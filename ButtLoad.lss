
ButtLoad.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000026  00800100  00003752  000037e6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003752  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b0  00800126  00800126  0000380c  2**0
                  ALLOC
  3 .noinit       00000000  008002d6  008002d6  0000380c  2**0
                  CONTENTS
  4 .eeprom       00000000  00810000  00810000  0000380c  2**0
                  CONTENTS
  5 .stab         00000084  00000000  00000000  0000380c  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      00000078  00000000  00000000  00003890  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000140  00000000  00000000  00003908  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000f8a  00000000  00000000  00003a48  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0000347e  00000000  00000000  000049d2  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00000e30  00000000  00000000  00007e50  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0000309b  00000000  00000000  00008c80  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000010f1  00000000  00000000  0000bd1b  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 08 02 	jmp	0x410 <__init>
       4:	0c 94 23 02 	jmp	0x446 <__bad_interrupt>
       8:	0c 94 24 1b 	jmp	0x3648 <__vector_2>
       c:	0c 94 8e 03 	jmp	0x71c <__vector_3>
      10:	0c 94 23 02 	jmp	0x446 <__bad_interrupt>
      14:	0c 94 83 07 	jmp	0xf06 <__vector_5>
      18:	0c 94 23 02 	jmp	0x446 <__bad_interrupt>
      1c:	0c 94 23 02 	jmp	0x446 <__bad_interrupt>
      20:	0c 94 23 02 	jmp	0x446 <__bad_interrupt>
      24:	0c 94 e0 0b 	jmp	0x17c0 <__vector_9>
      28:	0c 94 26 1b 	jmp	0x364c <__vector_10>
      2c:	0c 94 23 02 	jmp	0x446 <__bad_interrupt>
      30:	0c 94 23 02 	jmp	0x446 <__bad_interrupt>
      34:	0c 94 0a 09 	jmp	0x1214 <__vector_13>
      38:	0c 94 23 02 	jmp	0x446 <__bad_interrupt>
      3c:	0c 94 23 02 	jmp	0x446 <__bad_interrupt>
      40:	0c 94 23 02 	jmp	0x446 <__bad_interrupt>
      44:	0c 94 4f 09 	jmp	0x129e <__vector_17>
      48:	0c 94 23 02 	jmp	0x446 <__bad_interrupt>
      4c:	0c 94 23 02 	jmp	0x446 <__bad_interrupt>
      50:	0c 94 23 02 	jmp	0x446 <__bad_interrupt>
      54:	0c 94 23 02 	jmp	0x446 <__bad_interrupt>
      58:	0c 94 40 08 	jmp	0x1080 <__vector_22>

0000005c <SIFOOptionPtrs>:
      5c:	6f 00 60 00                                         o.`.

00000060 <SIFO_Tags>:
      60:	56 49 45 57 20 44 41 54 41 20 54 41 47 53 00        VIEW DATA TAGS.

0000006f <SIFO_Size>:
      6f:	53 54 4f 52 41 47 45 20 53 49 5a 45 53 00           STORAGE SIZES.

0000007d <USIPSNamePtrs>:
      7d:	a3 00 99 00 8f 00 85 00                             ........

00000085 <USI_Speed3>:
      85:	32 31 30 36 35 31 20 48 5a 00                       210651 HZ.

0000008f <USI_Speed2>:
      8f:	31 31 33 34 32 37 20 48 5a 00                       113427 HZ.

00000099 <USI_Speed1>:
      99:	20 38 36 37 33 38 20 48 5a 00                        86738 HZ.

000000a3 <USI_Speed0>:
      a3:	20 35 37 31 35 33 20 48 5a 00                        57153 HZ.

000000ad <ProgOptions>:
      ad:	16 01 0a 01 fa 00 ea 00 da 00 c6 00 bb 00           ..............

000000bb <PRG_C>:
      bb:	45 52 41 53 45 20 4f 4e 4c 59 00                    ERASE ONLY.

000000c6 <PRG_FL>:
      c6:	46 55 53 45 20 41 4e 44 20 4c 4f 43 4b 20 42 59     FUSE AND LOCK BY
      d6:	54 45 53 00                                         TES.

000000da <PRG_L>:
      da:	4c 4f 43 4b 20 42 59 54 45 53 20 4f 4e 4c 59 00     LOCK BYTES ONLY.

000000ea <PRG_F>:
      ea:	46 55 53 45 20 42 59 54 45 53 20 4f 4e 4c 59 00     FUSE BYTES ONLY.

000000fa <PRG_DE>:
      fa:	44 41 54 41 20 41 4e 44 20 45 45 50 52 4f 4d 00     DATA AND EEPROM.

0000010a <PRG_E>:
     10a:	45 45 50 52 4f 4d 20 4f 4e 4c 59 00                 EEPROM ONLY.

00000116 <PRG_D>:
     116:	44 41 54 41 20 4f 4e 4c 59 00                       DATA ONLY.

00000120 <SettingFunctionPtrs>:
     120:	31 06 7d 06 7b 05 d0 05 d7 05 24 07                 1.}.{.....$.

0000012c <SettingFunctionNames>:
     12c:	88 01 7a 01 6d 01 5e 01 4b 01 38 01                 ..z.m.^.K.8.

00000138 <SFunc_GOBOOTLOADER>:
     138:	4a 55 4d 50 20 54 4f 20 42 4f 4f 54 4c 4f 41 44     JUMP TO BOOTLOAD
     148:	45 52 00                                            ER.

0000014b <SFunc_MANCALIB>:
     14b:	4d 41 4e 55 41 4c 20 43 41 4c 49 42 52 41 54 49     MANUAL CALIBRATI
     15b:	4f 4e 00                                            ON.

0000015e <SFunc_AUTOCALIB>:
     15e:	41 55 54 4f 20 43 41 4c 49 42 52 41 54 45 00        AUTO CALIBRATE.

0000016d <SFunc_CLEARMEM>:
     16d:	43 4c 45 41 52 20 4d 45 4d 4f 52 59 00              CLEAR MEMORY.

0000017a <SFunc_SETSPISPEED>:
     17a:	53 45 54 20 53 50 49 20 53 50 45 45 44 00           SET SPI SPEED.

00000188 <SFunc_SETCONTRAST>:
     188:	53 45 54 20 43 4f 4e 54 52 41 53 54 00              SET CONTRAST.

00000195 <MainFunctionPtrs>:
     195:	df 03 55 05 10 04 ec 03 aa 03 b2 06                 ..U.........

000001a1 <MainFunctionNames>:
     1a1:	ec 01 e1 01 d5 01 c1 01 b8 01 ad 01                 ............

000001ad <Func_SLEEP>:
     1ad:	53 4c 45 45 50 20 4d 4f 44 45 00                    SLEEP MODE.

000001b8 <Func_SETTINGS>:
     1b8:	53 45 54 54 49 4e 47 53 00                          SETTINGS.

000001c1 <Func_PRGMDATAFLASH>:
     1c1:	44 41 54 41 46 4c 41 53 48 20 50 52 47 4d 20 4d     DATAFLASH PRGM M
     1d1:	4f 44 45 00                                         ODE.

000001d5 <Func_PRGMAVR>:
     1d5:	50 52 4f 47 52 41 4d 20 41 56 52 00                 PROGRAM AVR.

000001e1 <Func_STOREPRGM>:
     1e1:	53 54 4f 52 45 20 50 52 47 4d 00                    STORE PRGM.

000001ec <Func_ISPPRGM>:
     1ec:	41 56 52 49 53 50 20 4d 4f 44 45 00                 AVRISP MODE.

000001f8 <AboutTextPtrs>:
     1f8:	23 02 1e 02 0f 02 00 02                             #.......

00000200 <CopyRight>:
     200:	3c 43 3e 20 32 30 30 36 20 2d 20 47 50 4c 00        <C> 2006 - GPL.

0000020f <AuthorName>:
     20f:	42 59 20 44 45 41 4e 20 43 41 4d 45 52 41 00        BY DEAN CAMERA.

0000021e <VersionInfo>:
     21e:	56 31 2d 33 00                                      V1-3.

00000223 <ProgrammerName>:
     223:	42 55 54 54 4c 4f 41 44 00                          BUTTLOAD.

0000022c <WaitText>:
     22c:	2a 57 41 49 54 2a 00                                *WAIT*.

00000233 <BUTTTAG_Author>:
     233:	40 28 23 29 42 59 20 44 45 41 4e 20 43 41 4d 45     @(#)BY DEAN CAME
     243:	52 41 00                                            RA.

00000246 <BUTTTAG_Name>:
     246:	40 28 23 29 42 55 54 54 4c 4f 41 44 20 41 56 52     @(#)BUTTLOAD AVR
     256:	49 53 50 00                                         ISP.

0000025a <__c.14>:
     25a:	50 52 47 3e 20 00                                   PRG> .

00000260 <__c.13>:
     260:	42 41 44 49 53 52 00                                BADISR.

00000267 <__c.6>:
     267:	4e 4f 20 45 52 41 53 45 20 43 4d 44 00              NO ERASE CMD.

00000274 <__c.7>:
     274:	4e 4f 20 44 41 54 41 00                             NO DATA.

0000027c <__c.8>:
     27c:	4e 4f 20 45 45 50 52 4f 4d 00                       NO EEPROM.

00000286 <__c.9>:
     286:	4e 4f 20 46 55 53 45 20 42 59 54 45 53 00           NO FUSE BYTES.

00000294 <__c.10>:
     294:	4e 4f 20 4c 4f 43 4b 20 42 59 54 45 53 00           NO LOCK BYTES.

000002a2 <__c.11>:
     2a2:	50 52 4f 47 52 41 4d 4d 49 4e 47 20 44 4f 4e 45     PROGRAMMING DONE
	...

000002b3 <__c.12>:
     2b3:	46 41 49 4c 45 44 00                                FAILED.

000002ba <__c.5>:
     2ba:	2a 53 54 4f 52 41 47 45 20 4d 4f 44 45 2a 00        *STORAGE MODE*.

000002c9 <__c.2>:
     2c9:	43 4f 4e 46 49 52 4d 00                             CONFIRM.

000002d1 <__c.3>:
     2d1:	3c 4e 20 59 3e 00                                   <N Y>.

000002d7 <__c.4>:
     2d7:	4d 45 4d 20 43 4c 45 41 52 45 44 00                 MEM CLEARED.

000002e3 <__c.1>:
     2e3:	4e 4f 20 53 54 4f 52 45 44 20 50 52 47 4d 00        NO STORED PRGM.

000002f2 <__c.0>:
     2f2:	2a 4a 54 41 47 20 4f 4e 2a 00                       *JTAG ON*.

000002fc <LCD_SegTable>:
     2fc:	a8 ea 80 2a 00 40 00 0a 51 0a 08 40 59 55 18 01     ...*.@..Q..@YU..
     30c:	11 1e 11 1b 50 0b 41 1b 41 1f 11 01 51 1f 51 1b     ....P.A.A...Q.Q.
     31c:	00 00 00 00 08 80 00 1a 20 40 00 00 00 00 51 0f     ........ @....Q.
     32c:	91 39 41 14 91 31 41 1e 41 0e 41 1d 50 0f 80 20     .9A..1A.A.A.P.. 
     33c:	10 15 48 86 40 14 78 05 70 85 51 15 51 0e 51 95     ..H.@.x.p.Q.Q.Q.
     34c:	51 8e 21 90 81 20 50 15 48 44 50 c5 28 c0 28 20     Q.!.. P.HDP.(.( 
     35c:	09 50 41 14 20 80 11 11 00 00 00 10                 .PA. .......

00000368 <USIPSValues>:
     368:	03 80 02 54 01 40 00 22                             ...T.@."

00000370 <DataFlashError>:
     370:	44 41 54 41 46 4c 41 53 48 20 45 52 52 4f 52 00     DATAFLASH ERROR.

00000380 <DF_Pages>:
     380:	f9 00 f1 01 e1 03 10 3e 84 0f 84 0f 08 1f 08 1f     .......>........

00000390 <DF_PageSize>:
     390:	08 01 08 01 08 01 08 01 08 01 10 02 10 02 20 04     .............. .

000003a0 <DF_PageBits>:
     3a0:	09 09 09 09 09 0a 0a 0b                             ........

000003a8 <__c.0>:
     3a8:	42 55 46 46 20 4f 56 45 52 46 4c 4f 57 00           BUFF OVERFLOW.

000003b6 <DataFlashProgMode>:
     3b6:	2a 44 41 54 41 46 4c 41 53 48 20 4d 4f 44 45 2a     *DATAFLASH MODE*
	...

000003c7 <SignonResponse>:
     3c7:	01 00 08 41 56 52 49 53 50 5f 32                    ...AVRISP_2

000003d2 <VersionData>:
     3d2:	02 02 04                                            ...

000003d5 <SyncErrorMessage>:
     3d5:	53 59 4e 43 20 45 52 52 4f 52 00                    SYNC ERROR.

000003e0 <AVRISPModeMessage>:
     3e0:	2a 41 54 41 56 52 49 53 50 20 4d 4f 44 45 2a 00     *ATAVRISP MODE*.

000003f0 <__c.0>:
     3f0:	44 41 54 41 2d 00                                   DATA-.

000003f6 <__c.1>:
     3f6:	45 50 52 4d 2d 00                                   EPRM-.

000003fc <__c.2>:
     3fc:	46 55 53 45 2d 00                                   FUSE-.

00000402 <__c.3>:
     402:	4c 4f 43 4b 2d 00                                   LOCK-.

00000408 <__c.0>:
     408:	4e 4f 20 54 41 47 53 00                             NO TAGS.

00000410 <__init>:
     410:	11 24       	eor	r1, r1
     412:	1f be       	out	0x3f, r1	; 63
     414:	cf ef       	ldi	r28, 0xFF	; 255
     416:	d4 e0       	ldi	r29, 0x04	; 4
     418:	de bf       	out	0x3e, r29	; 62
     41a:	cd bf       	out	0x3d, r28	; 61

0000041c <__do_copy_data>:
     41c:	11 e0       	ldi	r17, 0x01	; 1
     41e:	a0 e0       	ldi	r26, 0x00	; 0
     420:	b1 e0       	ldi	r27, 0x01	; 1
     422:	e2 e5       	ldi	r30, 0x52	; 82
     424:	f7 e3       	ldi	r31, 0x37	; 55
     426:	02 c0       	rjmp	.+4      	; 0x42c <.do_copy_data_start>

00000428 <.do_copy_data_loop>:
     428:	05 90       	lpm	r0, Z+
     42a:	0d 92       	st	X+, r0

0000042c <.do_copy_data_start>:
     42c:	a6 32       	cpi	r26, 0x26	; 38
     42e:	b1 07       	cpc	r27, r17
     430:	d9 f7       	brne	.-10     	; 0x428 <.do_copy_data_loop>

00000432 <__do_clear_bss>:
     432:	12 e0       	ldi	r17, 0x02	; 2
     434:	a6 e2       	ldi	r26, 0x26	; 38
     436:	b1 e0       	ldi	r27, 0x01	; 1
     438:	01 c0       	rjmp	.+2      	; 0x43c <.do_clear_bss_start>

0000043a <.do_clear_bss_loop>:
     43a:	1d 92       	st	X+, r1

0000043c <.do_clear_bss_start>:
     43c:	a6 3d       	cpi	r26, 0xD6	; 214
     43e:	b1 07       	cpc	r27, r17
     440:	e1 f7       	brne	.-8      	; 0x43a <.do_clear_bss_loop>
     442:	0c 94 69 02 	jmp	0x4d2 <main>

00000446 <__bad_interrupt>:
     446:	0c 94 a5 03 	jmp	0x74a <__vector_default>

0000044a <MAIN_Delay10MS>:

// ======================================================================================

void MAIN_Delay10MS(uint8_t loops)
{
     44a:	cf 93       	push	r28
     44c:	df 93       	push	r29
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     44e:	28 2f       	mov	r18, r24
     450:	21 50       	subi	r18, 0x01	; 1
     452:	2f 3f       	cpi	r18, 0xFF	; 255
     454:	49 f0       	breq	.+18     	; 0x468 <MAIN_Delay10MS+0x1e>
     456:	a0 e0       	ldi	r26, 0x00	; 0
     458:	b8 e4       	ldi	r27, 0x48	; 72
     45a:	c0 e0       	ldi	r28, 0x00	; 0
     45c:	d0 e0       	ldi	r29, 0x00	; 0
     45e:	cd 01       	movw	r24, r26
     460:	01 97       	sbiw	r24, 0x01	; 1
     462:	f1 f7       	brne	.-4      	; 0x460 <MAIN_Delay10MS+0x16>
     464:	21 50       	subi	r18, 0x01	; 1
     466:	d8 f7       	brcc	.-10     	; 0x45e <MAIN_Delay10MS+0x14>
     468:	df 91       	pop	r29
     46a:	cf 91       	pop	r28
     46c:	08 95       	ret

0000046e <MAIN_WaitForJoyRelease>:
  /* Prevents the use of floating point libraries. Delaying in groups of
     10ms increases accuracy by reducing the time overhead for each loop
     interation of the while.                                            */

	while (loops--)
	  _delay_ms(10);
}

void MAIN_Delay1MS(uint8_t loops)
{
  /* Prevents the use of floating point libraries. Less accurate than the
     Delay10MS routine, but nessesary for many commands. The overhead required
     to call the routine is substantially less than the overhead required to
     calculate the float at compile time, so this actually saves execution time. */

	while (loops--)
	  _delay_ms(1);
}

void MAIN_ResetCSLine(uint8_t ActiveInactive)
{
  /* ActiveInactive controls the /Reset line to an AVR device or external dataflash
     /CS line. If the reset polarity parameter is a 0 then interfacing with AT89
	 devices which has an active high reset. Pins are tristated when inactive.      */
	
	switch (ActiveInactive)
	{
		case MAIN_RESETCS_ACTIVE:   // The target RESET line may be either active high or low.
			DDRF |= (1 << 6);
		
			if (!(eeprom_read_byte_169(&Param_ResetPolarity))) // Translate to correct logic level for target device type
			  PORTF |=  (1 << 6);
			else
			  PORTF &= ~(1 << 6);
		
			break;
		case MAIN_RESETCS_DFACTIVE: // Dataflashes are always active low.
			DDRF  |=  (1 << 6);
			PORTF &= ~(1 << 6);
			
			break;
		case MAIN_RESETCS_INACTIVE: // Both modes tristate the pins when inactive.
			DDRF  &= ~(1 << 6);
			PORTF &= ~(1 << 6);
	}
}

void MAIN_WaitForJoyRelease(void)
{
	while (1)
	{
		while (JoyStatus) {};                   // Wait until joystick released
     46e:	8e b3       	in	r24, 0x1e	; 30
     470:	88 23       	and	r24, r24
     472:	e9 f7       	brne	.-6      	; 0x46e <MAIN_WaitForJoyRelease>

		MAIN_Delay10MS(1);
     474:	81 e0       	ldi	r24, 0x01	; 1
     476:	0e 94 25 02 	call	0x44a <MAIN_Delay10MS>

		if (!(JoyStatus))                       // Joystick still released (not bouncing), return
     47a:	8e b3       	in	r24, 0x1e	; 30
     47c:	88 23       	and	r24, r24
     47e:	b9 f7       	brne	.-18     	; 0x46e <MAIN_WaitForJoyRelease>
     480:	08 95       	ret

00000482 <FUNCShowAbout>:
		  return;
	}
}

void MAIN_IntToStr(uint16_t IntV, uint8_t* Buff)
{
	// Shows leading zeros, unlike itoa.

	uint8_t Temp = 0;
	
	while (IntV >= 100)
	{
		Temp++;
		IntV -= 100;
	}

	*(Buff++) = '0' + Temp;
	
	Temp = 0;
	
	while (IntV >= 10)
	{
		Temp++;
		IntV -= 10;
	}
		
	*(Buff++) = '0' + Temp;
	*(Buff++) = '0' + IntV;
	*(Buff)   = '\0';
}

void MAIN_ShowProgType(uint8_t Letter)
{
	uint8_t ProgTypeBuffer[7];

	strcpy_P(ProgTypeBuffer, PSTR("PRG> "));
	ProgTypeBuffer[5] = Letter;
	ProgTypeBuffer[6] = '\0';
	
	LCD_puts(ProgTypeBuffer);
}

void MAIN_ShowError(const uint8_t *pFlashStr)
{
	uint8_t ErrorBuff[LCD_TEXTBUFFER_SIZE];       // New buffer, LCD text buffer size
	
	ErrorBuff[0] = 'E';
	ErrorBuff[1] = '>';

	strcpy_P(&ErrorBuff[2], pFlashStr);       // WARNING: If error text is larger than (TEXTBUFFER_SIZE - 2),
	                                          // this will overflow the buffer and probably crash the micro!
	LCD_puts(ErrorBuff);
	
	MAIN_WaitForJoyRelease();
	while (!(JoyStatus & JOY_PRESS)) {};
	MAIN_WaitForJoyRelease();
}

// ======================================================================================

ISR(PCINT1_vect, ISR_NOBLOCK)                 // Joystick routine; PCINT0_vect is bound to this also via JoystickInterrupt.S
{
	JoyStatus = (~PINB & JOY_BMASK)
	          | (~PINE & JOY_EMASK);
}

ISR(BADISR_vect, ISR_NAKED)                   // Bad ISR routine; should never be called, here for safety
{
	MAIN_ShowError(PSTR("BADISR"));
	while (1) {};
}

// ======================================================================================

void FUNCChangeSettings(void)
{
	uint8_t CurrSFunc = 0;
	
	JoyStatus = 1;

	while (1)
	{
		if (JoyStatus)                         // Joystick is in the non-center position
		{
			if (JoyStatus & JOY_UP)            // Previous function
			  (CurrSFunc == 0)? CurrSFunc = 5 : CurrSFunc--;
			else if (JoyStatus & JOY_DOWN)     // Next function
			  (CurrSFunc == 5)? CurrSFunc = 0 : CurrSFunc++;
			else if (JoyStatus & JOY_PRESS)    // Select current function
			  ((FuncPtr)pgm_read_word(&SettingFunctionPtrs[CurrSFunc]))(); // Run associated function
			else if (JoyStatus & JOY_LEFT)
			  return;
		
			// Show current function onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&SettingFunctionNames[CurrSFunc]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCShowAbout(void)
{
     482:	cf 93       	push	r28
	uint8_t InfoNum = 0;
     484:	c0 e0       	ldi	r28, 0x00	; 0
	
	JoyStatus = 1;
     486:	81 e0       	ldi	r24, 0x01	; 1
     488:	8e bb       	out	0x1e, r24	; 30
			
	while (1)
	{
		if (JoyStatus)
     48a:	8e b3       	in	r24, 0x1e	; 30
     48c:	88 23       	and	r24, r24
     48e:	e9 f3       	breq	.-6      	; 0x48a <FUNCShowAbout+0x8>
		{
			if (JoyStatus & JOY_UP)
     490:	f6 9b       	sbis	0x1e, 6	; 30
     492:	06 c0       	rjmp	.+12     	; 0x4a0 <FUNCShowAbout+0x1e>
			  (InfoNum == 0)? InfoNum = 3 : InfoNum--;
     494:	cc 23       	and	r28, r28
     496:	11 f4       	brne	.+4      	; 0x49c <FUNCShowAbout+0x1a>
     498:	c3 e0       	ldi	r28, 0x03	; 3
     49a:	0c c0       	rjmp	.+24     	; 0x4b4 <FUNCShowAbout+0x32>
     49c:	c1 50       	subi	r28, 0x01	; 1
     49e:	0a c0       	rjmp	.+20     	; 0x4b4 <FUNCShowAbout+0x32>
			else if (JoyStatus & JOY_DOWN)
     4a0:	f7 9b       	sbis	0x1e, 7	; 30
     4a2:	06 c0       	rjmp	.+12     	; 0x4b0 <FUNCShowAbout+0x2e>
			  (InfoNum == 3)? InfoNum = 0 : InfoNum++;
     4a4:	c3 30       	cpi	r28, 0x03	; 3
     4a6:	11 f4       	brne	.+4      	; 0x4ac <FUNCShowAbout+0x2a>
     4a8:	c0 e0       	ldi	r28, 0x00	; 0
     4aa:	04 c0       	rjmp	.+8      	; 0x4b4 <FUNCShowAbout+0x32>
     4ac:	cf 5f       	subi	r28, 0xFF	; 255
     4ae:	02 c0       	rjmp	.+4      	; 0x4b4 <FUNCShowAbout+0x32>
			else if (JoyStatus & JOY_LEFT)
     4b0:	f2 99       	sbic	0x1e, 2	; 30
     4b2:	0d c0       	rjmp	.+26     	; 0x4ce <FUNCShowAbout+0x4c>
			  return;

			LCD_puts_f((uint8_t*)pgm_read_word(&AboutTextPtrs[InfoNum]));
     4b4:	ec 2f       	mov	r30, r28
     4b6:	ff 27       	eor	r31, r31
     4b8:	ee 0f       	add	r30, r30
     4ba:	ff 1f       	adc	r31, r31
     4bc:	e8 50       	subi	r30, 0x08	; 8
     4be:	fe 4f       	sbci	r31, 0xFE	; 254
     4c0:	85 91       	lpm	r24, Z+
     4c2:	94 91       	lpm	r25, Z
     4c4:	0e 94 f7 07 	call	0xfee <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     4c8:	0e 94 37 02 	call	0x46e <MAIN_WaitForJoyRelease>
     4cc:	de cf       	rjmp	.-68     	; 0x48a <FUNCShowAbout+0x8>
     4ce:	cf 91       	pop	r28
     4d0:	08 95       	ret

000004d2 <main>:
     4d2:	cd ef       	ldi	r28, 0xFD	; 253
     4d4:	d4 e0       	ldi	r29, 0x04	; 4
     4d6:	de bf       	out	0x3e, r29	; 62
     4d8:	cd bf       	out	0x3d, r28	; 61
     4da:	10 e0       	ldi	r17, 0x00	; 0
     4dc:	80 e8       	ldi	r24, 0x80	; 128
     4de:	85 bf       	out	0x35, r24	; 53
     4e0:	85 bf       	out	0x35, r24	; 53
     4e2:	80 bf       	out	0x30, r24	; 48
     4e4:	85 e0       	ldi	r24, 0x05	; 5
     4e6:	80 93 64 00 	sts	0x0064, r24
     4ea:	80 e3       	ldi	r24, 0x30	; 48
     4ec:	80 bb       	out	0x10, r24	; 16
     4ee:	87 e2       	ldi	r24, 0x27	; 39
     4f0:	84 b9       	out	0x04, r24	; 4
     4f2:	8f ed       	ldi	r24, 0xDF	; 223
     4f4:	85 b9       	out	0x05, r24	; 5
     4f6:	8c e0       	ldi	r24, 0x0C	; 12
     4f8:	8e b9       	out	0x0e, r24	; 14
     4fa:	80 93 6b 00 	sts	0x006B, r24
     4fe:	80 ed       	ldi	r24, 0xD0	; 208
     500:	80 93 6c 00 	sts	0x006C, r24
     504:	80 ec       	ldi	r24, 0xC0	; 192
     506:	8d bb       	out	0x1d, r24	; 29
     508:	8c bb       	out	0x1c, r24	; 28
     50a:	81 b3       	in	r24, 0x11	; 17
     50c:	8f 7c       	andi	r24, 0xCF	; 207
     50e:	80 62       	ori	r24, 0x20	; 32
     510:	81 bb       	out	0x11, r24	; 17
     512:	82 e0       	ldi	r24, 0x02	; 2
     514:	91 e0       	ldi	r25, 0x01	; 1
     516:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
     51a:	8a 37       	cpi	r24, 0x7A	; 122
     51c:	09 f1       	breq	.+66     	; 0x560 <__stack+0x61>
     51e:	20 e0       	ldi	r18, 0x00	; 0
     520:	30 e0       	ldi	r19, 0x00	; 0
     522:	3a 83       	std	Y+2, r19	; 0x02
     524:	29 83       	std	Y+1, r18	; 0x01
     526:	80 91 02 01 	lds	r24, 0x0102
     52a:	90 91 03 01 	lds	r25, 0x0103
     52e:	28 17       	cp	r18, r24
     530:	39 07       	cpc	r19, r25
     532:	88 f4       	brcc	.+34     	; 0x556 <__stack+0x57>
     534:	6f ef       	ldi	r22, 0xFF	; 255
     536:	ce 01       	movw	r24, r28
     538:	01 96       	adiw	r24, 0x01	; 1
     53a:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
     53e:	89 81       	ldd	r24, Y+1	; 0x01
     540:	9a 81       	ldd	r25, Y+2	; 0x02
     542:	01 96       	adiw	r24, 0x01	; 1
     544:	9a 83       	std	Y+2, r25	; 0x02
     546:	89 83       	std	Y+1, r24	; 0x01
     548:	20 91 02 01 	lds	r18, 0x0102
     54c:	30 91 03 01 	lds	r19, 0x0103
     550:	82 17       	cp	r24, r18
     552:	93 07       	cpc	r25, r19
     554:	78 f3       	brcs	.-34     	; 0x534 <__stack+0x35>
     556:	6a e7       	ldi	r22, 0x7A	; 122
     558:	82 e0       	ldi	r24, 0x02	; 2
     55a:	91 e0       	ldi	r25, 0x01	; 1
     55c:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
     560:	0e 94 a4 07 	call	0xf48 <LCD_Init>
     564:	84 e0       	ldi	r24, 0x04	; 4
     566:	91 e0       	ldi	r25, 0x01	; 1
     568:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
     56c:	8f 70       	andi	r24, 0x0F	; 15
     56e:	80 93 e7 00 	sts	0x00E7, r24
     572:	78 94       	sei
     574:	8c e2       	ldi	r24, 0x2C	; 44
     576:	92 e0       	ldi	r25, 0x02	; 2
     578:	0e 94 f7 07 	call	0xfee <LCD_puts_f>
     57c:	80 e0       	ldi	r24, 0x00	; 0
     57e:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
     582:	81 b3       	in	r24, 0x11	; 17
     584:	80 63       	ori	r24, 0x30	; 48
     586:	81 bb       	out	0x11, r24	; 17
     588:	0e 94 32 07 	call	0xe64 <OSCCAL_Calibrate>
     58c:	87 e0       	ldi	r24, 0x07	; 7
     58e:	90 e0       	ldi	r25, 0x00	; 0
     590:	0e 94 d4 08 	call	0x11a8 <USART_Init>
     594:	81 b3       	in	r24, 0x11	; 17
     596:	8f 7c       	andi	r24, 0xCF	; 207
     598:	80 61       	ori	r24, 0x10	; 16
     59a:	81 bb       	out	0x11, r24	; 17
     59c:	81 e0       	ldi	r24, 0x01	; 1
     59e:	8e bb       	out	0x1e, r24	; 30
     5a0:	8e b3       	in	r24, 0x1e	; 30
     5a2:	88 23       	and	r24, r24
     5a4:	e9 f3       	breq	.-6      	; 0x5a0 <__stack+0xa1>
     5a6:	f6 9b       	sbis	0x1e, 6	; 30
     5a8:	06 c0       	rjmp	.+12     	; 0x5b6 <__stack+0xb7>
     5aa:	11 23       	and	r17, r17
     5ac:	11 f4       	brne	.+4      	; 0x5b2 <__stack+0xb3>
     5ae:	15 e0       	ldi	r17, 0x05	; 5
     5b0:	1b c0       	rjmp	.+54     	; 0x5e8 <__stack+0xe9>
     5b2:	11 50       	subi	r17, 0x01	; 1
     5b4:	19 c0       	rjmp	.+50     	; 0x5e8 <__stack+0xe9>
     5b6:	f7 9b       	sbis	0x1e, 7	; 30
     5b8:	06 c0       	rjmp	.+12     	; 0x5c6 <__stack+0xc7>
     5ba:	15 30       	cpi	r17, 0x05	; 5
     5bc:	11 f4       	brne	.+4      	; 0x5c2 <__stack+0xc3>
     5be:	10 e0       	ldi	r17, 0x00	; 0
     5c0:	13 c0       	rjmp	.+38     	; 0x5e8 <__stack+0xe9>
     5c2:	1f 5f       	subi	r17, 0xFF	; 255
     5c4:	11 c0       	rjmp	.+34     	; 0x5e8 <__stack+0xe9>
     5c6:	f4 9b       	sbis	0x1e, 4	; 30
     5c8:	0b c0       	rjmp	.+22     	; 0x5e0 <__stack+0xe1>
     5ca:	e1 2f       	mov	r30, r17
     5cc:	ff 27       	eor	r31, r31
     5ce:	ee 0f       	add	r30, r30
     5d0:	ff 1f       	adc	r31, r31
     5d2:	eb 56       	subi	r30, 0x6B	; 107
     5d4:	fe 4f       	sbci	r31, 0xFE	; 254
     5d6:	85 91       	lpm	r24, Z+
     5d8:	94 91       	lpm	r25, Z
     5da:	fc 01       	movw	r30, r24
     5dc:	09 95       	icall
     5de:	04 c0       	rjmp	.+8      	; 0x5e8 <__stack+0xe9>
     5e0:	f3 9b       	sbis	0x1e, 3	; 30
     5e2:	02 c0       	rjmp	.+4      	; 0x5e8 <__stack+0xe9>
     5e4:	0e 94 41 02 	call	0x482 <FUNCShowAbout>
     5e8:	e1 2f       	mov	r30, r17
     5ea:	ff 27       	eor	r31, r31
     5ec:	ee 0f       	add	r30, r30
     5ee:	ff 1f       	adc	r31, r31
     5f0:	ef 55       	subi	r30, 0x5F	; 95
     5f2:	fe 4f       	sbci	r31, 0xFE	; 254
     5f4:	85 91       	lpm	r24, Z+
     5f6:	94 91       	lpm	r25, Z
     5f8:	0e 94 f7 07 	call	0xfee <LCD_puts_f>
     5fc:	0e 94 37 02 	call	0x46e <MAIN_WaitForJoyRelease>
     600:	cf cf       	rjmp	.-98     	; 0x5a0 <__stack+0xa1>

00000602 <MAIN_Delay1MS>:
     602:	cf 93       	push	r28
     604:	df 93       	push	r29
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     606:	28 2f       	mov	r18, r24
     608:	21 50       	subi	r18, 0x01	; 1
     60a:	2f 3f       	cpi	r18, 0xFF	; 255
     60c:	49 f0       	breq	.+18     	; 0x620 <MAIN_Delay1MS+0x1e>
     60e:	a3 e3       	ldi	r26, 0x33	; 51
     610:	b7 e0       	ldi	r27, 0x07	; 7
     612:	c0 e0       	ldi	r28, 0x00	; 0
     614:	d0 e0       	ldi	r29, 0x00	; 0
     616:	cd 01       	movw	r24, r26
     618:	01 97       	sbiw	r24, 0x01	; 1
     61a:	f1 f7       	brne	.-4      	; 0x618 <MAIN_Delay1MS+0x16>
     61c:	21 50       	subi	r18, 0x01	; 1
     61e:	d8 f7       	brcc	.-10     	; 0x616 <MAIN_Delay1MS+0x14>
     620:	df 91       	pop	r29
     622:	cf 91       	pop	r28
     624:	08 95       	ret

00000626 <MAIN_ResetCSLine>:
     626:	99 27       	eor	r25, r25
     628:	81 30       	cpi	r24, 0x01	; 1
     62a:	91 05       	cpc	r25, r1
     62c:	a9 f0       	breq	.+42     	; 0x658 <MAIN_ResetCSLine+0x32>
     62e:	82 30       	cpi	r24, 0x02	; 2
     630:	91 05       	cpc	r25, r1
     632:	1c f4       	brge	.+6      	; 0x63a <MAIN_ResetCSLine+0x14>
     634:	89 2b       	or	r24, r25
     636:	21 f0       	breq	.+8      	; 0x640 <MAIN_ResetCSLine+0x1a>
     638:	08 95       	ret
     63a:	02 97       	sbiw	r24, 0x02	; 2
     63c:	51 f0       	breq	.+20     	; 0x652 <MAIN_ResetCSLine+0x2c>
     63e:	08 95       	ret
     640:	86 9a       	sbi	0x10, 6	; 16
     642:	82 e2       	ldi	r24, 0x22	; 34
     644:	91 e0       	ldi	r25, 0x01	; 1
     646:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
     64a:	88 23       	and	r24, r24
     64c:	19 f4       	brne	.+6      	; 0x654 <MAIN_ResetCSLine+0x2e>
     64e:	8e 9a       	sbi	0x11, 6	; 17
     650:	08 95       	ret
     652:	86 9a       	sbi	0x10, 6	; 16
     654:	8e 98       	cbi	0x11, 6	; 17
     656:	08 95       	ret
     658:	86 98       	cbi	0x10, 6	; 16
     65a:	fc cf       	rjmp	.-8      	; 0x654 <MAIN_ResetCSLine+0x2e>

0000065c <MAIN_IntToStr>:
     65c:	fb 01       	movw	r30, r22
     65e:	20 e0       	ldi	r18, 0x00	; 0
     660:	84 36       	cpi	r24, 0x64	; 100
     662:	91 05       	cpc	r25, r1
     664:	20 f0       	brcs	.+8      	; 0x66e <MAIN_IntToStr+0x12>
     666:	2f 5f       	subi	r18, 0xFF	; 255
     668:	84 56       	subi	r24, 0x64	; 100
     66a:	90 40       	sbci	r25, 0x00	; 0
     66c:	f9 cf       	rjmp	.-14     	; 0x660 <MAIN_IntToStr+0x4>
     66e:	20 5d       	subi	r18, 0xD0	; 208
     670:	21 93       	st	Z+, r18
     672:	20 e0       	ldi	r18, 0x00	; 0
     674:	8a 30       	cpi	r24, 0x0A	; 10
     676:	91 05       	cpc	r25, r1
     678:	18 f0       	brcs	.+6      	; 0x680 <MAIN_IntToStr+0x24>
     67a:	2f 5f       	subi	r18, 0xFF	; 255
     67c:	0a 97       	sbiw	r24, 0x0a	; 10
     67e:	fa cf       	rjmp	.-12     	; 0x674 <MAIN_IntToStr+0x18>
     680:	20 5d       	subi	r18, 0xD0	; 208
     682:	21 93       	st	Z+, r18
     684:	80 5d       	subi	r24, 0xD0	; 208
     686:	81 93       	st	Z+, r24
     688:	10 82       	st	Z, r1
     68a:	08 95       	ret

0000068c <MAIN_ShowProgType>:
     68c:	1f 93       	push	r17
     68e:	cf 93       	push	r28
     690:	df 93       	push	r29
     692:	cd b7       	in	r28, 0x3d	; 61
     694:	de b7       	in	r29, 0x3e	; 62
     696:	27 97       	sbiw	r28, 0x07	; 7
     698:	0f b6       	in	r0, 0x3f	; 63
     69a:	f8 94       	cli
     69c:	de bf       	out	0x3e, r29	; 62
     69e:	0f be       	out	0x3f, r0	; 63
     6a0:	cd bf       	out	0x3d, r28	; 61
     6a2:	18 2f       	mov	r17, r24
     6a4:	6a e5       	ldi	r22, 0x5A	; 90
     6a6:	72 e0       	ldi	r23, 0x02	; 2
     6a8:	ce 01       	movw	r24, r28
     6aa:	01 96       	adiw	r24, 0x01	; 1
     6ac:	0e 94 2c 1b 	call	0x3658 <strcpy_P>
     6b0:	1e 83       	std	Y+6, r17	; 0x06
     6b2:	1f 82       	std	Y+7, r1	; 0x07
     6b4:	ce 01       	movw	r24, r28
     6b6:	01 96       	adiw	r24, 0x01	; 1
     6b8:	0e 94 b6 07 	call	0xf6c <LCD_puts>
     6bc:	27 96       	adiw	r28, 0x07	; 7
     6be:	0f b6       	in	r0, 0x3f	; 63
     6c0:	f8 94       	cli
     6c2:	de bf       	out	0x3e, r29	; 62
     6c4:	0f be       	out	0x3f, r0	; 63
     6c6:	cd bf       	out	0x3d, r28	; 61
     6c8:	df 91       	pop	r29
     6ca:	cf 91       	pop	r28
     6cc:	1f 91       	pop	r17
     6ce:	08 95       	ret

000006d0 <MAIN_ShowError>:
     6d0:	cf 93       	push	r28
     6d2:	df 93       	push	r29
     6d4:	cd b7       	in	r28, 0x3d	; 61
     6d6:	de b7       	in	r29, 0x3e	; 62
     6d8:	64 97       	sbiw	r28, 0x14	; 20
     6da:	0f b6       	in	r0, 0x3f	; 63
     6dc:	f8 94       	cli
     6de:	de bf       	out	0x3e, r29	; 62
     6e0:	0f be       	out	0x3f, r0	; 63
     6e2:	cd bf       	out	0x3d, r28	; 61
     6e4:	25 e4       	ldi	r18, 0x45	; 69
     6e6:	29 83       	std	Y+1, r18	; 0x01
     6e8:	2e e3       	ldi	r18, 0x3E	; 62
     6ea:	2a 83       	std	Y+2, r18	; 0x02
     6ec:	bc 01       	movw	r22, r24
     6ee:	ce 01       	movw	r24, r28
     6f0:	03 96       	adiw	r24, 0x03	; 3
     6f2:	0e 94 2c 1b 	call	0x3658 <strcpy_P>
     6f6:	ce 01       	movw	r24, r28
     6f8:	01 96       	adiw	r24, 0x01	; 1
     6fa:	0e 94 b6 07 	call	0xf6c <LCD_puts>
     6fe:	0e 94 37 02 	call	0x46e <MAIN_WaitForJoyRelease>
     702:	f4 9b       	sbis	0x1e, 4	; 30
     704:	fe cf       	rjmp	.-4      	; 0x702 <MAIN_ShowError+0x32>
     706:	0e 94 37 02 	call	0x46e <MAIN_WaitForJoyRelease>
     70a:	64 96       	adiw	r28, 0x14	; 20
     70c:	0f b6       	in	r0, 0x3f	; 63
     70e:	f8 94       	cli
     710:	de bf       	out	0x3e, r29	; 62
     712:	0f be       	out	0x3f, r0	; 63
     714:	cd bf       	out	0x3d, r28	; 61
     716:	df 91       	pop	r29
     718:	cf 91       	pop	r28
     71a:	08 95       	ret

0000071c <__vector_3>:
     71c:	78 94       	sei
     71e:	1f 92       	push	r1
     720:	0f 92       	push	r0
     722:	0f b6       	in	r0, 0x3f	; 63
     724:	0f 92       	push	r0
     726:	11 24       	eor	r1, r1
     728:	8f 93       	push	r24
     72a:	9f 93       	push	r25
     72c:	93 b1       	in	r25, 0x03	; 3
     72e:	90 95       	com	r25
     730:	90 7d       	andi	r25, 0xD0	; 208
     732:	8c b1       	in	r24, 0x0c	; 12
     734:	80 95       	com	r24
     736:	8c 70       	andi	r24, 0x0C	; 12
     738:	98 2b       	or	r25, r24
     73a:	9e bb       	out	0x1e, r25	; 30
     73c:	9f 91       	pop	r25
     73e:	8f 91       	pop	r24
     740:	0f 90       	pop	r0
     742:	0f be       	out	0x3f, r0	; 63
     744:	0f 90       	pop	r0
     746:	1f 90       	pop	r1
     748:	18 95       	reti

0000074a <__vector_default>:
     74a:	80 e6       	ldi	r24, 0x60	; 96
     74c:	92 e0       	ldi	r25, 0x02	; 2
     74e:	0e 94 68 03 	call	0x6d0 <MAIN_ShowError>
     752:	ff cf       	rjmp	.-2      	; 0x752 <__vector_default+0x8>

00000754 <FUNCChangeSettings>:
     754:	cf 93       	push	r28
     756:	c0 e0       	ldi	r28, 0x00	; 0
     758:	81 e0       	ldi	r24, 0x01	; 1
     75a:	8e bb       	out	0x1e, r24	; 30
     75c:	8e b3       	in	r24, 0x1e	; 30
     75e:	88 23       	and	r24, r24
     760:	e9 f3       	breq	.-6      	; 0x75c <FUNCChangeSettings+0x8>
     762:	f6 9b       	sbis	0x1e, 6	; 30
     764:	06 c0       	rjmp	.+12     	; 0x772 <FUNCChangeSettings+0x1e>
     766:	cc 23       	and	r28, r28
     768:	11 f4       	brne	.+4      	; 0x76e <FUNCChangeSettings+0x1a>
     76a:	c5 e0       	ldi	r28, 0x05	; 5
     76c:	19 c0       	rjmp	.+50     	; 0x7a0 <FUNCChangeSettings+0x4c>
     76e:	c1 50       	subi	r28, 0x01	; 1
     770:	17 c0       	rjmp	.+46     	; 0x7a0 <FUNCChangeSettings+0x4c>
     772:	f7 9b       	sbis	0x1e, 7	; 30
     774:	06 c0       	rjmp	.+12     	; 0x782 <FUNCChangeSettings+0x2e>
     776:	c5 30       	cpi	r28, 0x05	; 5
     778:	11 f4       	brne	.+4      	; 0x77e <FUNCChangeSettings+0x2a>
     77a:	c0 e0       	ldi	r28, 0x00	; 0
     77c:	11 c0       	rjmp	.+34     	; 0x7a0 <FUNCChangeSettings+0x4c>
     77e:	cf 5f       	subi	r28, 0xFF	; 255
     780:	0f c0       	rjmp	.+30     	; 0x7a0 <FUNCChangeSettings+0x4c>
     782:	f4 9b       	sbis	0x1e, 4	; 30
     784:	0b c0       	rjmp	.+22     	; 0x79c <FUNCChangeSettings+0x48>
     786:	ec 2f       	mov	r30, r28
     788:	ff 27       	eor	r31, r31
     78a:	ee 0f       	add	r30, r30
     78c:	ff 1f       	adc	r31, r31
     78e:	e0 5e       	subi	r30, 0xE0	; 224
     790:	fe 4f       	sbci	r31, 0xFE	; 254
     792:	85 91       	lpm	r24, Z+
     794:	94 91       	lpm	r25, Z
     796:	fc 01       	movw	r30, r24
     798:	09 95       	icall
     79a:	02 c0       	rjmp	.+4      	; 0x7a0 <FUNCChangeSettings+0x4c>
     79c:	f2 99       	sbic	0x1e, 2	; 30
     79e:	0d c0       	rjmp	.+26     	; 0x7ba <FUNCChangeSettings+0x66>
     7a0:	ec 2f       	mov	r30, r28
     7a2:	ff 27       	eor	r31, r31
     7a4:	ee 0f       	add	r30, r30
     7a6:	ff 1f       	adc	r31, r31
     7a8:	e4 5d       	subi	r30, 0xD4	; 212
     7aa:	fe 4f       	sbci	r31, 0xFE	; 254
     7ac:	85 91       	lpm	r24, Z+
     7ae:	94 91       	lpm	r25, Z
     7b0:	0e 94 f7 07 	call	0xfee <LCD_puts_f>
     7b4:	0e 94 37 02 	call	0x46e <MAIN_WaitForJoyRelease>
     7b8:	d1 cf       	rjmp	.-94     	; 0x75c <FUNCChangeSettings+0x8>
     7ba:	cf 91       	pop	r28
     7bc:	08 95       	ret

000007be <FUNCAVRISPMode>:
		}
	}
}

void FUNCAVRISPMode(void)
{
	LCD_puts_f(AVRISPModeMessage);
     7be:	80 ee       	ldi	r24, 0xE0	; 224
     7c0:	93 e0       	ldi	r25, 0x03	; 3
     7c2:	0e 94 f7 07 	call	0xfee <LCD_puts_f>
	
	InterpretPacketRoutine = (FuncPtr)AICI_InterpretPacket;
     7c6:	84 e0       	ldi	r24, 0x04	; 4
     7c8:	92 e1       	ldi	r25, 0x12	; 18
     7ca:	90 93 25 01 	sts	0x0125, r25
     7ce:	80 93 24 01 	sts	0x0124, r24
	V2P_RunStateMachine();
     7d2:	0e 94 14 0f 	call	0x1e28 <V2P_RunStateMachine>
     7d6:	08 95       	ret

000007d8 <FUNCProgramDataflash>:
}

void FUNCProgramDataflash(void)
{
	USI_SPIInitMaster(eeprom_read_byte_169(&Param_SCKDuration));
     7d8:	80 e2       	ldi	r24, 0x20	; 32
     7da:	91 e0       	ldi	r25, 0x01	; 1
     7dc:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
     7e0:	0e 94 85 09 	call	0x130a <USI_SPIInitMaster>
	UseExernalDF = TRUE;
     7e4:	81 e0       	ldi	r24, 0x01	; 1
     7e6:	80 93 83 02 	sts	0x0283, r24
	DFSPIRoutinePointer = USI_SPITransmit;
     7ea:	8f e9       	ldi	r24, 0x9F	; 159
     7ec:	99 e0       	ldi	r25, 0x09	; 9
     7ee:	90 93 01 01 	sts	0x0101, r25
     7f2:	80 93 00 01 	sts	0x0100, r24
	
	LCD_puts_f(DataFlashProgMode);
     7f6:	86 eb       	ldi	r24, 0xB6	; 182
     7f8:	93 e0       	ldi	r25, 0x03	; 3
     7fa:	0e 94 f7 07 	call	0xfee <LCD_puts_f>

	InterpretPacketRoutine = PD_InterpretAVRISPPacket;
     7fe:	88 e6       	ldi	r24, 0x68	; 104
     800:	9c e0       	ldi	r25, 0x0C	; 12
     802:	90 93 25 01 	sts	0x0125, r25
     806:	80 93 24 01 	sts	0x0124, r24
	V2P_RunStateMachine();
     80a:	0e 94 14 0f 	call	0x1e28 <V2P_RunStateMachine>
	   
	DF_EnableDataflash(FALSE);
     80e:	80 e0       	ldi	r24, 0x00	; 0
     810:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
	SPI_SPIOFF();
     814:	80 91 64 00 	lds	r24, 0x0064
     818:	84 60       	ori	r24, 0x04	; 4
     81a:	80 93 64 00 	sts	0x0064, r24
     81e:	08 95       	ret

00000820 <FUNCProgramAVR>:
}

void FUNCProgramAVR(void)
{
     820:	df 92       	push	r13
     822:	ef 92       	push	r14
     824:	ff 92       	push	r15
     826:	0f 93       	push	r16
     828:	1f 93       	push	r17
     82a:	cf 93       	push	r28
     82c:	df 93       	push	r29
     82e:	cd b7       	in	r28, 0x3d	; 61
     830:	de b7       	in	r29, 0x3e	; 62
     832:	65 97       	sbiw	r28, 0x15	; 21
     834:	0f b6       	in	r0, 0x3f	; 63
     836:	f8 94       	cli
     838:	de bf       	out	0x3e, r29	; 62
     83a:	0f be       	out	0x3f, r0	; 63
     83c:	cd bf       	out	0x3d, r28	; 61
	uint8_t  DoneFailMessageBuff[19];
	uint16_t EEPROMAddress;
	uint8_t  Fault = ISPCC_NO_FAULT;
     83e:	dd 24       	eor	r13, r13
	uint8_t  ProgMode = 0;
     840:	0d 2d       	mov	r16, r13

	SPI_SPIInit();
     842:	0e 94 30 09 	call	0x1260 <SPI_SPIInit>
	UseExernalDF = FALSE;
     846:	d0 92 83 02 	sts	0x0283, r13
	DFSPIRoutinePointer = SPI_SPITransmit;
     84a:	8a e3       	ldi	r24, 0x3A	; 58
     84c:	99 e0       	ldi	r25, 0x09	; 9
     84e:	90 93 01 01 	sts	0x0101, r25
     852:	80 93 00 01 	sts	0x0100, r24
	
	if (!(DF_CheckCorrectOnboardChip()))
     856:	0e 94 73 0b 	call	0x16e6 <DF_CheckCorrectOnboardChip>
     85a:	88 23       	and	r24, r24
     85c:	09 f4       	brne	.+2      	; 0x860 <FUNCProgramAVR+0x40>
     85e:	17 c1       	rjmp	.+558    	; 0xa8e <FUNCProgramAVR+0x26e>
	  return;

	MAIN_WaitForJoyRelease();
     860:	0e 94 37 02 	call	0x46e <MAIN_WaitForJoyRelease>
	
	JoyStatus = 1;                            // Use an invalid joystick value to force the program to write the
     864:	81 e0       	ldi	r24, 0x01	; 1
     866:	8e bb       	out	0x1e, r24	; 30
	                                          // name of the default command onto the LCD
	while (1)
	{
		if (JoyStatus)
     868:	8e b3       	in	r24, 0x1e	; 30
     86a:	88 23       	and	r24, r24
     86c:	e9 f3       	breq	.-6      	; 0x868 <FUNCProgramAVR+0x48>
		{
			if (JoyStatus & JOY_LEFT)
     86e:	f2 99       	sbic	0x1e, 2	; 30
     870:	0e c1       	rjmp	.+540    	; 0xa8e <FUNCProgramAVR+0x26e>
			  return;
			else if (JoyStatus & JOY_PRESS)
     872:	f4 99       	sbic	0x1e, 4	; 30
     874:	1c c0       	rjmp	.+56     	; 0x8ae <FUNCProgramAVR+0x8e>
			  break;
			else if (JoyStatus & JOY_UP)
     876:	f6 9b       	sbis	0x1e, 6	; 30
     878:	06 c0       	rjmp	.+12     	; 0x886 <FUNCProgramAVR+0x66>
			  (ProgMode == 0)? ProgMode = 6 : ProgMode--;
     87a:	00 23       	and	r16, r16
     87c:	11 f4       	brne	.+4      	; 0x882 <FUNCProgramAVR+0x62>
     87e:	06 e0       	ldi	r16, 0x06	; 6
     880:	09 c0       	rjmp	.+18     	; 0x894 <FUNCProgramAVR+0x74>
     882:	01 50       	subi	r16, 0x01	; 1
     884:	07 c0       	rjmp	.+14     	; 0x894 <FUNCProgramAVR+0x74>
			else if (JoyStatus & JOY_DOWN)
     886:	f7 9b       	sbis	0x1e, 7	; 30
     888:	05 c0       	rjmp	.+10     	; 0x894 <FUNCProgramAVR+0x74>
			  (ProgMode == 6)? ProgMode = 0 : ProgMode++;
     88a:	06 30       	cpi	r16, 0x06	; 6
     88c:	11 f4       	brne	.+4      	; 0x892 <FUNCProgramAVR+0x72>
     88e:	00 e0       	ldi	r16, 0x00	; 0
     890:	01 c0       	rjmp	.+2      	; 0x894 <FUNCProgramAVR+0x74>
     892:	0f 5f       	subi	r16, 0xFF	; 255

			LCD_puts_f((uint8_t*)pgm_read_word(&ProgOptions[ProgMode])); // Show current function onto the LCD
     894:	e0 2f       	mov	r30, r16
     896:	ff 27       	eor	r31, r31
     898:	ee 0f       	add	r30, r30
     89a:	ff 1f       	adc	r31, r31
     89c:	e3 55       	subi	r30, 0x53	; 83
     89e:	ff 4f       	sbci	r31, 0xFF	; 255
     8a0:	85 91       	lpm	r24, Z+
     8a2:	94 91       	lpm	r25, Z
     8a4:	0e 94 f7 07 	call	0xfee <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     8a8:	0e 94 37 02 	call	0x46e <MAIN_WaitForJoyRelease>
     8ac:	dd cf       	rjmp	.-70     	; 0x868 <FUNCProgramAVR+0x48>
		}
	}

	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);                // Orange = busy
     8ae:	81 b3       	in	r24, 0x11	; 17
     8b0:	80 63       	ori	r24, 0x30	; 48
     8b2:	81 bb       	out	0x11, r24	; 17
	LCD_puts_f(WaitText);
     8b4:	8c e2       	ldi	r24, 0x2C	; 44
     8b6:	92 e0       	ldi	r25, 0x02	; 2
     8b8:	0e 94 f7 07 	call	0xfee <LCD_puts_f>

	USI_SPIInitMaster(eeprom_read_byte_169(&Param_SCKDuration));
     8bc:	80 e2       	ldi	r24, 0x20	; 32
     8be:	91 e0       	ldi	r25, 0x01	; 1
     8c0:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
     8c4:	0e 94 85 09 	call	0x130a <USI_SPIInitMaster>
	MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE); // Capture the RESET line of the slave AVR
     8c8:	80 e0       	ldi	r24, 0x00	; 0
     8ca:	0e 94 13 03 	call	0x626 <MAIN_ResetCSLine>

	EEPROMAddress = Prog_EnterProgMode;
     8ce:	80 91 12 01 	lds	r24, 0x0112
     8d2:	90 91 13 01 	lds	r25, 0x0113
     8d6:	9d 8b       	std	Y+21, r25	; 0x15
     8d8:	8c 8b       	std	Y+20, r24	; 0x14
     8da:	54 e3       	ldi	r21, 0x34	; 52
     8dc:	e5 2e       	mov	r14, r21
     8de:	51 e0       	ldi	r21, 0x01	; 1
     8e0:	f5 2e       	mov	r15, r21
     8e2:	1b e0       	ldi	r17, 0x0B	; 11
			
	for (uint8_t PacketB = 0; PacketB <= 11; PacketB++) // Read the enter programming mode command bytes
	{
		PacketBytes[PacketB] = eeprom_read_byte_169(&EEPROMAddress);
     8e4:	ce 01       	movw	r24, r28
     8e6:	44 96       	adiw	r24, 0x14	; 20
     8e8:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
     8ec:	f7 01       	movw	r30, r14
     8ee:	81 93       	st	Z+, r24
     8f0:	7f 01       	movw	r14, r30
		EEPROMAddress++;
     8f2:	8c 89       	ldd	r24, Y+20	; 0x14
     8f4:	9d 89       	ldd	r25, Y+21	; 0x15
     8f6:	01 96       	adiw	r24, 0x01	; 1
     8f8:	9d 8b       	std	Y+21, r25	; 0x15
     8fa:	8c 8b       	std	Y+20, r24	; 0x14
     8fc:	11 50       	subi	r17, 0x01	; 1
     8fe:	17 ff       	sbrs	r17, 7
     900:	f1 cf       	rjmp	.-30     	; 0x8e4 <FUNCProgramAVR+0xc4>
	}
	
	ISPCC_EnterChipProgrammingMode();    // Try to sync with the slave AVR
     902:	0e 94 74 10 	call	0x20e8 <ISPCC_EnterChipProgrammingMode>

	CurrAddress = 0;
     906:	10 92 2b 01 	sts	0x012B, r1
     90a:	10 92 2c 01 	sts	0x012C, r1
     90e:	10 92 2d 01 	sts	0x012D, r1
     912:	10 92 2e 01 	sts	0x012E, r1

	if (PacketBytes[1] == STATUS_CMD_OK) // ISPCC_EnterChipProgrammingMode alters the PacketBytes buffer rather than returning a value
     916:	80 91 35 01 	lds	r24, 0x0135
     91a:	88 23       	and	r24, r24
     91c:	09 f0       	breq	.+2      	; 0x920 <FUNCProgramAVR+0x100>
     91e:	a2 c0       	rjmp	.+324    	; 0xa64 <FUNCProgramAVR+0x244>
	{						
		if ((ProgMode == 6) || (ProgMode == 0) || (ProgMode == 2)) // Erase chip, or program flash mode
     920:	06 30       	cpi	r16, 0x06	; 6
     922:	21 f0       	breq	.+8      	; 0x92c <FUNCProgramAVR+0x10c>
     924:	00 23       	and	r16, r16
     926:	11 f0       	breq	.+4      	; 0x92c <FUNCProgramAVR+0x10c>
     928:	02 30       	cpi	r16, 0x02	; 2
     92a:	91 f4       	brne	.+36     	; 0x950 <FUNCProgramAVR+0x130>
		{
			MAIN_ShowProgType('C');
     92c:	83 e4       	ldi	r24, 0x43	; 67
     92e:	0e 94 46 03 	call	0x68c <MAIN_ShowProgType>
			
			if (!(eeprom_read_byte_169(&Prog_EraseCmdStored) == TRUE))
     932:	8a e1       	ldi	r24, 0x1A	; 26
     934:	91 e0       	ldi	r25, 0x01	; 1
     936:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
     93a:	81 30       	cpi	r24, 0x01	; 1
     93c:	39 f0       	breq	.+14     	; 0x94c <FUNCProgramAVR+0x12c>
			{
				Fault = ISPCC_FAULT_NOERASE;
     93e:	42 e0       	ldi	r20, 0x02	; 2
     940:	d4 2e       	mov	r13, r20
				MAIN_ShowError(PSTR("NO ERASE CMD"));
     942:	87 e6       	ldi	r24, 0x67	; 103
     944:	92 e0       	ldi	r25, 0x02	; 2
     946:	0e 94 68 03 	call	0x6d0 <MAIN_ShowError>
     94a:	02 c0       	rjmp	.+4      	; 0x950 <FUNCProgramAVR+0x130>
			}
			else
			{
				PM_SendEraseCommand();
     94c:	0e 94 2d 18 	call	0x305a <PM_SendEraseCommand>
			}
		}

		if (((ProgMode == 0) || (ProgMode == 2)) && (Fault == ISPCC_NO_FAULT)) // Program flash
     950:	00 23       	and	r16, r16
     952:	11 f0       	breq	.+4      	; 0x958 <FUNCProgramAVR+0x138>
     954:	02 30       	cpi	r16, 0x02	; 2
     956:	c1 f4       	brne	.+48     	; 0x988 <FUNCProgramAVR+0x168>
     958:	dd 20       	and	r13, r13
     95a:	b1 f4       	brne	.+44     	; 0x988 <FUNCProgramAVR+0x168>
		{
			MAIN_ShowProgType('D');
     95c:	84 e4       	ldi	r24, 0x44	; 68
     95e:	0e 94 46 03 	call	0x68c <MAIN_ShowProgType>

			if (!(PM_GetStoredDataSize(TYPE_FLASH))) // Check to make sure a program is present in memory
     962:	81 e0       	ldi	r24, 0x01	; 1
     964:	0e 94 73 13 	call	0x26e6 <PM_GetStoredDataSize>
     968:	dc 01       	movw	r26, r24
     96a:	cb 01       	movw	r24, r22
     96c:	00 97       	sbiw	r24, 0x00	; 0
     96e:	a1 05       	cpc	r26, r1
     970:	b1 05       	cpc	r27, r1
     972:	39 f4       	brne	.+14     	; 0x982 <FUNCProgramAVR+0x162>
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
     974:	33 e0       	ldi	r19, 0x03	; 3
     976:	d3 2e       	mov	r13, r19
				MAIN_ShowError(PSTR("NO DATA"));
     978:	84 e7       	ldi	r24, 0x74	; 116
     97a:	92 e0       	ldi	r25, 0x02	; 2
     97c:	0e 94 68 03 	call	0x6d0 <MAIN_ShowError>
     980:	03 c0       	rjmp	.+6      	; 0x988 <FUNCProgramAVR+0x168>
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_FLASH);
     982:	81 e0       	ldi	r24, 0x01	; 1
     984:	0e 94 7d 18 	call	0x30fa <PM_CreateProgrammingPackets>
			}
		}
	
		if ((ProgMode == 1) || (ProgMode == 2)) // Program EEPROM
     988:	80 2f       	mov	r24, r16
     98a:	81 50       	subi	r24, 0x01	; 1
     98c:	82 30       	cpi	r24, 0x02	; 2
     98e:	b0 f4       	brcc	.+44     	; 0x9bc <FUNCProgramAVR+0x19c>
		{
			MAIN_ShowProgType('E');
     990:	85 e4       	ldi	r24, 0x45	; 69
     992:	0e 94 46 03 	call	0x68c <MAIN_ShowProgType>
				
			if (!(PM_GetStoredDataSize(TYPE_EEPROM))) // Check to make sure EEPROM data is present in memory
     996:	80 e0       	ldi	r24, 0x00	; 0
     998:	0e 94 73 13 	call	0x26e6 <PM_GetStoredDataSize>
     99c:	dc 01       	movw	r26, r24
     99e:	cb 01       	movw	r24, r22
     9a0:	00 97       	sbiw	r24, 0x00	; 0
     9a2:	a1 05       	cpc	r26, r1
     9a4:	b1 05       	cpc	r27, r1
     9a6:	39 f4       	brne	.+14     	; 0x9b6 <FUNCProgramAVR+0x196>
			{
				Fault = ISPCC_FAULT_NODATATYPE;
     9a8:	23 e0       	ldi	r18, 0x03	; 3
     9aa:	d2 2e       	mov	r13, r18
				MAIN_ShowError(PSTR("NO EEPROM"));
     9ac:	8c e7       	ldi	r24, 0x7C	; 124
     9ae:	92 e0       	ldi	r25, 0x02	; 2
     9b0:	0e 94 68 03 	call	0x6d0 <MAIN_ShowError>
     9b4:	03 c0       	rjmp	.+6      	; 0x9bc <FUNCProgramAVR+0x19c>
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_EEPROM);
     9b6:	80 e0       	ldi	r24, 0x00	; 0
     9b8:	0e 94 7d 18 	call	0x30fa <PM_CreateProgrammingPackets>
			}
		}

		if ((ProgMode == 3) || (ProgMode == 5)) // Program Fuse bytes
     9bc:	03 30       	cpi	r16, 0x03	; 3
     9be:	11 f0       	breq	.+4      	; 0x9c4 <FUNCProgramAVR+0x1a4>
     9c0:	05 30       	cpi	r16, 0x05	; 5
     9c2:	99 f4       	brne	.+38     	; 0x9ea <FUNCProgramAVR+0x1ca>
		{
			MAIN_ShowProgType('F');
     9c4:	86 e4       	ldi	r24, 0x46	; 70
     9c6:	0e 94 46 03 	call	0x68c <MAIN_ShowProgType>
			
			if (!(eeprom_read_byte_169(&Prog_TotalFuseBytes)))
     9ca:	80 e1       	ldi	r24, 0x10	; 16
     9cc:	91 e0       	ldi	r25, 0x01	; 1
     9ce:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
     9d2:	88 23       	and	r24, r24
     9d4:	39 f4       	brne	.+14     	; 0x9e4 <FUNCProgramAVR+0x1c4>
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
     9d6:	93 e0       	ldi	r25, 0x03	; 3
     9d8:	d9 2e       	mov	r13, r25
				MAIN_ShowError(PSTR("NO FUSE BYTES"));
     9da:	86 e8       	ldi	r24, 0x86	; 134
     9dc:	92 e0       	ldi	r25, 0x02	; 2
     9de:	0e 94 68 03 	call	0x6d0 <MAIN_ShowError>
     9e2:	03 c0       	rjmp	.+6      	; 0x9ea <FUNCProgramAVR+0x1ca>
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_FUSE);
     9e4:	82 e0       	ldi	r24, 0x02	; 2
     9e6:	0e 94 dd 17 	call	0x2fba <PM_SendFuseLockBytes>
			}
		}

		if ((ProgMode == 4) || (ProgMode == 5)) // Program Lock bytes
     9ea:	80 2f       	mov	r24, r16
     9ec:	84 50       	subi	r24, 0x04	; 4
     9ee:	82 30       	cpi	r24, 0x02	; 2
     9f0:	00 f5       	brcc	.+64     	; 0xa32 <FUNCProgramAVR+0x212>
		{
			if (ProgMode == 5)                    // If fusebytes have already been written, we need to reenter programming mode to latch them
     9f2:	05 30       	cpi	r16, 0x05	; 5
     9f4:	59 f4       	brne	.+22     	; 0xa0c <FUNCProgramAVR+0x1ec>
			{
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line of the slave AVR
     9f6:	81 e0       	ldi	r24, 0x01	; 1
     9f8:	0e 94 13 03 	call	0x626 <MAIN_ResetCSLine>
				MAIN_Delay10MS(1);
     9fc:	81 e0       	ldi	r24, 0x01	; 1
     9fe:	0e 94 25 02 	call	0x44a <MAIN_Delay10MS>
				MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE); // Capture the RESET line of the slave AVR
     a02:	80 e0       	ldi	r24, 0x00	; 0
     a04:	0e 94 13 03 	call	0x626 <MAIN_ResetCSLine>
				ISPCC_EnterChipProgrammingMode(); // Try to sync with the slave AVR
     a08:	0e 94 74 10 	call	0x20e8 <ISPCC_EnterChipProgrammingMode>
			}

			MAIN_ShowProgType('L');
     a0c:	8c e4       	ldi	r24, 0x4C	; 76
     a0e:	0e 94 46 03 	call	0x68c <MAIN_ShowProgType>
		
			if (!(eeprom_read_byte_169(&Prog_TotalLockBytes)))
     a12:	8e e0       	ldi	r24, 0x0E	; 14
     a14:	91 e0       	ldi	r25, 0x01	; 1
     a16:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
     a1a:	88 23       	and	r24, r24
     a1c:	39 f4       	brne	.+14     	; 0xa2c <FUNCProgramAVR+0x20c>
			{
				Fault = ISPCC_FAULT_NODATATYPE;
     a1e:	83 e0       	ldi	r24, 0x03	; 3
     a20:	d8 2e       	mov	r13, r24
				MAIN_ShowError(PSTR("NO LOCK BYTES"));
     a22:	84 e9       	ldi	r24, 0x94	; 148
     a24:	92 e0       	ldi	r25, 0x02	; 2
     a26:	0e 94 68 03 	call	0x6d0 <MAIN_ShowError>
     a2a:	03 c0       	rjmp	.+6      	; 0xa32 <FUNCProgramAVR+0x212>
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_LOCK);
     a2c:	83 e0       	ldi	r24, 0x03	; 3
     a2e:	0e 94 dd 17 	call	0x2fba <PM_SendFuseLockBytes>
			}
		}

		strcpy_P(DoneFailMessageBuff, PSTR("PROGRAMMING DONE"));
     a32:	62 ea       	ldi	r22, 0xA2	; 162
     a34:	72 e0       	ldi	r23, 0x02	; 2
     a36:	ce 01       	movw	r24, r28
     a38:	01 96       	adiw	r24, 0x01	; 1
     a3a:	0e 94 2c 1b 	call	0x3658 <strcpy_P>

		if (Fault != ISPCC_NO_FAULT)         // Takes less code to just overwrite part of the string on fail
     a3e:	dd 20       	and	r13, r13
     a40:	31 f0       	breq	.+12     	; 0xa4e <FUNCProgramAVR+0x22e>
		  strcpy_P(&DoneFailMessageBuff[12], PSTR("FAILED"));
     a42:	63 eb       	ldi	r22, 0xB3	; 179
     a44:	72 e0       	ldi	r23, 0x02	; 2
     a46:	ce 01       	movw	r24, r28
     a48:	0d 96       	adiw	r24, 0x0d	; 13
     a4a:	0e 94 2c 1b 	call	0x3658 <strcpy_P>

		LCD_puts(DoneFailMessageBuff);
     a4e:	ce 01       	movw	r24, r28
     a50:	01 96       	adiw	r24, 0x01	; 1
     a52:	0e 94 b6 07 	call	0xf6c <LCD_puts>

		MAIN_Delay10MS(255);
     a56:	8f ef       	ldi	r24, 0xFF	; 255
     a58:	0e 94 25 02 	call	0x44a <MAIN_Delay10MS>
		MAIN_Delay10MS(100);
     a5c:	84 e6       	ldi	r24, 0x64	; 100
     a5e:	0e 94 25 02 	call	0x44a <MAIN_Delay10MS>
     a62:	04 c0       	rjmp	.+8      	; 0xa6c <FUNCProgramAVR+0x24c>
	}
	else
	{
		MAIN_ShowError(SyncErrorMessage);
     a64:	85 ed       	ldi	r24, 0xD5	; 213
     a66:	93 e0       	ldi	r25, 0x03	; 3
     a68:	0e 94 68 03 	call	0x6d0 <MAIN_ShowError>
	}
	
	MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run	
     a6c:	81 e0       	ldi	r24, 0x01	; 1
     a6e:	0e 94 13 03 	call	0x626 <MAIN_ResetCSLine>
	USI_SPIOff();
     a72:	0e 94 95 09 	call	0x132a <USI_SPIOff>
	DF_EnableDataflash(FALSE);
     a76:	80 e0       	ldi	r24, 0x00	; 0
     a78:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
	SPI_SPIOFF();
     a7c:	80 91 64 00 	lds	r24, 0x0064
     a80:	84 60       	ori	r24, 0x04	; 4
     a82:	80 93 64 00 	sts	0x0064, r24
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Green = ready
     a86:	81 b3       	in	r24, 0x11	; 17
     a88:	8f 7c       	andi	r24, 0xCF	; 207
     a8a:	80 61       	ori	r24, 0x10	; 16
     a8c:	81 bb       	out	0x11, r24	; 17
     a8e:	65 96       	adiw	r28, 0x15	; 21
     a90:	0f b6       	in	r0, 0x3f	; 63
     a92:	f8 94       	cli
     a94:	de bf       	out	0x3e, r29	; 62
     a96:	0f be       	out	0x3f, r0	; 63
     a98:	cd bf       	out	0x3d, r28	; 61
     a9a:	df 91       	pop	r29
     a9c:	cf 91       	pop	r28
     a9e:	1f 91       	pop	r17
     aa0:	0f 91       	pop	r16
     aa2:	ff 90       	pop	r15
     aa4:	ef 90       	pop	r14
     aa6:	df 90       	pop	r13
     aa8:	08 95       	ret

00000aaa <FUNCStoreProgram>:
}

void FUNCStoreProgram(void)
{
	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
     aaa:	8a e3       	ldi	r24, 0x3A	; 58
     aac:	99 e0       	ldi	r25, 0x09	; 9
     aae:	90 93 01 01 	sts	0x0101, r25
     ab2:	80 93 00 01 	sts	0x0100, r24
	SPI_SPIInit();
     ab6:	0e 94 30 09 	call	0x1260 <SPI_SPIInit>
	UseExernalDF = FALSE;
     aba:	10 92 83 02 	sts	0x0283, r1
	DF_EnableDataflash(TRUE);
     abe:	81 e0       	ldi	r24, 0x01	; 1
     ac0:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>

	if (!(DF_CheckCorrectOnboardChip()))
     ac4:	0e 94 73 0b 	call	0x16e6 <DF_CheckCorrectOnboardChip>
     ac8:	88 23       	and	r24, r24
     aca:	a1 f0       	breq	.+40     	; 0xaf4 <FUNCStoreProgram+0x4a>
	  return;
			
	LCD_puts_f(PSTR("*STORAGE MODE*"));
     acc:	8a eb       	ldi	r24, 0xBA	; 186
     ace:	92 e0       	ldi	r25, 0x02	; 2
     ad0:	0e 94 f7 07 	call	0xfee <LCD_puts_f>

	InterpretPacketRoutine = (FuncPtr)PM_InterpretAVRISPPacket;
     ad4:	8b e1       	ldi	r24, 0x1B	; 27
     ad6:	95 e1       	ldi	r25, 0x15	; 21
     ad8:	90 93 25 01 	sts	0x0125, r25
     adc:	80 93 24 01 	sts	0x0124, r24
	V2P_RunStateMachine();
     ae0:	0e 94 14 0f 	call	0x1e28 <V2P_RunStateMachine>
	DF_EnableDataflash(FALSE);
     ae4:	80 e0       	ldi	r24, 0x00	; 0
     ae6:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
	SPI_SPIOFF();
     aea:	80 91 64 00 	lds	r24, 0x0064
     aee:	84 60       	ori	r24, 0x04	; 4
     af0:	80 93 64 00 	sts	0x0064, r24
     af4:	08 95       	ret

00000af6 <FUNCClearMem>:
}

void FUNCClearMem(void)
{
     af6:	0f 93       	push	r16
     af8:	1f 93       	push	r17
     afa:	cf 93       	push	r28
     afc:	df 93       	push	r29
     afe:	cd b7       	in	r28, 0x3d	; 61
     b00:	de b7       	in	r29, 0x3e	; 62
     b02:	22 97       	sbiw	r28, 0x02	; 2
     b04:	0f b6       	in	r0, 0x3f	; 63
     b06:	f8 94       	cli
     b08:	de bf       	out	0x3e, r29	; 62
     b0a:	0f be       	out	0x3f, r0	; 63
     b0c:	cd bf       	out	0x3d, r28	; 61
	LCD_puts_f(PSTR("CONFIRM"));
     b0e:	89 ec       	ldi	r24, 0xC9	; 201
     b10:	92 e0       	ldi	r25, 0x02	; 2
     b12:	0e 94 f7 07 	call	0xfee <LCD_puts_f>
	MAIN_Delay10MS(180);
     b16:	84 eb       	ldi	r24, 0xB4	; 180
     b18:	0e 94 25 02 	call	0x44a <MAIN_Delay10MS>

	LCD_puts_f(PSTR("<N Y>"));
     b1c:	81 ed       	ldi	r24, 0xD1	; 209
     b1e:	92 e0       	ldi	r25, 0x02	; 2
     b20:	0e 94 f7 07 	call	0xfee <LCD_puts_f>

	while (1)
	{
		if (JoyStatus)
     b24:	8e b3       	in	r24, 0x1e	; 30
     b26:	88 23       	and	r24, r24
     b28:	e9 f3       	breq	.-6      	; 0xb24 <FUNCClearMem+0x2e>
		{
			if (JoyStatus & JOY_LEFT)
     b2a:	8e b3       	in	r24, 0x1e	; 30
     b2c:	99 27       	eor	r25, r25
     b2e:	8c 01       	movw	r16, r24
     b30:	04 70       	andi	r16, 0x04	; 4
     b32:	10 70       	andi	r17, 0x00	; 0
     b34:	82 fd       	sbrc	r24, 2
     b36:	29 c0       	rjmp	.+82     	; 0xb8a <FUNCClearMem+0x94>
			  return;
			else if (JoyStatus & JOY_RIGHT)
     b38:	f3 9b       	sbis	0x1e, 3	; 30
     b3a:	f4 cf       	rjmp	.-24     	; 0xb24 <FUNCClearMem+0x2e>
			  break;
		}
	}

	MAIN_WaitForJoyRelease();
     b3c:	0e 94 37 02 	call	0x46e <MAIN_WaitForJoyRelease>

	LCD_puts_f(WaitText);
     b40:	8c e2       	ldi	r24, 0x2C	; 44
     b42:	92 e0       	ldi	r25, 0x02	; 2
     b44:	0e 94 f7 07 	call	0xfee <LCD_puts_f>

	for (uint16_t EAddr = 0; EAddr < Sys_MagicNumber; EAddr++)
     b48:	1a 83       	std	Y+2, r17	; 0x02
     b4a:	09 83       	std	Y+1, r16	; 0x01
     b4c:	80 91 02 01 	lds	r24, 0x0102
     b50:	90 91 03 01 	lds	r25, 0x0103
     b54:	08 17       	cp	r16, r24
     b56:	19 07       	cpc	r17, r25
     b58:	88 f4       	brcc	.+34     	; 0xb7c <FUNCClearMem+0x86>
	  eeprom_write_byte_169(&EAddr, 0xFF);
     b5a:	6f ef       	ldi	r22, 0xFF	; 255
     b5c:	ce 01       	movw	r24, r28
     b5e:	01 96       	adiw	r24, 0x01	; 1
     b60:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
     b64:	89 81       	ldd	r24, Y+1	; 0x01
     b66:	9a 81       	ldd	r25, Y+2	; 0x02
     b68:	01 96       	adiw	r24, 0x01	; 1
     b6a:	9a 83       	std	Y+2, r25	; 0x02
     b6c:	89 83       	std	Y+1, r24	; 0x01
     b6e:	20 91 02 01 	lds	r18, 0x0102
     b72:	30 91 03 01 	lds	r19, 0x0103
     b76:	82 17       	cp	r24, r18
     b78:	93 07       	cpc	r25, r19
     b7a:	78 f3       	brcs	.-34     	; 0xb5a <FUNCClearMem+0x64>

	LCD_puts_f(PSTR("MEM CLEARED"));
     b7c:	87 ed       	ldi	r24, 0xD7	; 215
     b7e:	92 e0       	ldi	r25, 0x02	; 2
     b80:	0e 94 f7 07 	call	0xfee <LCD_puts_f>
	MAIN_Delay10MS(255);
     b84:	8f ef       	ldi	r24, 0xFF	; 255
     b86:	0e 94 25 02 	call	0x44a <MAIN_Delay10MS>
     b8a:	22 96       	adiw	r28, 0x02	; 2
     b8c:	0f b6       	in	r0, 0x3f	; 63
     b8e:	f8 94       	cli
     b90:	de bf       	out	0x3e, r29	; 62
     b92:	0f be       	out	0x3f, r0	; 63
     b94:	cd bf       	out	0x3d, r28	; 61
     b96:	df 91       	pop	r29
     b98:	cf 91       	pop	r28
     b9a:	1f 91       	pop	r17
     b9c:	0f 91       	pop	r16
     b9e:	08 95       	ret

00000ba0 <FUNCAutoCalib>:
}

void FUNCAutoCalib(void)
{
	LCD_puts_f(WaitText);
     ba0:	8c e2       	ldi	r24, 0x2C	; 44
     ba2:	92 e0       	ldi	r25, 0x02	; 2
     ba4:	0e 94 f7 07 	call	0xfee <LCD_puts_f>
	OSCCAL_Calibrate();
     ba8:	0e 94 32 07 	call	0xe64 <OSCCAL_Calibrate>
     bac:	08 95       	ret

00000bae <FUNCManCalib>:
}

void FUNCManCalib(void)
{
     bae:	cf 93       	push	r28
     bb0:	df 93       	push	r29
     bb2:	cd b7       	in	r28, 0x3d	; 61
     bb4:	de b7       	in	r29, 0x3e	; 62
     bb6:	29 97       	sbiw	r28, 0x09	; 9
     bb8:	0f b6       	in	r0, 0x3f	; 63
     bba:	f8 94       	cli
     bbc:	de bf       	out	0x3e, r29	; 62
     bbe:	0f be       	out	0x3f, r0	; 63
     bc0:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[9];

	JoyStatus = 1;                           // Invalid value to force the LCD to update
     bc2:	81 e0       	ldi	r24, 0x01	; 1
     bc4:	8e bb       	out	0x1e, r24	; 30
	
	USART_ENABLE(USART_TX_ON, USART_RX_OFF);
     bc6:	80 91 c1 00 	lds	r24, 0x00C1
     bca:	80 78       	andi	r24, 0x80	; 128
     bcc:	88 60       	ori	r24, 0x08	; 8
     bce:	80 93 c1 00 	sts	0x00C1, r24

	while (1)
	{
		if (BuffElements)                    // Routine will also echo send chars (directly accesses the ringbuffer count var)
     bd2:	80 91 d1 02 	lds	r24, 0x02D1
     bd6:	88 23       	and	r24, r24
     bd8:	21 f0       	breq	.+8      	; 0xbe2 <FUNCManCalib+0x34>
		   USART_Tx(BUFF_GetBuffByte());
     bda:	0e 94 be 0b 	call	0x177c <BUFF_GetBuffByte>
     bde:	0e 94 e7 08 	call	0x11ce <USART_Tx>
	
		if (JoyStatus)
     be2:	8e b3       	in	r24, 0x1e	; 30
     be4:	88 23       	and	r24, r24
     be6:	a9 f3       	breq	.-22     	; 0xbd2 <FUNCManCalib+0x24>
		{
			if (JoyStatus & JOY_UP)
     be8:	f6 9b       	sbis	0x1e, 6	; 30
     bea:	04 c0       	rjmp	.+8      	; 0xbf4 <FUNCManCalib+0x46>
			  OSCCAL++;
     bec:	80 91 66 00 	lds	r24, 0x0066
     bf0:	8f 5f       	subi	r24, 0xFF	; 255
     bf2:	05 c0       	rjmp	.+10     	; 0xbfe <FUNCManCalib+0x50>
			else if (JoyStatus & JOY_DOWN)
     bf4:	f7 9b       	sbis	0x1e, 7	; 30
     bf6:	06 c0       	rjmp	.+12     	; 0xc04 <FUNCManCalib+0x56>
			  OSCCAL--;
     bf8:	80 91 66 00 	lds	r24, 0x0066
     bfc:	81 50       	subi	r24, 0x01	; 1
     bfe:	80 93 66 00 	sts	0x0066, r24
     c02:	02 c0       	rjmp	.+4      	; 0xc08 <FUNCManCalib+0x5a>
			else if (JoyStatus & JOY_LEFT)
     c04:	f2 99       	sbic	0x1e, 2	; 30
     c06:	1f c0       	rjmp	.+62     	; 0xc46 <FUNCManCalib+0x98>
			  break;
					
			// Copy the programmer name out of memory and transmit it via the USART:
			strcpy_P(Buffer, ProgrammerName);
     c08:	63 e2       	ldi	r22, 0x23	; 35
     c0a:	72 e0       	ldi	r23, 0x02	; 2
     c0c:	ce 01       	movw	r24, r28
     c0e:	01 96       	adiw	r24, 0x01	; 1
     c10:	0e 94 2c 1b 	call	0x3658 <strcpy_P>
			USART_TxString(Buffer);
     c14:	ce 01       	movw	r24, r28
     c16:	01 96       	adiw	r24, 0x01	; 1
     c18:	0e 94 ef 08 	call	0x11de <USART_TxString>

			Buffer[0] = 'C';
     c1c:	83 e4       	ldi	r24, 0x43	; 67
     c1e:	89 83       	std	Y+1, r24	; 0x01
			Buffer[1] = 'V';
     c20:	86 e5       	ldi	r24, 0x56	; 86
     c22:	8a 83       	std	Y+2, r24	; 0x02
			Buffer[2] = ' ';
     c24:	80 e2       	ldi	r24, 0x20	; 32
     c26:	8b 83       	std	Y+3, r24	; 0x03

			MAIN_IntToStr(OSCCAL, &Buffer[3]);
     c28:	80 91 66 00 	lds	r24, 0x0066
     c2c:	be 01       	movw	r22, r28
     c2e:	6c 5f       	subi	r22, 0xFC	; 252
     c30:	7f 4f       	sbci	r23, 0xFF	; 255
     c32:	99 27       	eor	r25, r25
     c34:	0e 94 2e 03 	call	0x65c <MAIN_IntToStr>
			LCD_puts(Buffer);
     c38:	ce 01       	movw	r24, r28
     c3a:	01 96       	adiw	r24, 0x01	; 1
     c3c:	0e 94 b6 07 	call	0xf6c <LCD_puts>

			MAIN_WaitForJoyRelease();
     c40:	0e 94 37 02 	call	0x46e <MAIN_WaitForJoyRelease>
     c44:	c6 cf       	rjmp	.-116    	; 0xbd2 <FUNCManCalib+0x24>
		}
	}
	
	USART_ENABLE(USART_TX_OFF, USART_RX_OFF);
     c46:	80 91 c1 00 	lds	r24, 0x00C1
     c4a:	80 78       	andi	r24, 0x80	; 128
     c4c:	80 93 c1 00 	sts	0x00C1, r24
     c50:	29 96       	adiw	r28, 0x09	; 9
     c52:	0f b6       	in	r0, 0x3f	; 63
     c54:	f8 94       	cli
     c56:	de bf       	out	0x3e, r29	; 62
     c58:	0f be       	out	0x3f, r0	; 63
     c5a:	cd bf       	out	0x3d, r28	; 61
     c5c:	df 91       	pop	r29
     c5e:	cf 91       	pop	r28
     c60:	08 95       	ret

00000c62 <FUNCSetContrast>:
}

void FUNCSetContrast(void)
{
     c62:	1f 93       	push	r17
     c64:	cf 93       	push	r28
     c66:	df 93       	push	r29
     c68:	cd b7       	in	r28, 0x3d	; 61
     c6a:	de b7       	in	r29, 0x3e	; 62
     c6c:	26 97       	sbiw	r28, 0x06	; 6
     c6e:	0f b6       	in	r0, 0x3f	; 63
     c70:	f8 94       	cli
     c72:	de bf       	out	0x3e, r29	; 62
     c74:	0f be       	out	0x3f, r0	; 63
     c76:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[6];
	uint8_t Contrast = (eeprom_read_byte_169(&Sys_LCDContrast) & 0x0F); // Ranges from 0-15 so mask retuns 15 on blank EEPROM (0xFF)
     c78:	84 e0       	ldi	r24, 0x04	; 4
     c7a:	91 e0       	ldi	r25, 0x01	; 1
     c7c:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
     c80:	18 2f       	mov	r17, r24
     c82:	1f 70       	andi	r17, 0x0F	; 15
	
	JoyStatus = 1;                          // Invalid value to force the LCD to update
     c84:	81 e0       	ldi	r24, 0x01	; 1
     c86:	8e bb       	out	0x1e, r24	; 30
	
	while (1)
	{
		if (JoyStatus)
     c88:	8e b3       	in	r24, 0x1e	; 30
     c8a:	88 23       	and	r24, r24
     c8c:	e9 f3       	breq	.-6      	; 0xc88 <FUNCSetContrast+0x26>
		{
			if (JoyStatus & JOY_UP)
     c8e:	f6 9b       	sbis	0x1e, 6	; 30
     c90:	04 c0       	rjmp	.+8      	; 0xc9a <FUNCSetContrast+0x38>
			{
				if (Contrast < 15)
     c92:	1f 30       	cpi	r17, 0x0F	; 15
     c94:	80 f4       	brcc	.+32     	; 0xcb6 <FUNCSetContrast+0x54>
				  Contrast++;
     c96:	1f 5f       	subi	r17, 0xFF	; 255
     c98:	0e c0       	rjmp	.+28     	; 0xcb6 <FUNCSetContrast+0x54>
			}
			else if (JoyStatus & JOY_DOWN)
     c9a:	f7 9b       	sbis	0x1e, 7	; 30
     c9c:	04 c0       	rjmp	.+8      	; 0xca6 <FUNCSetContrast+0x44>
			{
				if (Contrast > 1)          // Zero is non-visible, so 1 is the minimum
     c9e:	12 30       	cpi	r17, 0x02	; 2
     ca0:	50 f0       	brcs	.+20     	; 0xcb6 <FUNCSetContrast+0x54>
				  Contrast--;
     ca2:	11 50       	subi	r17, 0x01	; 1
     ca4:	08 c0       	rjmp	.+16     	; 0xcb6 <FUNCSetContrast+0x54>
			}
			else if (JoyStatus & JOY_LEFT)
     ca6:	f2 9b       	sbis	0x1e, 2	; 30
     ca8:	06 c0       	rjmp	.+12     	; 0xcb6 <FUNCSetContrast+0x54>
			{
				eeprom_write_byte_169(&Sys_LCDContrast, Contrast);
     caa:	61 2f       	mov	r22, r17
     cac:	84 e0       	ldi	r24, 0x04	; 4
     cae:	91 e0       	ldi	r25, 0x01	; 1
     cb0:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
				return;
     cb4:	18 c0       	rjmp	.+48     	; 0xce6 <FUNCSetContrast+0x84>
			}
					
			Buffer[0] = 'C';
     cb6:	83 e4       	ldi	r24, 0x43	; 67
     cb8:	89 83       	std	Y+1, r24	; 0x01
			Buffer[1] = 'T';
     cba:	84 e5       	ldi	r24, 0x54	; 84
     cbc:	8a 83       	std	Y+2, r24	; 0x02
			Buffer[2] = ' ';
     cbe:	80 e2       	ldi	r24, 0x20	; 32
     cc0:	8b 83       	std	Y+3, r24	; 0x03

			MAIN_IntToStr((uint16_t)Contrast, &Buffer[3]);
     cc2:	be 01       	movw	r22, r28
     cc4:	6c 5f       	subi	r22, 0xFC	; 252
     cc6:	7f 4f       	sbci	r23, 0xFF	; 255
     cc8:	81 2f       	mov	r24, r17
     cca:	99 27       	eor	r25, r25
     ccc:	0e 94 2e 03 	call	0x65c <MAIN_IntToStr>
			LCD_puts(Buffer);
     cd0:	ce 01       	movw	r24, r28
     cd2:	01 96       	adiw	r24, 0x01	; 1
     cd4:	0e 94 b6 07 	call	0xf6c <LCD_puts>

			LCD_CONTRAST_LEVEL(Contrast);
     cd8:	81 2f       	mov	r24, r17
     cda:	8f 70       	andi	r24, 0x0F	; 15
     cdc:	80 93 e7 00 	sts	0x00E7, r24

			MAIN_WaitForJoyRelease();
     ce0:	0e 94 37 02 	call	0x46e <MAIN_WaitForJoyRelease>
     ce4:	d1 cf       	rjmp	.-94     	; 0xc88 <FUNCSetContrast+0x26>
     ce6:	26 96       	adiw	r28, 0x06	; 6
     ce8:	0f b6       	in	r0, 0x3f	; 63
     cea:	f8 94       	cli
     cec:	de bf       	out	0x3e, r29	; 62
     cee:	0f be       	out	0x3f, r0	; 63
     cf0:	cd bf       	out	0x3d, r28	; 61
     cf2:	df 91       	pop	r29
     cf4:	cf 91       	pop	r28
     cf6:	1f 91       	pop	r17
     cf8:	08 95       	ret

00000cfa <FUNCSetISPSpeed>:
		}
	}
}

void FUNCSetISPSpeed(void)
{
     cfa:	cf 93       	push	r28
	JoyStatus = 1;                         // Invalid value to force the LCD to update
     cfc:	81 e0       	ldi	r24, 0x01	; 1
     cfe:	8e bb       	out	0x1e, r24	; 30

	uint8_t CurrSpeed = eeprom_read_byte_169(&Param_SCKDuration);
     d00:	80 e2       	ldi	r24, 0x20	; 32
     d02:	91 e0       	ldi	r25, 0x01	; 1
     d04:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
     d08:	c8 2f       	mov	r28, r24

	if (CurrSpeed > (USI_PRESET_SPEEDS - 1)) CurrSpeed = 0; // Protection against blank EEPROM
     d0a:	84 30       	cpi	r24, 0x04	; 4
     d0c:	08 f0       	brcs	.+2      	; 0xd10 <FUNCSetISPSpeed+0x16>
     d0e:	c0 e0       	ldi	r28, 0x00	; 0

	while (1)
	{
		if (JoyStatus)
     d10:	8e b3       	in	r24, 0x1e	; 30
     d12:	88 23       	and	r24, r24
     d14:	e9 f3       	breq	.-6      	; 0xd10 <FUNCSetISPSpeed+0x16>
		{
			if (JoyStatus & JOY_UP)
     d16:	f6 9b       	sbis	0x1e, 6	; 30
     d18:	06 c0       	rjmp	.+12     	; 0xd26 <FUNCSetISPSpeed+0x2c>
			{
				(CurrSpeed == 0)? CurrSpeed = (USI_PRESET_SPEEDS - 1) : CurrSpeed--;
     d1a:	cc 23       	and	r28, r28
     d1c:	11 f4       	brne	.+4      	; 0xd22 <FUNCSetISPSpeed+0x28>
     d1e:	c3 e0       	ldi	r28, 0x03	; 3
     d20:	12 c0       	rjmp	.+36     	; 0xd46 <FUNCSetISPSpeed+0x4c>
     d22:	c1 50       	subi	r28, 0x01	; 1
     d24:	10 c0       	rjmp	.+32     	; 0xd46 <FUNCSetISPSpeed+0x4c>
			}
			else if (JoyStatus & JOY_DOWN)
     d26:	f7 9b       	sbis	0x1e, 7	; 30
     d28:	06 c0       	rjmp	.+12     	; 0xd36 <FUNCSetISPSpeed+0x3c>
			{
				(CurrSpeed == (USI_PRESET_SPEEDS - 1))? CurrSpeed = 0 : CurrSpeed++;
     d2a:	c3 30       	cpi	r28, 0x03	; 3
     d2c:	11 f4       	brne	.+4      	; 0xd32 <FUNCSetISPSpeed+0x38>
     d2e:	c0 e0       	ldi	r28, 0x00	; 0
     d30:	0a c0       	rjmp	.+20     	; 0xd46 <FUNCSetISPSpeed+0x4c>
     d32:	cf 5f       	subi	r28, 0xFF	; 255
     d34:	08 c0       	rjmp	.+16     	; 0xd46 <FUNCSetISPSpeed+0x4c>
			}
			else if (JoyStatus & JOY_LEFT)
     d36:	f2 9b       	sbis	0x1e, 2	; 30
     d38:	06 c0       	rjmp	.+12     	; 0xd46 <FUNCSetISPSpeed+0x4c>
			{
				eeprom_write_byte_169(&Param_SCKDuration, CurrSpeed);
     d3a:	6c 2f       	mov	r22, r28
     d3c:	80 e2       	ldi	r24, 0x20	; 32
     d3e:	91 e0       	ldi	r25, 0x01	; 1
     d40:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
				return;
     d44:	0d c0       	rjmp	.+26     	; 0xd60 <FUNCSetISPSpeed+0x66>
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&USIPSNamePtrs[CurrSpeed]));
     d46:	ec 2f       	mov	r30, r28
     d48:	ff 27       	eor	r31, r31
     d4a:	ee 0f       	add	r30, r30
     d4c:	ff 1f       	adc	r31, r31
     d4e:	e3 58       	subi	r30, 0x83	; 131
     d50:	ff 4f       	sbci	r31, 0xFF	; 255
     d52:	85 91       	lpm	r24, Z+
     d54:	94 91       	lpm	r25, Z
     d56:	0e 94 f7 07 	call	0xfee <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     d5a:	0e 94 37 02 	call	0x46e <MAIN_WaitForJoyRelease>
     d5e:	d8 cf       	rjmp	.-80     	; 0xd10 <FUNCSetISPSpeed+0x16>
     d60:	cf 91       	pop	r28
     d62:	08 95       	ret

00000d64 <FUNCSleepMode>:
		}
	}
}

void FUNCSleepMode(void)
{
	SMCR    = ((1 << SM1) | (1 << SE));   // Power down sleep mode
     d64:	85 e0       	ldi	r24, 0x05	; 5
     d66:	83 bf       	out	0x33, r24	; 51
	LCDCRA &= ~(1 << LCDEN); 
     d68:	80 91 e4 00 	lds	r24, 0x00E4
     d6c:	8f 77       	andi	r24, 0x7F	; 127
     d6e:	80 93 e4 00 	sts	0x00E4, r24
	
	while (!(JoyStatus & JOY_UP))        // Joystick interrupt wakes the micro
	  SLEEP();
     d72:	f6 99       	sbic	0x1e, 6	; 30
     d74:	03 c0       	rjmp	.+6      	; 0xd7c <FUNCSleepMode+0x18>
     d76:	88 95       	sleep
     d78:	f6 9b       	sbis	0x1e, 6	; 30
     d7a:	fd cf       	rjmp	.-6      	; 0xd76 <FUNCSleepMode+0x12>
	   
	LCDCRA |= (1 << LCDEN);
     d7c:	80 91 e4 00 	lds	r24, 0x00E4
     d80:	80 68       	ori	r24, 0x80	; 128
     d82:	80 93 e4 00 	sts	0x00E4, r24

	LCD_puts_f(WaitText);
     d86:	8c e2       	ldi	r24, 0x2C	; 44
     d88:	92 e0       	ldi	r25, 0x02	; 2
     d8a:	0e 94 f7 07 	call	0xfee <LCD_puts_f>
	OSCCAL_Calibrate();	
     d8e:	0e 94 32 07 	call	0xe64 <OSCCAL_Calibrate>
	
	MAIN_WaitForJoyRelease();
     d92:	0e 94 37 02 	call	0x46e <MAIN_WaitForJoyRelease>
     d96:	08 95       	ret

00000d98 <FUNCStorageInfo>:
}

void FUNCStorageInfo(void)
{
     d98:	1f 93       	push	r17
     d9a:	cf 93       	push	r28
	uint8_t SelectedItem = 0;
     d9c:	10 e0       	ldi	r17, 0x00	; 0

	MAIN_WaitForJoyRelease();
     d9e:	0e 94 37 02 	call	0x46e <MAIN_WaitForJoyRelease>

	JoyStatus = 1;                         // Invalid value to force the LCD to update
     da2:	81 e0       	ldi	r24, 0x01	; 1
     da4:	8e bb       	out	0x1e, r24	; 30

	while (1)
	{
		if (JoyStatus)
     da6:	8e b3       	in	r24, 0x1e	; 30
     da8:	88 23       	and	r24, r24
     daa:	e9 f3       	breq	.-6      	; 0xda6 <FUNCStorageInfo+0xe>
		{
			if (JoyStatus & (JOY_UP | JOY_DOWN))
     dac:	ce b3       	in	r28, 0x1e	; 30
     dae:	c0 7c       	andi	r28, 0xC0	; 192
     db0:	19 f0       	breq	.+6      	; 0xdb8 <FUNCStorageInfo+0x20>
			{
				SelectedItem ^= 1;
     db2:	81 e0       	ldi	r24, 0x01	; 1
     db4:	18 27       	eor	r17, r24
     db6:	38 c0       	rjmp	.+112    	; 0xe28 <FUNCStorageInfo+0x90>
			}
			else if (JoyStatus & JOY_LEFT)
     db8:	f2 99       	sbic	0x1e, 2	; 30
     dba:	43 c0       	rjmp	.+134    	; 0xe42 <FUNCStorageInfo+0xaa>
			{
				return;
			}
			else if (JoyStatus & JOY_PRESS)
     dbc:	f4 9b       	sbis	0x1e, 4	; 30
     dbe:	34 c0       	rjmp	.+104    	; 0xe28 <FUNCStorageInfo+0x90>
			{
				if (SelectedItem == 1)    // View storage tags
     dc0:	11 30       	cpi	r17, 0x01	; 1
     dc2:	81 f5       	brne	.+96     	; 0xe24 <FUNCStorageInfo+0x8c>
				{
					DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
     dc4:	8a e3       	ldi	r24, 0x3A	; 58
     dc6:	99 e0       	ldi	r25, 0x09	; 9
     dc8:	90 93 01 01 	sts	0x0101, r25
     dcc:	80 93 00 01 	sts	0x0100, r24
					SPI_SPIInit();
     dd0:	0e 94 30 09 	call	0x1260 <SPI_SPIInit>
					UseExernalDF = FALSE;
     dd4:	c0 93 83 02 	sts	0x0283, r28
					DF_EnableDataflash(TRUE);
     dd8:	81 2f       	mov	r24, r17
     dda:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>

					if (DF_CheckCorrectOnboardChip())
     dde:	0e 94 73 0b 	call	0x16e6 <DF_CheckCorrectOnboardChip>
     de2:	c8 2f       	mov	r28, r24
     de4:	88 23       	and	r24, r24
     de6:	41 f0       	breq	.+16     	; 0xdf8 <FUNCStorageInfo+0x60>
					{
						TM_ShowTags();
     de8:	0e 94 fe 1a 	call	0x35fc <TM_ShowTags>
						SPI_SPIOFF();
     dec:	80 91 64 00 	lds	r24, 0x0064
     df0:	84 60       	ori	r24, 0x04	; 4
     df2:	80 93 64 00 	sts	0x0064, r24
     df6:	18 c0       	rjmp	.+48     	; 0xe28 <FUNCStorageInfo+0x90>
					}
					else if (!(PM_GetStoredDataSize(TYPE_FLASH)))
     df8:	81 2f       	mov	r24, r17
     dfa:	0e 94 73 13 	call	0x26e6 <PM_GetStoredDataSize>
     dfe:	dc 01       	movw	r26, r24
     e00:	cb 01       	movw	r24, r22
     e02:	00 97       	sbiw	r24, 0x00	; 0
     e04:	a1 05       	cpc	r26, r1
     e06:	b1 05       	cpc	r27, r1
     e08:	79 f4       	brne	.+30     	; 0xe28 <FUNCStorageInfo+0x90>
					{
						DF_EnableDataflash(FALSE);
     e0a:	8c 2f       	mov	r24, r28
     e0c:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
						SPI_SPIOFF();
     e10:	80 91 64 00 	lds	r24, 0x0064
     e14:	84 60       	ori	r24, 0x04	; 4
     e16:	80 93 64 00 	sts	0x0064, r24

						MAIN_ShowError(PSTR("NO STORED PRGM"));
     e1a:	83 ee       	ldi	r24, 0xE3	; 227
     e1c:	92 e0       	ldi	r25, 0x02	; 2
     e1e:	0e 94 68 03 	call	0x6d0 <MAIN_ShowError>
     e22:	02 c0       	rjmp	.+4      	; 0xe28 <FUNCStorageInfo+0x90>
					}	
				}
				else                  // View stored data sizes
				{
					PM_ShowStoredItemSizes();
     e24:	0e 94 da 19 	call	0x33b4 <PM_ShowStoredItemSizes>
				}
			}
			
			LCD_puts_f((uint8_t*)pgm_read_word(&SIFOOptionPtrs[SelectedItem]));
     e28:	e1 2f       	mov	r30, r17
     e2a:	ff 27       	eor	r31, r31
     e2c:	ee 0f       	add	r30, r30
     e2e:	ff 1f       	adc	r31, r31
     e30:	e4 5a       	subi	r30, 0xA4	; 164
     e32:	ff 4f       	sbci	r31, 0xFF	; 255
     e34:	85 91       	lpm	r24, Z+
     e36:	94 91       	lpm	r25, Z
     e38:	0e 94 f7 07 	call	0xfee <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     e3c:	0e 94 37 02 	call	0x46e <MAIN_WaitForJoyRelease>
     e40:	b2 cf       	rjmp	.-156    	; 0xda6 <FUNCStorageInfo+0xe>
     e42:	cf 91       	pop	r28
     e44:	1f 91       	pop	r17
     e46:	08 95       	ret

00000e48 <FUNCGoBootloader>:
		}
	}
}

void FUNCGoBootloader(void)
{
	uint8_t MD = (MCUCR & ~(1 << JTD)); // Forces compiler to use two OUTs rather than two IN/AND/OUTs
     e48:	85 b7       	in	r24, 0x35	; 53
     e4a:	8f 77       	andi	r24, 0x7F	; 127
	MCUCR = MD;  // Turn on JTAG via code
     e4c:	85 bf       	out	0x35, r24	; 53
	MCUCR = MD;  // Twice as specified in datasheet        
     e4e:	85 bf       	out	0x35, r24	; 53
	
	LCD_puts_f(PSTR("*JTAG ON*"));
     e50:	82 ef       	ldi	r24, 0xF2	; 242
     e52:	92 e0       	ldi	r25, 0x02	; 2
     e54:	0e 94 f7 07 	call	0xfee <LCD_puts_f>
	
	MAIN_WaitForJoyRelease();
     e58:	0e 94 37 02 	call	0x46e <MAIN_WaitForJoyRelease>
	
	WDTCR = ((1<<WDCE) | (1<<WDE)); // Enable Watchdog Timer to give reset after minimum timeout
     e5c:	88 e1       	ldi	r24, 0x18	; 24
     e5e:	80 93 60 00 	sts	0x0060, r24
	while (1) {};                  // Eternal loop - when watchdog resets the AVR it will enter the bootloader
     e62:	ff cf       	rjmp	.-2      	; 0xe62 <FUNCGoBootloader+0x1a>

00000e64 <OSCCAL_Calibrate>:
	unsigned char SREG_Backup;
	unsigned char LoopCount = 64; // Maximum range is 128, and starts from the middle, so 64 is the max number of iterations required
   
	// Make sure all clock division is turned off (8Mhz RC clock)
	CLKPR = (1 << CLKPCE);
     e64:	80 e8       	ldi	r24, 0x80	; 128
     e66:	80 93 61 00 	sts	0x0061, r24
	CLKPR = 0;
     e6a:	10 92 61 00 	sts	0x0061, r1

	// Inital OSCCAL of half its maximum for speed
	OSCCAL = (0x7F / 2);
     e6e:	8f e3       	ldi	r24, 0x3F	; 63
     e70:	80 93 66 00 	sts	0x0066, r24

	//Save the SREG
	SREG_Backup = SREG;
     e74:	3f b7       	in	r19, 0x3f	; 63
    
	// Disable all timer 1 interrupts
	TIMSK1 = 0;
     e76:	10 92 6f 00 	sts	0x006F, r1
        
	// Set timer 2 to asyncronous mode (32.768KHz crystal)
	ASSR  = (1 << AS2);
     e7a:	88 e0       	ldi	r24, 0x08	; 8
     e7c:	80 93 b6 00 	sts	0x00B6, r24
        
	// Timer 2 overflow interrupt enable
	TIMSK2 = (1 << TOIE2);
     e80:	81 e0       	ldi	r24, 0x01	; 1
     e82:	80 93 70 00 	sts	0x0070, r24

	//Enable interrupts
	sei();
     e86:	78 94       	sei

	// Start both counters with no prescaling
	TCCR1B = (1 << CS10);
     e88:	80 93 81 00 	sts	0x0081, r24
	TCCR2A = (1 << CS20);
     e8c:	80 93 b0 00 	sts	0x00B0, r24
	 	 
	// Wait until timer 2's external 32.768KHz crystal is stable
	while (ASSR & ((1 << TCN2UB) | (1 << TCR2UB) | (1 << OCR2UB)));
     e90:	80 91 b6 00 	lds	r24, 0x00B6
     e94:	99 27       	eor	r25, r25
     e96:	87 70       	andi	r24, 0x07	; 7
     e98:	90 70       	andi	r25, 0x00	; 0
     e9a:	00 97       	sbiw	r24, 0x00	; 0
     e9c:	c9 f7       	brne	.-14     	; 0xe90 <OSCCAL_Calibrate+0x2c>
    
	// Clear the timer values
	TCNT1 = 0;
     e9e:	90 93 85 00 	sts	0x0085, r25
     ea2:	80 93 84 00 	sts	0x0084, r24
	TCNT2 = 0;
     ea6:	10 92 b2 00 	sts	0x00B2, r1
    
	while (LoopCount--)
	{
		// Let it take a few readings (60ms, approx 7 readings)
		_delay_ms(60);
        
		if (ActualCount > (TARGETCOUNT + 5))		    // Clock is running too fast
		{
			// Bit 7 selects low or high range - only low range is nessesary
			OSCCAL = ((OSCCAL - 1) & ~(1 << 7));
		}
		else if (ActualCount < (TARGETCOUNT - 5))		// Clock is running too slow
		{
			// Bit 7 selects low or high range - only low range is nessesary
			OSCCAL = ((OSCCAL + 1) & ~(1 << 7));
		}
		else		                                    // Clock is just right
		{
			break;
     eaa:	2f e3       	ldi	r18, 0x3F	; 63
     eac:	fc 01       	movw	r30, r24
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     eae:	cf 01       	movw	r24, r30
     eb0:	01 97       	sbiw	r24, 0x01	; 1
     eb2:	f1 f7       	brne	.-4      	; 0xeb0 <OSCCAL_Calibrate+0x4c>
     eb4:	80 91 26 01 	lds	r24, 0x0126
     eb8:	90 91 27 01 	lds	r25, 0x0127
     ebc:	81 50       	subi	r24, 0x01	; 1
     ebe:	91 4e       	sbci	r25, 0xE1	; 225
     ec0:	20 f0       	brcs	.+8      	; 0xeca <OSCCAL_Calibrate+0x66>
     ec2:	80 91 66 00 	lds	r24, 0x0066
     ec6:	81 50       	subi	r24, 0x01	; 1
     ec8:	0a c0       	rjmp	.+20     	; 0xede <OSCCAL_Calibrate+0x7a>
     eca:	80 91 26 01 	lds	r24, 0x0126
     ece:	90 91 27 01 	lds	r25, 0x0127
     ed2:	86 5f       	subi	r24, 0xF6	; 246
     ed4:	90 4e       	sbci	r25, 0xE0	; 224
     ed6:	40 f4       	brcc	.+16     	; 0xee8 <OSCCAL_Calibrate+0x84>
     ed8:	80 91 66 00 	lds	r24, 0x0066
     edc:	8f 5f       	subi	r24, 0xFF	; 255
     ede:	8f 77       	andi	r24, 0x7F	; 127
     ee0:	80 93 66 00 	sts	0x0066, r24
     ee4:	21 50       	subi	r18, 0x01	; 1
     ee6:	18 f7       	brcc	.-58     	; 0xeae <OSCCAL_Calibrate+0x4a>
		}		
	}
            
	// Disable all timer interrupts
	TIMSK1 = 0;
     ee8:	10 92 6f 00 	sts	0x006F, r1
	TIMSK2 = 0;
     eec:	10 92 70 00 	sts	0x0070, r1
    
	// Stop the timers
	TCCR1B = 0x00;
     ef0:	10 92 81 00 	sts	0x0081, r1
	TCCR2A = 0x00;
     ef4:	10 92 b0 00 	sts	0x00B0, r1

	// Turn off timer 2 asynchronous mode
	ASSR  &= ~(1 << AS2);
     ef8:	80 91 b6 00 	lds	r24, 0x00B6
     efc:	87 7f       	andi	r24, 0xF7	; 247
     efe:	80 93 b6 00 	sts	0x00B6, r24

	// Restore SREG
	SREG = SREG_Backup;
     f02:	3f bf       	out	0x3f, r19	; 63
     f04:	08 95       	ret

00000f06 <__vector_5>:
        
	return;
}

ISR(TIMER2_OVF_vect, ISR_BLOCK) // Occurs 32768/256 timers per second, or 128Hz
{
     f06:	1f 92       	push	r1
     f08:	0f 92       	push	r0
     f0a:	0f b6       	in	r0, 0x3f	; 63
     f0c:	0f 92       	push	r0
     f0e:	11 24       	eor	r1, r1
     f10:	8f 93       	push	r24
     f12:	9f 93       	push	r25
	// Stop timer 1 so it can be read
	TCCR1B = 0x00;
     f14:	10 92 81 00 	sts	0x0081, r1
    
	// Record timer 1's value
	ActualCount = TCNT1;
     f18:	80 91 84 00 	lds	r24, 0x0084
     f1c:	90 91 85 00 	lds	r25, 0x0085
     f20:	90 93 27 01 	sts	0x0127, r25
     f24:	80 93 26 01 	sts	0x0126, r24
	     
	// Reset counters and restart timer 1
	TCNT1  = 0;
     f28:	10 92 85 00 	sts	0x0085, r1
     f2c:	10 92 84 00 	sts	0x0084, r1
	TCNT2  = 0;
     f30:	10 92 b2 00 	sts	0x00B2, r1
	TCCR1B = (1 << CS10);
     f34:	81 e0       	ldi	r24, 0x01	; 1
     f36:	80 93 81 00 	sts	0x0081, r24
     f3a:	9f 91       	pop	r25
     f3c:	8f 91       	pop	r24
     f3e:	0f 90       	pop	r0
     f40:	0f be       	out	0x3f, r0	; 63
     f42:	0f 90       	pop	r0
     f44:	1f 90       	pop	r1
     f46:	18 95       	reti

00000f48 <LCD_Init>:
// ======================================================================================

void LCD_Init(void)
{
	LCDCCR = 0x0F;
     f48:	8f e0       	ldi	r24, 0x0F	; 15
     f4a:	80 93 e7 00 	sts	0x00E7, r24

    // Select asynchronous clock source, enable all COM pins and enable all segment pins.
    LCDCRB  = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
     f4e:	87 eb       	ldi	r24, 0xB7	; 183
     f50:	80 93 e5 00 	sts	0x00E5, r24

    // Set LCD prescaler to give a framerate of 32,0 Hz
    LCDFRR  = (0<<LCDPS0) | (7<<LCDCD0);    
     f54:	87 e0       	ldi	r24, 0x07	; 7
     f56:	80 93 e6 00 	sts	0x00E6, r24

	// Enable LCD and set low power waveform
    LCDCRA  = (1<<LCDEN) | (1<<LCDAB); 
     f5a:	80 ec       	ldi	r24, 0xC0	; 192
     f5c:	80 93 e4 00 	sts	0x00E4, r24

    //Enable LCD start of frame interrupt
    LCDCRA |= (1<<LCDIE);
     f60:	80 91 e4 00 	lds	r24, 0x00E4
     f64:	88 60       	ori	r24, 0x08	; 8
     f66:	80 93 e4 00 	sts	0x00E4, r24
     f6a:	08 95       	ret

00000f6c <LCD_puts>:
}

void LCD_puts_f(const uint8_t *FlashData)
{
	uint8_t StrBuff[LCD_TEXTBUFFER_SIZE];

	strcpy_P(StrBuff, FlashData);
	LCD_puts(StrBuff);
}

void LCD_puts(uint8_t *Data)
{
     f6c:	cf 93       	push	r28
     f6e:	df 93       	push	r29
     f70:	ec 01       	movw	r28, r24
	uint8_t LoadB;
	
	for (LoadB = 0; LoadB < 20; LoadB++)
     f72:	20 e0       	ldi	r18, 0x00	; 0
     f74:	3f ef       	ldi	r19, 0xFF	; 255
     f76:	ef e4       	ldi	r30, 0x4F	; 79
     f78:	f2 e0       	ldi	r31, 0x02	; 2
     f7a:	df 01       	movw	r26, r30
	{
		uint8_t CByte = *(Data++);
     f7c:	89 91       	ld	r24, Y+
	
		if ((CByte >= '*') && (CByte <= 'z'))
     f7e:	98 2f       	mov	r25, r24
     f80:	9a 52       	subi	r25, 0x2A	; 42
     f82:	91 35       	cpi	r25, 0x51	; 81
     f84:	38 f4       	brcc	.+14     	; 0xf94 <LCD_puts+0x28>
		  TextBuffer[LoadB] = ((CByte == ' ')? 0xFF : (CByte - '*'));
     f86:	80 32       	cpi	r24, 0x20	; 32
     f88:	11 f0       	breq	.+4      	; 0xf8e <LCD_puts+0x22>
     f8a:	89 2f       	mov	r24, r25
     f8c:	01 c0       	rjmp	.+2      	; 0xf90 <LCD_puts+0x24>
     f8e:	8f ef       	ldi	r24, 0xFF	; 255
     f90:	8c 93       	st	X, r24
     f92:	03 c0       	rjmp	.+6      	; 0xf9a <LCD_puts+0x2e>
		else if (CByte == 0x00)
     f94:	88 23       	and	r24, r24
     f96:	31 f0       	breq	.+12     	; 0xfa4 <LCD_puts+0x38>
		  break;
		else
		  TextBuffer[LoadB] = 0xFF;		
     f98:	30 83       	st	Z, r19
     f9a:	2f 5f       	subi	r18, 0xFF	; 255
     f9c:	11 96       	adiw	r26, 0x01	; 1
     f9e:	31 96       	adiw	r30, 0x01	; 1
     fa0:	24 31       	cpi	r18, 0x14	; 20
     fa2:	60 f3       	brcs	.-40     	; 0xf7c <LCD_puts+0x10>
	}

	ScrollMode  = ((LoadB > 6)? TRUE : FALSE);
     fa4:	80 e0       	ldi	r24, 0x00	; 0
     fa6:	27 30       	cpi	r18, 0x07	; 7
     fa8:	08 f0       	brcs	.+2      	; 0xfac <LCD_puts+0x40>
     faa:	81 e0       	ldi	r24, 0x01	; 1
     fac:	80 93 7f 02 	sts	0x027F, r24
	ScrollCount = 0;
     fb0:	10 92 4d 02 	sts	0x024D, r1
     fb4:	9f ef       	ldi	r25, 0xFF	; 255
     fb6:	86 e0       	ldi	r24, 0x06	; 6

	for (uint8_t Nulls = 0; Nulls < 7; Nulls++)
		TextBuffer[LoadB++] = 0xFF;
     fb8:	e2 2f       	mov	r30, r18
     fba:	ff 27       	eor	r31, r31
     fbc:	e1 5b       	subi	r30, 0xB1	; 177
     fbe:	fd 4f       	sbci	r31, 0xFD	; 253
     fc0:	90 83       	st	Z, r25
     fc2:	2f 5f       	subi	r18, 0xFF	; 255
     fc4:	81 50       	subi	r24, 0x01	; 1
     fc6:	87 ff       	sbrs	r24, 7
     fc8:	f7 cf       	rjmp	.-18     	; 0xfb8 <LCD_puts+0x4c>
	
	TextBuffer[LoadB] = 0x00;
     fca:	e2 2f       	mov	r30, r18
     fcc:	ff 27       	eor	r31, r31
     fce:	e1 5b       	subi	r30, 0xB1	; 177
     fd0:	fd 4f       	sbci	r31, 0xFD	; 253
     fd2:	10 82       	st	Z, r1
	StrStart   = 0;
     fd4:	10 92 4e 02 	sts	0x024E, r1
	StrEnd     = LoadB;	
     fd8:	20 93 4c 02 	sts	0x024C, r18
	DelayCount = LCD_DELAYCOUNT_DEFAULT;
     fdc:	8a e0       	ldi	r24, 0x0A	; 10
     fde:	80 93 80 02 	sts	0x0280, r24

	UpdateLCD  = TRUE;
     fe2:	81 e0       	ldi	r24, 0x01	; 1
     fe4:	80 93 6a 02 	sts	0x026A, r24
     fe8:	df 91       	pop	r29
     fea:	cf 91       	pop	r28
     fec:	08 95       	ret

00000fee <LCD_puts_f>:
     fee:	cf 93       	push	r28
     ff0:	df 93       	push	r29
     ff2:	cd b7       	in	r28, 0x3d	; 61
     ff4:	de b7       	in	r29, 0x3e	; 62
     ff6:	64 97       	sbiw	r28, 0x14	; 20
     ff8:	0f b6       	in	r0, 0x3f	; 63
     ffa:	f8 94       	cli
     ffc:	de bf       	out	0x3e, r29	; 62
     ffe:	0f be       	out	0x3f, r0	; 63
    1000:	cd bf       	out	0x3d, r28	; 61
    1002:	bc 01       	movw	r22, r24
    1004:	ce 01       	movw	r24, r28
    1006:	01 96       	adiw	r24, 0x01	; 1
    1008:	0e 94 2c 1b 	call	0x3658 <strcpy_P>
    100c:	ce 01       	movw	r24, r28
    100e:	01 96       	adiw	r24, 0x01	; 1
    1010:	0e 94 b6 07 	call	0xf6c <LCD_puts>
    1014:	64 96       	adiw	r28, 0x14	; 20
    1016:	0f b6       	in	r0, 0x3f	; 63
    1018:	f8 94       	cli
    101a:	de bf       	out	0x3e, r29	; 62
    101c:	0f be       	out	0x3f, r0	; 63
    101e:	cd bf       	out	0x3d, r28	; 61
    1020:	df 91       	pop	r29
    1022:	cf 91       	pop	r28
    1024:	08 95       	ret

00001026 <LCD_WriteChar>:
}

void LCD_WriteChar(uint8_t Byte, uint8_t Digit)
{
    1026:	e8 2f       	mov	r30, r24
	uint16_t SegData  = 0x00;
    1028:	20 e0       	ldi	r18, 0x00	; 0
    102a:	30 e0       	ldi	r19, 0x00	; 0
	uint8_t  *BuffPtr = (&SegBuffer[0] + (Digit >> 1));
    102c:	86 2f       	mov	r24, r22
    102e:	86 95       	lsr	r24
    1030:	a8 2f       	mov	r26, r24
    1032:	bb 27       	eor	r27, r27
    1034:	a5 59       	subi	r26, 0x95	; 149
    1036:	bd 4f       	sbci	r27, 0xFD	; 253

	if (Byte != 0xFF)
    1038:	ef 3f       	cpi	r30, 0xFF	; 255
    103a:	39 f0       	breq	.+14     	; 0x104a <LCD_WriteChar+0x24>
	  SegData = pgm_read_word(&LCD_SegTable[Byte]);	
    103c:	ff 27       	eor	r31, r31
    103e:	ee 0f       	add	r30, r30
    1040:	ff 1f       	adc	r31, r31
    1042:	e4 50       	subi	r30, 0x04	; 4
    1044:	fd 4f       	sbci	r31, 0xFD	; 253
    1046:	25 91       	lpm	r18, Z+
    1048:	34 91       	lpm	r19, Z
    104a:	77 27       	eor	r23, r23
    104c:	61 70       	andi	r22, 0x01	; 1
    104e:	70 70       	andi	r23, 0x00	; 0
    1050:	43 e0       	ldi	r20, 0x03	; 3

	for (uint8_t BNib = 0; BNib < 4; BNib++)
	{
		uint8_t Mask          = 0xF0;
    1052:	50 ef       	ldi	r21, 0xF0	; 240
		uint8_t MaskedSegData = (SegData & 0x0000F);
    1054:	92 2f       	mov	r25, r18
    1056:	9f 70       	andi	r25, 0x0F	; 15
	
		if (Digit & 0x01)
    1058:	61 15       	cp	r22, r1
    105a:	71 05       	cpc	r23, r1
    105c:	19 f0       	breq	.+6      	; 0x1064 <LCD_WriteChar+0x3e>
		{
			Mask = 0x0F;
    105e:	5f e0       	ldi	r21, 0x0F	; 15
			MaskedSegData <<= 4;
    1060:	92 95       	swap	r25
    1062:	90 7f       	andi	r25, 0xF0	; 240
		}
		
		*BuffPtr = ((*BuffPtr & Mask) | MaskedSegData);
    1064:	8c 91       	ld	r24, X
    1066:	85 23       	and	r24, r21
    1068:	89 2b       	or	r24, r25
    106a:	8c 93       	st	X, r24

		SegData >>= 4;
    106c:	84 e0       	ldi	r24, 0x04	; 4
    106e:	36 95       	lsr	r19
    1070:	27 95       	ror	r18
    1072:	8a 95       	dec	r24
    1074:	e1 f7       	brne	.-8      	; 0x106e <LCD_WriteChar+0x48>
		BuffPtr  += 5;
    1076:	15 96       	adiw	r26, 0x05	; 5
    1078:	41 50       	subi	r20, 0x01	; 1
    107a:	47 ff       	sbrs	r20, 7
    107c:	ea cf       	rjmp	.-44     	; 0x1052 <LCD_WriteChar+0x2c>
    107e:	08 95       	ret

00001080 <__vector_22>:
	}
}

ISR(LCD_vect, ISR_NOBLOCK)
{
    1080:	78 94       	sei
    1082:	1f 92       	push	r1
    1084:	0f 92       	push	r0
    1086:	0f b6       	in	r0, 0x3f	; 63
    1088:	0f 92       	push	r0
    108a:	11 24       	eor	r1, r1
    108c:	2f 93       	push	r18
    108e:	3f 93       	push	r19
    1090:	4f 93       	push	r20
    1092:	5f 93       	push	r21
    1094:	6f 93       	push	r22
    1096:	7f 93       	push	r23
    1098:	8f 93       	push	r24
    109a:	9f 93       	push	r25
    109c:	af 93       	push	r26
    109e:	bf 93       	push	r27
    10a0:	cf 93       	push	r28
    10a2:	ef 93       	push	r30
    10a4:	ff 93       	push	r31
	if (ScrollMode)
    10a6:	80 91 7f 02 	lds	r24, 0x027F
    10aa:	88 23       	and	r24, r24
    10ac:	99 f0       	breq	.+38     	; 0x10d4 <__vector_22+0x54>
	{
		if (DelayCount)
    10ae:	80 91 80 02 	lds	r24, 0x0280
    10b2:	88 23       	and	r24, r24
    10b4:	21 f0       	breq	.+8      	; 0x10be <__vector_22+0x3e>
		{
			DelayCount--;
    10b6:	81 50       	subi	r24, 0x01	; 1
    10b8:	80 93 80 02 	sts	0x0280, r24
    10bc:	0b c0       	rjmp	.+22     	; 0x10d4 <__vector_22+0x54>
		}
		else
		{
			if (!(ScrollCount))
    10be:	80 91 4d 02 	lds	r24, 0x024D
    10c2:	88 23       	and	r24, r24
    10c4:	21 f4       	brne	.+8      	; 0x10ce <__vector_22+0x4e>
			  UpdateLCD = TRUE;
    10c6:	81 e0       	ldi	r24, 0x01	; 1
    10c8:	80 93 6a 02 	sts	0x026A, r24
    10cc:	03 c0       	rjmp	.+6      	; 0x10d4 <__vector_22+0x54>
			else
			  ScrollCount--;
    10ce:	81 50       	subi	r24, 0x01	; 1
    10d0:	80 93 4d 02 	sts	0x024D, r24
		}
	}

	if (UpdateLCD)
    10d4:	80 91 6a 02 	lds	r24, 0x026A
    10d8:	88 23       	and	r24, r24
    10da:	39 f1       	breq	.+78     	; 0x112a <__vector_22+0xaa>
	{
		for (uint8_t Character = 0; Character < 6; Character++)
    10dc:	c0 e0       	ldi	r28, 0x00	; 0
		{
			uint8_t Byte = (StrStart + Character);
    10de:	80 91 4e 02 	lds	r24, 0x024E
    10e2:	8c 0f       	add	r24, r28

			if (Byte >= StrEnd)
    10e4:	90 91 4c 02 	lds	r25, 0x024C
    10e8:	e8 2f       	mov	r30, r24
    10ea:	ff 27       	eor	r31, r31
    10ec:	89 17       	cp	r24, r25
    10ee:	10 f0       	brcs	.+4      	; 0x10f4 <__vector_22+0x74>
			  Byte = TextBuffer[Byte - StrEnd];
    10f0:	e9 1b       	sub	r30, r25
    10f2:	f1 09       	sbc	r31, r1
			else
			  Byte = TextBuffer[Byte];
    10f4:	e1 5b       	subi	r30, 0xB1	; 177
    10f6:	fd 4f       	sbci	r31, 0xFD	; 253
    10f8:	80 81       	ld	r24, Z
			
			LCD_WriteChar(Byte, Character);
    10fa:	6c 2f       	mov	r22, r28
    10fc:	0e 94 13 08 	call	0x1026 <LCD_WriteChar>
    1100:	cf 5f       	subi	r28, 0xFF	; 255
    1102:	c6 30       	cpi	r28, 0x06	; 6
    1104:	60 f3       	brcs	.-40     	; 0x10de <__vector_22+0x5e>
		}
		
		if (StrStart++ == StrEnd)
    1106:	80 91 4e 02 	lds	r24, 0x024E
    110a:	98 2f       	mov	r25, r24
    110c:	8f 5f       	subi	r24, 0xFF	; 255
    110e:	80 93 4e 02 	sts	0x024E, r24
    1112:	80 91 4c 02 	lds	r24, 0x024C
    1116:	98 17       	cp	r25, r24
    1118:	19 f4       	brne	.+6      	; 0x1120 <__vector_22+0xa0>
		  StrStart = 1;
    111a:	81 e0       	ldi	r24, 0x01	; 1
    111c:	80 93 4e 02 	sts	0x024E, r24
		
		ScrollCount = LCD_SCROLLCOUNT_DEFAULT;
    1120:	83 e0       	ldi	r24, 0x03	; 3
    1122:	80 93 4d 02 	sts	0x024D, r24
		UpdateLCD = FALSE;
    1126:	10 92 6a 02 	sts	0x026A, r1
    112a:	ac ee       	ldi	r26, 0xEC	; 236
    112c:	b0 e0       	ldi	r27, 0x00	; 0
    112e:	eb e6       	ldi	r30, 0x6B	; 107
    1130:	f2 e0       	ldi	r31, 0x02	; 2
    1132:	93 e1       	ldi	r25, 0x13	; 19
	}

	for (uint8_t LCDChar = 0; LCDChar < LCD_SEGBUFFER_SIZE; LCDChar++)
	  *(pLCDREG + LCDChar) = SegBuffer[LCDChar];
    1134:	81 91       	ld	r24, Z+
    1136:	8d 93       	st	X+, r24
    1138:	91 50       	subi	r25, 0x01	; 1
    113a:	97 ff       	sbrs	r25, 7
    113c:	fb cf       	rjmp	.-10     	; 0x1134 <__vector_22+0xb4>
    113e:	ff 91       	pop	r31
    1140:	ef 91       	pop	r30
    1142:	cf 91       	pop	r28
    1144:	bf 91       	pop	r27
    1146:	af 91       	pop	r26
    1148:	9f 91       	pop	r25
    114a:	8f 91       	pop	r24
    114c:	7f 91       	pop	r23
    114e:	6f 91       	pop	r22
    1150:	5f 91       	pop	r21
    1152:	4f 91       	pop	r20
    1154:	3f 91       	pop	r19
    1156:	2f 91       	pop	r18
    1158:	0f 90       	pop	r0
    115a:	0f be       	out	0x3f, r0	; 63
    115c:	0f 90       	pop	r0
    115e:	1f 90       	pop	r1
    1160:	18 95       	reti

00001162 <eeprom_read_byte_169>:
#include <avr/interrupt.h>
#include "eeprom169.h"

uint8_t eeprom_read_byte_169(const uint16_t *addr)
{
    1162:	fc 01       	movw	r30, r24
	cli();
    1164:	f8 94       	cli
	/* Set up address register */
	EEAR = *addr;
    1166:	80 81       	ld	r24, Z
    1168:	91 81       	ldd	r25, Z+1	; 0x01
    116a:	92 bd       	out	0x22, r25	; 34
    116c:	81 bd       	out	0x21, r24	; 33
	/* Start eeprom read by writing EERE */
	EECR |= (1<<EERE);
    116e:	f8 9a       	sbi	0x1f, 0	; 31
	sei();
    1170:	78 94       	sei
	/* Return data from Data Register */
	return EEDR;
    1172:	80 b5       	in	r24, 0x20	; 32
}
    1174:	99 27       	eor	r25, r25
    1176:	08 95       	ret

00001178 <eeprom_write_byte_169>:

void eeprom_write_byte_169(const uint16_t *addr, uint8_t val) 
{
    1178:	1f 93       	push	r17
    117a:	cf 93       	push	r28
    117c:	df 93       	push	r29
    117e:	ec 01       	movw	r28, r24
    1180:	16 2f       	mov	r17, r22
	if(eeprom_read_byte_169(addr) == val) // Compare stored value with new value for match
    1182:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
    1186:	81 17       	cp	r24, r17
    1188:	59 f0       	breq	.+22     	; 0x11a0 <eeprom_write_byte_169+0x28>
		return; // Don't re-write the same value and waste EEPROM life

	cli();
    118a:	f8 94       	cli
	/* Set up address and Data Registers */
	EEAR = *addr;
    118c:	88 81       	ld	r24, Y
    118e:	99 81       	ldd	r25, Y+1	; 0x01
    1190:	92 bd       	out	0x22, r25	; 34
    1192:	81 bd       	out	0x21, r24	; 33
	EEDR = val;
    1194:	10 bd       	out	0x20, r17	; 32
	/* Write logical one to EEMWE */
	EECR |= (1<<EEMWE);
    1196:	fa 9a       	sbi	0x1f, 2	; 31
	/* Start eeprom write by setting EEWE */
	EECR |= (1<<EEWE);
    1198:	f9 9a       	sbi	0x1f, 1	; 31
	sei();
    119a:	78 94       	sei
	/* Wait for completion */
	while(EECR & (1<<EEWE));
    119c:	f9 99       	sbic	0x1f, 1	; 31
    119e:	fe cf       	rjmp	.-4      	; 0x119c <eeprom_write_byte_169+0x24>
    11a0:	df 91       	pop	r29
    11a2:	cf 91       	pop	r28
    11a4:	1f 91       	pop	r17
    11a6:	08 95       	ret

000011a8 <USART_Init>:
*   Purpose :       Initialize the USART
*
*****************************************************************************/
void USART_Init(unsigned int baudrate)
{
    11a8:	9c 01       	movw	r18, r24
    // Set baud rate
    UBRRH = (unsigned char)(baudrate>>8);
    11aa:	83 2f       	mov	r24, r19
    11ac:	99 27       	eor	r25, r25
    11ae:	80 93 c5 00 	sts	0x00C5, r24
    UBRRL = (unsigned char)(baudrate);
    11b2:	20 93 c4 00 	sts	0x00C4, r18

    // Double speed
	UCSRA = (USART_DOUBLESPEED << U2X);
    11b6:	82 e0       	ldi	r24, 0x02	; 2
    11b8:	80 93 c0 00 	sts	0x00C0, r24

    // Enable recieve complete interrupt
	UCSRB = (1 << RXCIE);
    11bc:	80 e8       	ldi	r24, 0x80	; 128
    11be:	80 93 c1 00 	sts	0x00C1, r24
	 
    // Async. mode, 8N1
    UCSRC = (3 << UCSZ0);
    11c2:	86 e0       	ldi	r24, 0x06	; 6
    11c4:	80 93 c2 00 	sts	0x00C2, r24
	 
	 // Initalise ringbuffer
	BUFF_InitialiseBuffer();
    11c8:	0e 94 88 0b 	call	0x1710 <BUFF_InitialiseBuffer>
    11cc:	08 95       	ret

000011ce <USART_Tx>:
}

/*****************************************************************************
*
*   Function name : Usart_Tx
*
*   Returns :       None
*
*   Parameters :    char data: byte to send
*
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_Tx(char data)
{
    11ce:	98 2f       	mov	r25, r24
    while (!(UCSRA & (1<<UDRE)));
    11d0:	80 91 c0 00 	lds	r24, 0x00C0
    11d4:	85 ff       	sbrs	r24, 5
    11d6:	fc cf       	rjmp	.-8      	; 0x11d0 <USART_Tx+0x2>
    UDR = data;
    11d8:	90 93 c6 00 	sts	0x00C6, r25
    11dc:	08 95       	ret

000011de <USART_TxString>:
}

/*****************************************************************************
*
*   Function name : Usart_Tx
*
*   Returns :       None
*
*   Parameters :    char data: byte to send
*
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_TxString(char *data)
{
    11de:	cf 93       	push	r28
    11e0:	df 93       	push	r29
    11e2:	ec 01       	movw	r28, r24
	while (*data != '\0')
		USART_Tx(*data++);
    11e4:	88 81       	ld	r24, Y
    11e6:	88 23       	and	r24, r24
    11e8:	31 f0       	breq	.+12     	; 0x11f6 <USART_TxString+0x18>
    11ea:	89 91       	ld	r24, Y+
    11ec:	0e 94 e7 08 	call	0x11ce <USART_Tx>
    11f0:	88 81       	ld	r24, Y
    11f2:	88 23       	and	r24, r24
    11f4:	d1 f7       	brne	.-12     	; 0x11ea <USART_TxString+0xc>
    11f6:	df 91       	pop	r29
    11f8:	cf 91       	pop	r28
    11fa:	08 95       	ret

000011fc <USART_Rx>:
}

/*****************************************************************************
*
*   Function name : Usart_Rx
*
*   Returns :       char: byte received
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART
*
*****************************************************************************/
char USART_Rx(void)
{
    while (!(BuffElements) && !(TimeOut)) {};
    11fc:	80 91 d1 02 	lds	r24, 0x02D1
    1200:	88 23       	and	r24, r24
    1202:	21 f4       	brne	.+8      	; 0x120c <USART_Rx+0x10>
    1204:	80 91 28 01 	lds	r24, 0x0128
    1208:	88 23       	and	r24, r24
    120a:	c1 f3       	breq	.-16     	; 0x11fc <USART_Rx>
    return BUFF_GetBuffByte();
    120c:	0e 94 be 0b 	call	0x177c <BUFF_GetBuffByte>
}
    1210:	99 27       	eor	r25, r25
    1212:	08 95       	ret

00001214 <__vector_13>:

/*****************************************************************************
*
*   Function name : Usart_Rx Interrupt
*
*   Returns :       N/A
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART and stores it into the buffer
*
*****************************************************************************/

ISR(USART0_RX_vect, ISR_BLOCK)
{
    1214:	1f 92       	push	r1
    1216:	0f 92       	push	r0
    1218:	0f b6       	in	r0, 0x3f	; 63
    121a:	0f 92       	push	r0
    121c:	11 24       	eor	r1, r1
    121e:	2f 93       	push	r18
    1220:	3f 93       	push	r19
    1222:	4f 93       	push	r20
    1224:	5f 93       	push	r21
    1226:	6f 93       	push	r22
    1228:	7f 93       	push	r23
    122a:	8f 93       	push	r24
    122c:	9f 93       	push	r25
    122e:	af 93       	push	r26
    1230:	bf 93       	push	r27
    1232:	ef 93       	push	r30
    1234:	ff 93       	push	r31
	BUFF_StoreBuffByte(UDR);
    1236:	80 91 c6 00 	lds	r24, 0x00C6
    123a:	0e 94 95 0b 	call	0x172a <BUFF_StoreBuffByte>
    123e:	ff 91       	pop	r31
    1240:	ef 91       	pop	r30
    1242:	bf 91       	pop	r27
    1244:	af 91       	pop	r26
    1246:	9f 91       	pop	r25
    1248:	8f 91       	pop	r24
    124a:	7f 91       	pop	r23
    124c:	6f 91       	pop	r22
    124e:	5f 91       	pop	r21
    1250:	4f 91       	pop	r20
    1252:	3f 91       	pop	r19
    1254:	2f 91       	pop	r18
    1256:	0f 90       	pop	r0
    1258:	0f be       	out	0x3f, r0	; 63
    125a:	0f 90       	pop	r0
    125c:	1f 90       	pop	r1
    125e:	18 95       	reti

00001260 <SPI_SPIInit>:
// ======================================================================================

void SPI_SPIInit(void)
{
	PRR &= ~(1 << PRSPI);              // Enable the SPI system by clearing the power save register SPI disable bit
    1260:	80 91 64 00 	lds	r24, 0x0064
    1264:	8b 7f       	andi	r24, 0xFB	; 251
    1266:	80 93 64 00 	sts	0x0064, r24

	// Master, Sample falling edge (setup rising), Fosc/32 speed (8Mhz/32 = 125Khz)
	SPSR = (1 << SPI2X);
    126a:	81 e0       	ldi	r24, 0x01	; 1
    126c:	8d bd       	out	0x2d, r24	; 45
	SPCR = ((1 << SPE) | (1 << MSTR) | (1 << CPHA) | (1 << CPOL) | (1 << SPR1));
    126e:	8e e5       	ldi	r24, 0x5E	; 94
    1270:	8c bd       	out	0x2c, r24	; 44
    1272:	08 95       	ret

00001274 <SPI_SPITransmit>:
}

uint8_t SPI_SPITransmit(uint8_t Data)
{
	SPDR = Data;                       // Loading a byte into the register starts the transmission
    1274:	8e bd       	out	0x2e, r24	; 46
	while (!(SPSR & (1 << SPIF)));    // Wait until transmission completed
    1276:	0d b4       	in	r0, 0x2d	; 45
    1278:	07 fe       	sbrs	r0, 7
    127a:	fd cf       	rjmp	.-6      	; 0x1276 <SPI_SPITransmit+0x2>
	return SPDR;
    127c:	8e b5       	in	r24, 0x2e	; 46
}
    127e:	99 27       	eor	r25, r25
    1280:	08 95       	ret

00001282 <SPI_SPITransmitWord>:

uint8_t SPI_SPITransmitWord(uint16_t Data)
{
    1282:	0f 93       	push	r16
    1284:	1f 93       	push	r17
    1286:	8c 01       	movw	r16, r24
	SPI_SPITransmit((uint8_t)(Data >> 8));
    1288:	81 2f       	mov	r24, r17
    128a:	99 27       	eor	r25, r25
    128c:	0e 94 3a 09 	call	0x1274 <SPI_SPITransmit>
	return SPI_SPITransmit((uint8_t)Data);
    1290:	80 2f       	mov	r24, r16
    1292:	0e 94 3a 09 	call	0x1274 <SPI_SPITransmit>
}
    1296:	99 27       	eor	r25, r25
    1298:	1f 91       	pop	r17
    129a:	0f 91       	pop	r16
    129c:	08 95       	ret

0000129e <__vector_17>:
 *  have to stop the timer tick.
 *  For all modes the USIDR contents are stored and flags are updated.
 */
ISR(USI_OVERFLOW_vect, ISR_BLOCK)
{
    129e:	1f 92       	push	r1
    12a0:	0f 92       	push	r0
    12a2:	0f b6       	in	r0, 0x3f	; 63
    12a4:	0f 92       	push	r0
    12a6:	11 24       	eor	r1, r1
    12a8:	8f 93       	push	r24
	// Master must now disable the compare match interrupt
	// to prevent more USI counter clocks.
	TIMSK0 &= ~(1<<OCIE0A);
    12aa:	80 91 6e 00 	lds	r24, 0x006E
    12ae:	8d 7f       	andi	r24, 0xFD	; 253
    12b0:	80 93 6e 00 	sts	0x006E, r24
	
	// Update flags and clear USI counter
	USISR = (1<<USIOIF);
    12b4:	80 e4       	ldi	r24, 0x40	; 64
    12b6:	80 93 b9 00 	sts	0x00B9, r24
	TransferComplete = 1;
    12ba:	81 e0       	ldi	r24, 0x01	; 1
    12bc:	80 93 81 02 	sts	0x0281, r24

	// Copy USIDR to buffer to prevent overwrite on next transfer.
	storedUSIDR = USIDR;
    12c0:	80 91 ba 00 	lds	r24, 0x00BA
    12c4:	80 93 82 02 	sts	0x0282, r24
    12c8:	8f 91       	pop	r24
    12ca:	0f 90       	pop	r0
    12cc:	0f be       	out	0x3f, r0	; 63
    12ce:	0f 90       	pop	r0
    12d0:	1f 90       	pop	r1
    12d2:	18 95       	reti

000012d4 <USI_SPISetSpeed>:
}



/*! \brief  Initialize USI as SPI master.
 *
 *  This function sets up all pin directions and module configurations.
 *  Use this function initially or when changing from slave to master mode.
 *  Note that the stored USIDR value is cleared.
 *
 */
void USI_SPIInitMaster(char Freq)
{
	// Configure port directions.
 	USI_DIR_REG |= (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN);  // Outputs.
	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN);                       // Inputs.
	USI_OUT_REG |= (1<<USI_DATAIN_PIN);                        // Pull-ups.
	USI_OUT_REG &= ~(1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN); // Pull-ups.
	
	// Configure USI to 3-wire master mode with overflow interrupt.
	USICR = USI_CONTROL_REG_FLAGS;

	// Set the compare and prescaler for the requested frequency:
	USI_SPISetSpeed(Freq);
	
	// Init driver status register.
	TransferComplete = 0;
	
	storedUSIDR = 0;
}

void USI_SPIOff( void )
{
	USI_DIR_REG &= ~((1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN));                        // Inputs.
	USI_OUT_REG &= ~((1<<USI_DATAIN_PIN)  | (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN)); // Pull-ups.
	DDRF  &= ~(1 << 6);
	PORTF &= ~(1 << 6);
	
	USI_STOPUSITIMER();
}

/*! \brief  Put one byte on bus.
 *
 *  Use this function like you would write to the SPDR register in the native SPI module.
 *  Calling this function in master mode starts a transfer, while in slave mode, a
 *  byte will be prepared for the next transfer initiated by the master device.
 *  If a transfer is in progress, this function will set the write collision flag
 *  and return without altering the data registers.
 *
 *  \returns  0 if a write collision occurred, 1 otherwise.
 */
uint8_t USI_SPITransmit( unsigned char val )
{
	// Reinit flags.
	TransferComplete = 0;

	// Put data in USI data register.
	USIDR = val;
	
	TIFR0  |= (1<<OCF0A);  // Clear compare match flag.
	TIMSK0 |= (1<<OCIE0A); // Enable compare match interrupt.

	// Clear the timer 0 value
	TCNT0 = 0;

	while (!(TransferComplete));

	return storedUSIDR;
}

uint8_t USI_SPITransmitWord( unsigned int val )
{
	USI_SPITransmit((uint8_t)(val >> 8));
	return USI_SPITransmit((uint8_t)val);
}

void USI_SPIToggleClock(void)
{
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);	
}

void USI_SPISetSpeed(uint8_t Freq)
{
    12d4:	48 2f       	mov	r20, r24
	for (uint8_t MatchIndex = 0; MatchIndex < USI_PRESET_SPEEDS; MatchIndex++)
    12d6:	90 e0       	ldi	r25, 0x00	; 0
    12d8:	69 e6       	ldi	r22, 0x69	; 105
    12da:	73 e0       	ldi	r23, 0x03	; 3
    12dc:	9b 01       	movw	r18, r22
    12de:	21 50       	subi	r18, 0x01	; 1
    12e0:	30 40       	sbci	r19, 0x00	; 0
	{
		if ((pgm_read_byte(&USIPSValues[MatchIndex][0]) == Freq) || (MatchIndex == (USI_PRESET_SPEEDS - 1)))
    12e2:	f9 01       	movw	r30, r18
    12e4:	84 91       	lpm	r24, Z
    12e6:	84 17       	cp	r24, r20
    12e8:	11 f0       	breq	.+4      	; 0x12ee <USI_SPISetSpeed+0x1a>
    12ea:	93 30       	cpi	r25, 0x03	; 3
    12ec:	31 f4       	brne	.+12     	; 0x12fa <USI_SPISetSpeed+0x26>
		{
			// Init Output Compare Register.
			OCR0A = pgm_read_byte(&USIPSValues[MatchIndex][1]);
    12ee:	fb 01       	movw	r30, r22
    12f0:	84 91       	lpm	r24, Z
    12f2:	87 bd       	out	0x27, r24	; 39

			// Enable 'Clear Timer on Compare match' and set prescaler, which starts the timer
			TCCR0A = ((1<<WGM01) | TC0_PS_1);
    12f4:	89 e0       	ldi	r24, 0x09	; 9
    12f6:	84 bd       	out	0x24, r24	; 36
				
			return;
    12f8:	08 95       	ret
    12fa:	9f 5f       	subi	r25, 0xFF	; 255
    12fc:	2e 5f       	subi	r18, 0xFE	; 254
    12fe:	3f 4f       	sbci	r19, 0xFF	; 255
    1300:	6e 5f       	subi	r22, 0xFE	; 254
    1302:	7f 4f       	sbci	r23, 0xFF	; 255
    1304:	94 30       	cpi	r25, 0x04	; 4
    1306:	68 f3       	brcs	.-38     	; 0x12e2 <USI_SPISetSpeed+0xe>
    1308:	08 95       	ret

0000130a <USI_SPIInitMaster>:
    130a:	9d b1       	in	r25, 0x0d	; 13
    130c:	90 65       	ori	r25, 0x50	; 80
    130e:	9d b9       	out	0x0d, r25	; 13
    1310:	6d 98       	cbi	0x0d, 5	; 13
    1312:	75 9a       	sbi	0x0e, 5	; 14
    1314:	76 98       	cbi	0x0e, 6	; 14
    1316:	9a e5       	ldi	r25, 0x5A	; 90
    1318:	90 93 b8 00 	sts	0x00B8, r25
    131c:	0e 94 6a 09 	call	0x12d4 <USI_SPISetSpeed>
    1320:	10 92 81 02 	sts	0x0281, r1
    1324:	10 92 82 02 	sts	0x0282, r1
    1328:	08 95       	ret

0000132a <USI_SPIOff>:
    132a:	8d b1       	in	r24, 0x0d	; 13
    132c:	8f 7a       	andi	r24, 0xAF	; 175
    132e:	8d b9       	out	0x0d, r24	; 13
    1330:	8e b1       	in	r24, 0x0e	; 14
    1332:	8f 78       	andi	r24, 0x8F	; 143
    1334:	8e b9       	out	0x0e, r24	; 14
    1336:	86 98       	cbi	0x10, 6	; 16
    1338:	8e 98       	cbi	0x11, 6	; 17
    133a:	14 bc       	out	0x24, r1	; 36
    133c:	08 95       	ret

0000133e <USI_SPITransmit>:
    133e:	10 92 81 02 	sts	0x0281, r1
    1342:	80 93 ba 00 	sts	0x00BA, r24
    1346:	a9 9a       	sbi	0x15, 1	; 21
    1348:	80 91 6e 00 	lds	r24, 0x006E
    134c:	82 60       	ori	r24, 0x02	; 2
    134e:	80 93 6e 00 	sts	0x006E, r24
    1352:	16 bc       	out	0x26, r1	; 38
    1354:	80 91 81 02 	lds	r24, 0x0281
    1358:	88 23       	and	r24, r24
    135a:	e1 f3       	breq	.-8      	; 0x1354 <USI_SPITransmit+0x16>
    135c:	80 91 82 02 	lds	r24, 0x0282
    1360:	99 27       	eor	r25, r25
    1362:	08 95       	ret

00001364 <USI_SPITransmitWord>:
    1364:	0f 93       	push	r16
    1366:	1f 93       	push	r17
    1368:	8c 01       	movw	r16, r24
    136a:	81 2f       	mov	r24, r17
    136c:	99 27       	eor	r25, r25
    136e:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    1372:	80 2f       	mov	r24, r16
    1374:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    1378:	99 27       	eor	r25, r25
    137a:	1f 91       	pop	r17
    137c:	0f 91       	pop	r16
    137e:	08 95       	ret

00001380 <USI_SPIToggleClock>:
    1380:	81 e0       	ldi	r24, 0x01	; 1
    1382:	0e 94 01 03 	call	0x602 <MAIN_Delay1MS>
    1386:	80 91 b8 00 	lds	r24, 0x00B8
    138a:	81 60       	ori	r24, 0x01	; 1
    138c:	80 93 b8 00 	sts	0x00B8, r24
    1390:	81 e0       	ldi	r24, 0x01	; 1
    1392:	0e 94 01 03 	call	0x602 <MAIN_Delay1MS>
    1396:	80 91 b8 00 	lds	r24, 0x00B8
    139a:	81 60       	ori	r24, 0x01	; 1
    139c:	80 93 b8 00 	sts	0x00B8, r24
    13a0:	81 e0       	ldi	r24, 0x01	; 1
    13a2:	0e 94 01 03 	call	0x602 <MAIN_Delay1MS>
    13a6:	08 95       	ret

000013a8 <DF_EnableDataflash>:
	while(DF_BUSY());
}

void DF_EnableDataflash(uint8_t Enabled)
{
    13a8:	90 91 83 02 	lds	r25, 0x0283
	if (Enabled == TRUE)
    13ac:	81 30       	cpi	r24, 0x01	; 1
    13ae:	31 f4       	brne	.+12     	; 0x13bc <DF_EnableDataflash+0x14>
	{
		if (UseExernalDF == TRUE)
    13b0:	91 30       	cpi	r25, 0x01	; 1
    13b2:	11 f4       	brne	.+4      	; 0x13b8 <DF_EnableDataflash+0x10>
		  MAIN_ResetCSLine(MAIN_RESETCS_DFACTIVE);
    13b4:	82 e0       	ldi	r24, 0x02	; 2
    13b6:	05 c0       	rjmp	.+10     	; 0x13c2 <DF_EnableDataflash+0x1a>
		else
		  PORTB &= ~(1 << 0);
    13b8:	28 98       	cbi	0x05, 0	; 5
    13ba:	08 95       	ret
	}
	else
	{
		if (UseExernalDF == TRUE)
    13bc:	91 30       	cpi	r25, 0x01	; 1
    13be:	21 f4       	brne	.+8      	; 0x13c8 <DF_EnableDataflash+0x20>
		  MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);
    13c0:	89 2f       	mov	r24, r25
    13c2:	0e 94 13 03 	call	0x626 <MAIN_ResetCSLine>
    13c6:	08 95       	ret
		else
		  PORTB |= (1 << 0);
    13c8:	28 9a       	sbi	0x05, 0	; 5
    13ca:	08 95       	ret

000013cc <DF_ReadBufferByte>:
    13cc:	0f 93       	push	r16
    13ce:	1f 93       	push	r17
    13d0:	8c 01       	movw	r16, r24
    13d2:	80 e0       	ldi	r24, 0x00	; 0
    13d4:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    13d8:	00 00       	nop
    13da:	81 e0       	ldi	r24, 0x01	; 1
    13dc:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    13e0:	e0 91 00 01 	lds	r30, 0x0100
    13e4:	f0 91 01 01 	lds	r31, 0x0101
    13e8:	84 e5       	ldi	r24, 0x54	; 84
    13ea:	09 95       	icall
    13ec:	81 2f       	mov	r24, r17
    13ee:	99 27       	eor	r25, r25
    13f0:	e0 91 00 01 	lds	r30, 0x0100
    13f4:	f0 91 01 01 	lds	r31, 0x0101
    13f8:	09 95       	icall
    13fa:	e0 91 00 01 	lds	r30, 0x0100
    13fe:	f0 91 01 01 	lds	r31, 0x0101
    1402:	80 2f       	mov	r24, r16
    1404:	09 95       	icall
    1406:	e0 91 00 01 	lds	r30, 0x0100
    140a:	f0 91 01 01 	lds	r31, 0x0101
    140e:	80 e0       	ldi	r24, 0x00	; 0
    1410:	09 95       	icall
    1412:	e0 91 00 01 	lds	r30, 0x0100
    1416:	f0 91 01 01 	lds	r31, 0x0101
    141a:	80 e0       	ldi	r24, 0x00	; 0
    141c:	09 95       	icall
    141e:	99 27       	eor	r25, r25
    1420:	1f 91       	pop	r17
    1422:	0f 91       	pop	r16
    1424:	08 95       	ret

00001426 <DF_ContinuousReadEnable>:
    1426:	ef 92       	push	r14
    1428:	ff 92       	push	r15
    142a:	0f 93       	push	r16
    142c:	1f 93       	push	r17
    142e:	8c 01       	movw	r16, r24
    1430:	7b 01       	movw	r14, r22
    1432:	80 e0       	ldi	r24, 0x00	; 0
    1434:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    1438:	00 00       	nop
    143a:	81 e0       	ldi	r24, 0x01	; 1
    143c:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    1440:	e0 91 00 01 	lds	r30, 0x0100
    1444:	f0 91 01 01 	lds	r31, 0x0101
    1448:	88 e6       	ldi	r24, 0x68	; 104
    144a:	09 95       	icall
    144c:	8a b5       	in	r24, 0x2a	; 42
    144e:	98 01       	movw	r18, r16
    1450:	02 c0       	rjmp	.+4      	; 0x1456 <DF_ContinuousReadEnable+0x30>
    1452:	36 95       	lsr	r19
    1454:	27 95       	ror	r18
    1456:	8a 95       	dec	r24
    1458:	e2 f7       	brpl	.-8      	; 0x1452 <DF_ContinuousReadEnable+0x2c>
    145a:	c9 01       	movw	r24, r18
    145c:	e0 91 00 01 	lds	r30, 0x0100
    1460:	f0 91 01 01 	lds	r31, 0x0101
    1464:	09 95       	icall
    1466:	8b b5       	in	r24, 0x2b	; 43
    1468:	02 c0       	rjmp	.+4      	; 0x146e <DF_ContinuousReadEnable+0x48>
    146a:	00 0f       	add	r16, r16
    146c:	11 1f       	adc	r17, r17
    146e:	8a 95       	dec	r24
    1470:	e2 f7       	brpl	.-8      	; 0x146a <DF_ContinuousReadEnable+0x44>
    1472:	8f 2d       	mov	r24, r15
    1474:	99 27       	eor	r25, r25
    1476:	e0 91 00 01 	lds	r30, 0x0100
    147a:	f0 91 01 01 	lds	r31, 0x0101
    147e:	80 0f       	add	r24, r16
    1480:	09 95       	icall
    1482:	e0 91 00 01 	lds	r30, 0x0100
    1486:	f0 91 01 01 	lds	r31, 0x0101
    148a:	8e 2d       	mov	r24, r14
    148c:	09 95       	icall
    148e:	03 e0       	ldi	r16, 0x03	; 3
    1490:	e0 91 00 01 	lds	r30, 0x0100
    1494:	f0 91 01 01 	lds	r31, 0x0101
    1498:	80 e0       	ldi	r24, 0x00	; 0
    149a:	09 95       	icall
    149c:	01 50       	subi	r16, 0x01	; 1
    149e:	07 ff       	sbrs	r16, 7
    14a0:	f7 cf       	rjmp	.-18     	; 0x1490 <DF_ContinuousReadEnable+0x6a>
    14a2:	1f 91       	pop	r17
    14a4:	0f 91       	pop	r16
    14a6:	ff 90       	pop	r15
    14a8:	ef 90       	pop	r14
    14aa:	08 95       	ret

000014ac <DF_BufferWriteEnable>:
    14ac:	0f 93       	push	r16
    14ae:	1f 93       	push	r17
    14b0:	8c 01       	movw	r16, r24
    14b2:	80 e0       	ldi	r24, 0x00	; 0
    14b4:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    14b8:	00 00       	nop
    14ba:	81 e0       	ldi	r24, 0x01	; 1
    14bc:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    14c0:	e0 91 00 01 	lds	r30, 0x0100
    14c4:	f0 91 01 01 	lds	r31, 0x0101
    14c8:	84 e8       	ldi	r24, 0x84	; 132
    14ca:	09 95       	icall
    14cc:	e0 91 00 01 	lds	r30, 0x0100
    14d0:	f0 91 01 01 	lds	r31, 0x0101
    14d4:	80 e0       	ldi	r24, 0x00	; 0
    14d6:	09 95       	icall
    14d8:	81 2f       	mov	r24, r17
    14da:	99 27       	eor	r25, r25
    14dc:	e0 91 00 01 	lds	r30, 0x0100
    14e0:	f0 91 01 01 	lds	r31, 0x0101
    14e4:	09 95       	icall
    14e6:	e0 91 00 01 	lds	r30, 0x0100
    14ea:	f0 91 01 01 	lds	r31, 0x0101
    14ee:	80 2f       	mov	r24, r16
    14f0:	09 95       	icall
    14f2:	1f 91       	pop	r17
    14f4:	0f 91       	pop	r16
    14f6:	08 95       	ret

000014f8 <DF_GetChipCharacteristics>:
    14f8:	80 e0       	ldi	r24, 0x00	; 0
    14fa:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    14fe:	00 00       	nop
    1500:	81 e0       	ldi	r24, 0x01	; 1
    1502:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    1506:	e0 91 00 01 	lds	r30, 0x0100
    150a:	f0 91 01 01 	lds	r31, 0x0101
    150e:	87 e5       	ldi	r24, 0x57	; 87
    1510:	09 95       	icall
    1512:	e0 91 00 01 	lds	r30, 0x0100
    1516:	f0 91 01 01 	lds	r31, 0x0101
    151a:	80 e0       	ldi	r24, 0x00	; 0
    151c:	09 95       	icall
    151e:	68 2f       	mov	r22, r24
    1520:	77 27       	eor	r23, r23
    1522:	cb 01       	movw	r24, r22
    1524:	88 73       	andi	r24, 0x38	; 56
    1526:	90 70       	andi	r25, 0x00	; 0
    1528:	33 e0       	ldi	r19, 0x03	; 3
    152a:	95 95       	asr	r25
    152c:	87 95       	ror	r24
    152e:	3a 95       	dec	r19
    1530:	e1 f7       	brne	.-8      	; 0x152a <DF_GetChipCharacteristics+0x32>
    1532:	99 27       	eor	r25, r25
    1534:	fc 01       	movw	r30, r24
    1536:	e0 56       	subi	r30, 0x60	; 96
    1538:	fc 4f       	sbci	r31, 0xFC	; 252
    153a:	44 91       	lpm	r20, Z
    153c:	40 93 86 02 	sts	0x0286, r20
    1540:	9c 01       	movw	r18, r24
    1542:	28 0f       	add	r18, r24
    1544:	39 1f       	adc	r19, r25
    1546:	f9 01       	movw	r30, r18
    1548:	e0 57       	subi	r30, 0x70	; 112
    154a:	fc 4f       	sbci	r31, 0xFC	; 252
    154c:	85 91       	lpm	r24, Z+
    154e:	94 91       	lpm	r25, Z
    1550:	90 93 88 02 	sts	0x0288, r25
    1554:	80 93 87 02 	sts	0x0287, r24
    1558:	f9 01       	movw	r30, r18
    155a:	e0 58       	subi	r30, 0x80	; 128
    155c:	fc 4f       	sbci	r31, 0xFC	; 252
    155e:	85 91       	lpm	r24, Z+
    1560:	94 91       	lpm	r25, Z
    1562:	90 93 8a 02 	sts	0x028A, r25
    1566:	80 93 89 02 	sts	0x0289, r24
    156a:	80 e1       	ldi	r24, 0x10	; 16
    156c:	84 1b       	sub	r24, r20
    156e:	8a bd       	out	0x2a, r24	; 42
    1570:	48 50       	subi	r20, 0x08	; 8
    1572:	4b bd       	out	0x2b, r20	; 43
    1574:	cb 01       	movw	r24, r22
    1576:	08 95       	ret

00001578 <DF_ErasePage>:
    1578:	0f 93       	push	r16
    157a:	1f 93       	push	r17
    157c:	8c 01       	movw	r16, r24
    157e:	80 e0       	ldi	r24, 0x00	; 0
    1580:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    1584:	00 00       	nop
    1586:	81 e0       	ldi	r24, 0x01	; 1
    1588:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    158c:	e0 91 00 01 	lds	r30, 0x0100
    1590:	f0 91 01 01 	lds	r31, 0x0101
    1594:	81 e8       	ldi	r24, 0x81	; 129
    1596:	09 95       	icall
    1598:	8a b5       	in	r24, 0x2a	; 42
    159a:	98 01       	movw	r18, r16
    159c:	02 c0       	rjmp	.+4      	; 0x15a2 <DF_ErasePage+0x2a>
    159e:	36 95       	lsr	r19
    15a0:	27 95       	ror	r18
    15a2:	8a 95       	dec	r24
    15a4:	e2 f7       	brpl	.-8      	; 0x159e <DF_ErasePage+0x26>
    15a6:	c9 01       	movw	r24, r18
    15a8:	e0 91 00 01 	lds	r30, 0x0100
    15ac:	f0 91 01 01 	lds	r31, 0x0101
    15b0:	09 95       	icall
    15b2:	8b b5       	in	r24, 0x2b	; 43
    15b4:	02 c0       	rjmp	.+4      	; 0x15ba <DF_ErasePage+0x42>
    15b6:	00 0f       	add	r16, r16
    15b8:	11 1f       	adc	r17, r17
    15ba:	8a 95       	dec	r24
    15bc:	e2 f7       	brpl	.-8      	; 0x15b6 <DF_ErasePage+0x3e>
    15be:	e0 91 00 01 	lds	r30, 0x0100
    15c2:	f0 91 01 01 	lds	r31, 0x0101
    15c6:	80 2f       	mov	r24, r16
    15c8:	09 95       	icall
    15ca:	e0 91 00 01 	lds	r30, 0x0100
    15ce:	f0 91 01 01 	lds	r31, 0x0101
    15d2:	80 e0       	ldi	r24, 0x00	; 0
    15d4:	09 95       	icall
    15d6:	80 e0       	ldi	r24, 0x00	; 0
    15d8:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    15dc:	00 00       	nop
    15de:	81 e0       	ldi	r24, 0x01	; 1
    15e0:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    15e4:	0e 94 7c 0a 	call	0x14f8 <DF_GetChipCharacteristics>
    15e8:	88 23       	and	r24, r24
    15ea:	e4 f7       	brge	.-8      	; 0x15e4 <DF_ErasePage+0x6c>
    15ec:	1f 91       	pop	r17
    15ee:	0f 91       	pop	r16
    15f0:	08 95       	ret

000015f2 <DF_CopyFlashPageToBuffer>:
    15f2:	0f 93       	push	r16
    15f4:	1f 93       	push	r17
    15f6:	8c 01       	movw	r16, r24
    15f8:	80 e0       	ldi	r24, 0x00	; 0
    15fa:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    15fe:	00 00       	nop
    1600:	81 e0       	ldi	r24, 0x01	; 1
    1602:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    1606:	e0 91 00 01 	lds	r30, 0x0100
    160a:	f0 91 01 01 	lds	r31, 0x0101
    160e:	83 e5       	ldi	r24, 0x53	; 83
    1610:	09 95       	icall
    1612:	8a b5       	in	r24, 0x2a	; 42
    1614:	98 01       	movw	r18, r16
    1616:	02 c0       	rjmp	.+4      	; 0x161c <DF_CopyFlashPageToBuffer+0x2a>
    1618:	36 95       	lsr	r19
    161a:	27 95       	ror	r18
    161c:	8a 95       	dec	r24
    161e:	e2 f7       	brpl	.-8      	; 0x1618 <DF_CopyFlashPageToBuffer+0x26>
    1620:	c9 01       	movw	r24, r18
    1622:	e0 91 00 01 	lds	r30, 0x0100
    1626:	f0 91 01 01 	lds	r31, 0x0101
    162a:	09 95       	icall
    162c:	8b b5       	in	r24, 0x2b	; 43
    162e:	02 c0       	rjmp	.+4      	; 0x1634 <DF_CopyFlashPageToBuffer+0x42>
    1630:	00 0f       	add	r16, r16
    1632:	11 1f       	adc	r17, r17
    1634:	8a 95       	dec	r24
    1636:	e2 f7       	brpl	.-8      	; 0x1630 <DF_CopyFlashPageToBuffer+0x3e>
    1638:	e0 91 00 01 	lds	r30, 0x0100
    163c:	f0 91 01 01 	lds	r31, 0x0101
    1640:	80 2f       	mov	r24, r16
    1642:	09 95       	icall
    1644:	e0 91 00 01 	lds	r30, 0x0100
    1648:	f0 91 01 01 	lds	r31, 0x0101
    164c:	80 e0       	ldi	r24, 0x00	; 0
    164e:	09 95       	icall
    1650:	80 e0       	ldi	r24, 0x00	; 0
    1652:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    1656:	00 00       	nop
    1658:	81 e0       	ldi	r24, 0x01	; 1
    165a:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    165e:	0e 94 7c 0a 	call	0x14f8 <DF_GetChipCharacteristics>
    1662:	88 23       	and	r24, r24
    1664:	e4 f7       	brge	.-8      	; 0x165e <DF_CopyFlashPageToBuffer+0x6c>
    1666:	1f 91       	pop	r17
    1668:	0f 91       	pop	r16
    166a:	08 95       	ret

0000166c <DF_CopyBufferToFlashPage>:
    166c:	0f 93       	push	r16
    166e:	1f 93       	push	r17
    1670:	8c 01       	movw	r16, r24
    1672:	80 e0       	ldi	r24, 0x00	; 0
    1674:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    1678:	00 00       	nop
    167a:	81 e0       	ldi	r24, 0x01	; 1
    167c:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    1680:	e0 91 00 01 	lds	r30, 0x0100
    1684:	f0 91 01 01 	lds	r31, 0x0101
    1688:	83 e8       	ldi	r24, 0x83	; 131
    168a:	09 95       	icall
    168c:	8a b5       	in	r24, 0x2a	; 42
    168e:	98 01       	movw	r18, r16
    1690:	02 c0       	rjmp	.+4      	; 0x1696 <DF_CopyBufferToFlashPage+0x2a>
    1692:	36 95       	lsr	r19
    1694:	27 95       	ror	r18
    1696:	8a 95       	dec	r24
    1698:	e2 f7       	brpl	.-8      	; 0x1692 <DF_CopyBufferToFlashPage+0x26>
    169a:	c9 01       	movw	r24, r18
    169c:	e0 91 00 01 	lds	r30, 0x0100
    16a0:	f0 91 01 01 	lds	r31, 0x0101
    16a4:	09 95       	icall
    16a6:	8b b5       	in	r24, 0x2b	; 43
    16a8:	02 c0       	rjmp	.+4      	; 0x16ae <DF_CopyBufferToFlashPage+0x42>
    16aa:	00 0f       	add	r16, r16
    16ac:	11 1f       	adc	r17, r17
    16ae:	8a 95       	dec	r24
    16b0:	e2 f7       	brpl	.-8      	; 0x16aa <DF_CopyBufferToFlashPage+0x3e>
    16b2:	e0 91 00 01 	lds	r30, 0x0100
    16b6:	f0 91 01 01 	lds	r31, 0x0101
    16ba:	80 2f       	mov	r24, r16
    16bc:	09 95       	icall
    16be:	e0 91 00 01 	lds	r30, 0x0100
    16c2:	f0 91 01 01 	lds	r31, 0x0101
    16c6:	80 e0       	ldi	r24, 0x00	; 0
    16c8:	09 95       	icall
    16ca:	80 e0       	ldi	r24, 0x00	; 0
    16cc:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    16d0:	00 00       	nop
    16d2:	81 e0       	ldi	r24, 0x01	; 1
    16d4:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    16d8:	0e 94 7c 0a 	call	0x14f8 <DF_GetChipCharacteristics>
    16dc:	88 23       	and	r24, r24
    16de:	e4 f7       	brge	.-8      	; 0x16d8 <DF_CopyBufferToFlashPage+0x6c>
    16e0:	1f 91       	pop	r17
    16e2:	0f 91       	pop	r16
    16e4:	08 95       	ret

000016e6 <DF_CheckCorrectOnboardChip>:
    16e6:	0e 94 7c 0a 	call	0x14f8 <DF_GetChipCharacteristics>
    16ea:	80 91 86 02 	lds	r24, 0x0286
    16ee:	89 30       	cpi	r24, 0x09	; 9
    16f0:	61 f0       	breq	.+24     	; 0x170a <DF_CheckCorrectOnboardChip+0x24>
    16f2:	80 91 64 00 	lds	r24, 0x0064
    16f6:	84 60       	ori	r24, 0x04	; 4
    16f8:	80 93 64 00 	sts	0x0064, r24
    16fc:	80 e7       	ldi	r24, 0x70	; 112
    16fe:	93 e0       	ldi	r25, 0x03	; 3
    1700:	0e 94 68 03 	call	0x6d0 <MAIN_ShowError>
    1704:	80 e0       	ldi	r24, 0x00	; 0
    1706:	90 e0       	ldi	r25, 0x00	; 0
    1708:	08 95       	ret
    170a:	81 e0       	ldi	r24, 0x01	; 1
    170c:	90 e0       	ldi	r25, 0x00	; 0
    170e:	08 95       	ret

00001710 <BUFF_InitialiseBuffer>:

// Routines:
void BUFF_InitialiseBuffer(void)
{
	StoreLoc    = (BuffType*)&RingBuffer[0]; // Set up the IN pointer to the start of the buffer
    1710:	8d e8       	ldi	r24, 0x8D	; 141
    1712:	92 e0       	ldi	r25, 0x02	; 2
    1714:	90 93 ce 02 	sts	0x02CE, r25
    1718:	80 93 cd 02 	sts	0x02CD, r24
	RetrieveLoc = (BuffType*)&RingBuffer[0]; // Set up the OUT pointer to the start of the buffer
    171c:	90 93 d0 02 	sts	0x02D0, r25
    1720:	80 93 cf 02 	sts	0x02CF, r24

	BuffElements = 0;                     // Reset the buffer elements counter
    1724:	10 92 d1 02 	sts	0x02D1, r1
    1728:	08 95       	ret

0000172a <BUFF_StoreBuffByte>:
}

void BUFF_StoreBuffByte(BuffType DataToStore)
{
    172a:	98 2f       	mov	r25, r24
	if (BuffElements == BuffLen)          // Buffer full
    172c:	80 91 d1 02 	lds	r24, 0x02D1
    1730:	80 34       	cpi	r24, 0x40	; 64
    1732:	29 f4       	brne	.+10     	; 0x173e <BUFF_StoreBuffByte+0x14>
	{
		MAIN_ShowError(PSTR("BUFF OVERFLOW"));
    1734:	88 ea       	ldi	r24, 0xA8	; 168
    1736:	93 e0       	ldi	r25, 0x03	; 3
    1738:	0e 94 68 03 	call	0x6d0 <MAIN_ShowError>
		return;
    173c:	08 95       	ret
	}
		
	*StoreLoc = DataToStore;              // Store the data
    173e:	e0 91 cd 02 	lds	r30, 0x02CD
    1742:	f0 91 ce 02 	lds	r31, 0x02CE
    1746:	90 83       	st	Z, r25

	StoreLoc++;                           // Increment the IN pointer to the next element
    1748:	40 91 cd 02 	lds	r20, 0x02CD
    174c:	50 91 ce 02 	lds	r21, 0x02CE
    1750:	9a 01       	movw	r18, r20
    1752:	2f 5f       	subi	r18, 0xFF	; 255
    1754:	3f 4f       	sbci	r19, 0xFF	; 255
    1756:	30 93 ce 02 	sts	0x02CE, r19
    175a:	20 93 cd 02 	sts	0x02CD, r18
	BuffElements++;                       // Increment the total elements variable
    175e:	80 91 d1 02 	lds	r24, 0x02D1
    1762:	8f 5f       	subi	r24, 0xFF	; 255
    1764:	80 93 d1 02 	sts	0x02D1, r24

	if (StoreLoc == (BuffType*)&RingBuffer[BuffLen])
    1768:	2d 5c       	subi	r18, 0xCD	; 205
    176a:	32 40       	sbci	r19, 0x02	; 2
    176c:	31 f4       	brne	.+12     	; 0x177a <BUFF_StoreBuffByte+0x50>
		StoreLoc = (BuffType*)&RingBuffer[0]; // Wrap pointer if end of array reached
    176e:	4f 53       	subi	r20, 0x3F	; 63
    1770:	50 40       	sbci	r21, 0x00	; 0
    1772:	50 93 ce 02 	sts	0x02CE, r21
    1776:	40 93 cd 02 	sts	0x02CD, r20
    177a:	08 95       	ret

0000177c <BUFF_GetBuffByte>:
}	

BuffType BUFF_GetBuffByte(void)
{
	if (!(BuffElements))                  // No elements in the buffer
    177c:	80 91 d1 02 	lds	r24, 0x02D1
    1780:	88 23       	and	r24, r24
    1782:	19 f4       	brne	.+6      	; 0x178a <BUFF_GetBuffByte+0xe>
		return 0;
    1784:	80 e0       	ldi	r24, 0x00	; 0
    1786:	90 e0       	ldi	r25, 0x00	; 0
    1788:	08 95       	ret

	BuffType RetrievedData = *RetrieveLoc; // Grab the stored byte into a temp variable
    178a:	20 91 cf 02 	lds	r18, 0x02CF
    178e:	30 91 d0 02 	lds	r19, 0x02D0
    1792:	f9 01       	movw	r30, r18
    1794:	91 91       	ld	r25, Z+

	RetrieveLoc++;                         // Increment the OUT pointer to the next element if flag set
    1796:	f0 93 d0 02 	sts	0x02D0, r31
    179a:	e0 93 cf 02 	sts	0x02CF, r30
	BuffElements--;                        // Decrement the total elements variable
    179e:	80 91 d1 02 	lds	r24, 0x02D1
    17a2:	81 50       	subi	r24, 0x01	; 1
    17a4:	80 93 d1 02 	sts	0x02D1, r24
	
	if (RetrieveLoc == (BuffType*)&RingBuffer[BuffLen])
    17a8:	ed 5c       	subi	r30, 0xCD	; 205
    17aa:	f2 40       	sbci	r31, 0x02	; 2
    17ac:	31 f4       	brne	.+12     	; 0x17ba <BUFF_GetBuffByte+0x3e>
		RetrieveLoc = (BuffType*)&RingBuffer[0]; // Wrap pointer if end of array reached
    17ae:	2f 53       	subi	r18, 0x3F	; 63
    17b0:	30 40       	sbci	r19, 0x00	; 0
    17b2:	30 93 d0 02 	sts	0x02D0, r19
    17b6:	20 93 cf 02 	sts	0x02CF, r18
		
	return RetrievedData;                 // Return the retrieved data
    17ba:	89 2f       	mov	r24, r25
    17bc:	99 27       	eor	r25, r25
}
    17be:	08 95       	ret

000017c0 <__vector_9>:
// ======================================================================================

// Timeout = ((F_CPU / 64) / (65535 * TIMEOUT_TICKSBEFORETIMEOUT)) per second
ISR(TIMER1_OVF_vect, ISR_NOBLOCK)
{
    17c0:	78 94       	sei
    17c2:	1f 92       	push	r1
    17c4:	0f 92       	push	r0
    17c6:	0f b6       	in	r0, 0x3f	; 63
    17c8:	0f 92       	push	r0
    17ca:	11 24       	eor	r1, r1
    17cc:	8f 93       	push	r24
	if (Ticks++ == TIMEOUT_TICKSBEFORETIMEOUT)
    17ce:	80 91 29 01 	lds	r24, 0x0129
    17d2:	8f 5f       	subi	r24, 0xFF	; 255
    17d4:	80 93 29 01 	sts	0x0129, r24
    17d8:	80 91 29 01 	lds	r24, 0x0129
    17dc:	87 30       	cpi	r24, 0x07	; 7
    17de:	29 f4       	brne	.+10     	; 0x17ea <__vector_9+0x2a>
	{
	   Ticks   = 0;
    17e0:	10 92 29 01 	sts	0x0129, r1
	   TimeOut = TRUE;
    17e4:	81 e0       	ldi	r24, 0x01	; 1
    17e6:	80 93 28 01 	sts	0x0128, r24
    17ea:	8f 91       	pop	r24
    17ec:	0f 90       	pop	r0
    17ee:	0f be       	out	0x3f, r0	; 63
    17f0:	0f 90       	pop	r0
    17f2:	1f 90       	pop	r1
    17f4:	18 95       	reti

000017f6 <TIMEOUT_SetupTimeoutTimer>:
	}
}

// ======================================================================================

void TIMEOUT_SetupTimeoutTimer(void)
{
	TCCR1A = 0;
    17f6:	10 92 80 00 	sts	0x0080, r1
	TIMEOUT_TIMER_OFF();
    17fa:	10 92 81 00 	sts	0x0081, r1
    17fe:	10 92 29 01 	sts	0x0129, r1
    1802:	10 92 85 00 	sts	0x0085, r1
    1806:	10 92 84 00 	sts	0x0084, r1
	TCCR1C = 0;
    180a:	10 92 82 00 	sts	0x0082, r1
	
	TIMSK1 = (1 << TOIE1); // Turn timer 1 overflow interrupt on
    180e:	81 e0       	ldi	r24, 0x01	; 1
    1810:	80 93 6f 00 	sts	0x006F, r24
    1814:	08 95       	ret

00001816 <PD_SetupDFAddressCounters>:
}

void PD_SetupDFAddressCounters(void)
{
	uint32_t StartAddress = CurrAddress;
    1816:	20 91 2b 01 	lds	r18, 0x012B
    181a:	30 91 2c 01 	lds	r19, 0x012C
    181e:	40 91 2d 01 	lds	r20, 0x012D
    1822:	50 91 2e 01 	lds	r21, 0x012E

	CurrPageAddress = 0;
    1826:	10 92 8c 02 	sts	0x028C, r1
    182a:	10 92 8b 02 	sts	0x028B, r1

	while (StartAddress > DataflashInfo.PageSize)      // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DataflashInfo.PageSize;         // Subtract one page's worth of bytes from the desired address
		CurrPageAddress++;
    182e:	80 91 87 02 	lds	r24, 0x0287
    1832:	90 91 88 02 	lds	r25, 0x0288
    1836:	aa 27       	eor	r26, r26
    1838:	bb 27       	eor	r27, r27
    183a:	82 17       	cp	r24, r18
    183c:	93 07       	cpc	r25, r19
    183e:	a4 07       	cpc	r26, r20
    1840:	b5 07       	cpc	r27, r21
    1842:	88 f4       	brcc	.+34     	; 0x1866 <PD_SetupDFAddressCounters+0x50>
    1844:	60 e0       	ldi	r22, 0x00	; 0
    1846:	70 e0       	ldi	r23, 0x00	; 0
    1848:	28 1b       	sub	r18, r24
    184a:	39 0b       	sbc	r19, r25
    184c:	4a 0b       	sbc	r20, r26
    184e:	5b 0b       	sbc	r21, r27
    1850:	6f 5f       	subi	r22, 0xFF	; 255
    1852:	7f 4f       	sbci	r23, 0xFF	; 255
    1854:	82 17       	cp	r24, r18
    1856:	93 07       	cpc	r25, r19
    1858:	a4 07       	cpc	r26, r20
    185a:	b5 07       	cpc	r27, r21
    185c:	a8 f3       	brcs	.-22     	; 0x1848 <PD_SetupDFAddressCounters+0x32>
    185e:	70 93 8c 02 	sts	0x028C, r23
    1862:	60 93 8b 02 	sts	0x028B, r22
	}
	
	CurrBuffByte = (uint16_t)StartAddress;              // The buffer byte is the remainder
    1866:	30 93 85 02 	sts	0x0285, r19
    186a:	20 93 84 02 	sts	0x0284, r18
    186e:	08 95       	ret

00001870 <DF_StoreDataflashByte>:
}

void DF_StoreDataflashByte(uint8_t Data)
{
    1870:	cf 93       	push	r28
    1872:	c8 2f       	mov	r28, r24
	if (CurrBuffByte == DataflashInfo.PageSize)
    1874:	20 91 84 02 	lds	r18, 0x0284
    1878:	30 91 85 02 	lds	r19, 0x0285
    187c:	80 91 87 02 	lds	r24, 0x0287
    1880:	90 91 88 02 	lds	r25, 0x0288
    1884:	28 17       	cp	r18, r24
    1886:	39 07       	cpc	r19, r25
    1888:	a9 f4       	brne	.+42     	; 0x18b4 <DF_StoreDataflashByte+0x44>
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
    188a:	80 91 8b 02 	lds	r24, 0x028B
    188e:	90 91 8c 02 	lds	r25, 0x028C
    1892:	9c 01       	movw	r18, r24
    1894:	01 96       	adiw	r24, 0x01	; 1
    1896:	90 93 8c 02 	sts	0x028C, r25
    189a:	80 93 8b 02 	sts	0x028B, r24
    189e:	c9 01       	movw	r24, r18
    18a0:	0e 94 36 0b 	call	0x166c <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    18a4:	80 e0       	ldi	r24, 0x00	; 0
    18a6:	90 e0       	ldi	r25, 0x00	; 0
    18a8:	0e 94 56 0a 	call	0x14ac <DF_BufferWriteEnable>
		CurrBuffByte = 0;
    18ac:	10 92 85 02 	sts	0x0285, r1
    18b0:	10 92 84 02 	sts	0x0284, r1
	}
	
	USI_SPITransmit(Data);                                 // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    18b4:	8c 2f       	mov	r24, r28
    18b6:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
	CurrBuffByte++;
    18ba:	80 91 84 02 	lds	r24, 0x0284
    18be:	90 91 85 02 	lds	r25, 0x0285
    18c2:	01 96       	adiw	r24, 0x01	; 1
    18c4:	90 93 85 02 	sts	0x0285, r25
    18c8:	80 93 84 02 	sts	0x0284, r24
    18cc:	cf 91       	pop	r28
    18ce:	08 95       	ret

000018d0 <PD_InterpretAVRISPPacket>:
    18d0:	ef 92       	push	r14
    18d2:	ff 92       	push	r15
    18d4:	0f 93       	push	r16
    18d6:	1f 93       	push	r17
    18d8:	cf 93       	push	r28
    18da:	df 93       	push	r29
    18dc:	80 91 34 01 	lds	r24, 0x0134
    18e0:	99 27       	eor	r25, r25
    18e2:	86 31       	cpi	r24, 0x16	; 22
    18e4:	91 05       	cpc	r25, r1
    18e6:	09 f4       	brne	.+2      	; 0x18ea <PD_InterpretAVRISPPacket+0x1a>
    18e8:	04 c1       	rjmp	.+520    	; 0x1af2 <PD_InterpretAVRISPPacket+0x222>
    18ea:	87 31       	cpi	r24, 0x17	; 23
    18ec:	91 05       	cpc	r25, r1
    18ee:	b4 f4       	brge	.+44     	; 0x191c <PD_InterpretAVRISPPacket+0x4c>
    18f0:	82 31       	cpi	r24, 0x12	; 18
    18f2:	91 05       	cpc	r25, r1
    18f4:	09 f4       	brne	.+2      	; 0x18f8 <PD_InterpretAVRISPPacket+0x28>
    18f6:	69 c0       	rjmp	.+210    	; 0x19ca <PD_InterpretAVRISPPacket+0xfa>
    18f8:	83 31       	cpi	r24, 0x13	; 19
    18fa:	91 05       	cpc	r25, r1
    18fc:	3c f4       	brge	.+14     	; 0x190c <PD_InterpretAVRISPPacket+0x3c>
    18fe:	80 31       	cpi	r24, 0x10	; 16
    1900:	91 05       	cpc	r25, r1
    1902:	31 f1       	breq	.+76     	; 0x1950 <PD_InterpretAVRISPPacket+0x80>
    1904:	41 97       	sbiw	r24, 0x11	; 17
    1906:	09 f4       	brne	.+2      	; 0x190a <PD_InterpretAVRISPPacket+0x3a>
    1908:	46 c0       	rjmp	.+140    	; 0x1996 <PD_InterpretAVRISPPacket+0xc6>
    190a:	44 c1       	rjmp	.+648    	; 0x1b94 <PD_InterpretAVRISPPacket+0x2c4>
    190c:	84 31       	cpi	r24, 0x14	; 20
    190e:	91 05       	cpc	r25, r1
    1910:	09 f4       	brne	.+2      	; 0x1914 <PD_InterpretAVRISPPacket+0x44>
    1912:	90 c0       	rjmp	.+288    	; 0x1a34 <PD_InterpretAVRISPPacket+0x164>
    1914:	45 97       	sbiw	r24, 0x15	; 21
    1916:	0c f0       	brlt	.+2      	; 0x191a <PD_InterpretAVRISPPacket+0x4a>
    1918:	b3 c0       	rjmp	.+358    	; 0x1a80 <PD_InterpretAVRISPPacket+0x1b0>
    191a:	85 c0       	rjmp	.+266    	; 0x1a26 <PD_InterpretAVRISPPacket+0x156>
    191c:	89 31       	cpi	r24, 0x19	; 25
    191e:	91 05       	cpc	r25, r1
    1920:	09 f4       	brne	.+2      	; 0x1924 <PD_InterpretAVRISPPacket+0x54>
    1922:	76 c0       	rjmp	.+236    	; 0x1a10 <PD_InterpretAVRISPPacket+0x140>
    1924:	8a 31       	cpi	r24, 0x1A	; 26
    1926:	91 05       	cpc	r25, r1
    1928:	44 f4       	brge	.+16     	; 0x193a <PD_InterpretAVRISPPacket+0x6a>
    192a:	87 31       	cpi	r24, 0x17	; 23
    192c:	91 05       	cpc	r25, r1
    192e:	09 f4       	brne	.+2      	; 0x1932 <PD_InterpretAVRISPPacket+0x62>
    1930:	6f c0       	rjmp	.+222    	; 0x1a10 <PD_InterpretAVRISPPacket+0x140>
    1932:	48 97       	sbiw	r24, 0x18	; 24
    1934:	09 f4       	brne	.+2      	; 0x1938 <PD_InterpretAVRISPPacket+0x68>
    1936:	5e c0       	rjmp	.+188    	; 0x19f4 <PD_InterpretAVRISPPacket+0x124>
    1938:	2d c1       	rjmp	.+602    	; 0x1b94 <PD_InterpretAVRISPPacket+0x2c4>
    193a:	8b 31       	cpi	r24, 0x1B	; 27
    193c:	91 05       	cpc	r25, r1
    193e:	d9 f1       	breq	.+118    	; 0x19b6 <PD_InterpretAVRISPPacket+0xe6>
    1940:	8b 31       	cpi	r24, 0x1B	; 27
    1942:	91 05       	cpc	r25, r1
    1944:	0c f4       	brge	.+2      	; 0x1948 <PD_InterpretAVRISPPacket+0x78>
    1946:	56 c0       	rjmp	.+172    	; 0x19f4 <PD_InterpretAVRISPPacket+0x124>
    1948:	4c 97       	sbiw	r24, 0x1c	; 28
    194a:	09 f4       	brne	.+2      	; 0x194e <PD_InterpretAVRISPPacket+0x7e>
    194c:	53 c0       	rjmp	.+166    	; 0x19f4 <PD_InterpretAVRISPPacket+0x124>
    194e:	22 c1       	rjmp	.+580    	; 0x1b94 <PD_InterpretAVRISPPacket+0x2c4>
    1950:	82 e0       	ldi	r24, 0x02	; 2
    1952:	90 e0       	ldi	r25, 0x00	; 0
    1954:	90 93 31 01 	sts	0x0131, r25
    1958:	80 93 30 01 	sts	0x0130, r24
    195c:	81 e0       	ldi	r24, 0x01	; 1
    195e:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    1962:	0e 94 7c 0a 	call	0x14f8 <DF_GetChipCharacteristics>
    1966:	c0 91 86 02 	lds	r28, 0x0286
    196a:	cc 23       	and	r28, r28
    196c:	59 f0       	breq	.+22     	; 0x1984 <PD_InterpretAVRISPPacket+0xb4>
    196e:	86 eb       	ldi	r24, 0xB6	; 182
    1970:	93 e0       	ldi	r25, 0x03	; 3
    1972:	0e 94 f7 07 	call	0xfee <LCD_puts_f>
    1976:	81 e0       	ldi	r24, 0x01	; 1
    1978:	80 93 2f 01 	sts	0x012F, r24
    197c:	81 b3       	in	r24, 0x11	; 17
    197e:	8f 7c       	andi	r24, 0xCF	; 207
    1980:	80 62       	ori	r24, 0x20	; 32
    1982:	17 c0       	rjmp	.+46     	; 0x19b2 <PD_InterpretAVRISPPacket+0xe2>
    1984:	80 e7       	ldi	r24, 0x70	; 112
    1986:	93 e0       	ldi	r25, 0x03	; 3
    1988:	0e 94 f7 07 	call	0xfee <LCD_puts_f>
    198c:	8c 2f       	mov	r24, r28
    198e:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    1992:	80 ec       	ldi	r24, 0xC0	; 192
    1994:	06 c1       	rjmp	.+524    	; 0x1ba2 <PD_InterpretAVRISPPacket+0x2d2>
    1996:	82 e0       	ldi	r24, 0x02	; 2
    1998:	90 e0       	ldi	r25, 0x00	; 0
    199a:	90 93 31 01 	sts	0x0131, r25
    199e:	80 93 30 01 	sts	0x0130, r24
    19a2:	10 92 2f 01 	sts	0x012F, r1
    19a6:	80 e0       	ldi	r24, 0x00	; 0
    19a8:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    19ac:	81 b3       	in	r24, 0x11	; 17
    19ae:	8f 7c       	andi	r24, 0xCF	; 207
    19b0:	80 61       	ori	r24, 0x10	; 16
    19b2:	81 bb       	out	0x11, r24	; 17
    19b4:	9b c0       	rjmp	.+310    	; 0x1aec <PD_InterpretAVRISPPacket+0x21c>
    19b6:	84 e0       	ldi	r24, 0x04	; 4
    19b8:	90 e0       	ldi	r25, 0x00	; 0
    19ba:	90 93 31 01 	sts	0x0131, r25
    19be:	80 93 30 01 	sts	0x0130, r24
    19c2:	10 92 35 01 	sts	0x0135, r1
    19c6:	82 e0       	ldi	r24, 0x02	; 2
    19c8:	1e c0       	rjmp	.+60     	; 0x1a06 <PD_InterpretAVRISPPacket+0x136>
    19ca:	82 e0       	ldi	r24, 0x02	; 2
    19cc:	90 e0       	ldi	r25, 0x00	; 0
    19ce:	90 93 31 01 	sts	0x0131, r25
    19d2:	80 93 30 01 	sts	0x0130, r24
    19d6:	c0 e0       	ldi	r28, 0x00	; 0
    19d8:	d0 e0       	ldi	r29, 0x00	; 0
    19da:	80 91 89 02 	lds	r24, 0x0289
    19de:	90 91 8a 02 	lds	r25, 0x028A
    19e2:	c8 17       	cp	r28, r24
    19e4:	d9 07       	cpc	r29, r25
    19e6:	08 f0       	brcs	.+2      	; 0x19ea <PD_InterpretAVRISPPacket+0x11a>
    19e8:	81 c0       	rjmp	.+258    	; 0x1aec <PD_InterpretAVRISPPacket+0x21c>
    19ea:	ce 01       	movw	r24, r28
    19ec:	0e 94 bc 0a 	call	0x1578 <DF_ErasePage>
    19f0:	21 96       	adiw	r28, 0x01	; 1
    19f2:	f3 cf       	rjmp	.-26     	; 0x19da <PD_InterpretAVRISPPacket+0x10a>
    19f4:	84 e0       	ldi	r24, 0x04	; 4
    19f6:	90 e0       	ldi	r25, 0x00	; 0
    19f8:	90 93 31 01 	sts	0x0131, r25
    19fc:	80 93 30 01 	sts	0x0130, r24
    1a00:	10 92 35 01 	sts	0x0135, r1
    1a04:	8f ef       	ldi	r24, 0xFF	; 255
    1a06:	80 93 36 01 	sts	0x0136, r24
    1a0a:	10 92 37 01 	sts	0x0137, r1
    1a0e:	cb c0       	rjmp	.+406    	; 0x1ba6 <PD_InterpretAVRISPPacket+0x2d6>
    1a10:	83 e0       	ldi	r24, 0x03	; 3
    1a12:	90 e0       	ldi	r25, 0x00	; 0
    1a14:	90 93 31 01 	sts	0x0131, r25
    1a18:	80 93 30 01 	sts	0x0130, r24
    1a1c:	10 92 35 01 	sts	0x0135, r1
    1a20:	10 92 36 01 	sts	0x0136, r1
    1a24:	c0 c0       	rjmp	.+384    	; 0x1ba6 <PD_InterpretAVRISPPacket+0x2d6>
    1a26:	82 e0       	ldi	r24, 0x02	; 2
    1a28:	90 e0       	ldi	r25, 0x00	; 0
    1a2a:	90 93 31 01 	sts	0x0131, r25
    1a2e:	80 93 30 01 	sts	0x0130, r24
    1a32:	5c c0       	rjmp	.+184    	; 0x1aec <PD_InterpretAVRISPPacket+0x21c>
    1a34:	80 91 35 01 	lds	r24, 0x0135
    1a38:	99 27       	eor	r25, r25
    1a3a:	38 2f       	mov	r19, r24
    1a3c:	22 27       	eor	r18, r18
    1a3e:	80 91 36 01 	lds	r24, 0x0136
    1a42:	99 27       	eor	r25, r25
    1a44:	28 2b       	or	r18, r24
    1a46:	39 2b       	or	r19, r25
    1a48:	f9 01       	movw	r30, r18
    1a4a:	33 96       	adiw	r30, 0x03	; 3
    1a4c:	f0 93 31 01 	sts	0x0131, r31
    1a50:	e0 93 30 01 	sts	0x0130, r30
    1a54:	10 92 35 01 	sts	0x0135, r1
    1a58:	ed 5c       	subi	r30, 0xCD	; 205
    1a5a:	fe 4f       	sbci	r31, 0xFE	; 254
    1a5c:	10 82       	st	Z, r1
    1a5e:	81 e0       	ldi	r24, 0x01	; 1
    1a60:	90 e0       	ldi	r25, 0x00	; 0
    1a62:	28 0f       	add	r18, r24
    1a64:	39 1f       	adc	r19, r25
    1a66:	82 17       	cp	r24, r18
    1a68:	93 07       	cpc	r25, r19
    1a6a:	08 f0       	brcs	.+2      	; 0x1a6e <PD_InterpretAVRISPPacket+0x19e>
    1a6c:	9c c0       	rjmp	.+312    	; 0x1ba6 <PD_InterpretAVRISPPacket+0x2d6>
    1a6e:	4f ef       	ldi	r20, 0xFF	; 255
    1a70:	e5 e3       	ldi	r30, 0x35	; 53
    1a72:	f1 e0       	ldi	r31, 0x01	; 1
    1a74:	41 93       	st	Z+, r20
    1a76:	01 96       	adiw	r24, 0x01	; 1
    1a78:	82 17       	cp	r24, r18
    1a7a:	93 07       	cpc	r25, r19
    1a7c:	d8 f3       	brcs	.-10     	; 0x1a74 <PD_InterpretAVRISPPacket+0x1a4>
    1a7e:	93 c0       	rjmp	.+294    	; 0x1ba6 <PD_InterpretAVRISPPacket+0x2d6>
    1a80:	0e 94 0b 0c 	call	0x1816 <PD_SetupDFAddressCounters>
    1a84:	80 91 8b 02 	lds	r24, 0x028B
    1a88:	90 91 8c 02 	lds	r25, 0x028C
    1a8c:	0e 94 f9 0a 	call	0x15f2 <DF_CopyFlashPageToBuffer>
    1a90:	80 91 84 02 	lds	r24, 0x0284
    1a94:	90 91 85 02 	lds	r25, 0x0285
    1a98:	0e 94 56 0a 	call	0x14ac <DF_BufferWriteEnable>
    1a9c:	80 91 35 01 	lds	r24, 0x0135
    1aa0:	99 27       	eor	r25, r25
    1aa2:	d8 2f       	mov	r29, r24
    1aa4:	cc 27       	eor	r28, r28
    1aa6:	80 91 36 01 	lds	r24, 0x0136
    1aaa:	99 27       	eor	r25, r25
    1aac:	c8 2b       	or	r28, r24
    1aae:	d9 2b       	or	r29, r25
    1ab0:	00 e0       	ldi	r16, 0x00	; 0
    1ab2:	10 e0       	ldi	r17, 0x00	; 0
    1ab4:	0c 17       	cp	r16, r28
    1ab6:	1d 07       	cpc	r17, r29
    1ab8:	c8 f4       	brcc	.+50     	; 0x1aec <PD_InterpretAVRISPPacket+0x21c>
    1aba:	3e e3       	ldi	r19, 0x3E	; 62
    1abc:	e3 2e       	mov	r14, r19
    1abe:	31 e0       	ldi	r19, 0x01	; 1
    1ac0:	f3 2e       	mov	r15, r19
    1ac2:	f7 01       	movw	r30, r14
    1ac4:	81 91       	ld	r24, Z+
    1ac6:	7f 01       	movw	r14, r30
    1ac8:	0e 94 38 0c 	call	0x1870 <DF_StoreDataflashByte>
    1acc:	80 91 84 02 	lds	r24, 0x0284
    1ad0:	90 91 85 02 	lds	r25, 0x0285
    1ad4:	01 96       	adiw	r24, 0x01	; 1
    1ad6:	90 93 85 02 	sts	0x0285, r25
    1ada:	80 93 84 02 	sts	0x0284, r24
    1ade:	0e 94 d7 0e 	call	0x1dae <V2P_IncrementCurrAddress>
    1ae2:	0f 5f       	subi	r16, 0xFF	; 255
    1ae4:	1f 4f       	sbci	r17, 0xFF	; 255
    1ae6:	0c 17       	cp	r16, r28
    1ae8:	1d 07       	cpc	r17, r29
    1aea:	58 f3       	brcs	.-42     	; 0x1ac2 <PD_InterpretAVRISPPacket+0x1f2>
    1aec:	10 92 35 01 	sts	0x0135, r1
    1af0:	5a c0       	rjmp	.+180    	; 0x1ba6 <PD_InterpretAVRISPPacket+0x2d6>
    1af2:	0e 94 0b 0c 	call	0x1816 <PD_SetupDFAddressCounters>
    1af6:	80 91 8b 02 	lds	r24, 0x028B
    1afa:	90 91 8c 02 	lds	r25, 0x028C
    1afe:	0e 94 f9 0a 	call	0x15f2 <DF_CopyFlashPageToBuffer>
    1b02:	80 91 35 01 	lds	r24, 0x0135
    1b06:	99 27       	eor	r25, r25
    1b08:	d8 2f       	mov	r29, r24
    1b0a:	cc 27       	eor	r28, r28
    1b0c:	80 91 36 01 	lds	r24, 0x0136
    1b10:	99 27       	eor	r25, r25
    1b12:	c8 2b       	or	r28, r24
    1b14:	d9 2b       	or	r29, r25
    1b16:	00 e0       	ldi	r16, 0x00	; 0
    1b18:	10 e0       	ldi	r17, 0x00	; 0
    1b1a:	0c 17       	cp	r16, r28
    1b1c:	1d 07       	cpc	r17, r29
    1b1e:	70 f5       	brcc	.+92     	; 0x1b7c <PD_InterpretAVRISPPacket+0x2ac>
    1b20:	86 e3       	ldi	r24, 0x36	; 54
    1b22:	e8 2e       	mov	r14, r24
    1b24:	81 e0       	ldi	r24, 0x01	; 1
    1b26:	f8 2e       	mov	r15, r24
    1b28:	20 91 84 02 	lds	r18, 0x0284
    1b2c:	30 91 85 02 	lds	r19, 0x0285
    1b30:	80 91 87 02 	lds	r24, 0x0287
    1b34:	90 91 88 02 	lds	r25, 0x0288
    1b38:	28 17       	cp	r18, r24
    1b3a:	39 07       	cpc	r19, r25
    1b3c:	41 f4       	brne	.+16     	; 0x1b4e <PD_InterpretAVRISPPacket+0x27e>
    1b3e:	0e 94 0b 0c 	call	0x1816 <PD_SetupDFAddressCounters>
    1b42:	80 91 8b 02 	lds	r24, 0x028B
    1b46:	90 91 8c 02 	lds	r25, 0x028C
    1b4a:	0e 94 f9 0a 	call	0x15f2 <DF_CopyFlashPageToBuffer>
    1b4e:	80 91 84 02 	lds	r24, 0x0284
    1b52:	90 91 85 02 	lds	r25, 0x0285
    1b56:	9c 01       	movw	r18, r24
    1b58:	01 96       	adiw	r24, 0x01	; 1
    1b5a:	90 93 85 02 	sts	0x0285, r25
    1b5e:	80 93 84 02 	sts	0x0284, r24
    1b62:	c9 01       	movw	r24, r18
    1b64:	0e 94 e6 09 	call	0x13cc <DF_ReadBufferByte>
    1b68:	f7 01       	movw	r30, r14
    1b6a:	81 93       	st	Z+, r24
    1b6c:	7f 01       	movw	r14, r30
    1b6e:	0e 94 d7 0e 	call	0x1dae <V2P_IncrementCurrAddress>
    1b72:	0f 5f       	subi	r16, 0xFF	; 255
    1b74:	1f 4f       	sbci	r17, 0xFF	; 255
    1b76:	0c 17       	cp	r16, r28
    1b78:	1d 07       	cpc	r17, r29
    1b7a:	b0 f2       	brcs	.-84     	; 0x1b28 <PD_InterpretAVRISPPacket+0x258>
    1b7c:	23 96       	adiw	r28, 0x03	; 3
    1b7e:	d0 93 31 01 	sts	0x0131, r29
    1b82:	c0 93 30 01 	sts	0x0130, r28
    1b86:	23 97       	sbiw	r28, 0x03	; 3
    1b88:	10 92 35 01 	sts	0x0135, r1
    1b8c:	cc 5c       	subi	r28, 0xCC	; 204
    1b8e:	de 4f       	sbci	r29, 0xFE	; 254
    1b90:	1a 82       	std	Y+2, r1	; 0x02
    1b92:	09 c0       	rjmp	.+18     	; 0x1ba6 <PD_InterpretAVRISPPacket+0x2d6>
    1b94:	81 e0       	ldi	r24, 0x01	; 1
    1b96:	90 e0       	ldi	r25, 0x00	; 0
    1b98:	90 93 31 01 	sts	0x0131, r25
    1b9c:	80 93 30 01 	sts	0x0130, r24
    1ba0:	89 ec       	ldi	r24, 0xC9	; 201
    1ba2:	80 93 35 01 	sts	0x0135, r24
    1ba6:	0e 94 fd 0d 	call	0x1bfa <V2P_SendPacket>
    1baa:	df 91       	pop	r29
    1bac:	cf 91       	pop	r28
    1bae:	1f 91       	pop	r17
    1bb0:	0f 91       	pop	r16
    1bb2:	ff 90       	pop	r15
    1bb4:	ef 90       	pop	r14
    1bb6:	08 95       	ret

00001bb8 <V2P_GetChecksum>:
	
	/* Checksum for the V2 protocol is comprised of an XOR of all the packet 
      bytes, including the start, sequence number, size and token bytes.    */
	
	CheckSumByte  = MESSAGE_START;
    1bb8:	6b e1       	ldi	r22, 0x1B	; 27
	CheckSumByte ^= SequenceNum;
    1bba:	80 91 32 01 	lds	r24, 0x0132
    1bbe:	68 27       	eor	r22, r24
	CheckSumByte ^= (uint8_t)(MessageSize >> 8);
    1bc0:	20 91 30 01 	lds	r18, 0x0130
    1bc4:	30 91 31 01 	lds	r19, 0x0131
    1bc8:	83 2f       	mov	r24, r19
    1bca:	99 27       	eor	r25, r25
    1bcc:	68 27       	eor	r22, r24
	CheckSumByte ^= (uint8_t)(MessageSize);
    1bce:	80 91 30 01 	lds	r24, 0x0130
    1bd2:	68 27       	eor	r22, r24
	CheckSumByte ^= TOKEN;
    1bd4:	8e e0       	ldi	r24, 0x0E	; 14
    1bd6:	68 27       	eor	r22, r24
	
	for(uint16_t CByteIndex = 0; CByteIndex < MessageSize; CByteIndex++)
    1bd8:	40 e0       	ldi	r20, 0x00	; 0
    1bda:	50 e0       	ldi	r21, 0x00	; 0
    1bdc:	42 17       	cp	r20, r18
    1bde:	53 07       	cpc	r21, r19
    1be0:	48 f4       	brcc	.+18     	; 0x1bf4 <V2P_GetChecksum+0x3c>
    1be2:	e4 e3       	ldi	r30, 0x34	; 52
    1be4:	f1 e0       	ldi	r31, 0x01	; 1
		CheckSumByte ^= PacketBytes[CByteIndex];
    1be6:	81 91       	ld	r24, Z+
    1be8:	68 27       	eor	r22, r24
    1bea:	4f 5f       	subi	r20, 0xFF	; 255
    1bec:	5f 4f       	sbci	r21, 0xFF	; 255
    1bee:	42 17       	cp	r20, r18
    1bf0:	53 07       	cpc	r21, r19
    1bf2:	c8 f3       	brcs	.-14     	; 0x1be6 <V2P_GetChecksum+0x2e>

	return CheckSumByte;
}
    1bf4:	86 2f       	mov	r24, r22
    1bf6:	99 27       	eor	r25, r25
    1bf8:	08 95       	ret

00001bfa <V2P_SendPacket>:
    1bfa:	0f 93       	push	r16
    1bfc:	1f 93       	push	r17
    1bfe:	cf 93       	push	r28
    1c00:	df 93       	push	r29
    1c02:	8b e1       	ldi	r24, 0x1B	; 27
    1c04:	0e 94 e7 08 	call	0x11ce <USART_Tx>
    1c08:	80 91 32 01 	lds	r24, 0x0132
    1c0c:	0e 94 e7 08 	call	0x11ce <USART_Tx>
    1c10:	80 91 31 01 	lds	r24, 0x0131
    1c14:	0e 94 e7 08 	call	0x11ce <USART_Tx>
    1c18:	80 91 30 01 	lds	r24, 0x0130
    1c1c:	0e 94 e7 08 	call	0x11ce <USART_Tx>
    1c20:	8e e0       	ldi	r24, 0x0E	; 14
    1c22:	0e 94 e7 08 	call	0x11ce <USART_Tx>
    1c26:	c0 e0       	ldi	r28, 0x00	; 0
    1c28:	d0 e0       	ldi	r29, 0x00	; 0
    1c2a:	80 91 30 01 	lds	r24, 0x0130
    1c2e:	90 91 31 01 	lds	r25, 0x0131
    1c32:	c8 17       	cp	r28, r24
    1c34:	d9 07       	cpc	r29, r25
    1c36:	78 f4       	brcc	.+30     	; 0x1c56 <V2P_SendPacket+0x5c>
    1c38:	04 e3       	ldi	r16, 0x34	; 52
    1c3a:	11 e0       	ldi	r17, 0x01	; 1
    1c3c:	f8 01       	movw	r30, r16
    1c3e:	81 91       	ld	r24, Z+
    1c40:	8f 01       	movw	r16, r30
    1c42:	0e 94 e7 08 	call	0x11ce <USART_Tx>
    1c46:	21 96       	adiw	r28, 0x01	; 1
    1c48:	80 91 30 01 	lds	r24, 0x0130
    1c4c:	90 91 31 01 	lds	r25, 0x0131
    1c50:	c8 17       	cp	r28, r24
    1c52:	d9 07       	cpc	r29, r25
    1c54:	98 f3       	brcs	.-26     	; 0x1c3c <V2P_SendPacket+0x42>
    1c56:	0e 94 dc 0d 	call	0x1bb8 <V2P_GetChecksum>
    1c5a:	0e 94 e7 08 	call	0x11ce <USART_Tx>
    1c5e:	80 91 32 01 	lds	r24, 0x0132
    1c62:	90 91 33 01 	lds	r25, 0x0133
    1c66:	01 96       	adiw	r24, 0x01	; 1
    1c68:	90 93 33 01 	sts	0x0133, r25
    1c6c:	80 93 32 01 	sts	0x0132, r24
    1c70:	df 91       	pop	r29
    1c72:	cf 91       	pop	r28
    1c74:	1f 91       	pop	r17
    1c76:	0f 91       	pop	r16
    1c78:	08 95       	ret

00001c7a <V2P_GetSetParamater>:

void V2P_GetSetParamater(void)
{
	uint8_t Param_Name = PacketBytes[1];    // Save the parameter number
    1c7a:	20 91 35 01 	lds	r18, 0x0135

	MessageSize = 3;                        // Set the default response message size to 3 bytes     
    1c7e:	83 e0       	ldi	r24, 0x03	; 3
    1c80:	90 e0       	ldi	r25, 0x00	; 0
    1c82:	90 93 31 01 	sts	0x0131, r25
    1c86:	80 93 30 01 	sts	0x0130, r24
	PacketBytes[1] = STATUS_CMD_OK;         // Set the default response to OK
    1c8a:	10 92 35 01 	sts	0x0135, r1

	switch (Param_Name)                    // Switch based on the recieved parameter byte
    1c8e:	e2 2f       	mov	r30, r18
    1c90:	ff 27       	eor	r31, r31
    1c92:	e8 39       	cpi	r30, 0x98	; 152
    1c94:	f1 05       	cpc	r31, r1
    1c96:	ac f4       	brge	.+42     	; 0x1cc2 <V2P_GetSetParamater+0x48>
    1c98:	e6 39       	cpi	r30, 0x96	; 150
    1c9a:	f1 05       	cpc	r31, r1
    1c9c:	0c f0       	brlt	.+2      	; 0x1ca0 <V2P_GetSetParamater+0x26>
    1c9e:	6d c0       	rjmp	.+218    	; 0x1d7a <V2P_GetSetParamater+0x100>
    1ca0:	e1 38       	cpi	r30, 0x81	; 129
    1ca2:	f1 05       	cpc	r31, r1
    1ca4:	f9 f0       	breq	.+62     	; 0x1ce4 <V2P_GetSetParamater+0x6a>
    1ca6:	e2 38       	cpi	r30, 0x82	; 130
    1ca8:	f1 05       	cpc	r31, r1
    1caa:	24 f4       	brge	.+8      	; 0x1cb4 <V2P_GetSetParamater+0x3a>
    1cac:	e0 38       	cpi	r30, 0x80	; 128
    1cae:	f1 05       	cpc	r31, r1
    1cb0:	b9 f0       	breq	.+46     	; 0x1ce0 <V2P_GetSetParamater+0x66>
    1cb2:	71 c0       	rjmp	.+226    	; 0x1d96 <V2P_GetSetParamater+0x11c>
    1cb4:	cf 01       	movw	r24, r30
    1cb6:	80 59       	subi	r24, 0x90	; 144
    1cb8:	90 40       	sbci	r25, 0x00	; 0
    1cba:	03 97       	sbiw	r24, 0x03	; 3
    1cbc:	08 f0       	brcs	.+2      	; 0x1cc0 <V2P_GetSetParamater+0x46>
    1cbe:	6b c0       	rjmp	.+214    	; 0x1d96 <V2P_GetSetParamater+0x11c>
    1cc0:	13 c0       	rjmp	.+38     	; 0x1ce8 <V2P_GetSetParamater+0x6e>
    1cc2:	ee 39       	cpi	r30, 0x9E	; 158
    1cc4:	f1 05       	cpc	r31, r1
    1cc6:	09 f4       	brne	.+2      	; 0x1cca <V2P_GetSetParamater+0x50>
    1cc8:	3d c0       	rjmp	.+122    	; 0x1d44 <V2P_GetSetParamater+0xca>
    1cca:	ef 39       	cpi	r30, 0x9F	; 159
    1ccc:	f1 05       	cpc	r31, r1
    1cce:	24 f4       	brge	.+8      	; 0x1cd8 <V2P_GetSetParamater+0x5e>
    1cd0:	e8 39       	cpi	r30, 0x98	; 152
    1cd2:	f1 05       	cpc	r31, r1
    1cd4:	f9 f0       	breq	.+62     	; 0x1d14 <V2P_GetSetParamater+0x9a>
    1cd6:	5f c0       	rjmp	.+190    	; 0x1d96 <V2P_GetSetParamater+0x11c>
    1cd8:	ef 39       	cpi	r30, 0x9F	; 159
    1cda:	f1 05       	cpc	r31, r1
    1cdc:	49 f0       	breq	.+18     	; 0x1cf0 <V2P_GetSetParamater+0x76>
    1cde:	5b c0       	rjmp	.+182    	; 0x1d96 <V2P_GetSetParamater+0x11c>
	{
		case PARAM_BUILD_NUMBER_LOW:
			PacketBytes[2] = VERSION_MINOR;
    1ce0:	83 e0       	ldi	r24, 0x03	; 3
    1ce2:	38 c0       	rjmp	.+112    	; 0x1d54 <V2P_GetSetParamater+0xda>

			break;
		case PARAM_BUILD_NUMBER_HIGH:
			PacketBytes[2] = VERSION_MAJOR;
    1ce4:	81 e0       	ldi	r24, 0x01	; 1
    1ce6:	36 c0       	rjmp	.+108    	; 0x1d54 <V2P_GetSetParamater+0xda>

			break;
		case PARAM_HARDWARE_VERSION:
		case PARAM_SW_MAJOR:
		case PARAM_SW_MINOR:
			PacketBytes[2] = pgm_read_byte(&VersionData[Param_Name - PARAM_HARDWARE_VERSION]);
    1ce8:	ee 5b       	subi	r30, 0xBE	; 190
    1cea:	fc 4f       	sbci	r31, 0xFC	; 252
    1cec:	84 91       	lpm	r24, Z
    1cee:	32 c0       	rjmp	.+100    	; 0x1d54 <V2P_GetSetParamater+0xda>

			break;
		case PARAM_CONTROLLER_INIT:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1cf0:	80 91 34 01 	lds	r24, 0x0134
    1cf4:	83 30       	cpi	r24, 0x03	; 3
    1cf6:	19 f4       	brne	.+6      	; 0x1cfe <V2P_GetSetParamater+0x84>
			{
				PacketBytes[2] = Param_ControllerInit;
    1cf8:	80 91 2a 01 	lds	r24, 0x012A
    1cfc:	2b c0       	rjmp	.+86     	; 0x1d54 <V2P_GetSetParamater+0xda>
			}
			else
			{
				MessageSize = 2;
    1cfe:	82 e0       	ldi	r24, 0x02	; 2
    1d00:	90 e0       	ldi	r25, 0x00	; 0
    1d02:	90 93 31 01 	sts	0x0131, r25
    1d06:	80 93 30 01 	sts	0x0130, r24
				Param_ControllerInit = PacketBytes[2];
    1d0a:	80 91 36 01 	lds	r24, 0x0136
    1d0e:	80 93 2a 01 	sts	0x012A, r24
			}
			
			break;
    1d12:	4a c0       	rjmp	.+148    	; 0x1da8 <V2P_GetSetParamater+0x12e>
		case PARAM_SCK_DURATION:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1d14:	80 91 34 01 	lds	r24, 0x0134
    1d18:	83 30       	cpi	r24, 0x03	; 3
    1d1a:	19 f4       	brne	.+6      	; 0x1d22 <V2P_GetSetParamater+0xa8>
			{
				PacketBytes[2] = eeprom_read_byte_169(&Param_SCKDuration);
    1d1c:	80 e2       	ldi	r24, 0x20	; 32
    1d1e:	91 e0       	ldi	r25, 0x01	; 1
    1d20:	17 c0       	rjmp	.+46     	; 0x1d50 <V2P_GetSetParamater+0xd6>
			}
			else
			{
				MessageSize = 2;
    1d22:	82 e0       	ldi	r24, 0x02	; 2
    1d24:	90 e0       	ldi	r25, 0x00	; 0
    1d26:	90 93 31 01 	sts	0x0131, r25
    1d2a:	80 93 30 01 	sts	0x0130, r24
				eeprom_write_byte_169(&Param_SCKDuration, PacketBytes[2]);
    1d2e:	60 91 36 01 	lds	r22, 0x0136
    1d32:	80 e2       	ldi	r24, 0x20	; 32
    1d34:	91 e0       	ldi	r25, 0x01	; 1
    1d36:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
				USI_SPISetSpeed(PacketBytes[2]); // Re-Initialise the USI system with the new frequency
    1d3a:	80 91 36 01 	lds	r24, 0x0136
    1d3e:	0e 94 6a 09 	call	0x12d4 <USI_SPISetSpeed>
			}
					
			break;
    1d42:	32 c0       	rjmp	.+100    	; 0x1da8 <V2P_GetSetParamater+0x12e>
		case PARAM_RESET_POLARITY:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1d44:	80 91 34 01 	lds	r24, 0x0134
    1d48:	83 30       	cpi	r24, 0x03	; 3
    1d4a:	39 f4       	brne	.+14     	; 0x1d5a <V2P_GetSetParamater+0xe0>
			{
				PacketBytes[2] = eeprom_read_byte_169(&Param_ResetPolarity);		
    1d4c:	82 e2       	ldi	r24, 0x22	; 34
    1d4e:	91 e0       	ldi	r25, 0x01	; 1
    1d50:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
    1d54:	80 93 36 01 	sts	0x0136, r24
    1d58:	27 c0       	rjmp	.+78     	; 0x1da8 <V2P_GetSetParamater+0x12e>
			}
			else
			{
				MessageSize = 2;
    1d5a:	82 e0       	ldi	r24, 0x02	; 2
    1d5c:	90 e0       	ldi	r25, 0x00	; 0
    1d5e:	90 93 31 01 	sts	0x0131, r25
    1d62:	80 93 30 01 	sts	0x0130, r24
				eeprom_write_byte_169(&Param_ResetPolarity, PacketBytes[2]);
    1d66:	60 91 36 01 	lds	r22, 0x0136
    1d6a:	82 e2       	ldi	r24, 0x22	; 34
    1d6c:	91 e0       	ldi	r25, 0x01	; 1
    1d6e:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Change takes effect immediatly
    1d72:	81 e0       	ldi	r24, 0x01	; 1
    1d74:	0e 94 13 03 	call	0x626 <MAIN_ResetCSLine>
			}
			
			break;
    1d78:	17 c0       	rjmp	.+46     	; 0x1da8 <V2P_GetSetParamater+0x12e>
		case PARAM_OSC_PSCALE:
		case PARAM_OSC_CMATCH:
			/* Despite not supporting these parameters (STK500 only), the AVR Studio programmer
			   sends them along with the SCK duration. A OK must be returned or the sequence will fail
			   and the SCK duration byte will not be sent.                                             */
		
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1d7a:	80 91 34 01 	lds	r24, 0x0134
    1d7e:	83 30       	cpi	r24, 0x03	; 3
    1d80:	19 f4       	brne	.+6      	; 0x1d88 <V2P_GetSetParamater+0x10e>
			{
			   PacketBytes[2] = 0;            // If the command is a read, return a 0 for both parameters
    1d82:	10 92 36 01 	sts	0x0136, r1
    1d86:	10 c0       	rjmp	.+32     	; 0x1da8 <V2P_GetSetParamater+0x12e>
			}
			else
			{
				MessageSize = 2;              // Otherwise just send back an OK if the command is a set		
    1d88:	82 e0       	ldi	r24, 0x02	; 2
    1d8a:	90 e0       	ldi	r25, 0x00	; 0
    1d8c:	90 93 31 01 	sts	0x0131, r25
    1d90:	80 93 30 01 	sts	0x0130, r24
			}
			
			break;
    1d94:	09 c0       	rjmp	.+18     	; 0x1da8 <V2P_GetSetParamater+0x12e>
		default:                             // Unrecognised parameter
			MessageSize = 2;
    1d96:	82 e0       	ldi	r24, 0x02	; 2
    1d98:	90 e0       	ldi	r25, 0x00	; 0
    1d9a:	90 93 31 01 	sts	0x0131, r25
    1d9e:	80 93 30 01 	sts	0x0130, r24
			PacketBytes[1] = STATUS_CMD_FAILED;			
    1da2:	80 ec       	ldi	r24, 0xC0	; 192
    1da4:	80 93 35 01 	sts	0x0135, r24
	}
	
	V2P_SendPacket();
    1da8:	0e 94 fd 0d 	call	0x1bfa <V2P_SendPacket>
    1dac:	08 95       	ret

00001dae <V2P_IncrementCurrAddress>:
}

void V2P_IncrementCurrAddress(void)
{
	// Incrementing a 32-bit unsigned variable takes a lot of code. Because much of the code is
	// not very time critical (much of it is waiting for the hardware), i've chosen to waste
	// a few extra cycles per increment and save a good 60 bytes or so of code space by putting
	// the incrmement inside a function.

	CurrAddress++;
    1dae:	80 91 2b 01 	lds	r24, 0x012B
    1db2:	90 91 2c 01 	lds	r25, 0x012C
    1db6:	a0 91 2d 01 	lds	r26, 0x012D
    1dba:	b0 91 2e 01 	lds	r27, 0x012E
    1dbe:	01 96       	adiw	r24, 0x01	; 1
    1dc0:	a1 1d       	adc	r26, r1
    1dc2:	b1 1d       	adc	r27, r1
    1dc4:	80 93 2b 01 	sts	0x012B, r24
    1dc8:	90 93 2c 01 	sts	0x012C, r25
    1dcc:	a0 93 2d 01 	sts	0x012D, r26
    1dd0:	b0 93 2e 01 	sts	0x012E, r27
    1dd4:	08 95       	ret

00001dd6 <V2P_CheckForExtendedAddress>:
}

void V2P_CheckForExtendedAddress(void)
{
	if (CurrAddress & (1UL << 31))                     // MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
    1dd6:	80 91 2b 01 	lds	r24, 0x012B
    1dda:	90 91 2c 01 	lds	r25, 0x012C
    1dde:	a0 91 2d 01 	lds	r26, 0x012D
    1de2:	b0 91 2e 01 	lds	r27, 0x012E
    1de6:	b7 ff       	sbrs	r27, 7
    1de8:	1e c0       	rjmp	.+60     	; 0x1e26 <V2P_CheckForExtendedAddress+0x50>
	{
		USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);   // Load extended address command
    1dea:	8d e4       	ldi	r24, 0x4D	; 77
    1dec:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1df0:	80 e0       	ldi	r24, 0x00	; 0
    1df2:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
		USI_SPITransmit((CurrAddress & 0x00FF0000) >> 16); // The 3rd byte of the long holds the extended address
    1df6:	80 91 2d 01 	lds	r24, 0x012D
    1dfa:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1dfe:	80 e0       	ldi	r24, 0x00	; 0
    1e00:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
		
		CurrAddress &= ~(1UL << 31);                   // Clear the flag
    1e04:	80 91 2b 01 	lds	r24, 0x012B
    1e08:	90 91 2c 01 	lds	r25, 0x012C
    1e0c:	a0 91 2d 01 	lds	r26, 0x012D
    1e10:	b0 91 2e 01 	lds	r27, 0x012E
    1e14:	bf 77       	andi	r27, 0x7F	; 127
    1e16:	80 93 2b 01 	sts	0x012B, r24
    1e1a:	90 93 2c 01 	sts	0x012C, r25
    1e1e:	a0 93 2d 01 	sts	0x012D, r26
    1e22:	b0 93 2e 01 	sts	0x012E, r27
    1e26:	08 95       	ret

00001e28 <V2P_RunStateMachine>:
    1e28:	ef 92       	push	r14
    1e2a:	ff 92       	push	r15
    1e2c:	0f 93       	push	r16
    1e2e:	1f 93       	push	r17
    1e30:	cf 93       	push	r28
    1e32:	c0 e0       	ldi	r28, 0x00	; 0
    1e34:	ee 24       	eor	r14, r14
    1e36:	ff 24       	eor	r15, r15
    1e38:	80 91 c1 00 	lds	r24, 0x00C1
    1e3c:	80 78       	andi	r24, 0x80	; 128
    1e3e:	88 61       	ori	r24, 0x18	; 24
    1e40:	80 93 c1 00 	sts	0x00C1, r24
    1e44:	0e 94 88 0b 	call	0x1710 <BUFF_InitialiseBuffer>
    1e48:	0e 94 fb 0b 	call	0x17f6 <TIMEOUT_SetupTimeoutTimer>
    1e4c:	c0 93 2f 01 	sts	0x012F, r28
    1e50:	81 e0       	ldi	r24, 0x01	; 1
    1e52:	90 e0       	ldi	r25, 0x00	; 0
    1e54:	90 93 33 01 	sts	0x0133, r25
    1e58:	80 93 32 01 	sts	0x0132, r24
    1e5c:	10 92 2b 01 	sts	0x012B, r1
    1e60:	10 92 2c 01 	sts	0x012C, r1
    1e64:	10 92 2d 01 	sts	0x012D, r1
    1e68:	10 92 2e 01 	sts	0x012E, r1
    1e6c:	80 91 28 01 	lds	r24, 0x0128
    1e70:	81 30       	cpi	r24, 0x01	; 1
    1e72:	11 f4       	brne	.+4      	; 0x1e78 <V2P_RunStateMachine+0x50>
    1e74:	c9 e0       	ldi	r28, 0x09	; 9
    1e76:	05 c0       	rjmp	.+10     	; 0x1e82 <V2P_RunStateMachine+0x5a>
    1e78:	cc 23       	and	r28, r28
    1e7a:	19 f0       	breq	.+6      	; 0x1e82 <V2P_RunStateMachine+0x5a>
    1e7c:	83 e0       	ldi	r24, 0x03	; 3
    1e7e:	80 93 81 00 	sts	0x0081, r24
    1e82:	8c 2f       	mov	r24, r28
    1e84:	99 27       	eor	r25, r25
    1e86:	84 30       	cpi	r24, 0x04	; 4
    1e88:	91 05       	cpc	r25, r1
    1e8a:	09 f4       	brne	.+2      	; 0x1e8e <V2P_RunStateMachine+0x66>
    1e8c:	6d c0       	rjmp	.+218    	; 0x1f68 <V2P_RunStateMachine+0x140>
    1e8e:	85 30       	cpi	r24, 0x05	; 5
    1e90:	91 05       	cpc	r25, r1
    1e92:	94 f4       	brge	.+36     	; 0x1eb8 <V2P_RunStateMachine+0x90>
    1e94:	81 30       	cpi	r24, 0x01	; 1
    1e96:	91 05       	cpc	r25, r1
    1e98:	09 f4       	brne	.+2      	; 0x1e9c <V2P_RunStateMachine+0x74>
    1e9a:	4c c0       	rjmp	.+152    	; 0x1f34 <V2P_RunStateMachine+0x10c>
    1e9c:	82 30       	cpi	r24, 0x02	; 2
    1e9e:	91 05       	cpc	r25, r1
    1ea0:	1c f4       	brge	.+6      	; 0x1ea8 <V2P_RunStateMachine+0x80>
    1ea2:	89 2b       	or	r24, r25
    1ea4:	b1 f1       	breq	.+108    	; 0x1f12 <V2P_RunStateMachine+0xea>
    1ea6:	e2 cf       	rjmp	.-60     	; 0x1e6c <V2P_RunStateMachine+0x44>
    1ea8:	82 30       	cpi	r24, 0x02	; 2
    1eaa:	91 05       	cpc	r25, r1
    1eac:	09 f4       	brne	.+2      	; 0x1eb0 <V2P_RunStateMachine+0x88>
    1eae:	48 c0       	rjmp	.+144    	; 0x1f40 <V2P_RunStateMachine+0x118>
    1eb0:	03 97       	sbiw	r24, 0x03	; 3
    1eb2:	09 f4       	brne	.+2      	; 0x1eb6 <V2P_RunStateMachine+0x8e>
    1eb4:	4e c0       	rjmp	.+156    	; 0x1f52 <V2P_RunStateMachine+0x12a>
    1eb6:	da cf       	rjmp	.-76     	; 0x1e6c <V2P_RunStateMachine+0x44>
    1eb8:	87 30       	cpi	r24, 0x07	; 7
    1eba:	91 05       	cpc	r25, r1
    1ebc:	09 f4       	brne	.+2      	; 0x1ec0 <V2P_RunStateMachine+0x98>
    1ebe:	85 c0       	rjmp	.+266    	; 0x1fca <V2P_RunStateMachine+0x1a2>
    1ec0:	88 30       	cpi	r24, 0x08	; 8
    1ec2:	91 05       	cpc	r25, r1
    1ec4:	44 f4       	brge	.+16     	; 0x1ed6 <V2P_RunStateMachine+0xae>
    1ec6:	85 30       	cpi	r24, 0x05	; 5
    1ec8:	91 05       	cpc	r25, r1
    1eca:	09 f4       	brne	.+2      	; 0x1ece <V2P_RunStateMachine+0xa6>
    1ecc:	62 c0       	rjmp	.+196    	; 0x1f92 <V2P_RunStateMachine+0x16a>
    1ece:	06 97       	sbiw	r24, 0x06	; 6
    1ed0:	09 f4       	brne	.+2      	; 0x1ed4 <V2P_RunStateMachine+0xac>
    1ed2:	67 c0       	rjmp	.+206    	; 0x1fa2 <V2P_RunStateMachine+0x17a>
    1ed4:	cb cf       	rjmp	.-106    	; 0x1e6c <V2P_RunStateMachine+0x44>
    1ed6:	88 30       	cpi	r24, 0x08	; 8
    1ed8:	91 05       	cpc	r25, r1
    1eda:	79 f0       	breq	.+30     	; 0x1efa <V2P_RunStateMachine+0xd2>
    1edc:	09 97       	sbiw	r24, 0x09	; 9
    1ede:	31 f6       	brne	.-116    	; 0x1e6c <V2P_RunStateMachine+0x44>
    1ee0:	82 e0       	ldi	r24, 0x02	; 2
    1ee2:	90 e0       	ldi	r25, 0x00	; 0
    1ee4:	90 93 31 01 	sts	0x0131, r25
    1ee8:	80 93 30 01 	sts	0x0130, r24
    1eec:	80 ec       	ldi	r24, 0xC0	; 192
    1eee:	80 93 35 01 	sts	0x0135, r24
    1ef2:	10 92 28 01 	sts	0x0128, r1
    1ef6:	0e 94 fd 0d 	call	0x1bfa <V2P_SendPacket>
    1efa:	0e 94 88 0b 	call	0x1710 <BUFF_InitialiseBuffer>
    1efe:	10 92 81 00 	sts	0x0081, r1
    1f02:	10 92 29 01 	sts	0x0129, r1
    1f06:	10 92 85 00 	sts	0x0085, r1
    1f0a:	10 92 84 00 	sts	0x0084, r1
    1f0e:	c0 e0       	ldi	r28, 0x00	; 0
    1f10:	ad cf       	rjmp	.-166    	; 0x1e6c <V2P_RunStateMachine+0x44>
    1f12:	80 91 d1 02 	lds	r24, 0x02D1
    1f16:	81 11       	cpse	r24, r1
    1f18:	c1 e0       	ldi	r28, 0x01	; 1
    1f1a:	f2 9b       	sbis	0x1e, 2	; 30
    1f1c:	a7 cf       	rjmp	.-178    	; 0x1e6c <V2P_RunStateMachine+0x44>
    1f1e:	80 91 2f 01 	lds	r24, 0x012F
    1f22:	88 23       	and	r24, r24
    1f24:	09 f0       	breq	.+2      	; 0x1f28 <V2P_RunStateMachine+0x100>
    1f26:	a2 cf       	rjmp	.-188    	; 0x1e6c <V2P_RunStateMachine+0x44>
    1f28:	80 91 c1 00 	lds	r24, 0x00C1
    1f2c:	80 78       	andi	r24, 0x80	; 128
    1f2e:	80 93 c1 00 	sts	0x00C1, r24
    1f32:	d4 c0       	rjmp	.+424    	; 0x20dc <V2P_RunStateMachine+0x2b4>
    1f34:	0e 94 fe 08 	call	0x11fc <USART_Rx>
    1f38:	8b 31       	cpi	r24, 0x1B	; 27
    1f3a:	89 f5       	brne	.+98     	; 0x1f9e <V2P_RunStateMachine+0x176>
    1f3c:	c2 e0       	ldi	r28, 0x02	; 2
    1f3e:	96 cf       	rjmp	.-212    	; 0x1e6c <V2P_RunStateMachine+0x44>
    1f40:	0e 94 fe 08 	call	0x11fc <USART_Rx>
    1f44:	99 27       	eor	r25, r25
    1f46:	90 93 33 01 	sts	0x0133, r25
    1f4a:	80 93 32 01 	sts	0x0132, r24
    1f4e:	c3 e0       	ldi	r28, 0x03	; 3
    1f50:	8d cf       	rjmp	.-230    	; 0x1e6c <V2P_RunStateMachine+0x44>
    1f52:	0e 94 fe 08 	call	0x11fc <USART_Rx>
    1f56:	99 27       	eor	r25, r25
    1f58:	98 2f       	mov	r25, r24
    1f5a:	88 27       	eor	r24, r24
    1f5c:	90 93 31 01 	sts	0x0131, r25
    1f60:	80 93 30 01 	sts	0x0130, r24
    1f64:	c4 e0       	ldi	r28, 0x04	; 4
    1f66:	82 cf       	rjmp	.-252    	; 0x1e6c <V2P_RunStateMachine+0x44>
    1f68:	0e 94 fe 08 	call	0x11fc <USART_Rx>
    1f6c:	28 2f       	mov	r18, r24
    1f6e:	33 27       	eor	r19, r19
    1f70:	80 91 30 01 	lds	r24, 0x0130
    1f74:	90 91 31 01 	lds	r25, 0x0131
    1f78:	82 2b       	or	r24, r18
    1f7a:	93 2b       	or	r25, r19
    1f7c:	90 93 31 01 	sts	0x0131, r25
    1f80:	80 93 30 01 	sts	0x0130, r24
    1f84:	83 51       	subi	r24, 0x13	; 19
    1f86:	91 40       	sbci	r25, 0x01	; 1
    1f88:	50 f4       	brcc	.+20     	; 0x1f9e <V2P_RunStateMachine+0x176>
    1f8a:	c5 e0       	ldi	r28, 0x05	; 5
    1f8c:	ee 24       	eor	r14, r14
    1f8e:	ff 24       	eor	r15, r15
    1f90:	6d cf       	rjmp	.-294    	; 0x1e6c <V2P_RunStateMachine+0x44>
    1f92:	0e 94 fe 08 	call	0x11fc <USART_Rx>
    1f96:	8e 30       	cpi	r24, 0x0E	; 14
    1f98:	11 f4       	brne	.+4      	; 0x1f9e <V2P_RunStateMachine+0x176>
    1f9a:	c6 e0       	ldi	r28, 0x06	; 6
    1f9c:	67 cf       	rjmp	.-306    	; 0x1e6c <V2P_RunStateMachine+0x44>
    1f9e:	c9 e0       	ldi	r28, 0x09	; 9
    1fa0:	65 cf       	rjmp	.-310    	; 0x1e6c <V2P_RunStateMachine+0x44>
    1fa2:	80 91 30 01 	lds	r24, 0x0130
    1fa6:	90 91 31 01 	lds	r25, 0x0131
    1faa:	e8 16       	cp	r14, r24
    1fac:	f9 06       	cpc	r15, r25
    1fae:	11 f4       	brne	.+4      	; 0x1fb4 <V2P_RunStateMachine+0x18c>
    1fb0:	c7 e0       	ldi	r28, 0x07	; 7
    1fb2:	5c cf       	rjmp	.-328    	; 0x1e6c <V2P_RunStateMachine+0x44>
    1fb4:	87 01       	movw	r16, r14
    1fb6:	0c 5c       	subi	r16, 0xCC	; 204
    1fb8:	1e 4f       	sbci	r17, 0xFE	; 254
    1fba:	08 94       	sec
    1fbc:	e1 1c       	adc	r14, r1
    1fbe:	f1 1c       	adc	r15, r1
    1fc0:	0e 94 fe 08 	call	0x11fc <USART_Rx>
    1fc4:	f8 01       	movw	r30, r16
    1fc6:	80 83       	st	Z, r24
    1fc8:	51 cf       	rjmp	.-350    	; 0x1e6c <V2P_RunStateMachine+0x44>
    1fca:	0e 94 dc 0d 	call	0x1bb8 <V2P_GetChecksum>
    1fce:	18 2f       	mov	r17, r24
    1fd0:	0e 94 fe 08 	call	0x11fc <USART_Rx>
    1fd4:	18 17       	cp	r17, r24
    1fd6:	09 f0       	breq	.+2      	; 0x1fda <V2P_RunStateMachine+0x1b2>
    1fd8:	74 c0       	rjmp	.+232    	; 0x20c2 <V2P_RunStateMachine+0x29a>
    1fda:	80 91 34 01 	lds	r24, 0x0134
    1fde:	99 27       	eor	r25, r25
    1fe0:	84 30       	cpi	r24, 0x04	; 4
    1fe2:	91 05       	cpc	r25, r1
    1fe4:	3c f4       	brge	.+14     	; 0x1ff4 <V2P_RunStateMachine+0x1cc>
    1fe6:	82 30       	cpi	r24, 0x02	; 2
    1fe8:	91 05       	cpc	r25, r1
    1fea:	0c f0       	brlt	.+2      	; 0x1fee <V2P_RunStateMachine+0x1c6>
    1fec:	61 c0       	rjmp	.+194    	; 0x20b0 <V2P_RunStateMachine+0x288>
    1fee:	01 97       	sbiw	r24, 0x01	; 1
    1ff0:	39 f0       	breq	.+14     	; 0x2000 <V2P_RunStateMachine+0x1d8>
    1ff2:	61 c0       	rjmp	.+194    	; 0x20b6 <V2P_RunStateMachine+0x28e>
    1ff4:	86 30       	cpi	r24, 0x06	; 6
    1ff6:	91 05       	cpc	r25, r1
    1ff8:	e9 f0       	breq	.+58     	; 0x2034 <V2P_RunStateMachine+0x20c>
    1ffa:	07 97       	sbiw	r24, 0x07	; 7
    1ffc:	99 f0       	breq	.+38     	; 0x2024 <V2P_RunStateMachine+0x1fc>
    1ffe:	5b c0       	rjmp	.+182    	; 0x20b6 <V2P_RunStateMachine+0x28e>
    2000:	8b e0       	ldi	r24, 0x0B	; 11
    2002:	90 e0       	ldi	r25, 0x00	; 0
    2004:	90 93 31 01 	sts	0x0131, r25
    2008:	80 93 30 01 	sts	0x0130, r24
    200c:	a4 e3       	ldi	r26, 0x34	; 52
    200e:	b1 e0       	ldi	r27, 0x01	; 1
    2010:	e7 ec       	ldi	r30, 0xC7	; 199
    2012:	f3 e0       	ldi	r31, 0x03	; 3
    2014:	9a e0       	ldi	r25, 0x0A	; 10
    2016:	84 91       	lpm	r24, Z
    2018:	8d 93       	st	X+, r24
    201a:	91 50       	subi	r25, 0x01	; 1
    201c:	31 96       	adiw	r30, 0x01	; 1
    201e:	97 ff       	sbrs	r25, 7
    2020:	fa cf       	rjmp	.-12     	; 0x2016 <V2P_RunStateMachine+0x1ee>
    2022:	58 c0       	rjmp	.+176    	; 0x20d4 <V2P_RunStateMachine+0x2ac>
    2024:	82 e0       	ldi	r24, 0x02	; 2
    2026:	90 e0       	ldi	r25, 0x00	; 0
    2028:	90 93 31 01 	sts	0x0131, r25
    202c:	80 93 30 01 	sts	0x0130, r24
    2030:	80 ec       	ldi	r24, 0xC0	; 192
    2032:	4e c0       	rjmp	.+156    	; 0x20d0 <V2P_RunStateMachine+0x2a8>
    2034:	82 e0       	ldi	r24, 0x02	; 2
    2036:	90 e0       	ldi	r25, 0x00	; 0
    2038:	90 93 31 01 	sts	0x0131, r25
    203c:	80 93 30 01 	sts	0x0130, r24
    2040:	0e 94 eb 0e 	call	0x1dd6 <V2P_CheckForExtendedAddress>
    2044:	80 91 35 01 	lds	r24, 0x0135
    2048:	99 27       	eor	r25, r25
    204a:	aa 27       	eor	r26, r26
    204c:	bb 27       	eor	r27, r27
    204e:	b8 2f       	mov	r27, r24
    2050:	aa 27       	eor	r26, r26
    2052:	99 27       	eor	r25, r25
    2054:	88 27       	eor	r24, r24
    2056:	20 91 36 01 	lds	r18, 0x0136
    205a:	33 27       	eor	r19, r19
    205c:	44 27       	eor	r20, r20
    205e:	55 27       	eor	r21, r21
    2060:	a9 01       	movw	r20, r18
    2062:	33 27       	eor	r19, r19
    2064:	22 27       	eor	r18, r18
    2066:	82 2b       	or	r24, r18
    2068:	93 2b       	or	r25, r19
    206a:	a4 2b       	or	r26, r20
    206c:	b5 2b       	or	r27, r21
    206e:	20 91 37 01 	lds	r18, 0x0137
    2072:	33 27       	eor	r19, r19
    2074:	44 27       	eor	r20, r20
    2076:	55 27       	eor	r21, r21
    2078:	54 2f       	mov	r21, r20
    207a:	43 2f       	mov	r20, r19
    207c:	32 2f       	mov	r19, r18
    207e:	22 27       	eor	r18, r18
    2080:	82 2b       	or	r24, r18
    2082:	93 2b       	or	r25, r19
    2084:	a4 2b       	or	r26, r20
    2086:	b5 2b       	or	r27, r21
    2088:	20 91 38 01 	lds	r18, 0x0138
    208c:	33 27       	eor	r19, r19
    208e:	44 27       	eor	r20, r20
    2090:	55 27       	eor	r21, r21
    2092:	82 2b       	or	r24, r18
    2094:	93 2b       	or	r25, r19
    2096:	a4 2b       	or	r26, r20
    2098:	b5 2b       	or	r27, r21
    209a:	80 93 2b 01 	sts	0x012B, r24
    209e:	90 93 2c 01 	sts	0x012C, r25
    20a2:	a0 93 2d 01 	sts	0x012D, r26
    20a6:	b0 93 2e 01 	sts	0x012E, r27
    20aa:	10 92 35 01 	sts	0x0135, r1
    20ae:	12 c0       	rjmp	.+36     	; 0x20d4 <V2P_RunStateMachine+0x2ac>
    20b0:	0e 94 3d 0e 	call	0x1c7a <V2P_GetSetParamater>
    20b4:	11 c0       	rjmp	.+34     	; 0x20d8 <V2P_RunStateMachine+0x2b0>
    20b6:	e0 91 24 01 	lds	r30, 0x0124
    20ba:	f0 91 25 01 	lds	r31, 0x0125
    20be:	09 95       	icall
    20c0:	0b c0       	rjmp	.+22     	; 0x20d8 <V2P_RunStateMachine+0x2b0>
    20c2:	82 e0       	ldi	r24, 0x02	; 2
    20c4:	90 e0       	ldi	r25, 0x00	; 0
    20c6:	90 93 31 01 	sts	0x0131, r25
    20ca:	80 93 30 01 	sts	0x0130, r24
    20ce:	81 ec       	ldi	r24, 0xC1	; 193
    20d0:	80 93 35 01 	sts	0x0135, r24
    20d4:	0e 94 fd 0d 	call	0x1bfa <V2P_SendPacket>
    20d8:	c8 e0       	ldi	r28, 0x08	; 8
    20da:	c8 ce       	rjmp	.-624    	; 0x1e6c <V2P_RunStateMachine+0x44>
    20dc:	cf 91       	pop	r28
    20de:	1f 91       	pop	r17
    20e0:	0f 91       	pop	r16
    20e2:	ff 90       	pop	r15
    20e4:	ef 90       	pop	r14
    20e6:	08 95       	ret

000020e8 <ISPCC_EnterChipProgrammingMode>:

// ======================================================================================

void ISPCC_EnterChipProgrammingMode(void)
{
    20e8:	0f 93       	push	r16
    20ea:	1f 93       	push	r17
    20ec:	cf 93       	push	r28
	uint8_t ByteDelay = PacketBytes[5];
    20ee:	10 91 39 01 	lds	r17, 0x0139
	uint8_t Attempts  = PacketBytes[4];
    20f2:	c0 91 38 01 	lds	r28, 0x0138
	uint8_t Response;

	MAIN_Delay1MS(PacketBytes[2]);         // Wait before continuing, amount specified in the packet
    20f6:	80 91 36 01 	lds	r24, 0x0136
    20fa:	0e 94 01 03 	call	0x602 <MAIN_Delay1MS>

	if ((!(Attempts)) || (Attempts > 100)) // Safety - if no attempts or too high a value is specified, a fixed number is chosen
    20fe:	8c 2f       	mov	r24, r28
    2100:	81 50       	subi	r24, 0x01	; 1
    2102:	84 36       	cpi	r24, 0x64	; 100
    2104:	08 f0       	brcs	.+2      	; 0x2108 <ISPCC_EnterChipProgrammingMode+0x20>
	   Attempts = 24;
    2106:	c8 e1       	ldi	r28, 0x18	; 24
		
	while (Attempts--)
	{
		USI_SPITransmit(PacketBytes[8]);
		MAIN_Delay1MS(ByteDelay);
		USI_SPITransmit(PacketBytes[9]);
		MAIN_Delay1MS(ByteDelay);
			
		Response = USI_SPITransmit(PacketBytes[10]);
		MAIN_Delay1MS(ByteDelay);

		if(PacketBytes[7] == ISPCC_POLL_MODE_AVR)
		  USI_SPITransmit(PacketBytes[11]);
		else
		  Response = USI_SPITransmit(PacketBytes[11]);
				
		if(!(PacketBytes[7]) || (Response == PacketBytes[6])) // Polling disabled, or returned value matches expected poll value
		{
			MAIN_Delay1MS(ByteDelay);

			InProgrammingMode = TRUE;
			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = STATUS_CMD_OK;
			return;
		}
		
		MAIN_Delay1MS(ByteDelay);
		USI_SPIToggleClock();            // Out of sync, shift in one bit and try again
    2108:	c1 50       	subi	r28, 0x01	; 1
    210a:	cf 3f       	cpi	r28, 0xFF	; 255
    210c:	09 f4       	brne	.+2      	; 0x2110 <ISPCC_EnterChipProgrammingMode+0x28>
    210e:	3f c0       	rjmp	.+126    	; 0x218e <ISPCC_EnterChipProgrammingMode+0xa6>
    2110:	80 91 3c 01 	lds	r24, 0x013C
    2114:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    2118:	81 2f       	mov	r24, r17
    211a:	0e 94 01 03 	call	0x602 <MAIN_Delay1MS>
    211e:	80 91 3d 01 	lds	r24, 0x013D
    2122:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    2126:	81 2f       	mov	r24, r17
    2128:	0e 94 01 03 	call	0x602 <MAIN_Delay1MS>
    212c:	80 91 3e 01 	lds	r24, 0x013E
    2130:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    2134:	08 2f       	mov	r16, r24
    2136:	81 2f       	mov	r24, r17
    2138:	0e 94 01 03 	call	0x602 <MAIN_Delay1MS>
    213c:	80 91 3b 01 	lds	r24, 0x013B
    2140:	83 30       	cpi	r24, 0x03	; 3
    2142:	29 f4       	brne	.+10     	; 0x214e <ISPCC_EnterChipProgrammingMode+0x66>
    2144:	80 91 3f 01 	lds	r24, 0x013F
    2148:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    214c:	05 c0       	rjmp	.+10     	; 0x2158 <ISPCC_EnterChipProgrammingMode+0x70>
    214e:	80 91 3f 01 	lds	r24, 0x013F
    2152:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    2156:	08 2f       	mov	r16, r24
    2158:	80 91 3b 01 	lds	r24, 0x013B
    215c:	88 23       	and	r24, r24
    215e:	21 f0       	breq	.+8      	; 0x2168 <ISPCC_EnterChipProgrammingMode+0x80>
    2160:	80 91 3a 01 	lds	r24, 0x013A
    2164:	08 17       	cp	r16, r24
    2166:	69 f4       	brne	.+26     	; 0x2182 <ISPCC_EnterChipProgrammingMode+0x9a>
    2168:	81 2f       	mov	r24, r17
    216a:	0e 94 01 03 	call	0x602 <MAIN_Delay1MS>
    216e:	81 e0       	ldi	r24, 0x01	; 1
    2170:	80 93 2f 01 	sts	0x012F, r24
    2174:	81 b3       	in	r24, 0x11	; 17
    2176:	8f 7c       	andi	r24, 0xCF	; 207
    2178:	80 62       	ori	r24, 0x20	; 32
    217a:	81 bb       	out	0x11, r24	; 17
    217c:	10 92 35 01 	sts	0x0135, r1
    2180:	0d c0       	rjmp	.+26     	; 0x219c <ISPCC_EnterChipProgrammingMode+0xb4>
    2182:	81 2f       	mov	r24, r17
    2184:	0e 94 01 03 	call	0x602 <MAIN_Delay1MS>
    2188:	0e 94 c0 09 	call	0x1380 <USI_SPIToggleClock>
    218c:	bd cf       	rjmp	.-134    	; 0x2108 <ISPCC_EnterChipProgrammingMode+0x20>
	}

	// If function hasn't returned by now, all the attempts have failed. Show this by
	// resetting the status leds to green (ready) and send a fail message.

	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
    218e:	81 b3       	in	r24, 0x11	; 17
    2190:	8f 7c       	andi	r24, 0xCF	; 207
    2192:	80 61       	ori	r24, 0x10	; 16
    2194:	81 bb       	out	0x11, r24	; 17
	PacketBytes[1] = STATUS_CMD_FAILED;
    2196:	80 ec       	ldi	r24, 0xC0	; 192
    2198:	80 93 35 01 	sts	0x0135, r24
    219c:	cf 91       	pop	r28
    219e:	1f 91       	pop	r17
    21a0:	0f 91       	pop	r16
    21a2:	08 95       	ret

000021a4 <ISPCC_PollForProgComplete>:
}

void ISPCC_ProgramChip(void)
{
	uint16_t PollAddress  = 0;
	uint8_t  ProgMode     = PacketBytes[3];
	uint8_t  WriteCommand = PacketBytes[5];
	uint16_t StartAddress = (uint16_t)CurrAddress;
	uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
	                      | PacketBytes[2];
	uint8_t  PollType;
	uint8_t  ByteToWrite;
			
	if (ProgMode & ISPCC_PROG_MODE_PAGE)                 // Page writing mode
	{
		for (uint16_t WriteByte = 0; WriteByte < BytesToWrite; WriteByte++) // Transmit the page bytes
		{
			ByteToWrite = PacketBytes[10 + WriteByte];
		
			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) // Flash write mode - word addresses so MSB/LSB masking 
			   USI_SPITransmit(WriteCommand | ((WriteByte & 0x01)? ISPCC_HIGH_BYTE_WRITE : ISPCC_LOW_BYTE_WRITE));
			else                                         // EEPROM write mode - byte addresses so no masking 
			   USI_SPITransmit(WriteCommand);

			USI_SPITransmitWord(CurrAddress & 0xFFFF);    // Only the LSW of the address should be sent
			USI_SPITransmit(ByteToWrite);                 // Send one of the new bytes to be written

			if (!(PollAddress))
			{
				if ((PacketBytes[8] != ByteToWrite)       // Can do polling
				   && ((PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) || ((PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP) && (PacketBytes[9] != ByteToWrite))))
				{
					PollAddress = (CurrAddress & 0xFFFF); // Save the current address
				
					if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
					   PollAddress = ((PollAddress << 1) + (WriteByte & 0x01));
				}
			}

			// Flash addresses are in words; only increment address on odd byte, OR if it's the EEPROM being programmed (byte addresses)
			if ((WriteByte & 0x01) || (PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP))
			   V2P_IncrementCurrAddress();
		}

		PollType = ProgMode;

		if (ProgMode & ISPCC_PROG_MODE_PAGEDONE)         // If this packet is the end of a page, we need to send the program page command
		{
			USI_SPITransmit(PacketBytes[6]);             // Send the write program memory page command
			USI_SPITransmitWord(StartAddress);           // Send the page address word
			USI_SPITransmit(0x00);

			if (!(PollAddress))                          // No polling address
			   PollType = ((ProgMode & ~ISPCC_PAGE_POLLTYPE_MASK) | ISPCC_PAGE_POLLTYPE_WAIT);

			ISPCC_PollForProgComplete(PollType, PollAddress);
		}
	}
	else                                                 // Flash Word writing mode or EEPROM byte writing mode
	{
		for (uint16_t WriteByte = 0; WriteByte < BytesToWrite; WriteByte++)
		{
			ByteToWrite = PacketBytes[10 + WriteByte];

			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
			   USI_SPITransmit(WriteCommand | ((WriteByte & 0x01)? ISPCC_HIGH_BYTE_WRITE : ISPCC_LOW_BYTE_WRITE));
			else
			   USI_SPITransmit(WriteCommand);					
					
			USI_SPITransmitWord(CurrAddress & 0xFFFF);    // Transmit the current address to the slave AVR
			USI_SPITransmit(ByteToWrite);                 // Send one of the new bytes to be written

			PollType = ProgMode;

			if ((PacketBytes[8] != ByteToWrite)           // Can do polling
			   && ((PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) || ((PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP) && (PacketBytes[9] != ByteToWrite))))
			{
				PollAddress = (CurrAddress & 0xFFFF);     // Save the current address;

				if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
				   PollAddress = ((PollAddress << 1) + (WriteByte & 0x01));
			}
			else
			{
				PollType = ((ProgMode & ~ISPCC_WORD_POLLTYPE_MASK) | ISPCC_WORD_POLLTYPE_WAIT);
			}					

			// Flash addresses are in words; only increment address on the odd byte, OR if it's the EEPROM being programmed (byte addresses)
			if ((WriteByte & 0x01) || (PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP))
			   V2P_IncrementCurrAddress();

			ISPCC_PollForProgComplete(PollType, PollAddress);
		}
	}
}

void ISPCC_PollForProgComplete(uint8_t PollData, uint16_t PollAddr)
{
    21a4:	1f 93       	push	r17
    21a6:	cf 93       	push	r28
    21a8:	df 93       	push	r29
    21aa:	eb 01       	movw	r28, r22
	uint8_t PollType;
	uint8_t ProgCommand;

	if (PollData & ISPCC_PROG_MODE_PAGE)
    21ac:	99 27       	eor	r25, r25
    21ae:	80 ff       	sbrs	r24, 0
    21b0:	08 c0       	rjmp	.+16     	; 0x21c2 <ISPCC_PollForProgComplete+0x1e>
	   PollType = ((PollData & ISPCC_PAGE_POLLTYPE_MASK) >> ISPCC_PAGE_POLLTYPE_MASKSHIFT);
    21b2:	80 77       	andi	r24, 0x70	; 112
    21b4:	90 70       	andi	r25, 0x00	; 0
    21b6:	34 e0       	ldi	r19, 0x04	; 4
    21b8:	95 95       	asr	r25
    21ba:	87 95       	ror	r24
    21bc:	3a 95       	dec	r19
    21be:	e1 f7       	brne	.-8      	; 0x21b8 <ISPCC_PollForProgComplete+0x14>
    21c0:	04 c0       	rjmp	.+8      	; 0x21ca <ISPCC_PollForProgComplete+0x26>
	else
	   PollType = ((PollData & ISPCC_WORD_POLLTYPE_MASK) >> ISPCC_WORD_POLLTYPE_MASKSHIFT);	
    21c2:	8e 70       	andi	r24, 0x0E	; 14
    21c4:	90 70       	andi	r25, 0x00	; 0
    21c6:	95 95       	asr	r25
    21c8:	87 95       	ror	r24

	switch (PollType & ISPCC_POLLTYPE_MASK)
    21ca:	99 27       	eor	r25, r25
    21cc:	87 70       	andi	r24, 0x07	; 7
    21ce:	90 70       	andi	r25, 0x00	; 0
    21d0:	82 30       	cpi	r24, 0x02	; 2
    21d2:	91 05       	cpc	r25, r1
    21d4:	19 f0       	breq	.+6      	; 0x21dc <ISPCC_PollForProgComplete+0x38>
    21d6:	04 97       	sbiw	r24, 0x04	; 4
    21d8:	e1 f0       	breq	.+56     	; 0x2212 <ISPCC_PollForProgComplete+0x6e>
    21da:	26 c0       	rjmp	.+76     	; 0x2228 <ISPCC_PollForProgComplete+0x84>
	{
		case ISPCC_POLLTYPE_DATA:
			ProgCommand = PacketBytes[7];
    21dc:	10 91 3b 01 	lds	r17, 0x013B
			
			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) // Flash uses word addresses
    21e0:	80 91 34 01 	lds	r24, 0x0134
    21e4:	83 31       	cpi	r24, 0x13	; 19
    21e6:	39 f4       	brne	.+14     	; 0x21f6 <ISPCC_PollForProgComplete+0x52>
			{
				ProgCommand  |= ((PollAddr & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ);
    21e8:	81 2f       	mov	r24, r17
    21ea:	99 27       	eor	r25, r25
    21ec:	c0 fd       	sbrc	r28, 0
    21ee:	88 60       	ori	r24, 0x08	; 8
    21f0:	18 2f       	mov	r17, r24
				PollAddr    >>= 1;
    21f2:	d6 95       	lsr	r29
    21f4:	c7 95       	ror	r28
			}

			do
			{
				USI_SPITransmit(ProgCommand);
    21f6:	81 2f       	mov	r24, r17
    21f8:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
				USI_SPITransmitWord(PollAddr);
    21fc:	ce 01       	movw	r24, r28
    21fe:	0e 94 b2 09 	call	0x1364 <USI_SPITransmitWord>
			}
    2202:	80 e0       	ldi	r24, 0x00	; 0
    2204:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    2208:	90 91 3c 01 	lds	r25, 0x013C
    220c:	89 17       	cp	r24, r25
    220e:	99 f3       	breq	.-26     	; 0x21f6 <ISPCC_PollForProgComplete+0x52>
			while (USI_SPITransmit(0x00) == PacketBytes[8]);
						
			break;
    2210:	0f c0       	rjmp	.+30     	; 0x2230 <ISPCC_PollForProgComplete+0x8c>
		case ISPCC_POLLTYPE_READY:
			do
			   USI_SPITransmitWord(0xF000);
    2212:	80 e0       	ldi	r24, 0x00	; 0
    2214:	90 ef       	ldi	r25, 0xF0	; 240
    2216:	0e 94 b2 09 	call	0x1364 <USI_SPITransmitWord>
    221a:	80 e0       	ldi	r24, 0x00	; 0
    221c:	90 e0       	ldi	r25, 0x00	; 0
    221e:	0e 94 b2 09 	call	0x1364 <USI_SPITransmitWord>
    2222:	80 fd       	sbrc	r24, 0
    2224:	f6 cf       	rjmp	.-20     	; 0x2212 <ISPCC_PollForProgComplete+0x6e>
			while (USI_SPITransmitWord(0x0000) & ISPCC_POLL_BUSYFLAG);

			break;
    2226:	04 c0       	rjmp	.+8      	; 0x2230 <ISPCC_PollForProgComplete+0x8c>
		default:                                      // Default is Wait polling
			MAIN_Delay1MS(PacketBytes[4]);	
    2228:	80 91 38 01 	lds	r24, 0x0138
    222c:	0e 94 01 03 	call	0x602 <MAIN_Delay1MS>
    2230:	df 91       	pop	r29
    2232:	cf 91       	pop	r28
    2234:	1f 91       	pop	r17
    2236:	08 95       	ret

00002238 <ISPCC_ProgramChip>:
    2238:	6f 92       	push	r6
    223a:	7f 92       	push	r7
    223c:	9f 92       	push	r9
    223e:	af 92       	push	r10
    2240:	bf 92       	push	r11
    2242:	cf 92       	push	r12
    2244:	df 92       	push	r13
    2246:	ef 92       	push	r14
    2248:	ff 92       	push	r15
    224a:	0f 93       	push	r16
    224c:	1f 93       	push	r17
    224e:	cf 93       	push	r28
    2250:	df 93       	push	r29
    2252:	00 e0       	ldi	r16, 0x00	; 0
    2254:	10 e0       	ldi	r17, 0x00	; 0
    2256:	90 90 37 01 	lds	r9, 0x0137
    225a:	c0 90 39 01 	lds	r12, 0x0139
    225e:	60 90 2b 01 	lds	r6, 0x012B
    2262:	70 90 2c 01 	lds	r7, 0x012C
    2266:	80 91 35 01 	lds	r24, 0x0135
    226a:	99 27       	eor	r25, r25
    226c:	b8 2e       	mov	r11, r24
    226e:	aa 24       	eor	r10, r10
    2270:	80 91 36 01 	lds	r24, 0x0136
    2274:	99 27       	eor	r25, r25
    2276:	a8 2a       	or	r10, r24
    2278:	b9 2a       	or	r11, r25
    227a:	90 fe       	sbrs	r9, 0
    227c:	62 c0       	rjmp	.+196    	; 0x2342 <ISPCC_ProgramChip+0x10a>
    227e:	78 01       	movw	r14, r16
    2280:	0a 15       	cp	r16, r10
    2282:	1b 05       	cpc	r17, r11
    2284:	08 f0       	brcs	.+2      	; 0x2288 <ISPCC_ProgramChip+0x50>
    2286:	46 c0       	rjmp	.+140    	; 0x2314 <ISPCC_ProgramChip+0xdc>
    2288:	ce e3       	ldi	r28, 0x3E	; 62
    228a:	d1 e0       	ldi	r29, 0x01	; 1
    228c:	d9 90       	ld	r13, Y+
    228e:	80 91 34 01 	lds	r24, 0x0134
    2292:	83 31       	cpi	r24, 0x13	; 19
    2294:	31 f4       	brne	.+12     	; 0x22a2 <ISPCC_ProgramChip+0x6a>
    2296:	8c 2d       	mov	r24, r12
    2298:	99 27       	eor	r25, r25
    229a:	e0 fe       	sbrs	r14, 0
    229c:	03 c0       	rjmp	.+6      	; 0x22a4 <ISPCC_ProgramChip+0x6c>
    229e:	88 60       	ori	r24, 0x08	; 8
    22a0:	01 c0       	rjmp	.+2      	; 0x22a4 <ISPCC_ProgramChip+0x6c>
    22a2:	8c 2d       	mov	r24, r12
    22a4:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    22a8:	80 91 2b 01 	lds	r24, 0x012B
    22ac:	90 91 2c 01 	lds	r25, 0x012C
    22b0:	0e 94 b2 09 	call	0x1364 <USI_SPITransmitWord>
    22b4:	8d 2d       	mov	r24, r13
    22b6:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    22ba:	01 15       	cp	r16, r1
    22bc:	11 05       	cpc	r17, r1
    22be:	d9 f4       	brne	.+54     	; 0x22f6 <ISPCC_ProgramChip+0xbe>
    22c0:	80 91 3c 01 	lds	r24, 0x013C
    22c4:	8d 15       	cp	r24, r13
    22c6:	b9 f0       	breq	.+46     	; 0x22f6 <ISPCC_ProgramChip+0xbe>
    22c8:	90 91 34 01 	lds	r25, 0x0134
    22cc:	93 31       	cpi	r25, 0x13	; 19
    22ce:	31 f0       	breq	.+12     	; 0x22dc <ISPCC_ProgramChip+0xa4>
    22d0:	95 31       	cpi	r25, 0x15	; 21
    22d2:	89 f4       	brne	.+34     	; 0x22f6 <ISPCC_ProgramChip+0xbe>
    22d4:	80 91 3d 01 	lds	r24, 0x013D
    22d8:	8d 15       	cp	r24, r13
    22da:	69 f0       	breq	.+26     	; 0x22f6 <ISPCC_ProgramChip+0xbe>
    22dc:	00 91 2b 01 	lds	r16, 0x012B
    22e0:	10 91 2c 01 	lds	r17, 0x012C
    22e4:	93 31       	cpi	r25, 0x13	; 19
    22e6:	39 f4       	brne	.+14     	; 0x22f6 <ISPCC_ProgramChip+0xbe>
    22e8:	00 0f       	add	r16, r16
    22ea:	11 1f       	adc	r17, r17
    22ec:	c7 01       	movw	r24, r14
    22ee:	81 70       	andi	r24, 0x01	; 1
    22f0:	90 70       	andi	r25, 0x00	; 0
    22f2:	08 0f       	add	r16, r24
    22f4:	19 1f       	adc	r17, r25
    22f6:	e0 fc       	sbrc	r14, 0
    22f8:	04 c0       	rjmp	.+8      	; 0x2302 <ISPCC_ProgramChip+0xca>
    22fa:	80 91 34 01 	lds	r24, 0x0134
    22fe:	85 31       	cpi	r24, 0x15	; 21
    2300:	11 f4       	brne	.+4      	; 0x2306 <ISPCC_ProgramChip+0xce>
    2302:	0e 94 d7 0e 	call	0x1dae <V2P_IncrementCurrAddress>
    2306:	08 94       	sec
    2308:	e1 1c       	adc	r14, r1
    230a:	f1 1c       	adc	r15, r1
    230c:	ea 14       	cp	r14, r10
    230e:	fb 04       	cpc	r15, r11
    2310:	08 f4       	brcc	.+2      	; 0x2314 <ISPCC_ProgramChip+0xdc>
    2312:	bc cf       	rjmp	.-136    	; 0x228c <ISPCC_ProgramChip+0x54>
    2314:	c9 2d       	mov	r28, r9
    2316:	97 fe       	sbrs	r9, 7
    2318:	69 c0       	rjmp	.+210    	; 0x23ec <ISPCC_ProgramChip+0x1b4>
    231a:	80 91 3a 01 	lds	r24, 0x013A
    231e:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    2322:	c3 01       	movw	r24, r6
    2324:	0e 94 b2 09 	call	0x1364 <USI_SPITransmitWord>
    2328:	80 e0       	ldi	r24, 0x00	; 0
    232a:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    232e:	01 15       	cp	r16, r1
    2330:	11 05       	cpc	r17, r1
    2332:	11 f4       	brne	.+4      	; 0x2338 <ISPCC_ProgramChip+0x100>
    2334:	cf 78       	andi	r28, 0x8F	; 143
    2336:	c0 61       	ori	r28, 0x10	; 16
    2338:	b8 01       	movw	r22, r16
    233a:	8c 2f       	mov	r24, r28
    233c:	0e 94 d2 10 	call	0x21a4 <ISPCC_PollForProgComplete>
    2340:	55 c0       	rjmp	.+170    	; 0x23ec <ISPCC_ProgramChip+0x1b4>
    2342:	78 01       	movw	r14, r16
    2344:	0a 15       	cp	r16, r10
    2346:	1b 05       	cpc	r17, r11
    2348:	08 f0       	brcs	.+2      	; 0x234c <ISPCC_ProgramChip+0x114>
    234a:	50 c0       	rjmp	.+160    	; 0x23ec <ISPCC_ProgramChip+0x1b4>
    234c:	5e e3       	ldi	r21, 0x3E	; 62
    234e:	65 2e       	mov	r6, r21
    2350:	51 e0       	ldi	r21, 0x01	; 1
    2352:	75 2e       	mov	r7, r21
    2354:	f3 01       	movw	r30, r6
    2356:	d1 90       	ld	r13, Z+
    2358:	3f 01       	movw	r6, r30
    235a:	80 91 34 01 	lds	r24, 0x0134
    235e:	83 31       	cpi	r24, 0x13	; 19
    2360:	31 f4       	brne	.+12     	; 0x236e <ISPCC_ProgramChip+0x136>
    2362:	8c 2d       	mov	r24, r12
    2364:	99 27       	eor	r25, r25
    2366:	e0 fe       	sbrs	r14, 0
    2368:	03 c0       	rjmp	.+6      	; 0x2370 <ISPCC_ProgramChip+0x138>
    236a:	88 60       	ori	r24, 0x08	; 8
    236c:	01 c0       	rjmp	.+2      	; 0x2370 <ISPCC_ProgramChip+0x138>
    236e:	8c 2d       	mov	r24, r12
    2370:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    2374:	80 91 2b 01 	lds	r24, 0x012B
    2378:	90 91 2c 01 	lds	r25, 0x012C
    237c:	0e 94 b2 09 	call	0x1364 <USI_SPITransmitWord>
    2380:	8d 2d       	mov	r24, r13
    2382:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    2386:	c9 2d       	mov	r28, r9
    2388:	80 91 3c 01 	lds	r24, 0x013C
    238c:	8d 15       	cp	r24, r13
    238e:	c1 f0       	breq	.+48     	; 0x23c0 <ISPCC_ProgramChip+0x188>
    2390:	90 91 34 01 	lds	r25, 0x0134
    2394:	93 31       	cpi	r25, 0x13	; 19
    2396:	31 f0       	breq	.+12     	; 0x23a4 <ISPCC_ProgramChip+0x16c>
    2398:	95 31       	cpi	r25, 0x15	; 21
    239a:	91 f4       	brne	.+36     	; 0x23c0 <ISPCC_ProgramChip+0x188>
    239c:	80 91 3d 01 	lds	r24, 0x013D
    23a0:	8d 15       	cp	r24, r13
    23a2:	71 f0       	breq	.+28     	; 0x23c0 <ISPCC_ProgramChip+0x188>
    23a4:	00 91 2b 01 	lds	r16, 0x012B
    23a8:	10 91 2c 01 	lds	r17, 0x012C
    23ac:	93 31       	cpi	r25, 0x13	; 19
    23ae:	59 f4       	brne	.+22     	; 0x23c6 <ISPCC_ProgramChip+0x18e>
    23b0:	00 0f       	add	r16, r16
    23b2:	11 1f       	adc	r17, r17
    23b4:	c7 01       	movw	r24, r14
    23b6:	81 70       	andi	r24, 0x01	; 1
    23b8:	90 70       	andi	r25, 0x00	; 0
    23ba:	08 0f       	add	r16, r24
    23bc:	19 1f       	adc	r17, r25
    23be:	03 c0       	rjmp	.+6      	; 0x23c6 <ISPCC_ProgramChip+0x18e>
    23c0:	c9 2d       	mov	r28, r9
    23c2:	c1 7f       	andi	r28, 0xF1	; 241
    23c4:	c2 60       	ori	r28, 0x02	; 2
    23c6:	e0 fc       	sbrc	r14, 0
    23c8:	04 c0       	rjmp	.+8      	; 0x23d2 <ISPCC_ProgramChip+0x19a>
    23ca:	80 91 34 01 	lds	r24, 0x0134
    23ce:	85 31       	cpi	r24, 0x15	; 21
    23d0:	11 f4       	brne	.+4      	; 0x23d6 <ISPCC_ProgramChip+0x19e>
    23d2:	0e 94 d7 0e 	call	0x1dae <V2P_IncrementCurrAddress>
    23d6:	b8 01       	movw	r22, r16
    23d8:	8c 2f       	mov	r24, r28
    23da:	0e 94 d2 10 	call	0x21a4 <ISPCC_PollForProgComplete>
    23de:	08 94       	sec
    23e0:	e1 1c       	adc	r14, r1
    23e2:	f1 1c       	adc	r15, r1
    23e4:	ea 14       	cp	r14, r10
    23e6:	fb 04       	cpc	r15, r11
    23e8:	08 f4       	brcc	.+2      	; 0x23ec <ISPCC_ProgramChip+0x1b4>
    23ea:	b4 cf       	rjmp	.-152    	; 0x2354 <ISPCC_ProgramChip+0x11c>
    23ec:	df 91       	pop	r29
    23ee:	cf 91       	pop	r28
    23f0:	1f 91       	pop	r17
    23f2:	0f 91       	pop	r16
    23f4:	ff 90       	pop	r15
    23f6:	ef 90       	pop	r14
    23f8:	df 90       	pop	r13
    23fa:	cf 90       	pop	r12
    23fc:	bf 90       	pop	r11
    23fe:	af 90       	pop	r10
    2400:	9f 90       	pop	r9
    2402:	7f 90       	pop	r7
    2404:	6f 90       	pop	r6
    2406:	08 95       	ret

00002408 <AICI_InterpretPacket>:

// ======================================================================================

void AICI_InterpretPacket(void)
{
    2408:	df 92       	push	r13
    240a:	ef 92       	push	r14
    240c:	ff 92       	push	r15
    240e:	0f 93       	push	r16
    2410:	1f 93       	push	r17
    2412:	cf 93       	push	r28
    2414:	df 93       	push	r29
	switch (PacketBytes[0])
    2416:	80 91 34 01 	lds	r24, 0x0134
    241a:	99 27       	eor	r25, r25
    241c:	86 31       	cpi	r24, 0x16	; 22
    241e:	91 05       	cpc	r25, r1
    2420:	09 f4       	brne	.+2      	; 0x2424 <AICI_InterpretPacket+0x1c>
    2422:	fa c0       	rjmp	.+500    	; 0x2618 <AICI_InterpretPacket+0x210>
    2424:	87 31       	cpi	r24, 0x17	; 23
    2426:	91 05       	cpc	r25, r1
    2428:	94 f4       	brge	.+36     	; 0x244e <AICI_InterpretPacket+0x46>
    242a:	82 31       	cpi	r24, 0x12	; 18
    242c:	91 05       	cpc	r25, r1
    242e:	09 f4       	brne	.+2      	; 0x2432 <AICI_InterpretPacket+0x2a>
    2430:	5f c0       	rjmp	.+190    	; 0x24f0 <AICI_InterpretPacket+0xe8>
    2432:	83 31       	cpi	r24, 0x13	; 19
    2434:	91 05       	cpc	r25, r1
    2436:	3c f4       	brge	.+14     	; 0x2446 <AICI_InterpretPacket+0x3e>
    2438:	80 31       	cpi	r24, 0x10	; 16
    243a:	91 05       	cpc	r25, r1
    243c:	f9 f0       	breq	.+62     	; 0x247c <AICI_InterpretPacket+0x74>
    243e:	41 97       	sbiw	r24, 0x11	; 17
    2440:	09 f4       	brne	.+2      	; 0x2444 <AICI_InterpretPacket+0x3c>
    2442:	3c c0       	rjmp	.+120    	; 0x24bc <AICI_InterpretPacket+0xb4>
    2444:	3d c1       	rjmp	.+634    	; 0x26c0 <AICI_InterpretPacket+0x2b8>
    2446:	44 97       	sbiw	r24, 0x14	; 20
    2448:	09 f4       	brne	.+2      	; 0x244c <AICI_InterpretPacket+0x44>
    244a:	e6 c0       	rjmp	.+460    	; 0x2618 <AICI_InterpretPacket+0x210>
    244c:	2e c1       	rjmp	.+604    	; 0x26aa <AICI_InterpretPacket+0x2a2>
    244e:	89 31       	cpi	r24, 0x19	; 25
    2450:	91 05       	cpc	r25, r1
    2452:	09 f4       	brne	.+2      	; 0x2456 <AICI_InterpretPacket+0x4e>
    2454:	cb c0       	rjmp	.+406    	; 0x25ec <AICI_InterpretPacket+0x1e4>
    2456:	8a 31       	cpi	r24, 0x1A	; 26
    2458:	91 05       	cpc	r25, r1
    245a:	44 f4       	brge	.+16     	; 0x246c <AICI_InterpretPacket+0x64>
    245c:	87 31       	cpi	r24, 0x17	; 23
    245e:	91 05       	cpc	r25, r1
    2460:	09 f4       	brne	.+2      	; 0x2464 <AICI_InterpretPacket+0x5c>
    2462:	c4 c0       	rjmp	.+392    	; 0x25ec <AICI_InterpretPacket+0x1e4>
    2464:	48 97       	sbiw	r24, 0x18	; 24
    2466:	09 f4       	brne	.+2      	; 0x246a <AICI_InterpretPacket+0x62>
    2468:	a4 c0       	rjmp	.+328    	; 0x25b2 <AICI_InterpretPacket+0x1aa>
    246a:	2a c1       	rjmp	.+596    	; 0x26c0 <AICI_InterpretPacket+0x2b8>
    246c:	8d 31       	cpi	r24, 0x1D	; 29
    246e:	91 05       	cpc	r25, r1
    2470:	0c f4       	brge	.+2      	; 0x2474 <AICI_InterpretPacket+0x6c>
    2472:	9f c0       	rjmp	.+318    	; 0x25b2 <AICI_InterpretPacket+0x1aa>
    2474:	4d 97       	sbiw	r24, 0x1d	; 29
    2476:	09 f4       	brne	.+2      	; 0x247a <AICI_InterpretPacket+0x72>
    2478:	60 c0       	rjmp	.+192    	; 0x253a <AICI_InterpretPacket+0x132>
    247a:	22 c1       	rjmp	.+580    	; 0x26c0 <AICI_InterpretPacket+0x2b8>
	{
		case CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
    247c:	82 e0       	ldi	r24, 0x02	; 2
    247e:	90 e0       	ldi	r25, 0x00	; 0
    2480:	90 93 31 01 	sts	0x0131, r25
    2484:	80 93 30 01 	sts	0x0130, r24
			
			USI_SPIInitMaster(eeprom_read_byte_169(&Param_SCKDuration));
    2488:	80 e2       	ldi	r24, 0x20	; 32
    248a:	91 e0       	ldi	r25, 0x01	; 1
    248c:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
    2490:	0e 94 85 09 	call	0x130a <USI_SPIInitMaster>

			MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);  // Pull the slave AVR's RESET line to active
    2494:	80 e0       	ldi	r24, 0x00	; 0
    2496:	0e 94 13 03 	call	0x626 <MAIN_ResetCSLine>
			MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE); // Orange = Busy
    249a:	81 b3       	in	r24, 0x11	; 17
    249c:	80 63       	ori	r24, 0x30	; 48
    249e:	81 bb       	out	0x11, r24	; 17
			ISPCC_EnterChipProgrammingMode();       // Run the Enter Programming Mode routine
    24a0:	0e 94 74 10 	call	0x20e8 <ISPCC_EnterChipProgrammingMode>

			if (InProgrammingMode)
    24a4:	80 91 2f 01 	lds	r24, 0x012F
    24a8:	88 23       	and	r24, r24
    24aa:	19 f0       	breq	.+6      	; 0x24b2 <AICI_InterpretPacket+0xaa>
			   LCD_puts_f(AVRISPModeMessage);
    24ac:	80 ee       	ldi	r24, 0xE0	; 224
    24ae:	93 e0       	ldi	r25, 0x03	; 3
    24b0:	02 c0       	rjmp	.+4      	; 0x24b6 <AICI_InterpretPacket+0xae>
			else
			   LCD_puts_f(SyncErrorMessage);
    24b2:	85 ed       	ldi	r24, 0xD5	; 213
    24b4:	93 e0       	ldi	r25, 0x03	; 3
    24b6:	0e 94 f7 07 	call	0xfee <LCD_puts_f>
			
			break;
    24ba:	0b c1       	rjmp	.+534    	; 0x26d2 <AICI_InterpretPacket+0x2ca>
		case CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;
    24bc:	82 e0       	ldi	r24, 0x02	; 2
    24be:	90 e0       	ldi	r25, 0x00	; 0
    24c0:	90 93 31 01 	sts	0x0131, r25
    24c4:	80 93 30 01 	sts	0x0130, r24

			MAIN_Delay1MS(PacketBytes[1]);           // Wait for the "PreDelay" amount specified in the packet
    24c8:	80 91 35 01 	lds	r24, 0x0135
    24cc:	0e 94 01 03 	call	0x602 <MAIN_Delay1MS>
			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Non programming mode = green status led
    24d0:	81 b3       	in	r24, 0x11	; 17
    24d2:	8f 7c       	andi	r24, 0xCF	; 207
    24d4:	80 61       	ori	r24, 0x10	; 16
    24d6:	81 bb       	out	0x11, r24	; 17
			InProgrammingMode = FALSE;
    24d8:	10 92 2f 01 	sts	0x012F, r1
			MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run
    24dc:	81 e0       	ldi	r24, 0x01	; 1
    24de:	0e 94 13 03 	call	0x626 <MAIN_ResetCSLine>
			MAIN_Delay1MS(PacketBytes[2]);           // Wait for the "PostDelay" amount specified in the packet
    24e2:	80 91 36 01 	lds	r24, 0x0136
    24e6:	0e 94 01 03 	call	0x602 <MAIN_Delay1MS>
			
			USI_SPIOff();
    24ea:	0e 94 95 09 	call	0x132a <USI_SPIOff>
    24ee:	e5 c0       	rjmp	.+458    	; 0x26ba <AICI_InterpretPacket+0x2b2>

			PacketBytes[1] = STATUS_CMD_OK;      // Return OK

			break;
		case CMD_CHIP_ERASE_ISP:
			MessageSize = 2;
    24f0:	82 e0       	ldi	r24, 0x02	; 2
    24f2:	90 e0       	ldi	r25, 0x00	; 0
    24f4:	90 93 31 01 	sts	0x0131, r25
    24f8:	80 93 30 01 	sts	0x0130, r24
			
			for (uint8_t PacketB = 3; PacketB <= 6; PacketB++) // Send the erase commands to the slave AVR
    24fc:	c3 e0       	ldi	r28, 0x03	; 3
    24fe:	07 e3       	ldi	r16, 0x37	; 55
    2500:	11 e0       	ldi	r17, 0x01	; 1
				USI_SPITransmit(PacketBytes[PacketB]);
    2502:	f8 01       	movw	r30, r16
    2504:	81 91       	ld	r24, Z+
    2506:	8f 01       	movw	r16, r30
    2508:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    250c:	c1 50       	subi	r28, 0x01	; 1
    250e:	c7 ff       	sbrs	r28, 7
    2510:	f8 cf       	rjmp	.-16     	; 0x2502 <AICI_InterpretPacket+0xfa>

			if (PacketBytes[2])                  // Poll mode, value of 1 indicates a busy flag wait
    2512:	80 91 36 01 	lds	r24, 0x0136
    2516:	88 23       	and	r24, r24
    2518:	59 f0       	breq	.+22     	; 0x2530 <AICI_InterpretPacket+0x128>
			{
				do
					USI_SPITransmitWord(0xF000);
    251a:	80 e0       	ldi	r24, 0x00	; 0
    251c:	90 ef       	ldi	r25, 0xF0	; 240
    251e:	0e 94 b2 09 	call	0x1364 <USI_SPITransmitWord>
    2522:	80 e0       	ldi	r24, 0x00	; 0
    2524:	90 e0       	ldi	r25, 0x00	; 0
    2526:	0e 94 b2 09 	call	0x1364 <USI_SPITransmitWord>
    252a:	80 fd       	sbrc	r24, 0
    252c:	f6 cf       	rjmp	.-20     	; 0x251a <AICI_InterpretPacket+0x112>
    252e:	c5 c0       	rjmp	.+394    	; 0x26ba <AICI_InterpretPacket+0x2b2>
				while (USI_SPITransmitWord(0x0000) & 0x01);
			}
			else                                // Poll mode flag of 0 indicates a predefined delay
			{
				MAIN_Delay1MS(PacketBytes[1]);   // Wait the specified interval to ensure erase complete
    2530:	80 91 35 01 	lds	r24, 0x0135
    2534:	0e 94 01 03 	call	0x602 <MAIN_Delay1MS>
    2538:	c0 c0       	rjmp	.+384    	; 0x26ba <AICI_InterpretPacket+0x2b2>
			}
			
			PacketBytes[1] = STATUS_CMD_OK;      // Always return OK
			
			break;
		case CMD_SPI_MULTI:
				MessageSize = (3 + PacketBytes[2]);    // Number of recieved bytes, plus two OKs and the command byte
    253a:	e0 90 36 01 	lds	r14, 0x0136
    253e:	8e 2d       	mov	r24, r14
    2540:	99 27       	eor	r25, r25
    2542:	03 96       	adiw	r24, 0x03	; 3
    2544:	90 93 31 01 	sts	0x0131, r25
    2548:	80 93 30 01 	sts	0x0130, r24
		
				uint8_t TxBytes      = PacketBytes[1]; // \. The packet data is overwritten during the transfer. Because
    254c:	00 91 35 01 	lds	r16, 0x0135
				uint8_t RxStartByte  = PacketBytes[2]; // |  of this each data byte must be stored into temp variables
				uint8_t RxBytes      = PacketBytes[3]; // /  so that their contents are not lost.
    2550:	f0 90 37 01 	lds	r15, 0x0137
				uint8_t RxByteNum    = 1;
    2554:	c1 e0       	ldi	r28, 0x01	; 1
				uint8_t TxByteNum    = 1;
				uint8_t RecievedByte = 0;

				while (TxByteNum++ < TxBytes)          // Still bytes to transfer
				{
					RecievedByte = USI_SPITransmit(PacketBytes[3 + TxByteNum]); // Transmit the byte, store the answer

					if ((TxByteNum >= RxStartByte) && (RxByteNum < RxBytes))
					   PacketBytes[2 + RxByteNum++] = RecievedByte;
    2556:	12 e0       	ldi	r17, 0x02	; 2
    2558:	c0 17       	cp	r28, r16
    255a:	a8 f4       	brcc	.+42     	; 0x2586 <AICI_InterpretPacket+0x17e>
    255c:	e1 2f       	mov	r30, r17
    255e:	ff 27       	eor	r31, r31
    2560:	ec 5c       	subi	r30, 0xCC	; 204
    2562:	fe 4f       	sbci	r31, 0xFE	; 254
    2564:	83 81       	ldd	r24, Z+3	; 0x03
    2566:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    256a:	1e 15       	cp	r17, r14
    256c:	40 f0       	brcs	.+16     	; 0x257e <AICI_InterpretPacket+0x176>
    256e:	cf 15       	cp	r28, r15
    2570:	30 f4       	brcc	.+12     	; 0x257e <AICI_InterpretPacket+0x176>
    2572:	ec 2f       	mov	r30, r28
    2574:	ff 27       	eor	r31, r31
    2576:	ec 5c       	subi	r30, 0xCC	; 204
    2578:	fe 4f       	sbci	r31, 0xFE	; 254
    257a:	82 83       	std	Z+2, r24	; 0x02
    257c:	cf 5f       	subi	r28, 0xFF	; 255
    257e:	81 2f       	mov	r24, r17
    2580:	1f 5f       	subi	r17, 0xFF	; 255
    2582:	80 17       	cp	r24, r16
    2584:	58 f3       	brcs	.-42     	; 0x255c <AICI_InterpretPacket+0x154>
				}

				while (RxByteNum++ < RxBytes)                         // Still more bytes to recieve
				   PacketBytes[2 + RxByteNum] = USI_SPITransmit(0x00); // its answer to be recorded (or more bytes than sent need responses), send dummy bytes to fetch the response(s)
    2586:	8c 2f       	mov	r24, r28
    2588:	cf 5f       	subi	r28, 0xFF	; 255
    258a:	8f 15       	cp	r24, r15
    258c:	50 f4       	brcc	.+20     	; 0x25a2 <AICI_InterpretPacket+0x19a>
    258e:	0c 2f       	mov	r16, r28
    2590:	11 27       	eor	r17, r17
    2592:	0c 5c       	subi	r16, 0xCC	; 204
    2594:	1e 4f       	sbci	r17, 0xFE	; 254
    2596:	80 e0       	ldi	r24, 0x00	; 0
    2598:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    259c:	f8 01       	movw	r30, r16
    259e:	82 83       	std	Z+2, r24	; 0x02
    25a0:	f2 cf       	rjmp	.-28     	; 0x2586 <AICI_InterpretPacket+0x17e>

				PacketBytes[1]             = STATUS_CMD_OK; // Data should be encompassed
    25a2:	10 92 35 01 	sts	0x0135, r1
				PacketBytes[3 + RxByteNum] = STATUS_CMD_OK; //  by STATS_CMD_OKs
    25a6:	ec 2f       	mov	r30, r28
    25a8:	ff 27       	eor	r31, r31
    25aa:	ec 5c       	subi	r30, 0xCC	; 204
    25ac:	fe 4f       	sbci	r31, 0xFE	; 254
    25ae:	13 82       	std	Z+3, r1	; 0x03

				break;
    25b0:	90 c0       	rjmp	.+288    	; 0x26d2 <AICI_InterpretPacket+0x2ca>
		case CMD_READ_SIGNATURE_ISP:
		case CMD_READ_FUSE_ISP:
		case CMD_READ_LOCK_ISP:
		case CMD_READ_OSCCAL_ISP:
			MessageSize = 4;
    25b2:	84 e0       	ldi	r24, 0x04	; 4
    25b4:	90 e0       	ldi	r25, 0x00	; 0
    25b6:	90 93 31 01 	sts	0x0131, r25
    25ba:	80 93 30 01 	sts	0x0130, r24
	
			for(uint8_t ByteNum = 1; ByteNum <= 4; ByteNum++)
    25be:	c1 e0       	ldi	r28, 0x01	; 1
    25c0:	06 e3       	ldi	r16, 0x36	; 54
    25c2:	11 e0       	ldi	r17, 0x01	; 1
			{
				uint8_t Response = USI_SPITransmit(PacketBytes[1 + ByteNum]); // Transmit the four signature request bytes
    25c4:	f8 01       	movw	r30, r16
    25c6:	81 91       	ld	r24, Z+
    25c8:	8f 01       	movw	r16, r30
    25ca:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    25ce:	98 2f       	mov	r25, r24

				if (ByteNum == PacketBytes[1])         // If the current byte is the requested signature byte, save the reponse in the packet
    25d0:	80 91 35 01 	lds	r24, 0x0135
    25d4:	c8 17       	cp	r28, r24
    25d6:	11 f4       	brne	.+4      	; 0x25dc <AICI_InterpretPacket+0x1d4>
					PacketBytes[2] = Response;
    25d8:	90 93 36 01 	sts	0x0136, r25
    25dc:	cf 5f       	subi	r28, 0xFF	; 255
    25de:	c5 30       	cpi	r28, 0x05	; 5
    25e0:	88 f3       	brcs	.-30     	; 0x25c4 <AICI_InterpretPacket+0x1bc>
			}

			PacketBytes[1] = STATUS_CMD_OK;            // Data byte is encased in CMD_OKs
    25e2:	10 92 35 01 	sts	0x0135, r1
			PacketBytes[3] = STATUS_CMD_OK;            // Data byte is encased in CMD_OKs
    25e6:	10 92 37 01 	sts	0x0137, r1

			break;
    25ea:	73 c0       	rjmp	.+230    	; 0x26d2 <AICI_InterpretPacket+0x2ca>
		case CMD_PROGRAM_FUSE_ISP:
		case CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;
    25ec:	83 e0       	ldi	r24, 0x03	; 3
    25ee:	90 e0       	ldi	r25, 0x00	; 0
    25f0:	90 93 31 01 	sts	0x0131, r25
    25f4:	80 93 30 01 	sts	0x0130, r24
    25f8:	05 e3       	ldi	r16, 0x35	; 53
    25fa:	11 e0       	ldi	r17, 0x01	; 1
    25fc:	c3 e0       	ldi	r28, 0x03	; 3
			
			for (uint8_t PacketB = 1; PacketB <= 4; PacketB++) // Send the lock-byte values to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    25fe:	f8 01       	movw	r30, r16
    2600:	81 91       	ld	r24, Z+
    2602:	8f 01       	movw	r16, r30
    2604:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    2608:	c1 50       	subi	r28, 0x01	; 1
    260a:	c7 ff       	sbrs	r28, 7
    260c:	f8 cf       	rjmp	.-16     	; 0x25fe <AICI_InterpretPacket+0x1f6>

			PacketBytes[1] = STATUS_CMD_OK;            // Two CMD_OKs are always returned
    260e:	10 92 35 01 	sts	0x0135, r1
			PacketBytes[2] = STATUS_CMD_OK;            // Two CMD_OKs are always returned
    2612:	10 92 36 01 	sts	0x0136, r1

			break;
    2616:	5d c0       	rjmp	.+186    	; 0x26d2 <AICI_InterpretPacket+0x2ca>
		case CMD_READ_FLASH_ISP:
		case CMD_READ_EEPROM_ISP:
			MessageSize = 0;                           // Here to prevent compiler from complaining if a var dec appears straight after a case

			uint8_t  ReadCommand = PacketBytes[3];
    2618:	d0 90 37 01 	lds	r13, 0x0137
			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8) // Load in the number of bytes that is to
    261c:	80 91 35 01 	lds	r24, 0x0135
    2620:	99 27       	eor	r25, r25
    2622:	d8 2f       	mov	r29, r24
    2624:	cc 27       	eor	r28, r28
    2626:	80 91 36 01 	lds	r24, 0x0136
    262a:	99 27       	eor	r25, r25
    262c:	c8 2b       	or	r28, r24
    262e:	d9 2b       	or	r29, r25
			                     | PacketBytes[2];                 // be read into a temp variable (MSB first)

			MessageSize = BytesToRead + 3;
    2630:	23 96       	adiw	r28, 0x03	; 3
    2632:	d0 93 31 01 	sts	0x0131, r29
    2636:	c0 93 30 01 	sts	0x0130, r28
    263a:	23 97       	sbiw	r28, 0x03	; 3

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
    263c:	00 e0       	ldi	r16, 0x00	; 0
    263e:	10 e0       	ldi	r17, 0x00	; 0
    2640:	0c 17       	cp	r16, r28
    2642:	1d 07       	cpc	r17, r29
    2644:	60 f5       	brcc	.+88     	; 0x269e <AICI_InterpretPacket+0x296>
    2646:	86 e3       	ldi	r24, 0x36	; 54
    2648:	e8 2e       	mov	r14, r24
    264a:	81 e0       	ldi	r24, 0x01	; 1
    264c:	f8 2e       	mov	r15, r24
			{
				if (PacketBytes[0] == CMD_READ_FLASH_ISP)  // Flash read mode - word addresses so MSB/LSB masking nessesary
    264e:	80 91 34 01 	lds	r24, 0x0134
    2652:	84 31       	cpi	r24, 0x14	; 20
    2654:	31 f4       	brne	.+12     	; 0x2662 <AICI_InterpretPacket+0x25a>
				{
					USI_SPITransmit(ReadCommand | ((ReadByte & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ));
    2656:	8d 2d       	mov	r24, r13
    2658:	99 27       	eor	r25, r25
    265a:	00 ff       	sbrs	r16, 0
    265c:	03 c0       	rjmp	.+6      	; 0x2664 <AICI_InterpretPacket+0x25c>
    265e:	88 60       	ori	r24, 0x08	; 8
    2660:	01 c0       	rjmp	.+2      	; 0x2664 <AICI_InterpretPacket+0x25c>
				}
				else                                       // EEPROM read mode, address is in bytes and so no masking nessesary
				{
					USI_SPITransmit(ReadCommand);
    2662:	8d 2d       	mov	r24, r13
    2664:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
				}
				
				USI_SPITransmitWord(CurrAddress);          // Transmit the current address to the slave AVR
    2668:	80 91 2b 01 	lds	r24, 0x012B
    266c:	90 91 2c 01 	lds	r25, 0x012C
    2670:	0e 94 b2 09 	call	0x1364 <USI_SPITransmitWord>

				PacketBytes[2 + ReadByte] = USI_SPITransmit(0x00); // Read in the byte stored at the requested location
    2674:	80 e0       	ldi	r24, 0x00	; 0
    2676:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    267a:	f7 01       	movw	r30, r14
    267c:	80 83       	st	Z, r24

				if ((ReadByte & 0x01) || (PacketBytes[0] == CMD_READ_EEPROM_ISP)) // Flash addresses are given in words; only increment on the odd byte if reading the flash.
    267e:	00 fd       	sbrc	r16, 0
    2680:	04 c0       	rjmp	.+8      	; 0x268a <AICI_InterpretPacket+0x282>
    2682:	80 91 34 01 	lds	r24, 0x0134
    2686:	86 31       	cpi	r24, 0x16	; 22
    2688:	11 f4       	brne	.+4      	; 0x268e <AICI_InterpretPacket+0x286>
				{
					V2P_IncrementCurrAddress();             // Increment the address counter
    268a:	0e 94 d7 0e 	call	0x1dae <V2P_IncrementCurrAddress>
    268e:	0f 5f       	subi	r16, 0xFF	; 255
    2690:	1f 4f       	sbci	r17, 0xFF	; 255
    2692:	08 94       	sec
    2694:	e1 1c       	adc	r14, r1
    2696:	f1 1c       	adc	r15, r1
    2698:	0c 17       	cp	r16, r28
    269a:	1d 07       	cpc	r17, r29
    269c:	c0 f2       	brcs	.-80     	; 0x264e <AICI_InterpretPacket+0x246>
				}
				else
				{
					if ((CurrAddress & 0x00FF0000) & !(CurrAddress & 0x0000FFFF))
					{
						CurrAddress |= (1UL << 31);        // Set MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
						V2P_CheckForExtendedAddress();
					}
				}
			}
			
			PacketBytes[1]               = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    269e:	10 92 35 01 	sts	0x0135, r1
			PacketBytes[2 + BytesToRead] = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    26a2:	cc 5c       	subi	r28, 0xCC	; 204
    26a4:	de 4f       	sbci	r29, 0xFE	; 254
    26a6:	1a 82       	std	Y+2, r1	; 0x02

			break;
    26a8:	14 c0       	rjmp	.+40     	; 0x26d2 <AICI_InterpretPacket+0x2ca>
		case CMD_PROGRAM_FLASH_ISP:
		case CMD_PROGRAM_EEPROM_ISP:
			ISPCC_ProgramChip();                          // Program the bytes into the chip
    26aa:	0e 94 1c 11 	call	0x2238 <ISPCC_ProgramChip>
			
			MessageSize = 2;
    26ae:	82 e0       	ldi	r24, 0x02	; 2
    26b0:	90 e0       	ldi	r25, 0x00	; 0
    26b2:	90 93 31 01 	sts	0x0131, r25
    26b6:	80 93 30 01 	sts	0x0130, r24

			PacketBytes[1] = STATUS_CMD_OK;
    26ba:	10 92 35 01 	sts	0x0135, r1
			
			break;
    26be:	09 c0       	rjmp	.+18     	; 0x26d2 <AICI_InterpretPacket+0x2ca>
		default:                                        // Unknown command, return error
			MessageSize = 1;
    26c0:	81 e0       	ldi	r24, 0x01	; 1
    26c2:	90 e0       	ldi	r25, 0x00	; 0
    26c4:	90 93 31 01 	sts	0x0131, r25
    26c8:	80 93 30 01 	sts	0x0130, r24
			
			PacketBytes[1] = STATUS_CMD_UNKNOWN;
    26cc:	89 ec       	ldi	r24, 0xC9	; 201
    26ce:	80 93 35 01 	sts	0x0135, r24
	}

	V2P_SendPacket();                                   // Send the response packet
    26d2:	0e 94 fd 0d 	call	0x1bfa <V2P_SendPacket>
    26d6:	df 91       	pop	r29
    26d8:	cf 91       	pop	r28
    26da:	1f 91       	pop	r17
    26dc:	0f 91       	pop	r16
    26de:	ff 90       	pop	r15
    26e0:	ef 90       	pop	r14
    26e2:	df 90       	pop	r13
    26e4:	08 95       	ret

000026e6 <PM_GetStoredDataSize>:

// ======================================================================================

uint32_t PM_GetStoredDataSize(uint8_t Type)
{
    26e6:	ef 92       	push	r14
    26e8:	ff 92       	push	r15
    26ea:	0f 93       	push	r16
    26ec:	1f 93       	push	r17
    26ee:	cf 93       	push	r28
    26f0:	df 93       	push	r29
    26f2:	cd b7       	in	r28, 0x3d	; 61
    26f4:	de b7       	in	r29, 0x3e	; 62
    26f6:	22 97       	sbiw	r28, 0x02	; 2
    26f8:	0f b6       	in	r0, 0x3f	; 63
    26fa:	f8 94       	cli
    26fc:	de bf       	out	0x3e, r29	; 62
    26fe:	0f be       	out	0x3f, r0	; 63
    2700:	cd bf       	out	0x3d, r28	; 61
	/* This take a **LOT** of code (202 bytes), and is accessed several times throughout
	   the program, so I've put it into a seperate function to save on flash.            */

	uint32_t ProgDataSize  = 0;
	uint16_t EEPROMAddress;

	EEPROMAddress = ((Type == TYPE_FLASH)? Prog_DataSize : Prog_EEPROMSize);
    2702:	81 30       	cpi	r24, 0x01	; 1
    2704:	29 f4       	brne	.+10     	; 0x2710 <PM_GetStoredDataSize+0x2a>
    2706:	80 91 16 01 	lds	r24, 0x0116
    270a:	90 91 17 01 	lds	r25, 0x0117
    270e:	04 c0       	rjmp	.+8      	; 0x2718 <PM_GetStoredDataSize+0x32>
    2710:	80 91 14 01 	lds	r24, 0x0114
    2714:	90 91 15 01 	lds	r25, 0x0115
    2718:	9a 83       	std	Y+2, r25	; 0x02
    271a:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize  = ((uint32_t)eeprom_read_byte_169(&EEPROMAddress) << 24);
    271c:	ce 01       	movw	r24, r28
    271e:	01 96       	adiw	r24, 0x01	; 1
    2720:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
    2724:	99 27       	eor	r25, r25
    2726:	aa 27       	eor	r26, r26
    2728:	bb 27       	eor	r27, r27
    272a:	18 2f       	mov	r17, r24
    272c:	00 27       	eor	r16, r16
    272e:	ff 24       	eor	r15, r15
    2730:	ee 24       	eor	r14, r14
	EEPROMAddress++;
    2732:	89 81       	ldd	r24, Y+1	; 0x01
    2734:	9a 81       	ldd	r25, Y+2	; 0x02
    2736:	01 96       	adiw	r24, 0x01	; 1
    2738:	9a 83       	std	Y+2, r25	; 0x02
    273a:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize |= ((uint32_t)eeprom_read_byte_169(&EEPROMAddress) << 16);
    273c:	ce 01       	movw	r24, r28
    273e:	01 96       	adiw	r24, 0x01	; 1
    2740:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
    2744:	99 27       	eor	r25, r25
    2746:	aa 27       	eor	r26, r26
    2748:	bb 27       	eor	r27, r27
    274a:	dc 01       	movw	r26, r24
    274c:	99 27       	eor	r25, r25
    274e:	88 27       	eor	r24, r24
    2750:	e8 2a       	or	r14, r24
    2752:	f9 2a       	or	r15, r25
    2754:	0a 2b       	or	r16, r26
    2756:	1b 2b       	or	r17, r27
	EEPROMAddress++;
    2758:	89 81       	ldd	r24, Y+1	; 0x01
    275a:	9a 81       	ldd	r25, Y+2	; 0x02
    275c:	01 96       	adiw	r24, 0x01	; 1
    275e:	9a 83       	std	Y+2, r25	; 0x02
    2760:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize |= ((uint32_t)eeprom_read_byte_169(&EEPROMAddress) << 8);
    2762:	ce 01       	movw	r24, r28
    2764:	01 96       	adiw	r24, 0x01	; 1
    2766:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
    276a:	99 27       	eor	r25, r25
    276c:	aa 27       	eor	r26, r26
    276e:	bb 27       	eor	r27, r27
    2770:	ba 2f       	mov	r27, r26
    2772:	a9 2f       	mov	r26, r25
    2774:	98 2f       	mov	r25, r24
    2776:	88 27       	eor	r24, r24
    2778:	e8 2a       	or	r14, r24
    277a:	f9 2a       	or	r15, r25
    277c:	0a 2b       	or	r16, r26
    277e:	1b 2b       	or	r17, r27
	EEPROMAddress++;
    2780:	89 81       	ldd	r24, Y+1	; 0x01
    2782:	9a 81       	ldd	r25, Y+2	; 0x02
    2784:	01 96       	adiw	r24, 0x01	; 1
    2786:	9a 83       	std	Y+2, r25	; 0x02
    2788:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize |= eeprom_read_byte_169(&EEPROMAddress);
    278a:	ce 01       	movw	r24, r28
    278c:	01 96       	adiw	r24, 0x01	; 1
    278e:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
    2792:	99 27       	eor	r25, r25
    2794:	aa 27       	eor	r26, r26
    2796:	bb 27       	eor	r27, r27
    2798:	e8 2a       	or	r14, r24
    279a:	f9 2a       	or	r15, r25
    279c:	0a 2b       	or	r16, r26
    279e:	1b 2b       	or	r17, r27

	if (ProgDataSize == 0xFFFFFFFF)                                      // Blank EEPROM, return a size  of 0 bytes
    27a0:	8f ef       	ldi	r24, 0xFF	; 255
    27a2:	e8 16       	cp	r14, r24
    27a4:	8f ef       	ldi	r24, 0xFF	; 255
    27a6:	f8 06       	cpc	r15, r24
    27a8:	8f ef       	ldi	r24, 0xFF	; 255
    27aa:	08 07       	cpc	r16, r24
    27ac:	8f ef       	ldi	r24, 0xFF	; 255
    27ae:	18 07       	cpc	r17, r24
    27b0:	19 f4       	brne	.+6      	; 0x27b8 <PM_GetStoredDataSize+0xd2>
	   ProgDataSize = 0x00;
    27b2:	ee 24       	eor	r14, r14
    27b4:	ff 24       	eor	r15, r15
    27b6:	87 01       	movw	r16, r14

	return ProgDataSize;
}
    27b8:	c8 01       	movw	r24, r16
    27ba:	b7 01       	movw	r22, r14
    27bc:	22 96       	adiw	r28, 0x02	; 2
    27be:	0f b6       	in	r0, 0x3f	; 63
    27c0:	f8 94       	cli
    27c2:	de bf       	out	0x3e, r29	; 62
    27c4:	0f be       	out	0x3f, r0	; 63
    27c6:	cd bf       	out	0x3d, r28	; 61
    27c8:	df 91       	pop	r29
    27ca:	cf 91       	pop	r28
    27cc:	1f 91       	pop	r17
    27ce:	0f 91       	pop	r16
    27d0:	ff 90       	pop	r15
    27d2:	ef 90       	pop	r14
    27d4:	08 95       	ret

000027d6 <PM_SetupDFAddressCounters>:

void PM_SetupDFAddressCounters(uint8_t Type)
{
	uint32_t StartAddress;

	MemoryType   = Type;
    27d6:	80 93 4a 02 	sts	0x024A, r24
	PageLength   = 0;
    27da:	10 92 48 02 	sts	0x0248, r1
    27de:	10 92 47 02 	sts	0x0247, r1
    27e2:	20 91 2b 01 	lds	r18, 0x012B
    27e6:	30 91 2c 01 	lds	r19, 0x012C
    27ea:	40 91 2d 01 	lds	r20, 0x012D
    27ee:	50 91 2e 01 	lds	r21, 0x012E

	if (Type == TYPE_FLASH)                                              // Type 1 = Flash
    27f2:	81 30       	cpi	r24, 0x01	; 1
    27f4:	39 f4       	brne	.+14     	; 0x2804 <PM_SetupDFAddressCounters+0x2e>
		StartAddress = (CurrAddress << 1);                               // Convert flash word address to byte address
    27f6:	da 01       	movw	r26, r20
    27f8:	c9 01       	movw	r24, r18
    27fa:	88 0f       	add	r24, r24
    27fc:	99 1f       	adc	r25, r25
    27fe:	aa 1f       	adc	r26, r26
    2800:	bb 1f       	adc	r27, r27
    2802:	06 c0       	rjmp	.+12     	; 0x2810 <PM_SetupDFAddressCounters+0x3a>
	else
		StartAddress = CurrAddress + PM_EEPROM_OFFSET;                   // EEPROM uses byte addresses, and starts at the 257th kilobyte in Dataflash
    2804:	da 01       	movw	r26, r20
    2806:	c9 01       	movw	r24, r18
    2808:	80 50       	subi	r24, 0x00	; 0
    280a:	9c 4f       	sbci	r25, 0xFC	; 252
    280c:	ab 4f       	sbci	r26, 0xFB	; 251
    280e:	bf 4f       	sbci	r27, 0xFF	; 255
	
	CurrPageAddress = 0;
    2810:	10 92 8c 02 	sts	0x028C, r1
    2814:	10 92 8b 02 	sts	0x028B, r1

	while (StartAddress > DF_INTERNALDF_BUFFBYTES)                      // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DF_INTERNALDF_BUFFBYTES;                         // Subtract one page's worth of bytes from the desired address
		CurrPageAddress++;
    2818:	89 30       	cpi	r24, 0x09	; 9
    281a:	21 e0       	ldi	r18, 0x01	; 1
    281c:	92 07       	cpc	r25, r18
    281e:	20 e0       	ldi	r18, 0x00	; 0
    2820:	a2 07       	cpc	r26, r18
    2822:	20 e0       	ldi	r18, 0x00	; 0
    2824:	b2 07       	cpc	r27, r18
    2826:	a0 f0       	brcs	.+40     	; 0x2850 <PM_SetupDFAddressCounters+0x7a>
    2828:	20 e0       	ldi	r18, 0x00	; 0
    282a:	30 e0       	ldi	r19, 0x00	; 0
    282c:	88 50       	subi	r24, 0x08	; 8
    282e:	91 40       	sbci	r25, 0x01	; 1
    2830:	a0 40       	sbci	r26, 0x00	; 0
    2832:	b0 40       	sbci	r27, 0x00	; 0
    2834:	2f 5f       	subi	r18, 0xFF	; 255
    2836:	3f 4f       	sbci	r19, 0xFF	; 255
    2838:	89 30       	cpi	r24, 0x09	; 9
    283a:	41 e0       	ldi	r20, 0x01	; 1
    283c:	94 07       	cpc	r25, r20
    283e:	40 e0       	ldi	r20, 0x00	; 0
    2840:	a4 07       	cpc	r26, r20
    2842:	40 e0       	ldi	r20, 0x00	; 0
    2844:	b4 07       	cpc	r27, r20
    2846:	90 f7       	brcc	.-28     	; 0x282c <PM_SetupDFAddressCounters+0x56>
    2848:	30 93 8c 02 	sts	0x028C, r19
    284c:	20 93 8b 02 	sts	0x028B, r18
	}
	
	CurrBuffByte = (uint16_t)StartAddress;                               // The buffer byte is the remainder
    2850:	90 93 85 02 	sts	0x0285, r25
    2854:	80 93 84 02 	sts	0x0284, r24
    2858:	08 95       	ret

0000285a <PM_StoreProgramByte>:
}

void PM_StoreProgramByte(uint8_t Data)
{
    285a:	cf 93       	push	r28
    285c:	c8 2f       	mov	r28, r24
	if (CurrBuffByte == DF_INTERNALDF_BUFFBYTES)
    285e:	80 91 84 02 	lds	r24, 0x0284
    2862:	90 91 85 02 	lds	r25, 0x0285
    2866:	88 50       	subi	r24, 0x08	; 8
    2868:	91 40       	sbci	r25, 0x01	; 1
    286a:	a9 f4       	brne	.+42     	; 0x2896 <PM_StoreProgramByte+0x3c>
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
    286c:	80 91 8b 02 	lds	r24, 0x028B
    2870:	90 91 8c 02 	lds	r25, 0x028C
    2874:	9c 01       	movw	r18, r24
    2876:	01 96       	adiw	r24, 0x01	; 1
    2878:	90 93 8c 02 	sts	0x028C, r25
    287c:	80 93 8b 02 	sts	0x028B, r24
    2880:	c9 01       	movw	r24, r18
    2882:	0e 94 36 0b 	call	0x166c <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    2886:	80 e0       	ldi	r24, 0x00	; 0
    2888:	90 e0       	ldi	r25, 0x00	; 0
    288a:	0e 94 56 0a 	call	0x14ac <DF_BufferWriteEnable>
		CurrBuffByte = 0;
    288e:	10 92 85 02 	sts	0x0285, r1
    2892:	10 92 84 02 	sts	0x0284, r1
	}
	
	SPI_SPITransmit(Data);                                               // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    2896:	8c 2f       	mov	r24, r28
    2898:	0e 94 3a 09 	call	0x1274 <SPI_SPITransmit>
	CurrBuffByte++;
    289c:	80 91 84 02 	lds	r24, 0x0284
    28a0:	90 91 85 02 	lds	r25, 0x0285
    28a4:	01 96       	adiw	r24, 0x01	; 1
    28a6:	90 93 85 02 	sts	0x0285, r25
    28aa:	80 93 84 02 	sts	0x0284, r24
	PageLength++;
    28ae:	80 91 47 02 	lds	r24, 0x0247
    28b2:	90 91 48 02 	lds	r25, 0x0248
    28b6:	01 96       	adiw	r24, 0x01	; 1
    28b8:	90 93 48 02 	sts	0x0248, r25
    28bc:	80 93 47 02 	sts	0x0247, r24
    28c0:	cf 91       	pop	r28
    28c2:	08 95       	ret

000028c4 <PM_CheckEndOfProgramming>:
}

void PM_InterpretAVRISPPacket(void)
{
	uint16_t EEPROMAddress;

	switch (PacketBytes[0])
	{
		case CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
			
			EEPROMAddress = Prog_EnterProgMode;
			
			for (uint8_t PacketB = 0; PacketB <= 11; PacketB++)          // Save the enter programming mode command bytes
			{
				eeprom_write_byte_169(&EEPROMAddress, PacketBytes[PacketB]);
				EEPROMAddress++;
			}
			
			InProgrammingMode = TRUE;                                    // Set the flag, prevent the user from exiting the V2P state machine			
			CurrentMode = PM_NO_SETUP;                                   // Clear the current mode variable

			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = STATUS_CMD_OK;

			break;			
		case CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;

			PM_CheckEndOfProgramming();                                  // Check if the last command was a program - if so store the program length
			PM_CheckEndOfFuseLockStore();                                // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
			
			InProgrammingMode = FALSE;                                   // Clear the flag, allow the user to exit the V2P state machine

			DF_EnableDataflash(FALSE);

			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
			PacketBytes[1] = STATUS_CMD_OK;

			break;
		case CMD_READ_SIGNATURE_ISP:
			MessageSize = 4;

			PacketBytes[1] = STATUS_CMD_OK;                              // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x01;                                       // Signature bytes all return "01" in storage mode
			PacketBytes[3] = STATUS_CMD_OK;                              // Data byte is encased in CMD_OKs

			break;
		case CMD_CHIP_ERASE_ISP:
			MessageSize = 2;

			EEPROMAddress = Prog_EraseChip;                              // Program erase chip command start address
			
			for (uint8_t PacketB = 1; PacketB <= 6; PacketB++)          // Save the erase chip command bytes to EEPROM
			{
				eeprom_write_byte_169(&EEPROMAddress, PacketBytes[PacketB]);
				EEPROMAddress++;
			}

			EEPROMAddress = Prog_DataSize;
										
			for (uint8_t Byte = 0; Byte < 8; Byte++)                    // Clear the program and EEPROM size counters
			{
				if (Byte == 4)
				   EEPROMAddress = Prog_EEPROMSize;

				eeprom_write_byte_169(&EEPROMAddress, 0x00);
				EEPROMAddress++;						
			}
			
			eeprom_write_byte_169(&Prog_EraseCmdStored, TRUE);
			
			PacketBytes[1] = STATUS_CMD_OK;
			
			break;
		case CMD_READ_OSCCAL_ISP:
			MessageSize = 4;

			PacketBytes[1] = STATUS_CMD_OK;                             // Data byte is encased in CMD_OKs
			PacketBytes[1] = 0x00;                                      // Return 0x00 for the OSCCAL byte
			PacketBytes[3] = STATUS_CMD_OK;                             // Data byte is encased in CMD_OKs

			break;
		case CMD_READ_FUSE_ISP:
		case CMD_READ_LOCK_ISP:
			MessageSize = 4;
	
			if (CurrentMode != PM_LOCKFUSEBITS_READ)                    // First lock or fuse byte being read, set the EEPROM pointer
			{
				PM_CheckEndOfProgramming();                             // Check if the last command was a program - if so store the program length
				PM_CheckEndOfFuseLockStore();                           // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
				
				CurrBuffByte = 0;
				CurrentMode  = PM_LOCKFUSEBITS_READ;
			}
			
			EEPROMAddress = ((PacketBytes[0] == CMD_READ_FUSE_ISP)? Prog_TotalFuseBytes : Prog_TotalLockBytes);

			if (CurrBuffByte > eeprom_read_byte_169(&EEPROMAddress))    // Trying to read more fuse/lock bytes than are stored in memory
			{
				PacketBytes[2] = 0xFF;                                  // Return 0xFF for the fuse/lock byte
			}
			else
			{
				EEPROMAddress  = ((PacketBytes[0] == CMD_READ_FUSE_ISP)? Prog_FuseBytes : Prog_LockBytes) // Starting location
									+ (CurrBuffByte << 2) + (PacketBytes[1] - 1); // The start position of the actual fuse/lock byte to read (4 bytes each)

				PacketBytes[2] = eeprom_read_byte_169(&EEPROMAddress); // Return the fuse/lock byte
			}

			PacketBytes[1] = STATUS_CMD_OK;                            // Data byte is encased in CMD_OKs
			PacketBytes[3] = STATUS_CMD_OK;                            // Data byte is encased in CMD_OKs

			CurrBuffByte++;

			break;
		case CMD_PROGRAM_FUSE_ISP:
		case CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;

			if (CurrentMode != PM_LOCKFUSEBITS_WRITE)                  // First lock or fuse byte being written, set the EEPROM pointer
			{
				CurrentMode   = PM_LOCKFUSEBITS_WRITE;
				CurrBuffByte  = 0;                                     // CurrBuffByte is used to store the total fuse/lock bytes written
			}

			if (PacketBytes[0] == CMD_PROGRAM_FUSE_ISP)
			{
				EEPROMAddress = Prog_FuseBytes + (CurrBuffByte << 2);
				MemoryType    = TYPE_FUSE;
			}
			else
			{
				EEPROMAddress = Prog_LockBytes + (CurrBuffByte << 2);
				MemoryType    = TYPE_LOCK;
			}				
			
			if (CurrBuffByte < PM_MAX_FUSELOCKBITS)
			{
				for (uint8_t FLByte = 1; FLByte <= 4; FLByte++)
				{
					eeprom_write_byte_169(&EEPROMAddress, PacketBytes[FLByte]);
					EEPROMAddress++;
				}

				CurrBuffByte++;                                        // Increment the total fuse/lock bytes written counter
			}
			
			PacketBytes[1] = STATUS_CMD_OK;                            // Two CMD_OKs are always returned
			PacketBytes[2] = STATUS_CMD_OK;                            // Two CMD_OKs are always returned

			break;
		case CMD_PROGRAM_FLASH_ISP:
		case CMD_PROGRAM_EEPROM_ISP:
			MessageSize = 2;

			if (CurrentMode != PM_DATAFLASH_WRITE)                     // First programming packet
			{
				if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)           // Flash programming mode
				{
					EEPROMAddress = Prog_WriteProgram;                 // Set the eeprom address to the Program command bytes location
					PM_SetupDFAddressCounters(TYPE_FLASH);
				}
				else                                                  // EEPROM programming mode
				{
					EEPROMAddress = Prog_WriteEEPROM;                  // Set the eeprom address to the EEPROM command bytes location
					PM_SetupDFAddressCounters(TYPE_EEPROM);
				}
				
				DF_BufferWriteEnable(CurrBuffByte);
				CurrentMode = PM_DATAFLASH_WRITE;
				
				for (uint8_t B = 1; B <= 9; B++)                       // Save the command bytes
				{
					eeprom_write_byte_169(&EEPROMAddress, PacketBytes[B]);
					EEPROMAddress++;				
				}
			}

			uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
			                      | PacketBytes[2];

			for (uint16_t CurrByte = 0; CurrByte < BytesToWrite; CurrByte++)
				PM_StoreProgramByte(PacketBytes[10 + CurrByte]);
						
			if ((PacketBytes[3] & ISPCC_PROG_MODE_PAGEDONE) && !(PageLength & PM_PAGELENGTH_FOUNDBIT) && PageLength)
			{
				EEPROMAddress = ((MemoryType == TYPE_FLASH)? Prog_PageLength : Prog_EPageLength);
	
				eeprom_write_byte_169(&EEPROMAddress, (uint8_t)(PageLength >> 8));
				EEPROMAddress++;
				eeprom_write_byte_169(&EEPROMAddress, (uint8_t)PageLength);		
		
				PageLength |= PM_PAGELENGTH_FOUNDBIT;                 // Bit 15 is used to indicate if the length has been found
			}

			PacketBytes[1] = STATUS_CMD_OK;
		
			break;
		case CMD_READ_FLASH_ISP:
		case CMD_READ_EEPROM_ISP:	
			if (CurrentMode != PM_DATAFLASH_READ)
			{
				PM_CheckEndOfProgramming();                           // Check if the last command was a program - if so store the program length
				PM_CheckEndOfFuseLockStore();                         // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
				
				PM_SetupDFAddressCounters((PacketBytes[0] == CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);
				DF_ContinuousReadEnable(CurrPageAddress, CurrBuffByte);
				
				CurrentMode = PM_DATAFLASH_READ;
				CurrAddress = 0;
			}

			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8)    // \. Load in the number of bytes that is to
			                     | PacketBytes[2];                    // /  be read into a temp variable (MSB first)
						
			uint16_t BytesInMem  = PM_GetStoredDataSize((PacketBytes[0] == CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
			   PacketBytes[2 + ReadByte] = ((CurrAddress < BytesInMem)? SPI_SPITransmit(0x00) : 0xFF); // Read in the next dataflash byte if present
			   V2P_IncrementCurrAddress();
			}
			
			MessageSize = BytesToRead + 3;

			PacketBytes[1]               = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
			PacketBytes[2 + BytesToRead] = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
		
			break;
		default:
			MessageSize = 1;
			
			PacketBytes[1] = STATUS_CMD_UNKNOWN;
	}

	V2P_SendPacket();                                   // Send the response packet
}

void PM_CheckEndOfProgramming(void)
{
    28c4:	ef 92       	push	r14
    28c6:	ff 92       	push	r15
    28c8:	0f 93       	push	r16
    28ca:	1f 93       	push	r17
    28cc:	cf 93       	push	r28
    28ce:	df 93       	push	r29
    28d0:	cd b7       	in	r28, 0x3d	; 61
    28d2:	de b7       	in	r29, 0x3e	; 62
    28d4:	22 97       	sbiw	r28, 0x02	; 2
    28d6:	0f b6       	in	r0, 0x3f	; 63
    28d8:	f8 94       	cli
    28da:	de bf       	out	0x3e, r29	; 62
    28dc:	0f be       	out	0x3f, r0	; 63
    28de:	cd bf       	out	0x3d, r28	; 61
   uint16_t EEPROMAddress;

   if (CurrentMode == PM_DATAFLASH_WRITE)
    28e0:	80 91 49 02 	lds	r24, 0x0249
    28e4:	81 30       	cpi	r24, 0x01	; 1
    28e6:	09 f0       	breq	.+2      	; 0x28ea <PM_CheckEndOfProgramming+0x26>
    28e8:	6d c0       	rjmp	.+218    	; 0x29c4 <PM_CheckEndOfProgramming+0x100>
   {
      if (CurrBuffByte)                               // Data in the dataflash buffer, pending to be written
    28ea:	80 91 84 02 	lds	r24, 0x0284
    28ee:	90 91 85 02 	lds	r25, 0x0285
    28f2:	89 2b       	or	r24, r25
    28f4:	31 f0       	breq	.+12     	; 0x2902 <PM_CheckEndOfProgramming+0x3e>
         DF_CopyBufferToFlashPage(CurrPageAddress);   // Save the buffer
    28f6:	80 91 8b 02 	lds	r24, 0x028B
    28fa:	90 91 8c 02 	lds	r25, 0x028C
    28fe:	0e 94 36 0b 	call	0x166c <DF_CopyBufferToFlashPage>

      uint32_t DataSize = ((uint32_t)CurrPageAddress * DF_INTERNALDF_BUFFBYTES) + CurrBuffByte;
    2902:	80 91 8b 02 	lds	r24, 0x028B
    2906:	90 91 8c 02 	lds	r25, 0x028C
    290a:	aa 27       	eor	r26, r26
    290c:	bb 27       	eor	r27, r27
    290e:	bc 01       	movw	r22, r24
    2910:	cd 01       	movw	r24, r26
    2912:	28 e0       	ldi	r18, 0x08	; 8
    2914:	31 e0       	ldi	r19, 0x01	; 1
    2916:	40 e0       	ldi	r20, 0x00	; 0
    2918:	50 e0       	ldi	r21, 0x00	; 0
    291a:	0e 94 68 1b 	call	0x36d0 <__mulsi3>
    291e:	7b 01       	movw	r14, r22
    2920:	8c 01       	movw	r16, r24
    2922:	80 91 84 02 	lds	r24, 0x0284
    2926:	90 91 85 02 	lds	r25, 0x0285
    292a:	aa 27       	eor	r26, r26
    292c:	bb 27       	eor	r27, r27
    292e:	e8 0e       	add	r14, r24
    2930:	f9 1e       	adc	r15, r25
    2932:	0a 1f       	adc	r16, r26
    2934:	1b 1f       	adc	r17, r27

      if (MemoryType == TYPE_FLASH)
    2936:	80 91 4a 02 	lds	r24, 0x024A
    293a:	81 30       	cpi	r24, 0x01	; 1
    293c:	39 f4       	brne	.+14     	; 0x294c <PM_CheckEndOfProgramming+0x88>
      {
         EEPROMAddress = Prog_DataSize;       
    293e:	80 91 16 01 	lds	r24, 0x0116
    2942:	90 91 17 01 	lds	r25, 0x0117
    2946:	9a 83       	std	Y+2, r25	; 0x02
    2948:	89 83       	std	Y+1, r24	; 0x01
    294a:	0e c0       	rjmp	.+28     	; 0x2968 <PM_CheckEndOfProgramming+0xa4>
      }
      else
      {
         EEPROMAddress = Prog_EEPROMSize;
    294c:	80 91 14 01 	lds	r24, 0x0114
    2950:	90 91 15 01 	lds	r25, 0x0115
    2954:	9a 83       	std	Y+2, r25	; 0x02
    2956:	89 83       	std	Y+1, r24	; 0x01
         DataSize -= PM_EEPROM_OFFSET;                // Remove DataFlash starting offset
    2958:	80 e0       	ldi	r24, 0x00	; 0
    295a:	9c ef       	ldi	r25, 0xFC	; 252
    295c:	ab ef       	ldi	r26, 0xFB	; 251
    295e:	bf ef       	ldi	r27, 0xFF	; 255
    2960:	e8 0e       	add	r14, r24
    2962:	f9 1e       	adc	r15, r25
    2964:	0a 1f       	adc	r16, r26
    2966:	1b 1f       	adc	r17, r27
      }

      eeprom_write_byte_169(&EEPROMAddress, (DataSize >> 24));
    2968:	81 2f       	mov	r24, r17
    296a:	99 27       	eor	r25, r25
    296c:	aa 27       	eor	r26, r26
    296e:	bb 27       	eor	r27, r27
    2970:	68 2f       	mov	r22, r24
    2972:	ce 01       	movw	r24, r28
    2974:	01 96       	adiw	r24, 0x01	; 1
    2976:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
      EEPROMAddress++;
    297a:	89 81       	ldd	r24, Y+1	; 0x01
    297c:	9a 81       	ldd	r25, Y+2	; 0x02
    297e:	01 96       	adiw	r24, 0x01	; 1
    2980:	9a 83       	std	Y+2, r25	; 0x02
    2982:	89 83       	std	Y+1, r24	; 0x01
      eeprom_write_byte_169(&EEPROMAddress, (DataSize >> 16));             
    2984:	c8 01       	movw	r24, r16
    2986:	aa 27       	eor	r26, r26
    2988:	bb 27       	eor	r27, r27
    298a:	68 2f       	mov	r22, r24
    298c:	ce 01       	movw	r24, r28
    298e:	01 96       	adiw	r24, 0x01	; 1
    2990:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
      EEPROMAddress++;
    2994:	89 81       	ldd	r24, Y+1	; 0x01
    2996:	9a 81       	ldd	r25, Y+2	; 0x02
    2998:	01 96       	adiw	r24, 0x01	; 1
    299a:	9a 83       	std	Y+2, r25	; 0x02
    299c:	89 83       	std	Y+1, r24	; 0x01
      eeprom_write_byte_169(&EEPROMAddress, (DataSize >> 8));
    299e:	bb 27       	eor	r27, r27
    29a0:	a1 2f       	mov	r26, r17
    29a2:	90 2f       	mov	r25, r16
    29a4:	8f 2d       	mov	r24, r15
    29a6:	68 2f       	mov	r22, r24
    29a8:	ce 01       	movw	r24, r28
    29aa:	01 96       	adiw	r24, 0x01	; 1
    29ac:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
      EEPROMAddress++;
    29b0:	89 81       	ldd	r24, Y+1	; 0x01
    29b2:	9a 81       	ldd	r25, Y+2	; 0x02
    29b4:	01 96       	adiw	r24, 0x01	; 1
    29b6:	9a 83       	std	Y+2, r25	; 0x02
    29b8:	89 83       	std	Y+1, r24	; 0x01
      eeprom_write_byte_169(&EEPROMAddress, DataSize);
    29ba:	6e 2d       	mov	r22, r14
    29bc:	ce 01       	movw	r24, r28
    29be:	01 96       	adiw	r24, 0x01	; 1
    29c0:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
    29c4:	22 96       	adiw	r28, 0x02	; 2
    29c6:	0f b6       	in	r0, 0x3f	; 63
    29c8:	f8 94       	cli
    29ca:	de bf       	out	0x3e, r29	; 62
    29cc:	0f be       	out	0x3f, r0	; 63
    29ce:	cd bf       	out	0x3d, r28	; 61
    29d0:	df 91       	pop	r29
    29d2:	cf 91       	pop	r28
    29d4:	1f 91       	pop	r17
    29d6:	0f 91       	pop	r16
    29d8:	ff 90       	pop	r15
    29da:	ef 90       	pop	r14
    29dc:	08 95       	ret

000029de <PM_CheckEndOfFuseLockStore>:
   }
}

void PM_CheckEndOfFuseLockStore(void)
{
    29de:	cf 93       	push	r28
    29e0:	df 93       	push	r29
    29e2:	cd b7       	in	r28, 0x3d	; 61
    29e4:	de b7       	in	r29, 0x3e	; 62
    29e6:	22 97       	sbiw	r28, 0x02	; 2
    29e8:	0f b6       	in	r0, 0x3f	; 63
    29ea:	f8 94       	cli
    29ec:	de bf       	out	0x3e, r29	; 62
    29ee:	0f be       	out	0x3f, r0	; 63
    29f0:	cd bf       	out	0x3d, r28	; 61
	uint16_t EEPROMAddress;

	if (CurrentMode == PM_LOCKFUSEBITS_WRITE)
    29f2:	80 91 49 02 	lds	r24, 0x0249
    29f6:	83 30       	cpi	r24, 0x03	; 3
    29f8:	a9 f4       	brne	.+42     	; 0x2a24 <PM_CheckEndOfFuseLockStore+0x46>
	{
		EEPROMAddress = ((MemoryType == TYPE_FUSE)? Prog_TotalFuseBytes : Prog_TotalLockBytes);
    29fa:	80 91 4a 02 	lds	r24, 0x024A
    29fe:	82 30       	cpi	r24, 0x02	; 2
    2a00:	29 f4       	brne	.+10     	; 0x2a0c <PM_CheckEndOfFuseLockStore+0x2e>
    2a02:	80 91 10 01 	lds	r24, 0x0110
    2a06:	90 91 11 01 	lds	r25, 0x0111
    2a0a:	04 c0       	rjmp	.+8      	; 0x2a14 <PM_CheckEndOfFuseLockStore+0x36>
    2a0c:	80 91 0e 01 	lds	r24, 0x010E
    2a10:	90 91 0f 01 	lds	r25, 0x010F
    2a14:	9a 83       	std	Y+2, r25	; 0x02
    2a16:	89 83       	std	Y+1, r24	; 0x01
		
		eeprom_write_byte_169(&EEPROMAddress, CurrBuffByte); // CurrBuffByte stores the total number of fuse/lock bytes written in this case
    2a18:	60 91 84 02 	lds	r22, 0x0284
    2a1c:	ce 01       	movw	r24, r28
    2a1e:	01 96       	adiw	r24, 0x01	; 1
    2a20:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
    2a24:	22 96       	adiw	r28, 0x02	; 2
    2a26:	0f b6       	in	r0, 0x3f	; 63
    2a28:	f8 94       	cli
    2a2a:	de bf       	out	0x3e, r29	; 62
    2a2c:	0f be       	out	0x3f, r0	; 63
    2a2e:	cd bf       	out	0x3d, r28	; 61
    2a30:	df 91       	pop	r29
    2a32:	cf 91       	pop	r28
    2a34:	08 95       	ret

00002a36 <PM_InterpretAVRISPPacket>:
    2a36:	af 92       	push	r10
    2a38:	bf 92       	push	r11
    2a3a:	cf 92       	push	r12
    2a3c:	df 92       	push	r13
    2a3e:	ef 92       	push	r14
    2a40:	ff 92       	push	r15
    2a42:	0f 93       	push	r16
    2a44:	1f 93       	push	r17
    2a46:	cf 93       	push	r28
    2a48:	df 93       	push	r29
    2a4a:	cd b7       	in	r28, 0x3d	; 61
    2a4c:	de b7       	in	r29, 0x3e	; 62
    2a4e:	22 97       	sbiw	r28, 0x02	; 2
    2a50:	0f b6       	in	r0, 0x3f	; 63
    2a52:	f8 94       	cli
    2a54:	de bf       	out	0x3e, r29	; 62
    2a56:	0f be       	out	0x3f, r0	; 63
    2a58:	cd bf       	out	0x3d, r28	; 61
    2a5a:	40 91 34 01 	lds	r20, 0x0134
    2a5e:	84 2f       	mov	r24, r20
    2a60:	99 27       	eor	r25, r25
    2a62:	86 31       	cpi	r24, 0x16	; 22
    2a64:	91 05       	cpc	r25, r1
    2a66:	09 f4       	brne	.+2      	; 0x2a6a <PM_InterpretAVRISPPacket+0x34>
    2a68:	18 c2       	rjmp	.+1072   	; 0x2e9a <PM_InterpretAVRISPPacket+0x464>
    2a6a:	87 31       	cpi	r24, 0x17	; 23
    2a6c:	91 05       	cpc	r25, r1
    2a6e:	94 f4       	brge	.+36     	; 0x2a94 <PM_InterpretAVRISPPacket+0x5e>
    2a70:	82 31       	cpi	r24, 0x12	; 18
    2a72:	91 05       	cpc	r25, r1
    2a74:	09 f4       	brne	.+2      	; 0x2a78 <PM_InterpretAVRISPPacket+0x42>
    2a76:	72 c0       	rjmp	.+228    	; 0x2b5c <PM_InterpretAVRISPPacket+0x126>
    2a78:	83 31       	cpi	r24, 0x13	; 19
    2a7a:	91 05       	cpc	r25, r1
    2a7c:	3c f4       	brge	.+14     	; 0x2a8c <PM_InterpretAVRISPPacket+0x56>
    2a7e:	80 31       	cpi	r24, 0x10	; 16
    2a80:	91 05       	cpc	r25, r1
    2a82:	19 f1       	breq	.+70     	; 0x2aca <PM_InterpretAVRISPPacket+0x94>
    2a84:	41 97       	sbiw	r24, 0x11	; 17
    2a86:	09 f4       	brne	.+2      	; 0x2a8a <PM_InterpretAVRISPPacket+0x54>
    2a88:	49 c0       	rjmp	.+146    	; 0x2b1c <PM_InterpretAVRISPPacket+0xe6>
    2a8a:	7b c2       	rjmp	.+1270   	; 0x2f82 <PM_InterpretAVRISPPacket+0x54c>
    2a8c:	44 97       	sbiw	r24, 0x14	; 20
    2a8e:	09 f4       	brne	.+2      	; 0x2a92 <PM_InterpretAVRISPPacket+0x5c>
    2a90:	04 c2       	rjmp	.+1032   	; 0x2e9a <PM_InterpretAVRISPPacket+0x464>
    2a92:	71 c1       	rjmp	.+738    	; 0x2d76 <PM_InterpretAVRISPPacket+0x340>
    2a94:	89 31       	cpi	r24, 0x19	; 25
    2a96:	91 05       	cpc	r25, r1
    2a98:	09 f4       	brne	.+2      	; 0x2a9c <PM_InterpretAVRISPPacket+0x66>
    2a9a:	11 c1       	rjmp	.+546    	; 0x2cbe <PM_InterpretAVRISPPacket+0x288>
    2a9c:	8a 31       	cpi	r24, 0x1A	; 26
    2a9e:	91 05       	cpc	r25, r1
    2aa0:	44 f4       	brge	.+16     	; 0x2ab2 <PM_InterpretAVRISPPacket+0x7c>
    2aa2:	87 31       	cpi	r24, 0x17	; 23
    2aa4:	91 05       	cpc	r25, r1
    2aa6:	09 f4       	brne	.+2      	; 0x2aaa <PM_InterpretAVRISPPacket+0x74>
    2aa8:	0a c1       	rjmp	.+532    	; 0x2cbe <PM_InterpretAVRISPPacket+0x288>
    2aaa:	48 97       	sbiw	r24, 0x18	; 24
    2aac:	09 f4       	brne	.+2      	; 0x2ab0 <PM_InterpretAVRISPPacket+0x7a>
    2aae:	a3 c0       	rjmp	.+326    	; 0x2bf6 <PM_InterpretAVRISPPacket+0x1c0>
    2ab0:	68 c2       	rjmp	.+1232   	; 0x2f82 <PM_InterpretAVRISPPacket+0x54c>
    2ab2:	8b 31       	cpi	r24, 0x1B	; 27
    2ab4:	91 05       	cpc	r25, r1
    2ab6:	09 f4       	brne	.+2      	; 0x2aba <PM_InterpretAVRISPPacket+0x84>
    2ab8:	45 c0       	rjmp	.+138    	; 0x2b44 <PM_InterpretAVRISPPacket+0x10e>
    2aba:	8b 31       	cpi	r24, 0x1B	; 27
    2abc:	91 05       	cpc	r25, r1
    2abe:	0c f4       	brge	.+2      	; 0x2ac2 <PM_InterpretAVRISPPacket+0x8c>
    2ac0:	9a c0       	rjmp	.+308    	; 0x2bf6 <PM_InterpretAVRISPPacket+0x1c0>
    2ac2:	4c 97       	sbiw	r24, 0x1c	; 28
    2ac4:	09 f4       	brne	.+2      	; 0x2ac8 <PM_InterpretAVRISPPacket+0x92>
    2ac6:	8c c0       	rjmp	.+280    	; 0x2be0 <PM_InterpretAVRISPPacket+0x1aa>
    2ac8:	5c c2       	rjmp	.+1208   	; 0x2f82 <PM_InterpretAVRISPPacket+0x54c>
    2aca:	82 e0       	ldi	r24, 0x02	; 2
    2acc:	90 e0       	ldi	r25, 0x00	; 0
    2ace:	90 93 31 01 	sts	0x0131, r25
    2ad2:	80 93 30 01 	sts	0x0130, r24
    2ad6:	80 91 12 01 	lds	r24, 0x0112
    2ada:	90 91 13 01 	lds	r25, 0x0113
    2ade:	9a 83       	std	Y+2, r25	; 0x02
    2ae0:	89 83       	std	Y+1, r24	; 0x01
    2ae2:	f4 e3       	ldi	r31, 0x34	; 52
    2ae4:	ef 2e       	mov	r14, r31
    2ae6:	f1 e0       	ldi	r31, 0x01	; 1
    2ae8:	ff 2e       	mov	r15, r31
    2aea:	1b e0       	ldi	r17, 0x0B	; 11
    2aec:	f7 01       	movw	r30, r14
    2aee:	61 91       	ld	r22, Z+
    2af0:	7f 01       	movw	r14, r30
    2af2:	ce 01       	movw	r24, r28
    2af4:	01 96       	adiw	r24, 0x01	; 1
    2af6:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
    2afa:	89 81       	ldd	r24, Y+1	; 0x01
    2afc:	9a 81       	ldd	r25, Y+2	; 0x02
    2afe:	01 96       	adiw	r24, 0x01	; 1
    2b00:	9a 83       	std	Y+2, r25	; 0x02
    2b02:	89 83       	std	Y+1, r24	; 0x01
    2b04:	11 50       	subi	r17, 0x01	; 1
    2b06:	17 ff       	sbrs	r17, 7
    2b08:	f1 cf       	rjmp	.-30     	; 0x2aec <PM_InterpretAVRISPPacket+0xb6>
    2b0a:	81 e0       	ldi	r24, 0x01	; 1
    2b0c:	80 93 2f 01 	sts	0x012F, r24
    2b10:	10 92 49 02 	sts	0x0249, r1
    2b14:	81 b3       	in	r24, 0x11	; 17
    2b16:	8f 7c       	andi	r24, 0xCF	; 207
    2b18:	80 62       	ori	r24, 0x20	; 32
    2b1a:	12 c0       	rjmp	.+36     	; 0x2b40 <PM_InterpretAVRISPPacket+0x10a>
    2b1c:	82 e0       	ldi	r24, 0x02	; 2
    2b1e:	90 e0       	ldi	r25, 0x00	; 0
    2b20:	90 93 31 01 	sts	0x0131, r25
    2b24:	80 93 30 01 	sts	0x0130, r24
    2b28:	0e 94 62 14 	call	0x28c4 <PM_CheckEndOfProgramming>
    2b2c:	0e 94 ef 14 	call	0x29de <PM_CheckEndOfFuseLockStore>
    2b30:	10 92 2f 01 	sts	0x012F, r1
    2b34:	80 e0       	ldi	r24, 0x00	; 0
    2b36:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    2b3a:	81 b3       	in	r24, 0x11	; 17
    2b3c:	8f 7c       	andi	r24, 0xCF	; 207
    2b3e:	80 61       	ori	r24, 0x10	; 16
    2b40:	81 bb       	out	0x11, r24	; 17
    2b42:	a8 c1       	rjmp	.+848    	; 0x2e94 <PM_InterpretAVRISPPacket+0x45e>
    2b44:	84 e0       	ldi	r24, 0x04	; 4
    2b46:	90 e0       	ldi	r25, 0x00	; 0
    2b48:	90 93 31 01 	sts	0x0131, r25
    2b4c:	80 93 30 01 	sts	0x0130, r24
    2b50:	10 92 35 01 	sts	0x0135, r1
    2b54:	81 e0       	ldi	r24, 0x01	; 1
    2b56:	80 93 36 01 	sts	0x0136, r24
    2b5a:	4a c0       	rjmp	.+148    	; 0x2bf0 <PM_InterpretAVRISPPacket+0x1ba>
    2b5c:	82 e0       	ldi	r24, 0x02	; 2
    2b5e:	90 e0       	ldi	r25, 0x00	; 0
    2b60:	90 93 31 01 	sts	0x0131, r25
    2b64:	80 93 30 01 	sts	0x0130, r24
    2b68:	80 91 18 01 	lds	r24, 0x0118
    2b6c:	90 91 19 01 	lds	r25, 0x0119
    2b70:	9a 83       	std	Y+2, r25	; 0x02
    2b72:	89 83       	std	Y+1, r24	; 0x01
    2b74:	e5 e3       	ldi	r30, 0x35	; 53
    2b76:	ee 2e       	mov	r14, r30
    2b78:	e1 e0       	ldi	r30, 0x01	; 1
    2b7a:	fe 2e       	mov	r15, r30
    2b7c:	15 e0       	ldi	r17, 0x05	; 5
    2b7e:	f7 01       	movw	r30, r14
    2b80:	61 91       	ld	r22, Z+
    2b82:	7f 01       	movw	r14, r30
    2b84:	ce 01       	movw	r24, r28
    2b86:	01 96       	adiw	r24, 0x01	; 1
    2b88:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
    2b8c:	89 81       	ldd	r24, Y+1	; 0x01
    2b8e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b90:	01 96       	adiw	r24, 0x01	; 1
    2b92:	9a 83       	std	Y+2, r25	; 0x02
    2b94:	89 83       	std	Y+1, r24	; 0x01
    2b96:	11 50       	subi	r17, 0x01	; 1
    2b98:	17 ff       	sbrs	r17, 7
    2b9a:	f1 cf       	rjmp	.-30     	; 0x2b7e <PM_InterpretAVRISPPacket+0x148>
    2b9c:	80 91 16 01 	lds	r24, 0x0116
    2ba0:	90 91 17 01 	lds	r25, 0x0117
    2ba4:	9a 83       	std	Y+2, r25	; 0x02
    2ba6:	89 83       	std	Y+1, r24	; 0x01
    2ba8:	10 e0       	ldi	r17, 0x00	; 0
    2baa:	14 30       	cpi	r17, 0x04	; 4
    2bac:	31 f4       	brne	.+12     	; 0x2bba <PM_InterpretAVRISPPacket+0x184>
    2bae:	80 91 14 01 	lds	r24, 0x0114
    2bb2:	90 91 15 01 	lds	r25, 0x0115
    2bb6:	9a 83       	std	Y+2, r25	; 0x02
    2bb8:	89 83       	std	Y+1, r24	; 0x01
    2bba:	60 e0       	ldi	r22, 0x00	; 0
    2bbc:	ce 01       	movw	r24, r28
    2bbe:	01 96       	adiw	r24, 0x01	; 1
    2bc0:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
    2bc4:	89 81       	ldd	r24, Y+1	; 0x01
    2bc6:	9a 81       	ldd	r25, Y+2	; 0x02
    2bc8:	01 96       	adiw	r24, 0x01	; 1
    2bca:	9a 83       	std	Y+2, r25	; 0x02
    2bcc:	89 83       	std	Y+1, r24	; 0x01
    2bce:	1f 5f       	subi	r17, 0xFF	; 255
    2bd0:	18 30       	cpi	r17, 0x08	; 8
    2bd2:	58 f3       	brcs	.-42     	; 0x2baa <PM_InterpretAVRISPPacket+0x174>
    2bd4:	61 e0       	ldi	r22, 0x01	; 1
    2bd6:	8a e1       	ldi	r24, 0x1A	; 26
    2bd8:	91 e0       	ldi	r25, 0x01	; 1
    2bda:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
    2bde:	5a c1       	rjmp	.+692    	; 0x2e94 <PM_InterpretAVRISPPacket+0x45e>
    2be0:	84 e0       	ldi	r24, 0x04	; 4
    2be2:	90 e0       	ldi	r25, 0x00	; 0
    2be4:	90 93 31 01 	sts	0x0131, r25
    2be8:	80 93 30 01 	sts	0x0130, r24
    2bec:	10 92 35 01 	sts	0x0135, r1
    2bf0:	10 92 37 01 	sts	0x0137, r1
    2bf4:	cf c1       	rjmp	.+926    	; 0x2f94 <PM_InterpretAVRISPPacket+0x55e>
    2bf6:	84 e0       	ldi	r24, 0x04	; 4
    2bf8:	90 e0       	ldi	r25, 0x00	; 0
    2bfa:	90 93 31 01 	sts	0x0131, r25
    2bfe:	80 93 30 01 	sts	0x0130, r24
    2c02:	80 91 49 02 	lds	r24, 0x0249
    2c06:	84 30       	cpi	r24, 0x04	; 4
    2c08:	59 f0       	breq	.+22     	; 0x2c20 <PM_InterpretAVRISPPacket+0x1ea>
    2c0a:	0e 94 62 14 	call	0x28c4 <PM_CheckEndOfProgramming>
    2c0e:	0e 94 ef 14 	call	0x29de <PM_CheckEndOfFuseLockStore>
    2c12:	10 92 85 02 	sts	0x0285, r1
    2c16:	10 92 84 02 	sts	0x0284, r1
    2c1a:	84 e0       	ldi	r24, 0x04	; 4
    2c1c:	80 93 49 02 	sts	0x0249, r24
    2c20:	80 91 34 01 	lds	r24, 0x0134
    2c24:	88 31       	cpi	r24, 0x18	; 24
    2c26:	29 f4       	brne	.+10     	; 0x2c32 <PM_InterpretAVRISPPacket+0x1fc>
    2c28:	80 91 10 01 	lds	r24, 0x0110
    2c2c:	90 91 11 01 	lds	r25, 0x0111
    2c30:	04 c0       	rjmp	.+8      	; 0x2c3a <PM_InterpretAVRISPPacket+0x204>
    2c32:	80 91 0e 01 	lds	r24, 0x010E
    2c36:	90 91 0f 01 	lds	r25, 0x010F
    2c3a:	9a 83       	std	Y+2, r25	; 0x02
    2c3c:	89 83       	std	Y+1, r24	; 0x01
    2c3e:	ce 01       	movw	r24, r28
    2c40:	01 96       	adiw	r24, 0x01	; 1
    2c42:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
    2c46:	99 27       	eor	r25, r25
    2c48:	20 91 84 02 	lds	r18, 0x0284
    2c4c:	30 91 85 02 	lds	r19, 0x0285
    2c50:	82 17       	cp	r24, r18
    2c52:	93 07       	cpc	r25, r19
    2c54:	10 f4       	brcc	.+4      	; 0x2c5a <PM_InterpretAVRISPPacket+0x224>
    2c56:	8f ef       	ldi	r24, 0xFF	; 255
    2c58:	22 c0       	rjmp	.+68     	; 0x2c9e <PM_InterpretAVRISPPacket+0x268>
    2c5a:	a9 01       	movw	r20, r18
    2c5c:	44 0f       	add	r20, r20
    2c5e:	55 1f       	adc	r21, r21
    2c60:	44 0f       	add	r20, r20
    2c62:	55 1f       	adc	r21, r21
    2c64:	80 91 35 01 	lds	r24, 0x0135
    2c68:	28 2f       	mov	r18, r24
    2c6a:	33 27       	eor	r19, r19
    2c6c:	21 50       	subi	r18, 0x01	; 1
    2c6e:	30 40       	sbci	r19, 0x00	; 0
    2c70:	80 91 34 01 	lds	r24, 0x0134
    2c74:	88 31       	cpi	r24, 0x18	; 24
    2c76:	29 f4       	brne	.+10     	; 0x2c82 <PM_InterpretAVRISPPacket+0x24c>
    2c78:	80 91 0c 01 	lds	r24, 0x010C
    2c7c:	90 91 0d 01 	lds	r25, 0x010D
    2c80:	04 c0       	rjmp	.+8      	; 0x2c8a <PM_InterpretAVRISPPacket+0x254>
    2c82:	80 91 0a 01 	lds	r24, 0x010A
    2c86:	90 91 0b 01 	lds	r25, 0x010B
    2c8a:	84 0f       	add	r24, r20
    2c8c:	95 1f       	adc	r25, r21
    2c8e:	82 0f       	add	r24, r18
    2c90:	93 1f       	adc	r25, r19
    2c92:	9a 83       	std	Y+2, r25	; 0x02
    2c94:	89 83       	std	Y+1, r24	; 0x01
    2c96:	ce 01       	movw	r24, r28
    2c98:	01 96       	adiw	r24, 0x01	; 1
    2c9a:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
    2c9e:	80 93 36 01 	sts	0x0136, r24
    2ca2:	10 92 35 01 	sts	0x0135, r1
    2ca6:	10 92 37 01 	sts	0x0137, r1
    2caa:	80 91 84 02 	lds	r24, 0x0284
    2cae:	90 91 85 02 	lds	r25, 0x0285
    2cb2:	01 96       	adiw	r24, 0x01	; 1
    2cb4:	90 93 85 02 	sts	0x0285, r25
    2cb8:	80 93 84 02 	sts	0x0284, r24
    2cbc:	6b c1       	rjmp	.+726    	; 0x2f94 <PM_InterpretAVRISPPacket+0x55e>
    2cbe:	83 e0       	ldi	r24, 0x03	; 3
    2cc0:	90 e0       	ldi	r25, 0x00	; 0
    2cc2:	90 93 31 01 	sts	0x0131, r25
    2cc6:	80 93 30 01 	sts	0x0130, r24
    2cca:	80 91 49 02 	lds	r24, 0x0249
    2cce:	83 30       	cpi	r24, 0x03	; 3
    2cd0:	39 f0       	breq	.+14     	; 0x2ce0 <PM_InterpretAVRISPPacket+0x2aa>
    2cd2:	83 e0       	ldi	r24, 0x03	; 3
    2cd4:	80 93 49 02 	sts	0x0249, r24
    2cd8:	10 92 85 02 	sts	0x0285, r1
    2cdc:	10 92 84 02 	sts	0x0284, r1
    2ce0:	20 91 84 02 	lds	r18, 0x0284
    2ce4:	30 91 85 02 	lds	r19, 0x0285
    2ce8:	47 31       	cpi	r20, 0x17	; 23
    2cea:	71 f4       	brne	.+28     	; 0x2d08 <PM_InterpretAVRISPPacket+0x2d2>
    2cec:	22 0f       	add	r18, r18
    2cee:	33 1f       	adc	r19, r19
    2cf0:	22 0f       	add	r18, r18
    2cf2:	33 1f       	adc	r19, r19
    2cf4:	80 91 0c 01 	lds	r24, 0x010C
    2cf8:	90 91 0d 01 	lds	r25, 0x010D
    2cfc:	82 0f       	add	r24, r18
    2cfe:	93 1f       	adc	r25, r19
    2d00:	9a 83       	std	Y+2, r25	; 0x02
    2d02:	89 83       	std	Y+1, r24	; 0x01
    2d04:	82 e0       	ldi	r24, 0x02	; 2
    2d06:	0d c0       	rjmp	.+26     	; 0x2d22 <PM_InterpretAVRISPPacket+0x2ec>
    2d08:	22 0f       	add	r18, r18
    2d0a:	33 1f       	adc	r19, r19
    2d0c:	22 0f       	add	r18, r18
    2d0e:	33 1f       	adc	r19, r19
    2d10:	80 91 0a 01 	lds	r24, 0x010A
    2d14:	90 91 0b 01 	lds	r25, 0x010B
    2d18:	82 0f       	add	r24, r18
    2d1a:	93 1f       	adc	r25, r19
    2d1c:	9a 83       	std	Y+2, r25	; 0x02
    2d1e:	89 83       	std	Y+1, r24	; 0x01
    2d20:	83 e0       	ldi	r24, 0x03	; 3
    2d22:	80 93 4a 02 	sts	0x024A, r24
    2d26:	80 91 84 02 	lds	r24, 0x0284
    2d2a:	90 91 85 02 	lds	r25, 0x0285
    2d2e:	0a 97       	sbiw	r24, 0x0a	; 10
    2d30:	e8 f4       	brcc	.+58     	; 0x2d6c <PM_InterpretAVRISPPacket+0x336>
    2d32:	45 e3       	ldi	r20, 0x35	; 53
    2d34:	e4 2e       	mov	r14, r20
    2d36:	41 e0       	ldi	r20, 0x01	; 1
    2d38:	f4 2e       	mov	r15, r20
    2d3a:	13 e0       	ldi	r17, 0x03	; 3
    2d3c:	f7 01       	movw	r30, r14
    2d3e:	61 91       	ld	r22, Z+
    2d40:	7f 01       	movw	r14, r30
    2d42:	ce 01       	movw	r24, r28
    2d44:	01 96       	adiw	r24, 0x01	; 1
    2d46:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
    2d4a:	89 81       	ldd	r24, Y+1	; 0x01
    2d4c:	9a 81       	ldd	r25, Y+2	; 0x02
    2d4e:	01 96       	adiw	r24, 0x01	; 1
    2d50:	9a 83       	std	Y+2, r25	; 0x02
    2d52:	89 83       	std	Y+1, r24	; 0x01
    2d54:	11 50       	subi	r17, 0x01	; 1
    2d56:	17 ff       	sbrs	r17, 7
    2d58:	f1 cf       	rjmp	.-30     	; 0x2d3c <PM_InterpretAVRISPPacket+0x306>
    2d5a:	80 91 84 02 	lds	r24, 0x0284
    2d5e:	90 91 85 02 	lds	r25, 0x0285
    2d62:	01 96       	adiw	r24, 0x01	; 1
    2d64:	90 93 85 02 	sts	0x0285, r25
    2d68:	80 93 84 02 	sts	0x0284, r24
    2d6c:	10 92 35 01 	sts	0x0135, r1
    2d70:	10 92 36 01 	sts	0x0136, r1
    2d74:	0f c1       	rjmp	.+542    	; 0x2f94 <PM_InterpretAVRISPPacket+0x55e>
    2d76:	82 e0       	ldi	r24, 0x02	; 2
    2d78:	90 e0       	ldi	r25, 0x00	; 0
    2d7a:	90 93 31 01 	sts	0x0131, r25
    2d7e:	80 93 30 01 	sts	0x0130, r24
    2d82:	80 91 49 02 	lds	r24, 0x0249
    2d86:	81 30       	cpi	r24, 0x01	; 1
    2d88:	81 f1       	breq	.+96     	; 0x2dea <PM_InterpretAVRISPPacket+0x3b4>
    2d8a:	43 31       	cpi	r20, 0x13	; 19
    2d8c:	41 f4       	brne	.+16     	; 0x2d9e <PM_InterpretAVRISPPacket+0x368>
    2d8e:	80 91 1e 01 	lds	r24, 0x011E
    2d92:	90 91 1f 01 	lds	r25, 0x011F
    2d96:	9a 83       	std	Y+2, r25	; 0x02
    2d98:	89 83       	std	Y+1, r24	; 0x01
    2d9a:	81 e0       	ldi	r24, 0x01	; 1
    2d9c:	07 c0       	rjmp	.+14     	; 0x2dac <PM_InterpretAVRISPPacket+0x376>
    2d9e:	80 91 1c 01 	lds	r24, 0x011C
    2da2:	90 91 1d 01 	lds	r25, 0x011D
    2da6:	9a 83       	std	Y+2, r25	; 0x02
    2da8:	89 83       	std	Y+1, r24	; 0x01
    2daa:	80 e0       	ldi	r24, 0x00	; 0
    2dac:	0e 94 eb 13 	call	0x27d6 <PM_SetupDFAddressCounters>
    2db0:	80 91 84 02 	lds	r24, 0x0284
    2db4:	90 91 85 02 	lds	r25, 0x0285
    2db8:	0e 94 56 0a 	call	0x14ac <DF_BufferWriteEnable>
    2dbc:	81 e0       	ldi	r24, 0x01	; 1
    2dbe:	80 93 49 02 	sts	0x0249, r24
    2dc2:	35 e3       	ldi	r19, 0x35	; 53
    2dc4:	e3 2e       	mov	r14, r19
    2dc6:	31 e0       	ldi	r19, 0x01	; 1
    2dc8:	f3 2e       	mov	r15, r19
    2dca:	18 e0       	ldi	r17, 0x08	; 8
    2dcc:	f7 01       	movw	r30, r14
    2dce:	61 91       	ld	r22, Z+
    2dd0:	7f 01       	movw	r14, r30
    2dd2:	ce 01       	movw	r24, r28
    2dd4:	01 96       	adiw	r24, 0x01	; 1
    2dd6:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
    2dda:	89 81       	ldd	r24, Y+1	; 0x01
    2ddc:	9a 81       	ldd	r25, Y+2	; 0x02
    2dde:	01 96       	adiw	r24, 0x01	; 1
    2de0:	9a 83       	std	Y+2, r25	; 0x02
    2de2:	89 83       	std	Y+1, r24	; 0x01
    2de4:	11 50       	subi	r17, 0x01	; 1
    2de6:	17 ff       	sbrs	r17, 7
    2de8:	f1 cf       	rjmp	.-30     	; 0x2dcc <PM_InterpretAVRISPPacket+0x396>
    2dea:	80 91 35 01 	lds	r24, 0x0135
    2dee:	99 27       	eor	r25, r25
    2df0:	18 2f       	mov	r17, r24
    2df2:	00 27       	eor	r16, r16
    2df4:	80 91 36 01 	lds	r24, 0x0136
    2df8:	99 27       	eor	r25, r25
    2dfa:	08 2b       	or	r16, r24
    2dfc:	19 2b       	or	r17, r25
    2dfe:	ee 24       	eor	r14, r14
    2e00:	ff 24       	eor	r15, r15
    2e02:	e0 16       	cp	r14, r16
    2e04:	f1 06       	cpc	r15, r17
    2e06:	78 f4       	brcc	.+30     	; 0x2e26 <PM_InterpretAVRISPPacket+0x3f0>
    2e08:	8e e3       	ldi	r24, 0x3E	; 62
    2e0a:	c8 2e       	mov	r12, r24
    2e0c:	81 e0       	ldi	r24, 0x01	; 1
    2e0e:	d8 2e       	mov	r13, r24
    2e10:	f6 01       	movw	r30, r12
    2e12:	81 91       	ld	r24, Z+
    2e14:	6f 01       	movw	r12, r30
    2e16:	0e 94 2d 14 	call	0x285a <PM_StoreProgramByte>
    2e1a:	08 94       	sec
    2e1c:	e1 1c       	adc	r14, r1
    2e1e:	f1 1c       	adc	r15, r1
    2e20:	e0 16       	cp	r14, r16
    2e22:	f1 06       	cpc	r15, r17
    2e24:	a8 f3       	brcs	.-22     	; 0x2e10 <PM_InterpretAVRISPPacket+0x3da>
    2e26:	80 91 37 01 	lds	r24, 0x0137
    2e2a:	87 ff       	sbrs	r24, 7
    2e2c:	33 c0       	rjmp	.+102    	; 0x2e94 <PM_InterpretAVRISPPacket+0x45e>
    2e2e:	40 91 47 02 	lds	r20, 0x0247
    2e32:	50 91 48 02 	lds	r21, 0x0248
    2e36:	57 fd       	sbrc	r21, 7
    2e38:	2d c0       	rjmp	.+90     	; 0x2e94 <PM_InterpretAVRISPPacket+0x45e>
    2e3a:	41 15       	cp	r20, r1
    2e3c:	51 05       	cpc	r21, r1
    2e3e:	51 f1       	breq	.+84     	; 0x2e94 <PM_InterpretAVRISPPacket+0x45e>
    2e40:	80 91 4a 02 	lds	r24, 0x024A
    2e44:	81 30       	cpi	r24, 0x01	; 1
    2e46:	29 f4       	brne	.+10     	; 0x2e52 <PM_InterpretAVRISPPacket+0x41c>
    2e48:	20 91 08 01 	lds	r18, 0x0108
    2e4c:	30 91 09 01 	lds	r19, 0x0109
    2e50:	04 c0       	rjmp	.+8      	; 0x2e5a <PM_InterpretAVRISPPacket+0x424>
    2e52:	20 91 06 01 	lds	r18, 0x0106
    2e56:	30 91 07 01 	lds	r19, 0x0107
    2e5a:	3a 83       	std	Y+2, r19	; 0x02
    2e5c:	29 83       	std	Y+1, r18	; 0x01
    2e5e:	85 2f       	mov	r24, r21
    2e60:	99 27       	eor	r25, r25
    2e62:	68 2f       	mov	r22, r24
    2e64:	ce 01       	movw	r24, r28
    2e66:	01 96       	adiw	r24, 0x01	; 1
    2e68:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
    2e6c:	89 81       	ldd	r24, Y+1	; 0x01
    2e6e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e70:	01 96       	adiw	r24, 0x01	; 1
    2e72:	9a 83       	std	Y+2, r25	; 0x02
    2e74:	89 83       	std	Y+1, r24	; 0x01
    2e76:	60 91 47 02 	lds	r22, 0x0247
    2e7a:	ce 01       	movw	r24, r28
    2e7c:	01 96       	adiw	r24, 0x01	; 1
    2e7e:	0e 94 bc 08 	call	0x1178 <eeprom_write_byte_169>
    2e82:	80 91 47 02 	lds	r24, 0x0247
    2e86:	90 91 48 02 	lds	r25, 0x0248
    2e8a:	90 68       	ori	r25, 0x80	; 128
    2e8c:	90 93 48 02 	sts	0x0248, r25
    2e90:	80 93 47 02 	sts	0x0247, r24
    2e94:	10 92 35 01 	sts	0x0135, r1
    2e98:	7d c0       	rjmp	.+250    	; 0x2f94 <PM_InterpretAVRISPPacket+0x55e>
    2e9a:	80 91 49 02 	lds	r24, 0x0249
    2e9e:	82 30       	cpi	r24, 0x02	; 2
    2ea0:	11 f1       	breq	.+68     	; 0x2ee6 <PM_InterpretAVRISPPacket+0x4b0>
    2ea2:	0e 94 62 14 	call	0x28c4 <PM_CheckEndOfProgramming>
    2ea6:	0e 94 ef 14 	call	0x29de <PM_CheckEndOfFuseLockStore>
    2eaa:	90 e0       	ldi	r25, 0x00	; 0
    2eac:	80 91 34 01 	lds	r24, 0x0134
    2eb0:	84 31       	cpi	r24, 0x14	; 20
    2eb2:	09 f4       	brne	.+2      	; 0x2eb6 <PM_InterpretAVRISPPacket+0x480>
    2eb4:	91 e0       	ldi	r25, 0x01	; 1
    2eb6:	89 2f       	mov	r24, r25
    2eb8:	0e 94 eb 13 	call	0x27d6 <PM_SetupDFAddressCounters>
    2ebc:	60 91 84 02 	lds	r22, 0x0284
    2ec0:	70 91 85 02 	lds	r23, 0x0285
    2ec4:	80 91 8b 02 	lds	r24, 0x028B
    2ec8:	90 91 8c 02 	lds	r25, 0x028C
    2ecc:	0e 94 13 0a 	call	0x1426 <DF_ContinuousReadEnable>
    2ed0:	82 e0       	ldi	r24, 0x02	; 2
    2ed2:	80 93 49 02 	sts	0x0249, r24
    2ed6:	10 92 2b 01 	sts	0x012B, r1
    2eda:	10 92 2c 01 	sts	0x012C, r1
    2ede:	10 92 2d 01 	sts	0x012D, r1
    2ee2:	10 92 2e 01 	sts	0x012E, r1
    2ee6:	80 91 35 01 	lds	r24, 0x0135
    2eea:	99 27       	eor	r25, r25
    2eec:	18 2f       	mov	r17, r24
    2eee:	00 27       	eor	r16, r16
    2ef0:	80 91 36 01 	lds	r24, 0x0136
    2ef4:	99 27       	eor	r25, r25
    2ef6:	08 2b       	or	r16, r24
    2ef8:	19 2b       	or	r17, r25
    2efa:	90 e0       	ldi	r25, 0x00	; 0
    2efc:	80 91 34 01 	lds	r24, 0x0134
    2f00:	84 31       	cpi	r24, 0x14	; 20
    2f02:	09 f4       	brne	.+2      	; 0x2f06 <PM_InterpretAVRISPPacket+0x4d0>
    2f04:	91 e0       	ldi	r25, 0x01	; 1
    2f06:	89 2f       	mov	r24, r25
    2f08:	0e 94 73 13 	call	0x26e6 <PM_GetStoredDataSize>
    2f0c:	dc 01       	movw	r26, r24
    2f0e:	cb 01       	movw	r24, r22
    2f10:	6c 01       	movw	r12, r24
    2f12:	ee 24       	eor	r14, r14
    2f14:	ff 24       	eor	r15, r15
    2f16:	e0 16       	cp	r14, r16
    2f18:	f1 06       	cpc	r15, r17
    2f1a:	20 f5       	brcc	.+72     	; 0x2f64 <PM_InterpretAVRISPPacket+0x52e>
    2f1c:	f6 e3       	ldi	r31, 0x36	; 54
    2f1e:	af 2e       	mov	r10, r31
    2f20:	f1 e0       	ldi	r31, 0x01	; 1
    2f22:	bf 2e       	mov	r11, r31
    2f24:	96 01       	movw	r18, r12
    2f26:	44 27       	eor	r20, r20
    2f28:	55 27       	eor	r21, r21
    2f2a:	80 91 2b 01 	lds	r24, 0x012B
    2f2e:	90 91 2c 01 	lds	r25, 0x012C
    2f32:	a0 91 2d 01 	lds	r26, 0x012D
    2f36:	b0 91 2e 01 	lds	r27, 0x012E
    2f3a:	82 17       	cp	r24, r18
    2f3c:	93 07       	cpc	r25, r19
    2f3e:	a4 07       	cpc	r26, r20
    2f40:	b5 07       	cpc	r27, r21
    2f42:	20 f4       	brcc	.+8      	; 0x2f4c <PM_InterpretAVRISPPacket+0x516>
    2f44:	80 e0       	ldi	r24, 0x00	; 0
    2f46:	0e 94 3a 09 	call	0x1274 <SPI_SPITransmit>
    2f4a:	01 c0       	rjmp	.+2      	; 0x2f4e <PM_InterpretAVRISPPacket+0x518>
    2f4c:	8f ef       	ldi	r24, 0xFF	; 255
    2f4e:	f5 01       	movw	r30, r10
    2f50:	81 93       	st	Z+, r24
    2f52:	5f 01       	movw	r10, r30
    2f54:	0e 94 d7 0e 	call	0x1dae <V2P_IncrementCurrAddress>
    2f58:	08 94       	sec
    2f5a:	e1 1c       	adc	r14, r1
    2f5c:	f1 1c       	adc	r15, r1
    2f5e:	e0 16       	cp	r14, r16
    2f60:	f1 06       	cpc	r15, r17
    2f62:	00 f3       	brcs	.-64     	; 0x2f24 <PM_InterpretAVRISPPacket+0x4ee>
    2f64:	0d 5f       	subi	r16, 0xFD	; 253
    2f66:	1f 4f       	sbci	r17, 0xFF	; 255
    2f68:	10 93 31 01 	sts	0x0131, r17
    2f6c:	00 93 30 01 	sts	0x0130, r16
    2f70:	03 50       	subi	r16, 0x03	; 3
    2f72:	10 40       	sbci	r17, 0x00	; 0
    2f74:	10 92 35 01 	sts	0x0135, r1
    2f78:	0c 5c       	subi	r16, 0xCC	; 204
    2f7a:	1e 4f       	sbci	r17, 0xFE	; 254
    2f7c:	f8 01       	movw	r30, r16
    2f7e:	12 82       	std	Z+2, r1	; 0x02
    2f80:	09 c0       	rjmp	.+18     	; 0x2f94 <PM_InterpretAVRISPPacket+0x55e>
    2f82:	81 e0       	ldi	r24, 0x01	; 1
    2f84:	90 e0       	ldi	r25, 0x00	; 0
    2f86:	90 93 31 01 	sts	0x0131, r25
    2f8a:	80 93 30 01 	sts	0x0130, r24
    2f8e:	89 ec       	ldi	r24, 0xC9	; 201
    2f90:	80 93 35 01 	sts	0x0135, r24
    2f94:	0e 94 fd 0d 	call	0x1bfa <V2P_SendPacket>
    2f98:	22 96       	adiw	r28, 0x02	; 2
    2f9a:	0f b6       	in	r0, 0x3f	; 63
    2f9c:	f8 94       	cli
    2f9e:	de bf       	out	0x3e, r29	; 62
    2fa0:	0f be       	out	0x3f, r0	; 63
    2fa2:	cd bf       	out	0x3d, r28	; 61
    2fa4:	df 91       	pop	r29
    2fa6:	cf 91       	pop	r28
    2fa8:	1f 91       	pop	r17
    2faa:	0f 91       	pop	r16
    2fac:	ff 90       	pop	r15
    2fae:	ef 90       	pop	r14
    2fb0:	df 90       	pop	r13
    2fb2:	cf 90       	pop	r12
    2fb4:	bf 90       	pop	r11
    2fb6:	af 90       	pop	r10
    2fb8:	08 95       	ret

00002fba <PM_SendFuseLockBytes>:
	}
}

void PM_SendFuseLockBytes(uint8_t Type)
{
    2fba:	0f 93       	push	r16
    2fbc:	1f 93       	push	r17
    2fbe:	cf 93       	push	r28
    2fc0:	df 93       	push	r29
    2fc2:	cd b7       	in	r28, 0x3d	; 61
    2fc4:	de b7       	in	r29, 0x3e	; 62
    2fc6:	22 97       	sbiw	r28, 0x02	; 2
    2fc8:	0f b6       	in	r0, 0x3f	; 63
    2fca:	f8 94       	cli
    2fcc:	de bf       	out	0x3e, r29	; 62
    2fce:	0f be       	out	0x3f, r0	; 63
    2fd0:	cd bf       	out	0x3d, r28	; 61
    2fd2:	08 2f       	mov	r16, r24
	uint16_t EEPROMAddress;
	uint8_t  TotalBytes;
	
	EEPROMAddress = ((Type == TYPE_FUSE)? Prog_TotalFuseBytes : Prog_TotalLockBytes);
    2fd4:	82 30       	cpi	r24, 0x02	; 2
    2fd6:	29 f4       	brne	.+10     	; 0x2fe2 <PM_SendFuseLockBytes+0x28>
    2fd8:	80 91 10 01 	lds	r24, 0x0110
    2fdc:	90 91 11 01 	lds	r25, 0x0111
    2fe0:	04 c0       	rjmp	.+8      	; 0x2fea <PM_SendFuseLockBytes+0x30>
    2fe2:	80 91 0e 01 	lds	r24, 0x010E
    2fe6:	90 91 0f 01 	lds	r25, 0x010F
    2fea:	9a 83       	std	Y+2, r25	; 0x02
    2fec:	89 83       	std	Y+1, r24	; 0x01

	TotalBytes = eeprom_read_byte_169(&EEPROMAddress); // Get the total number of stored fuse/lock bytes
    2fee:	ce 01       	movw	r24, r28
    2ff0:	01 96       	adiw	r24, 0x01	; 1
    2ff2:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
    2ff6:	18 2f       	mov	r17, r24
			
	EEPROMAddress = ((Type == TYPE_FUSE)? Prog_FuseBytes : Prog_LockBytes); // Set the EEPROM pointer to the fuse/lock bytes start (each fuse or lock byte takes four bytes in EEPROM)
    2ff8:	02 30       	cpi	r16, 0x02	; 2
    2ffa:	29 f4       	brne	.+10     	; 0x3006 <PM_SendFuseLockBytes+0x4c>
    2ffc:	80 91 0c 01 	lds	r24, 0x010C
    3000:	90 91 0d 01 	lds	r25, 0x010D
    3004:	04 c0       	rjmp	.+8      	; 0x300e <PM_SendFuseLockBytes+0x54>
    3006:	80 91 0a 01 	lds	r24, 0x010A
    300a:	90 91 0b 01 	lds	r25, 0x010B
    300e:	9a 83       	std	Y+2, r25	; 0x02
    3010:	89 83       	std	Y+1, r24	; 0x01

	while (TotalBytes--)                              // Write each of the fuse/lock bytes stored in memory to the slave AVR
	{
		for (uint8_t CommandByte = 0; CommandByte < 4; CommandByte++)      // Write each individual command byte
		{
			USI_SPITransmit(eeprom_read_byte_169(&EEPROMAddress));
			EEPROMAddress++;
		}
		
		// Add some delay before programming next byte, if there is one:
		if (TotalBytes)
		   MAIN_Delay10MS(5);
    3012:	11 50       	subi	r17, 0x01	; 1
    3014:	1f 3f       	cpi	r17, 0xFF	; 255
    3016:	b1 f0       	breq	.+44     	; 0x3044 <PM_SendFuseLockBytes+0x8a>
    3018:	03 e0       	ldi	r16, 0x03	; 3
    301a:	ce 01       	movw	r24, r28
    301c:	01 96       	adiw	r24, 0x01	; 1
    301e:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
    3022:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    3026:	89 81       	ldd	r24, Y+1	; 0x01
    3028:	9a 81       	ldd	r25, Y+2	; 0x02
    302a:	01 96       	adiw	r24, 0x01	; 1
    302c:	9a 83       	std	Y+2, r25	; 0x02
    302e:	89 83       	std	Y+1, r24	; 0x01
    3030:	01 50       	subi	r16, 0x01	; 1
    3032:	07 ff       	sbrs	r16, 7
    3034:	f2 cf       	rjmp	.-28     	; 0x301a <PM_SendFuseLockBytes+0x60>
    3036:	11 23       	and	r17, r17
    3038:	19 f0       	breq	.+6      	; 0x3040 <PM_SendFuseLockBytes+0x86>
    303a:	85 e0       	ldi	r24, 0x05	; 5
    303c:	0e 94 25 02 	call	0x44a <MAIN_Delay10MS>
    3040:	11 50       	subi	r17, 0x01	; 1
    3042:	50 f7       	brcc	.-44     	; 0x3018 <PM_SendFuseLockBytes+0x5e>
    3044:	22 96       	adiw	r28, 0x02	; 2
    3046:	0f b6       	in	r0, 0x3f	; 63
    3048:	f8 94       	cli
    304a:	de bf       	out	0x3e, r29	; 62
    304c:	0f be       	out	0x3f, r0	; 63
    304e:	cd bf       	out	0x3d, r28	; 61
    3050:	df 91       	pop	r29
    3052:	cf 91       	pop	r28
    3054:	1f 91       	pop	r17
    3056:	0f 91       	pop	r16
    3058:	08 95       	ret

0000305a <PM_SendEraseCommand>:
	}
}

void PM_SendEraseCommand(void)
{
    305a:	0f 93       	push	r16
    305c:	1f 93       	push	r17
    305e:	cf 93       	push	r28
    3060:	df 93       	push	r29
    3062:	cd b7       	in	r28, 0x3d	; 61
    3064:	de b7       	in	r29, 0x3e	; 62
    3066:	22 97       	sbiw	r28, 0x02	; 2
    3068:	0f b6       	in	r0, 0x3f	; 63
    306a:	f8 94       	cli
    306c:	de bf       	out	0x3e, r29	; 62
    306e:	0f be       	out	0x3f, r0	; 63
    3070:	cd bf       	out	0x3d, r28	; 61
	uint16_t EEPROMAddress;

	EEPROMAddress = Prog_EraseChip + 2;               // Start of the erase commands
    3072:	80 91 18 01 	lds	r24, 0x0118
    3076:	90 91 19 01 	lds	r25, 0x0119
    307a:	02 96       	adiw	r24, 0x02	; 2
    307c:	9a 83       	std	Y+2, r25	; 0x02
    307e:	89 83       	std	Y+1, r24	; 0x01
    3080:	13 e0       	ldi	r17, 0x03	; 3
			
	for (uint8_t B = 0; B < 4 ; B++)                  // Read out the erase chip command bytes
	{
		USI_SPITransmit(eeprom_read_byte_169(&EEPROMAddress)); // Send the erase chip commands
    3082:	ce 01       	movw	r24, r28
    3084:	01 96       	adiw	r24, 0x01	; 1
    3086:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
    308a:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
		EEPROMAddress++;
    308e:	89 81       	ldd	r24, Y+1	; 0x01
    3090:	9a 81       	ldd	r25, Y+2	; 0x02
    3092:	01 96       	adiw	r24, 0x01	; 1
    3094:	9a 83       	std	Y+2, r25	; 0x02
    3096:	89 83       	std	Y+1, r24	; 0x01
    3098:	11 50       	subi	r17, 0x01	; 1
    309a:	17 ff       	sbrs	r17, 7
    309c:	f2 cf       	rjmp	.-28     	; 0x3082 <PM_SendEraseCommand+0x28>
	}
			
	EEPROMAddress = Prog_EraseChip + 1;                // Poll mode flag address
    309e:	00 91 18 01 	lds	r16, 0x0118
    30a2:	10 91 19 01 	lds	r17, 0x0119
    30a6:	0f 5f       	subi	r16, 0xFF	; 255
    30a8:	1f 4f       	sbci	r17, 0xFF	; 255
    30aa:	1a 83       	std	Y+2, r17	; 0x02
    30ac:	09 83       	std	Y+1, r16	; 0x01
    30ae:	01 50       	subi	r16, 0x01	; 1
    30b0:	10 40       	sbci	r17, 0x00	; 0
	if (eeprom_read_byte_169(&EEPROMAddress))          // Value of 1 indicates a busy flag test
    30b2:	ce 01       	movw	r24, r28
    30b4:	01 96       	adiw	r24, 0x01	; 1
    30b6:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
    30ba:	88 23       	and	r24, r24
    30bc:	59 f0       	breq	.+22     	; 0x30d4 <PM_SendEraseCommand+0x7a>
	{
		do
			USI_SPITransmitWord(0xF000);
    30be:	80 e0       	ldi	r24, 0x00	; 0
    30c0:	90 ef       	ldi	r25, 0xF0	; 240
    30c2:	0e 94 b2 09 	call	0x1364 <USI_SPITransmitWord>
    30c6:	80 e0       	ldi	r24, 0x00	; 0
    30c8:	90 e0       	ldi	r25, 0x00	; 0
    30ca:	0e 94 b2 09 	call	0x1364 <USI_SPITransmitWord>
    30ce:	80 fd       	sbrc	r24, 0
    30d0:	f6 cf       	rjmp	.-20     	; 0x30be <PM_SendEraseCommand+0x64>
    30d2:	08 c0       	rjmp	.+16     	; 0x30e4 <PM_SendEraseCommand+0x8a>
		while (USI_SPITransmitWord(0x0000) & 0x01);
	}
	else                                               // Cleared flag means use a predefined delay
	{
		EEPROMAddress = Prog_EraseChip;                 // Delay value address			
    30d4:	1a 83       	std	Y+2, r17	; 0x02
    30d6:	09 83       	std	Y+1, r16	; 0x01
		MAIN_Delay1MS(eeprom_read_byte_169(&EEPROMAddress)); // Wait the erase delay
    30d8:	ce 01       	movw	r24, r28
    30da:	01 96       	adiw	r24, 0x01	; 1
    30dc:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
    30e0:	0e 94 01 03 	call	0x602 <MAIN_Delay1MS>
    30e4:	22 96       	adiw	r28, 0x02	; 2
    30e6:	0f b6       	in	r0, 0x3f	; 63
    30e8:	f8 94       	cli
    30ea:	de bf       	out	0x3e, r29	; 62
    30ec:	0f be       	out	0x3f, r0	; 63
    30ee:	cd bf       	out	0x3d, r28	; 61
    30f0:	df 91       	pop	r29
    30f2:	cf 91       	pop	r28
    30f4:	1f 91       	pop	r17
    30f6:	0f 91       	pop	r16
    30f8:	08 95       	ret

000030fa <PM_CreateProgrammingPackets>:
	}
}

void PM_CreateProgrammingPackets(uint8_t Type)
{			
    30fa:	2f 92       	push	r2
    30fc:	3f 92       	push	r3
    30fe:	4f 92       	push	r4
    3100:	5f 92       	push	r5
    3102:	6f 92       	push	r6
    3104:	7f 92       	push	r7
    3106:	8f 92       	push	r8
    3108:	9f 92       	push	r9
    310a:	af 92       	push	r10
    310c:	bf 92       	push	r11
    310e:	cf 92       	push	r12
    3110:	df 92       	push	r13
    3112:	ef 92       	push	r14
    3114:	ff 92       	push	r15
    3116:	0f 93       	push	r16
    3118:	1f 93       	push	r17
    311a:	cf 93       	push	r28
    311c:	df 93       	push	r29
    311e:	cd b7       	in	r28, 0x3d	; 61
    3120:	de b7       	in	r29, 0x3e	; 62
    3122:	23 97       	sbiw	r28, 0x03	; 3
    3124:	0f b6       	in	r0, 0x3f	; 63
    3126:	f8 94       	cli
    3128:	de bf       	out	0x3e, r29	; 62
    312a:	0f be       	out	0x3f, r0	; 63
    312c:	cd bf       	out	0x3d, r28	; 61
    312e:	18 2f       	mov	r17, r24
	uint32_t BytesRead       = 0;
    3130:	88 24       	eor	r8, r8
    3132:	99 24       	eor	r9, r9
    3134:	54 01       	movw	r10, r8
	uint32_t BytesToRead     = PM_GetStoredDataSize(Type);      // Get the byte size of the stored program
    3136:	0e 94 73 13 	call	0x26e6 <PM_GetStoredDataSize>
    313a:	1b 01       	movw	r2, r22
    313c:	2c 01       	movw	r4, r24
	uint16_t BytesPerProgram;
	uint16_t EEPROMAddress;
	uint16_t PageLength;
	uint8_t  ContinuedPage   = FALSE;
    313e:	1b 82       	std	Y+3, r1	; 0x03

	EEPROMAddress = ((Type == TYPE_FLASH)? Prog_PageLength : Prog_EPageLength);
    3140:	11 30       	cpi	r17, 0x01	; 1
    3142:	29 f4       	brne	.+10     	; 0x314e <PM_CreateProgrammingPackets+0x54>
    3144:	80 91 08 01 	lds	r24, 0x0108
    3148:	90 91 09 01 	lds	r25, 0x0109
    314c:	04 c0       	rjmp	.+8      	; 0x3156 <PM_CreateProgrammingPackets+0x5c>
    314e:	80 91 06 01 	lds	r24, 0x0106
    3152:	90 91 07 01 	lds	r25, 0x0107
    3156:	9a 83       	std	Y+2, r25	; 0x02
    3158:	89 83       	std	Y+1, r24	; 0x01
	PageLength    = ((uint16_t)eeprom_read_byte_169(&EEPROMAddress) << 8);
    315a:	ce 01       	movw	r24, r28
    315c:	01 96       	adiw	r24, 0x01	; 1
    315e:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
    3162:	99 27       	eor	r25, r25
    3164:	78 2e       	mov	r7, r24
    3166:	66 24       	eor	r6, r6
	EEPROMAddress++;
    3168:	89 81       	ldd	r24, Y+1	; 0x01
    316a:	9a 81       	ldd	r25, Y+2	; 0x02
    316c:	01 96       	adiw	r24, 0x01	; 1
    316e:	9a 83       	std	Y+2, r25	; 0x02
    3170:	89 83       	std	Y+1, r24	; 0x01
	PageLength   |= (eeprom_read_byte_169(&EEPROMAddress));
    3172:	ce 01       	movw	r24, r28
    3174:	01 96       	adiw	r24, 0x01	; 1
    3176:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
    317a:	99 27       	eor	r25, r25
    317c:	68 2a       	or	r6, r24
    317e:	79 2a       	or	r7, r25
	
	CurrAddress = 0;
    3180:	10 92 2b 01 	sts	0x012B, r1
    3184:	10 92 2c 01 	sts	0x012C, r1
    3188:	10 92 2d 01 	sts	0x012D, r1
    318c:	10 92 2e 01 	sts	0x012E, r1

	if (Type == TYPE_FLASH)
    3190:	11 30       	cpi	r17, 0x01	; 1
    3192:	69 f4       	brne	.+26     	; 0x31ae <PM_CreateProgrammingPackets+0xb4>
	{
		EEPROMAddress = Prog_WriteProgram;             // Set the EEPROM pointer to the write flash command bytes location
    3194:	80 91 1e 01 	lds	r24, 0x011E
    3198:	90 91 1f 01 	lds	r25, 0x011F
    319c:	9a 83       	std	Y+2, r25	; 0x02
    319e:	89 83       	std	Y+1, r24	; 0x01
		DF_ContinuousReadEnable(0, 0);
    31a0:	60 e0       	ldi	r22, 0x00	; 0
    31a2:	70 e0       	ldi	r23, 0x00	; 0
    31a4:	cb 01       	movw	r24, r22
    31a6:	0e 94 13 0a 	call	0x1426 <DF_ContinuousReadEnable>
		PacketBytes[0] = CMD_PROGRAM_FLASH_ISP;
    31aa:	83 e1       	ldi	r24, 0x13	; 19
    31ac:	0d c0       	rjmp	.+26     	; 0x31c8 <PM_CreateProgrammingPackets+0xce>
	}
	else
	{
		EEPROMAddress = Prog_WriteEEPROM;              // Set the EEPROM pointer to the write EEPROM command bytes location
    31ae:	80 91 1c 01 	lds	r24, 0x011C
    31b2:	90 91 1d 01 	lds	r25, 0x011D
    31b6:	9a 83       	std	Y+2, r25	; 0x02
    31b8:	89 83       	std	Y+1, r24	; 0x01
		DF_ContinuousReadEnable(PM_EEPROM_OFFSET / DF_INTERNALDF_BUFFBYTES, PM_EEPROM_OFFSET % DF_INTERNALDF_BUFFBYTES); // Start read from the EEPROM offset location
    31ba:	60 ee       	ldi	r22, 0xE0	; 224
    31bc:	70 e0       	ldi	r23, 0x00	; 0
    31be:	84 ee       	ldi	r24, 0xE4	; 228
    31c0:	93 e0       	ldi	r25, 0x03	; 3
    31c2:	0e 94 13 0a 	call	0x1426 <DF_ContinuousReadEnable>
		PacketBytes[0] = CMD_PROGRAM_EEPROM_ISP;
    31c6:	85 e1       	ldi	r24, 0x15	; 21
    31c8:	80 93 34 01 	sts	0x0134, r24
    31cc:	f5 e3       	ldi	r31, 0x35	; 53
    31ce:	ef 2e       	mov	r14, r31
    31d0:	f1 e0       	ldi	r31, 0x01	; 1
    31d2:	ff 2e       	mov	r15, r31
    31d4:	18 e0       	ldi	r17, 0x08	; 8
	}

	for (uint8_t B = 1; B <= 9 ; B++)                 // Load in the write data command bytes
	{
		PacketBytes[B] = eeprom_read_byte_169(&EEPROMAddress); // Synthesise a write packet header
    31d6:	ce 01       	movw	r24, r28
    31d8:	01 96       	adiw	r24, 0x01	; 1
    31da:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
    31de:	f7 01       	movw	r30, r14
    31e0:	81 93       	st	Z+, r24
    31e2:	7f 01       	movw	r14, r30
		EEPROMAddress++;                               // Increment the EEPROM location counter
    31e4:	89 81       	ldd	r24, Y+1	; 0x01
    31e6:	9a 81       	ldd	r25, Y+2	; 0x02
    31e8:	01 96       	adiw	r24, 0x01	; 1
    31ea:	9a 83       	std	Y+2, r25	; 0x02
    31ec:	89 83       	std	Y+1, r24	; 0x01
    31ee:	11 50       	subi	r17, 0x01	; 1
    31f0:	17 ff       	sbrs	r17, 7
    31f2:	f1 cf       	rjmp	.-30     	; 0x31d6 <PM_CreateProgrammingPackets+0xdc>
	}
	
	BytesPerProgram = ((uint16_t)PacketBytes[1] << 8)
    31f4:	80 91 35 01 	lds	r24, 0x0135
    31f8:	99 27       	eor	r25, r25
    31fa:	d8 2e       	mov	r13, r24
    31fc:	cc 24       	eor	r12, r12
    31fe:	80 91 36 01 	lds	r24, 0x0136
    3202:	99 27       	eor	r25, r25
    3204:	c8 2a       	or	r12, r24
    3206:	d9 2a       	or	r13, r25
	                | PacketBytes[2];

	while (BytesRead < BytesToRead)
	{
		if (PacketBytes[3] & ISPCC_PROG_MODE_PAGE)
		{
			if (PageLength > 160) // Max 160 bytes at a time
			{
				if (!(ContinuedPage))                      // Start of a new page, program in the first 150 bytes
				{
					BytesPerProgram = 160;
					PacketBytes[3] &= ~ISPCC_PROG_MODE_PAGEDONE;		
					ContinuedPage = TRUE;
				}
				else                                       // Middle of a page, program in the remainder
				{
					BytesPerProgram = PageLength - 160;
					PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
					ContinuedPage = FALSE;
				}
				
				for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page				

				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);
				PacketBytes[2] = (uint8_t)(BytesPerProgram);

				BytesRead += BytesPerProgram;                         // Increment the counter
			}
			else
			{
				for (uint16_t LoadB = 0; LoadB < PageLength; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page
			
				PacketBytes[1]  = (uint8_t)(PageLength >> 8);
				PacketBytes[2]  = (uint8_t)(PageLength);
				PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;

				BytesRead     += PageLength;                          // Increment the counter
			}
		}
		else
		{
			if ((BytesRead + BytesPerProgram) > BytesToRead)        // Less than a whole BytesPerProgram left of data to write
			{
				BytesPerProgram = BytesToRead - BytesRead;          // Next lot of bytes will be the remaining data length
				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);   // \. Save the new length
				PacketBytes[2] = (uint8_t)(BytesPerProgram);        // /  into the data packet
			}

			for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
				PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);    // Load in the page
			
			BytesRead += BytesPerProgram;                           // Increment the counter
		}
	
		if (!(BytesRead & 0xFFFF) && (BytesRead & 0x00FF0000))      // Extended address required
		{
			USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);            // Load extended address command
			USI_SPITransmit(0x00);
			USI_SPITransmit((BytesRead & 0x00FF0000) >> 16);        // The 3rd byte of the long holds the extended address
			USI_SPITransmit(0x00);
		}

		ISPCC_ProgramChip();                                        // Start the program cycle
    3208:	82 14       	cp	r8, r2
    320a:	93 04       	cpc	r9, r3
    320c:	a4 04       	cpc	r10, r4
    320e:	b5 04       	cpc	r11, r5
    3210:	08 f0       	brcs	.+2      	; 0x3214 <PM_CreateProgrammingPackets+0x11a>
    3212:	b7 c0       	rjmp	.+366    	; 0x3382 <PM_CreateProgrammingPackets+0x288>
    3214:	20 91 37 01 	lds	r18, 0x0137
    3218:	82 2f       	mov	r24, r18
    321a:	99 27       	eor	r25, r25
    321c:	ac 01       	movw	r20, r24
    321e:	41 70       	andi	r20, 0x01	; 1
    3220:	50 70       	andi	r21, 0x00	; 0
    3222:	80 ff       	sbrs	r24, 0
    3224:	58 c0       	rjmp	.+176    	; 0x32d6 <PM_CreateProgrammingPackets+0x1dc>
    3226:	f1 ea       	ldi	r31, 0xA1	; 161
    3228:	6f 16       	cp	r6, r31
    322a:	71 04       	cpc	r7, r1
    322c:	88 f1       	brcs	.+98     	; 0x3290 <PM_CreateProgrammingPackets+0x196>
    322e:	8b 81       	ldd	r24, Y+3	; 0x03
    3230:	88 23       	and	r24, r24
    3232:	49 f4       	brne	.+18     	; 0x3246 <PM_CreateProgrammingPackets+0x14c>
    3234:	70 ea       	ldi	r23, 0xA0	; 160
    3236:	c7 2e       	mov	r12, r23
    3238:	d1 2c       	mov	r13, r1
    323a:	2f 77       	andi	r18, 0x7F	; 127
    323c:	20 93 37 01 	sts	0x0137, r18
    3240:	e1 e0       	ldi	r30, 0x01	; 1
    3242:	eb 83       	std	Y+3, r30	; 0x03
    3244:	0a c0       	rjmp	.+20     	; 0x325a <PM_CreateProgrammingPackets+0x160>
    3246:	60 e6       	ldi	r22, 0x60	; 96
    3248:	c6 2e       	mov	r12, r22
    324a:	6f ef       	ldi	r22, 0xFF	; 255
    324c:	d6 2e       	mov	r13, r22
    324e:	c6 0c       	add	r12, r6
    3250:	d7 1c       	adc	r13, r7
    3252:	20 68       	ori	r18, 0x80	; 128
    3254:	20 93 37 01 	sts	0x0137, r18
    3258:	1b 82       	std	Y+3, r1	; 0x03
    325a:	00 e0       	ldi	r16, 0x00	; 0
    325c:	10 e0       	ldi	r17, 0x00	; 0
    325e:	0c 15       	cp	r16, r12
    3260:	1d 05       	cpc	r17, r13
    3262:	78 f4       	brcc	.+30     	; 0x3282 <PM_CreateProgrammingPackets+0x188>
    3264:	5e e3       	ldi	r21, 0x3E	; 62
    3266:	e5 2e       	mov	r14, r21
    3268:	51 e0       	ldi	r21, 0x01	; 1
    326a:	f5 2e       	mov	r15, r21
    326c:	80 e0       	ldi	r24, 0x00	; 0
    326e:	0e 94 3a 09 	call	0x1274 <SPI_SPITransmit>
    3272:	f7 01       	movw	r30, r14
    3274:	81 93       	st	Z+, r24
    3276:	7f 01       	movw	r14, r30
    3278:	0f 5f       	subi	r16, 0xFF	; 255
    327a:	1f 4f       	sbci	r17, 0xFF	; 255
    327c:	0c 15       	cp	r16, r12
    327e:	1d 05       	cpc	r17, r13
    3280:	a8 f3       	brcs	.-22     	; 0x326c <PM_CreateProgrammingPackets+0x172>
    3282:	8d 2d       	mov	r24, r13
    3284:	99 27       	eor	r25, r25
    3286:	80 93 35 01 	sts	0x0135, r24
    328a:	c0 92 36 01 	sts	0x0136, r12
    328e:	4b c0       	rjmp	.+150    	; 0x3326 <PM_CreateProgrammingPackets+0x22c>
    3290:	00 e0       	ldi	r16, 0x00	; 0
    3292:	10 e0       	ldi	r17, 0x00	; 0
    3294:	06 15       	cp	r16, r6
    3296:	17 05       	cpc	r17, r7
    3298:	78 f4       	brcc	.+30     	; 0x32b8 <PM_CreateProgrammingPackets+0x1be>
    329a:	3e e3       	ldi	r19, 0x3E	; 62
    329c:	e3 2e       	mov	r14, r19
    329e:	31 e0       	ldi	r19, 0x01	; 1
    32a0:	f3 2e       	mov	r15, r19
    32a2:	80 e0       	ldi	r24, 0x00	; 0
    32a4:	0e 94 3a 09 	call	0x1274 <SPI_SPITransmit>
    32a8:	f7 01       	movw	r30, r14
    32aa:	81 93       	st	Z+, r24
    32ac:	7f 01       	movw	r14, r30
    32ae:	0f 5f       	subi	r16, 0xFF	; 255
    32b0:	1f 4f       	sbci	r17, 0xFF	; 255
    32b2:	06 15       	cp	r16, r6
    32b4:	17 05       	cpc	r17, r7
    32b6:	a8 f3       	brcs	.-22     	; 0x32a2 <PM_CreateProgrammingPackets+0x1a8>
    32b8:	87 2d       	mov	r24, r7
    32ba:	99 27       	eor	r25, r25
    32bc:	80 93 35 01 	sts	0x0135, r24
    32c0:	60 92 36 01 	sts	0x0136, r6
    32c4:	80 91 37 01 	lds	r24, 0x0137
    32c8:	80 68       	ori	r24, 0x80	; 128
    32ca:	80 93 37 01 	sts	0x0137, r24
    32ce:	c3 01       	movw	r24, r6
    32d0:	aa 27       	eor	r26, r26
    32d2:	bb 27       	eor	r27, r27
    32d4:	2b c0       	rjmp	.+86     	; 0x332c <PM_CreateProgrammingPackets+0x232>
    32d6:	c6 01       	movw	r24, r12
    32d8:	aa 27       	eor	r26, r26
    32da:	bb 27       	eor	r27, r27
    32dc:	88 0d       	add	r24, r8
    32de:	99 1d       	adc	r25, r9
    32e0:	aa 1d       	adc	r26, r10
    32e2:	bb 1d       	adc	r27, r11
    32e4:	28 16       	cp	r2, r24
    32e6:	39 06       	cpc	r3, r25
    32e8:	4a 06       	cpc	r4, r26
    32ea:	5b 06       	cpc	r5, r27
    32ec:	48 f4       	brcc	.+18     	; 0x3300 <PM_CreateProgrammingPackets+0x206>
    32ee:	61 01       	movw	r12, r2
    32f0:	c8 18       	sub	r12, r8
    32f2:	d9 08       	sbc	r13, r9
    32f4:	8d 2d       	mov	r24, r13
    32f6:	99 27       	eor	r25, r25
    32f8:	80 93 35 01 	sts	0x0135, r24
    32fc:	c0 92 36 01 	sts	0x0136, r12
    3300:	8a 01       	movw	r16, r20
    3302:	4c 15       	cp	r20, r12
    3304:	5d 05       	cpc	r21, r13
    3306:	78 f4       	brcc	.+30     	; 0x3326 <PM_CreateProgrammingPackets+0x22c>
    3308:	8e e3       	ldi	r24, 0x3E	; 62
    330a:	e8 2e       	mov	r14, r24
    330c:	81 e0       	ldi	r24, 0x01	; 1
    330e:	f8 2e       	mov	r15, r24
    3310:	80 e0       	ldi	r24, 0x00	; 0
    3312:	0e 94 3a 09 	call	0x1274 <SPI_SPITransmit>
    3316:	f7 01       	movw	r30, r14
    3318:	81 93       	st	Z+, r24
    331a:	7f 01       	movw	r14, r30
    331c:	0f 5f       	subi	r16, 0xFF	; 255
    331e:	1f 4f       	sbci	r17, 0xFF	; 255
    3320:	0c 15       	cp	r16, r12
    3322:	1d 05       	cpc	r17, r13
    3324:	a8 f3       	brcs	.-22     	; 0x3310 <PM_CreateProgrammingPackets+0x216>
    3326:	c6 01       	movw	r24, r12
    3328:	aa 27       	eor	r26, r26
    332a:	bb 27       	eor	r27, r27
    332c:	88 0e       	add	r8, r24
    332e:	99 1e       	adc	r9, r25
    3330:	aa 1e       	adc	r10, r26
    3332:	bb 1e       	adc	r11, r27
    3334:	81 14       	cp	r8, r1
    3336:	91 04       	cpc	r9, r1
    3338:	e1 f4       	brne	.+56     	; 0x3372 <PM_CreateProgrammingPackets+0x278>
    333a:	e1 2c       	mov	r14, r1
    333c:	f1 2c       	mov	r15, r1
    333e:	bf ef       	ldi	r27, 0xFF	; 255
    3340:	0b 2f       	mov	r16, r27
    3342:	11 2d       	mov	r17, r1
    3344:	e8 20       	and	r14, r8
    3346:	f9 20       	and	r15, r9
    3348:	0a 21       	and	r16, r10
    334a:	1b 21       	and	r17, r11
    334c:	e1 14       	cp	r14, r1
    334e:	f1 04       	cpc	r15, r1
    3350:	01 05       	cpc	r16, r1
    3352:	11 05       	cpc	r17, r1
    3354:	71 f0       	breq	.+28     	; 0x3372 <PM_CreateProgrammingPackets+0x278>
    3356:	8d e4       	ldi	r24, 0x4D	; 77
    3358:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    335c:	80 e0       	ldi	r24, 0x00	; 0
    335e:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    3362:	c8 01       	movw	r24, r16
    3364:	aa 27       	eor	r26, r26
    3366:	bb 27       	eor	r27, r27
    3368:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    336c:	80 e0       	ldi	r24, 0x00	; 0
    336e:	0e 94 9f 09 	call	0x133e <USI_SPITransmit>
    3372:	0e 94 1c 11 	call	0x2238 <ISPCC_ProgramChip>
    3376:	82 14       	cp	r8, r2
    3378:	93 04       	cpc	r9, r3
    337a:	a4 04       	cpc	r10, r4
    337c:	b5 04       	cpc	r11, r5
    337e:	08 f4       	brcc	.+2      	; 0x3382 <PM_CreateProgrammingPackets+0x288>
    3380:	49 cf       	rjmp	.-366    	; 0x3214 <PM_CreateProgrammingPackets+0x11a>
    3382:	23 96       	adiw	r28, 0x03	; 3
    3384:	0f b6       	in	r0, 0x3f	; 63
    3386:	f8 94       	cli
    3388:	de bf       	out	0x3e, r29	; 62
    338a:	0f be       	out	0x3f, r0	; 63
    338c:	cd bf       	out	0x3d, r28	; 61
    338e:	df 91       	pop	r29
    3390:	cf 91       	pop	r28
    3392:	1f 91       	pop	r17
    3394:	0f 91       	pop	r16
    3396:	ff 90       	pop	r15
    3398:	ef 90       	pop	r14
    339a:	df 90       	pop	r13
    339c:	cf 90       	pop	r12
    339e:	bf 90       	pop	r11
    33a0:	af 90       	pop	r10
    33a2:	9f 90       	pop	r9
    33a4:	8f 90       	pop	r8
    33a6:	7f 90       	pop	r7
    33a8:	6f 90       	pop	r6
    33aa:	5f 90       	pop	r5
    33ac:	4f 90       	pop	r4
    33ae:	3f 90       	pop	r3
    33b0:	2f 90       	pop	r2
    33b2:	08 95       	ret

000033b4 <PM_ShowStoredItemSizes>:
	}
}

void PM_ShowStoredItemSizes(void)
{
    33b4:	1f 93       	push	r17
    33b6:	cf 93       	push	r28
    33b8:	df 93       	push	r29
    33ba:	cd b7       	in	r28, 0x3d	; 61
    33bc:	de b7       	in	r29, 0x3e	; 62
    33be:	2e 97       	sbiw	r28, 0x0e	; 14
    33c0:	0f b6       	in	r0, 0x3f	; 63
    33c2:	f8 94       	cli
    33c4:	de bf       	out	0x3e, r29	; 62
    33c6:	0f be       	out	0x3f, r0	; 63
    33c8:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[14];
	uint8_t ItemInfoIndex = 0;
    33ca:	10 e0       	ldi	r17, 0x00	; 0
	uint8_t TempB;
	
	JoyStatus = 1;
    33cc:	81 e0       	ldi	r24, 0x01	; 1
    33ce:	8e bb       	out	0x1e, r24	; 30
	
	while (1)
	{
		if (JoyStatus)                           // Joystick is in the non-center position
    33d0:	8e b3       	in	r24, 0x1e	; 30
    33d2:	88 23       	and	r24, r24
    33d4:	e9 f3       	breq	.-6      	; 0x33d0 <PM_ShowStoredItemSizes+0x1c>
		{
			if (JoyStatus & JOY_UP)              // Previous item
    33d6:	f6 9b       	sbis	0x1e, 6	; 30
    33d8:	06 c0       	rjmp	.+12     	; 0x33e6 <PM_ShowStoredItemSizes+0x32>
				(ItemInfoIndex == 0)? ItemInfoIndex = 3 : ItemInfoIndex--;
    33da:	11 23       	and	r17, r17
    33dc:	11 f4       	brne	.+4      	; 0x33e2 <PM_ShowStoredItemSizes+0x2e>
    33de:	13 e0       	ldi	r17, 0x03	; 3
    33e0:	0c c0       	rjmp	.+24     	; 0x33fa <PM_ShowStoredItemSizes+0x46>
    33e2:	11 50       	subi	r17, 0x01	; 1
    33e4:	0a c0       	rjmp	.+20     	; 0x33fa <PM_ShowStoredItemSizes+0x46>
			else if (JoyStatus & JOY_DOWN)      // Next item
    33e6:	f7 9b       	sbis	0x1e, 7	; 30
    33e8:	06 c0       	rjmp	.+12     	; 0x33f6 <PM_ShowStoredItemSizes+0x42>
				(ItemInfoIndex == 3)? ItemInfoIndex = 0 : ItemInfoIndex++;
    33ea:	13 30       	cpi	r17, 0x03	; 3
    33ec:	11 f4       	brne	.+4      	; 0x33f2 <PM_ShowStoredItemSizes+0x3e>
    33ee:	10 e0       	ldi	r17, 0x00	; 0
    33f0:	04 c0       	rjmp	.+8      	; 0x33fa <PM_ShowStoredItemSizes+0x46>
    33f2:	1f 5f       	subi	r17, 0xFF	; 255
    33f4:	02 c0       	rjmp	.+4      	; 0x33fa <PM_ShowStoredItemSizes+0x46>
			else if (JoyStatus & JOY_LEFT)
    33f6:	f2 99       	sbic	0x1e, 2	; 30
    33f8:	53 c0       	rjmp	.+166    	; 0x34a0 <PM_ShowStoredItemSizes+0xec>
				return;
		
			switch (ItemInfoIndex)
    33fa:	81 2f       	mov	r24, r17
    33fc:	99 27       	eor	r25, r25
    33fe:	81 30       	cpi	r24, 0x01	; 1
    3400:	91 05       	cpc	r25, r1
    3402:	a1 f0       	breq	.+40     	; 0x342c <PM_ShowStoredItemSizes+0x78>
    3404:	82 30       	cpi	r24, 0x02	; 2
    3406:	91 05       	cpc	r25, r1
    3408:	1c f4       	brge	.+6      	; 0x3410 <PM_ShowStoredItemSizes+0x5c>
    340a:	89 2b       	or	r24, r25
    340c:	39 f0       	breq	.+14     	; 0x341c <PM_ShowStoredItemSizes+0x68>
    340e:	41 c0       	rjmp	.+130    	; 0x3492 <PM_ShowStoredItemSizes+0xde>
    3410:	82 30       	cpi	r24, 0x02	; 2
    3412:	91 05       	cpc	r25, r1
    3414:	01 f1       	breq	.+64     	; 0x3456 <PM_ShowStoredItemSizes+0xa2>
    3416:	03 97       	sbiw	r24, 0x03	; 3
    3418:	39 f1       	breq	.+78     	; 0x3468 <PM_ShowStoredItemSizes+0xb4>
    341a:	3b c0       	rjmp	.+118    	; 0x3492 <PM_ShowStoredItemSizes+0xde>
			{
				case 0:
					strcpy_P(Buffer, PSTR("DATA-"));
    341c:	60 ef       	ldi	r22, 0xF0	; 240
    341e:	73 e0       	ldi	r23, 0x03	; 3
    3420:	ce 01       	movw	r24, r28
    3422:	01 96       	adiw	r24, 0x01	; 1
    3424:	0e 94 2c 1b 	call	0x3658 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_FLASH), &Buffer[5], 10);
    3428:	81 e0       	ldi	r24, 0x01	; 1
    342a:	07 c0       	rjmp	.+14     	; 0x343a <PM_ShowStoredItemSizes+0x86>
					break;
				case 1:
					strcpy_P(Buffer, PSTR("EPRM-"));
    342c:	66 ef       	ldi	r22, 0xF6	; 246
    342e:	73 e0       	ldi	r23, 0x03	; 3
    3430:	ce 01       	movw	r24, r28
    3432:	01 96       	adiw	r24, 0x01	; 1
    3434:	0e 94 2c 1b 	call	0x3658 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_EEPROM), &Buffer[5], 10);
    3438:	80 e0       	ldi	r24, 0x00	; 0
    343a:	0e 94 73 13 	call	0x26e6 <PM_GetStoredDataSize>
    343e:	dc 01       	movw	r26, r24
    3440:	cb 01       	movw	r24, r22
    3442:	2a e0       	ldi	r18, 0x0A	; 10
    3444:	30 e0       	ldi	r19, 0x00	; 0
    3446:	ae 01       	movw	r20, r28
    3448:	4a 5f       	subi	r20, 0xFA	; 250
    344a:	5f 4f       	sbci	r21, 0xFF	; 255
    344c:	bc 01       	movw	r22, r24
    344e:	cd 01       	movw	r24, r26
    3450:	0e 94 33 1b 	call	0x3666 <ultoa>
					break;
    3454:	1e c0       	rjmp	.+60     	; 0x3492 <PM_ShowStoredItemSizes+0xde>
				case 2:
					strcpy_P(Buffer, PSTR("FUSE-"));
    3456:	6c ef       	ldi	r22, 0xFC	; 252
    3458:	73 e0       	ldi	r23, 0x03	; 3
    345a:	ce 01       	movw	r24, r28
    345c:	01 96       	adiw	r24, 0x01	; 1
    345e:	0e 94 2c 1b 	call	0x3658 <strcpy_P>
					TempB = eeprom_read_byte_169(&Prog_TotalFuseBytes);
    3462:	80 e1       	ldi	r24, 0x10	; 16
    3464:	91 e0       	ldi	r25, 0x01	; 1
    3466:	08 c0       	rjmp	.+16     	; 0x3478 <PM_ShowStoredItemSizes+0xc4>
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);
					break;
				case 3:
					strcpy_P(Buffer, PSTR("LOCK-"));
    3468:	62 e0       	ldi	r22, 0x02	; 2
    346a:	74 e0       	ldi	r23, 0x04	; 4
    346c:	ce 01       	movw	r24, r28
    346e:	01 96       	adiw	r24, 0x01	; 1
    3470:	0e 94 2c 1b 	call	0x3658 <strcpy_P>
					TempB = eeprom_read_byte_169(&Prog_TotalLockBytes);
    3474:	8e e0       	ldi	r24, 0x0E	; 14
    3476:	91 e0       	ldi	r25, 0x01	; 1
    3478:	0e 94 b1 08 	call	0x1162 <eeprom_read_byte_169>
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);		
    347c:	8f 3f       	cpi	r24, 0xFF	; 255
    347e:	11 f0       	breq	.+4      	; 0x3484 <PM_ShowStoredItemSizes+0xd0>
    3480:	99 27       	eor	r25, r25
    3482:	02 c0       	rjmp	.+4      	; 0x3488 <PM_ShowStoredItemSizes+0xd4>
    3484:	80 e0       	ldi	r24, 0x00	; 0
    3486:	90 e0       	ldi	r25, 0x00	; 0
    3488:	be 01       	movw	r22, r28
    348a:	6a 5f       	subi	r22, 0xFA	; 250
    348c:	7f 4f       	sbci	r23, 0xFF	; 255
    348e:	0e 94 2e 03 	call	0x65c <MAIN_IntToStr>
			}
	
			LCD_puts(Buffer);
    3492:	ce 01       	movw	r24, r28
    3494:	01 96       	adiw	r24, 0x01	; 1
    3496:	0e 94 b6 07 	call	0xf6c <LCD_puts>

			MAIN_WaitForJoyRelease();
    349a:	0e 94 37 02 	call	0x46e <MAIN_WaitForJoyRelease>
    349e:	98 cf       	rjmp	.-208    	; 0x33d0 <PM_ShowStoredItemSizes+0x1c>
    34a0:	2e 96       	adiw	r28, 0x0e	; 14
    34a2:	0f b6       	in	r0, 0x3f	; 63
    34a4:	f8 94       	cli
    34a6:	de bf       	out	0x3e, r29	; 62
    34a8:	0f be       	out	0x3f, r0	; 63
    34aa:	cd bf       	out	0x3d, r28	; 61
    34ac:	df 91       	pop	r29
    34ae:	cf 91       	pop	r28
    34b0:	1f 91       	pop	r17
    34b2:	08 95       	ret

000034b4 <TM_FindNextTag>:
	DF_EnableDataflash(FALSE);
}

void TM_FindNextTag(void)
{
    34b4:	af 92       	push	r10
    34b6:	bf 92       	push	r11
    34b8:	df 92       	push	r13
    34ba:	ef 92       	push	r14
    34bc:	ff 92       	push	r15
    34be:	0f 93       	push	r16
    34c0:	1f 93       	push	r17
    34c2:	cf 93       	push	r28
    34c4:	df 93       	push	r29
    34c6:	cd b7       	in	r28, 0x3d	; 61
    34c8:	de b7       	in	r29, 0x3e	; 62
    34ca:	69 97       	sbiw	r28, 0x19	; 25
    34cc:	0f b6       	in	r0, 0x3f	; 63
    34ce:	f8 94       	cli
    34d0:	de bf       	out	0x3e, r29	; 62
    34d2:	0f be       	out	0x3f, r0	; 63
    34d4:	cd bf       	out	0x3d, r28	; 61
	uint8_t  Buffer[21];
	uint8_t  HeadBuff[4]      = BT_TAGHEADER;
    34d6:	80 e4       	ldi	r24, 0x40	; 64
    34d8:	8e 8b       	std	Y+22, r24	; 0x16
    34da:	86 e1       	ldi	r24, 0x16	; 22
    34dc:	a8 2e       	mov	r10, r24
    34de:	b1 2c       	mov	r11, r1
    34e0:	ac 0e       	add	r10, r28
    34e2:	bd 1e       	adc	r11, r29
    34e4:	88 e2       	ldi	r24, 0x28	; 40
    34e6:	8f 8b       	std	Y+23, r24	; 0x17
    34e8:	83 e2       	ldi	r24, 0x23	; 35
    34ea:	88 8f       	std	Y+24, r24	; 0x18
    34ec:	89 e2       	ldi	r24, 0x29	; 41
    34ee:	89 8f       	std	Y+25, r24	; 0x19
	uint32_t ProgDataSize     = PM_GetStoredDataSize(TYPE_FLASH);
    34f0:	81 e0       	ldi	r24, 0x01	; 1
    34f2:	0e 94 73 13 	call	0x26e6 <PM_GetStoredDataSize>
    34f6:	7b 01       	movw	r14, r22
    34f8:	8c 01       	movw	r16, r24
	uint8_t  TotalOkHeadBytes = 0;
    34fa:	dd 24       	eor	r13, r13
	uint8_t  TagByte;
	uint8_t  BytesRead;
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);    // Orange = busy
    34fc:	81 b3       	in	r24, 0x11	; 17
    34fe:	80 63       	ori	r24, 0x30	; 48
    3500:	81 bb       	out	0x11, r24	; 17

	while (DFPos < ProgDataSize)
	{
		BytesRead = 1;
		
		if (SPI_SPITransmit(0x00) == HeadBuff[TotalOkHeadBytes++])
		{
			if (TotalOkHeadBytes == 4)
			{
				uint8_t HB;
			
				for (HB = 0; HB < 20; HB++)
				{
					TagByte = SPI_SPITransmit(0x00);
					Buffer[HB] = TagByte;
					
					if (TagByte == 0x00)
					  break;
				}
				
				Buffer[20] = '\0';             // Make sure string is null-terminated

				TagExists = TRUE;
				BytesRead = (HB + 2);

				LCD_puts(Buffer);
				MAIN_SETSTATUSLED(MAIN_STATLED_GREEN); // Green = ready
				return;
			}
		}
		else
		{
			TotalOkHeadBytes = 0;
		}

		DFPos += BytesRead;
    3502:	80 91 d2 02 	lds	r24, 0x02D2
    3506:	90 91 d3 02 	lds	r25, 0x02D3
    350a:	a0 91 d4 02 	lds	r26, 0x02D4
    350e:	b0 91 d5 02 	lds	r27, 0x02D5
    3512:	8e 15       	cp	r24, r14
    3514:	9f 05       	cpc	r25, r15
    3516:	a0 07       	cpc	r26, r16
    3518:	b1 07       	cpc	r27, r17
    351a:	08 f0       	brcs	.+2      	; 0x351e <TM_FindNextTag+0x6a>
    351c:	43 c0       	rjmp	.+134    	; 0x35a4 <TM_FindNextTag+0xf0>
    351e:	80 e0       	ldi	r24, 0x00	; 0
    3520:	0e 94 3a 09 	call	0x1274 <SPI_SPITransmit>
    3524:	f5 01       	movw	r30, r10
    3526:	ed 0d       	add	r30, r13
    3528:	f1 1d       	adc	r31, r1
    352a:	d3 94       	inc	r13
    352c:	90 81       	ld	r25, Z
    352e:	89 17       	cp	r24, r25
    3530:	21 f5       	brne	.+72     	; 0x357a <TM_FindNextTag+0xc6>
    3532:	84 e0       	ldi	r24, 0x04	; 4
    3534:	d8 16       	cp	r13, r24
    3536:	11 f5       	brne	.+68     	; 0x357c <TM_FindNextTag+0xc8>
    3538:	ff 24       	eor	r15, r15
    353a:	00 e0       	ldi	r16, 0x00	; 0
    353c:	10 e0       	ldi	r17, 0x00	; 0
    353e:	80 e0       	ldi	r24, 0x00	; 0
    3540:	0e 94 3a 09 	call	0x1274 <SPI_SPITransmit>
    3544:	9e 01       	movw	r18, r28
    3546:	2f 5f       	subi	r18, 0xFF	; 255
    3548:	3f 4f       	sbci	r19, 0xFF	; 255
    354a:	f8 01       	movw	r30, r16
    354c:	e2 0f       	add	r30, r18
    354e:	f3 1f       	adc	r31, r19
    3550:	80 83       	st	Z, r24
    3552:	88 23       	and	r24, r24
    3554:	31 f0       	breq	.+12     	; 0x3562 <TM_FindNextTag+0xae>
    3556:	f3 94       	inc	r15
    3558:	0f 5f       	subi	r16, 0xFF	; 255
    355a:	1f 4f       	sbci	r17, 0xFF	; 255
    355c:	83 e1       	ldi	r24, 0x13	; 19
    355e:	8f 15       	cp	r24, r15
    3560:	70 f7       	brcc	.-36     	; 0x353e <TM_FindNextTag+0x8a>
    3562:	1d 8a       	std	Y+21, r1	; 0x15
    3564:	81 e0       	ldi	r24, 0x01	; 1
    3566:	80 93 4b 02 	sts	0x024B, r24
    356a:	c9 01       	movw	r24, r18
    356c:	0e 94 b6 07 	call	0xf6c <LCD_puts>
    3570:	81 b3       	in	r24, 0x11	; 17
    3572:	8f 7c       	andi	r24, 0xCF	; 207
    3574:	80 61       	ori	r24, 0x10	; 16
    3576:	81 bb       	out	0x11, r24	; 17
    3578:	31 c0       	rjmp	.+98     	; 0x35dc <TM_FindNextTag+0x128>
    357a:	dd 24       	eor	r13, r13
    357c:	80 91 d2 02 	lds	r24, 0x02D2
    3580:	90 91 d3 02 	lds	r25, 0x02D3
    3584:	a0 91 d4 02 	lds	r26, 0x02D4
    3588:	b0 91 d5 02 	lds	r27, 0x02D5
    358c:	01 96       	adiw	r24, 0x01	; 1
    358e:	a1 1d       	adc	r26, r1
    3590:	b1 1d       	adc	r27, r1
    3592:	80 93 d2 02 	sts	0x02D2, r24
    3596:	90 93 d3 02 	sts	0x02D3, r25
    359a:	a0 93 d4 02 	sts	0x02D4, r26
    359e:	b0 93 d5 02 	sts	0x02D5, r27
    35a2:	b7 cf       	rjmp	.-146    	; 0x3512 <TM_FindNextTag+0x5e>
	}
	
	DF_ContinuousReadEnable(0, 0);
    35a4:	60 e0       	ldi	r22, 0x00	; 0
    35a6:	70 e0       	ldi	r23, 0x00	; 0
    35a8:	cb 01       	movw	r24, r22
    35aa:	0e 94 13 0a 	call	0x1426 <DF_ContinuousReadEnable>
	DFPos = 0;
    35ae:	10 92 d2 02 	sts	0x02D2, r1
    35b2:	10 92 d3 02 	sts	0x02D3, r1
    35b6:	10 92 d4 02 	sts	0x02D4, r1
    35ba:	10 92 d5 02 	sts	0x02D5, r1
	
	if (TagExists == FALSE)
    35be:	80 91 4b 02 	lds	r24, 0x024B
    35c2:	88 23       	and	r24, r24
    35c4:	49 f4       	brne	.+18     	; 0x35d8 <TM_FindNextTag+0x124>
	{
		MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);  // Green = ready
    35c6:	81 b3       	in	r24, 0x11	; 17
    35c8:	8f 7c       	andi	r24, 0xCF	; 207
    35ca:	80 61       	ori	r24, 0x10	; 16
    35cc:	81 bb       	out	0x11, r24	; 17
		MAIN_ShowError(PSTR("NO TAGS"));
    35ce:	88 e0       	ldi	r24, 0x08	; 8
    35d0:	94 e0       	ldi	r25, 0x04	; 4
    35d2:	0e 94 68 03 	call	0x6d0 <MAIN_ShowError>
    35d6:	02 c0       	rjmp	.+4      	; 0x35dc <TM_FindNextTag+0x128>
	}
	else
	{
		/* The following line _is_ recursion, but the function will only ever call itself
		   a maximum of one time. The function will call itself upon skipping from the last
		   tag stored in the program data to the first; to guard against infinite recursion
		   if no tags are present, the system will error out if the TagExists flag is empty
		   after a full data read. Once a tag has been read and displayed onto the LCD, the
           function returns to the main tag handling routine.                               */
		TM_FindNextTag();
    35d8:	0e 94 5a 1a 	call	0x34b4 <TM_FindNextTag>
    35dc:	69 96       	adiw	r28, 0x19	; 25
    35de:	0f b6       	in	r0, 0x3f	; 63
    35e0:	f8 94       	cli
    35e2:	de bf       	out	0x3e, r29	; 62
    35e4:	0f be       	out	0x3f, r0	; 63
    35e6:	cd bf       	out	0x3d, r28	; 61
    35e8:	df 91       	pop	r29
    35ea:	cf 91       	pop	r28
    35ec:	1f 91       	pop	r17
    35ee:	0f 91       	pop	r16
    35f0:	ff 90       	pop	r15
    35f2:	ef 90       	pop	r14
    35f4:	df 90       	pop	r13
    35f6:	bf 90       	pop	r11
    35f8:	af 90       	pop	r10
    35fa:	08 95       	ret

000035fc <TM_ShowTags>:
    35fc:	60 e0       	ldi	r22, 0x00	; 0
    35fe:	70 e0       	ldi	r23, 0x00	; 0
    3600:	cb 01       	movw	r24, r22
    3602:	0e 94 13 0a 	call	0x1426 <DF_ContinuousReadEnable>
    3606:	10 92 4b 02 	sts	0x024B, r1
    360a:	10 92 d2 02 	sts	0x02D2, r1
    360e:	10 92 d3 02 	sts	0x02D3, r1
    3612:	10 92 d4 02 	sts	0x02D4, r1
    3616:	10 92 d5 02 	sts	0x02D5, r1
    361a:	0e 94 5a 1a 	call	0x34b4 <TM_FindNextTag>
    361e:	80 91 4b 02 	lds	r24, 0x024B
    3622:	88 23       	and	r24, r24
    3624:	71 f0       	breq	.+28     	; 0x3642 <TM_ShowTags+0x46>
    3626:	8e b3       	in	r24, 0x1e	; 30
    3628:	88 23       	and	r24, r24
    362a:	e9 f3       	breq	.-6      	; 0x3626 <TM_ShowTags+0x2a>
    362c:	f7 9b       	sbis	0x1e, 7	; 30
    362e:	03 c0       	rjmp	.+6      	; 0x3636 <TM_ShowTags+0x3a>
    3630:	0e 94 5a 1a 	call	0x34b4 <TM_FindNextTag>
    3634:	02 c0       	rjmp	.+4      	; 0x363a <TM_ShowTags+0x3e>
    3636:	f2 99       	sbic	0x1e, 2	; 30
    3638:	03 c0       	rjmp	.+6      	; 0x3640 <TM_ShowTags+0x44>
    363a:	0e 94 37 02 	call	0x46e <MAIN_WaitForJoyRelease>
    363e:	f3 cf       	rjmp	.-26     	; 0x3626 <TM_ShowTags+0x2a>
    3640:	80 e0       	ldi	r24, 0x00	; 0
    3642:	0e 94 d4 09 	call	0x13a8 <DF_EnableDataflash>
    3646:	08 95       	ret

00003648 <__vector_2>:
.global PCINT0_vect             ; Pin change 0 (joystick)
.global PCINT1_vect             ; Pin change 1 (joystick)

PCINT0_vect:
  jmp PCINT1_vect
    3648:	0c 94 8e 03 	jmp	0x71c <__vector_3>

0000364c <__vector_10>:

.global TIMER0_COMP_vect             ; Timer 0 compare

TIMER0_COMP_vect:
  push r24
    364c:	8f 93       	push	r24
  ldi r24, (USI_CONTROL_REG_FLAGS | (1<<USITC))
    364e:	8b e5       	ldi	r24, 0x5B	; 91
  sts _SFR_MEM_ADDR(USICR), r24
    3650:	80 93 b8 00 	sts	0x00B8, r24
  pop r24
    3654:	8f 91       	pop	r24
  reti
    3656:	18 95       	reti

00003658 <strcpy_P>:
    3658:	fb 01       	movw	r30, r22
    365a:	dc 01       	movw	r26, r24
    365c:	05 90       	lpm	r0, Z+
    365e:	0d 92       	st	X+, r0
    3660:	00 20       	and	r0, r0
    3662:	e1 f7       	brne	.-8      	; 0x365c <strcpy_P+0x4>
    3664:	08 95       	ret

00003666 <ultoa>:
    3666:	fa 01       	movw	r30, r20
    3668:	cf 93       	push	r28
    366a:	ff 93       	push	r31
    366c:	ef 93       	push	r30
    366e:	22 30       	cpi	r18, 0x02	; 2
    3670:	cc f0       	brlt	.+50     	; 0x36a4 <ultoa+0x3e>
    3672:	25 32       	cpi	r18, 0x25	; 37
    3674:	bc f4       	brge	.+46     	; 0x36a4 <ultoa+0x3e>
    3676:	c2 2f       	mov	r28, r18
    3678:	2c 2f       	mov	r18, r28
    367a:	33 27       	eor	r19, r19
    367c:	44 27       	eor	r20, r20
    367e:	55 27       	eor	r21, r21
    3680:	ff 93       	push	r31
    3682:	ef 93       	push	r30
    3684:	0e 94 87 1b 	call	0x370e <__udivmodsi4>
    3688:	ef 91       	pop	r30
    368a:	ff 91       	pop	r31
    368c:	60 5d       	subi	r22, 0xD0	; 208
    368e:	6a 33       	cpi	r22, 0x3A	; 58
    3690:	0c f0       	brlt	.+2      	; 0x3694 <ultoa+0x2e>
    3692:	69 5d       	subi	r22, 0xD9	; 217
    3694:	61 93       	st	Z+, r22
    3696:	b9 01       	movw	r22, r18
    3698:	ca 01       	movw	r24, r20
    369a:	60 50       	subi	r22, 0x00	; 0
    369c:	70 40       	sbci	r23, 0x00	; 0
    369e:	80 40       	sbci	r24, 0x00	; 0
    36a0:	90 40       	sbci	r25, 0x00	; 0
    36a2:	51 f7       	brne	.-44     	; 0x3678 <ultoa+0x12>
    36a4:	10 82       	st	Z, r1
    36a6:	8f 91       	pop	r24
    36a8:	9f 91       	pop	r25
    36aa:	cf 91       	pop	r28
    36ac:	0c 94 58 1b 	jmp	0x36b0 <strrev>

000036b0 <strrev>:
    36b0:	dc 01       	movw	r26, r24
    36b2:	fc 01       	movw	r30, r24
    36b4:	01 90       	ld	r0, Z+
    36b6:	00 20       	and	r0, r0
    36b8:	e9 f7       	brne	.-6      	; 0x36b4 <strrev+0x4>
    36ba:	32 97       	sbiw	r30, 0x02	; 2
    36bc:	ae 17       	cp	r26, r30
    36be:	bf 07       	cpc	r27, r31
    36c0:	30 f4       	brcc	.+12     	; 0x36ce <strrev+0x1e>
    36c2:	7c 91       	ld	r23, X
    36c4:	60 81       	ld	r22, Z
    36c6:	70 83       	st	Z, r23
    36c8:	31 97       	sbiw	r30, 0x01	; 1
    36ca:	6d 93       	st	X+, r22
    36cc:	f7 cf       	rjmp	.-18     	; 0x36bc <strrev+0xc>
    36ce:	08 95       	ret

000036d0 <__mulsi3>:
    36d0:	62 9f       	mul	r22, r18
    36d2:	d0 01       	movw	r26, r0
    36d4:	73 9f       	mul	r23, r19
    36d6:	f0 01       	movw	r30, r0
    36d8:	82 9f       	mul	r24, r18
    36da:	e0 0d       	add	r30, r0
    36dc:	f1 1d       	adc	r31, r1
    36de:	64 9f       	mul	r22, r20
    36e0:	e0 0d       	add	r30, r0
    36e2:	f1 1d       	adc	r31, r1
    36e4:	92 9f       	mul	r25, r18
    36e6:	f0 0d       	add	r31, r0
    36e8:	83 9f       	mul	r24, r19
    36ea:	f0 0d       	add	r31, r0
    36ec:	74 9f       	mul	r23, r20
    36ee:	f0 0d       	add	r31, r0
    36f0:	65 9f       	mul	r22, r21
    36f2:	f0 0d       	add	r31, r0
    36f4:	99 27       	eor	r25, r25
    36f6:	72 9f       	mul	r23, r18
    36f8:	b0 0d       	add	r27, r0
    36fa:	e1 1d       	adc	r30, r1
    36fc:	f9 1f       	adc	r31, r25
    36fe:	63 9f       	mul	r22, r19
    3700:	b0 0d       	add	r27, r0
    3702:	e1 1d       	adc	r30, r1
    3704:	f9 1f       	adc	r31, r25
    3706:	bd 01       	movw	r22, r26
    3708:	cf 01       	movw	r24, r30
    370a:	11 24       	eor	r1, r1
    370c:	08 95       	ret

0000370e <__udivmodsi4>:
    370e:	a1 e2       	ldi	r26, 0x21	; 33
    3710:	1a 2e       	mov	r1, r26
    3712:	aa 1b       	sub	r26, r26
    3714:	bb 1b       	sub	r27, r27
    3716:	fd 01       	movw	r30, r26
    3718:	0d c0       	rjmp	.+26     	; 0x3734 <__udivmodsi4_ep>

0000371a <__udivmodsi4_loop>:
    371a:	aa 1f       	adc	r26, r26
    371c:	bb 1f       	adc	r27, r27
    371e:	ee 1f       	adc	r30, r30
    3720:	ff 1f       	adc	r31, r31
    3722:	a2 17       	cp	r26, r18
    3724:	b3 07       	cpc	r27, r19
    3726:	e4 07       	cpc	r30, r20
    3728:	f5 07       	cpc	r31, r21
    372a:	20 f0       	brcs	.+8      	; 0x3734 <__udivmodsi4_ep>
    372c:	a2 1b       	sub	r26, r18
    372e:	b3 0b       	sbc	r27, r19
    3730:	e4 0b       	sbc	r30, r20
    3732:	f5 0b       	sbc	r31, r21

00003734 <__udivmodsi4_ep>:
    3734:	66 1f       	adc	r22, r22
    3736:	77 1f       	adc	r23, r23
    3738:	88 1f       	adc	r24, r24
    373a:	99 1f       	adc	r25, r25
    373c:	1a 94       	dec	r1
    373e:	69 f7       	brne	.-38     	; 0x371a <__udivmodsi4_loop>
    3740:	60 95       	com	r22
    3742:	70 95       	com	r23
    3744:	80 95       	com	r24
    3746:	90 95       	com	r25
    3748:	9b 01       	movw	r18, r22
    374a:	ac 01       	movw	r20, r24
    374c:	bd 01       	movw	r22, r26
    374e:	cf 01       	movw	r24, r30
    3750:	08 95       	ret
