
ButtLoad.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  0000336a  0000341e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000336a  00000000  00000000  000000b4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b0  00800104  00800104  00003422  2**0
                  ALLOC
  3 .noinit       00000000  008002b4  008002b4  000034a9  2**0
                  CONTENTS
  4 .eeprom       00000087  00810000  00810000  00003422  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  5 .stab         00000084  00000000  00000000  000034ac  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      00000078  00000000  00000000  00003530  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 0000012c  00000000  00000000  000035a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000da4  00000000  00000000  000036d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00003fb3  00000000  00000000  00004478  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00000fea  00000000  00000000  0000842b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00003298  00000000  00000000  00009415  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000010cd  00000000  00000000  0000c6ad  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 fa 01 	jmp	0x3f4 <__init>
       4:	0c 94 15 02 	jmp	0x42a <__bad_interrupt>
       8:	0c 94 08 19 	jmp	0x3210 <__vector_2>
       c:	0c 94 7b 03 	jmp	0x6f6 <__vector_3>
      10:	0c 94 15 02 	jmp	0x42a <__bad_interrupt>
      14:	0c 94 1d 07 	jmp	0xe3a <__vector_5>
      18:	0c 94 15 02 	jmp	0x42a <__bad_interrupt>
      1c:	0c 94 15 02 	jmp	0x42a <__bad_interrupt>
      20:	0c 94 15 02 	jmp	0x42a <__bad_interrupt>
      24:	0c 94 2c 0b 	jmp	0x1658 <__vector_9>
      28:	0c 94 0a 19 	jmp	0x3214 <__vector_10>
      2c:	0c 94 15 02 	jmp	0x42a <__bad_interrupt>
      30:	0c 94 15 02 	jmp	0x42a <__bad_interrupt>
      34:	0c 94 b2 0a 	jmp	0x1564 <__vector_13>
      38:	0c 94 15 02 	jmp	0x42a <__bad_interrupt>
      3c:	0c 94 15 02 	jmp	0x42a <__bad_interrupt>
      40:	0c 94 15 02 	jmp	0x42a <__bad_interrupt>
      44:	0c 94 9e 08 	jmp	0x113c <__vector_17>
      48:	0c 94 15 02 	jmp	0x42a <__bad_interrupt>
      4c:	0c 94 15 02 	jmp	0x42a <__bad_interrupt>
      50:	0c 94 15 02 	jmp	0x42a <__bad_interrupt>
      54:	0c 94 15 02 	jmp	0x42a <__bad_interrupt>
      58:	0c 94 da 07 	jmp	0xfb4 <__vector_22>

0000005c <SIFOOptionPtrs>:
      5c:	6f 00 60 00                                         o.`.

00000060 <SIFO_Tags>:
      60:	56 49 45 57 20 44 41 54 41 20 54 41 47 53 00        VIEW DATA TAGS.

0000006f <SIFO_Size>:
      6f:	53 54 4f 52 41 47 45 20 53 49 5a 45 53 00           STORAGE SIZES.

0000007d <USIPSNamePtrs>:
      7d:	a3 00 99 00 8f 00 85 00                             ........

00000085 <USI_Speed3>:
      85:	32 31 30 36 35 31 20 48 5a 00                       210651 HZ.

0000008f <USI_Speed2>:
      8f:	31 31 33 34 32 37 20 48 5a 00                       113427 HZ.

00000099 <USI_Speed1>:
      99:	20 38 36 37 33 38 20 48 5a 00                        86738 HZ.

000000a3 <USI_Speed0>:
      a3:	20 35 37 31 35 33 20 48 5a 00                        57153 HZ.

000000ad <ProgOptions>:
      ad:	16 01 0a 01 fa 00 ea 00 da 00 c6 00 bb 00           ..............

000000bb <PRG_C>:
      bb:	45 52 41 53 45 20 4f 4e 4c 59 00                    ERASE ONLY.

000000c6 <PRG_FL>:
      c6:	46 55 53 45 20 41 4e 44 20 4c 4f 43 4b 20 42 59     FUSE AND LOCK BY
      d6:	54 45 53 00                                         TES.

000000da <PRG_L>:
      da:	4c 4f 43 4b 20 42 59 54 45 53 20 4f 4e 4c 59 00     LOCK BYTES ONLY.

000000ea <PRG_F>:
      ea:	46 55 53 45 20 42 59 54 45 53 20 4f 4e 4c 59 00     FUSE BYTES ONLY.

000000fa <PRG_DE>:
      fa:	44 41 54 41 20 41 4e 44 20 45 45 50 52 4f 4d 00     DATA AND EEPROM.

0000010a <PRG_E>:
     10a:	45 45 50 52 4f 4d 20 4f 4e 4c 59 00                 EEPROM ONLY.

00000116 <PRG_D>:
     116:	44 41 54 41 20 4f 4e 4c 59 00                       DATA ONLY.

00000120 <SettingFunctionPtrs>:
     120:	b1 05 04 06 7d 05 aa 06                             ....}...

00000128 <SettingFunctionNames>:
     128:	5e 01 50 01 43 01 30 01                             ^.P.C.0.

00000130 <SFunc_GOBOOTLOADER>:
     130:	4a 55 4d 50 20 54 4f 20 42 4f 4f 54 4c 4f 41 44     JUMP TO BOOTLOAD
     140:	45 52 00                                            ER.

00000143 <SFunc_CLEARMEM>:
     143:	43 4c 45 41 52 20 4d 45 4d 4f 52 59 00              CLEAR MEMORY.

00000150 <SFunc_SETSPISPEED>:
     150:	53 45 54 20 53 50 49 20 53 50 45 45 44 00           SET SPI SPEED.

0000015e <SFunc_SETCONTRAST>:
     15e:	53 45 54 20 43 4f 4e 54 52 41 53 54 00              SET CONTRAST.

0000016b <MainFunctionPtrs>:
     16b:	cc 03 4b 05 16 04 e5 03 52 06 97 03 3e 06           ..K.....R...>.

00000179 <MainFunctionNames>:
     179:	d0 01 c5 01 b9 01 aa 01 9b 01 92 01 87 01           ..............

00000187 <Func_SLEEP>:
     187:	53 4c 45 45 50 20 4d 4f 44 45 00                    SLEEP MODE.

00000192 <Func_SETTINGS>:
     192:	53 45 54 54 49 4e 47 53 00                          SETTINGS.

0000019b <Func_PRGMSTOREINFO>:
     19b:	44 41 54 41 53 54 4f 52 45 20 49 4e 46 4f 00        DATASTORE INFO.

000001aa <Func_PRGMDATAFLASH>:
     1aa:	44 41 54 41 46 4c 41 53 48 20 50 52 47 4d 00        DATAFLASH PRGM.

000001b9 <Func_PRGMAVR>:
     1b9:	50 52 4f 47 52 41 4d 20 41 56 52 00                 PROGRAM AVR.

000001c5 <Func_STOREPRGM>:
     1c5:	53 54 4f 52 45 20 50 52 47 4d 00                    STORE PRGM.

000001d0 <Func_ISPPRGM>:
     1d0:	41 56 52 49 53 50 20 4d 4f 44 45 00                 AVRISP MODE.

000001dc <AboutTextPtrs>:
     1dc:	07 02 02 02 f3 01 e4 01                             ........

000001e4 <CopyRight>:
     1e4:	3c 43 3e 20 32 30 30 36 20 2d 20 47 50 4c 00        <C> 2006 - GPL.

000001f3 <AuthorName>:
     1f3:	42 59 20 44 45 41 4e 20 43 41 4d 45 52 41 00        BY DEAN CAMERA.

00000202 <VersionInfo>:
     202:	56 31 2d 33 00                                      V1-3.

00000207 <ProgrammerName>:
     207:	42 55 54 54 4c 4f 41 44 00                          BUTTLOAD.

00000210 <WaitText>:
     210:	2a 57 41 49 54 2a 00                                *WAIT*.

00000217 <BUTTTAG_Author>:
     217:	40 28 23 29 42 59 20 44 45 41 4e 20 43 41 4d 45     @(#)BY DEAN CAME
     227:	52 41 00                                            RA.

0000022a <BUTTTAG_Name>:
     22a:	40 28 23 29 42 55 54 54 4c 4f 41 44 20 41 56 52     @(#)BUTTLOAD AVR
     23a:	49 53 50 00                                         ISP.

0000023e <__c.14>:
     23e:	50 52 47 3e 20 00                                   PRG> .

00000244 <__c.13>:
     244:	42 41 44 49 53 52 00                                BADISR.

0000024b <__c.6>:
     24b:	4e 4f 20 45 52 41 53 45 20 43 4d 44 00              NO ERASE CMD.

00000258 <__c.7>:
     258:	4e 4f 20 44 41 54 41 00                             NO DATA.

00000260 <__c.8>:
     260:	4e 4f 20 45 45 50 52 4f 4d 00                       NO EEPROM.

0000026a <__c.9>:
     26a:	4e 4f 20 46 55 53 45 20 42 59 54 45 53 00           NO FUSE BYTES.

00000278 <__c.10>:
     278:	4e 4f 20 4c 4f 43 4b 20 42 59 54 45 53 00           NO LOCK BYTES.

00000286 <__c.11>:
     286:	50 52 4f 47 52 41 4d 4d 49 4e 47 20 44 4f 4e 45     PROGRAMMING DONE
	...

00000297 <__c.12>:
     297:	46 41 49 4c 45 44 00                                FAILED.

0000029e <__c.5>:
     29e:	2a 53 54 4f 52 41 47 45 20 4d 4f 44 45 2a 00        *STORAGE MODE*.

000002ad <__c.2>:
     2ad:	43 4f 4e 46 49 52 4d 00                             CONFIRM.

000002b5 <__c.3>:
     2b5:	3c 4e 20 59 3e 00                                   <N Y>.

000002bb <__c.4>:
     2bb:	4d 45 4d 20 43 4c 45 41 52 45 44 00                 MEM CLEARED.

000002c7 <__c.1>:
     2c7:	4e 4f 20 53 54 4f 52 45 44 20 50 52 47 4d 00        NO STORED PRGM.

000002d6 <__c.0>:
     2d6:	2a 4a 54 41 47 20 4f 4e 2a 00                       *JTAG ON*.

000002e0 <LCD_SegTable>:
     2e0:	a8 ea 80 2a 00 40 00 0a 51 0a 08 40 59 55 18 01     ...*.@..Q..@YU..
     2f0:	11 1e 11 1b 50 0b 41 1b 41 1f 11 01 51 1f 51 1b     ....P.A.A...Q.Q.
     300:	00 00 00 00 08 80 00 1a 20 40 00 00 00 00 51 0f     ........ @....Q.
     310:	91 39 41 14 91 31 41 1e 41 0e 41 1d 50 0f 80 20     .9A..1A.A.A.P.. 
     320:	10 15 48 86 40 14 78 05 70 85 51 15 51 0e 51 95     ..H.@.x.p.Q.Q.Q.
     330:	51 8e 21 90 81 20 50 15 48 44 50 c5 28 c0 28 20     Q.!.. P.HDP.(.( 
     340:	09 50 41 14 20 80 11 11 00 00 00 10                 .PA. .......

0000034c <USIPSValues>:
     34c:	03 80 02 54 01 40 00 22                             ...T.@."

00000354 <DataFlashError>:
     354:	44 41 54 41 46 4c 41 53 48 20 45 52 52 4f 52 00     DATAFLASH ERROR.

00000364 <DF_Pages>:
     364:	00 01 00 02 00 04 00 08 00 10 00 10 00 20 00 20     ............. . 

00000374 <DF_PageSize>:
     374:	08 01 08 01 08 01 08 01 08 01 10 02 10 02 20 04     .............. .

00000384 <DF_PageBits>:
     384:	09 09 09 09 09 0a 0a 0b                             ........

0000038c <__c.0>:
     38c:	42 55 46 46 20 4f 56 45 52 46 4c 4f 57 00           BUFF OVERFLOW.

0000039a <DataFlashProgMode>:
     39a:	2a 44 41 54 41 46 4c 41 53 48 20 4d 4f 44 45 2a     *DATAFLASH MODE*
	...

000003ab <SignonResponse>:
     3ab:	01 00 08 41 56 52 49 53 50 5f 32                    ...AVRISP_2

000003b6 <VersionData>:
     3b6:	02 02 04                                            ...

000003b9 <SyncErrorMessage>:
     3b9:	53 59 4e 43 20 45 52 52 4f 52 00                    SYNC ERROR.

000003c4 <AVRISPModeMessage>:
     3c4:	2a 41 54 41 56 52 49 53 50 20 4d 4f 44 45 2a 00     *ATAVRISP MODE*.

000003d4 <__c.0>:
     3d4:	44 41 54 41 2d 00                                   DATA-.

000003da <__c.1>:
     3da:	45 50 52 4d 2d 00                                   EPRM-.

000003e0 <__c.2>:
     3e0:	46 55 53 45 2d 00                                   FUSE-.

000003e6 <__c.3>:
     3e6:	4c 4f 43 4b 2d 00                                   LOCK-.

000003ec <__c.0>:
     3ec:	4e 4f 20 54 41 47 53 00                             NO TAGS.

000003f4 <__init>:
     3f4:	11 24       	eor	r1, r1
     3f6:	1f be       	out	0x3f, r1	; 63
     3f8:	cf ef       	ldi	r28, 0xFF	; 255
     3fa:	d4 e0       	ldi	r29, 0x04	; 4
     3fc:	de bf       	out	0x3e, r29	; 62
     3fe:	cd bf       	out	0x3d, r28	; 61

00000400 <__do_copy_data>:
     400:	11 e0       	ldi	r17, 0x01	; 1
     402:	a0 e0       	ldi	r26, 0x00	; 0
     404:	b1 e0       	ldi	r27, 0x01	; 1
     406:	ea e6       	ldi	r30, 0x6A	; 106
     408:	f3 e3       	ldi	r31, 0x33	; 51
     40a:	02 c0       	rjmp	.+4      	; 0x410 <.do_copy_data_start>

0000040c <.do_copy_data_loop>:
     40c:	05 90       	lpm	r0, Z+
     40e:	0d 92       	st	X+, r0

00000410 <.do_copy_data_start>:
     410:	a4 30       	cpi	r26, 0x04	; 4
     412:	b1 07       	cpc	r27, r17
     414:	d9 f7       	brne	.-10     	; 0x40c <.do_copy_data_loop>

00000416 <__do_clear_bss>:
     416:	12 e0       	ldi	r17, 0x02	; 2
     418:	a4 e0       	ldi	r26, 0x04	; 4
     41a:	b1 e0       	ldi	r27, 0x01	; 1
     41c:	01 c0       	rjmp	.+2      	; 0x420 <.do_clear_bss_start>

0000041e <.do_clear_bss_loop>:
     41e:	1d 92       	st	X+, r1

00000420 <.do_clear_bss_start>:
     420:	a4 3b       	cpi	r26, 0xB4	; 180
     422:	b1 07       	cpc	r27, r17
     424:	e1 f7       	brne	.-8      	; 0x41e <.do_clear_bss_loop>
     426:	0c 94 5b 02 	jmp	0x4b6 <main>

0000042a <__bad_interrupt>:
     42a:	0c 94 92 03 	jmp	0x724 <__vector_default>

0000042e <MAIN_Delay10MS>:

// ======================================================================================

void MAIN_Delay10MS(uint8_t loops)
{
     42e:	cf 93       	push	r28
     430:	df 93       	push	r29
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     432:	28 2f       	mov	r18, r24
     434:	21 50       	subi	r18, 0x01	; 1
     436:	2f 3f       	cpi	r18, 0xFF	; 255
     438:	49 f0       	breq	.+18     	; 0x44c <MAIN_Delay10MS+0x1e>
     43a:	a0 e0       	ldi	r26, 0x00	; 0
     43c:	b8 e4       	ldi	r27, 0x48	; 72
     43e:	c0 e0       	ldi	r28, 0x00	; 0
     440:	d0 e0       	ldi	r29, 0x00	; 0
     442:	cd 01       	movw	r24, r26
     444:	01 97       	sbiw	r24, 0x01	; 1
     446:	f1 f7       	brne	.-4      	; 0x444 <MAIN_Delay10MS+0x16>
     448:	21 50       	subi	r18, 0x01	; 1
     44a:	d8 f7       	brcc	.-10     	; 0x442 <MAIN_Delay10MS+0x14>
     44c:	df 91       	pop	r29
     44e:	cf 91       	pop	r28
     450:	08 95       	ret

00000452 <MAIN_WaitForJoyRelease>:
  /* Prevents the use of floating point libraries. Delaying in groups of
     10ms increases accuracy by reducing the time overhead for each loop
     interation of the while.                                            */

	while (loops--)
	  _delay_ms(10);
}

void MAIN_Delay1MS(uint8_t loops)
{
  /* Prevents the use of floating point libraries. Less accurate than the
     Delay10MS routine, but nessesary for many commands. The overhead required
     to call the routine is substantially less than the overhead required to
     calculate the float at compile time, so this actually saves execution time. */

	while (loops--)
	  _delay_ms(1);
}

void MAIN_ResetCSLine(uint8_t ActiveInactive)
{
  /* ActiveInactive controls the /Reset line to an AVR device or external dataflash
     /CS line. If the reset polarity parameter is a 0 then interfacing with AT89
	 devices which has an active high reset. Pins are tristated when inactive.      */
	
	switch (ActiveInactive)
	{
		case MAIN_RESETCS_ACTIVE:   // The target RESET line may be either active high or low.
			DDRF |= (1 << 6);
		
			if (!(eeprom_read_byte(&EEPROMVars.ResetPolarity))) // Translate to correct logic level for target device type
			  PORTF |=  (1 << 6);
			else
			  PORTF &= ~(1 << 6);
		
			break;
		case MAIN_RESETCS_EXTDFACTIVE: // Dataflashes are always active low.
			DDRF  |=  (1 << 6);
			PORTF &= ~(1 << 6);
			
			break;
		case MAIN_RESETCS_INACTIVE: // Both modes tristate the pins when inactive.
			DDRF  &= ~(1 << 6);
			PORTF &= ~(1 << 6);
	}
}

void MAIN_WaitForJoyRelease(void)
{
	while (1)
	{
		while (JoyStatus) {};                   // Wait until joystick released
     452:	8e b3       	in	r24, 0x1e	; 30
     454:	88 23       	and	r24, r24
     456:	e9 f7       	brne	.-6      	; 0x452 <MAIN_WaitForJoyRelease>

		MAIN_Delay10MS(1);
     458:	81 e0       	ldi	r24, 0x01	; 1
     45a:	0e 94 17 02 	call	0x42e <MAIN_Delay10MS>

		if (!(JoyStatus))                       // Joystick still released (not bouncing), return
     45e:	8e b3       	in	r24, 0x1e	; 30
     460:	88 23       	and	r24, r24
     462:	b9 f7       	brne	.-18     	; 0x452 <MAIN_WaitForJoyRelease>
     464:	08 95       	ret

00000466 <FUNCShowAbout>:
		  return;
	}
}

void MAIN_IntToStr(uint16_t IntV, uint8_t* Buff)
{
	// Shows leading zeros, unlike itoa.

	uint8_t Temp = 0;
	
	while (IntV >= 100)
	{
		Temp++;
		IntV -= 100;
	}

	*(Buff++) = '0' + Temp;
	
	Temp = 0;
	
	while (IntV >= 10)
	{
		Temp++;
		IntV -= 10;
	}
		
	*(Buff++) = '0' + Temp;
	*(Buff++) = '0' + IntV;
	*(Buff)   = '\0';
}

void MAIN_ShowProgType(uint8_t Letter)
{
	uint8_t ProgTypeBuffer[7];

	strcpy_P(ProgTypeBuffer, PSTR("PRG> "));
	ProgTypeBuffer[5] = Letter;
	ProgTypeBuffer[6] = '\0';
	
	LCD_puts(ProgTypeBuffer);
}

void MAIN_ShowError(const uint8_t *pFlashStr)
{
	uint8_t ErrorBuff[LCD_TEXTBUFFER_SIZE];       // New buffer, LCD text buffer size
	
	ErrorBuff[0] = 'E';
	ErrorBuff[1] = '>';

	strcpy_P(&ErrorBuff[2], pFlashStr);       // WARNING: If error text is larger than (TEXTBUFFER_SIZE - 2),
	                                          // this will overflow the buffer and probably crash the micro!
	LCD_puts(ErrorBuff);
	
	MAIN_WaitForJoyRelease();
	while (!(JoyStatus & JOY_PRESS)) {};
	MAIN_WaitForJoyRelease();
}

// ======================================================================================

ISR(PCINT1_vect, ISR_NOBLOCK)                 // Joystick routine; PCINT0_vect is bound to this also via JoystickInterrupt.S
{
	JoyStatus = (~PINB & JOY_BMASK)
	          | (~PINE & JOY_EMASK);
}

ISR(BADISR_vect, ISR_NAKED)                   // Bad ISR routine; should never be called, here for safety
{
	MAIN_ShowError(PSTR("BADISR"));
	while (1) {};
}

// ======================================================================================

void FUNCChangeSettings(void)
{
	uint8_t CurrSFunc = 0;
	
	JoyStatus = 1;

	while (1)
	{
		if (JoyStatus)                         // Joystick is in the non-center position
		{
			if (JoyStatus & JOY_UP)            // Previous function
			  (CurrSFunc == 0)? CurrSFunc = 3 : CurrSFunc--;
			else if (JoyStatus & JOY_DOWN)     // Next function
			  (CurrSFunc == 3)? CurrSFunc = 0 : CurrSFunc++;
			else if (JoyStatus & JOY_PRESS)    // Select current function
			  ((FuncPtr)pgm_read_word(&SettingFunctionPtrs[CurrSFunc]))(); // Run associated function
			else if (JoyStatus & JOY_LEFT)
			  return;
		
			// Show current function onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&SettingFunctionNames[CurrSFunc]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCShowAbout(void)
{
     466:	cf 93       	push	r28
	uint8_t InfoNum = 0;
     468:	c0 e0       	ldi	r28, 0x00	; 0
	
	JoyStatus = 1;
     46a:	81 e0       	ldi	r24, 0x01	; 1
     46c:	8e bb       	out	0x1e, r24	; 30
			
	while (1)
	{
		if (JoyStatus)
     46e:	8e b3       	in	r24, 0x1e	; 30
     470:	88 23       	and	r24, r24
     472:	e9 f3       	breq	.-6      	; 0x46e <FUNCShowAbout+0x8>
		{
			if (JoyStatus & JOY_UP)
     474:	f6 9b       	sbis	0x1e, 6	; 30
     476:	06 c0       	rjmp	.+12     	; 0x484 <FUNCShowAbout+0x1e>
			  (InfoNum == 0)? InfoNum = 3 : InfoNum--;
     478:	cc 23       	and	r28, r28
     47a:	11 f4       	brne	.+4      	; 0x480 <FUNCShowAbout+0x1a>
     47c:	c3 e0       	ldi	r28, 0x03	; 3
     47e:	0c c0       	rjmp	.+24     	; 0x498 <FUNCShowAbout+0x32>
     480:	c1 50       	subi	r28, 0x01	; 1
     482:	0a c0       	rjmp	.+20     	; 0x498 <FUNCShowAbout+0x32>
			else if (JoyStatus & JOY_DOWN)
     484:	f7 9b       	sbis	0x1e, 7	; 30
     486:	06 c0       	rjmp	.+12     	; 0x494 <FUNCShowAbout+0x2e>
			  (InfoNum == 3)? InfoNum = 0 : InfoNum++;
     488:	c3 30       	cpi	r28, 0x03	; 3
     48a:	11 f4       	brne	.+4      	; 0x490 <FUNCShowAbout+0x2a>
     48c:	c0 e0       	ldi	r28, 0x00	; 0
     48e:	04 c0       	rjmp	.+8      	; 0x498 <FUNCShowAbout+0x32>
     490:	cf 5f       	subi	r28, 0xFF	; 255
     492:	02 c0       	rjmp	.+4      	; 0x498 <FUNCShowAbout+0x32>
			else if (JoyStatus & JOY_LEFT)
     494:	f2 99       	sbic	0x1e, 2	; 30
     496:	0d c0       	rjmp	.+26     	; 0x4b2 <FUNCShowAbout+0x4c>
			  return;

			LCD_puts_f((uint8_t*)pgm_read_word(&AboutTextPtrs[InfoNum]));
     498:	ec 2f       	mov	r30, r28
     49a:	ff 27       	eor	r31, r31
     49c:	ee 0f       	add	r30, r30
     49e:	ff 1f       	adc	r31, r31
     4a0:	e4 52       	subi	r30, 0x24	; 36
     4a2:	fe 4f       	sbci	r31, 0xFE	; 254
     4a4:	85 91       	lpm	r24, Z+
     4a6:	94 91       	lpm	r25, Z
     4a8:	0e 94 91 07 	call	0xf22 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     4ac:	0e 94 29 02 	call	0x452 <MAIN_WaitForJoyRelease>
     4b0:	de cf       	rjmp	.-68     	; 0x46e <FUNCShowAbout+0x8>
     4b2:	cf 91       	pop	r28
     4b4:	08 95       	ret

000004b6 <main>:
     4b6:	cf ef       	ldi	r28, 0xFF	; 255
     4b8:	d4 e0       	ldi	r29, 0x04	; 4
     4ba:	de bf       	out	0x3e, r29	; 62
     4bc:	cd bf       	out	0x3d, r28	; 61
     4be:	c0 e0       	ldi	r28, 0x00	; 0
     4c0:	80 e8       	ldi	r24, 0x80	; 128
     4c2:	85 bf       	out	0x35, r24	; 53
     4c4:	85 bf       	out	0x35, r24	; 53
     4c6:	80 bf       	out	0x30, r24	; 48
     4c8:	85 e0       	ldi	r24, 0x05	; 5
     4ca:	80 93 64 00 	sts	0x0064, r24
     4ce:	80 e3       	ldi	r24, 0x30	; 48
     4d0:	80 bb       	out	0x10, r24	; 16
     4d2:	87 e2       	ldi	r24, 0x27	; 39
     4d4:	84 b9       	out	0x04, r24	; 4
     4d6:	8f ed       	ldi	r24, 0xDF	; 223
     4d8:	85 b9       	out	0x05, r24	; 5
     4da:	8c e0       	ldi	r24, 0x0C	; 12
     4dc:	8e b9       	out	0x0e, r24	; 14
     4de:	80 93 6b 00 	sts	0x006B, r24
     4e2:	80 ed       	ldi	r24, 0xD0	; 208
     4e4:	80 93 6c 00 	sts	0x006C, r24
     4e8:	80 ec       	ldi	r24, 0xC0	; 192
     4ea:	8d bb       	out	0x1d, r24	; 29
     4ec:	8c bb       	out	0x1c, r24	; 28
     4ee:	81 b3       	in	r24, 0x11	; 17
     4f0:	8f 7c       	andi	r24, 0xCF	; 207
     4f2:	80 62       	ori	r24, 0x20	; 32
     4f4:	81 bb       	out	0x11, r24	; 17
     4f6:	0e 94 3e 07 	call	0xe7c <LCD_Init>
     4fa:	8f e0       	ldi	r24, 0x0F	; 15
     4fc:	80 93 e7 00 	sts	0x00E7, r24
     500:	80 e1       	ldi	r24, 0x10	; 16
     502:	92 e0       	ldi	r25, 0x02	; 2
     504:	0e 94 91 07 	call	0xf22 <LCD_puts_f>
     508:	78 94       	sei
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     50a:	26 e8       	ldi	r18, 0x86	; 134
     50c:	30 e0       	ldi	r19, 0x00	; 0
  uint8_t result;
  asm volatile
     50e:	d9 01       	movw	r26, r18
     510:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
     514:	80 2d       	mov	r24, r0
     516:	8a 37       	cpi	r24, 0x7A	; 122
     518:	89 f0       	breq	.+34     	; 0x53c <__stack+0x3d>
     51a:	80 e0       	ldi	r24, 0x00	; 0
     51c:	90 e0       	ldi	r25, 0x00	; 0
     51e:	4f ef       	ldi	r20, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     520:	dc 01       	movw	r26, r24
     522:	04 2e       	mov	r0, r20
     524:	0e 94 7d 19 	call	0x32fa <__eeprom_write_byte_1F2021>
     528:	01 96       	adiw	r24, 0x01	; 1
     52a:	52 e0       	ldi	r21, 0x02	; 2
     52c:	80 30       	cpi	r24, 0x00	; 0
     52e:	95 07       	cpc	r25, r21
     530:	b8 f3       	brcs	.-18     	; 0x520 <__stack+0x21>
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
     532:	8a e7       	ldi	r24, 0x7A	; 122
  asm volatile (
     534:	d9 01       	movw	r26, r18
     536:	08 2e       	mov	r0, r24
     538:	0e 94 7d 19 	call	0x32fa <__eeprom_write_byte_1F2021>
     53c:	a5 e8       	ldi	r26, 0x85	; 133
     53e:	b0 e0       	ldi	r27, 0x00	; 0
     540:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
     544:	80 2d       	mov	r24, r0
     546:	8f 70       	andi	r24, 0x0F	; 15
     548:	80 93 e7 00 	sts	0x00E7, r24
     54c:	80 e0       	ldi	r24, 0x00	; 0
     54e:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
     552:	81 b3       	in	r24, 0x11	; 17
     554:	80 63       	ori	r24, 0x30	; 48
     556:	81 bb       	out	0x11, r24	; 17
     558:	0e 94 4b 08 	call	0x1096 <USART_Init>
     55c:	0e 94 b8 06 	call	0xd70 <OSCCAL_Calibrate>
     560:	81 b3       	in	r24, 0x11	; 17
     562:	8f 7c       	andi	r24, 0xCF	; 207
     564:	80 61       	ori	r24, 0x10	; 16
     566:	81 bb       	out	0x11, r24	; 17
     568:	81 e0       	ldi	r24, 0x01	; 1
     56a:	8e bb       	out	0x1e, r24	; 30
     56c:	80 e8       	ldi	r24, 0x80	; 128
     56e:	80 93 61 00 	sts	0x0061, r24
     572:	83 e0       	ldi	r24, 0x03	; 3
     574:	80 93 61 00 	sts	0x0061, r24
     578:	8e b3       	in	r24, 0x1e	; 30
     57a:	88 23       	and	r24, r24
     57c:	e9 f3       	breq	.-6      	; 0x578 <__stack+0x79>
     57e:	f6 9b       	sbis	0x1e, 6	; 30
     580:	06 c0       	rjmp	.+12     	; 0x58e <__stack+0x8f>
     582:	cc 23       	and	r28, r28
     584:	11 f4       	brne	.+4      	; 0x58a <__stack+0x8b>
     586:	c6 e0       	ldi	r28, 0x06	; 6
     588:	1b c0       	rjmp	.+54     	; 0x5c0 <__stack+0xc1>
     58a:	c1 50       	subi	r28, 0x01	; 1
     58c:	19 c0       	rjmp	.+50     	; 0x5c0 <__stack+0xc1>
     58e:	f7 9b       	sbis	0x1e, 7	; 30
     590:	06 c0       	rjmp	.+12     	; 0x59e <__stack+0x9f>
     592:	c6 30       	cpi	r28, 0x06	; 6
     594:	11 f4       	brne	.+4      	; 0x59a <__stack+0x9b>
     596:	c0 e0       	ldi	r28, 0x00	; 0
     598:	13 c0       	rjmp	.+38     	; 0x5c0 <__stack+0xc1>
     59a:	cf 5f       	subi	r28, 0xFF	; 255
     59c:	11 c0       	rjmp	.+34     	; 0x5c0 <__stack+0xc1>
     59e:	f4 9b       	sbis	0x1e, 4	; 30
     5a0:	0b c0       	rjmp	.+22     	; 0x5b8 <__stack+0xb9>
     5a2:	ec 2f       	mov	r30, r28
     5a4:	ff 27       	eor	r31, r31
     5a6:	ee 0f       	add	r30, r30
     5a8:	ff 1f       	adc	r31, r31
     5aa:	e5 59       	subi	r30, 0x95	; 149
     5ac:	fe 4f       	sbci	r31, 0xFE	; 254
     5ae:	85 91       	lpm	r24, Z+
     5b0:	94 91       	lpm	r25, Z
     5b2:	fc 01       	movw	r30, r24
     5b4:	09 95       	icall
     5b6:	04 c0       	rjmp	.+8      	; 0x5c0 <__stack+0xc1>
     5b8:	f3 9b       	sbis	0x1e, 3	; 30
     5ba:	02 c0       	rjmp	.+4      	; 0x5c0 <__stack+0xc1>
     5bc:	0e 94 33 02 	call	0x466 <FUNCShowAbout>
     5c0:	ec 2f       	mov	r30, r28
     5c2:	ff 27       	eor	r31, r31
     5c4:	ee 0f       	add	r30, r30
     5c6:	ff 1f       	adc	r31, r31
     5c8:	e7 58       	subi	r30, 0x87	; 135
     5ca:	fe 4f       	sbci	r31, 0xFE	; 254
     5cc:	85 91       	lpm	r24, Z+
     5ce:	94 91       	lpm	r25, Z
     5d0:	0e 94 91 07 	call	0xf22 <LCD_puts_f>
     5d4:	0e 94 29 02 	call	0x452 <MAIN_WaitForJoyRelease>
     5d8:	cf cf       	rjmp	.-98     	; 0x578 <__stack+0x79>

000005da <MAIN_Delay1MS>:
     5da:	cf 93       	push	r28
     5dc:	df 93       	push	r29
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     5de:	28 2f       	mov	r18, r24
     5e0:	21 50       	subi	r18, 0x01	; 1
     5e2:	2f 3f       	cpi	r18, 0xFF	; 255
     5e4:	49 f0       	breq	.+18     	; 0x5f8 <MAIN_Delay1MS+0x1e>
     5e6:	a3 e3       	ldi	r26, 0x33	; 51
     5e8:	b7 e0       	ldi	r27, 0x07	; 7
     5ea:	c0 e0       	ldi	r28, 0x00	; 0
     5ec:	d0 e0       	ldi	r29, 0x00	; 0
     5ee:	cd 01       	movw	r24, r26
     5f0:	01 97       	sbiw	r24, 0x01	; 1
     5f2:	f1 f7       	brne	.-4      	; 0x5f0 <MAIN_Delay1MS+0x16>
     5f4:	21 50       	subi	r18, 0x01	; 1
     5f6:	d8 f7       	brcc	.-10     	; 0x5ee <MAIN_Delay1MS+0x14>
     5f8:	df 91       	pop	r29
     5fa:	cf 91       	pop	r28
     5fc:	08 95       	ret

000005fe <MAIN_ResetCSLine>:
     5fe:	99 27       	eor	r25, r25
     600:	81 30       	cpi	r24, 0x01	; 1
     602:	91 05       	cpc	r25, r1
     604:	b1 f0       	breq	.+44     	; 0x632 <MAIN_ResetCSLine+0x34>
     606:	82 30       	cpi	r24, 0x02	; 2
     608:	91 05       	cpc	r25, r1
     60a:	1c f4       	brge	.+6      	; 0x612 <MAIN_ResetCSLine+0x14>
     60c:	89 2b       	or	r24, r25
     60e:	21 f0       	breq	.+8      	; 0x618 <MAIN_ResetCSLine+0x1a>
     610:	08 95       	ret
     612:	02 97       	sbiw	r24, 0x02	; 2
     614:	59 f0       	breq	.+22     	; 0x62c <MAIN_ResetCSLine+0x2e>
     616:	08 95       	ret
     618:	86 9a       	sbi	0x10, 6	; 16
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     61a:	a0 e0       	ldi	r26, 0x00	; 0
     61c:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     61e:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
     622:	80 2d       	mov	r24, r0
     624:	88 23       	and	r24, r24
     626:	19 f4       	brne	.+6      	; 0x62e <MAIN_ResetCSLine+0x30>
     628:	8e 9a       	sbi	0x11, 6	; 17
     62a:	08 95       	ret
     62c:	86 9a       	sbi	0x10, 6	; 16
     62e:	8e 98       	cbi	0x11, 6	; 17
     630:	08 95       	ret
     632:	86 98       	cbi	0x10, 6	; 16
     634:	fc cf       	rjmp	.-8      	; 0x62e <MAIN_ResetCSLine+0x30>

00000636 <MAIN_IntToStr>:
     636:	fb 01       	movw	r30, r22
     638:	20 e0       	ldi	r18, 0x00	; 0
     63a:	84 36       	cpi	r24, 0x64	; 100
     63c:	91 05       	cpc	r25, r1
     63e:	20 f0       	brcs	.+8      	; 0x648 <MAIN_IntToStr+0x12>
     640:	2f 5f       	subi	r18, 0xFF	; 255
     642:	84 56       	subi	r24, 0x64	; 100
     644:	90 40       	sbci	r25, 0x00	; 0
     646:	f9 cf       	rjmp	.-14     	; 0x63a <MAIN_IntToStr+0x4>
     648:	20 5d       	subi	r18, 0xD0	; 208
     64a:	21 93       	st	Z+, r18
     64c:	20 e0       	ldi	r18, 0x00	; 0
     64e:	8a 30       	cpi	r24, 0x0A	; 10
     650:	91 05       	cpc	r25, r1
     652:	18 f0       	brcs	.+6      	; 0x65a <MAIN_IntToStr+0x24>
     654:	2f 5f       	subi	r18, 0xFF	; 255
     656:	0a 97       	sbiw	r24, 0x0a	; 10
     658:	fa cf       	rjmp	.-12     	; 0x64e <MAIN_IntToStr+0x18>
     65a:	20 5d       	subi	r18, 0xD0	; 208
     65c:	21 93       	st	Z+, r18
     65e:	80 5d       	subi	r24, 0xD0	; 208
     660:	81 93       	st	Z+, r24
     662:	10 82       	st	Z, r1
     664:	08 95       	ret

00000666 <MAIN_ShowProgType>:
     666:	1f 93       	push	r17
     668:	cf 93       	push	r28
     66a:	df 93       	push	r29
     66c:	cd b7       	in	r28, 0x3d	; 61
     66e:	de b7       	in	r29, 0x3e	; 62
     670:	27 97       	sbiw	r28, 0x07	; 7
     672:	0f b6       	in	r0, 0x3f	; 63
     674:	f8 94       	cli
     676:	de bf       	out	0x3e, r29	; 62
     678:	0f be       	out	0x3f, r0	; 63
     67a:	cd bf       	out	0x3d, r28	; 61
     67c:	18 2f       	mov	r17, r24
     67e:	6e e3       	ldi	r22, 0x3E	; 62
     680:	72 e0       	ldi	r23, 0x02	; 2
     682:	ce 01       	movw	r24, r28
     684:	01 96       	adiw	r24, 0x01	; 1
     686:	0e 94 10 19 	call	0x3220 <strcpy_P>
     68a:	1e 83       	std	Y+6, r17	; 0x06
     68c:	1f 82       	std	Y+7, r1	; 0x07
     68e:	ce 01       	movw	r24, r28
     690:	01 96       	adiw	r24, 0x01	; 1
     692:	0e 94 50 07 	call	0xea0 <LCD_puts>
     696:	27 96       	adiw	r28, 0x07	; 7
     698:	0f b6       	in	r0, 0x3f	; 63
     69a:	f8 94       	cli
     69c:	de bf       	out	0x3e, r29	; 62
     69e:	0f be       	out	0x3f, r0	; 63
     6a0:	cd bf       	out	0x3d, r28	; 61
     6a2:	df 91       	pop	r29
     6a4:	cf 91       	pop	r28
     6a6:	1f 91       	pop	r17
     6a8:	08 95       	ret

000006aa <MAIN_ShowError>:
     6aa:	cf 93       	push	r28
     6ac:	df 93       	push	r29
     6ae:	cd b7       	in	r28, 0x3d	; 61
     6b0:	de b7       	in	r29, 0x3e	; 62
     6b2:	64 97       	sbiw	r28, 0x14	; 20
     6b4:	0f b6       	in	r0, 0x3f	; 63
     6b6:	f8 94       	cli
     6b8:	de bf       	out	0x3e, r29	; 62
     6ba:	0f be       	out	0x3f, r0	; 63
     6bc:	cd bf       	out	0x3d, r28	; 61
     6be:	25 e4       	ldi	r18, 0x45	; 69
     6c0:	29 83       	std	Y+1, r18	; 0x01
     6c2:	2e e3       	ldi	r18, 0x3E	; 62
     6c4:	2a 83       	std	Y+2, r18	; 0x02
     6c6:	bc 01       	movw	r22, r24
     6c8:	ce 01       	movw	r24, r28
     6ca:	03 96       	adiw	r24, 0x03	; 3
     6cc:	0e 94 10 19 	call	0x3220 <strcpy_P>
     6d0:	ce 01       	movw	r24, r28
     6d2:	01 96       	adiw	r24, 0x01	; 1
     6d4:	0e 94 50 07 	call	0xea0 <LCD_puts>
     6d8:	0e 94 29 02 	call	0x452 <MAIN_WaitForJoyRelease>
     6dc:	f4 9b       	sbis	0x1e, 4	; 30
     6de:	fe cf       	rjmp	.-4      	; 0x6dc <MAIN_ShowError+0x32>
     6e0:	0e 94 29 02 	call	0x452 <MAIN_WaitForJoyRelease>
     6e4:	64 96       	adiw	r28, 0x14	; 20
     6e6:	0f b6       	in	r0, 0x3f	; 63
     6e8:	f8 94       	cli
     6ea:	de bf       	out	0x3e, r29	; 62
     6ec:	0f be       	out	0x3f, r0	; 63
     6ee:	cd bf       	out	0x3d, r28	; 61
     6f0:	df 91       	pop	r29
     6f2:	cf 91       	pop	r28
     6f4:	08 95       	ret

000006f6 <__vector_3>:
     6f6:	78 94       	sei
     6f8:	1f 92       	push	r1
     6fa:	0f 92       	push	r0
     6fc:	0f b6       	in	r0, 0x3f	; 63
     6fe:	0f 92       	push	r0
     700:	11 24       	eor	r1, r1
     702:	8f 93       	push	r24
     704:	9f 93       	push	r25
     706:	93 b1       	in	r25, 0x03	; 3
     708:	90 95       	com	r25
     70a:	90 7d       	andi	r25, 0xD0	; 208
     70c:	8c b1       	in	r24, 0x0c	; 12
     70e:	80 95       	com	r24
     710:	8c 70       	andi	r24, 0x0C	; 12
     712:	98 2b       	or	r25, r24
     714:	9e bb       	out	0x1e, r25	; 30
     716:	9f 91       	pop	r25
     718:	8f 91       	pop	r24
     71a:	0f 90       	pop	r0
     71c:	0f be       	out	0x3f, r0	; 63
     71e:	0f 90       	pop	r0
     720:	1f 90       	pop	r1
     722:	18 95       	reti

00000724 <__vector_default>:
     724:	84 e4       	ldi	r24, 0x44	; 68
     726:	92 e0       	ldi	r25, 0x02	; 2
     728:	0e 94 55 03 	call	0x6aa <MAIN_ShowError>
     72c:	ff cf       	rjmp	.-2      	; 0x72c <__vector_default+0x8>

0000072e <FUNCChangeSettings>:
     72e:	cf 93       	push	r28
     730:	c0 e0       	ldi	r28, 0x00	; 0
     732:	81 e0       	ldi	r24, 0x01	; 1
     734:	8e bb       	out	0x1e, r24	; 30
     736:	8e b3       	in	r24, 0x1e	; 30
     738:	88 23       	and	r24, r24
     73a:	e9 f3       	breq	.-6      	; 0x736 <FUNCChangeSettings+0x8>
     73c:	f6 9b       	sbis	0x1e, 6	; 30
     73e:	06 c0       	rjmp	.+12     	; 0x74c <FUNCChangeSettings+0x1e>
     740:	cc 23       	and	r28, r28
     742:	11 f4       	brne	.+4      	; 0x748 <FUNCChangeSettings+0x1a>
     744:	c3 e0       	ldi	r28, 0x03	; 3
     746:	19 c0       	rjmp	.+50     	; 0x77a <FUNCChangeSettings+0x4c>
     748:	c1 50       	subi	r28, 0x01	; 1
     74a:	17 c0       	rjmp	.+46     	; 0x77a <FUNCChangeSettings+0x4c>
     74c:	f7 9b       	sbis	0x1e, 7	; 30
     74e:	06 c0       	rjmp	.+12     	; 0x75c <FUNCChangeSettings+0x2e>
     750:	c3 30       	cpi	r28, 0x03	; 3
     752:	11 f4       	brne	.+4      	; 0x758 <FUNCChangeSettings+0x2a>
     754:	c0 e0       	ldi	r28, 0x00	; 0
     756:	11 c0       	rjmp	.+34     	; 0x77a <FUNCChangeSettings+0x4c>
     758:	cf 5f       	subi	r28, 0xFF	; 255
     75a:	0f c0       	rjmp	.+30     	; 0x77a <FUNCChangeSettings+0x4c>
     75c:	f4 9b       	sbis	0x1e, 4	; 30
     75e:	0b c0       	rjmp	.+22     	; 0x776 <FUNCChangeSettings+0x48>
     760:	ec 2f       	mov	r30, r28
     762:	ff 27       	eor	r31, r31
     764:	ee 0f       	add	r30, r30
     766:	ff 1f       	adc	r31, r31
     768:	e0 5e       	subi	r30, 0xE0	; 224
     76a:	fe 4f       	sbci	r31, 0xFE	; 254
     76c:	85 91       	lpm	r24, Z+
     76e:	94 91       	lpm	r25, Z
     770:	fc 01       	movw	r30, r24
     772:	09 95       	icall
     774:	02 c0       	rjmp	.+4      	; 0x77a <FUNCChangeSettings+0x4c>
     776:	f2 99       	sbic	0x1e, 2	; 30
     778:	0d c0       	rjmp	.+26     	; 0x794 <FUNCChangeSettings+0x66>
     77a:	ec 2f       	mov	r30, r28
     77c:	ff 27       	eor	r31, r31
     77e:	ee 0f       	add	r30, r30
     780:	ff 1f       	adc	r31, r31
     782:	e8 5d       	subi	r30, 0xD8	; 216
     784:	fe 4f       	sbci	r31, 0xFE	; 254
     786:	85 91       	lpm	r24, Z+
     788:	94 91       	lpm	r25, Z
     78a:	0e 94 91 07 	call	0xf22 <LCD_puts_f>
     78e:	0e 94 29 02 	call	0x452 <MAIN_WaitForJoyRelease>
     792:	d1 cf       	rjmp	.-94     	; 0x736 <FUNCChangeSettings+0x8>
     794:	cf 91       	pop	r28
     796:	08 95       	ret

00000798 <FUNCAVRISPMode>:
		}
	}
}

void FUNCAVRISPMode(void)
{
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
     798:	80 e1       	ldi	r24, 0x10	; 16
     79a:	92 e0       	ldi	r25, 0x02	; 2
     79c:	0e 94 91 07 	call	0xf22 <LCD_puts_f>
     7a0:	0e 94 b8 06 	call	0xd70 <OSCCAL_Calibrate>
     7a4:	80 91 c1 00 	lds	r24, 0x00C1
     7a8:	80 78       	andi	r24, 0x80	; 128
     7aa:	88 61       	ori	r24, 0x18	; 24
     7ac:	80 93 c1 00 	sts	0x00C1, r24

	LCD_puts_f(AVRISPModeMessage);
     7b0:	84 ec       	ldi	r24, 0xC4	; 196
     7b2:	93 e0       	ldi	r25, 0x03	; 3
     7b4:	0e 94 91 07 	call	0xf22 <LCD_puts_f>
	
	InterpretPacketRoutine = (FuncPtr)AICI_InterpretPacket;
     7b8:	84 e6       	ldi	r24, 0x64	; 100
     7ba:	91 e1       	ldi	r25, 0x11	; 17
     7bc:	90 93 03 01 	sts	0x0103, r25
     7c0:	80 93 02 01 	sts	0x0102, r24
	V2P_RunStateMachine();
     7c4:	0e 94 7a 0e 	call	0x1cf4 <V2P_RunStateMachine>
     7c8:	08 95       	ret

000007ca <FUNCProgramDataflash>:
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     7ca:	a1 e0       	ldi	r26, 0x01	; 1
     7cc:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     7ce:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
     7d2:	80 2d       	mov	r24, r0
     7d4:	0e 94 d4 08 	call	0x11a8 <USI_SPIInitMaster>
}

void FUNCProgramDataflash(void)
{
	USI_SPIInitMaster(eeprom_read_byte(&EEPROMVars.SCKDuration));
	UseExernalDF = TRUE;
     7d8:	81 e0       	ldi	r24, 0x01	; 1
     7da:	80 93 61 02 	sts	0x0261, r24
	DFSPIRoutinePointer = USI_SPITransmit;
     7de:	8e ee       	ldi	r24, 0xEE	; 238
     7e0:	98 e0       	ldi	r25, 0x08	; 8
     7e2:	90 93 01 01 	sts	0x0101, r25
     7e6:	80 93 00 01 	sts	0x0100, r24
	
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
     7ea:	80 e1       	ldi	r24, 0x10	; 16
     7ec:	92 e0       	ldi	r25, 0x02	; 2
     7ee:	0e 94 91 07 	call	0xf22 <LCD_puts_f>
     7f2:	0e 94 b8 06 	call	0xd70 <OSCCAL_Calibrate>
     7f6:	80 91 c1 00 	lds	r24, 0x00C1
     7fa:	80 78       	andi	r24, 0x80	; 128
     7fc:	88 61       	ori	r24, 0x18	; 24
     7fe:	80 93 c1 00 	sts	0x00C1, r24

	LCD_puts_f(DataFlashProgMode);
     802:	8a e9       	ldi	r24, 0x9A	; 154
     804:	93 e0       	ldi	r25, 0x03	; 3
     806:	0e 94 91 07 	call	0xf22 <LCD_puts_f>

	InterpretPacketRoutine = PD_InterpretAVRISPPacket;
     80a:	84 eb       	ldi	r24, 0xB4	; 180
     80c:	9b e0       	ldi	r25, 0x0B	; 11
     80e:	90 93 03 01 	sts	0x0103, r25
     812:	80 93 02 01 	sts	0x0102, r24
	V2P_RunStateMachine();
     816:	0e 94 7a 0e 	call	0x1cf4 <V2P_RunStateMachine>
	   
	DF_EnableDataflash(FALSE);
     81a:	80 e0       	ldi	r24, 0x00	; 0
     81c:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
	SPI_SPIOFF();
     820:	80 91 64 00 	lds	r24, 0x0064
     824:	84 60       	ori	r24, 0x04	; 4
     826:	80 93 64 00 	sts	0x0064, r24
     82a:	08 95       	ret

0000082c <FUNCProgramAVR>:
}

void FUNCProgramAVR(void)
{
     82c:	0f 93       	push	r16
     82e:	1f 93       	push	r17
     830:	cf 93       	push	r28
     832:	df 93       	push	r29
     834:	cd b7       	in	r28, 0x3d	; 61
     836:	de b7       	in	r29, 0x3e	; 62
     838:	63 97       	sbiw	r28, 0x13	; 19
     83a:	0f b6       	in	r0, 0x3f	; 63
     83c:	f8 94       	cli
     83e:	de bf       	out	0x3e, r29	; 62
     840:	0f be       	out	0x3f, r0	; 63
     842:	cd bf       	out	0x3d, r28	; 61
	uint8_t  DoneFailMessageBuff[19];
	uint8_t* EEPROMAddress;
	uint8_t  Fault = ISPCC_NO_FAULT;
     844:	00 e0       	ldi	r16, 0x00	; 0
	uint8_t  ProgMode = 0;
     846:	10 2f       	mov	r17, r16

	SPI_SPIInit();
     848:	0e 94 7f 08 	call	0x10fe <SPI_SPIInit>
	UseExernalDF = FALSE;
     84c:	00 93 61 02 	sts	0x0261, r16
	DFSPIRoutinePointer = SPI_SPITransmit;
     850:	89 e8       	ldi	r24, 0x89	; 137
     852:	98 e0       	ldi	r25, 0x08	; 8
     854:	90 93 01 01 	sts	0x0101, r25
     858:	80 93 00 01 	sts	0x0100, r24
	
	if (!(DF_CheckCorrectOnboardChip()))
     85c:	0e 94 9a 0a 	call	0x1534 <DF_CheckCorrectOnboardChip>
     860:	88 23       	and	r24, r24
     862:	09 f4       	brne	.+2      	; 0x866 <FUNCProgramAVR+0x3a>
     864:	0d c1       	rjmp	.+538    	; 0xa80 <FUNCProgramAVR+0x254>
	  return;

	MAIN_WaitForJoyRelease();
     866:	0e 94 29 02 	call	0x452 <MAIN_WaitForJoyRelease>
	
	JoyStatus = 1;                            // Use an invalid joystick value to force the program to write the
     86a:	81 e0       	ldi	r24, 0x01	; 1
     86c:	8e bb       	out	0x1e, r24	; 30
	                                          // name of the default command onto the LCD
	while (1)
	{
		if (JoyStatus)
     86e:	8e b3       	in	r24, 0x1e	; 30
     870:	88 23       	and	r24, r24
     872:	e9 f3       	breq	.-6      	; 0x86e <FUNCProgramAVR+0x42>
		{
			if (JoyStatus & JOY_LEFT)
     874:	f2 99       	sbic	0x1e, 2	; 30
     876:	04 c1       	rjmp	.+520    	; 0xa80 <FUNCProgramAVR+0x254>
			  return;
			else if (JoyStatus & JOY_PRESS)
     878:	f4 99       	sbic	0x1e, 4	; 30
     87a:	1c c0       	rjmp	.+56     	; 0x8b4 <FUNCProgramAVR+0x88>
			  break;
			else if (JoyStatus & JOY_UP)
     87c:	f6 9b       	sbis	0x1e, 6	; 30
     87e:	06 c0       	rjmp	.+12     	; 0x88c <FUNCProgramAVR+0x60>
			  (ProgMode == 0)? ProgMode = 6 : ProgMode--;
     880:	11 23       	and	r17, r17
     882:	11 f4       	brne	.+4      	; 0x888 <FUNCProgramAVR+0x5c>
     884:	16 e0       	ldi	r17, 0x06	; 6
     886:	09 c0       	rjmp	.+18     	; 0x89a <FUNCProgramAVR+0x6e>
     888:	11 50       	subi	r17, 0x01	; 1
     88a:	07 c0       	rjmp	.+14     	; 0x89a <FUNCProgramAVR+0x6e>
			else if (JoyStatus & JOY_DOWN)
     88c:	f7 9b       	sbis	0x1e, 7	; 30
     88e:	05 c0       	rjmp	.+10     	; 0x89a <FUNCProgramAVR+0x6e>
			  (ProgMode == 6)? ProgMode = 0 : ProgMode++;
     890:	16 30       	cpi	r17, 0x06	; 6
     892:	11 f4       	brne	.+4      	; 0x898 <FUNCProgramAVR+0x6c>
     894:	10 e0       	ldi	r17, 0x00	; 0
     896:	01 c0       	rjmp	.+2      	; 0x89a <FUNCProgramAVR+0x6e>
     898:	1f 5f       	subi	r17, 0xFF	; 255

			LCD_puts_f((uint8_t*)pgm_read_word(&ProgOptions[ProgMode])); // Show current function onto the LCD
     89a:	e1 2f       	mov	r30, r17
     89c:	ff 27       	eor	r31, r31
     89e:	ee 0f       	add	r30, r30
     8a0:	ff 1f       	adc	r31, r31
     8a2:	e3 55       	subi	r30, 0x53	; 83
     8a4:	ff 4f       	sbci	r31, 0xFF	; 255
     8a6:	85 91       	lpm	r24, Z+
     8a8:	94 91       	lpm	r25, Z
     8aa:	0e 94 91 07 	call	0xf22 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     8ae:	0e 94 29 02 	call	0x452 <MAIN_WaitForJoyRelease>
     8b2:	dd cf       	rjmp	.-70     	; 0x86e <FUNCProgramAVR+0x42>
		}
	}

	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);                // Orange = busy
     8b4:	81 b3       	in	r24, 0x11	; 17
     8b6:	80 63       	ori	r24, 0x30	; 48
     8b8:	81 bb       	out	0x11, r24	; 17
	LCD_puts_f(WaitText);
     8ba:	80 e1       	ldi	r24, 0x10	; 16
     8bc:	92 e0       	ldi	r25, 0x02	; 2
     8be:	0e 94 91 07 	call	0xf22 <LCD_puts_f>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     8c2:	a1 e0       	ldi	r26, 0x01	; 1
     8c4:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     8c6:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
     8ca:	80 2d       	mov	r24, r0
     8cc:	0e 94 d4 08 	call	0x11a8 <USI_SPIInitMaster>

	USI_SPIInitMaster(eeprom_read_byte(&EEPROMVars.SCKDuration));
	MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE); // Capture the RESET line of the slave AVR
     8d0:	80 e0       	ldi	r24, 0x00	; 0
     8d2:	0e 94 ff 02 	call	0x5fe <MAIN_ResetCSLine>
     8d6:	e2 e1       	ldi	r30, 0x12	; 18
     8d8:	f1 e0       	ldi	r31, 0x01	; 1
     8da:	20 e0       	ldi	r18, 0x00	; 0
     8dc:	30 e0       	ldi	r19, 0x00	; 0
     8de:	9b e0       	ldi	r25, 0x0B	; 11
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     8e0:	d9 01       	movw	r26, r18
     8e2:	ad 5d       	subi	r26, 0xDD	; 221
     8e4:	bf 4f       	sbci	r27, 0xFF	; 255
  uint8_t result;
  asm volatile
     8e6:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
     8ea:	80 2d       	mov	r24, r0
     8ec:	81 93       	st	Z+, r24
			
	for (uint8_t PacketB = 0; PacketB <= 11; PacketB++) // Read the enter programming mode command bytes
     8ee:	91 50       	subi	r25, 0x01	; 1
     8f0:	2f 5f       	subi	r18, 0xFF	; 255
     8f2:	3f 4f       	sbci	r19, 0xFF	; 255
     8f4:	97 ff       	sbrs	r25, 7
     8f6:	f4 cf       	rjmp	.-24     	; 0x8e0 <FUNCProgramAVR+0xb4>
	{
		PacketBytes[PacketB] = eeprom_read_byte(&EEPROMVars.EnterProgMode[PacketB]);
		EEPROMAddress++;
	}
	
	ISPCC_EnterChipProgrammingMode();    // Try to sync with the slave AVR
     8f8:	0e 94 d4 0f 	call	0x1fa8 <ISPCC_EnterChipProgrammingMode>

	CurrAddress = 0;
     8fc:	10 92 09 01 	sts	0x0109, r1
     900:	10 92 0a 01 	sts	0x010A, r1
     904:	10 92 0b 01 	sts	0x010B, r1
     908:	10 92 0c 01 	sts	0x010C, r1

	if (PacketBytes[1] == STATUS_CMD_OK) // ISPCC_EnterChipProgrammingMode alters the PacketBytes buffer rather than returning a value
     90c:	80 91 13 01 	lds	r24, 0x0113
     910:	88 23       	and	r24, r24
     912:	09 f0       	breq	.+2      	; 0x916 <FUNCProgramAVR+0xea>
     914:	a0 c0       	rjmp	.+320    	; 0xa56 <FUNCProgramAVR+0x22a>
	{						
		if ((ProgMode == 6) || (ProgMode == 0) || (ProgMode == 2)) // Erase chip, or program flash mode
     916:	16 30       	cpi	r17, 0x06	; 6
     918:	21 f0       	breq	.+8      	; 0x922 <FUNCProgramAVR+0xf6>
     91a:	11 23       	and	r17, r17
     91c:	11 f0       	breq	.+4      	; 0x922 <FUNCProgramAVR+0xf6>
     91e:	12 30       	cpi	r17, 0x02	; 2
     920:	91 f4       	brne	.+36     	; 0x946 <FUNCProgramAVR+0x11a>
		{
			MAIN_ShowProgType('C');
     922:	83 e4       	ldi	r24, 0x43	; 67
     924:	0e 94 33 03 	call	0x666 <MAIN_ShowProgType>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     928:	a4 e1       	ldi	r26, 0x14	; 20
     92a:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     92c:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
     930:	80 2d       	mov	r24, r0
     932:	81 30       	cpi	r24, 0x01	; 1
     934:	31 f0       	breq	.+12     	; 0x942 <FUNCProgramAVR+0x116>
			
			if (!(eeprom_read_byte(&EEPROMVars.EraseCmdStored) == TRUE))
			{
				Fault = ISPCC_FAULT_NOERASE;
     936:	02 e0       	ldi	r16, 0x02	; 2
				MAIN_ShowError(PSTR("NO ERASE CMD"));
     938:	8b e4       	ldi	r24, 0x4B	; 75
     93a:	92 e0       	ldi	r25, 0x02	; 2
     93c:	0e 94 55 03 	call	0x6aa <MAIN_ShowError>
     940:	02 c0       	rjmp	.+4      	; 0x946 <FUNCProgramAVR+0x11a>
			}
			else
			{
				PM_SendEraseCommand();
     942:	0e 94 6c 16 	call	0x2cd8 <PM_SendEraseCommand>
			}
		}

		if (((ProgMode == 0) || (ProgMode == 2)) && (Fault == ISPCC_NO_FAULT)) // Program flash
     946:	11 23       	and	r17, r17
     948:	11 f0       	breq	.+4      	; 0x94e <FUNCProgramAVR+0x122>
     94a:	12 30       	cpi	r17, 0x02	; 2
     94c:	b9 f4       	brne	.+46     	; 0x97c <FUNCProgramAVR+0x150>
     94e:	00 23       	and	r16, r16
     950:	a9 f4       	brne	.+42     	; 0x97c <FUNCProgramAVR+0x150>
		{
			MAIN_ShowProgType('D');
     952:	84 e4       	ldi	r24, 0x44	; 68
     954:	0e 94 33 03 	call	0x666 <MAIN_ShowProgType>

			if (!(PM_GetStoredDataSize(TYPE_FLASH))) // Check to make sure a program is present in memory
     958:	81 e0       	ldi	r24, 0x01	; 1
     95a:	0e 94 d4 12 	call	0x25a8 <PM_GetStoredDataSize>
     95e:	dc 01       	movw	r26, r24
     960:	cb 01       	movw	r24, r22
     962:	00 97       	sbiw	r24, 0x00	; 0
     964:	a1 05       	cpc	r26, r1
     966:	b1 05       	cpc	r27, r1
     968:	31 f4       	brne	.+12     	; 0x976 <FUNCProgramAVR+0x14a>
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
     96a:	03 e0       	ldi	r16, 0x03	; 3
				MAIN_ShowError(PSTR("NO DATA"));
     96c:	88 e5       	ldi	r24, 0x58	; 88
     96e:	92 e0       	ldi	r25, 0x02	; 2
     970:	0e 94 55 03 	call	0x6aa <MAIN_ShowError>
     974:	03 c0       	rjmp	.+6      	; 0x97c <FUNCProgramAVR+0x150>
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_FLASH);
     976:	81 e0       	ldi	r24, 0x01	; 1
     978:	0e 94 9b 16 	call	0x2d36 <PM_CreateProgrammingPackets>
			}
		}
	
		if ((ProgMode == 1) || (ProgMode == 2)) // Program EEPROM
     97c:	81 2f       	mov	r24, r17
     97e:	81 50       	subi	r24, 0x01	; 1
     980:	82 30       	cpi	r24, 0x02	; 2
     982:	a8 f4       	brcc	.+42     	; 0x9ae <FUNCProgramAVR+0x182>
		{
			MAIN_ShowProgType('E');
     984:	85 e4       	ldi	r24, 0x45	; 69
     986:	0e 94 33 03 	call	0x666 <MAIN_ShowProgType>
				
			if (!(PM_GetStoredDataSize(TYPE_EEPROM))) // Check to make sure EEPROM data is present in memory
     98a:	80 e0       	ldi	r24, 0x00	; 0
     98c:	0e 94 d4 12 	call	0x25a8 <PM_GetStoredDataSize>
     990:	dc 01       	movw	r26, r24
     992:	cb 01       	movw	r24, r22
     994:	00 97       	sbiw	r24, 0x00	; 0
     996:	a1 05       	cpc	r26, r1
     998:	b1 05       	cpc	r27, r1
     99a:	31 f4       	brne	.+12     	; 0x9a8 <FUNCProgramAVR+0x17c>
			{
				Fault = ISPCC_FAULT_NODATATYPE;
     99c:	03 e0       	ldi	r16, 0x03	; 3
				MAIN_ShowError(PSTR("NO EEPROM"));
     99e:	80 e6       	ldi	r24, 0x60	; 96
     9a0:	92 e0       	ldi	r25, 0x02	; 2
     9a2:	0e 94 55 03 	call	0x6aa <MAIN_ShowError>
     9a6:	03 c0       	rjmp	.+6      	; 0x9ae <FUNCProgramAVR+0x182>
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_EEPROM);
     9a8:	80 e0       	ldi	r24, 0x00	; 0
     9aa:	0e 94 9b 16 	call	0x2d36 <PM_CreateProgrammingPackets>
			}
		}

		if ((ProgMode == 3) || (ProgMode == 5)) // Program Fuse bytes
     9ae:	13 30       	cpi	r17, 0x03	; 3
     9b0:	11 f0       	breq	.+4      	; 0x9b6 <FUNCProgramAVR+0x18a>
     9b2:	15 30       	cpi	r17, 0x05	; 5
     9b4:	99 f4       	brne	.+38     	; 0x9dc <FUNCProgramAVR+0x1b0>
		{
			MAIN_ShowProgType('F');
     9b6:	86 e4       	ldi	r24, 0x46	; 70
     9b8:	0e 94 33 03 	call	0x666 <MAIN_ShowProgType>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     9bc:	af e2       	ldi	r26, 0x2F	; 47
     9be:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     9c0:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
     9c4:	80 2d       	mov	r24, r0
     9c6:	88 23       	and	r24, r24
     9c8:	31 f4       	brne	.+12     	; 0x9d6 <FUNCProgramAVR+0x1aa>
			
			if (!(eeprom_read_byte(&EEPROMVars.TotalFuseBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
     9ca:	03 e0       	ldi	r16, 0x03	; 3
				MAIN_ShowError(PSTR("NO FUSE BYTES"));
     9cc:	8a e6       	ldi	r24, 0x6A	; 106
     9ce:	92 e0       	ldi	r25, 0x02	; 2
     9d0:	0e 94 55 03 	call	0x6aa <MAIN_ShowError>
     9d4:	03 c0       	rjmp	.+6      	; 0x9dc <FUNCProgramAVR+0x1b0>
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_FUSE);
     9d6:	82 e0       	ldi	r24, 0x02	; 2
     9d8:	0e 94 3b 16 	call	0x2c76 <PM_SendFuseLockBytes>
			}
		}

		if ((ProgMode == 4) || (ProgMode == 5)) // Program Lock bytes
     9dc:	81 2f       	mov	r24, r17
     9de:	84 50       	subi	r24, 0x04	; 4
     9e0:	82 30       	cpi	r24, 0x02	; 2
     9e2:	00 f5       	brcc	.+64     	; 0xa24 <FUNCProgramAVR+0x1f8>
		{
			if (ProgMode == 5)                    // If fusebytes have already been written, we need to reenter programming mode to latch them
     9e4:	15 30       	cpi	r17, 0x05	; 5
     9e6:	59 f4       	brne	.+22     	; 0x9fe <FUNCProgramAVR+0x1d2>
			{
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line of the slave AVR
     9e8:	81 e0       	ldi	r24, 0x01	; 1
     9ea:	0e 94 ff 02 	call	0x5fe <MAIN_ResetCSLine>
				MAIN_Delay10MS(1);
     9ee:	81 e0       	ldi	r24, 0x01	; 1
     9f0:	0e 94 17 02 	call	0x42e <MAIN_Delay10MS>
				MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE); // Capture the RESET line of the slave AVR
     9f4:	80 e0       	ldi	r24, 0x00	; 0
     9f6:	0e 94 ff 02 	call	0x5fe <MAIN_ResetCSLine>
				ISPCC_EnterChipProgrammingMode(); // Try to sync with the slave AVR
     9fa:	0e 94 d4 0f 	call	0x1fa8 <ISPCC_EnterChipProgrammingMode>
			}

			MAIN_ShowProgType('L');
     9fe:	8c e4       	ldi	r24, 0x4C	; 76
     a00:	0e 94 33 03 	call	0x666 <MAIN_ShowProgType>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     a04:	a0 e3       	ldi	r26, 0x30	; 48
     a06:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     a08:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
     a0c:	80 2d       	mov	r24, r0
     a0e:	88 23       	and	r24, r24
     a10:	31 f4       	brne	.+12     	; 0xa1e <FUNCProgramAVR+0x1f2>
		
			if (!(eeprom_read_byte(&EEPROMVars.TotalLockBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;
     a12:	03 e0       	ldi	r16, 0x03	; 3
				MAIN_ShowError(PSTR("NO LOCK BYTES"));
     a14:	88 e7       	ldi	r24, 0x78	; 120
     a16:	92 e0       	ldi	r25, 0x02	; 2
     a18:	0e 94 55 03 	call	0x6aa <MAIN_ShowError>
     a1c:	03 c0       	rjmp	.+6      	; 0xa24 <FUNCProgramAVR+0x1f8>
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_LOCK);
     a1e:	83 e0       	ldi	r24, 0x03	; 3
     a20:	0e 94 3b 16 	call	0x2c76 <PM_SendFuseLockBytes>
			}
		}

		strcpy_P(DoneFailMessageBuff, PSTR("PROGRAMMING DONE"));
     a24:	66 e8       	ldi	r22, 0x86	; 134
     a26:	72 e0       	ldi	r23, 0x02	; 2
     a28:	ce 01       	movw	r24, r28
     a2a:	01 96       	adiw	r24, 0x01	; 1
     a2c:	0e 94 10 19 	call	0x3220 <strcpy_P>

		if (Fault != ISPCC_NO_FAULT)         // Takes less code to just overwrite part of the string on fail
     a30:	00 23       	and	r16, r16
     a32:	31 f0       	breq	.+12     	; 0xa40 <FUNCProgramAVR+0x214>
		  strcpy_P(&DoneFailMessageBuff[12], PSTR("FAILED"));
     a34:	67 e9       	ldi	r22, 0x97	; 151
     a36:	72 e0       	ldi	r23, 0x02	; 2
     a38:	ce 01       	movw	r24, r28
     a3a:	0d 96       	adiw	r24, 0x0d	; 13
     a3c:	0e 94 10 19 	call	0x3220 <strcpy_P>

		LCD_puts(DoneFailMessageBuff);
     a40:	ce 01       	movw	r24, r28
     a42:	01 96       	adiw	r24, 0x01	; 1
     a44:	0e 94 50 07 	call	0xea0 <LCD_puts>

		MAIN_Delay10MS(255);
     a48:	8f ef       	ldi	r24, 0xFF	; 255
     a4a:	0e 94 17 02 	call	0x42e <MAIN_Delay10MS>
		MAIN_Delay10MS(100);
     a4e:	84 e6       	ldi	r24, 0x64	; 100
     a50:	0e 94 17 02 	call	0x42e <MAIN_Delay10MS>
     a54:	04 c0       	rjmp	.+8      	; 0xa5e <FUNCProgramAVR+0x232>
	}
	else
	{
		MAIN_ShowError(SyncErrorMessage);
     a56:	89 eb       	ldi	r24, 0xB9	; 185
     a58:	93 e0       	ldi	r25, 0x03	; 3
     a5a:	0e 94 55 03 	call	0x6aa <MAIN_ShowError>
	}
	
	MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run	
     a5e:	81 e0       	ldi	r24, 0x01	; 1
     a60:	0e 94 ff 02 	call	0x5fe <MAIN_ResetCSLine>
	USI_SPIOff();
     a64:	0e 94 e4 08 	call	0x11c8 <USI_SPIOff>
	DF_EnableDataflash(FALSE);
     a68:	80 e0       	ldi	r24, 0x00	; 0
     a6a:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
	SPI_SPIOFF();
     a6e:	80 91 64 00 	lds	r24, 0x0064
     a72:	84 60       	ori	r24, 0x04	; 4
     a74:	80 93 64 00 	sts	0x0064, r24
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Green = ready
     a78:	81 b3       	in	r24, 0x11	; 17
     a7a:	8f 7c       	andi	r24, 0xCF	; 207
     a7c:	80 61       	ori	r24, 0x10	; 16
     a7e:	81 bb       	out	0x11, r24	; 17
     a80:	63 96       	adiw	r28, 0x13	; 19
     a82:	0f b6       	in	r0, 0x3f	; 63
     a84:	f8 94       	cli
     a86:	de bf       	out	0x3e, r29	; 62
     a88:	0f be       	out	0x3f, r0	; 63
     a8a:	cd bf       	out	0x3d, r28	; 61
     a8c:	df 91       	pop	r29
     a8e:	cf 91       	pop	r28
     a90:	1f 91       	pop	r17
     a92:	0f 91       	pop	r16
     a94:	08 95       	ret

00000a96 <FUNCStoreProgram>:
}

void FUNCStoreProgram(void)
{
	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
     a96:	89 e8       	ldi	r24, 0x89	; 137
     a98:	98 e0       	ldi	r25, 0x08	; 8
     a9a:	90 93 01 01 	sts	0x0101, r25
     a9e:	80 93 00 01 	sts	0x0100, r24
	SPI_SPIInit();
     aa2:	0e 94 7f 08 	call	0x10fe <SPI_SPIInit>
	UseExernalDF = FALSE;
     aa6:	10 92 61 02 	sts	0x0261, r1
	DF_EnableDataflash(TRUE);
     aaa:	81 e0       	ldi	r24, 0x01	; 1
     aac:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>

	if (!(DF_CheckCorrectOnboardChip()))
     ab0:	0e 94 9a 0a 	call	0x1534 <DF_CheckCorrectOnboardChip>
     ab4:	88 23       	and	r24, r24
     ab6:	01 f1       	breq	.+64     	; 0xaf8 <FUNCStoreProgram+0x62>
	  return;
			
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
     ab8:	80 e1       	ldi	r24, 0x10	; 16
     aba:	92 e0       	ldi	r25, 0x02	; 2
     abc:	0e 94 91 07 	call	0xf22 <LCD_puts_f>
     ac0:	0e 94 b8 06 	call	0xd70 <OSCCAL_Calibrate>
     ac4:	80 91 c1 00 	lds	r24, 0x00C1
     ac8:	80 78       	andi	r24, 0x80	; 128
     aca:	88 61       	ori	r24, 0x18	; 24
     acc:	80 93 c1 00 	sts	0x00C1, r24

	LCD_puts_f(PSTR("*STORAGE MODE*"));
     ad0:	8e e9       	ldi	r24, 0x9E	; 158
     ad2:	92 e0       	ldi	r25, 0x02	; 2
     ad4:	0e 94 91 07 	call	0xf22 <LCD_puts_f>

	InterpretPacketRoutine = (FuncPtr)PM_InterpretAVRISPPacket;
     ad8:	8e ee       	ldi	r24, 0xEE	; 238
     ada:	93 e1       	ldi	r25, 0x13	; 19
     adc:	90 93 03 01 	sts	0x0103, r25
     ae0:	80 93 02 01 	sts	0x0102, r24
	V2P_RunStateMachine();
     ae4:	0e 94 7a 0e 	call	0x1cf4 <V2P_RunStateMachine>
	DF_EnableDataflash(FALSE);
     ae8:	80 e0       	ldi	r24, 0x00	; 0
     aea:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
	SPI_SPIOFF();
     aee:	80 91 64 00 	lds	r24, 0x0064
     af2:	84 60       	ori	r24, 0x04	; 4
     af4:	80 93 64 00 	sts	0x0064, r24
     af8:	08 95       	ret

00000afa <FUNCClearMem>:
}

void FUNCClearMem(void)
{
     afa:	cf 93       	push	r28
     afc:	df 93       	push	r29
	LCD_puts_f(PSTR("CONFIRM"));
     afe:	8d ea       	ldi	r24, 0xAD	; 173
     b00:	92 e0       	ldi	r25, 0x02	; 2
     b02:	0e 94 91 07 	call	0xf22 <LCD_puts_f>
	MAIN_Delay10MS(180);
     b06:	84 eb       	ldi	r24, 0xB4	; 180
     b08:	0e 94 17 02 	call	0x42e <MAIN_Delay10MS>

	LCD_puts_f(PSTR("<N Y>"));
     b0c:	85 eb       	ldi	r24, 0xB5	; 181
     b0e:	92 e0       	ldi	r25, 0x02	; 2
     b10:	0e 94 91 07 	call	0xf22 <LCD_puts_f>

	while (1)
	{
		if (JoyStatus)
     b14:	8e b3       	in	r24, 0x1e	; 30
     b16:	88 23       	and	r24, r24
     b18:	e9 f3       	breq	.-6      	; 0xb14 <FUNCClearMem+0x1a>
		{
			if (JoyStatus & JOY_LEFT)
     b1a:	8e b3       	in	r24, 0x1e	; 30
     b1c:	99 27       	eor	r25, r25
     b1e:	ec 01       	movw	r28, r24
     b20:	c4 70       	andi	r28, 0x04	; 4
     b22:	d0 70       	andi	r29, 0x00	; 0
     b24:	82 fd       	sbrc	r24, 2
     b26:	1a c0       	rjmp	.+52     	; 0xb5c <FUNCClearMem+0x62>
			  return;
			else if (JoyStatus & JOY_RIGHT)
     b28:	f3 9b       	sbis	0x1e, 3	; 30
     b2a:	f4 cf       	rjmp	.-24     	; 0xb14 <FUNCClearMem+0x1a>
			  break;
		}
	}

	MAIN_WaitForJoyRelease();
     b2c:	0e 94 29 02 	call	0x452 <MAIN_WaitForJoyRelease>

	LCD_puts_f(WaitText);
     b30:	80 e1       	ldi	r24, 0x10	; 16
     b32:	92 e0       	ldi	r25, 0x02	; 2
     b34:	0e 94 91 07 	call	0xf22 <LCD_puts_f>

	for (uint16_t EAddr = 0; EAddr < 512; EAddr++)
     b38:	ce 01       	movw	r24, r28
     b3a:	2f ef       	ldi	r18, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     b3c:	dc 01       	movw	r26, r24
     b3e:	02 2e       	mov	r0, r18
     b40:	0e 94 7d 19 	call	0x32fa <__eeprom_write_byte_1F2021>
     b44:	01 96       	adiw	r24, 0x01	; 1
     b46:	32 e0       	ldi	r19, 0x02	; 2
     b48:	80 30       	cpi	r24, 0x00	; 0
     b4a:	93 07       	cpc	r25, r19
     b4c:	b8 f3       	brcs	.-18     	; 0xb3c <FUNCClearMem+0x42>
	  eeprom_write_byte((uint8_t*)EAddr, 0xFF);

	LCD_puts_f(PSTR("MEM CLEARED"));
     b4e:	8b eb       	ldi	r24, 0xBB	; 187
     b50:	92 e0       	ldi	r25, 0x02	; 2
     b52:	0e 94 91 07 	call	0xf22 <LCD_puts_f>
	MAIN_Delay10MS(255);
     b56:	8f ef       	ldi	r24, 0xFF	; 255
     b58:	0e 94 17 02 	call	0x42e <MAIN_Delay10MS>
     b5c:	df 91       	pop	r29
     b5e:	cf 91       	pop	r28
     b60:	08 95       	ret

00000b62 <FUNCSetContrast>:
}

void FUNCSetContrast(void)
{
     b62:	ef 92       	push	r14
     b64:	ff 92       	push	r15
     b66:	1f 93       	push	r17
     b68:	cf 93       	push	r28
     b6a:	df 93       	push	r29
     b6c:	cd b7       	in	r28, 0x3d	; 61
     b6e:	de b7       	in	r29, 0x3e	; 62
     b70:	26 97       	sbiw	r28, 0x06	; 6
     b72:	0f b6       	in	r0, 0x3f	; 63
     b74:	f8 94       	cli
     b76:	de bf       	out	0x3e, r29	; 62
     b78:	0f be       	out	0x3f, r0	; 63
     b7a:	cd bf       	out	0x3d, r28	; 61
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     b7c:	85 e8       	ldi	r24, 0x85	; 133
     b7e:	e8 2e       	mov	r14, r24
     b80:	80 e0       	ldi	r24, 0x00	; 0
     b82:	f8 2e       	mov	r15, r24
  uint8_t result;
  asm volatile
     b84:	d7 01       	movw	r26, r14
     b86:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
     b8a:	80 2d       	mov	r24, r0
     b8c:	18 2f       	mov	r17, r24
     b8e:	1f 70       	andi	r17, 0x0F	; 15
	uint8_t Buffer[6];
	uint8_t Contrast = (eeprom_read_byte(&EEPROMVars.LCDContrast) & 0x0F); // Ranges from 0-15 so mask retuns 15 on blank EEPROM (0xFF)
	
	JoyStatus = 1;                          // Invalid value to force the LCD to update
     b90:	81 e0       	ldi	r24, 0x01	; 1
     b92:	8e bb       	out	0x1e, r24	; 30
	
	while (1)
	{
		if (JoyStatus)
     b94:	8e b3       	in	r24, 0x1e	; 30
     b96:	88 23       	and	r24, r24
     b98:	e9 f3       	breq	.-6      	; 0xb94 <FUNCSetContrast+0x32>
		{
			if (JoyStatus & JOY_UP)
     b9a:	f6 9b       	sbis	0x1e, 6	; 30
     b9c:	04 c0       	rjmp	.+8      	; 0xba6 <FUNCSetContrast+0x44>
			{
				if (Contrast < 15)
     b9e:	1f 30       	cpi	r17, 0x0F	; 15
     ba0:	78 f4       	brcc	.+30     	; 0xbc0 <FUNCSetContrast+0x5e>
				  Contrast++;
     ba2:	1f 5f       	subi	r17, 0xFF	; 255
     ba4:	0d c0       	rjmp	.+26     	; 0xbc0 <FUNCSetContrast+0x5e>
			}
			else if (JoyStatus & JOY_DOWN)
     ba6:	f7 9b       	sbis	0x1e, 7	; 30
     ba8:	04 c0       	rjmp	.+8      	; 0xbb2 <FUNCSetContrast+0x50>
			{
				if (Contrast > 1)          // Zero is non-visible, so 1 is the minimum
     baa:	12 30       	cpi	r17, 0x02	; 2
     bac:	48 f0       	brcs	.+18     	; 0xbc0 <FUNCSetContrast+0x5e>
				  Contrast--;
     bae:	11 50       	subi	r17, 0x01	; 1
     bb0:	07 c0       	rjmp	.+14     	; 0xbc0 <FUNCSetContrast+0x5e>
			}
			else if (JoyStatus & JOY_LEFT)
     bb2:	f2 9b       	sbis	0x1e, 2	; 30
     bb4:	05 c0       	rjmp	.+10     	; 0xbc0 <FUNCSetContrast+0x5e>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     bb6:	d7 01       	movw	r26, r14
     bb8:	01 2e       	mov	r0, r17
     bba:	0e 94 7d 19 	call	0x32fa <__eeprom_write_byte_1F2021>
			{
				eeprom_write_byte(&EEPROMVars.LCDContrast, Contrast);
				return;
     bbe:	18 c0       	rjmp	.+48     	; 0xbf0 <FUNCSetContrast+0x8e>
			}
					
			Buffer[0] = 'C';
     bc0:	83 e4       	ldi	r24, 0x43	; 67
     bc2:	89 83       	std	Y+1, r24	; 0x01
			Buffer[1] = 'T';
     bc4:	84 e5       	ldi	r24, 0x54	; 84
     bc6:	8a 83       	std	Y+2, r24	; 0x02
			Buffer[2] = ' ';
     bc8:	80 e2       	ldi	r24, 0x20	; 32
     bca:	8b 83       	std	Y+3, r24	; 0x03

			MAIN_IntToStr((uint16_t)Contrast, &Buffer[3]);
     bcc:	be 01       	movw	r22, r28
     bce:	6c 5f       	subi	r22, 0xFC	; 252
     bd0:	7f 4f       	sbci	r23, 0xFF	; 255
     bd2:	81 2f       	mov	r24, r17
     bd4:	99 27       	eor	r25, r25
     bd6:	0e 94 1b 03 	call	0x636 <MAIN_IntToStr>
			LCD_puts(Buffer);
     bda:	ce 01       	movw	r24, r28
     bdc:	01 96       	adiw	r24, 0x01	; 1
     bde:	0e 94 50 07 	call	0xea0 <LCD_puts>

			LCD_CONTRAST_LEVEL(Contrast);
     be2:	81 2f       	mov	r24, r17
     be4:	8f 70       	andi	r24, 0x0F	; 15
     be6:	80 93 e7 00 	sts	0x00E7, r24

			MAIN_WaitForJoyRelease();
     bea:	0e 94 29 02 	call	0x452 <MAIN_WaitForJoyRelease>
     bee:	d2 cf       	rjmp	.-92     	; 0xb94 <FUNCSetContrast+0x32>
     bf0:	26 96       	adiw	r28, 0x06	; 6
     bf2:	0f b6       	in	r0, 0x3f	; 63
     bf4:	f8 94       	cli
     bf6:	de bf       	out	0x3e, r29	; 62
     bf8:	0f be       	out	0x3f, r0	; 63
     bfa:	cd bf       	out	0x3d, r28	; 61
     bfc:	df 91       	pop	r29
     bfe:	cf 91       	pop	r28
     c00:	1f 91       	pop	r17
     c02:	ff 90       	pop	r15
     c04:	ef 90       	pop	r14
     c06:	08 95       	ret

00000c08 <FUNCSetISPSpeed>:
		}
	}
}

void FUNCSetISPSpeed(void)
{
     c08:	0f 93       	push	r16
     c0a:	1f 93       	push	r17
     c0c:	cf 93       	push	r28
	JoyStatus = 1;                         // Invalid value to force the LCD to update
     c0e:	81 e0       	ldi	r24, 0x01	; 1
     c10:	8e bb       	out	0x1e, r24	; 30
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     c12:	01 e0       	ldi	r16, 0x01	; 1
     c14:	10 e0       	ldi	r17, 0x00	; 0
  uint8_t result;
  asm volatile
     c16:	d8 01       	movw	r26, r16
     c18:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
     c1c:	80 2d       	mov	r24, r0
     c1e:	c8 2f       	mov	r28, r24

	uint8_t CurrSpeed = eeprom_read_byte(&EEPROMVars.SCKDuration);

	if (CurrSpeed > (USI_PRESET_SPEEDS - 1)) CurrSpeed = 0; // Protection against blank EEPROM
     c20:	84 30       	cpi	r24, 0x04	; 4
     c22:	08 f0       	brcs	.+2      	; 0xc26 <FUNCSetISPSpeed+0x1e>
     c24:	c0 e0       	ldi	r28, 0x00	; 0

	while (1)
	{
		if (JoyStatus)
     c26:	8e b3       	in	r24, 0x1e	; 30
     c28:	88 23       	and	r24, r24
     c2a:	e9 f3       	breq	.-6      	; 0xc26 <FUNCSetISPSpeed+0x1e>
		{
			if (JoyStatus & JOY_UP)
     c2c:	f6 9b       	sbis	0x1e, 6	; 30
     c2e:	06 c0       	rjmp	.+12     	; 0xc3c <FUNCSetISPSpeed+0x34>
			{
				(CurrSpeed == 0)? CurrSpeed = (USI_PRESET_SPEEDS - 1) : CurrSpeed--;
     c30:	cc 23       	and	r28, r28
     c32:	11 f4       	brne	.+4      	; 0xc38 <FUNCSetISPSpeed+0x30>
     c34:	c3 e0       	ldi	r28, 0x03	; 3
     c36:	11 c0       	rjmp	.+34     	; 0xc5a <FUNCSetISPSpeed+0x52>
     c38:	c1 50       	subi	r28, 0x01	; 1
     c3a:	0f c0       	rjmp	.+30     	; 0xc5a <FUNCSetISPSpeed+0x52>
			}
			else if (JoyStatus & JOY_DOWN)
     c3c:	f7 9b       	sbis	0x1e, 7	; 30
     c3e:	06 c0       	rjmp	.+12     	; 0xc4c <FUNCSetISPSpeed+0x44>
			{
				(CurrSpeed == (USI_PRESET_SPEEDS - 1))? CurrSpeed = 0 : CurrSpeed++;
     c40:	c3 30       	cpi	r28, 0x03	; 3
     c42:	11 f4       	brne	.+4      	; 0xc48 <FUNCSetISPSpeed+0x40>
     c44:	c0 e0       	ldi	r28, 0x00	; 0
     c46:	09 c0       	rjmp	.+18     	; 0xc5a <FUNCSetISPSpeed+0x52>
     c48:	cf 5f       	subi	r28, 0xFF	; 255
     c4a:	07 c0       	rjmp	.+14     	; 0xc5a <FUNCSetISPSpeed+0x52>
			}
			else if (JoyStatus & JOY_LEFT)
     c4c:	f2 9b       	sbis	0x1e, 2	; 30
     c4e:	05 c0       	rjmp	.+10     	; 0xc5a <FUNCSetISPSpeed+0x52>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     c50:	d8 01       	movw	r26, r16
     c52:	0c 2e       	mov	r0, r28
     c54:	0e 94 7d 19 	call	0x32fa <__eeprom_write_byte_1F2021>
			{
				eeprom_write_byte(&EEPROMVars.SCKDuration, CurrSpeed);
				return;
     c58:	0d c0       	rjmp	.+26     	; 0xc74 <FUNCSetISPSpeed+0x6c>
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&USIPSNamePtrs[CurrSpeed]));
     c5a:	ec 2f       	mov	r30, r28
     c5c:	ff 27       	eor	r31, r31
     c5e:	ee 0f       	add	r30, r30
     c60:	ff 1f       	adc	r31, r31
     c62:	e3 58       	subi	r30, 0x83	; 131
     c64:	ff 4f       	sbci	r31, 0xFF	; 255
     c66:	85 91       	lpm	r24, Z+
     c68:	94 91       	lpm	r25, Z
     c6a:	0e 94 91 07 	call	0xf22 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     c6e:	0e 94 29 02 	call	0x452 <MAIN_WaitForJoyRelease>
     c72:	d9 cf       	rjmp	.-78     	; 0xc26 <FUNCSetISPSpeed+0x1e>
     c74:	cf 91       	pop	r28
     c76:	1f 91       	pop	r17
     c78:	0f 91       	pop	r16
     c7a:	08 95       	ret

00000c7c <FUNCSleepMode>:
		}
	}
}

void FUNCSleepMode(void)
{
	SMCR    = ((1 << SM1) | (1 << SE));   // Power down sleep mode
     c7c:	85 e0       	ldi	r24, 0x05	; 5
     c7e:	83 bf       	out	0x33, r24	; 51
	LCDCRA &= ~(1 << LCDEN); 
     c80:	80 91 e4 00 	lds	r24, 0x00E4
     c84:	8f 77       	andi	r24, 0x7F	; 127
     c86:	80 93 e4 00 	sts	0x00E4, r24
	
	while (!(JoyStatus & JOY_UP))        // Joystick interrupt wakes the micro
	  SLEEP();
     c8a:	f6 99       	sbic	0x1e, 6	; 30
     c8c:	03 c0       	rjmp	.+6      	; 0xc94 <FUNCSleepMode+0x18>
     c8e:	88 95       	sleep
     c90:	f6 9b       	sbis	0x1e, 6	; 30
     c92:	fd cf       	rjmp	.-6      	; 0xc8e <FUNCSleepMode+0x12>
	   
	LCDCRA |= (1 << LCDEN);
     c94:	80 91 e4 00 	lds	r24, 0x00E4
     c98:	80 68       	ori	r24, 0x80	; 128
     c9a:	80 93 e4 00 	sts	0x00E4, r24
	
	MAIN_WaitForJoyRelease();
     c9e:	0e 94 29 02 	call	0x452 <MAIN_WaitForJoyRelease>
     ca2:	08 95       	ret

00000ca4 <FUNCStorageInfo>:
}

void FUNCStorageInfo(void)
{
     ca4:	1f 93       	push	r17
     ca6:	cf 93       	push	r28
	uint8_t SelectedItem = 0;
     ca8:	10 e0       	ldi	r17, 0x00	; 0

	MAIN_WaitForJoyRelease();
     caa:	0e 94 29 02 	call	0x452 <MAIN_WaitForJoyRelease>

	JoyStatus = 1;                         // Invalid value to force the LCD to update
     cae:	81 e0       	ldi	r24, 0x01	; 1
     cb0:	8e bb       	out	0x1e, r24	; 30

	while (1)
	{
		if (JoyStatus)
     cb2:	8e b3       	in	r24, 0x1e	; 30
     cb4:	88 23       	and	r24, r24
     cb6:	e9 f3       	breq	.-6      	; 0xcb2 <FUNCStorageInfo+0xe>
		{
			if (JoyStatus & (JOY_UP | JOY_DOWN))
     cb8:	ce b3       	in	r28, 0x1e	; 30
     cba:	c0 7c       	andi	r28, 0xC0	; 192
     cbc:	19 f0       	breq	.+6      	; 0xcc4 <FUNCStorageInfo+0x20>
			{
				SelectedItem ^= 1;
     cbe:	81 e0       	ldi	r24, 0x01	; 1
     cc0:	18 27       	eor	r17, r24
     cc2:	38 c0       	rjmp	.+112    	; 0xd34 <FUNCStorageInfo+0x90>
			}
			else if (JoyStatus & JOY_LEFT)
     cc4:	f2 99       	sbic	0x1e, 2	; 30
     cc6:	43 c0       	rjmp	.+134    	; 0xd4e <FUNCStorageInfo+0xaa>
			{
				return;
			}
			else if (JoyStatus & JOY_PRESS)
     cc8:	f4 9b       	sbis	0x1e, 4	; 30
     cca:	34 c0       	rjmp	.+104    	; 0xd34 <FUNCStorageInfo+0x90>
			{
				if (SelectedItem == 1)    // View storage tags
     ccc:	11 30       	cpi	r17, 0x01	; 1
     cce:	81 f5       	brne	.+96     	; 0xd30 <FUNCStorageInfo+0x8c>
				{
					DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
     cd0:	89 e8       	ldi	r24, 0x89	; 137
     cd2:	98 e0       	ldi	r25, 0x08	; 8
     cd4:	90 93 01 01 	sts	0x0101, r25
     cd8:	80 93 00 01 	sts	0x0100, r24
					SPI_SPIInit();
     cdc:	0e 94 7f 08 	call	0x10fe <SPI_SPIInit>
					UseExernalDF = FALSE;
     ce0:	c0 93 61 02 	sts	0x0261, r28
					DF_EnableDataflash(TRUE);
     ce4:	81 2f       	mov	r24, r17
     ce6:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>

					if (DF_CheckCorrectOnboardChip())
     cea:	0e 94 9a 0a 	call	0x1534 <DF_CheckCorrectOnboardChip>
     cee:	c8 2f       	mov	r28, r24
     cf0:	88 23       	and	r24, r24
     cf2:	41 f0       	breq	.+16     	; 0xd04 <FUNCStorageInfo+0x60>
					{
						TM_ShowTags();
     cf4:	0e 94 e2 18 	call	0x31c4 <TM_ShowTags>
						SPI_SPIOFF();
     cf8:	80 91 64 00 	lds	r24, 0x0064
     cfc:	84 60       	ori	r24, 0x04	; 4
     cfe:	80 93 64 00 	sts	0x0064, r24
     d02:	18 c0       	rjmp	.+48     	; 0xd34 <FUNCStorageInfo+0x90>
					}
					else if (!(PM_GetStoredDataSize(TYPE_FLASH)))
     d04:	81 2f       	mov	r24, r17
     d06:	0e 94 d4 12 	call	0x25a8 <PM_GetStoredDataSize>
     d0a:	dc 01       	movw	r26, r24
     d0c:	cb 01       	movw	r24, r22
     d0e:	00 97       	sbiw	r24, 0x00	; 0
     d10:	a1 05       	cpc	r26, r1
     d12:	b1 05       	cpc	r27, r1
     d14:	79 f4       	brne	.+30     	; 0xd34 <FUNCStorageInfo+0x90>
					{
						DF_EnableDataflash(FALSE);
     d16:	8c 2f       	mov	r24, r28
     d18:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
						SPI_SPIOFF();
     d1c:	80 91 64 00 	lds	r24, 0x0064
     d20:	84 60       	ori	r24, 0x04	; 4
     d22:	80 93 64 00 	sts	0x0064, r24

						MAIN_ShowError(PSTR("NO STORED PRGM"));
     d26:	87 ec       	ldi	r24, 0xC7	; 199
     d28:	92 e0       	ldi	r25, 0x02	; 2
     d2a:	0e 94 55 03 	call	0x6aa <MAIN_ShowError>
     d2e:	02 c0       	rjmp	.+4      	; 0xd34 <FUNCStorageInfo+0x90>
					}	
				}
				else                  // View stored data sizes
				{
					PM_ShowStoredItemSizes();
     d30:	0e 94 bd 17 	call	0x2f7a <PM_ShowStoredItemSizes>
				}
			}
			
			LCD_puts_f((uint8_t*)pgm_read_word(&SIFOOptionPtrs[SelectedItem]));
     d34:	e1 2f       	mov	r30, r17
     d36:	ff 27       	eor	r31, r31
     d38:	ee 0f       	add	r30, r30
     d3a:	ff 1f       	adc	r31, r31
     d3c:	e4 5a       	subi	r30, 0xA4	; 164
     d3e:	ff 4f       	sbci	r31, 0xFF	; 255
     d40:	85 91       	lpm	r24, Z+
     d42:	94 91       	lpm	r25, Z
     d44:	0e 94 91 07 	call	0xf22 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     d48:	0e 94 29 02 	call	0x452 <MAIN_WaitForJoyRelease>
     d4c:	b2 cf       	rjmp	.-156    	; 0xcb2 <FUNCStorageInfo+0xe>
     d4e:	cf 91       	pop	r28
     d50:	1f 91       	pop	r17
     d52:	08 95       	ret

00000d54 <FUNCGoBootloader>:
		}
	}
}

void FUNCGoBootloader(void)
{
	uint8_t MD = (MCUCR & ~(1 << JTD)); // Forces compiler to use IN, AND plus two OUTs rather than two lots of IN/AND/OUTs
     d54:	85 b7       	in	r24, 0x35	; 53
     d56:	8f 77       	andi	r24, 0x7F	; 127
	MCUCR = MD;  // Turn on JTAG via code
     d58:	85 bf       	out	0x35, r24	; 53
	MCUCR = MD;  // Twice as specified in datasheet        
     d5a:	85 bf       	out	0x35, r24	; 53
	
	LCD_puts_f(PSTR("*JTAG ON*"));
     d5c:	86 ed       	ldi	r24, 0xD6	; 214
     d5e:	92 e0       	ldi	r25, 0x02	; 2
     d60:	0e 94 91 07 	call	0xf22 <LCD_puts_f>
	
	MAIN_WaitForJoyRelease();
     d64:	0e 94 29 02 	call	0x452 <MAIN_WaitForJoyRelease>
	
	WDTCR = ((1<<WDCE) | (1<<WDE)); // Enable Watchdog Timer to give reset after minimum timeout
     d68:	88 e1       	ldi	r24, 0x18	; 24
     d6a:	80 93 60 00 	sts	0x0060, r24
	while (1) {};                  // Eternal loop - when watchdog resets the AVR it will enter the bootloader
     d6e:	ff cf       	rjmp	.-2      	; 0xd6e <FUNCGoBootloader+0x1a>

00000d70 <OSCCAL_Calibrate>:

static volatile uint16_t ActualCount;

void OSCCAL_Calibrate(void)
{
     d70:	cf 93       	push	r28
     d72:	df 93       	push	r29
	uint8_t SREG_Backup;
	uint8_t LoopCount = (0x7F / 2); // Maximum range is 128, and starts from the middle, so 64 is the max number of iterations required
     d74:	4f e3       	ldi	r20, 0x3F	; 63
	uint8_t PrevOSCALValues[2];
   
	// Reset ActualCount
	ActualCount = 0;
     d76:	10 92 05 01 	sts	0x0105, r1
     d7a:	10 92 04 01 	sts	0x0104, r1
   
	// Make sure all clock division is turned off (8Mhz RC clock)
	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_CLOCKSPEED_8MHZ);
     d7e:	80 e8       	ldi	r24, 0x80	; 128
     d80:	80 93 61 00 	sts	0x0061, r24
     d84:	10 92 61 00 	sts	0x0061, r1

	// Inital OSCCAL of half its maximum for speed
	OSCCAL = (0x7F / 2);
     d88:	40 93 66 00 	sts	0x0066, r20

	// Save the SREG
	SREG_Backup = SREG;
     d8c:	5f b7       	in	r21, 0x3f	; 63
    
	// Disable all timer 1 interrupts
	TIMSK1 = 0;
     d8e:	10 92 6f 00 	sts	0x006F, r1
        
	// Set timer 2 to asyncronous mode (32.768KHz crystal)
	ASSR   = (1 << AS2);
     d92:	88 e0       	ldi	r24, 0x08	; 8
     d94:	80 93 b6 00 	sts	0x00B6, r24
        
	// Timer 2 overflow interrupt enable
	TIMSK2 = (1 << TOIE2);
     d98:	81 e0       	ldi	r24, 0x01	; 1
     d9a:	80 93 70 00 	sts	0x0070, r24

	// Enable interrupts
	sei();
     d9e:	78 94       	sei

	// Start both counters with no prescaling
	TCCR1B = (1 << CS10);
     da0:	80 93 81 00 	sts	0x0081, r24
	TCCR2A = (1 << CS20);
     da4:	80 93 b0 00 	sts	0x00B0, r24
	 	 
	// Previous OSCCAL value of 0
	PrevOSCALValues[0] = 0;
     da8:	20 e0       	ldi	r18, 0x00	; 0
     daa:	30 e0       	ldi	r19, 0x00	; 0

	// Wait until timer 2's external 32.768KHz crystal is stable
	while (ASSR & ((1 << TCN2UB) | (1 << TCR2UB) | (1 << OCR2UB)));
     dac:	80 91 b6 00 	lds	r24, 0x00B6
     db0:	99 27       	eor	r25, r25
     db2:	87 70       	andi	r24, 0x07	; 7
     db4:	90 70       	andi	r25, 0x00	; 0
     db6:	00 97       	sbiw	r24, 0x00	; 0
     db8:	c9 f7       	brne	.-14     	; 0xdac <OSCCAL_Calibrate+0x3c>
    
	// Clear the timer values
	TCNT1  = 0;
     dba:	90 93 85 00 	sts	0x0085, r25
     dbe:	80 93 84 00 	sts	0x0084, r24
	TCNT2  = 0;
     dc2:	10 92 b2 00 	sts	0x00B2, r1
    
	while (LoopCount--)
	{
		// Let it take a few readings (14ms, approx 2 readings)
		_delay_ms(14);

		PrevOSCALValues[1] = PrevOSCALValues[0];
		PrevOSCALValues[0] = OSCCAL;
        
		if (ActualCount > OSCCAL_UPPERCOUNTBOUND)       // Clock is running too fast
			OSCCAL--;
		else if (ActualCount < OSCCAL_LOWERCOUNTBOUND) // Clock is running too slow
			OSCCAL++;
		else		                                     // Clock is just right
			break;
		
		// If the routine cannot find a value withing the count tollerance,
		// it will cause the OSCCAL to hover around the closest two values.
		// If the current value is the same as the 2*n previous, exit the
		// routine as the best value has been found.
		if (OSCCAL == PrevOSCALValues[1])
		  break;
     dc6:	4e e3       	ldi	r20, 0x3E	; 62
     dc8:	ac ec       	ldi	r26, 0xCC	; 204
     dca:	b4 e6       	ldi	r27, 0x64	; 100
     dcc:	c0 e0       	ldi	r28, 0x00	; 0
     dce:	d0 e0       	ldi	r29, 0x00	; 0
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     dd0:	cd 01       	movw	r24, r26
     dd2:	01 97       	sbiw	r24, 0x01	; 1
     dd4:	f1 f7       	brne	.-4      	; 0xdd2 <OSCCAL_Calibrate+0x62>
     dd6:	32 2f       	mov	r19, r18
     dd8:	80 91 66 00 	lds	r24, 0x0066
     ddc:	28 2f       	mov	r18, r24
     dde:	80 91 04 01 	lds	r24, 0x0104
     de2:	90 91 05 01 	lds	r25, 0x0105
     de6:	81 50       	subi	r24, 0x01	; 1
     de8:	91 4e       	sbci	r25, 0xE1	; 225
     dea:	20 f0       	brcs	.+8      	; 0xdf4 <OSCCAL_Calibrate+0x84>
     dec:	80 91 66 00 	lds	r24, 0x0066
     df0:	81 50       	subi	r24, 0x01	; 1
     df2:	0a c0       	rjmp	.+20     	; 0xe08 <OSCCAL_Calibrate+0x98>
     df4:	80 91 04 01 	lds	r24, 0x0104
     df8:	90 91 05 01 	lds	r25, 0x0105
     dfc:	86 5f       	subi	r24, 0xF6	; 246
     dfe:	90 4e       	sbci	r25, 0xE0	; 224
     e00:	58 f4       	brcc	.+22     	; 0xe18 <OSCCAL_Calibrate+0xa8>
     e02:	80 91 66 00 	lds	r24, 0x0066
     e06:	8f 5f       	subi	r24, 0xFF	; 255
     e08:	80 93 66 00 	sts	0x0066, r24
     e0c:	80 91 66 00 	lds	r24, 0x0066
     e10:	83 17       	cp	r24, r19
     e12:	11 f0       	breq	.+4      	; 0xe18 <OSCCAL_Calibrate+0xa8>
     e14:	41 50       	subi	r20, 0x01	; 1
     e16:	e0 f6       	brcc	.-72     	; 0xdd0 <OSCCAL_Calibrate+0x60>
	}

	// Disable all timer interrupts
	TIMSK1 = 0;
     e18:	10 92 6f 00 	sts	0x006F, r1
	TIMSK2 = 0;
     e1c:	10 92 70 00 	sts	0x0070, r1
    
	// Stop the timers
	TCCR1B = 0x00;
     e20:	10 92 81 00 	sts	0x0081, r1
	TCCR2A = 0x00;
     e24:	10 92 b0 00 	sts	0x00B0, r1

	// Turn off timer 2 asynchronous mode
	ASSR  &= ~(1 << AS2);
     e28:	80 91 b6 00 	lds	r24, 0x00B6
     e2c:	87 7f       	andi	r24, 0xF7	; 247
     e2e:	80 93 b6 00 	sts	0x00B6, r24

	// Restore SREG
	SREG = SREG_Backup;
     e32:	5f bf       	out	0x3f, r21	; 63
     e34:	df 91       	pop	r29
     e36:	cf 91       	pop	r28
     e38:	08 95       	ret

00000e3a <__vector_5>:
        
	return;
}

ISR(TIMER2_OVF_vect, ISR_BLOCK) // Occurs 32768/256 timers per second, or 128Hz
{
     e3a:	1f 92       	push	r1
     e3c:	0f 92       	push	r0
     e3e:	0f b6       	in	r0, 0x3f	; 63
     e40:	0f 92       	push	r0
     e42:	11 24       	eor	r1, r1
     e44:	8f 93       	push	r24
     e46:	9f 93       	push	r25
	// Stop timer 1 so it can be read
	TCCR1B = 0x00;
     e48:	10 92 81 00 	sts	0x0081, r1
    
	// Record timer 1's value
	ActualCount = TCNT1;
     e4c:	80 91 84 00 	lds	r24, 0x0084
     e50:	90 91 85 00 	lds	r25, 0x0085
     e54:	90 93 05 01 	sts	0x0105, r25
     e58:	80 93 04 01 	sts	0x0104, r24
	     
	// Reset counters and restart timer 1
	TCNT1  = 0;
     e5c:	10 92 85 00 	sts	0x0085, r1
     e60:	10 92 84 00 	sts	0x0084, r1
	TCNT2  = 0;
     e64:	10 92 b2 00 	sts	0x00B2, r1
	TCCR1B = (1 << CS10);
     e68:	81 e0       	ldi	r24, 0x01	; 1
     e6a:	80 93 81 00 	sts	0x0081, r24
     e6e:	9f 91       	pop	r25
     e70:	8f 91       	pop	r24
     e72:	0f 90       	pop	r0
     e74:	0f be       	out	0x3f, r0	; 63
     e76:	0f 90       	pop	r0
     e78:	1f 90       	pop	r1
     e7a:	18 95       	reti

00000e7c <LCD_Init>:
// ======================================================================================

void LCD_Init(void)
{
	LCDCCR = 0x0F;
     e7c:	8f e0       	ldi	r24, 0x0F	; 15
     e7e:	80 93 e7 00 	sts	0x00E7, r24

    // Select asynchronous clock source, enable all COM pins and enable all segment pins.
    LCDCRB  = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
     e82:	87 eb       	ldi	r24, 0xB7	; 183
     e84:	80 93 e5 00 	sts	0x00E5, r24

    // Set LCD prescaler to give a framerate of 32,0 Hz
    LCDFRR  = (0<<LCDPS0) | (7<<LCDCD0);    
     e88:	87 e0       	ldi	r24, 0x07	; 7
     e8a:	80 93 e6 00 	sts	0x00E6, r24

	// Enable LCD and set low power waveform
    LCDCRA  = (1<<LCDEN) | (1<<LCDAB); 
     e8e:	80 ec       	ldi	r24, 0xC0	; 192
     e90:	80 93 e4 00 	sts	0x00E4, r24

    //Enable LCD start of frame interrupt
    LCDCRA |= (1<<LCDIE);
     e94:	80 91 e4 00 	lds	r24, 0x00E4
     e98:	88 60       	ori	r24, 0x08	; 8
     e9a:	80 93 e4 00 	sts	0x00E4, r24
     e9e:	08 95       	ret

00000ea0 <LCD_puts>:
}

void LCD_puts_f(const uint8_t *FlashData)
{
	uint8_t StrBuff[LCD_TEXTBUFFER_SIZE];

	strcpy_P(StrBuff, FlashData);
	LCD_puts(StrBuff);
}

void LCD_puts(uint8_t *Data)
{
     ea0:	cf 93       	push	r28
     ea2:	df 93       	push	r29
     ea4:	ec 01       	movw	r28, r24
	uint8_t LoadB;
	
	for (LoadB = 0; LoadB < 20; LoadB++)
     ea6:	20 e0       	ldi	r18, 0x00	; 0
     ea8:	3f ef       	ldi	r19, 0xFF	; 255
     eaa:	ed e2       	ldi	r30, 0x2D	; 45
     eac:	f2 e0       	ldi	r31, 0x02	; 2
     eae:	df 01       	movw	r26, r30
	{
		uint8_t CByte = *(Data++);
     eb0:	89 91       	ld	r24, Y+
	
		if ((CByte >= '*') && (CByte <= 'z'))
     eb2:	98 2f       	mov	r25, r24
     eb4:	9a 52       	subi	r25, 0x2A	; 42
     eb6:	91 35       	cpi	r25, 0x51	; 81
     eb8:	38 f4       	brcc	.+14     	; 0xec8 <LCD_puts+0x28>
		  TextBuffer[LoadB] = ((CByte == ' ')? 0xFF : (CByte - '*'));
     eba:	80 32       	cpi	r24, 0x20	; 32
     ebc:	11 f0       	breq	.+4      	; 0xec2 <LCD_puts+0x22>
     ebe:	89 2f       	mov	r24, r25
     ec0:	01 c0       	rjmp	.+2      	; 0xec4 <LCD_puts+0x24>
     ec2:	8f ef       	ldi	r24, 0xFF	; 255
     ec4:	8c 93       	st	X, r24
     ec6:	03 c0       	rjmp	.+6      	; 0xece <LCD_puts+0x2e>
		else if (CByte == 0x00)
     ec8:	88 23       	and	r24, r24
     eca:	31 f0       	breq	.+12     	; 0xed8 <LCD_puts+0x38>
		  break;
		else
		  TextBuffer[LoadB] = 0xFF;		
     ecc:	30 83       	st	Z, r19
     ece:	2f 5f       	subi	r18, 0xFF	; 255
     ed0:	11 96       	adiw	r26, 0x01	; 1
     ed2:	31 96       	adiw	r30, 0x01	; 1
     ed4:	24 31       	cpi	r18, 0x14	; 20
     ed6:	60 f3       	brcs	.-40     	; 0xeb0 <LCD_puts+0x10>
	}

	ScrollMode  = ((LoadB > 6)? TRUE : FALSE);
     ed8:	80 e0       	ldi	r24, 0x00	; 0
     eda:	27 30       	cpi	r18, 0x07	; 7
     edc:	08 f0       	brcs	.+2      	; 0xee0 <LCD_puts+0x40>
     ede:	81 e0       	ldi	r24, 0x01	; 1
     ee0:	80 93 5d 02 	sts	0x025D, r24
	ScrollCount = 0;
     ee4:	10 92 2b 02 	sts	0x022B, r1
     ee8:	9f ef       	ldi	r25, 0xFF	; 255
     eea:	86 e0       	ldi	r24, 0x06	; 6

	for (uint8_t Nulls = 0; Nulls < 7; Nulls++)
		TextBuffer[LoadB++] = 0xFF;
     eec:	e2 2f       	mov	r30, r18
     eee:	ff 27       	eor	r31, r31
     ef0:	e3 5d       	subi	r30, 0xD3	; 211
     ef2:	fd 4f       	sbci	r31, 0xFD	; 253
     ef4:	90 83       	st	Z, r25
     ef6:	2f 5f       	subi	r18, 0xFF	; 255
     ef8:	81 50       	subi	r24, 0x01	; 1
     efa:	87 ff       	sbrs	r24, 7
     efc:	f7 cf       	rjmp	.-18     	; 0xeec <LCD_puts+0x4c>
	
	TextBuffer[LoadB] = 0x00;
     efe:	e2 2f       	mov	r30, r18
     f00:	ff 27       	eor	r31, r31
     f02:	e3 5d       	subi	r30, 0xD3	; 211
     f04:	fd 4f       	sbci	r31, 0xFD	; 253
     f06:	10 82       	st	Z, r1
	StrStart   = 0;
     f08:	10 92 2c 02 	sts	0x022C, r1
	StrEnd     = LoadB;	
     f0c:	20 93 2a 02 	sts	0x022A, r18
	DelayCount = LCD_DELAYCOUNT_DEFAULT;
     f10:	8a e0       	ldi	r24, 0x0A	; 10
     f12:	80 93 5e 02 	sts	0x025E, r24

	UpdateLCD  = TRUE;
     f16:	81 e0       	ldi	r24, 0x01	; 1
     f18:	80 93 48 02 	sts	0x0248, r24
     f1c:	df 91       	pop	r29
     f1e:	cf 91       	pop	r28
     f20:	08 95       	ret

00000f22 <LCD_puts_f>:
     f22:	cf 93       	push	r28
     f24:	df 93       	push	r29
     f26:	cd b7       	in	r28, 0x3d	; 61
     f28:	de b7       	in	r29, 0x3e	; 62
     f2a:	64 97       	sbiw	r28, 0x14	; 20
     f2c:	0f b6       	in	r0, 0x3f	; 63
     f2e:	f8 94       	cli
     f30:	de bf       	out	0x3e, r29	; 62
     f32:	0f be       	out	0x3f, r0	; 63
     f34:	cd bf       	out	0x3d, r28	; 61
     f36:	bc 01       	movw	r22, r24
     f38:	ce 01       	movw	r24, r28
     f3a:	01 96       	adiw	r24, 0x01	; 1
     f3c:	0e 94 10 19 	call	0x3220 <strcpy_P>
     f40:	ce 01       	movw	r24, r28
     f42:	01 96       	adiw	r24, 0x01	; 1
     f44:	0e 94 50 07 	call	0xea0 <LCD_puts>
     f48:	64 96       	adiw	r28, 0x14	; 20
     f4a:	0f b6       	in	r0, 0x3f	; 63
     f4c:	f8 94       	cli
     f4e:	de bf       	out	0x3e, r29	; 62
     f50:	0f be       	out	0x3f, r0	; 63
     f52:	cd bf       	out	0x3d, r28	; 61
     f54:	df 91       	pop	r29
     f56:	cf 91       	pop	r28
     f58:	08 95       	ret

00000f5a <LCD_WriteChar>:
}

void LCD_WriteChar(uint8_t Byte, uint8_t Digit)
{
     f5a:	e8 2f       	mov	r30, r24
	uint16_t SegData  = 0x00;
     f5c:	20 e0       	ldi	r18, 0x00	; 0
     f5e:	30 e0       	ldi	r19, 0x00	; 0
	uint8_t  *BuffPtr = (&SegBuffer[0] + (Digit >> 1));
     f60:	86 2f       	mov	r24, r22
     f62:	86 95       	lsr	r24
     f64:	a8 2f       	mov	r26, r24
     f66:	bb 27       	eor	r27, r27
     f68:	a7 5b       	subi	r26, 0xB7	; 183
     f6a:	bd 4f       	sbci	r27, 0xFD	; 253

	if (Byte != 0xFF)
     f6c:	ef 3f       	cpi	r30, 0xFF	; 255
     f6e:	39 f0       	breq	.+14     	; 0xf7e <LCD_WriteChar+0x24>
	  SegData = pgm_read_word(&LCD_SegTable[Byte]);	
     f70:	ff 27       	eor	r31, r31
     f72:	ee 0f       	add	r30, r30
     f74:	ff 1f       	adc	r31, r31
     f76:	e0 52       	subi	r30, 0x20	; 32
     f78:	fd 4f       	sbci	r31, 0xFD	; 253
     f7a:	25 91       	lpm	r18, Z+
     f7c:	34 91       	lpm	r19, Z
     f7e:	77 27       	eor	r23, r23
     f80:	61 70       	andi	r22, 0x01	; 1
     f82:	70 70       	andi	r23, 0x00	; 0
     f84:	43 e0       	ldi	r20, 0x03	; 3

	for (uint8_t BNib = 0; BNib < 4; BNib++)
	{
		uint8_t Mask          = 0xF0;
     f86:	50 ef       	ldi	r21, 0xF0	; 240
		uint8_t MaskedSegData = (SegData & 0x0000F);
     f88:	92 2f       	mov	r25, r18
     f8a:	9f 70       	andi	r25, 0x0F	; 15
	
		if (Digit & 0x01)
     f8c:	61 15       	cp	r22, r1
     f8e:	71 05       	cpc	r23, r1
     f90:	19 f0       	breq	.+6      	; 0xf98 <LCD_WriteChar+0x3e>
		{
			Mask = 0x0F;
     f92:	5f e0       	ldi	r21, 0x0F	; 15
			MaskedSegData <<= 4;
     f94:	92 95       	swap	r25
     f96:	90 7f       	andi	r25, 0xF0	; 240
		}
		
		*BuffPtr = ((*BuffPtr & Mask) | MaskedSegData);
     f98:	8c 91       	ld	r24, X
     f9a:	85 23       	and	r24, r21
     f9c:	89 2b       	or	r24, r25
     f9e:	8c 93       	st	X, r24

		SegData >>= 4;
     fa0:	84 e0       	ldi	r24, 0x04	; 4
     fa2:	36 95       	lsr	r19
     fa4:	27 95       	ror	r18
     fa6:	8a 95       	dec	r24
     fa8:	e1 f7       	brne	.-8      	; 0xfa2 <LCD_WriteChar+0x48>
		BuffPtr  += 5;
     faa:	15 96       	adiw	r26, 0x05	; 5
     fac:	41 50       	subi	r20, 0x01	; 1
     fae:	47 ff       	sbrs	r20, 7
     fb0:	ea cf       	rjmp	.-44     	; 0xf86 <LCD_WriteChar+0x2c>
     fb2:	08 95       	ret

00000fb4 <__vector_22>:
	}
}

ISR(LCD_vect, ISR_NOBLOCK)
{
     fb4:	78 94       	sei
     fb6:	1f 92       	push	r1
     fb8:	0f 92       	push	r0
     fba:	0f b6       	in	r0, 0x3f	; 63
     fbc:	0f 92       	push	r0
     fbe:	11 24       	eor	r1, r1
     fc0:	2f 93       	push	r18
     fc2:	3f 93       	push	r19
     fc4:	4f 93       	push	r20
     fc6:	5f 93       	push	r21
     fc8:	6f 93       	push	r22
     fca:	7f 93       	push	r23
     fcc:	8f 93       	push	r24
     fce:	9f 93       	push	r25
     fd0:	af 93       	push	r26
     fd2:	bf 93       	push	r27
     fd4:	cf 93       	push	r28
     fd6:	ef 93       	push	r30
     fd8:	ff 93       	push	r31
	if (ScrollMode)
     fda:	80 91 5d 02 	lds	r24, 0x025D
     fde:	88 23       	and	r24, r24
     fe0:	99 f0       	breq	.+38     	; 0x1008 <__vector_22+0x54>
	{
		if (DelayCount)
     fe2:	80 91 5e 02 	lds	r24, 0x025E
     fe6:	88 23       	and	r24, r24
     fe8:	21 f0       	breq	.+8      	; 0xff2 <__vector_22+0x3e>
		{
			DelayCount--;
     fea:	81 50       	subi	r24, 0x01	; 1
     fec:	80 93 5e 02 	sts	0x025E, r24
     ff0:	0b c0       	rjmp	.+22     	; 0x1008 <__vector_22+0x54>
		}
		else
		{
			if (!(ScrollCount))
     ff2:	80 91 2b 02 	lds	r24, 0x022B
     ff6:	88 23       	and	r24, r24
     ff8:	21 f4       	brne	.+8      	; 0x1002 <__vector_22+0x4e>
			  UpdateLCD = TRUE;
     ffa:	81 e0       	ldi	r24, 0x01	; 1
     ffc:	80 93 48 02 	sts	0x0248, r24
    1000:	03 c0       	rjmp	.+6      	; 0x1008 <__vector_22+0x54>
			else
			  ScrollCount--;
    1002:	81 50       	subi	r24, 0x01	; 1
    1004:	80 93 2b 02 	sts	0x022B, r24
		}
	}

	if (UpdateLCD)
    1008:	80 91 48 02 	lds	r24, 0x0248
    100c:	88 23       	and	r24, r24
    100e:	39 f1       	breq	.+78     	; 0x105e <__vector_22+0xaa>
	{
		for (uint8_t Character = 0; Character < 6; Character++)
    1010:	c0 e0       	ldi	r28, 0x00	; 0
		{
			uint8_t Byte = (StrStart + Character);
    1012:	80 91 2c 02 	lds	r24, 0x022C
    1016:	8c 0f       	add	r24, r28

			if (Byte >= StrEnd)
    1018:	90 91 2a 02 	lds	r25, 0x022A
    101c:	e8 2f       	mov	r30, r24
    101e:	ff 27       	eor	r31, r31
    1020:	89 17       	cp	r24, r25
    1022:	10 f0       	brcs	.+4      	; 0x1028 <__vector_22+0x74>
			  Byte = TextBuffer[Byte - StrEnd];
    1024:	e9 1b       	sub	r30, r25
    1026:	f1 09       	sbc	r31, r1
			else
			  Byte = TextBuffer[Byte];
    1028:	e3 5d       	subi	r30, 0xD3	; 211
    102a:	fd 4f       	sbci	r31, 0xFD	; 253
    102c:	80 81       	ld	r24, Z
			
			LCD_WriteChar(Byte, Character);
    102e:	6c 2f       	mov	r22, r28
    1030:	0e 94 ad 07 	call	0xf5a <LCD_WriteChar>
    1034:	cf 5f       	subi	r28, 0xFF	; 255
    1036:	c6 30       	cpi	r28, 0x06	; 6
    1038:	60 f3       	brcs	.-40     	; 0x1012 <__vector_22+0x5e>
		}
		
		if (StrStart++ == StrEnd)
    103a:	80 91 2c 02 	lds	r24, 0x022C
    103e:	98 2f       	mov	r25, r24
    1040:	8f 5f       	subi	r24, 0xFF	; 255
    1042:	80 93 2c 02 	sts	0x022C, r24
    1046:	80 91 2a 02 	lds	r24, 0x022A
    104a:	98 17       	cp	r25, r24
    104c:	19 f4       	brne	.+6      	; 0x1054 <__vector_22+0xa0>
		  StrStart = 1;
    104e:	81 e0       	ldi	r24, 0x01	; 1
    1050:	80 93 2c 02 	sts	0x022C, r24
		
		ScrollCount = LCD_SCROLLCOUNT_DEFAULT;
    1054:	83 e0       	ldi	r24, 0x03	; 3
    1056:	80 93 2b 02 	sts	0x022B, r24
		UpdateLCD = FALSE;
    105a:	10 92 48 02 	sts	0x0248, r1
    105e:	ac ee       	ldi	r26, 0xEC	; 236
    1060:	b0 e0       	ldi	r27, 0x00	; 0
    1062:	e9 e4       	ldi	r30, 0x49	; 73
    1064:	f2 e0       	ldi	r31, 0x02	; 2
    1066:	93 e1       	ldi	r25, 0x13	; 19
	}

	for (uint8_t LCDChar = 0; LCDChar < LCD_SEGBUFFER_SIZE; LCDChar++)
	  *(pLCDREG + LCDChar) = SegBuffer[LCDChar];
    1068:	81 91       	ld	r24, Z+
    106a:	8d 93       	st	X+, r24
    106c:	91 50       	subi	r25, 0x01	; 1
    106e:	97 ff       	sbrs	r25, 7
    1070:	fb cf       	rjmp	.-10     	; 0x1068 <__vector_22+0xb4>
    1072:	ff 91       	pop	r31
    1074:	ef 91       	pop	r30
    1076:	cf 91       	pop	r28
    1078:	bf 91       	pop	r27
    107a:	af 91       	pop	r26
    107c:	9f 91       	pop	r25
    107e:	8f 91       	pop	r24
    1080:	7f 91       	pop	r23
    1082:	6f 91       	pop	r22
    1084:	5f 91       	pop	r21
    1086:	4f 91       	pop	r20
    1088:	3f 91       	pop	r19
    108a:	2f 91       	pop	r18
    108c:	0f 90       	pop	r0
    108e:	0f be       	out	0x3f, r0	; 63
    1090:	0f 90       	pop	r0
    1092:	1f 90       	pop	r1
    1094:	18 95       	reti

00001096 <USART_Init>:
*****************************************************************************/
void USART_Init(void)
{
    // Set baud rate
    UBRRH = (uint8_t)(USART_BAUDVALUE >> 8);
    1096:	10 92 c5 00 	sts	0x00C5, r1
    UBRRL = (uint8_t)(USART_BAUDVALUE);
    109a:	87 e0       	ldi	r24, 0x07	; 7
    109c:	80 93 c4 00 	sts	0x00C4, r24

    // Double speed
	UCSRA = (USART_DOUBLESPEED << U2X);
    10a0:	82 e0       	ldi	r24, 0x02	; 2
    10a2:	80 93 c0 00 	sts	0x00C0, r24

    // Enable recieve complete interrupt
	UCSRB = (1 << RXCIE);
    10a6:	80 e8       	ldi	r24, 0x80	; 128
    10a8:	80 93 c1 00 	sts	0x00C1, r24
	 
    // Async. mode, 8N1
    UCSRC = (3 << UCSZ0);
    10ac:	86 e0       	ldi	r24, 0x06	; 6
    10ae:	80 93 c2 00 	sts	0x00C2, r24
	 
	 // Initalise ringbuffer
	BUFF_InitialiseBuffer();
    10b2:	0e 94 fd 0a 	call	0x15fa <BUFF_InitialiseBuffer>
    10b6:	08 95       	ret

000010b8 <USART_Tx>:
}

/*****************************************************************************
*
*   Function name : Usart_Tx
*
*   Returns :       None
*
*   Parameters :    char data: byte to send
*
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_Tx(char data)
{
    10b8:	98 2f       	mov	r25, r24
    while (!(UCSRA & (1 << UDRE)));
    10ba:	80 91 c0 00 	lds	r24, 0x00C0
    10be:	85 ff       	sbrs	r24, 5
    10c0:	fc cf       	rjmp	.-8      	; 0x10ba <USART_Tx+0x2>
    UDR = data;
    10c2:	90 93 c6 00 	sts	0x00C6, r25
    10c6:	08 95       	ret

000010c8 <USART_TxString>:
}

/*****************************************************************************
*
*   Function name : Usart_Tx
*
*   Returns :       None
*
*   Parameters :    char data: byte to send
*
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_TxString(char *data)
{
    10c8:	cf 93       	push	r28
    10ca:	df 93       	push	r29
    10cc:	ec 01       	movw	r28, r24
	while (*data != '\0')
	  USART_Tx(*data++);
    10ce:	88 81       	ld	r24, Y
    10d0:	88 23       	and	r24, r24
    10d2:	31 f0       	breq	.+12     	; 0x10e0 <USART_TxString+0x18>
    10d4:	89 91       	ld	r24, Y+
    10d6:	0e 94 5c 08 	call	0x10b8 <USART_Tx>
    10da:	88 81       	ld	r24, Y
    10dc:	88 23       	and	r24, r24
    10de:	d1 f7       	brne	.-12     	; 0x10d4 <USART_TxString+0xc>
    10e0:	df 91       	pop	r29
    10e2:	cf 91       	pop	r28
    10e4:	08 95       	ret

000010e6 <USART_Rx>:
}

/*****************************************************************************
*
*   Function name : Usart_Rx
*
*   Returns :       char: byte received
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART
*
*****************************************************************************/
char USART_Rx(void)
{
    while (!(BuffElements) && !(TimeOut)) {};
    10e6:	80 91 af 02 	lds	r24, 0x02AF
    10ea:	88 23       	and	r24, r24
    10ec:	21 f4       	brne	.+8      	; 0x10f6 <USART_Rx+0x10>
    10ee:	80 91 06 01 	lds	r24, 0x0106
    10f2:	88 23       	and	r24, r24
    10f4:	c1 f3       	breq	.-16     	; 0x10e6 <USART_Rx>
    return BUFF_GetBuffByte();
    10f6:	0e 94 0a 0b 	call	0x1614 <BUFF_GetBuffByte>
}
    10fa:	99 27       	eor	r25, r25
    10fc:	08 95       	ret

000010fe <SPI_SPIInit>:
// ======================================================================================

void SPI_SPIInit(void)
{
	PRR &= ~(1 << PRSPI);              // Enable the SPI system by clearing the power save register SPI disable bit
    10fe:	80 91 64 00 	lds	r24, 0x0064
    1102:	8b 7f       	andi	r24, 0xFB	; 251
    1104:	80 93 64 00 	sts	0x0064, r24

	// Master, Sample falling edge (setup rising), Fosc/2 speed (8Mhz/2 = 4MHz)
	SPSR = (1 << SPI2X);
    1108:	81 e0       	ldi	r24, 0x01	; 1
    110a:	8d bd       	out	0x2d, r24	; 45
	SPCR = ((1 << SPE) | (1 << MSTR) | (1 << CPHA) | (1 << CPOL));
    110c:	8c e5       	ldi	r24, 0x5C	; 92
    110e:	8c bd       	out	0x2c, r24	; 44
    1110:	08 95       	ret

00001112 <SPI_SPITransmit>:
}

uint8_t SPI_SPITransmit(uint8_t Data)
{
	SPDR = Data;                       // Loading a byte into the register starts the transmission
    1112:	8e bd       	out	0x2e, r24	; 46
	while (!(SPSR & (1 << SPIF)));    // Wait until transmission completed
    1114:	0d b4       	in	r0, 0x2d	; 45
    1116:	07 fe       	sbrs	r0, 7
    1118:	fd cf       	rjmp	.-6      	; 0x1114 <SPI_SPITransmit+0x2>
	return SPDR;
    111a:	8e b5       	in	r24, 0x2e	; 46
}
    111c:	99 27       	eor	r25, r25
    111e:	08 95       	ret

00001120 <SPI_SPITransmitWord>:

uint8_t SPI_SPITransmitWord(uint16_t Data)
{
    1120:	0f 93       	push	r16
    1122:	1f 93       	push	r17
    1124:	8c 01       	movw	r16, r24
	SPI_SPITransmit((uint8_t)(Data >> 8));
    1126:	81 2f       	mov	r24, r17
    1128:	99 27       	eor	r25, r25
    112a:	0e 94 89 08 	call	0x1112 <SPI_SPITransmit>
	return SPI_SPITransmit((uint8_t)Data);
    112e:	80 2f       	mov	r24, r16
    1130:	0e 94 89 08 	call	0x1112 <SPI_SPITransmit>
}
    1134:	99 27       	eor	r25, r25
    1136:	1f 91       	pop	r17
    1138:	0f 91       	pop	r16
    113a:	08 95       	ret

0000113c <__vector_17>:
 *  have to stop the timer tick.
 *  For all modes the USIDR contents are stored and flags are updated.
 */
ISR(USI_OVERFLOW_vect, ISR_BLOCK)
{
    113c:	1f 92       	push	r1
    113e:	0f 92       	push	r0
    1140:	0f b6       	in	r0, 0x3f	; 63
    1142:	0f 92       	push	r0
    1144:	11 24       	eor	r1, r1
    1146:	8f 93       	push	r24
	// Master must now disable the compare match interrupt
	// to prevent more USI counter clocks.
	TIMSK0 &= ~(1<<OCIE0A);
    1148:	80 91 6e 00 	lds	r24, 0x006E
    114c:	8d 7f       	andi	r24, 0xFD	; 253
    114e:	80 93 6e 00 	sts	0x006E, r24
	
	// Update flags and clear USI counter
	USISR = (1<<USIOIF);
    1152:	80 e4       	ldi	r24, 0x40	; 64
    1154:	80 93 b9 00 	sts	0x00B9, r24
	TransferComplete = 1;
    1158:	81 e0       	ldi	r24, 0x01	; 1
    115a:	80 93 5f 02 	sts	0x025F, r24

	// Copy USIDR to buffer to prevent overwrite on next transfer.
	storedUSIDR = USIDR;
    115e:	80 91 ba 00 	lds	r24, 0x00BA
    1162:	80 93 60 02 	sts	0x0260, r24
    1166:	8f 91       	pop	r24
    1168:	0f 90       	pop	r0
    116a:	0f be       	out	0x3f, r0	; 63
    116c:	0f 90       	pop	r0
    116e:	1f 90       	pop	r1
    1170:	18 95       	reti

00001172 <USI_SPISetSpeed>:
}



/*! \brief  Initialize USI as SPI master.
 *
 *  This function sets up all pin directions and module configurations.
 *  Use this function initially or when changing from slave to master mode.
 *  Note that the stored USIDR value is cleared.
 *
 */
void USI_SPIInitMaster(char Freq)
{
	// Configure port directions.
 	USI_DIR_REG |= (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN);  // Outputs.
	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN);                       // Inputs.
	USI_OUT_REG |= (1<<USI_DATAIN_PIN);                        // Pull-ups.
	USI_OUT_REG &= ~(1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN); // Pull-ups.
	
	// Configure USI to 3-wire master mode with overflow interrupt.
	USICR = USI_CONTROL_REG_FLAGS;

	// Set the compare and prescaler for the requested frequency:
	USI_SPISetSpeed(Freq);
	
	// Init driver status register.
	TransferComplete = 0;
	
	storedUSIDR = 0;
}

void USI_SPIOff( void )
{
	USI_DIR_REG &= ~((1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN));                        // Inputs.
	USI_OUT_REG &= ~((1<<USI_DATAIN_PIN)  | (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN)); // Pull-ups.
	DDRF  &= ~(1 << 6);
	PORTF &= ~(1 << 6);
	
	USI_STOPUSITIMER();
}

/*! \brief  Put one byte on bus.
 *
 *  Use this function like you would write to the SPDR register in the native SPI module.
 *  Calling this function in master mode starts a transfer, while in slave mode, a
 *  byte will be prepared for the next transfer initiated by the master device.
 *  If a transfer is in progress, this function will set the write collision flag
 *  and return without altering the data registers.
 *
 *  \returns  0 if a write collision occurred, 1 otherwise.
 */
uint8_t USI_SPITransmit( unsigned char val )
{
	// Reinit flags.
	TransferComplete = 0;

	// Put data in USI data register.
	USIDR = val;
	
	TIFR0  |= (1<<OCF0A);  // Clear compare match flag.
	TIMSK0 |= (1<<OCIE0A); // Enable compare match interrupt.

	// Clear the timer 0 value
	TCNT0 = 0;

	while (!(TransferComplete));

	return storedUSIDR;
}

uint8_t USI_SPITransmitWord( unsigned int val )
{
	USI_SPITransmit((uint8_t)(val >> 8));
	return USI_SPITransmit((uint8_t)val);
}

void USI_SPIToggleClock(void)
{
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);	
}

void USI_SPISetSpeed(uint8_t Freq)
{
    1172:	48 2f       	mov	r20, r24
	for (uint8_t MatchIndex = 0; MatchIndex < USI_PRESET_SPEEDS; MatchIndex++)
    1174:	90 e0       	ldi	r25, 0x00	; 0
    1176:	6d e4       	ldi	r22, 0x4D	; 77
    1178:	73 e0       	ldi	r23, 0x03	; 3
    117a:	9b 01       	movw	r18, r22
    117c:	21 50       	subi	r18, 0x01	; 1
    117e:	30 40       	sbci	r19, 0x00	; 0
	{
		if ((pgm_read_byte(&USIPSValues[MatchIndex][0]) == Freq) || (MatchIndex == (USI_PRESET_SPEEDS - 1)))
    1180:	f9 01       	movw	r30, r18
    1182:	84 91       	lpm	r24, Z
    1184:	84 17       	cp	r24, r20
    1186:	11 f0       	breq	.+4      	; 0x118c <USI_SPISetSpeed+0x1a>
    1188:	93 30       	cpi	r25, 0x03	; 3
    118a:	31 f4       	brne	.+12     	; 0x1198 <USI_SPISetSpeed+0x26>
		{
			// Init Output Compare Register.
			OCR0A = pgm_read_byte(&USIPSValues[MatchIndex][1]);
    118c:	fb 01       	movw	r30, r22
    118e:	84 91       	lpm	r24, Z
    1190:	87 bd       	out	0x27, r24	; 39

			// Enable 'Clear Timer on Compare match' and set prescaler, which starts the timer
			TCCR0A = ((1<<WGM01) | TC0_PS_1);
    1192:	89 e0       	ldi	r24, 0x09	; 9
    1194:	84 bd       	out	0x24, r24	; 36
				
			return;
    1196:	08 95       	ret
    1198:	9f 5f       	subi	r25, 0xFF	; 255
    119a:	2e 5f       	subi	r18, 0xFE	; 254
    119c:	3f 4f       	sbci	r19, 0xFF	; 255
    119e:	6e 5f       	subi	r22, 0xFE	; 254
    11a0:	7f 4f       	sbci	r23, 0xFF	; 255
    11a2:	94 30       	cpi	r25, 0x04	; 4
    11a4:	68 f3       	brcs	.-38     	; 0x1180 <USI_SPISetSpeed+0xe>
    11a6:	08 95       	ret

000011a8 <USI_SPIInitMaster>:
    11a8:	9d b1       	in	r25, 0x0d	; 13
    11aa:	90 65       	ori	r25, 0x50	; 80
    11ac:	9d b9       	out	0x0d, r25	; 13
    11ae:	6d 98       	cbi	0x0d, 5	; 13
    11b0:	75 9a       	sbi	0x0e, 5	; 14
    11b2:	76 98       	cbi	0x0e, 6	; 14
    11b4:	9a e5       	ldi	r25, 0x5A	; 90
    11b6:	90 93 b8 00 	sts	0x00B8, r25
    11ba:	0e 94 b9 08 	call	0x1172 <USI_SPISetSpeed>
    11be:	10 92 5f 02 	sts	0x025F, r1
    11c2:	10 92 60 02 	sts	0x0260, r1
    11c6:	08 95       	ret

000011c8 <USI_SPIOff>:
    11c8:	8d b1       	in	r24, 0x0d	; 13
    11ca:	8f 7a       	andi	r24, 0xAF	; 175
    11cc:	8d b9       	out	0x0d, r24	; 13
    11ce:	8e b1       	in	r24, 0x0e	; 14
    11d0:	8f 78       	andi	r24, 0x8F	; 143
    11d2:	8e b9       	out	0x0e, r24	; 14
    11d4:	86 98       	cbi	0x10, 6	; 16
    11d6:	8e 98       	cbi	0x11, 6	; 17
    11d8:	14 bc       	out	0x24, r1	; 36
    11da:	08 95       	ret

000011dc <USI_SPITransmit>:
    11dc:	10 92 5f 02 	sts	0x025F, r1
    11e0:	80 93 ba 00 	sts	0x00BA, r24
    11e4:	a9 9a       	sbi	0x15, 1	; 21
    11e6:	80 91 6e 00 	lds	r24, 0x006E
    11ea:	82 60       	ori	r24, 0x02	; 2
    11ec:	80 93 6e 00 	sts	0x006E, r24
    11f0:	16 bc       	out	0x26, r1	; 38
    11f2:	80 91 5f 02 	lds	r24, 0x025F
    11f6:	88 23       	and	r24, r24
    11f8:	e1 f3       	breq	.-8      	; 0x11f2 <USI_SPITransmit+0x16>
    11fa:	80 91 60 02 	lds	r24, 0x0260
    11fe:	99 27       	eor	r25, r25
    1200:	08 95       	ret

00001202 <USI_SPITransmitWord>:
    1202:	0f 93       	push	r16
    1204:	1f 93       	push	r17
    1206:	8c 01       	movw	r16, r24
    1208:	81 2f       	mov	r24, r17
    120a:	99 27       	eor	r25, r25
    120c:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    1210:	80 2f       	mov	r24, r16
    1212:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    1216:	99 27       	eor	r25, r25
    1218:	1f 91       	pop	r17
    121a:	0f 91       	pop	r16
    121c:	08 95       	ret

0000121e <USI_SPIToggleClock>:
    121e:	81 e0       	ldi	r24, 0x01	; 1
    1220:	0e 94 ed 02 	call	0x5da <MAIN_Delay1MS>
    1224:	80 91 b8 00 	lds	r24, 0x00B8
    1228:	81 60       	ori	r24, 0x01	; 1
    122a:	80 93 b8 00 	sts	0x00B8, r24
    122e:	81 e0       	ldi	r24, 0x01	; 1
    1230:	0e 94 ed 02 	call	0x5da <MAIN_Delay1MS>
    1234:	80 91 b8 00 	lds	r24, 0x00B8
    1238:	81 60       	ori	r24, 0x01	; 1
    123a:	80 93 b8 00 	sts	0x00B8, r24
    123e:	81 e0       	ldi	r24, 0x01	; 1
    1240:	0e 94 ed 02 	call	0x5da <MAIN_Delay1MS>
    1244:	08 95       	ret

00001246 <DF_EnableDataflash>:
	while (DF_BUSY());
}

void DF_EnableDataflash(uint8_t Enabled)
{
    1246:	90 91 61 02 	lds	r25, 0x0261
	if (Enabled == TRUE)
    124a:	81 30       	cpi	r24, 0x01	; 1
    124c:	31 f4       	brne	.+12     	; 0x125a <DF_EnableDataflash+0x14>
	{
		if (UseExernalDF == TRUE)
    124e:	91 30       	cpi	r25, 0x01	; 1
    1250:	11 f4       	brne	.+4      	; 0x1256 <DF_EnableDataflash+0x10>
		  MAIN_ResetCSLine(MAIN_RESETCS_EXTDFACTIVE);
    1252:	82 e0       	ldi	r24, 0x02	; 2
    1254:	05 c0       	rjmp	.+10     	; 0x1260 <DF_EnableDataflash+0x1a>
		else
		  PORTB &= ~(1 << 0);
    1256:	28 98       	cbi	0x05, 0	; 5
    1258:	08 95       	ret
	}
	else
	{
		if (UseExernalDF == TRUE)
    125a:	91 30       	cpi	r25, 0x01	; 1
    125c:	21 f4       	brne	.+8      	; 0x1266 <DF_EnableDataflash+0x20>
		  MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);
    125e:	89 2f       	mov	r24, r25
    1260:	0e 94 ff 02 	call	0x5fe <MAIN_ResetCSLine>
    1264:	08 95       	ret
		else
		  PORTB |= (1 << 0);
    1266:	28 9a       	sbi	0x05, 0	; 5
    1268:	08 95       	ret

0000126a <DF_ReadBufferByte>:
    126a:	0f 93       	push	r16
    126c:	1f 93       	push	r17
    126e:	8c 01       	movw	r16, r24
    1270:	80 e0       	ldi	r24, 0x00	; 0
    1272:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    1276:	81 e0       	ldi	r24, 0x01	; 1
    1278:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    127c:	e0 91 00 01 	lds	r30, 0x0100
    1280:	f0 91 01 01 	lds	r31, 0x0101
    1284:	84 e5       	ldi	r24, 0x54	; 84
    1286:	09 95       	icall
    1288:	81 2f       	mov	r24, r17
    128a:	99 27       	eor	r25, r25
    128c:	e0 91 00 01 	lds	r30, 0x0100
    1290:	f0 91 01 01 	lds	r31, 0x0101
    1294:	09 95       	icall
    1296:	e0 91 00 01 	lds	r30, 0x0100
    129a:	f0 91 01 01 	lds	r31, 0x0101
    129e:	80 2f       	mov	r24, r16
    12a0:	09 95       	icall
    12a2:	e0 91 00 01 	lds	r30, 0x0100
    12a6:	f0 91 01 01 	lds	r31, 0x0101
    12aa:	80 e0       	ldi	r24, 0x00	; 0
    12ac:	09 95       	icall
    12ae:	e0 91 00 01 	lds	r30, 0x0100
    12b2:	f0 91 01 01 	lds	r31, 0x0101
    12b6:	80 e0       	ldi	r24, 0x00	; 0
    12b8:	09 95       	icall
    12ba:	99 27       	eor	r25, r25
    12bc:	1f 91       	pop	r17
    12be:	0f 91       	pop	r16
    12c0:	08 95       	ret

000012c2 <DF_ContinuousReadEnable>:
    12c2:	ef 92       	push	r14
    12c4:	ff 92       	push	r15
    12c6:	0f 93       	push	r16
    12c8:	1f 93       	push	r17
    12ca:	8c 01       	movw	r16, r24
    12cc:	7b 01       	movw	r14, r22
    12ce:	80 e0       	ldi	r24, 0x00	; 0
    12d0:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    12d4:	81 e0       	ldi	r24, 0x01	; 1
    12d6:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    12da:	e0 91 00 01 	lds	r30, 0x0100
    12de:	f0 91 01 01 	lds	r31, 0x0101
    12e2:	88 e6       	ldi	r24, 0x68	; 104
    12e4:	09 95       	icall
    12e6:	8a b5       	in	r24, 0x2a	; 42
    12e8:	98 01       	movw	r18, r16
    12ea:	02 c0       	rjmp	.+4      	; 0x12f0 <DF_ContinuousReadEnable+0x2e>
    12ec:	36 95       	lsr	r19
    12ee:	27 95       	ror	r18
    12f0:	8a 95       	dec	r24
    12f2:	e2 f7       	brpl	.-8      	; 0x12ec <DF_ContinuousReadEnable+0x2a>
    12f4:	c9 01       	movw	r24, r18
    12f6:	e0 91 00 01 	lds	r30, 0x0100
    12fa:	f0 91 01 01 	lds	r31, 0x0101
    12fe:	09 95       	icall
    1300:	8b b5       	in	r24, 0x2b	; 43
    1302:	02 c0       	rjmp	.+4      	; 0x1308 <DF_ContinuousReadEnable+0x46>
    1304:	00 0f       	add	r16, r16
    1306:	11 1f       	adc	r17, r17
    1308:	8a 95       	dec	r24
    130a:	e2 f7       	brpl	.-8      	; 0x1304 <DF_ContinuousReadEnable+0x42>
    130c:	8f 2d       	mov	r24, r15
    130e:	99 27       	eor	r25, r25
    1310:	e0 91 00 01 	lds	r30, 0x0100
    1314:	f0 91 01 01 	lds	r31, 0x0101
    1318:	80 0f       	add	r24, r16
    131a:	09 95       	icall
    131c:	e0 91 00 01 	lds	r30, 0x0100
    1320:	f0 91 01 01 	lds	r31, 0x0101
    1324:	8e 2d       	mov	r24, r14
    1326:	09 95       	icall
    1328:	03 e0       	ldi	r16, 0x03	; 3
    132a:	e0 91 00 01 	lds	r30, 0x0100
    132e:	f0 91 01 01 	lds	r31, 0x0101
    1332:	80 e0       	ldi	r24, 0x00	; 0
    1334:	09 95       	icall
    1336:	01 50       	subi	r16, 0x01	; 1
    1338:	07 ff       	sbrs	r16, 7
    133a:	f7 cf       	rjmp	.-18     	; 0x132a <DF_ContinuousReadEnable+0x68>
    133c:	1f 91       	pop	r17
    133e:	0f 91       	pop	r16
    1340:	ff 90       	pop	r15
    1342:	ef 90       	pop	r14
    1344:	08 95       	ret

00001346 <DF_BufferWriteEnable>:
    1346:	0f 93       	push	r16
    1348:	1f 93       	push	r17
    134a:	8c 01       	movw	r16, r24
    134c:	80 e0       	ldi	r24, 0x00	; 0
    134e:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    1352:	81 e0       	ldi	r24, 0x01	; 1
    1354:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    1358:	e0 91 00 01 	lds	r30, 0x0100
    135c:	f0 91 01 01 	lds	r31, 0x0101
    1360:	84 e8       	ldi	r24, 0x84	; 132
    1362:	09 95       	icall
    1364:	e0 91 00 01 	lds	r30, 0x0100
    1368:	f0 91 01 01 	lds	r31, 0x0101
    136c:	80 e0       	ldi	r24, 0x00	; 0
    136e:	09 95       	icall
    1370:	81 2f       	mov	r24, r17
    1372:	99 27       	eor	r25, r25
    1374:	e0 91 00 01 	lds	r30, 0x0100
    1378:	f0 91 01 01 	lds	r31, 0x0101
    137c:	09 95       	icall
    137e:	e0 91 00 01 	lds	r30, 0x0100
    1382:	f0 91 01 01 	lds	r31, 0x0101
    1386:	80 2f       	mov	r24, r16
    1388:	09 95       	icall
    138a:	1f 91       	pop	r17
    138c:	0f 91       	pop	r16
    138e:	08 95       	ret

00001390 <DF_GetChipCharacteristics>:
    1390:	80 e0       	ldi	r24, 0x00	; 0
    1392:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    1396:	81 e0       	ldi	r24, 0x01	; 1
    1398:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    139c:	e0 91 00 01 	lds	r30, 0x0100
    13a0:	f0 91 01 01 	lds	r31, 0x0101
    13a4:	87 e5       	ldi	r24, 0x57	; 87
    13a6:	09 95       	icall
    13a8:	e0 91 00 01 	lds	r30, 0x0100
    13ac:	f0 91 01 01 	lds	r31, 0x0101
    13b0:	80 e0       	ldi	r24, 0x00	; 0
    13b2:	09 95       	icall
    13b4:	68 2f       	mov	r22, r24
    13b6:	77 27       	eor	r23, r23
    13b8:	cb 01       	movw	r24, r22
    13ba:	88 73       	andi	r24, 0x38	; 56
    13bc:	90 70       	andi	r25, 0x00	; 0
    13be:	33 e0       	ldi	r19, 0x03	; 3
    13c0:	95 95       	asr	r25
    13c2:	87 95       	ror	r24
    13c4:	3a 95       	dec	r19
    13c6:	e1 f7       	brne	.-8      	; 0x13c0 <DF_GetChipCharacteristics+0x30>
    13c8:	99 27       	eor	r25, r25
    13ca:	fc 01       	movw	r30, r24
    13cc:	ec 57       	subi	r30, 0x7C	; 124
    13ce:	fc 4f       	sbci	r31, 0xFC	; 252
    13d0:	44 91       	lpm	r20, Z
    13d2:	40 93 64 02 	sts	0x0264, r20
    13d6:	9c 01       	movw	r18, r24
    13d8:	28 0f       	add	r18, r24
    13da:	39 1f       	adc	r19, r25
    13dc:	f9 01       	movw	r30, r18
    13de:	ec 58       	subi	r30, 0x8C	; 140
    13e0:	fc 4f       	sbci	r31, 0xFC	; 252
    13e2:	85 91       	lpm	r24, Z+
    13e4:	94 91       	lpm	r25, Z
    13e6:	90 93 66 02 	sts	0x0266, r25
    13ea:	80 93 65 02 	sts	0x0265, r24
    13ee:	f9 01       	movw	r30, r18
    13f0:	ec 59       	subi	r30, 0x9C	; 156
    13f2:	fc 4f       	sbci	r31, 0xFC	; 252
    13f4:	85 91       	lpm	r24, Z+
    13f6:	94 91       	lpm	r25, Z
    13f8:	90 93 68 02 	sts	0x0268, r25
    13fc:	80 93 67 02 	sts	0x0267, r24
    1400:	80 e1       	ldi	r24, 0x10	; 16
    1402:	84 1b       	sub	r24, r20
    1404:	8a bd       	out	0x2a, r24	; 42
    1406:	48 50       	subi	r20, 0x08	; 8
    1408:	4b bd       	out	0x2b, r20	; 43
    140a:	cb 01       	movw	r24, r22
    140c:	08 95       	ret

0000140e <DF_EraseBlock>:
    140e:	0f 93       	push	r16
    1410:	1f 93       	push	r17
    1412:	8c 01       	movw	r16, r24
    1414:	80 e0       	ldi	r24, 0x00	; 0
    1416:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    141a:	81 e0       	ldi	r24, 0x01	; 1
    141c:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    1420:	e0 91 00 01 	lds	r30, 0x0100
    1424:	f0 91 01 01 	lds	r31, 0x0101
    1428:	80 e5       	ldi	r24, 0x50	; 80
    142a:	09 95       	icall
    142c:	81 2f       	mov	r24, r17
    142e:	99 27       	eor	r25, r25
    1430:	e0 91 00 01 	lds	r30, 0x0100
    1434:	f0 91 01 01 	lds	r31, 0x0101
    1438:	09 95       	icall
    143a:	e0 91 00 01 	lds	r30, 0x0100
    143e:	f0 91 01 01 	lds	r31, 0x0101
    1442:	80 2f       	mov	r24, r16
    1444:	09 95       	icall
    1446:	e0 91 00 01 	lds	r30, 0x0100
    144a:	f0 91 01 01 	lds	r31, 0x0101
    144e:	80 e0       	ldi	r24, 0x00	; 0
    1450:	09 95       	icall
    1452:	0e 94 c8 09 	call	0x1390 <DF_GetChipCharacteristics>
    1456:	88 23       	and	r24, r24
    1458:	e4 f7       	brge	.-8      	; 0x1452 <DF_EraseBlock+0x44>
    145a:	1f 91       	pop	r17
    145c:	0f 91       	pop	r16
    145e:	08 95       	ret

00001460 <DF_CopyFlashPageToBuffer>:
    1460:	0f 93       	push	r16
    1462:	1f 93       	push	r17
    1464:	8c 01       	movw	r16, r24
    1466:	80 e0       	ldi	r24, 0x00	; 0
    1468:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    146c:	81 e0       	ldi	r24, 0x01	; 1
    146e:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    1472:	e0 91 00 01 	lds	r30, 0x0100
    1476:	f0 91 01 01 	lds	r31, 0x0101
    147a:	83 e5       	ldi	r24, 0x53	; 83
    147c:	09 95       	icall
    147e:	8a b5       	in	r24, 0x2a	; 42
    1480:	98 01       	movw	r18, r16
    1482:	02 c0       	rjmp	.+4      	; 0x1488 <DF_CopyFlashPageToBuffer+0x28>
    1484:	36 95       	lsr	r19
    1486:	27 95       	ror	r18
    1488:	8a 95       	dec	r24
    148a:	e2 f7       	brpl	.-8      	; 0x1484 <DF_CopyFlashPageToBuffer+0x24>
    148c:	c9 01       	movw	r24, r18
    148e:	e0 91 00 01 	lds	r30, 0x0100
    1492:	f0 91 01 01 	lds	r31, 0x0101
    1496:	09 95       	icall
    1498:	8b b5       	in	r24, 0x2b	; 43
    149a:	02 c0       	rjmp	.+4      	; 0x14a0 <DF_CopyFlashPageToBuffer+0x40>
    149c:	00 0f       	add	r16, r16
    149e:	11 1f       	adc	r17, r17
    14a0:	8a 95       	dec	r24
    14a2:	e2 f7       	brpl	.-8      	; 0x149c <DF_CopyFlashPageToBuffer+0x3c>
    14a4:	e0 91 00 01 	lds	r30, 0x0100
    14a8:	f0 91 01 01 	lds	r31, 0x0101
    14ac:	80 2f       	mov	r24, r16
    14ae:	09 95       	icall
    14b0:	e0 91 00 01 	lds	r30, 0x0100
    14b4:	f0 91 01 01 	lds	r31, 0x0101
    14b8:	80 e0       	ldi	r24, 0x00	; 0
    14ba:	09 95       	icall
    14bc:	0e 94 c8 09 	call	0x1390 <DF_GetChipCharacteristics>
    14c0:	88 23       	and	r24, r24
    14c2:	e4 f7       	brge	.-8      	; 0x14bc <DF_CopyFlashPageToBuffer+0x5c>
    14c4:	1f 91       	pop	r17
    14c6:	0f 91       	pop	r16
    14c8:	08 95       	ret

000014ca <DF_CopyBufferToFlashPage>:
    14ca:	0f 93       	push	r16
    14cc:	1f 93       	push	r17
    14ce:	8c 01       	movw	r16, r24
    14d0:	80 e0       	ldi	r24, 0x00	; 0
    14d2:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    14d6:	81 e0       	ldi	r24, 0x01	; 1
    14d8:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    14dc:	e0 91 00 01 	lds	r30, 0x0100
    14e0:	f0 91 01 01 	lds	r31, 0x0101
    14e4:	83 e8       	ldi	r24, 0x83	; 131
    14e6:	09 95       	icall
    14e8:	8a b5       	in	r24, 0x2a	; 42
    14ea:	98 01       	movw	r18, r16
    14ec:	02 c0       	rjmp	.+4      	; 0x14f2 <DF_CopyBufferToFlashPage+0x28>
    14ee:	36 95       	lsr	r19
    14f0:	27 95       	ror	r18
    14f2:	8a 95       	dec	r24
    14f4:	e2 f7       	brpl	.-8      	; 0x14ee <DF_CopyBufferToFlashPage+0x24>
    14f6:	c9 01       	movw	r24, r18
    14f8:	e0 91 00 01 	lds	r30, 0x0100
    14fc:	f0 91 01 01 	lds	r31, 0x0101
    1500:	09 95       	icall
    1502:	8b b5       	in	r24, 0x2b	; 43
    1504:	02 c0       	rjmp	.+4      	; 0x150a <DF_CopyBufferToFlashPage+0x40>
    1506:	00 0f       	add	r16, r16
    1508:	11 1f       	adc	r17, r17
    150a:	8a 95       	dec	r24
    150c:	e2 f7       	brpl	.-8      	; 0x1506 <DF_CopyBufferToFlashPage+0x3c>
    150e:	e0 91 00 01 	lds	r30, 0x0100
    1512:	f0 91 01 01 	lds	r31, 0x0101
    1516:	80 2f       	mov	r24, r16
    1518:	09 95       	icall
    151a:	e0 91 00 01 	lds	r30, 0x0100
    151e:	f0 91 01 01 	lds	r31, 0x0101
    1522:	80 e0       	ldi	r24, 0x00	; 0
    1524:	09 95       	icall
    1526:	0e 94 c8 09 	call	0x1390 <DF_GetChipCharacteristics>
    152a:	88 23       	and	r24, r24
    152c:	e4 f7       	brge	.-8      	; 0x1526 <DF_CopyBufferToFlashPage+0x5c>
    152e:	1f 91       	pop	r17
    1530:	0f 91       	pop	r16
    1532:	08 95       	ret

00001534 <DF_CheckCorrectOnboardChip>:
    1534:	0e 94 c8 09 	call	0x1390 <DF_GetChipCharacteristics>
    1538:	80 91 67 02 	lds	r24, 0x0267
    153c:	90 91 68 02 	lds	r25, 0x0268
    1540:	80 50       	subi	r24, 0x00	; 0
    1542:	98 40       	sbci	r25, 0x08	; 8
    1544:	61 f0       	breq	.+24     	; 0x155e <DF_CheckCorrectOnboardChip+0x2a>
    1546:	80 91 64 00 	lds	r24, 0x0064
    154a:	84 60       	ori	r24, 0x04	; 4
    154c:	80 93 64 00 	sts	0x0064, r24
    1550:	84 e5       	ldi	r24, 0x54	; 84
    1552:	93 e0       	ldi	r25, 0x03	; 3
    1554:	0e 94 55 03 	call	0x6aa <MAIN_ShowError>
    1558:	80 e0       	ldi	r24, 0x00	; 0
    155a:	90 e0       	ldi	r25, 0x00	; 0
    155c:	08 95       	ret
    155e:	81 e0       	ldi	r24, 0x01	; 1
    1560:	90 e0       	ldi	r25, 0x00	; 0
    1562:	08 95       	ret

00001564 <__vector_13>:

// ======================================================================================

ISR(USART0_RX_vect, ISR_BLOCK)
{
    1564:	1f 92       	push	r1
    1566:	0f 92       	push	r0
    1568:	0f b6       	in	r0, 0x3f	; 63
    156a:	0f 92       	push	r0
    156c:	11 24       	eor	r1, r1
    156e:	2f 93       	push	r18
    1570:	3f 93       	push	r19
    1572:	4f 93       	push	r20
    1574:	5f 93       	push	r21
    1576:	6f 93       	push	r22
    1578:	7f 93       	push	r23
    157a:	8f 93       	push	r24
    157c:	9f 93       	push	r25
    157e:	af 93       	push	r26
    1580:	bf 93       	push	r27
    1582:	ef 93       	push	r30
    1584:	ff 93       	push	r31
	if (BuffElements == BuffLen)          // Buffer full
    1586:	80 91 af 02 	lds	r24, 0x02AF
    158a:	80 34       	cpi	r24, 0x40	; 64
    158c:	29 f4       	brne	.+10     	; 0x1598 <__vector_13+0x34>
	{
		MAIN_ShowError(PSTR("BUFF OVERFLOW"));
    158e:	8c e8       	ldi	r24, 0x8C	; 140
    1590:	93 e0       	ldi	r25, 0x03	; 3
    1592:	0e 94 55 03 	call	0x6aa <MAIN_ShowError>
		return;
    1596:	20 c0       	rjmp	.+64     	; 0x15d8 <__vector_13+0x74>
	}
		
	*StoreLoc = UDR;                      // Store the data
    1598:	e0 91 ab 02 	lds	r30, 0x02AB
    159c:	f0 91 ac 02 	lds	r31, 0x02AC
    15a0:	80 91 c6 00 	lds	r24, 0x00C6
    15a4:	80 83       	st	Z, r24

	StoreLoc++;                           // Increment the IN pointer to the next element
    15a6:	40 91 ab 02 	lds	r20, 0x02AB
    15aa:	50 91 ac 02 	lds	r21, 0x02AC
    15ae:	9a 01       	movw	r18, r20
    15b0:	2f 5f       	subi	r18, 0xFF	; 255
    15b2:	3f 4f       	sbci	r19, 0xFF	; 255
    15b4:	30 93 ac 02 	sts	0x02AC, r19
    15b8:	20 93 ab 02 	sts	0x02AB, r18
	BuffElements++;                       // Increment the total elements variable
    15bc:	80 91 af 02 	lds	r24, 0x02AF
    15c0:	8f 5f       	subi	r24, 0xFF	; 255
    15c2:	80 93 af 02 	sts	0x02AF, r24

	if (StoreLoc == (BuffType*)&RingBuffer[BuffLen])
    15c6:	2b 5a       	subi	r18, 0xAB	; 171
    15c8:	32 40       	sbci	r19, 0x02	; 2
    15ca:	31 f4       	brne	.+12     	; 0x15d8 <__vector_13+0x74>
		StoreLoc = (BuffType*)&RingBuffer[0]; // Wrap pointer if end of array reached
    15cc:	4f 53       	subi	r20, 0x3F	; 63
    15ce:	50 40       	sbci	r21, 0x00	; 0
    15d0:	50 93 ac 02 	sts	0x02AC, r21
    15d4:	40 93 ab 02 	sts	0x02AB, r20
    15d8:	ff 91       	pop	r31
    15da:	ef 91       	pop	r30
    15dc:	bf 91       	pop	r27
    15de:	af 91       	pop	r26
    15e0:	9f 91       	pop	r25
    15e2:	8f 91       	pop	r24
    15e4:	7f 91       	pop	r23
    15e6:	6f 91       	pop	r22
    15e8:	5f 91       	pop	r21
    15ea:	4f 91       	pop	r20
    15ec:	3f 91       	pop	r19
    15ee:	2f 91       	pop	r18
    15f0:	0f 90       	pop	r0
    15f2:	0f be       	out	0x3f, r0	; 63
    15f4:	0f 90       	pop	r0
    15f6:	1f 90       	pop	r1
    15f8:	18 95       	reti

000015fa <BUFF_InitialiseBuffer>:
}	

// ======================================================================================

void BUFF_InitialiseBuffer(void)
{
	StoreLoc    = (BuffType*)&RingBuffer[0]; // Set up the IN pointer to the start of the buffer
    15fa:	8b e6       	ldi	r24, 0x6B	; 107
    15fc:	92 e0       	ldi	r25, 0x02	; 2
    15fe:	90 93 ac 02 	sts	0x02AC, r25
    1602:	80 93 ab 02 	sts	0x02AB, r24
	RetrieveLoc = (BuffType*)&RingBuffer[0]; // Set up the OUT pointer to the start of the buffer
    1606:	90 93 ae 02 	sts	0x02AE, r25
    160a:	80 93 ad 02 	sts	0x02AD, r24

	BuffElements = 0;                     // Reset the buffer elements counter
    160e:	10 92 af 02 	sts	0x02AF, r1
    1612:	08 95       	ret

00001614 <BUFF_GetBuffByte>:
}

BuffType BUFF_GetBuffByte(void)
{
	if (!(BuffElements))                  // No elements in the buffer
    1614:	80 91 af 02 	lds	r24, 0x02AF
    1618:	88 23       	and	r24, r24
    161a:	19 f4       	brne	.+6      	; 0x1622 <BUFF_GetBuffByte+0xe>
		return 0;
    161c:	80 e0       	ldi	r24, 0x00	; 0
    161e:	90 e0       	ldi	r25, 0x00	; 0
    1620:	08 95       	ret

	BuffType RetrievedData = *RetrieveLoc; // Grab the stored byte into a temp variable
    1622:	20 91 ad 02 	lds	r18, 0x02AD
    1626:	30 91 ae 02 	lds	r19, 0x02AE
    162a:	f9 01       	movw	r30, r18
    162c:	91 91       	ld	r25, Z+

	RetrieveLoc++;                         // Increment the OUT pointer to the next element if flag set
    162e:	f0 93 ae 02 	sts	0x02AE, r31
    1632:	e0 93 ad 02 	sts	0x02AD, r30
	BuffElements--;                        // Decrement the total elements variable
    1636:	80 91 af 02 	lds	r24, 0x02AF
    163a:	81 50       	subi	r24, 0x01	; 1
    163c:	80 93 af 02 	sts	0x02AF, r24
	
	if (RetrieveLoc == (BuffType*)&RingBuffer[BuffLen])
    1640:	eb 5a       	subi	r30, 0xAB	; 171
    1642:	f2 40       	sbci	r31, 0x02	; 2
    1644:	31 f4       	brne	.+12     	; 0x1652 <BUFF_GetBuffByte+0x3e>
		RetrieveLoc = (BuffType*)&RingBuffer[0]; // Wrap pointer if end of array reached
    1646:	2f 53       	subi	r18, 0x3F	; 63
    1648:	30 40       	sbci	r19, 0x00	; 0
    164a:	30 93 ae 02 	sts	0x02AE, r19
    164e:	20 93 ad 02 	sts	0x02AD, r18
		
	return RetrievedData;                 // Return the retrieved data
    1652:	89 2f       	mov	r24, r25
    1654:	99 27       	eor	r25, r25
}
    1656:	08 95       	ret

00001658 <__vector_9>:
// ======================================================================================

// Timeout = ((F_CPU / 64) / (65535 * TIMEOUT_TICKSBEFORETIMEOUT)) per second
ISR(TIMER1_OVF_vect, ISR_NOBLOCK)
{
    1658:	78 94       	sei
    165a:	1f 92       	push	r1
    165c:	0f 92       	push	r0
    165e:	0f b6       	in	r0, 0x3f	; 63
    1660:	0f 92       	push	r0
    1662:	11 24       	eor	r1, r1
    1664:	8f 93       	push	r24
	if (Ticks++ == TIMEOUT_TICKSBEFORETIMEOUT)
    1666:	80 91 07 01 	lds	r24, 0x0107
    166a:	8f 5f       	subi	r24, 0xFF	; 255
    166c:	80 93 07 01 	sts	0x0107, r24
    1670:	80 91 07 01 	lds	r24, 0x0107
    1674:	87 30       	cpi	r24, 0x07	; 7
    1676:	29 f4       	brne	.+10     	; 0x1682 <__vector_9+0x2a>
	{
	   Ticks   = 0;
    1678:	10 92 07 01 	sts	0x0107, r1
	   TimeOut = TRUE;
    167c:	81 e0       	ldi	r24, 0x01	; 1
    167e:	80 93 06 01 	sts	0x0106, r24
    1682:	8f 91       	pop	r24
    1684:	0f 90       	pop	r0
    1686:	0f be       	out	0x3f, r0	; 63
    1688:	0f 90       	pop	r0
    168a:	1f 90       	pop	r1
    168c:	18 95       	reti

0000168e <TIMEOUT_SetupTimeoutTimer>:
	}
}

// ======================================================================================

void TIMEOUT_SetupTimeoutTimer(void)
{
	TCCR1A = 0;
    168e:	10 92 80 00 	sts	0x0080, r1
	TIMEOUT_TIMER_OFF();
    1692:	10 92 81 00 	sts	0x0081, r1
    1696:	10 92 07 01 	sts	0x0107, r1
    169a:	10 92 85 00 	sts	0x0085, r1
    169e:	10 92 84 00 	sts	0x0084, r1
	TCCR1C = 0;
    16a2:	10 92 82 00 	sts	0x0082, r1
	
	TIMSK1 = (1 << TOIE1); // Turn timer 1 overflow interrupt on
    16a6:	81 e0       	ldi	r24, 0x01	; 1
    16a8:	80 93 6f 00 	sts	0x006F, r24
    16ac:	08 95       	ret

000016ae <PD_SetupDFAddressCounters>:
}

void PD_SetupDFAddressCounters(void)
{
	uint32_t StartAddress = CurrAddress;
    16ae:	20 91 09 01 	lds	r18, 0x0109
    16b2:	30 91 0a 01 	lds	r19, 0x010A
    16b6:	40 91 0b 01 	lds	r20, 0x010B
    16ba:	50 91 0c 01 	lds	r21, 0x010C

	CurrPageAddress = 0;
    16be:	10 92 6a 02 	sts	0x026A, r1
    16c2:	10 92 69 02 	sts	0x0269, r1

	while (StartAddress > DataflashInfo.PageSize)      // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DataflashInfo.PageSize;         // Subtract one page's worth of bytes from the desired address
		CurrPageAddress++;
    16c6:	80 91 65 02 	lds	r24, 0x0265
    16ca:	90 91 66 02 	lds	r25, 0x0266
    16ce:	aa 27       	eor	r26, r26
    16d0:	bb 27       	eor	r27, r27
    16d2:	82 17       	cp	r24, r18
    16d4:	93 07       	cpc	r25, r19
    16d6:	a4 07       	cpc	r26, r20
    16d8:	b5 07       	cpc	r27, r21
    16da:	88 f4       	brcc	.+34     	; 0x16fe <PD_SetupDFAddressCounters+0x50>
    16dc:	60 e0       	ldi	r22, 0x00	; 0
    16de:	70 e0       	ldi	r23, 0x00	; 0
    16e0:	28 1b       	sub	r18, r24
    16e2:	39 0b       	sbc	r19, r25
    16e4:	4a 0b       	sbc	r20, r26
    16e6:	5b 0b       	sbc	r21, r27
    16e8:	6f 5f       	subi	r22, 0xFF	; 255
    16ea:	7f 4f       	sbci	r23, 0xFF	; 255
    16ec:	82 17       	cp	r24, r18
    16ee:	93 07       	cpc	r25, r19
    16f0:	a4 07       	cpc	r26, r20
    16f2:	b5 07       	cpc	r27, r21
    16f4:	a8 f3       	brcs	.-22     	; 0x16e0 <PD_SetupDFAddressCounters+0x32>
    16f6:	70 93 6a 02 	sts	0x026A, r23
    16fa:	60 93 69 02 	sts	0x0269, r22
	}
	
	CurrBuffByte = (uint16_t)StartAddress;              // The buffer byte is the remainder
    16fe:	30 93 63 02 	sts	0x0263, r19
    1702:	20 93 62 02 	sts	0x0262, r18
    1706:	08 95       	ret

00001708 <PD_StoreDataflashByte>:
}

void PD_StoreDataflashByte(uint8_t Data)
{
    1708:	cf 93       	push	r28
    170a:	c8 2f       	mov	r28, r24
	if (CurrBuffByte == DataflashInfo.PageSize)
    170c:	20 91 62 02 	lds	r18, 0x0262
    1710:	30 91 63 02 	lds	r19, 0x0263
    1714:	80 91 65 02 	lds	r24, 0x0265
    1718:	90 91 66 02 	lds	r25, 0x0266
    171c:	28 17       	cp	r18, r24
    171e:	39 07       	cpc	r19, r25
    1720:	a9 f4       	brne	.+42     	; 0x174c <PD_StoreDataflashByte+0x44>
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
    1722:	80 91 69 02 	lds	r24, 0x0269
    1726:	90 91 6a 02 	lds	r25, 0x026A
    172a:	9c 01       	movw	r18, r24
    172c:	01 96       	adiw	r24, 0x01	; 1
    172e:	90 93 6a 02 	sts	0x026A, r25
    1732:	80 93 69 02 	sts	0x0269, r24
    1736:	c9 01       	movw	r24, r18
    1738:	0e 94 65 0a 	call	0x14ca <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    173c:	80 e0       	ldi	r24, 0x00	; 0
    173e:	90 e0       	ldi	r25, 0x00	; 0
    1740:	0e 94 a3 09 	call	0x1346 <DF_BufferWriteEnable>
		CurrBuffByte = 0;
    1744:	10 92 63 02 	sts	0x0263, r1
    1748:	10 92 62 02 	sts	0x0262, r1
	}
	
	USI_SPITransmit(Data);                                 // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    174c:	8c 2f       	mov	r24, r28
    174e:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
	CurrBuffByte++;
    1752:	80 91 62 02 	lds	r24, 0x0262
    1756:	90 91 63 02 	lds	r25, 0x0263
    175a:	01 96       	adiw	r24, 0x01	; 1
    175c:	90 93 63 02 	sts	0x0263, r25
    1760:	80 93 62 02 	sts	0x0262, r24
    1764:	cf 91       	pop	r28
    1766:	08 95       	ret

00001768 <PD_InterpretAVRISPPacket>:
    1768:	df 92       	push	r13
    176a:	ef 92       	push	r14
    176c:	ff 92       	push	r15
    176e:	0f 93       	push	r16
    1770:	1f 93       	push	r17
    1772:	cf 93       	push	r28
    1774:	df 93       	push	r29
    1776:	dd 24       	eor	r13, r13
    1778:	80 91 12 01 	lds	r24, 0x0112
    177c:	99 27       	eor	r25, r25
    177e:	86 31       	cpi	r24, 0x16	; 22
    1780:	91 05       	cpc	r25, r1
    1782:	09 f4       	brne	.+2      	; 0x1786 <PD_InterpretAVRISPPacket+0x1e>
    1784:	00 c1       	rjmp	.+512    	; 0x1986 <PD_InterpretAVRISPPacket+0x21e>
    1786:	87 31       	cpi	r24, 0x17	; 23
    1788:	91 05       	cpc	r25, r1
    178a:	b4 f4       	brge	.+44     	; 0x17b8 <PD_InterpretAVRISPPacket+0x50>
    178c:	82 31       	cpi	r24, 0x12	; 18
    178e:	91 05       	cpc	r25, r1
    1790:	09 f4       	brne	.+2      	; 0x1794 <PD_InterpretAVRISPPacket+0x2c>
    1792:	6f c0       	rjmp	.+222    	; 0x1872 <PD_InterpretAVRISPPacket+0x10a>
    1794:	83 31       	cpi	r24, 0x13	; 19
    1796:	91 05       	cpc	r25, r1
    1798:	3c f4       	brge	.+14     	; 0x17a8 <PD_InterpretAVRISPPacket+0x40>
    179a:	80 31       	cpi	r24, 0x10	; 16
    179c:	91 05       	cpc	r25, r1
    179e:	31 f1       	breq	.+76     	; 0x17ec <PD_InterpretAVRISPPacket+0x84>
    17a0:	41 97       	sbiw	r24, 0x11	; 17
    17a2:	09 f4       	brne	.+2      	; 0x17a6 <PD_InterpretAVRISPPacket+0x3e>
    17a4:	46 c0       	rjmp	.+140    	; 0x1832 <PD_InterpretAVRISPPacket+0xca>
    17a6:	40 c1       	rjmp	.+640    	; 0x1a28 <PD_InterpretAVRISPPacket+0x2c0>
    17a8:	84 31       	cpi	r24, 0x14	; 20
    17aa:	91 05       	cpc	r25, r1
    17ac:	09 f4       	brne	.+2      	; 0x17b0 <PD_InterpretAVRISPPacket+0x48>
    17ae:	8a c0       	rjmp	.+276    	; 0x18c4 <PD_InterpretAVRISPPacket+0x15c>
    17b0:	45 97       	sbiw	r24, 0x15	; 21
    17b2:	0c f0       	brlt	.+2      	; 0x17b6 <PD_InterpretAVRISPPacket+0x4e>
    17b4:	af c0       	rjmp	.+350    	; 0x1914 <PD_InterpretAVRISPPacket+0x1ac>
    17b6:	7f c0       	rjmp	.+254    	; 0x18b6 <PD_InterpretAVRISPPacket+0x14e>
    17b8:	89 31       	cpi	r24, 0x19	; 25
    17ba:	91 05       	cpc	r25, r1
    17bc:	09 f4       	brne	.+2      	; 0x17c0 <PD_InterpretAVRISPPacket+0x58>
    17be:	70 c0       	rjmp	.+224    	; 0x18a0 <PD_InterpretAVRISPPacket+0x138>
    17c0:	8a 31       	cpi	r24, 0x1A	; 26
    17c2:	91 05       	cpc	r25, r1
    17c4:	44 f4       	brge	.+16     	; 0x17d6 <PD_InterpretAVRISPPacket+0x6e>
    17c6:	87 31       	cpi	r24, 0x17	; 23
    17c8:	91 05       	cpc	r25, r1
    17ca:	09 f4       	brne	.+2      	; 0x17ce <PD_InterpretAVRISPPacket+0x66>
    17cc:	69 c0       	rjmp	.+210    	; 0x18a0 <PD_InterpretAVRISPPacket+0x138>
    17ce:	48 97       	sbiw	r24, 0x18	; 24
    17d0:	09 f4       	brne	.+2      	; 0x17d4 <PD_InterpretAVRISPPacket+0x6c>
    17d2:	58 c0       	rjmp	.+176    	; 0x1884 <PD_InterpretAVRISPPacket+0x11c>
    17d4:	29 c1       	rjmp	.+594    	; 0x1a28 <PD_InterpretAVRISPPacket+0x2c0>
    17d6:	8b 31       	cpi	r24, 0x1B	; 27
    17d8:	91 05       	cpc	r25, r1
    17da:	e9 f1       	breq	.+122    	; 0x1856 <PD_InterpretAVRISPPacket+0xee>
    17dc:	8b 31       	cpi	r24, 0x1B	; 27
    17de:	91 05       	cpc	r25, r1
    17e0:	0c f4       	brge	.+2      	; 0x17e4 <PD_InterpretAVRISPPacket+0x7c>
    17e2:	50 c0       	rjmp	.+160    	; 0x1884 <PD_InterpretAVRISPPacket+0x11c>
    17e4:	4c 97       	sbiw	r24, 0x1c	; 28
    17e6:	09 f4       	brne	.+2      	; 0x17ea <PD_InterpretAVRISPPacket+0x82>
    17e8:	4d c0       	rjmp	.+154    	; 0x1884 <PD_InterpretAVRISPPacket+0x11c>
    17ea:	1e c1       	rjmp	.+572    	; 0x1a28 <PD_InterpretAVRISPPacket+0x2c0>
    17ec:	82 e0       	ldi	r24, 0x02	; 2
    17ee:	90 e0       	ldi	r25, 0x00	; 0
    17f0:	90 93 0f 01 	sts	0x010F, r25
    17f4:	80 93 0e 01 	sts	0x010E, r24
    17f8:	81 e0       	ldi	r24, 0x01	; 1
    17fa:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    17fe:	0e 94 c8 09 	call	0x1390 <DF_GetChipCharacteristics>
    1802:	80 91 64 02 	lds	r24, 0x0264
    1806:	88 23       	and	r24, r24
    1808:	59 f0       	breq	.+22     	; 0x1820 <PD_InterpretAVRISPPacket+0xb8>
    180a:	8a e9       	ldi	r24, 0x9A	; 154
    180c:	93 e0       	ldi	r25, 0x03	; 3
    180e:	0e 94 91 07 	call	0xf22 <LCD_puts_f>
    1812:	81 e0       	ldi	r24, 0x01	; 1
    1814:	80 93 0d 01 	sts	0x010D, r24
    1818:	81 b3       	in	r24, 0x11	; 17
    181a:	8f 7c       	andi	r24, 0xCF	; 207
    181c:	80 62       	ori	r24, 0x20	; 32
    181e:	17 c0       	rjmp	.+46     	; 0x184e <PD_InterpretAVRISPPacket+0xe6>
    1820:	84 e5       	ldi	r24, 0x54	; 84
    1822:	93 e0       	ldi	r25, 0x03	; 3
    1824:	0e 94 91 07 	call	0xf22 <LCD_puts_f>
    1828:	8d 2d       	mov	r24, r13
    182a:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    182e:	80 ec       	ldi	r24, 0xC0	; 192
    1830:	02 c1       	rjmp	.+516    	; 0x1a36 <PD_InterpretAVRISPPacket+0x2ce>
    1832:	82 e0       	ldi	r24, 0x02	; 2
    1834:	90 e0       	ldi	r25, 0x00	; 0
    1836:	90 93 0f 01 	sts	0x010F, r25
    183a:	80 93 0e 01 	sts	0x010E, r24
    183e:	d0 92 0d 01 	sts	0x010D, r13
    1842:	8d 2d       	mov	r24, r13
    1844:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    1848:	81 b3       	in	r24, 0x11	; 17
    184a:	8f 7c       	andi	r24, 0xCF	; 207
    184c:	80 61       	ori	r24, 0x10	; 16
    184e:	81 bb       	out	0x11, r24	; 17
    1850:	d0 92 13 01 	sts	0x0113, r13
    1854:	f2 c0       	rjmp	.+484    	; 0x1a3a <PD_InterpretAVRISPPacket+0x2d2>
    1856:	84 e0       	ldi	r24, 0x04	; 4
    1858:	90 e0       	ldi	r25, 0x00	; 0
    185a:	90 93 0f 01 	sts	0x010F, r25
    185e:	80 93 0e 01 	sts	0x010E, r24
    1862:	d0 92 13 01 	sts	0x0113, r13
    1866:	82 e0       	ldi	r24, 0x02	; 2
    1868:	80 93 14 01 	sts	0x0114, r24
    186c:	d0 92 15 01 	sts	0x0115, r13
    1870:	e4 c0       	rjmp	.+456    	; 0x1a3a <PD_InterpretAVRISPPacket+0x2d2>
    1872:	82 e0       	ldi	r24, 0x02	; 2
    1874:	90 e0       	ldi	r25, 0x00	; 0
    1876:	90 93 0f 01 	sts	0x010F, r25
    187a:	80 93 0e 01 	sts	0x010E, r24
    187e:	e1 e0       	ldi	r30, 0x01	; 1
    1880:	de 2e       	mov	r13, r30
    1882:	7e c0       	rjmp	.+252    	; 0x1980 <PD_InterpretAVRISPPacket+0x218>
    1884:	84 e0       	ldi	r24, 0x04	; 4
    1886:	90 e0       	ldi	r25, 0x00	; 0
    1888:	90 93 0f 01 	sts	0x010F, r25
    188c:	80 93 0e 01 	sts	0x010E, r24
    1890:	10 92 13 01 	sts	0x0113, r1
    1894:	8f ef       	ldi	r24, 0xFF	; 255
    1896:	80 93 14 01 	sts	0x0114, r24
    189a:	10 92 15 01 	sts	0x0115, r1
    189e:	cd c0       	rjmp	.+410    	; 0x1a3a <PD_InterpretAVRISPPacket+0x2d2>
    18a0:	83 e0       	ldi	r24, 0x03	; 3
    18a2:	90 e0       	ldi	r25, 0x00	; 0
    18a4:	90 93 0f 01 	sts	0x010F, r25
    18a8:	80 93 0e 01 	sts	0x010E, r24
    18ac:	10 92 13 01 	sts	0x0113, r1
    18b0:	10 92 14 01 	sts	0x0114, r1
    18b4:	c2 c0       	rjmp	.+388    	; 0x1a3a <PD_InterpretAVRISPPacket+0x2d2>
    18b6:	82 e0       	ldi	r24, 0x02	; 2
    18b8:	90 e0       	ldi	r25, 0x00	; 0
    18ba:	90 93 0f 01 	sts	0x010F, r25
    18be:	80 93 0e 01 	sts	0x010E, r24
    18c2:	5e c0       	rjmp	.+188    	; 0x1980 <PD_InterpretAVRISPPacket+0x218>
    18c4:	80 91 13 01 	lds	r24, 0x0113
    18c8:	99 27       	eor	r25, r25
    18ca:	98 2f       	mov	r25, r24
    18cc:	88 27       	eor	r24, r24
    18ce:	20 91 14 01 	lds	r18, 0x0114
    18d2:	33 27       	eor	r19, r19
    18d4:	82 2b       	or	r24, r18
    18d6:	93 2b       	or	r25, r19
    18d8:	03 96       	adiw	r24, 0x03	; 3
    18da:	90 93 0f 01 	sts	0x010F, r25
    18de:	80 93 0e 01 	sts	0x010E, r24
    18e2:	21 e0       	ldi	r18, 0x01	; 1
    18e4:	30 e0       	ldi	r19, 0x00	; 0
    18e6:	02 97       	sbiw	r24, 0x02	; 2
    18e8:	28 17       	cp	r18, r24
    18ea:	39 07       	cpc	r19, r25
    18ec:	48 f4       	brcc	.+18     	; 0x1900 <PD_InterpretAVRISPPacket+0x198>
    18ee:	4f ef       	ldi	r20, 0xFF	; 255
    18f0:	e3 e1       	ldi	r30, 0x13	; 19
    18f2:	f1 e0       	ldi	r31, 0x01	; 1
    18f4:	41 93       	st	Z+, r20
    18f6:	2f 5f       	subi	r18, 0xFF	; 255
    18f8:	3f 4f       	sbci	r19, 0xFF	; 255
    18fa:	28 17       	cp	r18, r24
    18fc:	39 07       	cpc	r19, r25
    18fe:	d0 f3       	brcs	.-12     	; 0x18f4 <PD_InterpretAVRISPPacket+0x18c>
    1900:	10 92 13 01 	sts	0x0113, r1
    1904:	e0 91 0e 01 	lds	r30, 0x010E
    1908:	f0 91 0f 01 	lds	r31, 0x010F
    190c:	ef 5e       	subi	r30, 0xEF	; 239
    190e:	fe 4f       	sbci	r31, 0xFE	; 254
    1910:	10 82       	st	Z, r1
    1912:	93 c0       	rjmp	.+294    	; 0x1a3a <PD_InterpretAVRISPPacket+0x2d2>
    1914:	0e 94 57 0b 	call	0x16ae <PD_SetupDFAddressCounters>
    1918:	80 91 69 02 	lds	r24, 0x0269
    191c:	90 91 6a 02 	lds	r25, 0x026A
    1920:	0e 94 30 0a 	call	0x1460 <DF_CopyFlashPageToBuffer>
    1924:	80 91 62 02 	lds	r24, 0x0262
    1928:	90 91 63 02 	lds	r25, 0x0263
    192c:	0e 94 a3 09 	call	0x1346 <DF_BufferWriteEnable>
    1930:	80 91 13 01 	lds	r24, 0x0113
    1934:	99 27       	eor	r25, r25
    1936:	d8 2f       	mov	r29, r24
    1938:	cc 27       	eor	r28, r28
    193a:	80 91 14 01 	lds	r24, 0x0114
    193e:	99 27       	eor	r25, r25
    1940:	c8 2b       	or	r28, r24
    1942:	d9 2b       	or	r29, r25
    1944:	00 e0       	ldi	r16, 0x00	; 0
    1946:	10 e0       	ldi	r17, 0x00	; 0
    1948:	0c 17       	cp	r16, r28
    194a:	1d 07       	cpc	r17, r29
    194c:	c8 f4       	brcc	.+50     	; 0x1980 <PD_InterpretAVRISPPacket+0x218>
    194e:	5c e1       	ldi	r21, 0x1C	; 28
    1950:	e5 2e       	mov	r14, r21
    1952:	51 e0       	ldi	r21, 0x01	; 1
    1954:	f5 2e       	mov	r15, r21
    1956:	f7 01       	movw	r30, r14
    1958:	81 91       	ld	r24, Z+
    195a:	7f 01       	movw	r14, r30
    195c:	0e 94 84 0b 	call	0x1708 <PD_StoreDataflashByte>
    1960:	80 91 62 02 	lds	r24, 0x0262
    1964:	90 91 63 02 	lds	r25, 0x0263
    1968:	01 96       	adiw	r24, 0x01	; 1
    196a:	90 93 63 02 	sts	0x0263, r25
    196e:	80 93 62 02 	sts	0x0262, r24
    1972:	0e 94 3d 0e 	call	0x1c7a <V2P_IncrementCurrAddress>
    1976:	0f 5f       	subi	r16, 0xFF	; 255
    1978:	1f 4f       	sbci	r17, 0xFF	; 255
    197a:	0c 17       	cp	r16, r28
    197c:	1d 07       	cpc	r17, r29
    197e:	58 f3       	brcs	.-42     	; 0x1956 <PD_InterpretAVRISPPacket+0x1ee>
    1980:	10 92 13 01 	sts	0x0113, r1
    1984:	5a c0       	rjmp	.+180    	; 0x1a3a <PD_InterpretAVRISPPacket+0x2d2>
    1986:	0e 94 57 0b 	call	0x16ae <PD_SetupDFAddressCounters>
    198a:	80 91 69 02 	lds	r24, 0x0269
    198e:	90 91 6a 02 	lds	r25, 0x026A
    1992:	0e 94 30 0a 	call	0x1460 <DF_CopyFlashPageToBuffer>
    1996:	80 91 13 01 	lds	r24, 0x0113
    199a:	99 27       	eor	r25, r25
    199c:	d8 2f       	mov	r29, r24
    199e:	cc 27       	eor	r28, r28
    19a0:	80 91 14 01 	lds	r24, 0x0114
    19a4:	99 27       	eor	r25, r25
    19a6:	c8 2b       	or	r28, r24
    19a8:	d9 2b       	or	r29, r25
    19aa:	00 e0       	ldi	r16, 0x00	; 0
    19ac:	10 e0       	ldi	r17, 0x00	; 0
    19ae:	0c 17       	cp	r16, r28
    19b0:	1d 07       	cpc	r17, r29
    19b2:	70 f5       	brcc	.+92     	; 0x1a10 <PD_InterpretAVRISPPacket+0x2a8>
    19b4:	34 e1       	ldi	r19, 0x14	; 20
    19b6:	e3 2e       	mov	r14, r19
    19b8:	31 e0       	ldi	r19, 0x01	; 1
    19ba:	f3 2e       	mov	r15, r19
    19bc:	20 91 62 02 	lds	r18, 0x0262
    19c0:	30 91 63 02 	lds	r19, 0x0263
    19c4:	80 91 65 02 	lds	r24, 0x0265
    19c8:	90 91 66 02 	lds	r25, 0x0266
    19cc:	28 17       	cp	r18, r24
    19ce:	39 07       	cpc	r19, r25
    19d0:	41 f4       	brne	.+16     	; 0x19e2 <PD_InterpretAVRISPPacket+0x27a>
    19d2:	0e 94 57 0b 	call	0x16ae <PD_SetupDFAddressCounters>
    19d6:	80 91 69 02 	lds	r24, 0x0269
    19da:	90 91 6a 02 	lds	r25, 0x026A
    19de:	0e 94 30 0a 	call	0x1460 <DF_CopyFlashPageToBuffer>
    19e2:	80 91 62 02 	lds	r24, 0x0262
    19e6:	90 91 63 02 	lds	r25, 0x0263
    19ea:	9c 01       	movw	r18, r24
    19ec:	01 96       	adiw	r24, 0x01	; 1
    19ee:	90 93 63 02 	sts	0x0263, r25
    19f2:	80 93 62 02 	sts	0x0262, r24
    19f6:	c9 01       	movw	r24, r18
    19f8:	0e 94 35 09 	call	0x126a <DF_ReadBufferByte>
    19fc:	f7 01       	movw	r30, r14
    19fe:	81 93       	st	Z+, r24
    1a00:	7f 01       	movw	r14, r30
    1a02:	0e 94 3d 0e 	call	0x1c7a <V2P_IncrementCurrAddress>
    1a06:	0f 5f       	subi	r16, 0xFF	; 255
    1a08:	1f 4f       	sbci	r17, 0xFF	; 255
    1a0a:	0c 17       	cp	r16, r28
    1a0c:	1d 07       	cpc	r17, r29
    1a0e:	b0 f2       	brcs	.-84     	; 0x19bc <PD_InterpretAVRISPPacket+0x254>
    1a10:	23 96       	adiw	r28, 0x03	; 3
    1a12:	d0 93 0f 01 	sts	0x010F, r29
    1a16:	c0 93 0e 01 	sts	0x010E, r28
    1a1a:	23 97       	sbiw	r28, 0x03	; 3
    1a1c:	10 92 13 01 	sts	0x0113, r1
    1a20:	ce 5e       	subi	r28, 0xEE	; 238
    1a22:	de 4f       	sbci	r29, 0xFE	; 254
    1a24:	1a 82       	std	Y+2, r1	; 0x02
    1a26:	09 c0       	rjmp	.+18     	; 0x1a3a <PD_InterpretAVRISPPacket+0x2d2>
    1a28:	81 e0       	ldi	r24, 0x01	; 1
    1a2a:	90 e0       	ldi	r25, 0x00	; 0
    1a2c:	90 93 0f 01 	sts	0x010F, r25
    1a30:	80 93 0e 01 	sts	0x010E, r24
    1a34:	89 ec       	ldi	r24, 0xC9	; 201
    1a36:	80 93 13 01 	sts	0x0113, r24
    1a3a:	0e 94 65 0d 	call	0x1aca <V2P_SendPacket>
    1a3e:	dd 20       	and	r13, r13
    1a40:	d9 f0       	breq	.+54     	; 0x1a78 <PD_InterpretAVRISPPacket+0x310>
    1a42:	80 e1       	ldi	r24, 0x10	; 16
    1a44:	92 e0       	ldi	r25, 0x02	; 2
    1a46:	0e 94 91 07 	call	0xf22 <LCD_puts_f>
    1a4a:	c0 e0       	ldi	r28, 0x00	; 0
    1a4c:	d0 e0       	ldi	r29, 0x00	; 0
    1a4e:	80 91 67 02 	lds	r24, 0x0267
    1a52:	90 91 68 02 	lds	r25, 0x0268
    1a56:	23 e0       	ldi	r18, 0x03	; 3
    1a58:	96 95       	lsr	r25
    1a5a:	87 95       	ror	r24
    1a5c:	2a 95       	dec	r18
    1a5e:	e1 f7       	brne	.-8      	; 0x1a58 <PD_InterpretAVRISPPacket+0x2f0>
    1a60:	c8 17       	cp	r28, r24
    1a62:	d9 07       	cpc	r29, r25
    1a64:	28 f4       	brcc	.+10     	; 0x1a70 <PD_InterpretAVRISPPacket+0x308>
    1a66:	ce 01       	movw	r24, r28
    1a68:	0e 94 07 0a 	call	0x140e <DF_EraseBlock>
    1a6c:	21 96       	adiw	r28, 0x01	; 1
    1a6e:	ef cf       	rjmp	.-34     	; 0x1a4e <PD_InterpretAVRISPPacket+0x2e6>
    1a70:	8a e9       	ldi	r24, 0x9A	; 154
    1a72:	93 e0       	ldi	r25, 0x03	; 3
    1a74:	0e 94 91 07 	call	0xf22 <LCD_puts_f>
    1a78:	df 91       	pop	r29
    1a7a:	cf 91       	pop	r28
    1a7c:	1f 91       	pop	r17
    1a7e:	0f 91       	pop	r16
    1a80:	ff 90       	pop	r15
    1a82:	ef 90       	pop	r14
    1a84:	df 90       	pop	r13
    1a86:	08 95       	ret

00001a88 <V2P_GetChecksum>:
	
	/* Checksum for the V2 protocol is comprised of an XOR of all the packet 
      bytes, including the start, sequence number, size and token bytes.    */
	
	CheckSumByte  = MESSAGE_START;
    1a88:	6b e1       	ldi	r22, 0x1B	; 27
	CheckSumByte ^= SequenceNum;
    1a8a:	80 91 10 01 	lds	r24, 0x0110
    1a8e:	68 27       	eor	r22, r24
	CheckSumByte ^= (uint8_t)(MessageSize >> 8);
    1a90:	20 91 0e 01 	lds	r18, 0x010E
    1a94:	30 91 0f 01 	lds	r19, 0x010F
    1a98:	83 2f       	mov	r24, r19
    1a9a:	99 27       	eor	r25, r25
    1a9c:	68 27       	eor	r22, r24
	CheckSumByte ^= (uint8_t)(MessageSize);
    1a9e:	80 91 0e 01 	lds	r24, 0x010E
    1aa2:	68 27       	eor	r22, r24
	CheckSumByte ^= TOKEN;
    1aa4:	8e e0       	ldi	r24, 0x0E	; 14
    1aa6:	68 27       	eor	r22, r24
	
	for (uint16_t CByteIndex = 0; CByteIndex < MessageSize; CByteIndex++)
    1aa8:	40 e0       	ldi	r20, 0x00	; 0
    1aaa:	50 e0       	ldi	r21, 0x00	; 0
    1aac:	42 17       	cp	r20, r18
    1aae:	53 07       	cpc	r21, r19
    1ab0:	48 f4       	brcc	.+18     	; 0x1ac4 <V2P_GetChecksum+0x3c>
    1ab2:	e2 e1       	ldi	r30, 0x12	; 18
    1ab4:	f1 e0       	ldi	r31, 0x01	; 1
	   CheckSumByte ^= PacketBytes[CByteIndex];
    1ab6:	81 91       	ld	r24, Z+
    1ab8:	68 27       	eor	r22, r24
    1aba:	4f 5f       	subi	r20, 0xFF	; 255
    1abc:	5f 4f       	sbci	r21, 0xFF	; 255
    1abe:	42 17       	cp	r20, r18
    1ac0:	53 07       	cpc	r21, r19
    1ac2:	c8 f3       	brcs	.-14     	; 0x1ab6 <V2P_GetChecksum+0x2e>

	return CheckSumByte;
}
    1ac4:	86 2f       	mov	r24, r22
    1ac6:	99 27       	eor	r25, r25
    1ac8:	08 95       	ret

00001aca <V2P_SendPacket>:
    1aca:	0f 93       	push	r16
    1acc:	1f 93       	push	r17
    1ace:	cf 93       	push	r28
    1ad0:	df 93       	push	r29
    1ad2:	8b e1       	ldi	r24, 0x1B	; 27
    1ad4:	0e 94 5c 08 	call	0x10b8 <USART_Tx>
    1ad8:	80 91 10 01 	lds	r24, 0x0110
    1adc:	0e 94 5c 08 	call	0x10b8 <USART_Tx>
    1ae0:	80 91 0f 01 	lds	r24, 0x010F
    1ae4:	0e 94 5c 08 	call	0x10b8 <USART_Tx>
    1ae8:	80 91 0e 01 	lds	r24, 0x010E
    1aec:	0e 94 5c 08 	call	0x10b8 <USART_Tx>
    1af0:	8e e0       	ldi	r24, 0x0E	; 14
    1af2:	0e 94 5c 08 	call	0x10b8 <USART_Tx>
    1af6:	c0 e0       	ldi	r28, 0x00	; 0
    1af8:	d0 e0       	ldi	r29, 0x00	; 0
    1afa:	80 91 0e 01 	lds	r24, 0x010E
    1afe:	90 91 0f 01 	lds	r25, 0x010F
    1b02:	c8 17       	cp	r28, r24
    1b04:	d9 07       	cpc	r29, r25
    1b06:	78 f4       	brcc	.+30     	; 0x1b26 <V2P_SendPacket+0x5c>
    1b08:	02 e1       	ldi	r16, 0x12	; 18
    1b0a:	11 e0       	ldi	r17, 0x01	; 1
    1b0c:	f8 01       	movw	r30, r16
    1b0e:	81 91       	ld	r24, Z+
    1b10:	8f 01       	movw	r16, r30
    1b12:	0e 94 5c 08 	call	0x10b8 <USART_Tx>
    1b16:	21 96       	adiw	r28, 0x01	; 1
    1b18:	80 91 0e 01 	lds	r24, 0x010E
    1b1c:	90 91 0f 01 	lds	r25, 0x010F
    1b20:	c8 17       	cp	r28, r24
    1b22:	d9 07       	cpc	r29, r25
    1b24:	98 f3       	brcs	.-26     	; 0x1b0c <V2P_SendPacket+0x42>
    1b26:	0e 94 44 0d 	call	0x1a88 <V2P_GetChecksum>
    1b2a:	0e 94 5c 08 	call	0x10b8 <USART_Tx>
    1b2e:	80 91 10 01 	lds	r24, 0x0110
    1b32:	90 91 11 01 	lds	r25, 0x0111
    1b36:	01 96       	adiw	r24, 0x01	; 1
    1b38:	90 93 11 01 	sts	0x0111, r25
    1b3c:	80 93 10 01 	sts	0x0110, r24
    1b40:	df 91       	pop	r29
    1b42:	cf 91       	pop	r28
    1b44:	1f 91       	pop	r17
    1b46:	0f 91       	pop	r16
    1b48:	08 95       	ret

00001b4a <V2P_GetSetParamater>:

void V2P_GetSetParamater(void)
{
	uint8_t Param_Name = PacketBytes[1];    // Save the parameter number
    1b4a:	20 91 13 01 	lds	r18, 0x0113

	MessageSize = 3;                        // Set the default response message size to 3 bytes     
    1b4e:	83 e0       	ldi	r24, 0x03	; 3
    1b50:	90 e0       	ldi	r25, 0x00	; 0
    1b52:	90 93 0f 01 	sts	0x010F, r25
    1b56:	80 93 0e 01 	sts	0x010E, r24
	PacketBytes[1] = STATUS_CMD_OK;         // Set the default response to OK
    1b5a:	10 92 13 01 	sts	0x0113, r1

	switch (Param_Name)                    // Switch based on the recieved parameter byte
    1b5e:	e2 2f       	mov	r30, r18
    1b60:	ff 27       	eor	r31, r31
    1b62:	e8 39       	cpi	r30, 0x98	; 152
    1b64:	f1 05       	cpc	r31, r1
    1b66:	ac f4       	brge	.+42     	; 0x1b92 <V2P_GetSetParamater+0x48>
    1b68:	e6 39       	cpi	r30, 0x96	; 150
    1b6a:	f1 05       	cpc	r31, r1
    1b6c:	0c f0       	brlt	.+2      	; 0x1b70 <V2P_GetSetParamater+0x26>
    1b6e:	6b c0       	rjmp	.+214    	; 0x1c46 <V2P_GetSetParamater+0xfc>
    1b70:	e1 38       	cpi	r30, 0x81	; 129
    1b72:	f1 05       	cpc	r31, r1
    1b74:	f9 f0       	breq	.+62     	; 0x1bb4 <V2P_GetSetParamater+0x6a>
    1b76:	e2 38       	cpi	r30, 0x82	; 130
    1b78:	f1 05       	cpc	r31, r1
    1b7a:	24 f4       	brge	.+8      	; 0x1b84 <V2P_GetSetParamater+0x3a>
    1b7c:	e0 38       	cpi	r30, 0x80	; 128
    1b7e:	f1 05       	cpc	r31, r1
    1b80:	b9 f0       	breq	.+46     	; 0x1bb0 <V2P_GetSetParamater+0x66>
    1b82:	6f c0       	rjmp	.+222    	; 0x1c62 <V2P_GetSetParamater+0x118>
    1b84:	cf 01       	movw	r24, r30
    1b86:	80 59       	subi	r24, 0x90	; 144
    1b88:	90 40       	sbci	r25, 0x00	; 0
    1b8a:	03 97       	sbiw	r24, 0x03	; 3
    1b8c:	08 f0       	brcs	.+2      	; 0x1b90 <V2P_GetSetParamater+0x46>
    1b8e:	69 c0       	rjmp	.+210    	; 0x1c62 <V2P_GetSetParamater+0x118>
    1b90:	13 c0       	rjmp	.+38     	; 0x1bb8 <V2P_GetSetParamater+0x6e>
    1b92:	ee 39       	cpi	r30, 0x9E	; 158
    1b94:	f1 05       	cpc	r31, r1
    1b96:	09 f4       	brne	.+2      	; 0x1b9a <V2P_GetSetParamater+0x50>
    1b98:	3b c0       	rjmp	.+118    	; 0x1c10 <V2P_GetSetParamater+0xc6>
    1b9a:	ef 39       	cpi	r30, 0x9F	; 159
    1b9c:	f1 05       	cpc	r31, r1
    1b9e:	24 f4       	brge	.+8      	; 0x1ba8 <V2P_GetSetParamater+0x5e>
    1ba0:	e8 39       	cpi	r30, 0x98	; 152
    1ba2:	f1 05       	cpc	r31, r1
    1ba4:	f9 f0       	breq	.+62     	; 0x1be4 <V2P_GetSetParamater+0x9a>
    1ba6:	5d c0       	rjmp	.+186    	; 0x1c62 <V2P_GetSetParamater+0x118>
    1ba8:	ef 39       	cpi	r30, 0x9F	; 159
    1baa:	f1 05       	cpc	r31, r1
    1bac:	49 f0       	breq	.+18     	; 0x1bc0 <V2P_GetSetParamater+0x76>
    1bae:	59 c0       	rjmp	.+178    	; 0x1c62 <V2P_GetSetParamater+0x118>
	{
		case PARAM_BUILD_NUMBER_LOW:
			PacketBytes[2] = VERSION_MINOR;
    1bb0:	83 e0       	ldi	r24, 0x03	; 3
    1bb2:	37 c0       	rjmp	.+110    	; 0x1c22 <V2P_GetSetParamater+0xd8>

			break;
		case PARAM_BUILD_NUMBER_HIGH:
			PacketBytes[2] = VERSION_MAJOR;
    1bb4:	81 e0       	ldi	r24, 0x01	; 1
    1bb6:	35 c0       	rjmp	.+106    	; 0x1c22 <V2P_GetSetParamater+0xd8>

			break;
		case PARAM_HARDWARE_VERSION:
		case PARAM_SW_MAJOR:
		case PARAM_SW_MINOR:
			PacketBytes[2] = pgm_read_byte(&VersionData[Param_Name - PARAM_HARDWARE_VERSION]);
    1bb8:	ea 5d       	subi	r30, 0xDA	; 218
    1bba:	fc 4f       	sbci	r31, 0xFC	; 252
    1bbc:	84 91       	lpm	r24, Z
    1bbe:	31 c0       	rjmp	.+98     	; 0x1c22 <V2P_GetSetParamater+0xd8>

			break;
		case PARAM_CONTROLLER_INIT:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1bc0:	80 91 12 01 	lds	r24, 0x0112
    1bc4:	83 30       	cpi	r24, 0x03	; 3
    1bc6:	19 f4       	brne	.+6      	; 0x1bce <V2P_GetSetParamater+0x84>
			{
				PacketBytes[2] = Param_ControllerInit;
    1bc8:	80 91 08 01 	lds	r24, 0x0108
    1bcc:	2a c0       	rjmp	.+84     	; 0x1c22 <V2P_GetSetParamater+0xd8>
			}
			else
			{
				MessageSize = 2;
    1bce:	82 e0       	ldi	r24, 0x02	; 2
    1bd0:	90 e0       	ldi	r25, 0x00	; 0
    1bd2:	90 93 0f 01 	sts	0x010F, r25
    1bd6:	80 93 0e 01 	sts	0x010E, r24
				Param_ControllerInit = PacketBytes[2];
    1bda:	80 91 14 01 	lds	r24, 0x0114
    1bde:	80 93 08 01 	sts	0x0108, r24
			}
			
			break;
    1be2:	48 c0       	rjmp	.+144    	; 0x1c74 <V2P_GetSetParamater+0x12a>
		case PARAM_SCK_DURATION:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1be4:	80 91 12 01 	lds	r24, 0x0112
    1be8:	a1 e0       	ldi	r26, 0x01	; 1
    1bea:	b0 e0       	ldi	r27, 0x00	; 0
    1bec:	83 30       	cpi	r24, 0x03	; 3
    1bee:	b1 f0       	breq	.+44     	; 0x1c1c <V2P_GetSetParamater+0xd2>
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.SCKDuration);
			}
			else
			{
				MessageSize = 2;
    1bf0:	82 e0       	ldi	r24, 0x02	; 2
    1bf2:	90 e0       	ldi	r25, 0x00	; 0
    1bf4:	90 93 0f 01 	sts	0x010F, r25
    1bf8:	80 93 0e 01 	sts	0x010E, r24
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    1bfc:	80 91 14 01 	lds	r24, 0x0114
  asm volatile (
    1c00:	08 2e       	mov	r0, r24
    1c02:	0e 94 7d 19 	call	0x32fa <__eeprom_write_byte_1F2021>
				eeprom_write_byte(&EEPROMVars.SCKDuration, PacketBytes[2]);
				USI_SPISetSpeed(PacketBytes[2]); // Re-Initialise the USI system with the new frequency
    1c06:	80 91 14 01 	lds	r24, 0x0114
    1c0a:	0e 94 b9 08 	call	0x1172 <USI_SPISetSpeed>
			}
					
			break;
    1c0e:	32 c0       	rjmp	.+100    	; 0x1c74 <V2P_GetSetParamater+0x12a>
		case PARAM_RESET_POLARITY:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1c10:	80 91 12 01 	lds	r24, 0x0112
    1c14:	a0 e0       	ldi	r26, 0x00	; 0
    1c16:	b0 e0       	ldi	r27, 0x00	; 0
    1c18:	83 30       	cpi	r24, 0x03	; 3
    1c1a:	31 f4       	brne	.+12     	; 0x1c28 <V2P_GetSetParamater+0xde>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1c1c:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
    1c20:	80 2d       	mov	r24, r0
    1c22:	80 93 14 01 	sts	0x0114, r24
    1c26:	26 c0       	rjmp	.+76     	; 0x1c74 <V2P_GetSetParamater+0x12a>
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.ResetPolarity);		
			}
			else
			{
				MessageSize = 2;
    1c28:	82 e0       	ldi	r24, 0x02	; 2
    1c2a:	90 e0       	ldi	r25, 0x00	; 0
    1c2c:	90 93 0f 01 	sts	0x010F, r25
    1c30:	80 93 0e 01 	sts	0x010E, r24
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    1c34:	80 91 14 01 	lds	r24, 0x0114
  asm volatile (
    1c38:	08 2e       	mov	r0, r24
    1c3a:	0e 94 7d 19 	call	0x32fa <__eeprom_write_byte_1F2021>
				eeprom_write_byte(&EEPROMVars.ResetPolarity, PacketBytes[2]);
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Change takes effect immediatly
    1c3e:	81 e0       	ldi	r24, 0x01	; 1
    1c40:	0e 94 ff 02 	call	0x5fe <MAIN_ResetCSLine>
			}
			
			break;
    1c44:	17 c0       	rjmp	.+46     	; 0x1c74 <V2P_GetSetParamater+0x12a>
		case PARAM_OSC_PSCALE:
		case PARAM_OSC_CMATCH:
			/* Despite not supporting these parameters (STK500 only), the AVR Studio programmer
			   sends them along with the SCK duration. A OK must be returned or the sequence will fail
			   and the SCK duration byte will not be sent.                                             */
		
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1c46:	80 91 12 01 	lds	r24, 0x0112
    1c4a:	83 30       	cpi	r24, 0x03	; 3
    1c4c:	19 f4       	brne	.+6      	; 0x1c54 <V2P_GetSetParamater+0x10a>
			{
			   PacketBytes[2] = 0;            // If the command is a read, return a 0 for both parameters
    1c4e:	10 92 14 01 	sts	0x0114, r1
    1c52:	10 c0       	rjmp	.+32     	; 0x1c74 <V2P_GetSetParamater+0x12a>
			}
			else
			{
				MessageSize = 2;              // Otherwise just send back an OK if the command is a set		
    1c54:	82 e0       	ldi	r24, 0x02	; 2
    1c56:	90 e0       	ldi	r25, 0x00	; 0
    1c58:	90 93 0f 01 	sts	0x010F, r25
    1c5c:	80 93 0e 01 	sts	0x010E, r24
			}
			
			break;
    1c60:	09 c0       	rjmp	.+18     	; 0x1c74 <V2P_GetSetParamater+0x12a>
		default:                             // Unrecognised parameter
			MessageSize = 2;
    1c62:	82 e0       	ldi	r24, 0x02	; 2
    1c64:	90 e0       	ldi	r25, 0x00	; 0
    1c66:	90 93 0f 01 	sts	0x010F, r25
    1c6a:	80 93 0e 01 	sts	0x010E, r24
			PacketBytes[1] = STATUS_CMD_FAILED;			
    1c6e:	80 ec       	ldi	r24, 0xC0	; 192
    1c70:	80 93 13 01 	sts	0x0113, r24
	}
	
	V2P_SendPacket();
    1c74:	0e 94 65 0d 	call	0x1aca <V2P_SendPacket>
    1c78:	08 95       	ret

00001c7a <V2P_IncrementCurrAddress>:
}

void V2P_IncrementCurrAddress(void)
{
	// Incrementing a 32-bit unsigned variable takes a lot of code. Because much of the code is
	// not very time critical (much of it is waiting for the hardware), i've chosen to waste
	// a few extra cycles per increment and save a good 60 bytes or so of code space by putting
	// the incrmement inside a function.

	CurrAddress++;
    1c7a:	80 91 09 01 	lds	r24, 0x0109
    1c7e:	90 91 0a 01 	lds	r25, 0x010A
    1c82:	a0 91 0b 01 	lds	r26, 0x010B
    1c86:	b0 91 0c 01 	lds	r27, 0x010C
    1c8a:	01 96       	adiw	r24, 0x01	; 1
    1c8c:	a1 1d       	adc	r26, r1
    1c8e:	b1 1d       	adc	r27, r1
    1c90:	80 93 09 01 	sts	0x0109, r24
    1c94:	90 93 0a 01 	sts	0x010A, r25
    1c98:	a0 93 0b 01 	sts	0x010B, r26
    1c9c:	b0 93 0c 01 	sts	0x010C, r27
    1ca0:	08 95       	ret

00001ca2 <V2P_CheckForExtendedAddress>:
}

void V2P_CheckForExtendedAddress(void)
{
	if (CurrAddress & (1UL << 31))                     // MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
    1ca2:	80 91 09 01 	lds	r24, 0x0109
    1ca6:	90 91 0a 01 	lds	r25, 0x010A
    1caa:	a0 91 0b 01 	lds	r26, 0x010B
    1cae:	b0 91 0c 01 	lds	r27, 0x010C
    1cb2:	b7 ff       	sbrs	r27, 7
    1cb4:	1e c0       	rjmp	.+60     	; 0x1cf2 <V2P_CheckForExtendedAddress+0x50>
	{
		USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);   // Load extended address command
    1cb6:	8d e4       	ldi	r24, 0x4D	; 77
    1cb8:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1cbc:	80 e0       	ldi	r24, 0x00	; 0
    1cbe:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
		USI_SPITransmit((CurrAddress & 0x00FF0000) >> 16); // The 3rd byte of the long holds the extended address
    1cc2:	80 91 0b 01 	lds	r24, 0x010B
    1cc6:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1cca:	80 e0       	ldi	r24, 0x00	; 0
    1ccc:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
		
		CurrAddress &= ~(1UL << 31);                   // Clear the flag
    1cd0:	80 91 09 01 	lds	r24, 0x0109
    1cd4:	90 91 0a 01 	lds	r25, 0x010A
    1cd8:	a0 91 0b 01 	lds	r26, 0x010B
    1cdc:	b0 91 0c 01 	lds	r27, 0x010C
    1ce0:	bf 77       	andi	r27, 0x7F	; 127
    1ce2:	80 93 09 01 	sts	0x0109, r24
    1ce6:	90 93 0a 01 	sts	0x010A, r25
    1cea:	a0 93 0b 01 	sts	0x010B, r26
    1cee:	b0 93 0c 01 	sts	0x010C, r27
    1cf2:	08 95       	ret

00001cf4 <V2P_RunStateMachine>:
    1cf4:	ef 92       	push	r14
    1cf6:	ff 92       	push	r15
    1cf8:	0f 93       	push	r16
    1cfa:	1f 93       	push	r17
    1cfc:	cf 93       	push	r28
    1cfe:	c0 e0       	ldi	r28, 0x00	; 0
    1d00:	ee 24       	eor	r14, r14
    1d02:	ff 24       	eor	r15, r15
    1d04:	0e 94 fd 0a 	call	0x15fa <BUFF_InitialiseBuffer>
    1d08:	0e 94 47 0b 	call	0x168e <TIMEOUT_SetupTimeoutTimer>
    1d0c:	c0 93 0d 01 	sts	0x010D, r28
    1d10:	10 92 09 01 	sts	0x0109, r1
    1d14:	10 92 0a 01 	sts	0x010A, r1
    1d18:	10 92 0b 01 	sts	0x010B, r1
    1d1c:	10 92 0c 01 	sts	0x010C, r1
    1d20:	80 91 06 01 	lds	r24, 0x0106
    1d24:	81 30       	cpi	r24, 0x01	; 1
    1d26:	11 f4       	brne	.+4      	; 0x1d2c <V2P_RunStateMachine+0x38>
    1d28:	c9 e0       	ldi	r28, 0x09	; 9
    1d2a:	05 c0       	rjmp	.+10     	; 0x1d36 <V2P_RunStateMachine+0x42>
    1d2c:	cc 23       	and	r28, r28
    1d2e:	19 f0       	breq	.+6      	; 0x1d36 <V2P_RunStateMachine+0x42>
    1d30:	83 e0       	ldi	r24, 0x03	; 3
    1d32:	80 93 81 00 	sts	0x0081, r24
    1d36:	8c 2f       	mov	r24, r28
    1d38:	99 27       	eor	r25, r25
    1d3a:	84 30       	cpi	r24, 0x04	; 4
    1d3c:	91 05       	cpc	r25, r1
    1d3e:	09 f4       	brne	.+2      	; 0x1d42 <V2P_RunStateMachine+0x4e>
    1d40:	73 c0       	rjmp	.+230    	; 0x1e28 <V2P_RunStateMachine+0x134>
    1d42:	85 30       	cpi	r24, 0x05	; 5
    1d44:	91 05       	cpc	r25, r1
    1d46:	94 f4       	brge	.+36     	; 0x1d6c <V2P_RunStateMachine+0x78>
    1d48:	81 30       	cpi	r24, 0x01	; 1
    1d4a:	91 05       	cpc	r25, r1
    1d4c:	09 f4       	brne	.+2      	; 0x1d50 <V2P_RunStateMachine+0x5c>
    1d4e:	52 c0       	rjmp	.+164    	; 0x1df4 <V2P_RunStateMachine+0x100>
    1d50:	82 30       	cpi	r24, 0x02	; 2
    1d52:	91 05       	cpc	r25, r1
    1d54:	1c f4       	brge	.+6      	; 0x1d5c <V2P_RunStateMachine+0x68>
    1d56:	89 2b       	or	r24, r25
    1d58:	b1 f1       	breq	.+108    	; 0x1dc6 <V2P_RunStateMachine+0xd2>
    1d5a:	e2 cf       	rjmp	.-60     	; 0x1d20 <V2P_RunStateMachine+0x2c>
    1d5c:	82 30       	cpi	r24, 0x02	; 2
    1d5e:	91 05       	cpc	r25, r1
    1d60:	09 f4       	brne	.+2      	; 0x1d64 <V2P_RunStateMachine+0x70>
    1d62:	4e c0       	rjmp	.+156    	; 0x1e00 <V2P_RunStateMachine+0x10c>
    1d64:	03 97       	sbiw	r24, 0x03	; 3
    1d66:	09 f4       	brne	.+2      	; 0x1d6a <V2P_RunStateMachine+0x76>
    1d68:	54 c0       	rjmp	.+168    	; 0x1e12 <V2P_RunStateMachine+0x11e>
    1d6a:	da cf       	rjmp	.-76     	; 0x1d20 <V2P_RunStateMachine+0x2c>
    1d6c:	87 30       	cpi	r24, 0x07	; 7
    1d6e:	91 05       	cpc	r25, r1
    1d70:	09 f4       	brne	.+2      	; 0x1d74 <V2P_RunStateMachine+0x80>
    1d72:	8b c0       	rjmp	.+278    	; 0x1e8a <V2P_RunStateMachine+0x196>
    1d74:	88 30       	cpi	r24, 0x08	; 8
    1d76:	91 05       	cpc	r25, r1
    1d78:	44 f4       	brge	.+16     	; 0x1d8a <V2P_RunStateMachine+0x96>
    1d7a:	85 30       	cpi	r24, 0x05	; 5
    1d7c:	91 05       	cpc	r25, r1
    1d7e:	09 f4       	brne	.+2      	; 0x1d82 <V2P_RunStateMachine+0x8e>
    1d80:	68 c0       	rjmp	.+208    	; 0x1e52 <V2P_RunStateMachine+0x15e>
    1d82:	06 97       	sbiw	r24, 0x06	; 6
    1d84:	09 f4       	brne	.+2      	; 0x1d88 <V2P_RunStateMachine+0x94>
    1d86:	6d c0       	rjmp	.+218    	; 0x1e62 <V2P_RunStateMachine+0x16e>
    1d88:	cb cf       	rjmp	.-106    	; 0x1d20 <V2P_RunStateMachine+0x2c>
    1d8a:	88 30       	cpi	r24, 0x08	; 8
    1d8c:	91 05       	cpc	r25, r1
    1d8e:	79 f0       	breq	.+30     	; 0x1dae <V2P_RunStateMachine+0xba>
    1d90:	09 97       	sbiw	r24, 0x09	; 9
    1d92:	31 f6       	brne	.-116    	; 0x1d20 <V2P_RunStateMachine+0x2c>
    1d94:	82 e0       	ldi	r24, 0x02	; 2
    1d96:	90 e0       	ldi	r25, 0x00	; 0
    1d98:	90 93 0f 01 	sts	0x010F, r25
    1d9c:	80 93 0e 01 	sts	0x010E, r24
    1da0:	80 ec       	ldi	r24, 0xC0	; 192
    1da2:	80 93 13 01 	sts	0x0113, r24
    1da6:	10 92 06 01 	sts	0x0106, r1
    1daa:	0e 94 65 0d 	call	0x1aca <V2P_SendPacket>
    1dae:	0e 94 fd 0a 	call	0x15fa <BUFF_InitialiseBuffer>
    1db2:	10 92 81 00 	sts	0x0081, r1
    1db6:	10 92 07 01 	sts	0x0107, r1
    1dba:	10 92 85 00 	sts	0x0085, r1
    1dbe:	10 92 84 00 	sts	0x0084, r1
    1dc2:	c0 e0       	ldi	r28, 0x00	; 0
    1dc4:	ad cf       	rjmp	.-166    	; 0x1d20 <V2P_RunStateMachine+0x2c>
    1dc6:	80 91 af 02 	lds	r24, 0x02AF
    1dca:	81 11       	cpse	r24, r1
    1dcc:	c1 e0       	ldi	r28, 0x01	; 1
    1dce:	f2 9b       	sbis	0x1e, 2	; 30
    1dd0:	a7 cf       	rjmp	.-178    	; 0x1d20 <V2P_RunStateMachine+0x2c>
    1dd2:	80 91 0d 01 	lds	r24, 0x010D
    1dd6:	88 23       	and	r24, r24
    1dd8:	09 f0       	breq	.+2      	; 0x1ddc <V2P_RunStateMachine+0xe8>
    1dda:	a2 cf       	rjmp	.-188    	; 0x1d20 <V2P_RunStateMachine+0x2c>
    1ddc:	80 e8       	ldi	r24, 0x80	; 128
    1dde:	80 93 61 00 	sts	0x0061, r24
    1de2:	83 e0       	ldi	r24, 0x03	; 3
    1de4:	80 93 61 00 	sts	0x0061, r24
    1de8:	80 91 c1 00 	lds	r24, 0x00C1
    1dec:	80 78       	andi	r24, 0x80	; 128
    1dee:	80 93 c1 00 	sts	0x00C1, r24
    1df2:	d4 c0       	rjmp	.+424    	; 0x1f9c <V2P_RunStateMachine+0x2a8>
    1df4:	0e 94 73 08 	call	0x10e6 <USART_Rx>
    1df8:	8b 31       	cpi	r24, 0x1B	; 27
    1dfa:	89 f5       	brne	.+98     	; 0x1e5e <V2P_RunStateMachine+0x16a>
    1dfc:	c2 e0       	ldi	r28, 0x02	; 2
    1dfe:	90 cf       	rjmp	.-224    	; 0x1d20 <V2P_RunStateMachine+0x2c>
    1e00:	0e 94 73 08 	call	0x10e6 <USART_Rx>
    1e04:	99 27       	eor	r25, r25
    1e06:	90 93 11 01 	sts	0x0111, r25
    1e0a:	80 93 10 01 	sts	0x0110, r24
    1e0e:	c3 e0       	ldi	r28, 0x03	; 3
    1e10:	87 cf       	rjmp	.-242    	; 0x1d20 <V2P_RunStateMachine+0x2c>
    1e12:	0e 94 73 08 	call	0x10e6 <USART_Rx>
    1e16:	99 27       	eor	r25, r25
    1e18:	98 2f       	mov	r25, r24
    1e1a:	88 27       	eor	r24, r24
    1e1c:	90 93 0f 01 	sts	0x010F, r25
    1e20:	80 93 0e 01 	sts	0x010E, r24
    1e24:	c4 e0       	ldi	r28, 0x04	; 4
    1e26:	7c cf       	rjmp	.-264    	; 0x1d20 <V2P_RunStateMachine+0x2c>
    1e28:	0e 94 73 08 	call	0x10e6 <USART_Rx>
    1e2c:	28 2f       	mov	r18, r24
    1e2e:	33 27       	eor	r19, r19
    1e30:	80 91 0e 01 	lds	r24, 0x010E
    1e34:	90 91 0f 01 	lds	r25, 0x010F
    1e38:	82 2b       	or	r24, r18
    1e3a:	93 2b       	or	r25, r19
    1e3c:	90 93 0f 01 	sts	0x010F, r25
    1e40:	80 93 0e 01 	sts	0x010E, r24
    1e44:	83 51       	subi	r24, 0x13	; 19
    1e46:	91 40       	sbci	r25, 0x01	; 1
    1e48:	50 f4       	brcc	.+20     	; 0x1e5e <V2P_RunStateMachine+0x16a>
    1e4a:	c5 e0       	ldi	r28, 0x05	; 5
    1e4c:	ee 24       	eor	r14, r14
    1e4e:	ff 24       	eor	r15, r15
    1e50:	67 cf       	rjmp	.-306    	; 0x1d20 <V2P_RunStateMachine+0x2c>
    1e52:	0e 94 73 08 	call	0x10e6 <USART_Rx>
    1e56:	8e 30       	cpi	r24, 0x0E	; 14
    1e58:	11 f4       	brne	.+4      	; 0x1e5e <V2P_RunStateMachine+0x16a>
    1e5a:	c6 e0       	ldi	r28, 0x06	; 6
    1e5c:	61 cf       	rjmp	.-318    	; 0x1d20 <V2P_RunStateMachine+0x2c>
    1e5e:	c9 e0       	ldi	r28, 0x09	; 9
    1e60:	5f cf       	rjmp	.-322    	; 0x1d20 <V2P_RunStateMachine+0x2c>
    1e62:	80 91 0e 01 	lds	r24, 0x010E
    1e66:	90 91 0f 01 	lds	r25, 0x010F
    1e6a:	e8 16       	cp	r14, r24
    1e6c:	f9 06       	cpc	r15, r25
    1e6e:	11 f4       	brne	.+4      	; 0x1e74 <V2P_RunStateMachine+0x180>
    1e70:	c7 e0       	ldi	r28, 0x07	; 7
    1e72:	56 cf       	rjmp	.-340    	; 0x1d20 <V2P_RunStateMachine+0x2c>
    1e74:	87 01       	movw	r16, r14
    1e76:	0e 5e       	subi	r16, 0xEE	; 238
    1e78:	1e 4f       	sbci	r17, 0xFE	; 254
    1e7a:	08 94       	sec
    1e7c:	e1 1c       	adc	r14, r1
    1e7e:	f1 1c       	adc	r15, r1
    1e80:	0e 94 73 08 	call	0x10e6 <USART_Rx>
    1e84:	f8 01       	movw	r30, r16
    1e86:	80 83       	st	Z, r24
    1e88:	4b cf       	rjmp	.-362    	; 0x1d20 <V2P_RunStateMachine+0x2c>
    1e8a:	0e 94 44 0d 	call	0x1a88 <V2P_GetChecksum>
    1e8e:	18 2f       	mov	r17, r24
    1e90:	0e 94 73 08 	call	0x10e6 <USART_Rx>
    1e94:	18 17       	cp	r17, r24
    1e96:	09 f0       	breq	.+2      	; 0x1e9a <V2P_RunStateMachine+0x1a6>
    1e98:	74 c0       	rjmp	.+232    	; 0x1f82 <V2P_RunStateMachine+0x28e>
    1e9a:	80 91 12 01 	lds	r24, 0x0112
    1e9e:	99 27       	eor	r25, r25
    1ea0:	84 30       	cpi	r24, 0x04	; 4
    1ea2:	91 05       	cpc	r25, r1
    1ea4:	3c f4       	brge	.+14     	; 0x1eb4 <V2P_RunStateMachine+0x1c0>
    1ea6:	82 30       	cpi	r24, 0x02	; 2
    1ea8:	91 05       	cpc	r25, r1
    1eaa:	0c f0       	brlt	.+2      	; 0x1eae <V2P_RunStateMachine+0x1ba>
    1eac:	61 c0       	rjmp	.+194    	; 0x1f70 <V2P_RunStateMachine+0x27c>
    1eae:	01 97       	sbiw	r24, 0x01	; 1
    1eb0:	39 f0       	breq	.+14     	; 0x1ec0 <V2P_RunStateMachine+0x1cc>
    1eb2:	61 c0       	rjmp	.+194    	; 0x1f76 <V2P_RunStateMachine+0x282>
    1eb4:	86 30       	cpi	r24, 0x06	; 6
    1eb6:	91 05       	cpc	r25, r1
    1eb8:	e9 f0       	breq	.+58     	; 0x1ef4 <V2P_RunStateMachine+0x200>
    1eba:	07 97       	sbiw	r24, 0x07	; 7
    1ebc:	99 f0       	breq	.+38     	; 0x1ee4 <V2P_RunStateMachine+0x1f0>
    1ebe:	5b c0       	rjmp	.+182    	; 0x1f76 <V2P_RunStateMachine+0x282>
    1ec0:	8b e0       	ldi	r24, 0x0B	; 11
    1ec2:	90 e0       	ldi	r25, 0x00	; 0
    1ec4:	90 93 0f 01 	sts	0x010F, r25
    1ec8:	80 93 0e 01 	sts	0x010E, r24
    1ecc:	a2 e1       	ldi	r26, 0x12	; 18
    1ece:	b1 e0       	ldi	r27, 0x01	; 1
    1ed0:	eb ea       	ldi	r30, 0xAB	; 171
    1ed2:	f3 e0       	ldi	r31, 0x03	; 3
    1ed4:	9a e0       	ldi	r25, 0x0A	; 10
    1ed6:	84 91       	lpm	r24, Z
    1ed8:	8d 93       	st	X+, r24
    1eda:	91 50       	subi	r25, 0x01	; 1
    1edc:	31 96       	adiw	r30, 0x01	; 1
    1ede:	97 ff       	sbrs	r25, 7
    1ee0:	fa cf       	rjmp	.-12     	; 0x1ed6 <V2P_RunStateMachine+0x1e2>
    1ee2:	58 c0       	rjmp	.+176    	; 0x1f94 <V2P_RunStateMachine+0x2a0>
    1ee4:	82 e0       	ldi	r24, 0x02	; 2
    1ee6:	90 e0       	ldi	r25, 0x00	; 0
    1ee8:	90 93 0f 01 	sts	0x010F, r25
    1eec:	80 93 0e 01 	sts	0x010E, r24
    1ef0:	80 ec       	ldi	r24, 0xC0	; 192
    1ef2:	4e c0       	rjmp	.+156    	; 0x1f90 <V2P_RunStateMachine+0x29c>
    1ef4:	82 e0       	ldi	r24, 0x02	; 2
    1ef6:	90 e0       	ldi	r25, 0x00	; 0
    1ef8:	90 93 0f 01 	sts	0x010F, r25
    1efc:	80 93 0e 01 	sts	0x010E, r24
    1f00:	0e 94 51 0e 	call	0x1ca2 <V2P_CheckForExtendedAddress>
    1f04:	80 91 13 01 	lds	r24, 0x0113
    1f08:	99 27       	eor	r25, r25
    1f0a:	aa 27       	eor	r26, r26
    1f0c:	bb 27       	eor	r27, r27
    1f0e:	b8 2f       	mov	r27, r24
    1f10:	aa 27       	eor	r26, r26
    1f12:	99 27       	eor	r25, r25
    1f14:	88 27       	eor	r24, r24
    1f16:	20 91 14 01 	lds	r18, 0x0114
    1f1a:	33 27       	eor	r19, r19
    1f1c:	44 27       	eor	r20, r20
    1f1e:	55 27       	eor	r21, r21
    1f20:	a9 01       	movw	r20, r18
    1f22:	33 27       	eor	r19, r19
    1f24:	22 27       	eor	r18, r18
    1f26:	82 2b       	or	r24, r18
    1f28:	93 2b       	or	r25, r19
    1f2a:	a4 2b       	or	r26, r20
    1f2c:	b5 2b       	or	r27, r21
    1f2e:	20 91 15 01 	lds	r18, 0x0115
    1f32:	33 27       	eor	r19, r19
    1f34:	44 27       	eor	r20, r20
    1f36:	55 27       	eor	r21, r21
    1f38:	54 2f       	mov	r21, r20
    1f3a:	43 2f       	mov	r20, r19
    1f3c:	32 2f       	mov	r19, r18
    1f3e:	22 27       	eor	r18, r18
    1f40:	82 2b       	or	r24, r18
    1f42:	93 2b       	or	r25, r19
    1f44:	a4 2b       	or	r26, r20
    1f46:	b5 2b       	or	r27, r21
    1f48:	20 91 16 01 	lds	r18, 0x0116
    1f4c:	33 27       	eor	r19, r19
    1f4e:	44 27       	eor	r20, r20
    1f50:	55 27       	eor	r21, r21
    1f52:	82 2b       	or	r24, r18
    1f54:	93 2b       	or	r25, r19
    1f56:	a4 2b       	or	r26, r20
    1f58:	b5 2b       	or	r27, r21
    1f5a:	80 93 09 01 	sts	0x0109, r24
    1f5e:	90 93 0a 01 	sts	0x010A, r25
    1f62:	a0 93 0b 01 	sts	0x010B, r26
    1f66:	b0 93 0c 01 	sts	0x010C, r27
    1f6a:	10 92 13 01 	sts	0x0113, r1
    1f6e:	12 c0       	rjmp	.+36     	; 0x1f94 <V2P_RunStateMachine+0x2a0>
    1f70:	0e 94 a5 0d 	call	0x1b4a <V2P_GetSetParamater>
    1f74:	11 c0       	rjmp	.+34     	; 0x1f98 <V2P_RunStateMachine+0x2a4>
    1f76:	e0 91 02 01 	lds	r30, 0x0102
    1f7a:	f0 91 03 01 	lds	r31, 0x0103
    1f7e:	09 95       	icall
    1f80:	0b c0       	rjmp	.+22     	; 0x1f98 <V2P_RunStateMachine+0x2a4>
    1f82:	82 e0       	ldi	r24, 0x02	; 2
    1f84:	90 e0       	ldi	r25, 0x00	; 0
    1f86:	90 93 0f 01 	sts	0x010F, r25
    1f8a:	80 93 0e 01 	sts	0x010E, r24
    1f8e:	81 ec       	ldi	r24, 0xC1	; 193
    1f90:	80 93 13 01 	sts	0x0113, r24
    1f94:	0e 94 65 0d 	call	0x1aca <V2P_SendPacket>
    1f98:	c8 e0       	ldi	r28, 0x08	; 8
    1f9a:	c2 ce       	rjmp	.-636    	; 0x1d20 <V2P_RunStateMachine+0x2c>
    1f9c:	cf 91       	pop	r28
    1f9e:	1f 91       	pop	r17
    1fa0:	0f 91       	pop	r16
    1fa2:	ff 90       	pop	r15
    1fa4:	ef 90       	pop	r14
    1fa6:	08 95       	ret

00001fa8 <ISPCC_EnterChipProgrammingMode>:

// ======================================================================================

void ISPCC_EnterChipProgrammingMode(void)
{
    1fa8:	0f 93       	push	r16
    1faa:	1f 93       	push	r17
    1fac:	cf 93       	push	r28
	uint8_t ByteDelay = PacketBytes[5];
    1fae:	10 91 17 01 	lds	r17, 0x0117
	uint8_t Attempts  = PacketBytes[4];
    1fb2:	c0 91 16 01 	lds	r28, 0x0116
	uint8_t Response;

	MAIN_Delay1MS(PacketBytes[2]);         // Wait before continuing, amount specified in the packet
    1fb6:	80 91 14 01 	lds	r24, 0x0114
    1fba:	0e 94 ed 02 	call	0x5da <MAIN_Delay1MS>

	if ((!(Attempts)) || (Attempts > 100)) // if no attempts or too high a value is specified, a fixed number is chosen
    1fbe:	8c 2f       	mov	r24, r28
    1fc0:	81 50       	subi	r24, 0x01	; 1
    1fc2:	84 36       	cpi	r24, 0x64	; 100
    1fc4:	08 f0       	brcs	.+2      	; 0x1fc8 <ISPCC_EnterChipProgrammingMode+0x20>
	   Attempts = 24;
    1fc6:	c8 e1       	ldi	r28, 0x18	; 24
		
	while (Attempts--)
	{
		USI_SPITransmit(PacketBytes[8]);
		MAIN_Delay1MS(ByteDelay);
		USI_SPITransmit(PacketBytes[9]);
		MAIN_Delay1MS(ByteDelay);
			
		Response = USI_SPITransmit(PacketBytes[10]);
		MAIN_Delay1MS(ByteDelay);

		if (PacketBytes[7] == ISPCC_POLL_MODE_AVR)
		  USI_SPITransmit(PacketBytes[11]);
		else
		  Response = USI_SPITransmit(PacketBytes[11]);
				
		if (!(PacketBytes[7]) || (Response == PacketBytes[6])) // Polling disabled, or returned value matches expected poll value
		{
			MAIN_Delay1MS(ByteDelay);

			InProgrammingMode = TRUE;
			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = STATUS_CMD_OK;
			return;
		}
		
		MAIN_Delay1MS(ByteDelay);
		USI_SPIToggleClock();            // Out of sync, shift in one bit and try again
    1fc8:	c1 50       	subi	r28, 0x01	; 1
    1fca:	cf 3f       	cpi	r28, 0xFF	; 255
    1fcc:	09 f4       	brne	.+2      	; 0x1fd0 <ISPCC_EnterChipProgrammingMode+0x28>
    1fce:	3f c0       	rjmp	.+126    	; 0x204e <ISPCC_EnterChipProgrammingMode+0xa6>
    1fd0:	80 91 1a 01 	lds	r24, 0x011A
    1fd4:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    1fd8:	81 2f       	mov	r24, r17
    1fda:	0e 94 ed 02 	call	0x5da <MAIN_Delay1MS>
    1fde:	80 91 1b 01 	lds	r24, 0x011B
    1fe2:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    1fe6:	81 2f       	mov	r24, r17
    1fe8:	0e 94 ed 02 	call	0x5da <MAIN_Delay1MS>
    1fec:	80 91 1c 01 	lds	r24, 0x011C
    1ff0:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    1ff4:	08 2f       	mov	r16, r24
    1ff6:	81 2f       	mov	r24, r17
    1ff8:	0e 94 ed 02 	call	0x5da <MAIN_Delay1MS>
    1ffc:	80 91 19 01 	lds	r24, 0x0119
    2000:	83 30       	cpi	r24, 0x03	; 3
    2002:	29 f4       	brne	.+10     	; 0x200e <ISPCC_EnterChipProgrammingMode+0x66>
    2004:	80 91 1d 01 	lds	r24, 0x011D
    2008:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    200c:	05 c0       	rjmp	.+10     	; 0x2018 <ISPCC_EnterChipProgrammingMode+0x70>
    200e:	80 91 1d 01 	lds	r24, 0x011D
    2012:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    2016:	08 2f       	mov	r16, r24
    2018:	80 91 19 01 	lds	r24, 0x0119
    201c:	88 23       	and	r24, r24
    201e:	21 f0       	breq	.+8      	; 0x2028 <ISPCC_EnterChipProgrammingMode+0x80>
    2020:	80 91 18 01 	lds	r24, 0x0118
    2024:	08 17       	cp	r16, r24
    2026:	69 f4       	brne	.+26     	; 0x2042 <ISPCC_EnterChipProgrammingMode+0x9a>
    2028:	81 2f       	mov	r24, r17
    202a:	0e 94 ed 02 	call	0x5da <MAIN_Delay1MS>
    202e:	81 e0       	ldi	r24, 0x01	; 1
    2030:	80 93 0d 01 	sts	0x010D, r24
    2034:	81 b3       	in	r24, 0x11	; 17
    2036:	8f 7c       	andi	r24, 0xCF	; 207
    2038:	80 62       	ori	r24, 0x20	; 32
    203a:	81 bb       	out	0x11, r24	; 17
    203c:	10 92 13 01 	sts	0x0113, r1
    2040:	0d c0       	rjmp	.+26     	; 0x205c <ISPCC_EnterChipProgrammingMode+0xb4>
    2042:	81 2f       	mov	r24, r17
    2044:	0e 94 ed 02 	call	0x5da <MAIN_Delay1MS>
    2048:	0e 94 0f 09 	call	0x121e <USI_SPIToggleClock>
    204c:	bd cf       	rjmp	.-134    	; 0x1fc8 <ISPCC_EnterChipProgrammingMode+0x20>
	}

	// If function hasn't returned by now, all the attempts have failed. Show this by
	// resetting the status leds to green (ready) and send a fail message.

	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
    204e:	81 b3       	in	r24, 0x11	; 17
    2050:	8f 7c       	andi	r24, 0xCF	; 207
    2052:	80 61       	ori	r24, 0x10	; 16
    2054:	81 bb       	out	0x11, r24	; 17
	PacketBytes[1] = STATUS_CMD_FAILED;
    2056:	80 ec       	ldi	r24, 0xC0	; 192
    2058:	80 93 13 01 	sts	0x0113, r24
    205c:	cf 91       	pop	r28
    205e:	1f 91       	pop	r17
    2060:	0f 91       	pop	r16
    2062:	08 95       	ret

00002064 <ISPCC_PollForProgComplete>:
}

void ISPCC_ProgramChip(void)
{
	uint16_t PollAddress  = 0;
	uint8_t  ProgMode     = PacketBytes[3];
	uint8_t  WriteCommand = PacketBytes[5];
	uint16_t StartAddress = (uint16_t)CurrAddress;
	uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
	                      | PacketBytes[2];
	uint8_t  PollType;
	uint8_t  ByteToWrite;
			
	if (ProgMode & ISPCC_PROG_MODE_PAGE)                 // Page writing mode
	{
		for (uint16_t WriteByte = 0; WriteByte < BytesToWrite; WriteByte++) // Transmit the page bytes
		{
			ByteToWrite = PacketBytes[10 + WriteByte];
		
			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) // Flash write mode - word addresses so MSB/LSB masking 
			   USI_SPITransmit(WriteCommand | ((WriteByte & 0x01)? ISPCC_HIGH_BYTE_WRITE : ISPCC_LOW_BYTE_WRITE));
			else                                         // EEPROM write mode - byte addresses so no masking 
			   USI_SPITransmit(WriteCommand);

			USI_SPITransmitWord(CurrAddress & 0xFFFF);    // Only the LSW of the address should be sent
			USI_SPITransmit(ByteToWrite);                 // Send one of the new bytes to be written

			if (!(PollAddress))
			{
				if ((PacketBytes[8] != ByteToWrite)       // Can do polling
				   && ((PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) || ((PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP) && (PacketBytes[9] != ByteToWrite))))
				{
					PollAddress = (CurrAddress & 0xFFFF); // Save the current address
				
					if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
					   PollAddress = ((PollAddress << 1) + (WriteByte & 0x01));
				}
			}

			// Flash addresses are in words; only increment address on odd byte, OR if it's the EEPROM being programmed (byte addresses)
			if ((WriteByte & 0x01) || (PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP))
			   V2P_IncrementCurrAddress();
		}

		PollType = ProgMode;

		if (ProgMode & ISPCC_PROG_MODE_PAGEDONE)         // If this packet is the end of a page, we need to send the program page command
		{
			USI_SPITransmit(PacketBytes[6]);             // Send the write program memory page command
			USI_SPITransmitWord(StartAddress);           // Send the page address word
			USI_SPITransmit(0x00);

			if (!(PollAddress))                          // No polling address
			   PollType = ((ProgMode & ~ISPCC_PAGE_POLLTYPE_MASK) | ISPCC_PAGE_POLLTYPE_WAIT);

			ISPCC_PollForProgComplete(PollType, PollAddress);
		}
	}
	else                                                 // Flash Word writing mode or EEPROM byte writing mode
	{
		for (uint16_t WriteByte = 0; WriteByte < BytesToWrite; WriteByte++)
		{
			ByteToWrite = PacketBytes[10 + WriteByte];

			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
			   USI_SPITransmit(WriteCommand | ((WriteByte & 0x01)? ISPCC_HIGH_BYTE_WRITE : ISPCC_LOW_BYTE_WRITE));
			else
			   USI_SPITransmit(WriteCommand);					
					
			USI_SPITransmitWord(CurrAddress & 0xFFFF);    // Transmit the current address to the slave AVR
			USI_SPITransmit(ByteToWrite);                 // Send one of the new bytes to be written

			PollType = ProgMode;

			if ((PacketBytes[8] != ByteToWrite)           // Can do polling
			   && ((PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) || ((PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP) && (PacketBytes[9] != ByteToWrite))))
			{
				PollAddress = (CurrAddress & 0xFFFF);     // Save the current address;

				if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
				   PollAddress = ((PollAddress << 1) + (WriteByte & 0x01));
			}
			else
			{
				PollType = ((ProgMode & ~ISPCC_WORD_POLLTYPE_MASK) | ISPCC_WORD_POLLTYPE_WAIT);
			}					

			// Flash addresses are in words; only increment address on the odd byte, OR if it's the EEPROM being programmed (byte addresses)
			if ((WriteByte & 0x01) || (PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP))
			   V2P_IncrementCurrAddress();

			ISPCC_PollForProgComplete(PollType, PollAddress);
		}
	}
}

void ISPCC_PollForProgComplete(uint8_t PollData, uint16_t PollAddr)
{
    2064:	1f 93       	push	r17
    2066:	cf 93       	push	r28
    2068:	df 93       	push	r29
    206a:	eb 01       	movw	r28, r22
	uint8_t PollType;
	uint8_t ProgCommand;

	if (PollData & ISPCC_PROG_MODE_PAGE)
    206c:	99 27       	eor	r25, r25
    206e:	80 ff       	sbrs	r24, 0
    2070:	08 c0       	rjmp	.+16     	; 0x2082 <ISPCC_PollForProgComplete+0x1e>
	   PollType = ((PollData & ISPCC_PAGE_POLLTYPE_MASK) >> ISPCC_PAGE_POLLTYPE_MASKSHIFT);
    2072:	80 77       	andi	r24, 0x70	; 112
    2074:	90 70       	andi	r25, 0x00	; 0
    2076:	34 e0       	ldi	r19, 0x04	; 4
    2078:	95 95       	asr	r25
    207a:	87 95       	ror	r24
    207c:	3a 95       	dec	r19
    207e:	e1 f7       	brne	.-8      	; 0x2078 <ISPCC_PollForProgComplete+0x14>
    2080:	04 c0       	rjmp	.+8      	; 0x208a <ISPCC_PollForProgComplete+0x26>
	else
	   PollType = ((PollData & ISPCC_WORD_POLLTYPE_MASK) >> ISPCC_WORD_POLLTYPE_MASKSHIFT);	
    2082:	8e 70       	andi	r24, 0x0E	; 14
    2084:	90 70       	andi	r25, 0x00	; 0
    2086:	95 95       	asr	r25
    2088:	87 95       	ror	r24

	switch (PollType & ISPCC_POLLTYPE_MASK)
    208a:	99 27       	eor	r25, r25
    208c:	87 70       	andi	r24, 0x07	; 7
    208e:	90 70       	andi	r25, 0x00	; 0
    2090:	82 30       	cpi	r24, 0x02	; 2
    2092:	91 05       	cpc	r25, r1
    2094:	19 f0       	breq	.+6      	; 0x209c <ISPCC_PollForProgComplete+0x38>
    2096:	04 97       	sbiw	r24, 0x04	; 4
    2098:	e1 f0       	breq	.+56     	; 0x20d2 <ISPCC_PollForProgComplete+0x6e>
    209a:	26 c0       	rjmp	.+76     	; 0x20e8 <ISPCC_PollForProgComplete+0x84>
	{
		case ISPCC_POLLTYPE_DATA:
			ProgCommand = PacketBytes[7];
    209c:	10 91 19 01 	lds	r17, 0x0119
			
			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) // Flash uses word addresses
    20a0:	80 91 12 01 	lds	r24, 0x0112
    20a4:	83 31       	cpi	r24, 0x13	; 19
    20a6:	39 f4       	brne	.+14     	; 0x20b6 <ISPCC_PollForProgComplete+0x52>
			{
				ProgCommand  |= ((PollAddr & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ);
    20a8:	81 2f       	mov	r24, r17
    20aa:	99 27       	eor	r25, r25
    20ac:	c0 fd       	sbrc	r28, 0
    20ae:	88 60       	ori	r24, 0x08	; 8
    20b0:	18 2f       	mov	r17, r24
				PollAddr    >>= 1;
    20b2:	d6 95       	lsr	r29
    20b4:	c7 95       	ror	r28
			}

			do
			{
				USI_SPITransmit(ProgCommand);
    20b6:	81 2f       	mov	r24, r17
    20b8:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
				USI_SPITransmitWord(PollAddr);
    20bc:	ce 01       	movw	r24, r28
    20be:	0e 94 01 09 	call	0x1202 <USI_SPITransmitWord>
			}
    20c2:	80 e0       	ldi	r24, 0x00	; 0
    20c4:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    20c8:	90 91 1a 01 	lds	r25, 0x011A
    20cc:	89 17       	cp	r24, r25
    20ce:	99 f3       	breq	.-26     	; 0x20b6 <ISPCC_PollForProgComplete+0x52>
			while (USI_SPITransmit(0x00) == PacketBytes[8]);
						
			break;
    20d0:	0f c0       	rjmp	.+30     	; 0x20f0 <ISPCC_PollForProgComplete+0x8c>
		case ISPCC_POLLTYPE_READY:
			do
			   USI_SPITransmitWord(0xF000);
    20d2:	80 e0       	ldi	r24, 0x00	; 0
    20d4:	90 ef       	ldi	r25, 0xF0	; 240
    20d6:	0e 94 01 09 	call	0x1202 <USI_SPITransmitWord>
    20da:	80 e0       	ldi	r24, 0x00	; 0
    20dc:	90 e0       	ldi	r25, 0x00	; 0
    20de:	0e 94 01 09 	call	0x1202 <USI_SPITransmitWord>
    20e2:	80 fd       	sbrc	r24, 0
    20e4:	f6 cf       	rjmp	.-20     	; 0x20d2 <ISPCC_PollForProgComplete+0x6e>
			while (USI_SPITransmitWord(0x0000) & ISPCC_POLL_BUSYFLAG);

			break;
    20e6:	04 c0       	rjmp	.+8      	; 0x20f0 <ISPCC_PollForProgComplete+0x8c>
		default:                                      // Default is Wait polling
			MAIN_Delay1MS(PacketBytes[4]);	
    20e8:	80 91 16 01 	lds	r24, 0x0116
    20ec:	0e 94 ed 02 	call	0x5da <MAIN_Delay1MS>
    20f0:	df 91       	pop	r29
    20f2:	cf 91       	pop	r28
    20f4:	1f 91       	pop	r17
    20f6:	08 95       	ret

000020f8 <ISPCC_ProgramChip>:
    20f8:	6f 92       	push	r6
    20fa:	7f 92       	push	r7
    20fc:	9f 92       	push	r9
    20fe:	af 92       	push	r10
    2100:	bf 92       	push	r11
    2102:	cf 92       	push	r12
    2104:	df 92       	push	r13
    2106:	ef 92       	push	r14
    2108:	ff 92       	push	r15
    210a:	0f 93       	push	r16
    210c:	1f 93       	push	r17
    210e:	cf 93       	push	r28
    2110:	df 93       	push	r29
    2112:	00 e0       	ldi	r16, 0x00	; 0
    2114:	10 e0       	ldi	r17, 0x00	; 0
    2116:	90 90 15 01 	lds	r9, 0x0115
    211a:	c0 90 17 01 	lds	r12, 0x0117
    211e:	60 90 09 01 	lds	r6, 0x0109
    2122:	70 90 0a 01 	lds	r7, 0x010A
    2126:	80 91 13 01 	lds	r24, 0x0113
    212a:	99 27       	eor	r25, r25
    212c:	b8 2e       	mov	r11, r24
    212e:	aa 24       	eor	r10, r10
    2130:	80 91 14 01 	lds	r24, 0x0114
    2134:	99 27       	eor	r25, r25
    2136:	a8 2a       	or	r10, r24
    2138:	b9 2a       	or	r11, r25
    213a:	90 fe       	sbrs	r9, 0
    213c:	62 c0       	rjmp	.+196    	; 0x2202 <ISPCC_ProgramChip+0x10a>
    213e:	78 01       	movw	r14, r16
    2140:	0a 15       	cp	r16, r10
    2142:	1b 05       	cpc	r17, r11
    2144:	08 f0       	brcs	.+2      	; 0x2148 <ISPCC_ProgramChip+0x50>
    2146:	46 c0       	rjmp	.+140    	; 0x21d4 <ISPCC_ProgramChip+0xdc>
    2148:	cc e1       	ldi	r28, 0x1C	; 28
    214a:	d1 e0       	ldi	r29, 0x01	; 1
    214c:	d9 90       	ld	r13, Y+
    214e:	80 91 12 01 	lds	r24, 0x0112
    2152:	83 31       	cpi	r24, 0x13	; 19
    2154:	31 f4       	brne	.+12     	; 0x2162 <ISPCC_ProgramChip+0x6a>
    2156:	8c 2d       	mov	r24, r12
    2158:	99 27       	eor	r25, r25
    215a:	e0 fe       	sbrs	r14, 0
    215c:	03 c0       	rjmp	.+6      	; 0x2164 <ISPCC_ProgramChip+0x6c>
    215e:	88 60       	ori	r24, 0x08	; 8
    2160:	01 c0       	rjmp	.+2      	; 0x2164 <ISPCC_ProgramChip+0x6c>
    2162:	8c 2d       	mov	r24, r12
    2164:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    2168:	80 91 09 01 	lds	r24, 0x0109
    216c:	90 91 0a 01 	lds	r25, 0x010A
    2170:	0e 94 01 09 	call	0x1202 <USI_SPITransmitWord>
    2174:	8d 2d       	mov	r24, r13
    2176:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    217a:	01 15       	cp	r16, r1
    217c:	11 05       	cpc	r17, r1
    217e:	d9 f4       	brne	.+54     	; 0x21b6 <ISPCC_ProgramChip+0xbe>
    2180:	80 91 1a 01 	lds	r24, 0x011A
    2184:	8d 15       	cp	r24, r13
    2186:	b9 f0       	breq	.+46     	; 0x21b6 <ISPCC_ProgramChip+0xbe>
    2188:	90 91 12 01 	lds	r25, 0x0112
    218c:	93 31       	cpi	r25, 0x13	; 19
    218e:	31 f0       	breq	.+12     	; 0x219c <ISPCC_ProgramChip+0xa4>
    2190:	95 31       	cpi	r25, 0x15	; 21
    2192:	89 f4       	brne	.+34     	; 0x21b6 <ISPCC_ProgramChip+0xbe>
    2194:	80 91 1b 01 	lds	r24, 0x011B
    2198:	8d 15       	cp	r24, r13
    219a:	69 f0       	breq	.+26     	; 0x21b6 <ISPCC_ProgramChip+0xbe>
    219c:	00 91 09 01 	lds	r16, 0x0109
    21a0:	10 91 0a 01 	lds	r17, 0x010A
    21a4:	93 31       	cpi	r25, 0x13	; 19
    21a6:	39 f4       	brne	.+14     	; 0x21b6 <ISPCC_ProgramChip+0xbe>
    21a8:	00 0f       	add	r16, r16
    21aa:	11 1f       	adc	r17, r17
    21ac:	c7 01       	movw	r24, r14
    21ae:	81 70       	andi	r24, 0x01	; 1
    21b0:	90 70       	andi	r25, 0x00	; 0
    21b2:	08 0f       	add	r16, r24
    21b4:	19 1f       	adc	r17, r25
    21b6:	e0 fc       	sbrc	r14, 0
    21b8:	04 c0       	rjmp	.+8      	; 0x21c2 <ISPCC_ProgramChip+0xca>
    21ba:	80 91 12 01 	lds	r24, 0x0112
    21be:	85 31       	cpi	r24, 0x15	; 21
    21c0:	11 f4       	brne	.+4      	; 0x21c6 <ISPCC_ProgramChip+0xce>
    21c2:	0e 94 3d 0e 	call	0x1c7a <V2P_IncrementCurrAddress>
    21c6:	08 94       	sec
    21c8:	e1 1c       	adc	r14, r1
    21ca:	f1 1c       	adc	r15, r1
    21cc:	ea 14       	cp	r14, r10
    21ce:	fb 04       	cpc	r15, r11
    21d0:	08 f4       	brcc	.+2      	; 0x21d4 <ISPCC_ProgramChip+0xdc>
    21d2:	bc cf       	rjmp	.-136    	; 0x214c <ISPCC_ProgramChip+0x54>
    21d4:	c9 2d       	mov	r28, r9
    21d6:	97 fe       	sbrs	r9, 7
    21d8:	69 c0       	rjmp	.+210    	; 0x22ac <ISPCC_ProgramChip+0x1b4>
    21da:	80 91 18 01 	lds	r24, 0x0118
    21de:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    21e2:	c3 01       	movw	r24, r6
    21e4:	0e 94 01 09 	call	0x1202 <USI_SPITransmitWord>
    21e8:	80 e0       	ldi	r24, 0x00	; 0
    21ea:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    21ee:	01 15       	cp	r16, r1
    21f0:	11 05       	cpc	r17, r1
    21f2:	11 f4       	brne	.+4      	; 0x21f8 <ISPCC_ProgramChip+0x100>
    21f4:	cf 78       	andi	r28, 0x8F	; 143
    21f6:	c0 61       	ori	r28, 0x10	; 16
    21f8:	b8 01       	movw	r22, r16
    21fa:	8c 2f       	mov	r24, r28
    21fc:	0e 94 32 10 	call	0x2064 <ISPCC_PollForProgComplete>
    2200:	55 c0       	rjmp	.+170    	; 0x22ac <ISPCC_ProgramChip+0x1b4>
    2202:	78 01       	movw	r14, r16
    2204:	0a 15       	cp	r16, r10
    2206:	1b 05       	cpc	r17, r11
    2208:	08 f0       	brcs	.+2      	; 0x220c <ISPCC_ProgramChip+0x114>
    220a:	50 c0       	rjmp	.+160    	; 0x22ac <ISPCC_ProgramChip+0x1b4>
    220c:	5c e1       	ldi	r21, 0x1C	; 28
    220e:	65 2e       	mov	r6, r21
    2210:	51 e0       	ldi	r21, 0x01	; 1
    2212:	75 2e       	mov	r7, r21
    2214:	f3 01       	movw	r30, r6
    2216:	d1 90       	ld	r13, Z+
    2218:	3f 01       	movw	r6, r30
    221a:	80 91 12 01 	lds	r24, 0x0112
    221e:	83 31       	cpi	r24, 0x13	; 19
    2220:	31 f4       	brne	.+12     	; 0x222e <ISPCC_ProgramChip+0x136>
    2222:	8c 2d       	mov	r24, r12
    2224:	99 27       	eor	r25, r25
    2226:	e0 fe       	sbrs	r14, 0
    2228:	03 c0       	rjmp	.+6      	; 0x2230 <ISPCC_ProgramChip+0x138>
    222a:	88 60       	ori	r24, 0x08	; 8
    222c:	01 c0       	rjmp	.+2      	; 0x2230 <ISPCC_ProgramChip+0x138>
    222e:	8c 2d       	mov	r24, r12
    2230:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    2234:	80 91 09 01 	lds	r24, 0x0109
    2238:	90 91 0a 01 	lds	r25, 0x010A
    223c:	0e 94 01 09 	call	0x1202 <USI_SPITransmitWord>
    2240:	8d 2d       	mov	r24, r13
    2242:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    2246:	c9 2d       	mov	r28, r9
    2248:	80 91 1a 01 	lds	r24, 0x011A
    224c:	8d 15       	cp	r24, r13
    224e:	c1 f0       	breq	.+48     	; 0x2280 <ISPCC_ProgramChip+0x188>
    2250:	90 91 12 01 	lds	r25, 0x0112
    2254:	93 31       	cpi	r25, 0x13	; 19
    2256:	31 f0       	breq	.+12     	; 0x2264 <ISPCC_ProgramChip+0x16c>
    2258:	95 31       	cpi	r25, 0x15	; 21
    225a:	91 f4       	brne	.+36     	; 0x2280 <ISPCC_ProgramChip+0x188>
    225c:	80 91 1b 01 	lds	r24, 0x011B
    2260:	8d 15       	cp	r24, r13
    2262:	71 f0       	breq	.+28     	; 0x2280 <ISPCC_ProgramChip+0x188>
    2264:	00 91 09 01 	lds	r16, 0x0109
    2268:	10 91 0a 01 	lds	r17, 0x010A
    226c:	93 31       	cpi	r25, 0x13	; 19
    226e:	59 f4       	brne	.+22     	; 0x2286 <ISPCC_ProgramChip+0x18e>
    2270:	00 0f       	add	r16, r16
    2272:	11 1f       	adc	r17, r17
    2274:	c7 01       	movw	r24, r14
    2276:	81 70       	andi	r24, 0x01	; 1
    2278:	90 70       	andi	r25, 0x00	; 0
    227a:	08 0f       	add	r16, r24
    227c:	19 1f       	adc	r17, r25
    227e:	03 c0       	rjmp	.+6      	; 0x2286 <ISPCC_ProgramChip+0x18e>
    2280:	c9 2d       	mov	r28, r9
    2282:	c1 7f       	andi	r28, 0xF1	; 241
    2284:	c2 60       	ori	r28, 0x02	; 2
    2286:	e0 fc       	sbrc	r14, 0
    2288:	04 c0       	rjmp	.+8      	; 0x2292 <ISPCC_ProgramChip+0x19a>
    228a:	80 91 12 01 	lds	r24, 0x0112
    228e:	85 31       	cpi	r24, 0x15	; 21
    2290:	11 f4       	brne	.+4      	; 0x2296 <ISPCC_ProgramChip+0x19e>
    2292:	0e 94 3d 0e 	call	0x1c7a <V2P_IncrementCurrAddress>
    2296:	b8 01       	movw	r22, r16
    2298:	8c 2f       	mov	r24, r28
    229a:	0e 94 32 10 	call	0x2064 <ISPCC_PollForProgComplete>
    229e:	08 94       	sec
    22a0:	e1 1c       	adc	r14, r1
    22a2:	f1 1c       	adc	r15, r1
    22a4:	ea 14       	cp	r14, r10
    22a6:	fb 04       	cpc	r15, r11
    22a8:	08 f4       	brcc	.+2      	; 0x22ac <ISPCC_ProgramChip+0x1b4>
    22aa:	b4 cf       	rjmp	.-152    	; 0x2214 <ISPCC_ProgramChip+0x11c>
    22ac:	df 91       	pop	r29
    22ae:	cf 91       	pop	r28
    22b0:	1f 91       	pop	r17
    22b2:	0f 91       	pop	r16
    22b4:	ff 90       	pop	r15
    22b6:	ef 90       	pop	r14
    22b8:	df 90       	pop	r13
    22ba:	cf 90       	pop	r12
    22bc:	bf 90       	pop	r11
    22be:	af 90       	pop	r10
    22c0:	9f 90       	pop	r9
    22c2:	7f 90       	pop	r7
    22c4:	6f 90       	pop	r6
    22c6:	08 95       	ret

000022c8 <AICI_InterpretPacket>:

// ======================================================================================

void AICI_InterpretPacket(void)
{
    22c8:	df 92       	push	r13
    22ca:	ef 92       	push	r14
    22cc:	ff 92       	push	r15
    22ce:	0f 93       	push	r16
    22d0:	1f 93       	push	r17
    22d2:	cf 93       	push	r28
    22d4:	df 93       	push	r29
	switch (PacketBytes[0])
    22d6:	80 91 12 01 	lds	r24, 0x0112
    22da:	99 27       	eor	r25, r25
    22dc:	86 31       	cpi	r24, 0x16	; 22
    22de:	91 05       	cpc	r25, r1
    22e0:	09 f4       	brne	.+2      	; 0x22e4 <AICI_InterpretPacket+0x1c>
    22e2:	fb c0       	rjmp	.+502    	; 0x24da <AICI_InterpretPacket+0x212>
    22e4:	87 31       	cpi	r24, 0x17	; 23
    22e6:	91 05       	cpc	r25, r1
    22e8:	94 f4       	brge	.+36     	; 0x230e <AICI_InterpretPacket+0x46>
    22ea:	82 31       	cpi	r24, 0x12	; 18
    22ec:	91 05       	cpc	r25, r1
    22ee:	09 f4       	brne	.+2      	; 0x22f2 <AICI_InterpretPacket+0x2a>
    22f0:	60 c0       	rjmp	.+192    	; 0x23b2 <AICI_InterpretPacket+0xea>
    22f2:	83 31       	cpi	r24, 0x13	; 19
    22f4:	91 05       	cpc	r25, r1
    22f6:	3c f4       	brge	.+14     	; 0x2306 <AICI_InterpretPacket+0x3e>
    22f8:	80 31       	cpi	r24, 0x10	; 16
    22fa:	91 05       	cpc	r25, r1
    22fc:	f9 f0       	breq	.+62     	; 0x233c <AICI_InterpretPacket+0x74>
    22fe:	41 97       	sbiw	r24, 0x11	; 17
    2300:	09 f4       	brne	.+2      	; 0x2304 <AICI_InterpretPacket+0x3c>
    2302:	3d c0       	rjmp	.+122    	; 0x237e <AICI_InterpretPacket+0xb6>
    2304:	3e c1       	rjmp	.+636    	; 0x2582 <AICI_InterpretPacket+0x2ba>
    2306:	44 97       	sbiw	r24, 0x14	; 20
    2308:	09 f4       	brne	.+2      	; 0x230c <AICI_InterpretPacket+0x44>
    230a:	e7 c0       	rjmp	.+462    	; 0x24da <AICI_InterpretPacket+0x212>
    230c:	2f c1       	rjmp	.+606    	; 0x256c <AICI_InterpretPacket+0x2a4>
    230e:	89 31       	cpi	r24, 0x19	; 25
    2310:	91 05       	cpc	r25, r1
    2312:	09 f4       	brne	.+2      	; 0x2316 <AICI_InterpretPacket+0x4e>
    2314:	cc c0       	rjmp	.+408    	; 0x24ae <AICI_InterpretPacket+0x1e6>
    2316:	8a 31       	cpi	r24, 0x1A	; 26
    2318:	91 05       	cpc	r25, r1
    231a:	44 f4       	brge	.+16     	; 0x232c <AICI_InterpretPacket+0x64>
    231c:	87 31       	cpi	r24, 0x17	; 23
    231e:	91 05       	cpc	r25, r1
    2320:	09 f4       	brne	.+2      	; 0x2324 <AICI_InterpretPacket+0x5c>
    2322:	c5 c0       	rjmp	.+394    	; 0x24ae <AICI_InterpretPacket+0x1e6>
    2324:	48 97       	sbiw	r24, 0x18	; 24
    2326:	09 f4       	brne	.+2      	; 0x232a <AICI_InterpretPacket+0x62>
    2328:	a5 c0       	rjmp	.+330    	; 0x2474 <AICI_InterpretPacket+0x1ac>
    232a:	2b c1       	rjmp	.+598    	; 0x2582 <AICI_InterpretPacket+0x2ba>
    232c:	8d 31       	cpi	r24, 0x1D	; 29
    232e:	91 05       	cpc	r25, r1
    2330:	0c f4       	brge	.+2      	; 0x2334 <AICI_InterpretPacket+0x6c>
    2332:	a0 c0       	rjmp	.+320    	; 0x2474 <AICI_InterpretPacket+0x1ac>
    2334:	4d 97       	sbiw	r24, 0x1d	; 29
    2336:	09 f4       	brne	.+2      	; 0x233a <AICI_InterpretPacket+0x72>
    2338:	61 c0       	rjmp	.+194    	; 0x23fc <AICI_InterpretPacket+0x134>
    233a:	23 c1       	rjmp	.+582    	; 0x2582 <AICI_InterpretPacket+0x2ba>
	{
		case CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
    233c:	82 e0       	ldi	r24, 0x02	; 2
    233e:	90 e0       	ldi	r25, 0x00	; 0
    2340:	90 93 0f 01 	sts	0x010F, r25
    2344:	80 93 0e 01 	sts	0x010E, r24
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2348:	a1 e0       	ldi	r26, 0x01	; 1
    234a:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    234c:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
    2350:	80 2d       	mov	r24, r0
    2352:	0e 94 d4 08 	call	0x11a8 <USI_SPIInitMaster>
			
			USI_SPIInitMaster(eeprom_read_byte(&EEPROMVars.SCKDuration));

			MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);  // Pull the slave AVR's RESET line to active
    2356:	80 e0       	ldi	r24, 0x00	; 0
    2358:	0e 94 ff 02 	call	0x5fe <MAIN_ResetCSLine>
			MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE); // Orange = Busy
    235c:	81 b3       	in	r24, 0x11	; 17
    235e:	80 63       	ori	r24, 0x30	; 48
    2360:	81 bb       	out	0x11, r24	; 17
			ISPCC_EnterChipProgrammingMode();       // Run the Enter Programming Mode routine
    2362:	0e 94 d4 0f 	call	0x1fa8 <ISPCC_EnterChipProgrammingMode>

			if (InProgrammingMode)
    2366:	80 91 0d 01 	lds	r24, 0x010D
    236a:	88 23       	and	r24, r24
    236c:	19 f0       	breq	.+6      	; 0x2374 <AICI_InterpretPacket+0xac>
			   LCD_puts_f(AVRISPModeMessage);
    236e:	84 ec       	ldi	r24, 0xC4	; 196
    2370:	93 e0       	ldi	r25, 0x03	; 3
    2372:	02 c0       	rjmp	.+4      	; 0x2378 <AICI_InterpretPacket+0xb0>
			else
			   LCD_puts_f(SyncErrorMessage);
    2374:	89 eb       	ldi	r24, 0xB9	; 185
    2376:	93 e0       	ldi	r25, 0x03	; 3
    2378:	0e 94 91 07 	call	0xf22 <LCD_puts_f>
			
			break;
    237c:	0b c1       	rjmp	.+534    	; 0x2594 <AICI_InterpretPacket+0x2cc>
		case CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;
    237e:	82 e0       	ldi	r24, 0x02	; 2
    2380:	90 e0       	ldi	r25, 0x00	; 0
    2382:	90 93 0f 01 	sts	0x010F, r25
    2386:	80 93 0e 01 	sts	0x010E, r24

			MAIN_Delay1MS(PacketBytes[1]);           // Wait for the "PreDelay" amount specified in the packet
    238a:	80 91 13 01 	lds	r24, 0x0113
    238e:	0e 94 ed 02 	call	0x5da <MAIN_Delay1MS>
			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Non programming mode = green status led
    2392:	81 b3       	in	r24, 0x11	; 17
    2394:	8f 7c       	andi	r24, 0xCF	; 207
    2396:	80 61       	ori	r24, 0x10	; 16
    2398:	81 bb       	out	0x11, r24	; 17
			InProgrammingMode = FALSE;
    239a:	10 92 0d 01 	sts	0x010D, r1
			MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run
    239e:	81 e0       	ldi	r24, 0x01	; 1
    23a0:	0e 94 ff 02 	call	0x5fe <MAIN_ResetCSLine>
			MAIN_Delay1MS(PacketBytes[2]);           // Wait for the "PostDelay" amount specified in the packet
    23a4:	80 91 14 01 	lds	r24, 0x0114
    23a8:	0e 94 ed 02 	call	0x5da <MAIN_Delay1MS>
			
			USI_SPIOff();
    23ac:	0e 94 e4 08 	call	0x11c8 <USI_SPIOff>
    23b0:	e5 c0       	rjmp	.+458    	; 0x257c <AICI_InterpretPacket+0x2b4>

			PacketBytes[1] = STATUS_CMD_OK;      // Return OK

			break;
		case CMD_CHIP_ERASE_ISP:
			MessageSize = 2;
    23b2:	82 e0       	ldi	r24, 0x02	; 2
    23b4:	90 e0       	ldi	r25, 0x00	; 0
    23b6:	90 93 0f 01 	sts	0x010F, r25
    23ba:	80 93 0e 01 	sts	0x010E, r24
			
			for (uint8_t PacketB = 3; PacketB <= 6; PacketB++) // Send the erase commands to the slave AVR
    23be:	c3 e0       	ldi	r28, 0x03	; 3
    23c0:	05 e1       	ldi	r16, 0x15	; 21
    23c2:	11 e0       	ldi	r17, 0x01	; 1
				USI_SPITransmit(PacketBytes[PacketB]);
    23c4:	f8 01       	movw	r30, r16
    23c6:	81 91       	ld	r24, Z+
    23c8:	8f 01       	movw	r16, r30
    23ca:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    23ce:	c1 50       	subi	r28, 0x01	; 1
    23d0:	c7 ff       	sbrs	r28, 7
    23d2:	f8 cf       	rjmp	.-16     	; 0x23c4 <AICI_InterpretPacket+0xfc>

			if (PacketBytes[2])                  // Poll mode, value of 1 indicates a busy flag wait
    23d4:	80 91 14 01 	lds	r24, 0x0114
    23d8:	88 23       	and	r24, r24
    23da:	59 f0       	breq	.+22     	; 0x23f2 <AICI_InterpretPacket+0x12a>
			{
				do
					USI_SPITransmitWord(0xF000);
    23dc:	80 e0       	ldi	r24, 0x00	; 0
    23de:	90 ef       	ldi	r25, 0xF0	; 240
    23e0:	0e 94 01 09 	call	0x1202 <USI_SPITransmitWord>
    23e4:	80 e0       	ldi	r24, 0x00	; 0
    23e6:	90 e0       	ldi	r25, 0x00	; 0
    23e8:	0e 94 01 09 	call	0x1202 <USI_SPITransmitWord>
    23ec:	80 fd       	sbrc	r24, 0
    23ee:	f6 cf       	rjmp	.-20     	; 0x23dc <AICI_InterpretPacket+0x114>
    23f0:	c5 c0       	rjmp	.+394    	; 0x257c <AICI_InterpretPacket+0x2b4>
				while (USI_SPITransmitWord(0x0000) & 0x01);
			}
			else                                // Poll mode flag of 0 indicates a predefined delay
			{
				MAIN_Delay1MS(PacketBytes[1]);   // Wait the specified interval to ensure erase complete
    23f2:	80 91 13 01 	lds	r24, 0x0113
    23f6:	0e 94 ed 02 	call	0x5da <MAIN_Delay1MS>
    23fa:	c0 c0       	rjmp	.+384    	; 0x257c <AICI_InterpretPacket+0x2b4>
			}
			
			PacketBytes[1] = STATUS_CMD_OK;      // Always return OK
			
			break;
		case CMD_SPI_MULTI:
				MessageSize = (3 + PacketBytes[2]);    // Number of recieved bytes, plus two OKs and the command byte
    23fc:	e0 90 14 01 	lds	r14, 0x0114
    2400:	8e 2d       	mov	r24, r14
    2402:	99 27       	eor	r25, r25
    2404:	03 96       	adiw	r24, 0x03	; 3
    2406:	90 93 0f 01 	sts	0x010F, r25
    240a:	80 93 0e 01 	sts	0x010E, r24
		
				uint8_t TxBytes      = PacketBytes[1]; // \. The packet data is overwritten during the transfer. Because
    240e:	00 91 13 01 	lds	r16, 0x0113
				uint8_t RxStartByte  = PacketBytes[2]; // |  of this each data byte must be stored into temp variables
				uint8_t RxBytes      = PacketBytes[3]; // /  so that their contents are not lost.
    2412:	f0 90 15 01 	lds	r15, 0x0115
				uint8_t RxByteNum    = 1;
    2416:	c1 e0       	ldi	r28, 0x01	; 1
				uint8_t TxByteNum    = 1;
				uint8_t RecievedByte = 0;

				while (TxByteNum++ < TxBytes)          // Still bytes to transfer
				{
					RecievedByte = USI_SPITransmit(PacketBytes[3 + TxByteNum]); // Transmit the byte, store the answer

					if ((TxByteNum >= RxStartByte) && (RxByteNum < RxBytes))
					   PacketBytes[2 + RxByteNum++] = RecievedByte;
    2418:	12 e0       	ldi	r17, 0x02	; 2
    241a:	c0 17       	cp	r28, r16
    241c:	a8 f4       	brcc	.+42     	; 0x2448 <AICI_InterpretPacket+0x180>
    241e:	e1 2f       	mov	r30, r17
    2420:	ff 27       	eor	r31, r31
    2422:	ee 5e       	subi	r30, 0xEE	; 238
    2424:	fe 4f       	sbci	r31, 0xFE	; 254
    2426:	83 81       	ldd	r24, Z+3	; 0x03
    2428:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    242c:	1e 15       	cp	r17, r14
    242e:	40 f0       	brcs	.+16     	; 0x2440 <AICI_InterpretPacket+0x178>
    2430:	cf 15       	cp	r28, r15
    2432:	30 f4       	brcc	.+12     	; 0x2440 <AICI_InterpretPacket+0x178>
    2434:	ec 2f       	mov	r30, r28
    2436:	ff 27       	eor	r31, r31
    2438:	ee 5e       	subi	r30, 0xEE	; 238
    243a:	fe 4f       	sbci	r31, 0xFE	; 254
    243c:	82 83       	std	Z+2, r24	; 0x02
    243e:	cf 5f       	subi	r28, 0xFF	; 255
    2440:	81 2f       	mov	r24, r17
    2442:	1f 5f       	subi	r17, 0xFF	; 255
    2444:	80 17       	cp	r24, r16
    2446:	58 f3       	brcs	.-42     	; 0x241e <AICI_InterpretPacket+0x156>
				}

				while (RxByteNum++ < RxBytes)                         // Still more bytes to recieve
				   PacketBytes[2 + RxByteNum] = USI_SPITransmit(0x00); // its answer to be recorded (or more bytes than sent need responses), send dummy bytes to fetch the response(s)
    2448:	8c 2f       	mov	r24, r28
    244a:	cf 5f       	subi	r28, 0xFF	; 255
    244c:	8f 15       	cp	r24, r15
    244e:	50 f4       	brcc	.+20     	; 0x2464 <AICI_InterpretPacket+0x19c>
    2450:	0c 2f       	mov	r16, r28
    2452:	11 27       	eor	r17, r17
    2454:	0e 5e       	subi	r16, 0xEE	; 238
    2456:	1e 4f       	sbci	r17, 0xFE	; 254
    2458:	80 e0       	ldi	r24, 0x00	; 0
    245a:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    245e:	f8 01       	movw	r30, r16
    2460:	82 83       	std	Z+2, r24	; 0x02
    2462:	f2 cf       	rjmp	.-28     	; 0x2448 <AICI_InterpretPacket+0x180>

				PacketBytes[1]             = STATUS_CMD_OK; // Data should be encompassed
    2464:	10 92 13 01 	sts	0x0113, r1
				PacketBytes[3 + RxByteNum] = STATUS_CMD_OK; //  by STATS_CMD_OKs
    2468:	ec 2f       	mov	r30, r28
    246a:	ff 27       	eor	r31, r31
    246c:	ee 5e       	subi	r30, 0xEE	; 238
    246e:	fe 4f       	sbci	r31, 0xFE	; 254
    2470:	13 82       	std	Z+3, r1	; 0x03

				break;
    2472:	90 c0       	rjmp	.+288    	; 0x2594 <AICI_InterpretPacket+0x2cc>
		case CMD_READ_SIGNATURE_ISP:
		case CMD_READ_FUSE_ISP:
		case CMD_READ_LOCK_ISP:
		case CMD_READ_OSCCAL_ISP:
			MessageSize = 4;
    2474:	84 e0       	ldi	r24, 0x04	; 4
    2476:	90 e0       	ldi	r25, 0x00	; 0
    2478:	90 93 0f 01 	sts	0x010F, r25
    247c:	80 93 0e 01 	sts	0x010E, r24
	
			for (uint8_t ByteNum = 1; ByteNum <= 4; ByteNum++)
    2480:	c1 e0       	ldi	r28, 0x01	; 1
    2482:	04 e1       	ldi	r16, 0x14	; 20
    2484:	11 e0       	ldi	r17, 0x01	; 1
			{
				uint8_t Response = USI_SPITransmit(PacketBytes[1 + ByteNum]); // Transmit the four signature request bytes
    2486:	f8 01       	movw	r30, r16
    2488:	81 91       	ld	r24, Z+
    248a:	8f 01       	movw	r16, r30
    248c:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    2490:	98 2f       	mov	r25, r24

				if (ByteNum == PacketBytes[1])         // If the current byte is the requested signature byte, save the reponse in the packet
    2492:	80 91 13 01 	lds	r24, 0x0113
    2496:	c8 17       	cp	r28, r24
    2498:	11 f4       	brne	.+4      	; 0x249e <AICI_InterpretPacket+0x1d6>
					PacketBytes[2] = Response;
    249a:	90 93 14 01 	sts	0x0114, r25
    249e:	cf 5f       	subi	r28, 0xFF	; 255
    24a0:	c5 30       	cpi	r28, 0x05	; 5
    24a2:	88 f3       	brcs	.-30     	; 0x2486 <AICI_InterpretPacket+0x1be>
			}

			PacketBytes[1] = STATUS_CMD_OK;            // Data byte is encased in CMD_OKs
    24a4:	10 92 13 01 	sts	0x0113, r1
			PacketBytes[3] = STATUS_CMD_OK;            // Data byte is encased in CMD_OKs
    24a8:	10 92 15 01 	sts	0x0115, r1

			break;
    24ac:	73 c0       	rjmp	.+230    	; 0x2594 <AICI_InterpretPacket+0x2cc>
		case CMD_PROGRAM_FUSE_ISP:
		case CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;
    24ae:	83 e0       	ldi	r24, 0x03	; 3
    24b0:	90 e0       	ldi	r25, 0x00	; 0
    24b2:	90 93 0f 01 	sts	0x010F, r25
    24b6:	80 93 0e 01 	sts	0x010E, r24
    24ba:	03 e1       	ldi	r16, 0x13	; 19
    24bc:	11 e0       	ldi	r17, 0x01	; 1
    24be:	c3 e0       	ldi	r28, 0x03	; 3
			
			for (uint8_t PacketB = 1; PacketB <= 4; PacketB++) // Send the lock-byte values to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    24c0:	f8 01       	movw	r30, r16
    24c2:	81 91       	ld	r24, Z+
    24c4:	8f 01       	movw	r16, r30
    24c6:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    24ca:	c1 50       	subi	r28, 0x01	; 1
    24cc:	c7 ff       	sbrs	r28, 7
    24ce:	f8 cf       	rjmp	.-16     	; 0x24c0 <AICI_InterpretPacket+0x1f8>

			PacketBytes[1] = STATUS_CMD_OK;            // Two CMD_OKs are always returned
    24d0:	10 92 13 01 	sts	0x0113, r1
			PacketBytes[2] = STATUS_CMD_OK;            // Two CMD_OKs are always returned
    24d4:	10 92 14 01 	sts	0x0114, r1

			break;
    24d8:	5d c0       	rjmp	.+186    	; 0x2594 <AICI_InterpretPacket+0x2cc>
		case CMD_READ_FLASH_ISP:
		case CMD_READ_EEPROM_ISP:
			MessageSize = 0;                           // Here to prevent compiler from complaining if a var dec appears straight after a case

			uint8_t  ReadCommand = PacketBytes[3];
    24da:	d0 90 15 01 	lds	r13, 0x0115
			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8) // Load in the number of bytes that is to
    24de:	80 91 13 01 	lds	r24, 0x0113
    24e2:	99 27       	eor	r25, r25
    24e4:	d8 2f       	mov	r29, r24
    24e6:	cc 27       	eor	r28, r28
    24e8:	80 91 14 01 	lds	r24, 0x0114
    24ec:	99 27       	eor	r25, r25
    24ee:	c8 2b       	or	r28, r24
    24f0:	d9 2b       	or	r29, r25
			                     | PacketBytes[2];                 // be read into a temp variable (MSB first)

			MessageSize = BytesToRead + 3;
    24f2:	23 96       	adiw	r28, 0x03	; 3
    24f4:	d0 93 0f 01 	sts	0x010F, r29
    24f8:	c0 93 0e 01 	sts	0x010E, r28
    24fc:	23 97       	sbiw	r28, 0x03	; 3

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
    24fe:	00 e0       	ldi	r16, 0x00	; 0
    2500:	10 e0       	ldi	r17, 0x00	; 0
    2502:	0c 17       	cp	r16, r28
    2504:	1d 07       	cpc	r17, r29
    2506:	60 f5       	brcc	.+88     	; 0x2560 <AICI_InterpretPacket+0x298>
    2508:	84 e1       	ldi	r24, 0x14	; 20
    250a:	e8 2e       	mov	r14, r24
    250c:	81 e0       	ldi	r24, 0x01	; 1
    250e:	f8 2e       	mov	r15, r24
			{
				if (PacketBytes[0] == CMD_READ_FLASH_ISP)  // Flash read mode - word addresses so MSB/LSB masking nessesary
    2510:	80 91 12 01 	lds	r24, 0x0112
    2514:	84 31       	cpi	r24, 0x14	; 20
    2516:	31 f4       	brne	.+12     	; 0x2524 <AICI_InterpretPacket+0x25c>
				{
					USI_SPITransmit(ReadCommand | ((ReadByte & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ));
    2518:	8d 2d       	mov	r24, r13
    251a:	99 27       	eor	r25, r25
    251c:	00 ff       	sbrs	r16, 0
    251e:	03 c0       	rjmp	.+6      	; 0x2526 <AICI_InterpretPacket+0x25e>
    2520:	88 60       	ori	r24, 0x08	; 8
    2522:	01 c0       	rjmp	.+2      	; 0x2526 <AICI_InterpretPacket+0x25e>
				}
				else                                       // EEPROM read mode, address is in bytes and so no masking nessesary
				{
					USI_SPITransmit(ReadCommand);
    2524:	8d 2d       	mov	r24, r13
    2526:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
				}
				
				USI_SPITransmitWord(CurrAddress);          // Transmit the current address to the slave AVR
    252a:	80 91 09 01 	lds	r24, 0x0109
    252e:	90 91 0a 01 	lds	r25, 0x010A
    2532:	0e 94 01 09 	call	0x1202 <USI_SPITransmitWord>

				PacketBytes[2 + ReadByte] = USI_SPITransmit(0x00); // Read in the byte stored at the requested location
    2536:	80 e0       	ldi	r24, 0x00	; 0
    2538:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    253c:	f7 01       	movw	r30, r14
    253e:	80 83       	st	Z, r24

				if ((ReadByte & 0x01) || (PacketBytes[0] == CMD_READ_EEPROM_ISP)) // Flash addresses are given in words; only increment on the odd byte if reading the flash.
    2540:	00 fd       	sbrc	r16, 0
    2542:	04 c0       	rjmp	.+8      	; 0x254c <AICI_InterpretPacket+0x284>
    2544:	80 91 12 01 	lds	r24, 0x0112
    2548:	86 31       	cpi	r24, 0x16	; 22
    254a:	11 f4       	brne	.+4      	; 0x2550 <AICI_InterpretPacket+0x288>
				{
					V2P_IncrementCurrAddress();             // Increment the address counter
    254c:	0e 94 3d 0e 	call	0x1c7a <V2P_IncrementCurrAddress>
    2550:	0f 5f       	subi	r16, 0xFF	; 255
    2552:	1f 4f       	sbci	r17, 0xFF	; 255
    2554:	08 94       	sec
    2556:	e1 1c       	adc	r14, r1
    2558:	f1 1c       	adc	r15, r1
    255a:	0c 17       	cp	r16, r28
    255c:	1d 07       	cpc	r17, r29
    255e:	c0 f2       	brcs	.-80     	; 0x2510 <AICI_InterpretPacket+0x248>
				}
				else
				{
					if ((CurrAddress & 0x00FF0000) & !(CurrAddress & 0x0000FFFF))
					{
						CurrAddress |= (1UL << 31);        // Set MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
						V2P_CheckForExtendedAddress();
					}
				}
			}
			
			PacketBytes[1]               = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    2560:	10 92 13 01 	sts	0x0113, r1
			PacketBytes[2 + BytesToRead] = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    2564:	ce 5e       	subi	r28, 0xEE	; 238
    2566:	de 4f       	sbci	r29, 0xFE	; 254
    2568:	1a 82       	std	Y+2, r1	; 0x02

			break;
    256a:	14 c0       	rjmp	.+40     	; 0x2594 <AICI_InterpretPacket+0x2cc>
		case CMD_PROGRAM_FLASH_ISP:
		case CMD_PROGRAM_EEPROM_ISP:
			ISPCC_ProgramChip();                          // Program the bytes into the chip
    256c:	0e 94 7c 10 	call	0x20f8 <ISPCC_ProgramChip>
			
			MessageSize = 2;
    2570:	82 e0       	ldi	r24, 0x02	; 2
    2572:	90 e0       	ldi	r25, 0x00	; 0
    2574:	90 93 0f 01 	sts	0x010F, r25
    2578:	80 93 0e 01 	sts	0x010E, r24

			PacketBytes[1] = STATUS_CMD_OK;
    257c:	10 92 13 01 	sts	0x0113, r1
			
			break;
    2580:	09 c0       	rjmp	.+18     	; 0x2594 <AICI_InterpretPacket+0x2cc>
		default:                                        // Unknown command, return error
			MessageSize = 1;
    2582:	81 e0       	ldi	r24, 0x01	; 1
    2584:	90 e0       	ldi	r25, 0x00	; 0
    2586:	90 93 0f 01 	sts	0x010F, r25
    258a:	80 93 0e 01 	sts	0x010E, r24
			
			PacketBytes[1] = STATUS_CMD_UNKNOWN;
    258e:	89 ec       	ldi	r24, 0xC9	; 201
    2590:	80 93 13 01 	sts	0x0113, r24
	}

	V2P_SendPacket();                                   // Send the response packet
    2594:	0e 94 65 0d 	call	0x1aca <V2P_SendPacket>
    2598:	df 91       	pop	r29
    259a:	cf 91       	pop	r28
    259c:	1f 91       	pop	r17
    259e:	0f 91       	pop	r16
    25a0:	ff 90       	pop	r15
    25a2:	ef 90       	pop	r14
    25a4:	df 90       	pop	r13
    25a6:	08 95       	ret

000025a8 <PM_GetStoredDataSize>:

// ======================================================================================

uint32_t PM_GetStoredDataSize(uint8_t Type)
{
    25a8:	cf 93       	push	r28
    25aa:	df 93       	push	r29
    25ac:	cd b7       	in	r28, 0x3d	; 61
    25ae:	de b7       	in	r29, 0x3e	; 62
    25b0:	24 97       	sbiw	r28, 0x04	; 4
    25b2:	0f b6       	in	r0, 0x3f	; 63
    25b4:	f8 94       	cli
    25b6:	de bf       	out	0x3e, r29	; 62
    25b8:	0f be       	out	0x3f, r0	; 63
    25ba:	cd bf       	out	0x3d, r28	; 61
	/* This take a **LOT** of code (202 bytes), and is accessed several times throughout
	   the program, so I've put it into a seperate function to save on flash.            */

	uint32_t ProgDataSize = 0;
    25bc:	19 82       	std	Y+1, r1	; 0x01
    25be:	1a 82       	std	Y+2, r1	; 0x02
    25c0:	1b 82       	std	Y+3, r1	; 0x03
    25c2:	1c 82       	std	Y+4, r1	; 0x04
void 
eeprom_read_block (void *pointer_ram,
                   const void *pointer_eeprom,
                   size_t n)
{
    25c4:	fe 01       	movw	r30, r28
    25c6:	31 96       	adiw	r30, 0x01	; 1
    25c8:	81 30       	cpi	r24, 0x01	; 1
    25ca:	19 f4       	brne	.+6      	; 0x25d2 <PM_GetStoredDataSize+0x2a>
    25cc:	ab e1       	ldi	r26, 0x1B	; 27
    25ce:	b0 e0       	ldi	r27, 0x00	; 0
    25d0:	02 c0       	rjmp	.+4      	; 0x25d6 <PM_GetStoredDataSize+0x2e>
    25d2:	af e1       	ldi	r26, 0x1F	; 31
    25d4:	b0 e0       	ldi	r27, 0x00	; 0
  if (!__builtin_constant_p (n)
      || n > 256)
    {
      /* make sure size is a 16 bit variable.  */
      uint16_t size = n; 

      asm volatile ( 
            ".%=_start:" CR_TAB
            "sbiw %2,1" CR_TAB
            "brlt .%=_finished" CR_TAB
             XCALL " __eeprom_read_byte_" _REG_LOCATION_SUFFIX CR_TAB
            "st z+,__tmp_reg__" CR_TAB
            "rjmp .%=_start" CR_TAB
            ".%=_finished:" 
          : "=x" (pointer_eeprom),
            "=z" (pointer_ram),
            "+w" (size)
           : "x" (pointer_eeprom), 
             "z" (pointer_ram)
           : "memory");
    }
  else
    {
      if (n != 0)
        {
          if (n == 256)
            {
              asm volatile (
                  XCALL " __eeprom_read_block_" _REG_LOCATION_SUFFIX 
                : "+x" (pointer_eeprom),
                  "=z" (pointer_ram)
                : "z"  (pointer_ram)
                : "memory");
            }
          else
            {
              /* Needed in order to truncate to 8 bit.  */
              uint8_t len;
              len = (uint8_t) n; 
    25d6:	84 e0       	ldi	r24, 0x04	; 4

              asm volatile (
    25d8:	18 2e       	mov	r1, r24
    25da:	0e 94 73 19 	call	0x32e6 <__eeprom_read_block_1F2021>

	eeprom_read_block((void*)&ProgDataSize, (const void*)((Type == TYPE_FLASH)? &EEPROMVars.DataSize : &EEPROMVars.EEPROMSize), 4);

	if (ProgDataSize == 0xFFFFFFFF)                                      // Blank EEPROM, return a size  of 0 bytes
    25de:	89 81       	ldd	r24, Y+1	; 0x01
    25e0:	9a 81       	ldd	r25, Y+2	; 0x02
    25e2:	ab 81       	ldd	r26, Y+3	; 0x03
    25e4:	bc 81       	ldd	r27, Y+4	; 0x04
    25e6:	8f 5f       	subi	r24, 0xFF	; 255
    25e8:	9f 4f       	sbci	r25, 0xFF	; 255
    25ea:	af 4f       	sbci	r26, 0xFF	; 255
    25ec:	bf 4f       	sbci	r27, 0xFF	; 255
    25ee:	21 f4       	brne	.+8      	; 0x25f8 <PM_GetStoredDataSize+0x50>
	   ProgDataSize = 0x00;
    25f0:	19 82       	std	Y+1, r1	; 0x01
    25f2:	1a 82       	std	Y+2, r1	; 0x02
    25f4:	1b 82       	std	Y+3, r1	; 0x03
    25f6:	1c 82       	std	Y+4, r1	; 0x04

	return ProgDataSize;
    25f8:	89 81       	ldd	r24, Y+1	; 0x01
    25fa:	9a 81       	ldd	r25, Y+2	; 0x02
    25fc:	ab 81       	ldd	r26, Y+3	; 0x03
    25fe:	bc 81       	ldd	r27, Y+4	; 0x04
}
    2600:	bc 01       	movw	r22, r24
    2602:	cd 01       	movw	r24, r26
    2604:	24 96       	adiw	r28, 0x04	; 4
    2606:	0f b6       	in	r0, 0x3f	; 63
    2608:	f8 94       	cli
    260a:	de bf       	out	0x3e, r29	; 62
    260c:	0f be       	out	0x3f, r0	; 63
    260e:	cd bf       	out	0x3d, r28	; 61
    2610:	df 91       	pop	r29
    2612:	cf 91       	pop	r28
    2614:	08 95       	ret

00002616 <PM_SetupDFAddressCounters>:

void PM_SetupDFAddressCounters(uint8_t Type)
{
	uint32_t StartAddress;
	
	MemoryType  = Type;
    2616:	80 93 28 02 	sts	0x0228, r24
	GPageLength = 0;
    261a:	10 92 26 02 	sts	0x0226, r1
    261e:	10 92 25 02 	sts	0x0225, r1
    2622:	20 91 09 01 	lds	r18, 0x0109
    2626:	30 91 0a 01 	lds	r19, 0x010A
    262a:	40 91 0b 01 	lds	r20, 0x010B
    262e:	50 91 0c 01 	lds	r21, 0x010C

	if (Type == TYPE_FLASH)                                              // Type 1 = Flash
    2632:	81 30       	cpi	r24, 0x01	; 1
    2634:	39 f4       	brne	.+14     	; 0x2644 <PM_SetupDFAddressCounters+0x2e>
		StartAddress = (CurrAddress << 1);                               // Convert flash word address to byte address
    2636:	da 01       	movw	r26, r20
    2638:	c9 01       	movw	r24, r18
    263a:	88 0f       	add	r24, r24
    263c:	99 1f       	adc	r25, r25
    263e:	aa 1f       	adc	r26, r26
    2640:	bb 1f       	adc	r27, r27
    2642:	06 c0       	rjmp	.+12     	; 0x2650 <PM_SetupDFAddressCounters+0x3a>
	else
		StartAddress = CurrAddress + PM_EEPROM_OFFSET;                   // EEPROM uses byte addresses, and starts at the 257th kilobyte in Dataflash
    2644:	da 01       	movw	r26, r20
    2646:	c9 01       	movw	r24, r18
    2648:	80 50       	subi	r24, 0x00	; 0
    264a:	9c 4f       	sbci	r25, 0xFC	; 252
    264c:	ab 4f       	sbci	r26, 0xFB	; 251
    264e:	bf 4f       	sbci	r27, 0xFF	; 255
	
	CurrPageAddress = 0;
    2650:	10 92 6a 02 	sts	0x026A, r1
    2654:	10 92 69 02 	sts	0x0269, r1

	while (StartAddress >= DF_INTERNALDF_BUFFBYTES)                      // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DF_INTERNALDF_BUFFBYTES;                         // Subtract one page's worth of bytes from the desired address
		CurrPageAddress++;
    2658:	88 30       	cpi	r24, 0x08	; 8
    265a:	21 e0       	ldi	r18, 0x01	; 1
    265c:	92 07       	cpc	r25, r18
    265e:	20 e0       	ldi	r18, 0x00	; 0
    2660:	a2 07       	cpc	r26, r18
    2662:	20 e0       	ldi	r18, 0x00	; 0
    2664:	b2 07       	cpc	r27, r18
    2666:	a0 f0       	brcs	.+40     	; 0x2690 <PM_SetupDFAddressCounters+0x7a>
    2668:	20 e0       	ldi	r18, 0x00	; 0
    266a:	30 e0       	ldi	r19, 0x00	; 0
    266c:	88 50       	subi	r24, 0x08	; 8
    266e:	91 40       	sbci	r25, 0x01	; 1
    2670:	a0 40       	sbci	r26, 0x00	; 0
    2672:	b0 40       	sbci	r27, 0x00	; 0
    2674:	2f 5f       	subi	r18, 0xFF	; 255
    2676:	3f 4f       	sbci	r19, 0xFF	; 255
    2678:	88 30       	cpi	r24, 0x08	; 8
    267a:	41 e0       	ldi	r20, 0x01	; 1
    267c:	94 07       	cpc	r25, r20
    267e:	40 e0       	ldi	r20, 0x00	; 0
    2680:	a4 07       	cpc	r26, r20
    2682:	40 e0       	ldi	r20, 0x00	; 0
    2684:	b4 07       	cpc	r27, r20
    2686:	90 f7       	brcc	.-28     	; 0x266c <PM_SetupDFAddressCounters+0x56>
    2688:	30 93 6a 02 	sts	0x026A, r19
    268c:	20 93 69 02 	sts	0x0269, r18
	}
	
	CurrBuffByte = (uint16_t)StartAddress;                               // The buffer byte is the remainder
    2690:	90 93 63 02 	sts	0x0263, r25
    2694:	80 93 62 02 	sts	0x0262, r24
    2698:	08 95       	ret

0000269a <PM_StoreProgramByte>:
}

void PM_StoreProgramByte(uint8_t Data)
{
    269a:	cf 93       	push	r28
    269c:	c8 2f       	mov	r28, r24
	if (CurrBuffByte == DF_INTERNALDF_BUFFBYTES)
    269e:	80 91 62 02 	lds	r24, 0x0262
    26a2:	90 91 63 02 	lds	r25, 0x0263
    26a6:	88 50       	subi	r24, 0x08	; 8
    26a8:	91 40       	sbci	r25, 0x01	; 1
    26aa:	a9 f4       	brne	.+42     	; 0x26d6 <PM_StoreProgramByte+0x3c>
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
    26ac:	80 91 69 02 	lds	r24, 0x0269
    26b0:	90 91 6a 02 	lds	r25, 0x026A
    26b4:	9c 01       	movw	r18, r24
    26b6:	01 96       	adiw	r24, 0x01	; 1
    26b8:	90 93 6a 02 	sts	0x026A, r25
    26bc:	80 93 69 02 	sts	0x0269, r24
    26c0:	c9 01       	movw	r24, r18
    26c2:	0e 94 65 0a 	call	0x14ca <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    26c6:	80 e0       	ldi	r24, 0x00	; 0
    26c8:	90 e0       	ldi	r25, 0x00	; 0
    26ca:	0e 94 a3 09 	call	0x1346 <DF_BufferWriteEnable>
		CurrBuffByte = 0;
    26ce:	10 92 63 02 	sts	0x0263, r1
    26d2:	10 92 62 02 	sts	0x0262, r1
	}
	
	SPI_SPITransmit(Data);                                               // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    26d6:	8c 2f       	mov	r24, r28
    26d8:	0e 94 89 08 	call	0x1112 <SPI_SPITransmit>
	CurrBuffByte++;
    26dc:	80 91 62 02 	lds	r24, 0x0262
    26e0:	90 91 63 02 	lds	r25, 0x0263
    26e4:	01 96       	adiw	r24, 0x01	; 1
    26e6:	90 93 63 02 	sts	0x0263, r25
    26ea:	80 93 62 02 	sts	0x0262, r24
	GPageLength++;
    26ee:	80 91 25 02 	lds	r24, 0x0225
    26f2:	90 91 26 02 	lds	r25, 0x0226
    26f6:	01 96       	adiw	r24, 0x01	; 1
    26f8:	90 93 26 02 	sts	0x0226, r25
    26fc:	80 93 25 02 	sts	0x0225, r24
    2700:	cf 91       	pop	r28
    2702:	08 95       	ret

00002704 <PM_CheckEndOfProgramming>:
}

void PM_InterpretAVRISPPacket(void)
{
	uint8_t* EEPROMAddress;

	switch (PacketBytes[0])
	{
		case CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
						
			for (uint8_t PacketB = 0; PacketB <= 11; PacketB++)          // Save the enter programming mode command bytes
			  eeprom_write_byte(&EEPROMVars.EnterProgMode[PacketB], PacketBytes[PacketB]);
			
			InProgrammingMode = TRUE;                                    // Set the flag, prevent the user from exiting the V2P state machine			
			CurrentMode = PM_NO_SETUP;                                   // Clear the current mode variable

			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = STATUS_CMD_OK;

			break;			
		case CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;

			PM_CheckEndOfProgramming();                                  // Check if the last command was a program - if so store the program length
			PM_CheckEndOfFuseLockStore();                                // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
			
			InProgrammingMode = FALSE;                                   // Clear the flag, allow the user to exit the V2P state machine

			DF_EnableDataflash(FALSE);

			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
			PacketBytes[1] = STATUS_CMD_OK;

			break;
		case CMD_READ_SIGNATURE_ISP:
			MessageSize = 4;

			PacketBytes[1] = STATUS_CMD_OK;                              // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x01;                                       // Signature bytes all return "01" in storage mode
			PacketBytes[3] = STATUS_CMD_OK;                              // Data byte is encased in CMD_OKs

			break;
		case CMD_CHIP_ERASE_ISP:
			MessageSize = 2;

			for (uint8_t PacketB = 1; PacketB <= 6; PacketB++)          // Save the erase chip command bytes to EEPROM
			  eeprom_write_byte(&EEPROMVars.EraseChip[PacketB], PacketBytes[PacketB]);

			for (uint8_t Byte = 0; Byte < 8; Byte++)                    // Clear the program and EEPROM size counters
			{
				eeprom_write_byte(&EEPROMVars.DataSize[Byte], 0x00);
				eeprom_write_byte(&EEPROMVars.EEPROMSize[Byte], 0x00);
			}
						
			eeprom_write_byte(&EEPROMVars.EraseCmdStored, TRUE);
			
			PacketBytes[1] = STATUS_CMD_OK;
			
			break;
		case CMD_READ_OSCCAL_ISP:
			MessageSize = 4;

			PacketBytes[1] = STATUS_CMD_OK;                             // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x00;                                      // Return 0x00 for the OSCCAL byte
			PacketBytes[3] = STATUS_CMD_OK;                             // Data byte is encased in CMD_OKs

			break;
		case CMD_READ_FUSE_ISP:
		case CMD_READ_LOCK_ISP:
			MessageSize = 4;
	
			if (CurrentMode != PM_LOCKFUSEBITS_READ)                    // First lock or fuse byte being read, set the EEPROM pointer
			{
				PM_CheckEndOfProgramming();                             // Check if the last command was a program - if so store the program length
				PM_CheckEndOfFuseLockStore();                           // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
				
				CurrBuffByte = 0;
				CurrentMode  = PM_LOCKFUSEBITS_READ;
			}
			
			if (CurrBuffByte > eeprom_read_byte((uint8_t*)((PacketBytes[0] == CMD_READ_FUSE_ISP)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes)))    // Trying to read more fuse/lock bytes than are stored in memory
			{
				PacketBytes[2] = 0xFF;                                  // Return 0xFF for the fuse/lock byte
			}
			else
			{
				PacketBytes[2] = eeprom_read_byte((uint8_t*)((PacketBytes[0] == CMD_READ_FUSE_ISP)? &EEPROMVars.FuseBytes : &EEPROMVars.LockBytes) // Starting location
									                         + (CurrBuffByte << 2) + (PacketBytes[1] - 1));                                        // The start position of the actual fuse/lock byte to read (4 bytes each));
			}

			PacketBytes[1] = STATUS_CMD_OK;                            // Data byte is encased in CMD_OKs
			PacketBytes[3] = STATUS_CMD_OK;                            // Data byte is encased in CMD_OKs

			CurrBuffByte++;

			break;
		case CMD_PROGRAM_FUSE_ISP:
		case CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;

			if (CurrentMode != PM_LOCKFUSEBITS_WRITE)                  // First lock or fuse byte being written, set the EEPROM pointer
			{
				CurrentMode   = PM_LOCKFUSEBITS_WRITE;
				CurrBuffByte  = 0;                                     // CurrBuffByte is used to store the total fuse/lock bytes written
			}

			if (PacketBytes[0] == CMD_PROGRAM_FUSE_ISP)
			{
				EEPROMAddress = (uint8_t*)(&EEPROMVars.FuseBytes + (CurrBuffByte << 2));
				MemoryType    = TYPE_FUSE;
			}
			else
			{
				EEPROMAddress = (uint8_t*)(&EEPROMVars.LockBytes + (CurrBuffByte << 2));
				MemoryType    = TYPE_LOCK;
			}				
			
			if (CurrBuffByte < PM_MAX_FUSELOCKBITS)
			{
				for (uint8_t FLByte = 1; FLByte <= 4; FLByte++)
				{
					eeprom_write_byte(EEPROMAddress, PacketBytes[FLByte]);
					EEPROMAddress++;
				}

				CurrBuffByte++;                                        // Increment the total fuse/lock bytes written counter
			}
			
			PacketBytes[1] = STATUS_CMD_OK;                            // Two CMD_OKs are always returned
			PacketBytes[2] = STATUS_CMD_OK;                            // Two CMD_OKs are always returned

			break;
		case CMD_PROGRAM_FLASH_ISP:
		case CMD_PROGRAM_EEPROM_ISP:
			MessageSize = 2;

			if (CurrentMode != PM_DATAFLASH_WRITE)                     // First programming packet
			{
				if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)           // Flash programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram; // Set the eeprom address to the Program command bytes location
					PM_SetupDFAddressCounters(TYPE_FLASH);
				}
				else                                                   // EEPROM programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;  // Set the eeprom address to the EEPROM command bytes location
					PM_SetupDFAddressCounters(TYPE_EEPROM);
				}
				
				DF_BufferWriteEnable(CurrBuffByte);
				CurrentMode = PM_DATAFLASH_WRITE;
				
				for (uint8_t B = 1; B <= 9; B++)                       // Save the command bytes
				{
					eeprom_write_byte(EEPROMAddress, PacketBytes[B]);
					EEPROMAddress++;				
				}
			}

			uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
			                      | PacketBytes[2];

			for (uint16_t CurrByte = 0; CurrByte < BytesToWrite; CurrByte++)
				PM_StoreProgramByte(PacketBytes[10 + CurrByte]);

			if (!(GPageLength & PM_PAGELENGTH_FOUNDBIT) && (PacketBytes[3] & ISPCC_PROG_MODE_PAGEDONE) && GPageLength)
			{
				eeprom_write_word(((MemoryType == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength), GPageLength);
		
				GPageLength |= PM_PAGELENGTH_FOUNDBIT;                 // Bit 15 is used to indicate if the length has been found
			}

			PacketBytes[1] = STATUS_CMD_OK;
		
			break;
		case CMD_READ_FLASH_ISP:
		case CMD_READ_EEPROM_ISP:	
			if (CurrentMode != PM_DATAFLASH_READ)
			{
				PM_CheckEndOfProgramming();                           // Check if the last command was a program - if so store the program length
				PM_CheckEndOfFuseLockStore();                         // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
				
				PM_SetupDFAddressCounters((PacketBytes[0] == CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);
				DF_ContinuousReadEnable(CurrPageAddress, CurrBuffByte);
				
				CurrentMode = PM_DATAFLASH_READ;
				CurrAddress = 0;
			}

			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8)    // \. Load in the number of bytes that is to
			                     | PacketBytes[2];                    // /  be read into a temp variable (MSB first)
						
			uint16_t BytesInMem  = PM_GetStoredDataSize((PacketBytes[0] == CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
			   PacketBytes[2 + ReadByte] = ((CurrAddress < BytesInMem)? SPI_SPITransmit(0x00) : 0xFF); // Read in the next dataflash byte if present
			   V2P_IncrementCurrAddress();
			}
			
			MessageSize = BytesToRead + 3;

			PacketBytes[1]               = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
			PacketBytes[2 + BytesToRead] = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
		
			break;
		default:
			MessageSize = 1;
			
			PacketBytes[1] = STATUS_CMD_UNKNOWN;
	}

	V2P_SendPacket();                                   // Send the response packet
}

void PM_CheckEndOfProgramming(void)
{
    2704:	cf 93       	push	r28
    2706:	df 93       	push	r29
    2708:	cd b7       	in	r28, 0x3d	; 61
    270a:	de b7       	in	r29, 0x3e	; 62
    270c:	24 97       	sbiw	r28, 0x04	; 4
    270e:	0f b6       	in	r0, 0x3f	; 63
    2710:	f8 94       	cli
    2712:	de bf       	out	0x3e, r29	; 62
    2714:	0f be       	out	0x3f, r0	; 63
    2716:	cd bf       	out	0x3d, r28	; 61
	uint8_t* EEPROMAddress;

	if (CurrentMode == PM_DATAFLASH_WRITE)
    2718:	80 91 27 02 	lds	r24, 0x0227
    271c:	81 30       	cpi	r24, 0x01	; 1
    271e:	09 f0       	breq	.+2      	; 0x2722 <PM_CheckEndOfProgramming+0x1e>
    2720:	41 c0       	rjmp	.+130    	; 0x27a4 <PM_CheckEndOfProgramming+0xa0>
	{
		if (CurrBuffByte)                               // Data in the dataflash buffer, pending to be written
    2722:	80 91 62 02 	lds	r24, 0x0262
    2726:	90 91 63 02 	lds	r25, 0x0263
    272a:	89 2b       	or	r24, r25
    272c:	31 f0       	breq	.+12     	; 0x273a <PM_CheckEndOfProgramming+0x36>
		  DF_CopyBufferToFlashPage(CurrPageAddress);   // Save the buffer
    272e:	80 91 69 02 	lds	r24, 0x0269
    2732:	90 91 6a 02 	lds	r25, 0x026A
    2736:	0e 94 65 0a 	call	0x14ca <DF_CopyBufferToFlashPage>

		uint32_t DataSize = ((uint32_t)CurrPageAddress * DF_INTERNALDF_BUFFBYTES) + CurrBuffByte;
    273a:	80 91 69 02 	lds	r24, 0x0269
    273e:	90 91 6a 02 	lds	r25, 0x026A
    2742:	aa 27       	eor	r26, r26
    2744:	bb 27       	eor	r27, r27
    2746:	bc 01       	movw	r22, r24
    2748:	cd 01       	movw	r24, r26
    274a:	28 e0       	ldi	r18, 0x08	; 8
    274c:	31 e0       	ldi	r19, 0x01	; 1
    274e:	40 e0       	ldi	r20, 0x00	; 0
    2750:	50 e0       	ldi	r21, 0x00	; 0
    2752:	0e 94 4c 19 	call	0x3298 <__mulsi3>
    2756:	9b 01       	movw	r18, r22
    2758:	ac 01       	movw	r20, r24
    275a:	80 91 62 02 	lds	r24, 0x0262
    275e:	90 91 63 02 	lds	r25, 0x0263
    2762:	aa 27       	eor	r26, r26
    2764:	bb 27       	eor	r27, r27
    2766:	28 0f       	add	r18, r24
    2768:	39 1f       	adc	r19, r25
    276a:	4a 1f       	adc	r20, r26
    276c:	5b 1f       	adc	r21, r27
    276e:	29 83       	std	Y+1, r18	; 0x01
    2770:	3a 83       	std	Y+2, r19	; 0x02
    2772:	4b 83       	std	Y+3, r20	; 0x03
    2774:	5c 83       	std	Y+4, r21	; 0x04

		if (MemoryType == TYPE_FLASH)
    2776:	80 91 28 02 	lds	r24, 0x0228
    277a:	81 30       	cpi	r24, 0x01	; 1
    277c:	19 f4       	brne	.+6      	; 0x2784 <PM_CheckEndOfProgramming+0x80>
		{
			EEPROMAddress = (uint8_t*)&EEPROMVars.DataSize;       
    277e:	ab e1       	ldi	r26, 0x1B	; 27
    2780:	b0 e0       	ldi	r27, 0x00	; 0
    2782:	0a c0       	rjmp	.+20     	; 0x2798 <PM_CheckEndOfProgramming+0x94>
		}
		else
		{
			EEPROMAddress = (uint8_t*)&EEPROMVars.EEPROMSize;
    2784:	af e1       	ldi	r26, 0x1F	; 31
    2786:	b0 e0       	ldi	r27, 0x00	; 0
			DataSize -= PM_EEPROM_OFFSET;                // Remove DataFlash starting offset
    2788:	20 50       	subi	r18, 0x00	; 0
    278a:	34 40       	sbci	r19, 0x04	; 4
    278c:	44 40       	sbci	r20, 0x04	; 4
    278e:	50 40       	sbci	r21, 0x00	; 0
    2790:	29 83       	std	Y+1, r18	; 0x01
    2792:	3a 83       	std	Y+2, r19	; 0x02
    2794:	4b 83       	std	Y+3, r20	; 0x03
    2796:	5c 83       	std	Y+4, r21	; 0x04
void 
eeprom_write_block (const void *pointer_ram,
                    void *pointer_eeprom,
                    size_t n)
{
    2798:	fe 01       	movw	r30, r28
    279a:	31 96       	adiw	r30, 0x01	; 1
  if (!__builtin_constant_p (n)
      || n > 256)
    {
      /* make sure size is a 16 bit variable.  */
      uint16_t size = n; 

      asm volatile ( 
            ".%=_start:" CR_TAB
            "sbiw %2,1" CR_TAB
            "brlt .%=_finished" CR_TAB
            "ld __tmp_reg__,z+" CR_TAB
             XCALL " __eeprom_write_byte_" _REG_LOCATION_SUFFIX CR_TAB
            "rjmp .%=_start" CR_TAB
            ".%=_finished:" 
          : "=x" (pointer_eeprom),
            "=z" (pointer_ram),
            "+w" (size)
           : "x" (pointer_eeprom), 
             "z" (pointer_ram)
           : "memory");
    }
  else
    {
      /* Do nothing for compile time constant transfer size n == 0.  */
      if (n != 0)
        {
          if (n == 256)
            {
              asm volatile (
                 XCALL " __eeprom_write_block_" _REG_LOCATION_SUFFIX
               : "+x" (pointer_eeprom),
                 "=z" (pointer_ram)
               : "z"  (pointer_ram)
               : "memory" );
            }
          else
            {
              uint8_t len;
              len = (uint8_t) n;
    279c:	84 e0       	ldi	r24, 0x04	; 4

              asm volatile (
    279e:	18 2e       	mov	r1, r24
    27a0:	0e 94 8e 19 	call	0x331c <__eeprom_write_block_1F2021>
    27a4:	24 96       	adiw	r28, 0x04	; 4
    27a6:	0f b6       	in	r0, 0x3f	; 63
    27a8:	f8 94       	cli
    27aa:	de bf       	out	0x3e, r29	; 62
    27ac:	0f be       	out	0x3f, r0	; 63
    27ae:	cd bf       	out	0x3d, r28	; 61
    27b0:	df 91       	pop	r29
    27b2:	cf 91       	pop	r28
    27b4:	08 95       	ret

000027b6 <PM_CheckEndOfFuseLockStore>:
		}

		eeprom_write_block((const void*)&DataSize, (void*)EEPROMAddress, 4);
	}
}

void PM_CheckEndOfFuseLockStore(void)
{
	if (CurrentMode == PM_LOCKFUSEBITS_WRITE)
    27b6:	80 91 27 02 	lds	r24, 0x0227
    27ba:	83 30       	cpi	r24, 0x03	; 3
    27bc:	71 f4       	brne	.+28     	; 0x27da <PM_CheckEndOfFuseLockStore+0x24>
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    27be:	80 91 28 02 	lds	r24, 0x0228
    27c2:	82 30       	cpi	r24, 0x02	; 2
    27c4:	19 f4       	brne	.+6      	; 0x27cc <PM_CheckEndOfFuseLockStore+0x16>
    27c6:	af e2       	ldi	r26, 0x2F	; 47
    27c8:	b0 e0       	ldi	r27, 0x00	; 0
    27ca:	02 c0       	rjmp	.+4      	; 0x27d0 <PM_CheckEndOfFuseLockStore+0x1a>
    27cc:	a0 e3       	ldi	r26, 0x30	; 48
    27ce:	b0 e0       	ldi	r27, 0x00	; 0
    27d0:	80 91 62 02 	lds	r24, 0x0262
  asm volatile (
    27d4:	08 2e       	mov	r0, r24
    27d6:	0e 94 7d 19 	call	0x32fa <__eeprom_write_byte_1F2021>
    27da:	08 95       	ret

000027dc <PM_InterpretAVRISPPacket>:
    27dc:	cf 92       	push	r12
    27de:	df 92       	push	r13
    27e0:	ef 92       	push	r14
    27e2:	ff 92       	push	r15
    27e4:	0f 93       	push	r16
    27e6:	1f 93       	push	r17
    27e8:	cf 93       	push	r28
    27ea:	df 93       	push	r29
    27ec:	40 91 12 01 	lds	r20, 0x0112
    27f0:	84 2f       	mov	r24, r20
    27f2:	99 27       	eor	r25, r25
    27f4:	86 31       	cpi	r24, 0x16	; 22
    27f6:	91 05       	cpc	r25, r1
    27f8:	09 f4       	brne	.+2      	; 0x27fc <PM_InterpretAVRISPPacket+0x20>
    27fa:	b9 c1       	rjmp	.+882    	; 0x2b6e <PM_InterpretAVRISPPacket+0x392>
    27fc:	87 31       	cpi	r24, 0x17	; 23
    27fe:	91 05       	cpc	r25, r1
    2800:	94 f4       	brge	.+36     	; 0x2826 <PM_InterpretAVRISPPacket+0x4a>
    2802:	82 31       	cpi	r24, 0x12	; 18
    2804:	91 05       	cpc	r25, r1
    2806:	09 f4       	brne	.+2      	; 0x280a <PM_InterpretAVRISPPacket+0x2e>
    2808:	68 c0       	rjmp	.+208    	; 0x28da <PM_InterpretAVRISPPacket+0xfe>
    280a:	83 31       	cpi	r24, 0x13	; 19
    280c:	91 05       	cpc	r25, r1
    280e:	3c f4       	brge	.+14     	; 0x281e <PM_InterpretAVRISPPacket+0x42>
    2810:	80 31       	cpi	r24, 0x10	; 16
    2812:	91 05       	cpc	r25, r1
    2814:	11 f1       	breq	.+68     	; 0x285a <PM_InterpretAVRISPPacket+0x7e>
    2816:	41 97       	sbiw	r24, 0x11	; 17
    2818:	09 f4       	brne	.+2      	; 0x281c <PM_InterpretAVRISPPacket+0x40>
    281a:	3f c0       	rjmp	.+126    	; 0x289a <PM_InterpretAVRISPPacket+0xbe>
    281c:	18 c2       	rjmp	.+1072   	; 0x2c4e <PM_InterpretAVRISPPacket+0x472>
    281e:	44 97       	sbiw	r24, 0x14	; 20
    2820:	09 f4       	brne	.+2      	; 0x2824 <PM_InterpretAVRISPPacket+0x48>
    2822:	a5 c1       	rjmp	.+842    	; 0x2b6e <PM_InterpretAVRISPPacket+0x392>
    2824:	38 c1       	rjmp	.+624    	; 0x2a96 <PM_InterpretAVRISPPacket+0x2ba>
    2826:	89 31       	cpi	r24, 0x19	; 25
    2828:	91 05       	cpc	r25, r1
    282a:	09 f4       	brne	.+2      	; 0x282e <PM_InterpretAVRISPPacket+0x52>
    282c:	e2 c0       	rjmp	.+452    	; 0x29f2 <PM_InterpretAVRISPPacket+0x216>
    282e:	8a 31       	cpi	r24, 0x1A	; 26
    2830:	91 05       	cpc	r25, r1
    2832:	44 f4       	brge	.+16     	; 0x2844 <PM_InterpretAVRISPPacket+0x68>
    2834:	87 31       	cpi	r24, 0x17	; 23
    2836:	91 05       	cpc	r25, r1
    2838:	09 f4       	brne	.+2      	; 0x283c <PM_InterpretAVRISPPacket+0x60>
    283a:	db c0       	rjmp	.+438    	; 0x29f2 <PM_InterpretAVRISPPacket+0x216>
    283c:	48 97       	sbiw	r24, 0x18	; 24
    283e:	09 f4       	brne	.+2      	; 0x2842 <PM_InterpretAVRISPPacket+0x66>
    2840:	8b c0       	rjmp	.+278    	; 0x2958 <PM_InterpretAVRISPPacket+0x17c>
    2842:	05 c2       	rjmp	.+1034   	; 0x2c4e <PM_InterpretAVRISPPacket+0x472>
    2844:	8b 31       	cpi	r24, 0x1B	; 27
    2846:	91 05       	cpc	r25, r1
    2848:	e1 f1       	breq	.+120    	; 0x28c2 <PM_InterpretAVRISPPacket+0xe6>
    284a:	8b 31       	cpi	r24, 0x1B	; 27
    284c:	91 05       	cpc	r25, r1
    284e:	0c f4       	brge	.+2      	; 0x2852 <PM_InterpretAVRISPPacket+0x76>
    2850:	83 c0       	rjmp	.+262    	; 0x2958 <PM_InterpretAVRISPPacket+0x17c>
    2852:	4c 97       	sbiw	r24, 0x1c	; 28
    2854:	09 f4       	brne	.+2      	; 0x2858 <PM_InterpretAVRISPPacket+0x7c>
    2856:	73 c0       	rjmp	.+230    	; 0x293e <PM_InterpretAVRISPPacket+0x162>
    2858:	fa c1       	rjmp	.+1012   	; 0x2c4e <PM_InterpretAVRISPPacket+0x472>
    285a:	82 e0       	ldi	r24, 0x02	; 2
    285c:	90 e0       	ldi	r25, 0x00	; 0
    285e:	90 93 0f 01 	sts	0x010F, r25
    2862:	80 93 0e 01 	sts	0x010E, r24
    2866:	e2 e1       	ldi	r30, 0x12	; 18
    2868:	f1 e0       	ldi	r31, 0x01	; 1
    286a:	20 e0       	ldi	r18, 0x00	; 0
    286c:	30 e0       	ldi	r19, 0x00	; 0
    286e:	9b e0       	ldi	r25, 0x0B	; 11
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    2870:	d9 01       	movw	r26, r18
    2872:	ad 5d       	subi	r26, 0xDD	; 221
    2874:	bf 4f       	sbci	r27, 0xFF	; 255
    2876:	81 91       	ld	r24, Z+
  asm volatile (
    2878:	08 2e       	mov	r0, r24
    287a:	0e 94 7d 19 	call	0x32fa <__eeprom_write_byte_1F2021>
    287e:	91 50       	subi	r25, 0x01	; 1
    2880:	2f 5f       	subi	r18, 0xFF	; 255
    2882:	3f 4f       	sbci	r19, 0xFF	; 255
    2884:	97 ff       	sbrs	r25, 7
    2886:	f4 cf       	rjmp	.-24     	; 0x2870 <PM_InterpretAVRISPPacket+0x94>
    2888:	81 e0       	ldi	r24, 0x01	; 1
    288a:	80 93 0d 01 	sts	0x010D, r24
    288e:	10 92 27 02 	sts	0x0227, r1
    2892:	81 b3       	in	r24, 0x11	; 17
    2894:	8f 7c       	andi	r24, 0xCF	; 207
    2896:	80 62       	ori	r24, 0x20	; 32
    2898:	12 c0       	rjmp	.+36     	; 0x28be <PM_InterpretAVRISPPacket+0xe2>
    289a:	82 e0       	ldi	r24, 0x02	; 2
    289c:	90 e0       	ldi	r25, 0x00	; 0
    289e:	90 93 0f 01 	sts	0x010F, r25
    28a2:	80 93 0e 01 	sts	0x010E, r24
    28a6:	0e 94 82 13 	call	0x2704 <PM_CheckEndOfProgramming>
    28aa:	0e 94 db 13 	call	0x27b6 <PM_CheckEndOfFuseLockStore>
    28ae:	10 92 0d 01 	sts	0x010D, r1
    28b2:	80 e0       	ldi	r24, 0x00	; 0
    28b4:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    28b8:	81 b3       	in	r24, 0x11	; 17
    28ba:	8f 7c       	andi	r24, 0xCF	; 207
    28bc:	80 61       	ori	r24, 0x10	; 16
    28be:	81 bb       	out	0x11, r24	; 17
    28c0:	53 c1       	rjmp	.+678    	; 0x2b68 <PM_InterpretAVRISPPacket+0x38c>
    28c2:	84 e0       	ldi	r24, 0x04	; 4
    28c4:	90 e0       	ldi	r25, 0x00	; 0
    28c6:	90 93 0f 01 	sts	0x010F, r25
    28ca:	80 93 0e 01 	sts	0x010E, r24
    28ce:	10 92 13 01 	sts	0x0113, r1
    28d2:	81 e0       	ldi	r24, 0x01	; 1
    28d4:	80 93 14 01 	sts	0x0114, r24
    28d8:	3c c0       	rjmp	.+120    	; 0x2952 <PM_InterpretAVRISPPacket+0x176>
    28da:	82 e0       	ldi	r24, 0x02	; 2
    28dc:	90 e0       	ldi	r25, 0x00	; 0
    28de:	90 93 0f 01 	sts	0x010F, r25
    28e2:	80 93 0e 01 	sts	0x010E, r24
    28e6:	e3 e1       	ldi	r30, 0x13	; 19
    28e8:	f1 e0       	ldi	r31, 0x01	; 1
    28ea:	21 e0       	ldi	r18, 0x01	; 1
    28ec:	30 e0       	ldi	r19, 0x00	; 0
    28ee:	95 e0       	ldi	r25, 0x05	; 5
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    28f0:	d9 01       	movw	r26, r18
    28f2:	ab 5e       	subi	r26, 0xEB	; 235
    28f4:	bf 4f       	sbci	r27, 0xFF	; 255
    28f6:	81 91       	ld	r24, Z+
  asm volatile (
    28f8:	08 2e       	mov	r0, r24
    28fa:	0e 94 7d 19 	call	0x32fa <__eeprom_write_byte_1F2021>
    28fe:	91 50       	subi	r25, 0x01	; 1
    2900:	2f 5f       	subi	r18, 0xFF	; 255
    2902:	3f 4f       	sbci	r19, 0xFF	; 255
    2904:	97 ff       	sbrs	r25, 7
    2906:	f4 cf       	rjmp	.-24     	; 0x28f0 <PM_InterpretAVRISPPacket+0x114>
    2908:	20 e0       	ldi	r18, 0x00	; 0
    290a:	80 e0       	ldi	r24, 0x00	; 0
    290c:	90 e0       	ldi	r25, 0x00	; 0
    290e:	37 e0       	ldi	r19, 0x07	; 7
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    2910:	dc 01       	movw	r26, r24
    2912:	a5 5e       	subi	r26, 0xE5	; 229
    2914:	bf 4f       	sbci	r27, 0xFF	; 255
  asm volatile (
    2916:	02 2e       	mov	r0, r18
    2918:	0e 94 7d 19 	call	0x32fa <__eeprom_write_byte_1F2021>
    291c:	dc 01       	movw	r26, r24
    291e:	a1 5e       	subi	r26, 0xE1	; 225
    2920:	bf 4f       	sbci	r27, 0xFF	; 255
    2922:	02 2e       	mov	r0, r18
    2924:	0e 94 7d 19 	call	0x32fa <__eeprom_write_byte_1F2021>
    2928:	31 50       	subi	r19, 0x01	; 1
    292a:	01 96       	adiw	r24, 0x01	; 1
    292c:	37 ff       	sbrs	r19, 7
    292e:	f0 cf       	rjmp	.-32     	; 0x2910 <PM_InterpretAVRISPPacket+0x134>
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    2930:	a4 e1       	ldi	r26, 0x14	; 20
    2932:	b0 e0       	ldi	r27, 0x00	; 0
    2934:	81 e0       	ldi	r24, 0x01	; 1
  asm volatile (
    2936:	08 2e       	mov	r0, r24
    2938:	0e 94 7d 19 	call	0x32fa <__eeprom_write_byte_1F2021>
    293c:	15 c1       	rjmp	.+554    	; 0x2b68 <PM_InterpretAVRISPPacket+0x38c>
    293e:	84 e0       	ldi	r24, 0x04	; 4
    2940:	90 e0       	ldi	r25, 0x00	; 0
    2942:	90 93 0f 01 	sts	0x010F, r25
    2946:	80 93 0e 01 	sts	0x010E, r24
    294a:	10 92 13 01 	sts	0x0113, r1
    294e:	10 92 14 01 	sts	0x0114, r1
    2952:	10 92 15 01 	sts	0x0115, r1
    2956:	84 c1       	rjmp	.+776    	; 0x2c60 <PM_InterpretAVRISPPacket+0x484>
    2958:	84 e0       	ldi	r24, 0x04	; 4
    295a:	90 e0       	ldi	r25, 0x00	; 0
    295c:	90 93 0f 01 	sts	0x010F, r25
    2960:	80 93 0e 01 	sts	0x010E, r24
    2964:	80 91 27 02 	lds	r24, 0x0227
    2968:	84 30       	cpi	r24, 0x04	; 4
    296a:	59 f0       	breq	.+22     	; 0x2982 <PM_InterpretAVRISPPacket+0x1a6>
    296c:	0e 94 82 13 	call	0x2704 <PM_CheckEndOfProgramming>
    2970:	0e 94 db 13 	call	0x27b6 <PM_CheckEndOfFuseLockStore>
    2974:	10 92 63 02 	sts	0x0263, r1
    2978:	10 92 62 02 	sts	0x0262, r1
    297c:	84 e0       	ldi	r24, 0x04	; 4
    297e:	80 93 27 02 	sts	0x0227, r24
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2982:	60 91 12 01 	lds	r22, 0x0112
    2986:	68 31       	cpi	r22, 0x18	; 24
    2988:	19 f4       	brne	.+6      	; 0x2990 <PM_InterpretAVRISPPacket+0x1b4>
    298a:	af e2       	ldi	r26, 0x2F	; 47
    298c:	b0 e0       	ldi	r27, 0x00	; 0
    298e:	02 c0       	rjmp	.+4      	; 0x2994 <PM_InterpretAVRISPPacket+0x1b8>
    2990:	a0 e3       	ldi	r26, 0x30	; 48
    2992:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    2994:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
    2998:	80 2d       	mov	r24, r0
    299a:	99 27       	eor	r25, r25
    299c:	40 91 62 02 	lds	r20, 0x0262
    29a0:	50 91 63 02 	lds	r21, 0x0263
    29a4:	84 17       	cp	r24, r20
    29a6:	95 07       	cpc	r25, r21
    29a8:	10 f4       	brcc	.+4      	; 0x29ae <PM_InterpretAVRISPPacket+0x1d2>
    29aa:	8f ef       	ldi	r24, 0xFF	; 255
    29ac:	15 c0       	rjmp	.+42     	; 0x29d8 <PM_InterpretAVRISPPacket+0x1fc>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    29ae:	9a 01       	movw	r18, r20
    29b0:	22 0f       	add	r18, r18
    29b2:	33 1f       	adc	r19, r19
    29b4:	22 0f       	add	r18, r18
    29b6:	33 1f       	adc	r19, r19
    29b8:	80 91 13 01 	lds	r24, 0x0113
    29bc:	28 0f       	add	r18, r24
    29be:	31 1d       	adc	r19, r1
    29c0:	68 31       	cpi	r22, 0x18	; 24
    29c2:	21 f4       	brne	.+8      	; 0x29cc <PM_InterpretAVRISPPacket+0x1f0>
    29c4:	d9 01       	movw	r26, r18
    29c6:	a0 5d       	subi	r26, 0xD0	; 208
    29c8:	bf 4f       	sbci	r27, 0xFF	; 255
    29ca:	03 c0       	rjmp	.+6      	; 0x29d2 <PM_InterpretAVRISPPacket+0x1f6>
    29cc:	d9 01       	movw	r26, r18
    29ce:	a8 5a       	subi	r26, 0xA8	; 168
    29d0:	bf 4f       	sbci	r27, 0xFF	; 255
  uint8_t result;
  asm volatile
    29d2:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
    29d6:	80 2d       	mov	r24, r0
    29d8:	80 93 14 01 	sts	0x0114, r24
    29dc:	10 92 13 01 	sts	0x0113, r1
    29e0:	10 92 15 01 	sts	0x0115, r1
    29e4:	4f 5f       	subi	r20, 0xFF	; 255
    29e6:	5f 4f       	sbci	r21, 0xFF	; 255
    29e8:	50 93 63 02 	sts	0x0263, r21
    29ec:	40 93 62 02 	sts	0x0262, r20
    29f0:	37 c1       	rjmp	.+622    	; 0x2c60 <PM_InterpretAVRISPPacket+0x484>
    29f2:	83 e0       	ldi	r24, 0x03	; 3
    29f4:	90 e0       	ldi	r25, 0x00	; 0
    29f6:	90 93 0f 01 	sts	0x010F, r25
    29fa:	80 93 0e 01 	sts	0x010E, r24
    29fe:	80 91 27 02 	lds	r24, 0x0227
    2a02:	83 30       	cpi	r24, 0x03	; 3
    2a04:	39 f0       	breq	.+14     	; 0x2a14 <PM_InterpretAVRISPPacket+0x238>
    2a06:	83 e0       	ldi	r24, 0x03	; 3
    2a08:	80 93 27 02 	sts	0x0227, r24
    2a0c:	10 92 63 02 	sts	0x0263, r1
    2a10:	10 92 62 02 	sts	0x0262, r1
    2a14:	20 91 62 02 	lds	r18, 0x0262
    2a18:	30 91 63 02 	lds	r19, 0x0263
    2a1c:	47 31       	cpi	r20, 0x17	; 23
    2a1e:	69 f4       	brne	.+26     	; 0x2a3a <PM_InterpretAVRISPPacket+0x25e>
    2a20:	80 ea       	ldi	r24, 0xA0	; 160
    2a22:	90 e0       	ldi	r25, 0x00	; 0
    2a24:	28 9f       	mul	r18, r24
    2a26:	e0 01       	movw	r28, r0
    2a28:	29 9f       	mul	r18, r25
    2a2a:	d0 0d       	add	r29, r0
    2a2c:	38 9f       	mul	r19, r24
    2a2e:	d0 0d       	add	r29, r0
    2a30:	11 24       	eor	r1, r1
    2a32:	cf 5c       	subi	r28, 0xCF	; 207
    2a34:	df 4f       	sbci	r29, 0xFF	; 255
    2a36:	82 e0       	ldi	r24, 0x02	; 2
    2a38:	0c c0       	rjmp	.+24     	; 0x2a52 <PM_InterpretAVRISPPacket+0x276>
    2a3a:	80 ea       	ldi	r24, 0xA0	; 160
    2a3c:	90 e0       	ldi	r25, 0x00	; 0
    2a3e:	28 9f       	mul	r18, r24
    2a40:	e0 01       	movw	r28, r0
    2a42:	29 9f       	mul	r18, r25
    2a44:	d0 0d       	add	r29, r0
    2a46:	38 9f       	mul	r19, r24
    2a48:	d0 0d       	add	r29, r0
    2a4a:	11 24       	eor	r1, r1
    2a4c:	c7 5a       	subi	r28, 0xA7	; 167
    2a4e:	df 4f       	sbci	r29, 0xFF	; 255
    2a50:	83 e0       	ldi	r24, 0x03	; 3
    2a52:	80 93 28 02 	sts	0x0228, r24
    2a56:	80 91 62 02 	lds	r24, 0x0262
    2a5a:	90 91 63 02 	lds	r25, 0x0263
    2a5e:	0a 97       	sbiw	r24, 0x0a	; 10
    2a60:	a8 f4       	brcc	.+42     	; 0x2a8c <PM_InterpretAVRISPPacket+0x2b0>
    2a62:	e3 e1       	ldi	r30, 0x13	; 19
    2a64:	f1 e0       	ldi	r31, 0x01	; 1
    2a66:	93 e0       	ldi	r25, 0x03	; 3
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    2a68:	81 91       	ld	r24, Z+
  asm volatile (
    2a6a:	de 01       	movw	r26, r28
    2a6c:	08 2e       	mov	r0, r24
    2a6e:	0e 94 7d 19 	call	0x32fa <__eeprom_write_byte_1F2021>
    2a72:	21 96       	adiw	r28, 0x01	; 1
    2a74:	91 50       	subi	r25, 0x01	; 1
    2a76:	97 ff       	sbrs	r25, 7
    2a78:	f7 cf       	rjmp	.-18     	; 0x2a68 <PM_InterpretAVRISPPacket+0x28c>
    2a7a:	80 91 62 02 	lds	r24, 0x0262
    2a7e:	90 91 63 02 	lds	r25, 0x0263
    2a82:	01 96       	adiw	r24, 0x01	; 1
    2a84:	90 93 63 02 	sts	0x0263, r25
    2a88:	80 93 62 02 	sts	0x0262, r24
    2a8c:	10 92 13 01 	sts	0x0113, r1
    2a90:	10 92 14 01 	sts	0x0114, r1
    2a94:	e5 c0       	rjmp	.+458    	; 0x2c60 <PM_InterpretAVRISPPacket+0x484>
    2a96:	82 e0       	ldi	r24, 0x02	; 2
    2a98:	90 e0       	ldi	r25, 0x00	; 0
    2a9a:	90 93 0f 01 	sts	0x010F, r25
    2a9e:	80 93 0e 01 	sts	0x010E, r24
    2aa2:	80 91 27 02 	lds	r24, 0x0227
    2aa6:	81 30       	cpi	r24, 0x01	; 1
    2aa8:	01 f1       	breq	.+64     	; 0x2aea <PM_InterpretAVRISPPacket+0x30e>
    2aaa:	43 31       	cpi	r20, 0x13	; 19
    2aac:	21 f4       	brne	.+8      	; 0x2ab6 <PM_InterpretAVRISPPacket+0x2da>
    2aae:	c2 e0       	ldi	r28, 0x02	; 2
    2ab0:	d0 e0       	ldi	r29, 0x00	; 0
    2ab2:	81 e0       	ldi	r24, 0x01	; 1
    2ab4:	03 c0       	rjmp	.+6      	; 0x2abc <PM_InterpretAVRISPPacket+0x2e0>
    2ab6:	cb e0       	ldi	r28, 0x0B	; 11
    2ab8:	d0 e0       	ldi	r29, 0x00	; 0
    2aba:	80 e0       	ldi	r24, 0x00	; 0
    2abc:	0e 94 0b 13 	call	0x2616 <PM_SetupDFAddressCounters>
    2ac0:	80 91 62 02 	lds	r24, 0x0262
    2ac4:	90 91 63 02 	lds	r25, 0x0263
    2ac8:	0e 94 a3 09 	call	0x1346 <DF_BufferWriteEnable>
    2acc:	81 e0       	ldi	r24, 0x01	; 1
    2ace:	80 93 27 02 	sts	0x0227, r24
    2ad2:	e3 e1       	ldi	r30, 0x13	; 19
    2ad4:	f1 e0       	ldi	r31, 0x01	; 1
    2ad6:	98 e0       	ldi	r25, 0x08	; 8
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    2ad8:	81 91       	ld	r24, Z+
  asm volatile (
    2ada:	de 01       	movw	r26, r28
    2adc:	08 2e       	mov	r0, r24
    2ade:	0e 94 7d 19 	call	0x32fa <__eeprom_write_byte_1F2021>
    2ae2:	21 96       	adiw	r28, 0x01	; 1
    2ae4:	91 50       	subi	r25, 0x01	; 1
    2ae6:	97 ff       	sbrs	r25, 7
    2ae8:	f7 cf       	rjmp	.-18     	; 0x2ad8 <PM_InterpretAVRISPPacket+0x2fc>
    2aea:	80 91 13 01 	lds	r24, 0x0113
    2aee:	99 27       	eor	r25, r25
    2af0:	d8 2f       	mov	r29, r24
    2af2:	cc 27       	eor	r28, r28
    2af4:	80 91 14 01 	lds	r24, 0x0114
    2af8:	99 27       	eor	r25, r25
    2afa:	c8 2b       	or	r28, r24
    2afc:	d9 2b       	or	r29, r25
    2afe:	00 e0       	ldi	r16, 0x00	; 0
    2b00:	10 e0       	ldi	r17, 0x00	; 0
    2b02:	0c 17       	cp	r16, r28
    2b04:	1d 07       	cpc	r17, r29
    2b06:	70 f4       	brcc	.+28     	; 0x2b24 <PM_InterpretAVRISPPacket+0x348>
    2b08:	5c e1       	ldi	r21, 0x1C	; 28
    2b0a:	e5 2e       	mov	r14, r21
    2b0c:	51 e0       	ldi	r21, 0x01	; 1
    2b0e:	f5 2e       	mov	r15, r21
    2b10:	f7 01       	movw	r30, r14
    2b12:	81 91       	ld	r24, Z+
    2b14:	7f 01       	movw	r14, r30
    2b16:	0e 94 4d 13 	call	0x269a <PM_StoreProgramByte>
    2b1a:	0f 5f       	subi	r16, 0xFF	; 255
    2b1c:	1f 4f       	sbci	r17, 0xFF	; 255
    2b1e:	0c 17       	cp	r16, r28
    2b20:	1d 07       	cpc	r17, r29
    2b22:	b0 f3       	brcs	.-20     	; 0x2b10 <PM_InterpretAVRISPPacket+0x334>
    2b24:	20 91 25 02 	lds	r18, 0x0225
    2b28:	30 91 26 02 	lds	r19, 0x0226
    2b2c:	37 fd       	sbrc	r19, 7
    2b2e:	1c c0       	rjmp	.+56     	; 0x2b68 <PM_InterpretAVRISPPacket+0x38c>
    2b30:	80 91 15 01 	lds	r24, 0x0115
    2b34:	87 ff       	sbrs	r24, 7
    2b36:	18 c0       	rjmp	.+48     	; 0x2b68 <PM_InterpretAVRISPPacket+0x38c>
    2b38:	21 15       	cp	r18, r1
    2b3a:	31 05       	cpc	r19, r1
    2b3c:	a9 f0       	breq	.+42     	; 0x2b68 <PM_InterpretAVRISPPacket+0x38c>
    Write a word \c value to EEPROM address \c addr. */

void 
eeprom_write_word (uint16_t *addr,uint16_t value)
{
    2b3e:	80 91 28 02 	lds	r24, 0x0228
    2b42:	81 30       	cpi	r24, 0x01	; 1
    2b44:	19 f4       	brne	.+6      	; 0x2b4c <PM_InterpretAVRISPPacket+0x370>
    2b46:	a1 e8       	ldi	r26, 0x81	; 129
    2b48:	b0 e0       	ldi	r27, 0x00	; 0
    2b4a:	02 c0       	rjmp	.+4      	; 0x2b50 <PM_InterpretAVRISPPacket+0x374>
    2b4c:	a3 e8       	ldi	r26, 0x83	; 131
    2b4e:	b0 e0       	ldi	r27, 0x00	; 0
  asm volatile (
    2b50:	09 01       	movw	r0, r18
    2b52:	0e 94 89 19 	call	0x3312 <__eeprom_write_word_1F2021>
    2b56:	80 91 25 02 	lds	r24, 0x0225
    2b5a:	90 91 26 02 	lds	r25, 0x0226
    2b5e:	90 68       	ori	r25, 0x80	; 128
    2b60:	90 93 26 02 	sts	0x0226, r25
    2b64:	80 93 25 02 	sts	0x0225, r24
    2b68:	10 92 13 01 	sts	0x0113, r1
    2b6c:	79 c0       	rjmp	.+242    	; 0x2c60 <PM_InterpretAVRISPPacket+0x484>
    2b6e:	80 91 27 02 	lds	r24, 0x0227
    2b72:	82 30       	cpi	r24, 0x02	; 2
    2b74:	11 f1       	breq	.+68     	; 0x2bba <PM_InterpretAVRISPPacket+0x3de>
    2b76:	0e 94 82 13 	call	0x2704 <PM_CheckEndOfProgramming>
    2b7a:	0e 94 db 13 	call	0x27b6 <PM_CheckEndOfFuseLockStore>
    2b7e:	90 e0       	ldi	r25, 0x00	; 0
    2b80:	80 91 12 01 	lds	r24, 0x0112
    2b84:	84 31       	cpi	r24, 0x14	; 20
    2b86:	09 f4       	brne	.+2      	; 0x2b8a <PM_InterpretAVRISPPacket+0x3ae>
    2b88:	91 e0       	ldi	r25, 0x01	; 1
    2b8a:	89 2f       	mov	r24, r25
    2b8c:	0e 94 0b 13 	call	0x2616 <PM_SetupDFAddressCounters>
    2b90:	60 91 62 02 	lds	r22, 0x0262
    2b94:	70 91 63 02 	lds	r23, 0x0263
    2b98:	80 91 69 02 	lds	r24, 0x0269
    2b9c:	90 91 6a 02 	lds	r25, 0x026A
    2ba0:	0e 94 61 09 	call	0x12c2 <DF_ContinuousReadEnable>
    2ba4:	82 e0       	ldi	r24, 0x02	; 2
    2ba6:	80 93 27 02 	sts	0x0227, r24
    2baa:	10 92 09 01 	sts	0x0109, r1
    2bae:	10 92 0a 01 	sts	0x010A, r1
    2bb2:	10 92 0b 01 	sts	0x010B, r1
    2bb6:	10 92 0c 01 	sts	0x010C, r1
    2bba:	80 91 13 01 	lds	r24, 0x0113
    2bbe:	99 27       	eor	r25, r25
    2bc0:	d8 2f       	mov	r29, r24
    2bc2:	cc 27       	eor	r28, r28
    2bc4:	80 91 14 01 	lds	r24, 0x0114
    2bc8:	99 27       	eor	r25, r25
    2bca:	c8 2b       	or	r28, r24
    2bcc:	d9 2b       	or	r29, r25
    2bce:	90 e0       	ldi	r25, 0x00	; 0
    2bd0:	80 91 12 01 	lds	r24, 0x0112
    2bd4:	84 31       	cpi	r24, 0x14	; 20
    2bd6:	09 f4       	brne	.+2      	; 0x2bda <PM_InterpretAVRISPPacket+0x3fe>
    2bd8:	91 e0       	ldi	r25, 0x01	; 1
    2bda:	89 2f       	mov	r24, r25
    2bdc:	0e 94 d4 12 	call	0x25a8 <PM_GetStoredDataSize>
    2be0:	dc 01       	movw	r26, r24
    2be2:	cb 01       	movw	r24, r22
    2be4:	7c 01       	movw	r14, r24
    2be6:	00 e0       	ldi	r16, 0x00	; 0
    2be8:	10 e0       	ldi	r17, 0x00	; 0
    2bea:	0c 17       	cp	r16, r28
    2bec:	1d 07       	cpc	r17, r29
    2bee:	18 f5       	brcc	.+70     	; 0x2c36 <PM_InterpretAVRISPPacket+0x45a>
    2bf0:	34 e1       	ldi	r19, 0x14	; 20
    2bf2:	c3 2e       	mov	r12, r19
    2bf4:	31 e0       	ldi	r19, 0x01	; 1
    2bf6:	d3 2e       	mov	r13, r19
    2bf8:	97 01       	movw	r18, r14
    2bfa:	44 27       	eor	r20, r20
    2bfc:	55 27       	eor	r21, r21
    2bfe:	80 91 09 01 	lds	r24, 0x0109
    2c02:	90 91 0a 01 	lds	r25, 0x010A
    2c06:	a0 91 0b 01 	lds	r26, 0x010B
    2c0a:	b0 91 0c 01 	lds	r27, 0x010C
    2c0e:	82 17       	cp	r24, r18
    2c10:	93 07       	cpc	r25, r19
    2c12:	a4 07       	cpc	r26, r20
    2c14:	b5 07       	cpc	r27, r21
    2c16:	20 f4       	brcc	.+8      	; 0x2c20 <PM_InterpretAVRISPPacket+0x444>
    2c18:	80 e0       	ldi	r24, 0x00	; 0
    2c1a:	0e 94 89 08 	call	0x1112 <SPI_SPITransmit>
    2c1e:	01 c0       	rjmp	.+2      	; 0x2c22 <PM_InterpretAVRISPPacket+0x446>
    2c20:	8f ef       	ldi	r24, 0xFF	; 255
    2c22:	f6 01       	movw	r30, r12
    2c24:	81 93       	st	Z+, r24
    2c26:	6f 01       	movw	r12, r30
    2c28:	0e 94 3d 0e 	call	0x1c7a <V2P_IncrementCurrAddress>
    2c2c:	0f 5f       	subi	r16, 0xFF	; 255
    2c2e:	1f 4f       	sbci	r17, 0xFF	; 255
    2c30:	0c 17       	cp	r16, r28
    2c32:	1d 07       	cpc	r17, r29
    2c34:	08 f3       	brcs	.-62     	; 0x2bf8 <PM_InterpretAVRISPPacket+0x41c>
    2c36:	23 96       	adiw	r28, 0x03	; 3
    2c38:	d0 93 0f 01 	sts	0x010F, r29
    2c3c:	c0 93 0e 01 	sts	0x010E, r28
    2c40:	23 97       	sbiw	r28, 0x03	; 3
    2c42:	10 92 13 01 	sts	0x0113, r1
    2c46:	ce 5e       	subi	r28, 0xEE	; 238
    2c48:	de 4f       	sbci	r29, 0xFE	; 254
    2c4a:	1a 82       	std	Y+2, r1	; 0x02
    2c4c:	09 c0       	rjmp	.+18     	; 0x2c60 <PM_InterpretAVRISPPacket+0x484>
    2c4e:	81 e0       	ldi	r24, 0x01	; 1
    2c50:	90 e0       	ldi	r25, 0x00	; 0
    2c52:	90 93 0f 01 	sts	0x010F, r25
    2c56:	80 93 0e 01 	sts	0x010E, r24
    2c5a:	89 ec       	ldi	r24, 0xC9	; 201
    2c5c:	80 93 13 01 	sts	0x0113, r24
    2c60:	0e 94 65 0d 	call	0x1aca <V2P_SendPacket>
    2c64:	df 91       	pop	r29
    2c66:	cf 91       	pop	r28
    2c68:	1f 91       	pop	r17
    2c6a:	0f 91       	pop	r16
    2c6c:	ff 90       	pop	r15
    2c6e:	ef 90       	pop	r14
    2c70:	df 90       	pop	r13
    2c72:	cf 90       	pop	r12
    2c74:	08 95       	ret

00002c76 <PM_SendFuseLockBytes>:
	  eeprom_write_byte(((MemoryType == TYPE_FUSE)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes), CurrBuffByte); // CurrBuffByte stores the total number of fuse/lock bytes written in this case
}

void PM_SendFuseLockBytes(uint8_t Type)
{
    2c76:	0f 93       	push	r16
    2c78:	1f 93       	push	r17
    2c7a:	cf 93       	push	r28
    2c7c:	df 93       	push	r29
    2c7e:	98 2f       	mov	r25, r24
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2c80:	82 30       	cpi	r24, 0x02	; 2
    2c82:	19 f4       	brne	.+6      	; 0x2c8a <PM_SendFuseLockBytes+0x14>
    2c84:	af e2       	ldi	r26, 0x2F	; 47
    2c86:	b0 e0       	ldi	r27, 0x00	; 0
    2c88:	02 c0       	rjmp	.+4      	; 0x2c8e <PM_SendFuseLockBytes+0x18>
    2c8a:	a0 e3       	ldi	r26, 0x30	; 48
    2c8c:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    2c8e:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
    2c92:	80 2d       	mov	r24, r0
    2c94:	18 2f       	mov	r17, r24
	uint8_t* EEPROMAddress;
	uint8_t  TotalBytes;
	
	TotalBytes = eeprom_read_byte((Type == TYPE_FUSE)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes);

	EEPROMAddress = (uint8_t*)((Type == TYPE_FUSE)? &EEPROMVars.FuseBytes : &EEPROMVars.LockBytes); // Set the EEPROM pointer to the fuse/lock bytes start (each fuse or lock byte takes four bytes in EEPROM)
    2c96:	92 30       	cpi	r25, 0x02	; 2
    2c98:	19 f4       	brne	.+6      	; 0x2ca0 <PM_SendFuseLockBytes+0x2a>
    2c9a:	c1 e3       	ldi	r28, 0x31	; 49
    2c9c:	d0 e0       	ldi	r29, 0x00	; 0
    2c9e:	02 c0       	rjmp	.+4      	; 0x2ca4 <PM_SendFuseLockBytes+0x2e>
    2ca0:	c9 e5       	ldi	r28, 0x59	; 89
    2ca2:	d0 e0       	ldi	r29, 0x00	; 0

	while (TotalBytes--)                              // Write each of the fuse/lock bytes stored in memory to the slave AVR
	{
		for (uint8_t CommandByte = 0; CommandByte < 4; CommandByte++)      // Write each individual command byte
		{
			USI_SPITransmit(eeprom_read_byte(EEPROMAddress));
			EEPROMAddress++;
		}
		
		// Add some delay before programming next byte, if there is one:
		if (TotalBytes)
		   MAIN_Delay10MS(5);
    2ca4:	11 50       	subi	r17, 0x01	; 1
    2ca6:	1f 3f       	cpi	r17, 0xFF	; 255
    2ca8:	91 f0       	breq	.+36     	; 0x2cce <PM_SendFuseLockBytes+0x58>
    2caa:	03 e0       	ldi	r16, 0x03	; 3
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2cac:	de 01       	movw	r26, r28
    2cae:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
    2cb2:	80 2d       	mov	r24, r0
    2cb4:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    2cb8:	21 96       	adiw	r28, 0x01	; 1
    2cba:	01 50       	subi	r16, 0x01	; 1
    2cbc:	07 ff       	sbrs	r16, 7
    2cbe:	f6 cf       	rjmp	.-20     	; 0x2cac <PM_SendFuseLockBytes+0x36>
    2cc0:	11 23       	and	r17, r17
    2cc2:	19 f0       	breq	.+6      	; 0x2cca <PM_SendFuseLockBytes+0x54>
    2cc4:	85 e0       	ldi	r24, 0x05	; 5
    2cc6:	0e 94 17 02 	call	0x42e <MAIN_Delay10MS>
    2cca:	11 50       	subi	r17, 0x01	; 1
    2ccc:	70 f7       	brcc	.-36     	; 0x2caa <PM_SendFuseLockBytes+0x34>
    2cce:	df 91       	pop	r29
    2cd0:	cf 91       	pop	r28
    2cd2:	1f 91       	pop	r17
    2cd4:	0f 91       	pop	r16
    2cd6:	08 95       	ret

00002cd8 <PM_SendEraseCommand>:
	}
}

void PM_SendEraseCommand(void)
{			
    2cd8:	1f 93       	push	r17
    2cda:	cf 93       	push	r28
    2cdc:	df 93       	push	r29
    2cde:	c2 e0       	ldi	r28, 0x02	; 2
    2ce0:	d0 e0       	ldi	r29, 0x00	; 0
    2ce2:	13 e0       	ldi	r17, 0x03	; 3
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2ce4:	de 01       	movw	r26, r28
    2ce6:	ab 5e       	subi	r26, 0xEB	; 235
    2ce8:	bf 4f       	sbci	r27, 0xFF	; 255
  uint8_t result;
  asm volatile
    2cea:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
    2cee:	80 2d       	mov	r24, r0
    2cf0:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
	for (uint8_t B = 2; B < 6 ; B++)                  // Read out the erase chip command bytes
    2cf4:	11 50       	subi	r17, 0x01	; 1
    2cf6:	21 96       	adiw	r28, 0x01	; 1
    2cf8:	17 ff       	sbrs	r17, 7
    2cfa:	f4 cf       	rjmp	.-24     	; 0x2ce4 <PM_SendEraseCommand+0xc>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2cfc:	a6 e1       	ldi	r26, 0x16	; 22
    2cfe:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    2d00:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
    2d04:	80 2d       	mov	r24, r0
    2d06:	88 23       	and	r24, r24
    2d08:	59 f0       	breq	.+22     	; 0x2d20 <PM_SendEraseCommand+0x48>
	  USI_SPITransmit(eeprom_read_byte(&EEPROMVars.EraseChip[B])); // Send the erase chip commands
			
	if (eeprom_read_byte(&EEPROMVars.EraseChip[1]))   // Value of 1 indicates a busy flag test
	{
		do
			USI_SPITransmitWord(0xF000);
    2d0a:	80 e0       	ldi	r24, 0x00	; 0
    2d0c:	90 ef       	ldi	r25, 0xF0	; 240
    2d0e:	0e 94 01 09 	call	0x1202 <USI_SPITransmitWord>
    2d12:	80 e0       	ldi	r24, 0x00	; 0
    2d14:	90 e0       	ldi	r25, 0x00	; 0
    2d16:	0e 94 01 09 	call	0x1202 <USI_SPITransmitWord>
    2d1a:	80 fd       	sbrc	r24, 0
    2d1c:	f6 cf       	rjmp	.-20     	; 0x2d0a <PM_SendEraseCommand+0x32>
    2d1e:	07 c0       	rjmp	.+14     	; 0x2d2e <PM_SendEraseCommand+0x56>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2d20:	a5 e1       	ldi	r26, 0x15	; 21
    2d22:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    2d24:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
    2d28:	80 2d       	mov	r24, r0
    2d2a:	0e 94 ed 02 	call	0x5da <MAIN_Delay1MS>
    2d2e:	df 91       	pop	r29
    2d30:	cf 91       	pop	r28
    2d32:	1f 91       	pop	r17
    2d34:	08 95       	ret

00002d36 <PM_CreateProgrammingPackets>:
		while (USI_SPITransmitWord(0x0000) & 0x01);
	}
	else                                              // Cleared flag means use a predefined delay
	{		
		MAIN_Delay1MS(eeprom_read_byte((uint8_t*)&EEPROMVars.EraseChip)); // Wait the erase delay
	}
}

void PM_CreateProgrammingPackets(uint8_t Type)
{			
    2d36:	3f 92       	push	r3
    2d38:	4f 92       	push	r4
    2d3a:	5f 92       	push	r5
    2d3c:	6f 92       	push	r6
    2d3e:	7f 92       	push	r7
    2d40:	8f 92       	push	r8
    2d42:	9f 92       	push	r9
    2d44:	af 92       	push	r10
    2d46:	bf 92       	push	r11
    2d48:	cf 92       	push	r12
    2d4a:	df 92       	push	r13
    2d4c:	ef 92       	push	r14
    2d4e:	ff 92       	push	r15
    2d50:	0f 93       	push	r16
    2d52:	1f 93       	push	r17
    2d54:	cf 93       	push	r28
    2d56:	df 93       	push	r29
    2d58:	c8 2f       	mov	r28, r24
	uint32_t BytesRead       = 0;
    2d5a:	aa 24       	eor	r10, r10
    2d5c:	bb 24       	eor	r11, r11
    2d5e:	65 01       	movw	r12, r10
	uint32_t BytesToRead     = PM_GetStoredDataSize(Type);      // Get the byte size of the stored program
    2d60:	0e 94 d4 12 	call	0x25a8 <PM_GetStoredDataSize>
    2d64:	2b 01       	movw	r4, r22
    2d66:	3c 01       	movw	r6, r24
	uint16_t BytesPerProgram;
	uint16_t PageLength;
	uint8_t* EEPROMAddress;
	uint8_t  ContinuedPage   = FALSE;
    2d68:	33 24       	eor	r3, r3
/** \ingroup avr_eeprom
    Read one 16-bit word (little endian) from EEPROM address \c addr. */
uint16_t
eeprom_read_word (const uint16_t *addr)
{
    2d6a:	c1 30       	cpi	r28, 0x01	; 1
    2d6c:	19 f4       	brne	.+6      	; 0x2d74 <PM_CreateProgrammingPackets+0x3e>
    2d6e:	a1 e8       	ldi	r26, 0x81	; 129
    2d70:	b0 e0       	ldi	r27, 0x00	; 0
    2d72:	02 c0       	rjmp	.+4      	; 0x2d78 <PM_CreateProgrammingPackets+0x42>
    2d74:	a3 e8       	ldi	r26, 0x83	; 131
    2d76:	b0 e0       	ldi	r27, 0x00	; 0
  uint16_t result;

  asm ( 
    2d78:	0e 94 78 19 	call	0x32f0 <__eeprom_read_word_1F2021>
    2d7c:	4f 01       	movw	r8, r30

	PageLength  = eeprom_read_word((uint16_t*)(Type == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength);
	CurrAddress = 0;
    2d7e:	10 92 09 01 	sts	0x0109, r1
    2d82:	10 92 0a 01 	sts	0x010A, r1
    2d86:	10 92 0b 01 	sts	0x010B, r1
    2d8a:	10 92 0c 01 	sts	0x010C, r1

	if (Type == TYPE_FLASH)
    2d8e:	c1 30       	cpi	r28, 0x01	; 1
    2d90:	49 f4       	brne	.+18     	; 0x2da4 <PM_CreateProgrammingPackets+0x6e>
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram;       // Set the EEPROM pointer to the write flash command bytes location
    2d92:	c2 e0       	ldi	r28, 0x02	; 2
    2d94:	d0 e0       	ldi	r29, 0x00	; 0
		DF_ContinuousReadEnable(0, 0);
    2d96:	60 e0       	ldi	r22, 0x00	; 0
    2d98:	70 e0       	ldi	r23, 0x00	; 0
    2d9a:	cb 01       	movw	r24, r22
    2d9c:	0e 94 61 09 	call	0x12c2 <DF_ContinuousReadEnable>
		PacketBytes[0] = CMD_PROGRAM_FLASH_ISP;
    2da0:	83 e1       	ldi	r24, 0x13	; 19
    2da2:	09 c0       	rjmp	.+18     	; 0x2db6 <PM_CreateProgrammingPackets+0x80>
	}
	else
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;        // Set the EEPROM pointer to the write EEPROM command bytes location
    2da4:	cb e0       	ldi	r28, 0x0B	; 11
    2da6:	d0 e0       	ldi	r29, 0x00	; 0
		DF_ContinuousReadEnable(PM_EEPROM_OFFSET / DF_INTERNALDF_BUFFBYTES, PM_EEPROM_OFFSET % DF_INTERNALDF_BUFFBYTES); // Start read from the EEPROM offset location
    2da8:	60 ee       	ldi	r22, 0xE0	; 224
    2daa:	70 e0       	ldi	r23, 0x00	; 0
    2dac:	84 ee       	ldi	r24, 0xE4	; 228
    2dae:	93 e0       	ldi	r25, 0x03	; 3
    2db0:	0e 94 61 09 	call	0x12c2 <DF_ContinuousReadEnable>
		PacketBytes[0] = CMD_PROGRAM_EEPROM_ISP;
    2db4:	85 e1       	ldi	r24, 0x15	; 21
    2db6:	80 93 12 01 	sts	0x0112, r24
    2dba:	e3 e1       	ldi	r30, 0x13	; 19
    2dbc:	f1 e0       	ldi	r31, 0x01	; 1
    2dbe:	98 e0       	ldi	r25, 0x08	; 8
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2dc0:	de 01       	movw	r26, r28
    2dc2:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
    2dc6:	80 2d       	mov	r24, r0
    2dc8:	81 93       	st	Z+, r24
	}

	for (uint8_t B = 1; B <= 9 ; B++)                 // Load in the write data command bytes
	{
		PacketBytes[B] = eeprom_read_byte(EEPROMAddress); // Synthesise a write packet header
		EEPROMAddress++;                               // Increment the EEPROM location counter
    2dca:	21 96       	adiw	r28, 0x01	; 1
    2dcc:	91 50       	subi	r25, 0x01	; 1
    2dce:	97 ff       	sbrs	r25, 7
    2dd0:	f7 cf       	rjmp	.-18     	; 0x2dc0 <PM_CreateProgrammingPackets+0x8a>
	}
	
	BytesPerProgram = ((uint16_t)PacketBytes[1] << 8)
    2dd2:	80 91 13 01 	lds	r24, 0x0113
    2dd6:	99 27       	eor	r25, r25
    2dd8:	d8 2f       	mov	r29, r24
    2dda:	cc 27       	eor	r28, r28
    2ddc:	80 91 14 01 	lds	r24, 0x0114
    2de0:	99 27       	eor	r25, r25
    2de2:	c8 2b       	or	r28, r24
    2de4:	d9 2b       	or	r29, r25
	                | PacketBytes[2];

	while (BytesRead < BytesToRead)
	{
		if (PacketBytes[3] & ISPCC_PROG_MODE_PAGE)
		{
			if (PageLength > 160) // Max 160 bytes at a time
			{
				if (!(ContinuedPage))                      // Start of a new page, program in the first 150 bytes
				{
					BytesPerProgram = 160;
					PacketBytes[3] &= ~ISPCC_PROG_MODE_PAGEDONE;		
					ContinuedPage = TRUE;
				}
				else                                       // Middle of a page, program in the remainder
				{
					BytesPerProgram = PageLength - 160;
					PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
					ContinuedPage = FALSE;
				}
				
				for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page				

				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);
				PacketBytes[2] = (uint8_t)(BytesPerProgram);

				BytesRead += BytesPerProgram;                         // Increment the counter
			}
			else
			{
				for (uint16_t LoadB = 0; LoadB < PageLength; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page
			
				PacketBytes[1]  = (uint8_t)(PageLength >> 8);
				PacketBytes[2]  = (uint8_t)(PageLength);
				PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;

				BytesRead += PageLength;                            // Increment the counter
			}
		}
		else
		{
			if ((BytesRead + BytesPerProgram) > BytesToRead)        // Less than a whole BytesPerProgram left of data to write
			{
				BytesPerProgram = BytesToRead - BytesRead;          // Next lot of bytes will be the remaining data length
				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);   // \. Save the new length
				PacketBytes[2] = (uint8_t)(BytesPerProgram);        // /  into the data packet
			}

			for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
				PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);    // Load in the page
			
			BytesRead += BytesPerProgram;                           // Increment the counter
		}
	
		if (!(BytesRead & 0xFFFF) && (BytesRead & 0x00FF0000))      // Extended address required
		{
			USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);            // Load extended address command
			USI_SPITransmit(0x00);
			USI_SPITransmit((BytesRead & 0x00FF0000) >> 16);        // The 3rd byte of the long holds the extended address
			USI_SPITransmit(0x00);
		}

		ISPCC_ProgramChip();                                        // Start the program cycle
    2de6:	a4 14       	cp	r10, r4
    2de8:	b5 04       	cpc	r11, r5
    2dea:	c6 04       	cpc	r12, r6
    2dec:	d7 04       	cpc	r13, r7
    2dee:	08 f0       	brcs	.+2      	; 0x2df2 <PM_CreateProgrammingPackets+0xbc>
    2df0:	b2 c0       	rjmp	.+356    	; 0x2f56 <PM_CreateProgrammingPackets+0x220>
    2df2:	20 91 15 01 	lds	r18, 0x0115
    2df6:	82 2f       	mov	r24, r18
    2df8:	99 27       	eor	r25, r25
    2dfa:	ac 01       	movw	r20, r24
    2dfc:	41 70       	andi	r20, 0x01	; 1
    2dfe:	50 70       	andi	r21, 0x00	; 0
    2e00:	80 ff       	sbrs	r24, 0
    2e02:	53 c0       	rjmp	.+166    	; 0x2eaa <PM_CreateProgrammingPackets+0x174>
    2e04:	f1 ea       	ldi	r31, 0xA1	; 161
    2e06:	8f 16       	cp	r8, r31
    2e08:	91 04       	cpc	r9, r1
    2e0a:	60 f1       	brcs	.+88     	; 0x2e64 <PM_CreateProgrammingPackets+0x12e>
    2e0c:	33 20       	and	r3, r3
    2e0e:	41 f4       	brne	.+16     	; 0x2e20 <PM_CreateProgrammingPackets+0xea>
    2e10:	c0 ea       	ldi	r28, 0xA0	; 160
    2e12:	d0 e0       	ldi	r29, 0x00	; 0
    2e14:	2f 77       	andi	r18, 0x7F	; 127
    2e16:	20 93 15 01 	sts	0x0115, r18
    2e1a:	31 e0       	ldi	r19, 0x01	; 1
    2e1c:	33 2e       	mov	r3, r19
    2e1e:	07 c0       	rjmp	.+14     	; 0x2e2e <PM_CreateProgrammingPackets+0xf8>
    2e20:	e4 01       	movw	r28, r8
    2e22:	c0 5a       	subi	r28, 0xA0	; 160
    2e24:	d0 40       	sbci	r29, 0x00	; 0
    2e26:	20 68       	ori	r18, 0x80	; 128
    2e28:	20 93 15 01 	sts	0x0115, r18
    2e2c:	33 24       	eor	r3, r3
    2e2e:	00 e0       	ldi	r16, 0x00	; 0
    2e30:	10 e0       	ldi	r17, 0x00	; 0
    2e32:	0c 17       	cp	r16, r28
    2e34:	1d 07       	cpc	r17, r29
    2e36:	78 f4       	brcc	.+30     	; 0x2e56 <PM_CreateProgrammingPackets+0x120>
    2e38:	2c e1       	ldi	r18, 0x1C	; 28
    2e3a:	e2 2e       	mov	r14, r18
    2e3c:	21 e0       	ldi	r18, 0x01	; 1
    2e3e:	f2 2e       	mov	r15, r18
    2e40:	80 e0       	ldi	r24, 0x00	; 0
    2e42:	0e 94 89 08 	call	0x1112 <SPI_SPITransmit>
    2e46:	f7 01       	movw	r30, r14
    2e48:	81 93       	st	Z+, r24
    2e4a:	7f 01       	movw	r14, r30
    2e4c:	0f 5f       	subi	r16, 0xFF	; 255
    2e4e:	1f 4f       	sbci	r17, 0xFF	; 255
    2e50:	0c 17       	cp	r16, r28
    2e52:	1d 07       	cpc	r17, r29
    2e54:	a8 f3       	brcs	.-22     	; 0x2e40 <PM_CreateProgrammingPackets+0x10a>
    2e56:	8d 2f       	mov	r24, r29
    2e58:	99 27       	eor	r25, r25
    2e5a:	80 93 13 01 	sts	0x0113, r24
    2e5e:	c0 93 14 01 	sts	0x0114, r28
    2e62:	4b c0       	rjmp	.+150    	; 0x2efa <PM_CreateProgrammingPackets+0x1c4>
    2e64:	00 e0       	ldi	r16, 0x00	; 0
    2e66:	10 e0       	ldi	r17, 0x00	; 0
    2e68:	08 15       	cp	r16, r8
    2e6a:	19 05       	cpc	r17, r9
    2e6c:	78 f4       	brcc	.+30     	; 0x2e8c <PM_CreateProgrammingPackets+0x156>
    2e6e:	8c e1       	ldi	r24, 0x1C	; 28
    2e70:	e8 2e       	mov	r14, r24
    2e72:	81 e0       	ldi	r24, 0x01	; 1
    2e74:	f8 2e       	mov	r15, r24
    2e76:	80 e0       	ldi	r24, 0x00	; 0
    2e78:	0e 94 89 08 	call	0x1112 <SPI_SPITransmit>
    2e7c:	f7 01       	movw	r30, r14
    2e7e:	81 93       	st	Z+, r24
    2e80:	7f 01       	movw	r14, r30
    2e82:	0f 5f       	subi	r16, 0xFF	; 255
    2e84:	1f 4f       	sbci	r17, 0xFF	; 255
    2e86:	08 15       	cp	r16, r8
    2e88:	19 05       	cpc	r17, r9
    2e8a:	a8 f3       	brcs	.-22     	; 0x2e76 <PM_CreateProgrammingPackets+0x140>
    2e8c:	89 2d       	mov	r24, r9
    2e8e:	99 27       	eor	r25, r25
    2e90:	80 93 13 01 	sts	0x0113, r24
    2e94:	80 92 14 01 	sts	0x0114, r8
    2e98:	80 91 15 01 	lds	r24, 0x0115
    2e9c:	80 68       	ori	r24, 0x80	; 128
    2e9e:	80 93 15 01 	sts	0x0115, r24
    2ea2:	c4 01       	movw	r24, r8
    2ea4:	aa 27       	eor	r26, r26
    2ea6:	bb 27       	eor	r27, r27
    2ea8:	2b c0       	rjmp	.+86     	; 0x2f00 <PM_CreateProgrammingPackets+0x1ca>
    2eaa:	ce 01       	movw	r24, r28
    2eac:	aa 27       	eor	r26, r26
    2eae:	bb 27       	eor	r27, r27
    2eb0:	8a 0d       	add	r24, r10
    2eb2:	9b 1d       	adc	r25, r11
    2eb4:	ac 1d       	adc	r26, r12
    2eb6:	bd 1d       	adc	r27, r13
    2eb8:	48 16       	cp	r4, r24
    2eba:	59 06       	cpc	r5, r25
    2ebc:	6a 06       	cpc	r6, r26
    2ebe:	7b 06       	cpc	r7, r27
    2ec0:	48 f4       	brcc	.+18     	; 0x2ed4 <PM_CreateProgrammingPackets+0x19e>
    2ec2:	e2 01       	movw	r28, r4
    2ec4:	ca 19       	sub	r28, r10
    2ec6:	db 09       	sbc	r29, r11
    2ec8:	8d 2f       	mov	r24, r29
    2eca:	99 27       	eor	r25, r25
    2ecc:	80 93 13 01 	sts	0x0113, r24
    2ed0:	c0 93 14 01 	sts	0x0114, r28
    2ed4:	8a 01       	movw	r16, r20
    2ed6:	4c 17       	cp	r20, r28
    2ed8:	5d 07       	cpc	r21, r29
    2eda:	78 f4       	brcc	.+30     	; 0x2efa <PM_CreateProgrammingPackets+0x1c4>
    2edc:	ac e1       	ldi	r26, 0x1C	; 28
    2ede:	ea 2e       	mov	r14, r26
    2ee0:	a1 e0       	ldi	r26, 0x01	; 1
    2ee2:	fa 2e       	mov	r15, r26
    2ee4:	80 e0       	ldi	r24, 0x00	; 0
    2ee6:	0e 94 89 08 	call	0x1112 <SPI_SPITransmit>
    2eea:	f7 01       	movw	r30, r14
    2eec:	81 93       	st	Z+, r24
    2eee:	7f 01       	movw	r14, r30
    2ef0:	0f 5f       	subi	r16, 0xFF	; 255
    2ef2:	1f 4f       	sbci	r17, 0xFF	; 255
    2ef4:	0c 17       	cp	r16, r28
    2ef6:	1d 07       	cpc	r17, r29
    2ef8:	a8 f3       	brcs	.-22     	; 0x2ee4 <PM_CreateProgrammingPackets+0x1ae>
    2efa:	ce 01       	movw	r24, r28
    2efc:	aa 27       	eor	r26, r26
    2efe:	bb 27       	eor	r27, r27
    2f00:	a8 0e       	add	r10, r24
    2f02:	b9 1e       	adc	r11, r25
    2f04:	ca 1e       	adc	r12, r26
    2f06:	db 1e       	adc	r13, r27
    2f08:	a1 14       	cp	r10, r1
    2f0a:	b1 04       	cpc	r11, r1
    2f0c:	e1 f4       	brne	.+56     	; 0x2f46 <PM_CreateProgrammingPackets+0x210>
    2f0e:	e1 2c       	mov	r14, r1
    2f10:	f1 2c       	mov	r15, r1
    2f12:	ff ef       	ldi	r31, 0xFF	; 255
    2f14:	0f 2f       	mov	r16, r31
    2f16:	11 2d       	mov	r17, r1
    2f18:	ea 20       	and	r14, r10
    2f1a:	fb 20       	and	r15, r11
    2f1c:	0c 21       	and	r16, r12
    2f1e:	1d 21       	and	r17, r13
    2f20:	e1 14       	cp	r14, r1
    2f22:	f1 04       	cpc	r15, r1
    2f24:	01 05       	cpc	r16, r1
    2f26:	11 05       	cpc	r17, r1
    2f28:	71 f0       	breq	.+28     	; 0x2f46 <PM_CreateProgrammingPackets+0x210>
    2f2a:	8d e4       	ldi	r24, 0x4D	; 77
    2f2c:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    2f30:	80 e0       	ldi	r24, 0x00	; 0
    2f32:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    2f36:	c8 01       	movw	r24, r16
    2f38:	aa 27       	eor	r26, r26
    2f3a:	bb 27       	eor	r27, r27
    2f3c:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    2f40:	80 e0       	ldi	r24, 0x00	; 0
    2f42:	0e 94 ee 08 	call	0x11dc <USI_SPITransmit>
    2f46:	0e 94 7c 10 	call	0x20f8 <ISPCC_ProgramChip>
    2f4a:	a4 14       	cp	r10, r4
    2f4c:	b5 04       	cpc	r11, r5
    2f4e:	c6 04       	cpc	r12, r6
    2f50:	d7 04       	cpc	r13, r7
    2f52:	08 f4       	brcc	.+2      	; 0x2f56 <PM_CreateProgrammingPackets+0x220>
    2f54:	4e cf       	rjmp	.-356    	; 0x2df2 <PM_CreateProgrammingPackets+0xbc>
    2f56:	df 91       	pop	r29
    2f58:	cf 91       	pop	r28
    2f5a:	1f 91       	pop	r17
    2f5c:	0f 91       	pop	r16
    2f5e:	ff 90       	pop	r15
    2f60:	ef 90       	pop	r14
    2f62:	df 90       	pop	r13
    2f64:	cf 90       	pop	r12
    2f66:	bf 90       	pop	r11
    2f68:	af 90       	pop	r10
    2f6a:	9f 90       	pop	r9
    2f6c:	8f 90       	pop	r8
    2f6e:	7f 90       	pop	r7
    2f70:	6f 90       	pop	r6
    2f72:	5f 90       	pop	r5
    2f74:	4f 90       	pop	r4
    2f76:	3f 90       	pop	r3
    2f78:	08 95       	ret

00002f7a <PM_ShowStoredItemSizes>:
	}
}

void PM_ShowStoredItemSizes(void)
{
    2f7a:	1f 93       	push	r17
    2f7c:	cf 93       	push	r28
    2f7e:	df 93       	push	r29
    2f80:	cd b7       	in	r28, 0x3d	; 61
    2f82:	de b7       	in	r29, 0x3e	; 62
    2f84:	2e 97       	sbiw	r28, 0x0e	; 14
    2f86:	0f b6       	in	r0, 0x3f	; 63
    2f88:	f8 94       	cli
    2f8a:	de bf       	out	0x3e, r29	; 62
    2f8c:	0f be       	out	0x3f, r0	; 63
    2f8e:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[14];
	uint8_t ItemInfoIndex = 0;
    2f90:	10 e0       	ldi	r17, 0x00	; 0
	uint8_t TempB;
	
	JoyStatus = 1;
    2f92:	81 e0       	ldi	r24, 0x01	; 1
    2f94:	8e bb       	out	0x1e, r24	; 30
	
	while (1)
	{
		if (JoyStatus)                           // Joystick is in the non-center position
    2f96:	8e b3       	in	r24, 0x1e	; 30
    2f98:	88 23       	and	r24, r24
    2f9a:	e9 f3       	breq	.-6      	; 0x2f96 <PM_ShowStoredItemSizes+0x1c>
		{
			if (JoyStatus & JOY_UP)              // Previous item
    2f9c:	f6 9b       	sbis	0x1e, 6	; 30
    2f9e:	06 c0       	rjmp	.+12     	; 0x2fac <PM_ShowStoredItemSizes+0x32>
				(ItemInfoIndex == 0)? ItemInfoIndex = 3 : ItemInfoIndex--;
    2fa0:	11 23       	and	r17, r17
    2fa2:	11 f4       	brne	.+4      	; 0x2fa8 <PM_ShowStoredItemSizes+0x2e>
    2fa4:	13 e0       	ldi	r17, 0x03	; 3
    2fa6:	0c c0       	rjmp	.+24     	; 0x2fc0 <PM_ShowStoredItemSizes+0x46>
    2fa8:	11 50       	subi	r17, 0x01	; 1
    2faa:	0a c0       	rjmp	.+20     	; 0x2fc0 <PM_ShowStoredItemSizes+0x46>
			else if (JoyStatus & JOY_DOWN)      // Next item
    2fac:	f7 9b       	sbis	0x1e, 7	; 30
    2fae:	06 c0       	rjmp	.+12     	; 0x2fbc <PM_ShowStoredItemSizes+0x42>
				(ItemInfoIndex == 3)? ItemInfoIndex = 0 : ItemInfoIndex++;
    2fb0:	13 30       	cpi	r17, 0x03	; 3
    2fb2:	11 f4       	brne	.+4      	; 0x2fb8 <PM_ShowStoredItemSizes+0x3e>
    2fb4:	10 e0       	ldi	r17, 0x00	; 0
    2fb6:	04 c0       	rjmp	.+8      	; 0x2fc0 <PM_ShowStoredItemSizes+0x46>
    2fb8:	1f 5f       	subi	r17, 0xFF	; 255
    2fba:	02 c0       	rjmp	.+4      	; 0x2fc0 <PM_ShowStoredItemSizes+0x46>
			else if (JoyStatus & JOY_LEFT)
    2fbc:	f2 99       	sbic	0x1e, 2	; 30
    2fbe:	54 c0       	rjmp	.+168    	; 0x3068 <PM_ShowStoredItemSizes+0xee>
				return;
		
			switch (ItemInfoIndex)
    2fc0:	81 2f       	mov	r24, r17
    2fc2:	99 27       	eor	r25, r25
    2fc4:	81 30       	cpi	r24, 0x01	; 1
    2fc6:	91 05       	cpc	r25, r1
    2fc8:	a1 f0       	breq	.+40     	; 0x2ff2 <PM_ShowStoredItemSizes+0x78>
    2fca:	82 30       	cpi	r24, 0x02	; 2
    2fcc:	91 05       	cpc	r25, r1
    2fce:	1c f4       	brge	.+6      	; 0x2fd6 <PM_ShowStoredItemSizes+0x5c>
    2fd0:	89 2b       	or	r24, r25
    2fd2:	39 f0       	breq	.+14     	; 0x2fe2 <PM_ShowStoredItemSizes+0x68>
    2fd4:	42 c0       	rjmp	.+132    	; 0x305a <PM_ShowStoredItemSizes+0xe0>
    2fd6:	82 30       	cpi	r24, 0x02	; 2
    2fd8:	91 05       	cpc	r25, r1
    2fda:	01 f1       	breq	.+64     	; 0x301c <PM_ShowStoredItemSizes+0xa2>
    2fdc:	03 97       	sbiw	r24, 0x03	; 3
    2fde:	39 f1       	breq	.+78     	; 0x302e <PM_ShowStoredItemSizes+0xb4>
    2fe0:	3c c0       	rjmp	.+120    	; 0x305a <PM_ShowStoredItemSizes+0xe0>
			{
				case 0:
					strcpy_P(Buffer, PSTR("DATA-"));
    2fe2:	64 ed       	ldi	r22, 0xD4	; 212
    2fe4:	73 e0       	ldi	r23, 0x03	; 3
    2fe6:	ce 01       	movw	r24, r28
    2fe8:	01 96       	adiw	r24, 0x01	; 1
    2fea:	0e 94 10 19 	call	0x3220 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_FLASH), &Buffer[5], 10);
    2fee:	81 e0       	ldi	r24, 0x01	; 1
    2ff0:	07 c0       	rjmp	.+14     	; 0x3000 <PM_ShowStoredItemSizes+0x86>
					break;
				case 1:
					strcpy_P(Buffer, PSTR("EPRM-"));
    2ff2:	6a ed       	ldi	r22, 0xDA	; 218
    2ff4:	73 e0       	ldi	r23, 0x03	; 3
    2ff6:	ce 01       	movw	r24, r28
    2ff8:	01 96       	adiw	r24, 0x01	; 1
    2ffa:	0e 94 10 19 	call	0x3220 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_EEPROM), &Buffer[5], 10);
    2ffe:	80 e0       	ldi	r24, 0x00	; 0
    3000:	0e 94 d4 12 	call	0x25a8 <PM_GetStoredDataSize>
    3004:	dc 01       	movw	r26, r24
    3006:	cb 01       	movw	r24, r22
    3008:	2a e0       	ldi	r18, 0x0A	; 10
    300a:	30 e0       	ldi	r19, 0x00	; 0
    300c:	ae 01       	movw	r20, r28
    300e:	4a 5f       	subi	r20, 0xFA	; 250
    3010:	5f 4f       	sbci	r21, 0xFF	; 255
    3012:	bc 01       	movw	r22, r24
    3014:	cd 01       	movw	r24, r26
    3016:	0e 94 17 19 	call	0x322e <ultoa>
					break;
    301a:	1f c0       	rjmp	.+62     	; 0x305a <PM_ShowStoredItemSizes+0xe0>
				case 2:
					strcpy_P(Buffer, PSTR("FUSE-"));
    301c:	60 ee       	ldi	r22, 0xE0	; 224
    301e:	73 e0       	ldi	r23, 0x03	; 3
    3020:	ce 01       	movw	r24, r28
    3022:	01 96       	adiw	r24, 0x01	; 1
    3024:	0e 94 10 19 	call	0x3220 <strcpy_P>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    3028:	af e2       	ldi	r26, 0x2F	; 47
    302a:	b0 e0       	ldi	r27, 0x00	; 0
    302c:	08 c0       	rjmp	.+16     	; 0x303e <PM_ShowStoredItemSizes+0xc4>
					TempB = eeprom_read_byte(&EEPROMVars.TotalFuseBytes);
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);
					break;
				case 3:
					strcpy_P(Buffer, PSTR("LOCK-"));
    302e:	66 ee       	ldi	r22, 0xE6	; 230
    3030:	73 e0       	ldi	r23, 0x03	; 3
    3032:	ce 01       	movw	r24, r28
    3034:	01 96       	adiw	r24, 0x01	; 1
    3036:	0e 94 10 19 	call	0x3220 <strcpy_P>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    303a:	a0 e3       	ldi	r26, 0x30	; 48
    303c:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    303e:	0e 94 6b 19 	call	0x32d6 <__eeprom_read_byte_1F2021>
    3042:	80 2d       	mov	r24, r0
					TempB = eeprom_read_byte(&EEPROMVars.TotalLockBytes);
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);		
    3044:	8f 3f       	cpi	r24, 0xFF	; 255
    3046:	11 f0       	breq	.+4      	; 0x304c <PM_ShowStoredItemSizes+0xd2>
    3048:	99 27       	eor	r25, r25
    304a:	02 c0       	rjmp	.+4      	; 0x3050 <PM_ShowStoredItemSizes+0xd6>
    304c:	80 e0       	ldi	r24, 0x00	; 0
    304e:	90 e0       	ldi	r25, 0x00	; 0
    3050:	be 01       	movw	r22, r28
    3052:	6a 5f       	subi	r22, 0xFA	; 250
    3054:	7f 4f       	sbci	r23, 0xFF	; 255
    3056:	0e 94 1b 03 	call	0x636 <MAIN_IntToStr>
			}
	
			LCD_puts(Buffer);
    305a:	ce 01       	movw	r24, r28
    305c:	01 96       	adiw	r24, 0x01	; 1
    305e:	0e 94 50 07 	call	0xea0 <LCD_puts>

			MAIN_WaitForJoyRelease();
    3062:	0e 94 29 02 	call	0x452 <MAIN_WaitForJoyRelease>
    3066:	97 cf       	rjmp	.-210    	; 0x2f96 <PM_ShowStoredItemSizes+0x1c>
    3068:	2e 96       	adiw	r28, 0x0e	; 14
    306a:	0f b6       	in	r0, 0x3f	; 63
    306c:	f8 94       	cli
    306e:	de bf       	out	0x3e, r29	; 62
    3070:	0f be       	out	0x3f, r0	; 63
    3072:	cd bf       	out	0x3d, r28	; 61
    3074:	df 91       	pop	r29
    3076:	cf 91       	pop	r28
    3078:	1f 91       	pop	r17
    307a:	08 95       	ret

0000307c <TM_FindNextTag>:
	DF_EnableDataflash(FALSE);
}

void TM_FindNextTag(void)
{
    307c:	af 92       	push	r10
    307e:	bf 92       	push	r11
    3080:	df 92       	push	r13
    3082:	ef 92       	push	r14
    3084:	ff 92       	push	r15
    3086:	0f 93       	push	r16
    3088:	1f 93       	push	r17
    308a:	cf 93       	push	r28
    308c:	df 93       	push	r29
    308e:	cd b7       	in	r28, 0x3d	; 61
    3090:	de b7       	in	r29, 0x3e	; 62
    3092:	69 97       	sbiw	r28, 0x19	; 25
    3094:	0f b6       	in	r0, 0x3f	; 63
    3096:	f8 94       	cli
    3098:	de bf       	out	0x3e, r29	; 62
    309a:	0f be       	out	0x3f, r0	; 63
    309c:	cd bf       	out	0x3d, r28	; 61
	uint8_t  Buffer[21];
	uint8_t  HeadBuff[4]      = BT_TAGHEADER;
    309e:	80 e4       	ldi	r24, 0x40	; 64
    30a0:	8e 8b       	std	Y+22, r24	; 0x16
    30a2:	86 e1       	ldi	r24, 0x16	; 22
    30a4:	a8 2e       	mov	r10, r24
    30a6:	b1 2c       	mov	r11, r1
    30a8:	ac 0e       	add	r10, r28
    30aa:	bd 1e       	adc	r11, r29
    30ac:	88 e2       	ldi	r24, 0x28	; 40
    30ae:	8f 8b       	std	Y+23, r24	; 0x17
    30b0:	83 e2       	ldi	r24, 0x23	; 35
    30b2:	88 8f       	std	Y+24, r24	; 0x18
    30b4:	89 e2       	ldi	r24, 0x29	; 41
    30b6:	89 8f       	std	Y+25, r24	; 0x19
	uint32_t ProgDataSize     = PM_GetStoredDataSize(TYPE_FLASH);
    30b8:	81 e0       	ldi	r24, 0x01	; 1
    30ba:	0e 94 d4 12 	call	0x25a8 <PM_GetStoredDataSize>
    30be:	7b 01       	movw	r14, r22
    30c0:	8c 01       	movw	r16, r24
	uint8_t  TotalOkHeadBytes = 0;
    30c2:	dd 24       	eor	r13, r13
	uint8_t  TagByte;
	uint8_t  BytesRead;
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);    // Orange = busy
    30c4:	81 b3       	in	r24, 0x11	; 17
    30c6:	80 63       	ori	r24, 0x30	; 48
    30c8:	81 bb       	out	0x11, r24	; 17

	while (DFPos < ProgDataSize)
	{
		BytesRead = 1;
		
		if (SPI_SPITransmit(0x00) == HeadBuff[TotalOkHeadBytes++])
		{
			if (TotalOkHeadBytes == 4)
			{
				uint8_t HB;
			
				for (HB = 0; HB < 20; HB++)
				{
					TagByte = SPI_SPITransmit(0x00);
					Buffer[HB] = TagByte;
					
					if (TagByte == 0x00)
					  break;
				}
				
				Buffer[20] = '\0';             // Make sure string is null-terminated

				TagExists = TRUE;
				BytesRead = (HB + 2);

				LCD_puts(Buffer);
				MAIN_SETSTATUSLED(MAIN_STATLED_GREEN); // Green = ready
				return;
			}
		}
		else
		{
			TotalOkHeadBytes = 0;
		}

		DFPos += BytesRead;
    30ca:	80 91 b0 02 	lds	r24, 0x02B0
    30ce:	90 91 b1 02 	lds	r25, 0x02B1
    30d2:	a0 91 b2 02 	lds	r26, 0x02B2
    30d6:	b0 91 b3 02 	lds	r27, 0x02B3
    30da:	8e 15       	cp	r24, r14
    30dc:	9f 05       	cpc	r25, r15
    30de:	a0 07       	cpc	r26, r16
    30e0:	b1 07       	cpc	r27, r17
    30e2:	08 f0       	brcs	.+2      	; 0x30e6 <TM_FindNextTag+0x6a>
    30e4:	43 c0       	rjmp	.+134    	; 0x316c <TM_FindNextTag+0xf0>
    30e6:	80 e0       	ldi	r24, 0x00	; 0
    30e8:	0e 94 89 08 	call	0x1112 <SPI_SPITransmit>
    30ec:	f5 01       	movw	r30, r10
    30ee:	ed 0d       	add	r30, r13
    30f0:	f1 1d       	adc	r31, r1
    30f2:	d3 94       	inc	r13
    30f4:	90 81       	ld	r25, Z
    30f6:	89 17       	cp	r24, r25
    30f8:	21 f5       	brne	.+72     	; 0x3142 <TM_FindNextTag+0xc6>
    30fa:	84 e0       	ldi	r24, 0x04	; 4
    30fc:	d8 16       	cp	r13, r24
    30fe:	11 f5       	brne	.+68     	; 0x3144 <TM_FindNextTag+0xc8>
    3100:	ff 24       	eor	r15, r15
    3102:	00 e0       	ldi	r16, 0x00	; 0
    3104:	10 e0       	ldi	r17, 0x00	; 0
    3106:	80 e0       	ldi	r24, 0x00	; 0
    3108:	0e 94 89 08 	call	0x1112 <SPI_SPITransmit>
    310c:	9e 01       	movw	r18, r28
    310e:	2f 5f       	subi	r18, 0xFF	; 255
    3110:	3f 4f       	sbci	r19, 0xFF	; 255
    3112:	f8 01       	movw	r30, r16
    3114:	e2 0f       	add	r30, r18
    3116:	f3 1f       	adc	r31, r19
    3118:	80 83       	st	Z, r24
    311a:	88 23       	and	r24, r24
    311c:	31 f0       	breq	.+12     	; 0x312a <TM_FindNextTag+0xae>
    311e:	f3 94       	inc	r15
    3120:	0f 5f       	subi	r16, 0xFF	; 255
    3122:	1f 4f       	sbci	r17, 0xFF	; 255
    3124:	83 e1       	ldi	r24, 0x13	; 19
    3126:	8f 15       	cp	r24, r15
    3128:	70 f7       	brcc	.-36     	; 0x3106 <TM_FindNextTag+0x8a>
    312a:	1d 8a       	std	Y+21, r1	; 0x15
    312c:	81 e0       	ldi	r24, 0x01	; 1
    312e:	80 93 29 02 	sts	0x0229, r24
    3132:	c9 01       	movw	r24, r18
    3134:	0e 94 50 07 	call	0xea0 <LCD_puts>
    3138:	81 b3       	in	r24, 0x11	; 17
    313a:	8f 7c       	andi	r24, 0xCF	; 207
    313c:	80 61       	ori	r24, 0x10	; 16
    313e:	81 bb       	out	0x11, r24	; 17
    3140:	31 c0       	rjmp	.+98     	; 0x31a4 <TM_FindNextTag+0x128>
    3142:	dd 24       	eor	r13, r13
    3144:	80 91 b0 02 	lds	r24, 0x02B0
    3148:	90 91 b1 02 	lds	r25, 0x02B1
    314c:	a0 91 b2 02 	lds	r26, 0x02B2
    3150:	b0 91 b3 02 	lds	r27, 0x02B3
    3154:	01 96       	adiw	r24, 0x01	; 1
    3156:	a1 1d       	adc	r26, r1
    3158:	b1 1d       	adc	r27, r1
    315a:	80 93 b0 02 	sts	0x02B0, r24
    315e:	90 93 b1 02 	sts	0x02B1, r25
    3162:	a0 93 b2 02 	sts	0x02B2, r26
    3166:	b0 93 b3 02 	sts	0x02B3, r27
    316a:	b7 cf       	rjmp	.-146    	; 0x30da <TM_FindNextTag+0x5e>
	}
	
	DF_ContinuousReadEnable(0, 0);
    316c:	60 e0       	ldi	r22, 0x00	; 0
    316e:	70 e0       	ldi	r23, 0x00	; 0
    3170:	cb 01       	movw	r24, r22
    3172:	0e 94 61 09 	call	0x12c2 <DF_ContinuousReadEnable>
	DFPos = 0;
    3176:	10 92 b0 02 	sts	0x02B0, r1
    317a:	10 92 b1 02 	sts	0x02B1, r1
    317e:	10 92 b2 02 	sts	0x02B2, r1
    3182:	10 92 b3 02 	sts	0x02B3, r1
	
	if (TagExists == FALSE)
    3186:	80 91 29 02 	lds	r24, 0x0229
    318a:	88 23       	and	r24, r24
    318c:	49 f4       	brne	.+18     	; 0x31a0 <TM_FindNextTag+0x124>
	{
		MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);  // Green = ready
    318e:	81 b3       	in	r24, 0x11	; 17
    3190:	8f 7c       	andi	r24, 0xCF	; 207
    3192:	80 61       	ori	r24, 0x10	; 16
    3194:	81 bb       	out	0x11, r24	; 17
		MAIN_ShowError(PSTR("NO TAGS"));
    3196:	8c ee       	ldi	r24, 0xEC	; 236
    3198:	93 e0       	ldi	r25, 0x03	; 3
    319a:	0e 94 55 03 	call	0x6aa <MAIN_ShowError>
    319e:	02 c0       	rjmp	.+4      	; 0x31a4 <TM_FindNextTag+0x128>
	}
	else
	{
		/* The following line _is_ recursion, but the function will only ever call itself
		   a maximum of one time. The function will call itself upon skipping from the last
		   tag stored in the program data to the first; to guard against infinite recursion
		   if no tags are present, the system will error out if the TagExists flag is empty
		   after a full data read. Once a tag has been read and displayed onto the LCD, the
           function returns to the main tag handling routine.                               */
		TM_FindNextTag();
    31a0:	0e 94 3e 18 	call	0x307c <TM_FindNextTag>
    31a4:	69 96       	adiw	r28, 0x19	; 25
    31a6:	0f b6       	in	r0, 0x3f	; 63
    31a8:	f8 94       	cli
    31aa:	de bf       	out	0x3e, r29	; 62
    31ac:	0f be       	out	0x3f, r0	; 63
    31ae:	cd bf       	out	0x3d, r28	; 61
    31b0:	df 91       	pop	r29
    31b2:	cf 91       	pop	r28
    31b4:	1f 91       	pop	r17
    31b6:	0f 91       	pop	r16
    31b8:	ff 90       	pop	r15
    31ba:	ef 90       	pop	r14
    31bc:	df 90       	pop	r13
    31be:	bf 90       	pop	r11
    31c0:	af 90       	pop	r10
    31c2:	08 95       	ret

000031c4 <TM_ShowTags>:
    31c4:	60 e0       	ldi	r22, 0x00	; 0
    31c6:	70 e0       	ldi	r23, 0x00	; 0
    31c8:	cb 01       	movw	r24, r22
    31ca:	0e 94 61 09 	call	0x12c2 <DF_ContinuousReadEnable>
    31ce:	10 92 29 02 	sts	0x0229, r1
    31d2:	10 92 b0 02 	sts	0x02B0, r1
    31d6:	10 92 b1 02 	sts	0x02B1, r1
    31da:	10 92 b2 02 	sts	0x02B2, r1
    31de:	10 92 b3 02 	sts	0x02B3, r1
    31e2:	0e 94 3e 18 	call	0x307c <TM_FindNextTag>
    31e6:	80 91 29 02 	lds	r24, 0x0229
    31ea:	88 23       	and	r24, r24
    31ec:	71 f0       	breq	.+28     	; 0x320a <TM_ShowTags+0x46>
    31ee:	8e b3       	in	r24, 0x1e	; 30
    31f0:	88 23       	and	r24, r24
    31f2:	e9 f3       	breq	.-6      	; 0x31ee <TM_ShowTags+0x2a>
    31f4:	f7 9b       	sbis	0x1e, 7	; 30
    31f6:	03 c0       	rjmp	.+6      	; 0x31fe <TM_ShowTags+0x3a>
    31f8:	0e 94 3e 18 	call	0x307c <TM_FindNextTag>
    31fc:	02 c0       	rjmp	.+4      	; 0x3202 <TM_ShowTags+0x3e>
    31fe:	f2 99       	sbic	0x1e, 2	; 30
    3200:	03 c0       	rjmp	.+6      	; 0x3208 <TM_ShowTags+0x44>
    3202:	0e 94 29 02 	call	0x452 <MAIN_WaitForJoyRelease>
    3206:	f3 cf       	rjmp	.-26     	; 0x31ee <TM_ShowTags+0x2a>
    3208:	80 e0       	ldi	r24, 0x00	; 0
    320a:	0e 94 23 09 	call	0x1246 <DF_EnableDataflash>
    320e:	08 95       	ret

00003210 <__vector_2>:
.global PCINT0_vect             ; Pin change 0 (joystick)
.global PCINT1_vect             ; Pin change 1 (joystick)

PCINT0_vect:
  jmp PCINT1_vect
    3210:	0c 94 7b 03 	jmp	0x6f6 <__vector_3>

00003214 <__vector_10>:

.global TIMER0_COMP_vect             ; Timer 0 compare

TIMER0_COMP_vect:
  push r24
    3214:	8f 93       	push	r24
  ldi r24, (USI_CONTROL_REG_FLAGS | (1<<USITC))
    3216:	8b e5       	ldi	r24, 0x5B	; 91
  sts _SFR_MEM_ADDR(USICR), r24
    3218:	80 93 b8 00 	sts	0x00B8, r24
  pop r24
    321c:	8f 91       	pop	r24
  reti
    321e:	18 95       	reti

00003220 <strcpy_P>:
    3220:	fb 01       	movw	r30, r22
    3222:	dc 01       	movw	r26, r24
    3224:	05 90       	lpm	r0, Z+
    3226:	0d 92       	st	X+, r0
    3228:	00 20       	and	r0, r0
    322a:	e1 f7       	brne	.-8      	; 0x3224 <strcpy_P+0x4>
    322c:	08 95       	ret

0000322e <ultoa>:
    322e:	fa 01       	movw	r30, r20
    3230:	cf 93       	push	r28
    3232:	ff 93       	push	r31
    3234:	ef 93       	push	r30
    3236:	22 30       	cpi	r18, 0x02	; 2
    3238:	cc f0       	brlt	.+50     	; 0x326c <ultoa+0x3e>
    323a:	25 32       	cpi	r18, 0x25	; 37
    323c:	bc f4       	brge	.+46     	; 0x326c <ultoa+0x3e>
    323e:	c2 2f       	mov	r28, r18
    3240:	2c 2f       	mov	r18, r28
    3242:	33 27       	eor	r19, r19
    3244:	44 27       	eor	r20, r20
    3246:	55 27       	eor	r21, r21
    3248:	ff 93       	push	r31
    324a:	ef 93       	push	r30
    324c:	0e 94 93 19 	call	0x3326 <__udivmodsi4>
    3250:	ef 91       	pop	r30
    3252:	ff 91       	pop	r31
    3254:	60 5d       	subi	r22, 0xD0	; 208
    3256:	6a 33       	cpi	r22, 0x3A	; 58
    3258:	0c f0       	brlt	.+2      	; 0x325c <ultoa+0x2e>
    325a:	69 5d       	subi	r22, 0xD9	; 217
    325c:	61 93       	st	Z+, r22
    325e:	b9 01       	movw	r22, r18
    3260:	ca 01       	movw	r24, r20
    3262:	60 50       	subi	r22, 0x00	; 0
    3264:	70 40       	sbci	r23, 0x00	; 0
    3266:	80 40       	sbci	r24, 0x00	; 0
    3268:	90 40       	sbci	r25, 0x00	; 0
    326a:	51 f7       	brne	.-44     	; 0x3240 <ultoa+0x12>
    326c:	10 82       	st	Z, r1
    326e:	8f 91       	pop	r24
    3270:	9f 91       	pop	r25
    3272:	cf 91       	pop	r28
    3274:	0c 94 3c 19 	jmp	0x3278 <strrev>

00003278 <strrev>:
    3278:	dc 01       	movw	r26, r24
    327a:	fc 01       	movw	r30, r24
    327c:	01 90       	ld	r0, Z+
    327e:	00 20       	and	r0, r0
    3280:	e9 f7       	brne	.-6      	; 0x327c <strrev+0x4>
    3282:	32 97       	sbiw	r30, 0x02	; 2
    3284:	ae 17       	cp	r26, r30
    3286:	bf 07       	cpc	r27, r31
    3288:	30 f4       	brcc	.+12     	; 0x3296 <strrev+0x1e>
    328a:	7c 91       	ld	r23, X
    328c:	60 81       	ld	r22, Z
    328e:	70 83       	st	Z, r23
    3290:	31 97       	sbiw	r30, 0x01	; 1
    3292:	6d 93       	st	X+, r22
    3294:	f7 cf       	rjmp	.-18     	; 0x3284 <strrev+0xc>
    3296:	08 95       	ret

00003298 <__mulsi3>:
    3298:	62 9f       	mul	r22, r18
    329a:	d0 01       	movw	r26, r0
    329c:	73 9f       	mul	r23, r19
    329e:	f0 01       	movw	r30, r0
    32a0:	82 9f       	mul	r24, r18
    32a2:	e0 0d       	add	r30, r0
    32a4:	f1 1d       	adc	r31, r1
    32a6:	64 9f       	mul	r22, r20
    32a8:	e0 0d       	add	r30, r0
    32aa:	f1 1d       	adc	r31, r1
    32ac:	92 9f       	mul	r25, r18
    32ae:	f0 0d       	add	r31, r0
    32b0:	83 9f       	mul	r24, r19
    32b2:	f0 0d       	add	r31, r0
    32b4:	74 9f       	mul	r23, r20
    32b6:	f0 0d       	add	r31, r0
    32b8:	65 9f       	mul	r22, r21
    32ba:	f0 0d       	add	r31, r0
    32bc:	99 27       	eor	r25, r25
    32be:	72 9f       	mul	r23, r18
    32c0:	b0 0d       	add	r27, r0
    32c2:	e1 1d       	adc	r30, r1
    32c4:	f9 1f       	adc	r31, r25
    32c6:	63 9f       	mul	r22, r19
    32c8:	b0 0d       	add	r27, r0
    32ca:	e1 1d       	adc	r30, r1
    32cc:	f9 1f       	adc	r31, r25
    32ce:	bd 01       	movw	r22, r26
    32d0:	cf 01       	movw	r24, r30
    32d2:	11 24       	eor	r1, r1
    32d4:	08 95       	ret

000032d6 <__eeprom_read_byte_1F2021>:
    32d6:	f9 99       	sbic	0x1f, 1	; 31
    32d8:	fe cf       	rjmp	.-4      	; 0x32d6 <__eeprom_read_byte_1F2021>
    32da:	b2 bd       	out	0x22, r27	; 34
    32dc:	a1 bd       	out	0x21, r26	; 33
    32de:	f8 9a       	sbi	0x1f, 0	; 31
    32e0:	11 96       	adiw	r26, 0x01	; 1
    32e2:	00 b4       	in	r0, 0x20	; 32
    32e4:	08 95       	ret

000032e6 <__eeprom_read_block_1F2021>:
    32e6:	f7 df       	rcall	.-18     	; 0x32d6 <__eeprom_read_byte_1F2021>
    32e8:	01 92       	st	Z+, r0
    32ea:	1a 94       	dec	r1
    32ec:	e1 f7       	brne	.-8      	; 0x32e6 <__eeprom_read_block_1F2021>
    32ee:	08 95       	ret

000032f0 <__eeprom_read_word_1F2021>:
    32f0:	f2 df       	rcall	.-28     	; 0x32d6 <__eeprom_read_byte_1F2021>
    32f2:	e0 2d       	mov	r30, r0
    32f4:	f0 df       	rcall	.-32     	; 0x32d6 <__eeprom_read_byte_1F2021>
    32f6:	f0 2d       	mov	r31, r0
    32f8:	08 95       	ret

000032fa <__eeprom_write_byte_1F2021>:
    32fa:	f9 99       	sbic	0x1f, 1	; 31
    32fc:	fe cf       	rjmp	.-4      	; 0x32fa <__eeprom_write_byte_1F2021>
    32fe:	b2 bd       	out	0x22, r27	; 34
    3300:	a1 bd       	out	0x21, r26	; 33
    3302:	00 bc       	out	0x20, r0	; 32
    3304:	11 96       	adiw	r26, 0x01	; 1
    3306:	0f b6       	in	r0, 0x3f	; 63
    3308:	f8 94       	cli
    330a:	fa 9a       	sbi	0x1f, 2	; 31
    330c:	f9 9a       	sbi	0x1f, 1	; 31
    330e:	0f be       	out	0x3f, r0	; 63
    3310:	08 95       	ret

00003312 <__eeprom_write_word_1F2021>:
    3312:	f3 df       	rcall	.-26     	; 0x32fa <__eeprom_write_byte_1F2021>
    3314:	01 2c       	mov	r0, r1
    3316:	f1 df       	rcall	.-30     	; 0x32fa <__eeprom_write_byte_1F2021>
    3318:	11 24       	eor	r1, r1
    331a:	08 95       	ret

0000331c <__eeprom_write_block_1F2021>:
    331c:	01 90       	ld	r0, Z+
    331e:	ed df       	rcall	.-38     	; 0x32fa <__eeprom_write_byte_1F2021>
    3320:	1a 94       	dec	r1
    3322:	e1 f7       	brne	.-8      	; 0x331c <__eeprom_write_block_1F2021>
    3324:	08 95       	ret

00003326 <__udivmodsi4>:
    3326:	a1 e2       	ldi	r26, 0x21	; 33
    3328:	1a 2e       	mov	r1, r26
    332a:	aa 1b       	sub	r26, r26
    332c:	bb 1b       	sub	r27, r27
    332e:	fd 01       	movw	r30, r26
    3330:	0d c0       	rjmp	.+26     	; 0x334c <__udivmodsi4_ep>

00003332 <__udivmodsi4_loop>:
    3332:	aa 1f       	adc	r26, r26
    3334:	bb 1f       	adc	r27, r27
    3336:	ee 1f       	adc	r30, r30
    3338:	ff 1f       	adc	r31, r31
    333a:	a2 17       	cp	r26, r18
    333c:	b3 07       	cpc	r27, r19
    333e:	e4 07       	cpc	r30, r20
    3340:	f5 07       	cpc	r31, r21
    3342:	20 f0       	brcs	.+8      	; 0x334c <__udivmodsi4_ep>
    3344:	a2 1b       	sub	r26, r18
    3346:	b3 0b       	sbc	r27, r19
    3348:	e4 0b       	sbc	r30, r20
    334a:	f5 0b       	sbc	r31, r21

0000334c <__udivmodsi4_ep>:
    334c:	66 1f       	adc	r22, r22
    334e:	77 1f       	adc	r23, r23
    3350:	88 1f       	adc	r24, r24
    3352:	99 1f       	adc	r25, r25
    3354:	1a 94       	dec	r1
    3356:	69 f7       	brne	.-38     	; 0x3332 <__udivmodsi4_loop>
    3358:	60 95       	com	r22
    335a:	70 95       	com	r23
    335c:	80 95       	com	r24
    335e:	90 95       	com	r25
    3360:	9b 01       	movw	r18, r22
    3362:	ac 01       	movw	r20, r24
    3364:	bd 01       	movw	r22, r26
    3366:	cf 01       	movw	r24, r30
    3368:	08 95       	ret
