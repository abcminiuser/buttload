
ButtLoad.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  000035b0  00003664  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000035b0  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b2  00800104  00800104  00003668  2**0
                  ALLOC
  3 .eeprom       0000008e  00810000  00810000  00003668  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00000084  00000000  00000000  000036f8  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00000078  00000000  00000000  0000377c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 0000012c  00000000  00000000  000037f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 00000d5a  00000000  00000000  00003920  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   000044c4  00000000  00000000  0000467a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00001290  00000000  00000000  00008b3e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0000335b  00000000  00000000  00009dce  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000004f8  00000000  00000000  0000d129  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000011a2  00000000  00000000  0000d621  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000116e  00000000  00000000  0000e7c3  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000060  00000000  00000000  0000f931  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 33 02 	jmp	0x466	; 0x466 <__ctors_end>
       4:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
       8:	0c 94 49 1a 	jmp	0x3492	; 0x3492 <__vector_2>
       c:	0c 94 b6 02 	jmp	0x56c	; 0x56c <__vector_3>
      10:	0c 94 bb 0c 	jmp	0x1976	; 0x1976 <__vector_4>
      14:	0c 94 40 08 	jmp	0x1080	; 0x1080 <__vector_5>
      18:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      1c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      20:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      24:	0c 94 81 0c 	jmp	0x1902	; 0x1902 <__vector_9>
      28:	0c 94 4b 1a 	jmp	0x3496	; 0x3496 <__vector_10>
      2c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      30:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      34:	0c 94 ff 0b 	jmp	0x17fe	; 0x17fe <__vector_13>
      38:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      3c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      40:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      44:	0c 94 c5 09 	jmp	0x138a	; 0x138a <__vector_17>
      48:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      4c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      50:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      54:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      58:	0c 94 e3 08 	jmp	0x11c6	; 0x11c6 <__vector_22>

0000005c <BUTTTAG_Title>:
      5c:	40 28 23 29 42 55 54 54 4c 4f 41 44 20 41 56 52     @(#)BUTTLOAD AVR
      6c:	49 53 50 00                                         ISP.

00000070 <BUTTTAG_Version>:
      70:	40 28 23 29 56 31 2d 34 00                          @(#)V1-4.

00000079 <BUTTTAG_Author>:
      79:	40 28 23 29 42 59 20 44 45 41 4e 20 43 41 4d 45     @(#)BY DEAN CAME
      89:	52 41 00                                            RA.

0000008c <BUTTTAG_Copyright>:
      8c:	40 28 23 29 3c 43 3e 20 32 30 30 36 20 2d 20 47     @(#)<C> 2006 - G
      9c:	50 4c 00                                            PL.

0000009f <AboutTextPtrs>:
      9f:	60 00 74 00 7d 00 90 00                             `.t.}...

000000a7 <WaitText>:
      a7:	2a 57 41 49 54 2a 00                                *WAIT*.

000000ae <Func_ISPPRGM>:
      ae:	41 56 52 49 53 50 20 4d 4f 44 45 00                 AVRISP MODE.

000000ba <Func_STOREPRGM>:
      ba:	53 54 4f 52 45 20 50 52 47 4d 00                    STORE PRGM.

000000c5 <Func_PRGMAVR>:
      c5:	50 52 4f 47 52 41 4d 20 41 56 52 00                 PROGRAM AVR.

000000d1 <Func_PRGMDATAFLASH>:
      d1:	44 41 54 41 46 4c 41 53 48 20 50 52 47 4d 00        DATAFLASH PRGM.

000000e0 <Func_PRGMSTOREINFO>:
      e0:	44 41 54 41 53 54 4f 52 45 20 49 4e 46 4f 00        DATASTORE INFO.

000000ef <Func_SETTINGS>:
      ef:	53 45 54 54 49 4e 47 53 00                          SETTINGS.

000000f8 <Func_SLEEP>:
      f8:	53 4c 45 45 50 20 4d 4f 44 45 00                    SLEEP MODE.

00000103 <MainFunctionNames>:
     103:	ae 00 ba 00 c5 00 d1 00 e0 00 ef 00 f8 00           ..............

00000111 <MainFunctionPtrs>:
     111:	8a 04 5c 04 ef 04 9f 04 e4 03 27 03 d5 02           ..\.......'...

0000011f <SFunc_SETCONTRAST>:
     11f:	53 45 54 20 43 4f 4e 54 52 41 53 54 00              SET CONTRAST.

0000012c <SFunc_SETSPISPEED>:
     12c:	53 45 54 20 49 53 50 20 53 50 45 45 44 00           SET ISP SPEED.

0000013a <SFunc_SETRESETMODE>:
     13a:	53 45 54 20 52 45 53 45 54 20 4d 4f 44 45 00        SET RESET MODE.

00000149 <SFunc_SETFIRMMINOR>:
     149:	53 45 54 20 46 49 52 4d 20 56 45 52 53 49 4f 4e     SET FIRM VERSION
	...

0000015a <SFunc_SETAUTOSLEEPTO>:
     15a:	53 45 54 20 53 4c 45 45 50 20 54 49 4d 45 4f 55     SET SLEEP TIMEOU
     16a:	54 00                                               T.

0000016c <SFunc_CLEARMEM>:
     16c:	43 4c 45 41 52 20 4d 45 4d 4f 52 59 00              CLEAR MEMORY.

00000179 <SFunc_GOBOOTLOADER>:
     179:	4a 55 4d 50 20 54 4f 20 42 4f 4f 54 4c 4f 41 44     JUMP TO BOOTLOAD
     189:	45 52 00                                            ER.

0000018c <SettingFunctionNames>:
     18c:	1f 01 2c 01 3a 01 49 01 5a 01 6c 01 79 01           ..,.:.I.Z.l.y.

0000019a <SettingFunctionPtrs>:
     19a:	f5 06 41 07 74 07 9c 07 5c 03 c2 06 ef 02           ..A.t...\.....

000001a8 <PRG_A>:
     1a8:	50 52 47 4d 20 41 4c 4c 00                          PRGM ALL.

000001b1 <PRG_D>:
     1b1:	44 41 54 41 20 4f 4e 4c 59 00                       DATA ONLY.

000001bb <PRG_E>:
     1bb:	45 45 50 52 4f 4d 20 4f 4e 4c 59 00                 EEPROM ONLY.

000001c7 <PRG_DE>:
     1c7:	44 41 54 41 20 41 4e 44 20 45 45 50 52 4f 4d 00     DATA AND EEPROM.

000001d7 <PRG_F>:
     1d7:	46 55 53 45 20 42 59 54 45 53 20 4f 4e 4c 59 00     FUSE BYTES ONLY.

000001e7 <PRG_L>:
     1e7:	4c 4f 43 4b 20 42 59 54 45 53 20 4f 4e 4c 59 00     LOCK BYTES ONLY.

000001f7 <PRG_FL>:
     1f7:	46 55 53 45 20 41 4e 44 20 4c 4f 43 4b 20 42 59     FUSE AND LOCK BY
     207:	54 45 53 00                                         TES.

0000020b <PRG_C>:
     20b:	45 52 41 53 45 20 4f 4e 4c 59 00                    ERASE ONLY.

00000216 <ProgOptions>:
     216:	a8 01 b1 01 bb 01 c7 01 d7 01 e7 01 f7 01 0b 02     ................

00000226 <USISpeeds>:
     226:	20 35 37 31 35 33 20 48 5a 00 20 38 36 37 33 38      57153 HZ. 86738
     236:	20 48 5a 00 31 31 33 34 32 37 20 48 5a 00 32 31      HZ.113427 HZ.21
     246:	30 36 35 31 20 48 5a 00                             0651 HZ.

0000024e <SPIResetModes>:
     24e:	4c 4f 47 49 43 00 46 4c 4f 41 54 00                 LOGIC.FLOAT.

0000025a <SIFONames>:
     25a:	53 54 4f 52 41 47 45 20 53 49 5a 45 53 00 00 56     STORAGE SIZES..V
     26a:	49 45 57 20 44 41 54 41 20 54 41 47 53 00           IEW DATA TAGS.

00000278 <__c.2512>:
     278:	2a 4a 54 41 47 20 4f 4e 2a 00                       *JTAG ON*.

00000282 <__c.2481>:
     282:	4e 4f 20 53 54 4f 52 45 44 20 50 52 47 4d 00        NO STORED PRGM.

00000291 <__c.2427>:
     291:	4f 46 46 00                                         OFF.

00000295 <__c.2425>:
     295:	20 20 20 20 53 45 43 00                                 SEC.

0000029d <__c.2404>:
     29d:	56 32 2d 20 00                                      V2- .

000002a2 <__c.2306>:
     2a2:	4d 45 4d 20 43 4c 45 41 52 45 44 00                 MEM CLEARED.

000002ae <__c.2298>:
     2ae:	3c 4e 20 59 3e 00                                   <N Y>.

000002b4 <__c.2296>:
     2b4:	43 4f 4e 46 49 52 4d 00                             CONFIRM.

000002bc <__c.2279>:
     2bc:	2a 53 54 4f 52 41 47 45 20 4d 4f 44 45 2a 00        *STORAGE MODE*.

000002cb <__c.2212>:
     2cb:	46 41 49 4c 45 44 00                                FAILED.

000002d2 <__c.2210>:
     2d2:	50 52 4f 47 52 41 4d 4d 49 4e 47 20 44 4f 4e 45     PROGRAMMING DONE
	...

000002e3 <__c.2208>:
     2e3:	4e 4f 20 4c 4f 43 4b 20 42 59 54 45 53 00           NO LOCK BYTES.

000002f1 <__c.2206>:
     2f1:	4e 4f 20 46 55 53 45 20 42 59 54 45 53 00           NO FUSE BYTES.

000002ff <__c.2204>:
     2ff:	4e 4f 20 45 45 50 52 4f 4d 00                       NO EEPROM.

00000309 <__c.2202>:
     309:	4e 4f 20 44 41 54 41 00                             NO DATA.

00000311 <__c.2200>:
     311:	4e 4f 20 45 52 41 53 45 20 43 4d 44 00              NO ERASE CMD.

0000031e <__c.2097>:
     31e:	42 41 44 49 53 52 00                                BADISR.

00000325 <__c.2034>:
     325:	50 52 47 3e 20 20 00                                PRG>  .

0000032c <LCD_SegTable>:
     32c:	a8 ea 80 2a 00 40 00 0a 51 0a 08 40 59 55 18 01     ...*.@..Q..@YU..
     33c:	11 1e 11 1b 50 0b 41 1b 41 1f 11 01 51 1f 51 1b     ....P.A.A...Q.Q.
     34c:	00 00 00 00 08 80 00 1a 20 40 00 00 00 00 51 0f     ........ @....Q.
     35c:	91 39 41 14 91 31 41 1e 41 0e 41 1d 50 0f 80 20     .9A..1A.A.A.P.. 
     36c:	10 15 48 86 40 14 78 05 70 85 51 15 51 0e 51 95     ..H.@.x.p.Q.Q.Q.
     37c:	51 8e 21 90 81 20 50 15 48 44 50 c5 28 c0 28 20     Q.!.. P.HDP.(.( 
     38c:	09 50 41 14 20 80 11 11 00 00 00 10                 .PA. .......

00000398 <USIPSValues>:
     398:	03 80 02 54 01 40 00 22                             ...T.@."

000003a0 <DF_PageBits>:
     3a0:	09 09 09 09 09 0a 0a 0b                             ........

000003a8 <DF_PageSize>:
     3a8:	08 01 08 01 08 01 08 01 08 01 10 02 10 02 20 04     .............. .

000003b8 <DF_Pages>:
     3b8:	00 01 00 02 00 04 00 08 00 10 00 10 00 20 00 20     ............. . 

000003c8 <DataFlashError>:
     3c8:	44 41 54 41 46 4c 41 53 48 20 45 52 52 4f 52 00     DATAFLASH ERROR.

000003d8 <__c.1865>:
     3d8:	42 55 46 46 20 4f 56 46 00                          BUFF OVF.

000003e1 <AutoSleepTOValues>:
     3e1:	00 0f 1e 3c 78                                      ...<x

000003e6 <__c.1868>:
     3e6:	46 52 41 4d 45 20 45 52 52 00                       FRAME ERR.

000003f0 <__c.1866>:
     3f0:	44 41 54 41 20 4f 56 52 00                          DATA OVR.

000003f9 <DataFlashProgMode>:
     3f9:	2a 44 41 54 41 46 4c 41 53 48 20 4d 4f 44 45 2a     *DATAFLASH MODE*
	...

0000040a <SignonResponse>:
     40a:	01 00 08 41 56 52 49 53 50 5f 32 00                 ...AVRISP_2.

00000416 <ButtLoadData>:
     416:	40 28 23 29 2a 53 43 52 45 57 20 52 45 54 52 4f     @(#)*SCREW RETRO
     426:	44 41 4e 00 2a                                      DAN.*

0000042b <SyncErrorMessage>:
     42b:	53 59 4e 43 20 45 52 52 4f 52 00                    SYNC ERROR.

00000436 <AVRISPModeMessage>:
     436:	2a 41 54 41 56 52 49 53 50 20 4d 4f 44 45 2a 00     *ATAVRISP MODE*.

00000446 <__c.2143>:
     446:	4c 4f 43 4b 2d 00                                   LOCK-.

0000044c <__c.2140>:
     44c:	46 55 53 45 2d 00                                   FUSE-.

00000452 <__c.2137>:
     452:	45 50 52 4d 2d 00                                   EPRM-.

00000458 <__c.2133>:
     458:	44 41 54 41 2d 00                                   DATA-.

0000045e <__c.1887>:
     45e:	4e 4f 20 54 41 47 53 00                             NO TAGS.

00000466 <__ctors_end>:
     466:	11 24       	eor	r1, r1
     468:	1f be       	out	0x3f, r1	; 63
     46a:	cf ef       	ldi	r28, 0xFF	; 255
     46c:	d4 e0       	ldi	r29, 0x04	; 4
     46e:	de bf       	out	0x3e, r29	; 62
     470:	cd bf       	out	0x3d, r28	; 61

00000472 <__do_copy_data>:
     472:	11 e0       	ldi	r17, 0x01	; 1
     474:	a0 e0       	ldi	r26, 0x00	; 0
     476:	b1 e0       	ldi	r27, 0x01	; 1
     478:	e0 eb       	ldi	r30, 0xB0	; 176
     47a:	f5 e3       	ldi	r31, 0x35	; 53
     47c:	02 c0       	rjmp	.+4      	; 0x482 <.do_copy_data_start>

0000047e <.do_copy_data_loop>:
     47e:	05 90       	lpm	r0, Z+
     480:	0d 92       	st	X+, r0

00000482 <.do_copy_data_start>:
     482:	a4 30       	cpi	r26, 0x04	; 4
     484:	b1 07       	cpc	r27, r17
     486:	d9 f7       	brne	.-10     	; 0x47e <.do_copy_data_loop>

00000488 <__do_clear_bss>:
     488:	12 e0       	ldi	r17, 0x02	; 2
     48a:	a4 e0       	ldi	r26, 0x04	; 4
     48c:	b1 e0       	ldi	r27, 0x01	; 1
     48e:	01 c0       	rjmp	.+2      	; 0x492 <.do_clear_bss_start>

00000490 <.do_clear_bss_loop>:
     490:	1d 92       	st	X+, r1

00000492 <.do_clear_bss_start>:
     492:	a6 3b       	cpi	r26, 0xB6	; 182
     494:	b1 07       	cpc	r27, r17
     496:	e1 f7       	brne	.-8      	; 0x490 <.do_clear_bss_loop>
     498:	0e 94 32 06 	call	0xc64	; 0xc64 <main>
     49c:	0c 94 d7 1a 	jmp	0x35ae	; 0x35ae <_exit>

000004a0 <__bad_interrupt>:
     4a0:	0c 94 eb 04 	jmp	0x9d6	; 0x9d6 <__vector_default>

000004a4 <MAIN_Delay10MS>:

// ======================================================================================

void MAIN_Delay10MS(uint8_t loops)
{
     4a4:	28 2f       	mov	r18, r24
     4a6:	e0 e0       	ldi	r30, 0x00	; 0
     4a8:	f8 e4       	ldi	r31, 0x48	; 72
     4aa:	03 c0       	rjmp	.+6      	; 0x4b2 <MAIN_Delay10MS+0xe>
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     4ac:	cf 01       	movw	r24, r30
     4ae:	01 97       	sbiw	r24, 0x01	; 1
     4b0:	f1 f7       	brne	.-4      	; 0x4ae <MAIN_Delay10MS+0xa>
  /* Prevents the use of floating point libraries. Delaying in groups of
     10ms increases accuracy by reducing the time overhead for each loop
     interation of the while.                                            */

	while (loops--)
     4b2:	21 50       	subi	r18, 0x01	; 1
     4b4:	d8 f7       	brcc	.-10     	; 0x4ac <MAIN_Delay10MS+0x8>
     4b6:	08 95       	ret

000004b8 <MAIN_Delay1MS>:
	  _delay_ms(10);
}

void MAIN_Delay1MS(uint8_t loops)
{
     4b8:	28 2f       	mov	r18, r24
     4ba:	e3 e3       	ldi	r30, 0x33	; 51
     4bc:	f7 e0       	ldi	r31, 0x07	; 7
     4be:	03 c0       	rjmp	.+6      	; 0x4c6 <MAIN_Delay1MS+0xe>
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     4c0:	cf 01       	movw	r24, r30
     4c2:	01 97       	sbiw	r24, 0x01	; 1
     4c4:	f1 f7       	brne	.-4      	; 0x4c2 <MAIN_Delay1MS+0xa>
  /* Prevents the use of floating point libraries. Less accurate than the
     Delay10MS routine, but nessesary for many commands. The overhead required
     to call the routine is substantially less than the overhead required to
     calculate the float at compile time, so this actually saves execution time. */

	while (loops--)
     4c6:	21 50       	subi	r18, 0x01	; 1
     4c8:	d8 f7       	brcc	.-10     	; 0x4c0 <MAIN_Delay1MS+0x8>
     4ca:	08 95       	ret

000004cc <MAIN_ResetCSLine>:
	  _delay_ms(1);
}

void MAIN_ResetCSLine(const uint8_t ActiveInactive)
{
     4cc:	81 30       	cpi	r24, 0x01	; 1
     4ce:	81 f0       	breq	.+32     	; 0x4f0 <MAIN_ResetCSLine+0x24>
	/* ActiveInactive controls the /Reset line to an AVR device or external dataflash
	/CS line. If the reset polarity parameter is a 0 then interfacing with AT89
	devices which has an active high reset. Pins are tristated when inactive.         */
	
	switch (ActiveInactive)
     4d0:	81 30       	cpi	r24, 0x01	; 1
     4d2:	18 f0       	brcs	.+6      	; 0x4da <MAIN_ResetCSLine+0xe>
     4d4:	82 30       	cpi	r24, 0x02	; 2
     4d6:	01 f5       	brne	.+64     	; 0x518 <__stack+0x19>
     4d8:	09 c0       	rjmp	.+18     	; 0x4ec <MAIN_ResetCSLine+0x20>
	{
		case MAIN_RESETCS_ACTIVE:                // The target RESET line may be either active high or low.
			DDRF |= (1 << 6);
     4da:	86 9a       	sbi	0x10, 6	; 16
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     4dc:	a1 e0       	ldi	r26, 0x01	; 1
     4de:	b0 e0       	ldi	r27, 0x00	; 0
     4e0:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
     4e4:	80 2d       	mov	r24, r0
		
			if (eeprom_read_byte(&EEPROMVars.ResetPolarity)) // Translate to correct active logic level for target device type
     4e6:	88 23       	and	r24, r24
     4e8:	59 f4       	brne	.+22     	; 0x500 <__stack+0x1>
     4ea:	13 c0       	rjmp	.+38     	; 0x512 <__stack+0x13>
			  PORTF &= ~(1 << 6);
			else
			  PORTF |= (1 << 6);
		
			break;
		case MAIN_RESETCS_EXTDFACTIVE:           // Dataflashes are always active low.
			DDRF  |=  (1 << 6);
     4ec:	86 9a       	sbi	0x10, 6	; 16
     4ee:	08 c0       	rjmp	.+16     	; 0x500 <__stack+0x1>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     4f0:	ac e8       	ldi	r26, 0x8C	; 140
     4f2:	b0 e0       	ldi	r27, 0x00	; 0
     4f4:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
     4f8:	80 2d       	mov	r24, r0
			PORTF &= ~(1 << 6);
			
			break;
		case MAIN_RESETCS_INACTIVE:              // Must determine what to do for inactive RESET.
			if (eeprom_read_byte(&EEPROMVars.SPIResetMode)) // FLOAT mode reset
     4fa:	88 23       	and	r24, r24
     4fc:	19 f0       	breq	.+6      	; 0x504 <__stack+0x5>
			{
				DDRF  &= ~(1 << 6);
     4fe:	86 98       	cbi	0x10, 6	; 16
				PORTF &= ~(1 << 6);
     500:	8e 98       	cbi	0x11, 6	; 17
     502:	08 95       	ret
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     504:	a1 e0       	ldi	r26, 0x01	; 1
     506:	b0 e0       	ldi	r27, 0x00	; 0
     508:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
     50c:	80 2d       	mov	r24, r0
			}
			else                                 // ACTIVE mode reset
			{
				if (eeprom_read_byte(&EEPROMVars.ResetPolarity)) // Translate to correct inactive logic level for target device type
     50e:	88 23       	and	r24, r24
     510:	11 f0       	breq	.+4      	; 0x516 <__stack+0x17>
				  PORTF |= (1 << 6);
     512:	8e 9a       	sbi	0x11, 6	; 17
     514:	08 95       	ret
				else
				  PORTF &= ~(1 << 6);			
     516:	8e 98       	cbi	0x11, 6	; 17
     518:	08 95       	ret

0000051a <MAIN_WaitForJoyRelease>:
			}
	}
}

void MAIN_WaitForJoyRelease(void)
{
     51a:	8e b3       	in	r24, 0x1e	; 30
     51c:	88 23       	and	r24, r24
     51e:	e9 f7       	brne	.-6      	; 0x51a <MAIN_WaitForJoyRelease>
	for (;;)
	{
		while (JoyStatus) {};                    // Wait until joystick released

		MAIN_Delay10MS(2);
     520:	82 e0       	ldi	r24, 0x02	; 2
     522:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>

		if (!(JoyStatus))                        // Joystick still released (not bouncing), return
     526:	8e b3       	in	r24, 0x1e	; 30
     528:	88 23       	and	r24, r24
     52a:	b9 f7       	brne	.-18     	; 0x51a <MAIN_WaitForJoyRelease>
     52c:	08 95       	ret

0000052e <MAIN_IntToStr>:
		  return;
	}
}

void MAIN_IntToStr(uint16_t IntV, uint8_t* Buff)
{
     52e:	cf 93       	push	r28
     530:	df 93       	push	r29
     532:	fb 01       	movw	r30, r22
     534:	20 e0       	ldi	r18, 0x00	; 0
     536:	03 c0       	rjmp	.+6      	; 0x53e <MAIN_IntToStr+0x10>
	// Shows leading zeros, unlike itoa.

	uint8_t Temp = 0;
	
	while (IntV >= 100)
	{
		Temp++;
     538:	2f 5f       	subi	r18, 0xFF	; 255
		IntV -= 100;
     53a:	84 56       	subi	r24, 0x64	; 100
     53c:	90 40       	sbci	r25, 0x00	; 0
     53e:	84 36       	cpi	r24, 0x64	; 100
     540:	91 05       	cpc	r25, r1
     542:	d0 f7       	brcc	.-12     	; 0x538 <MAIN_IntToStr+0xa>
	}

	*(Buff++) = '0' + Temp;
     544:	20 5d       	subi	r18, 0xD0	; 208
     546:	21 93       	st	Z+, r18
     548:	df 01       	movw	r26, r30
     54a:	20 e0       	ldi	r18, 0x00	; 0
     54c:	02 c0       	rjmp	.+4      	; 0x552 <MAIN_IntToStr+0x24>
	
	Temp = 0;
	
	while (IntV >= 10)
	{
		Temp++;
     54e:	2f 5f       	subi	r18, 0xFF	; 255
		IntV -= 10;
     550:	0a 97       	sbiw	r24, 0x0a	; 10
     552:	8a 30       	cpi	r24, 0x0A	; 10
     554:	91 05       	cpc	r25, r1
     556:	d8 f7       	brcc	.-10     	; 0x54e <MAIN_IntToStr+0x20>
	}
		
	*(Buff++) = '0' + Temp;
     558:	20 5d       	subi	r18, 0xD0	; 208
     55a:	fd 01       	movw	r30, r26
     55c:	21 93       	st	Z+, r18
	*(Buff++) = '0' + IntV;
     55e:	80 5d       	subi	r24, 0xD0	; 208
     560:	ed 01       	movw	r28, r26
     562:	89 83       	std	Y+1, r24	; 0x01
	*(Buff)   = '\0';
     564:	11 82       	std	Z+1, r1	; 0x01
     566:	df 91       	pop	r29
     568:	cf 91       	pop	r28
     56a:	08 95       	ret

0000056c <__vector_3>:
}

void MAIN_ShowProgType(const uint8_t Letter)
{
	uint8_t ProgTypeBuffer[7];

	strcpy_P(ProgTypeBuffer, PSTR("PRG>  "));
	ProgTypeBuffer[5] = Letter;
	
	LCD_puts(ProgTypeBuffer);
}

void MAIN_ShowError(const uint8_t *pFlashStr)
{
	uint8_t ErrorBuff[LCD_TEXTBUFFER_SIZE];      // New buffer, LCD text buffer size
	
	ErrorBuff[0] = 'E';
	ErrorBuff[1] = '>';

	strcpy_P(&ErrorBuff[2], pFlashStr);          // WARNING: If flash error text is larger than (TEXTBUFFER_SIZE - 1),
	                                             // this will overflow the buffer and crash the program!
	LCD_puts(ErrorBuff);
	
	MAIN_WaitForJoyRelease();
	while (!(JoyStatus & JOY_PRESS)) {};
	MAIN_WaitForJoyRelease();
}

void MAIN_CrashProgram(uint8_t *ErrTxtPtr)
{
	SPI_SPIOFF();
	USI_SPIOff();
	TIMEOUT_PACKET_TIMER_OFF();
	TIMEOUT_SLEEP_TIMER_OFF();
	USART_ENABLE(USART_TX_OFF, USART_RX_OFF);

	LCD_puts(ErrTxtPtr);	
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);	

	for (;;)
	{
		MAIN_Delay10MS(50);
		PORTF ^= MAIN_STATLED_RED;               // Loop forever, blinking the status LED from orange to red and back
	}
}

// ======================================================================================

ISR(PCINT1_vect, ISR_NOBLOCK)                    // Joystick routine; PCINT0_vect is bound to this also via JoystickInterrupt.S
{
     56c:	78 94       	sei
     56e:	1f 92       	push	r1
     570:	0f 92       	push	r0
     572:	0f b6       	in	r0, 0x3f	; 63
     574:	0f 92       	push	r0
     576:	11 24       	eor	r1, r1
     578:	8f 93       	push	r24
     57a:	9f 93       	push	r25
	JoyStatus = (~PINB & JOY_BMASK)
     57c:	83 b1       	in	r24, 0x03	; 3
     57e:	9c b1       	in	r25, 0x0c	; 12
     580:	80 95       	com	r24
     582:	80 7d       	andi	r24, 0xD0	; 208
     584:	90 95       	com	r25
     586:	9c 70       	andi	r25, 0x0C	; 12
     588:	89 2b       	or	r24, r25
     58a:	8e bb       	out	0x1e, r24	; 30
	          | (~PINE & JOY_EMASK);
			  
	TIMEOUT_SLEEP_TIMEOUT_RESET();
     58c:	10 92 8e 01 	sts	0x018E, r1
     590:	10 92 8d 01 	sts	0x018D, r1
     594:	10 92 85 00 	sts	0x0085, r1
     598:	10 92 84 00 	sts	0x0084, r1
     59c:	9f 91       	pop	r25
     59e:	8f 91       	pop	r24
     5a0:	0f 90       	pop	r0
     5a2:	0f be       	out	0x3f, r0	; 63
     5a4:	0f 90       	pop	r0
     5a6:	1f 90       	pop	r1
     5a8:	18 95       	reti

000005aa <FUNCSleepMode>:
}

ISR(BADISR_vect, ISR_NAKED)                      // Bad ISR routine; should never be called, here for safety
{
	MAIN_CrashProgram(PSTR("BADISR"));
}

// ======================================================================================

void FUNCChangeSettings(void)
{
	uint8_t CurrSFunc = 0;
	
	JoyStatus = 1;

	for (;;)
	{
		if (JoyStatus)                           // Joystick is in the non-center position
		{
			if (JoyStatus & JOY_UP)              // Previous function
			  (CurrSFunc == 0)? CurrSFunc = ARRAY_UPPERBOUND(SettingFunctionPtrs) : CurrSFunc--;
			else if (JoyStatus & JOY_DOWN)       // Next function
			  (CurrSFunc == ARRAY_UPPERBOUND(SettingFunctionPtrs))? CurrSFunc = 0 : CurrSFunc++;
			else if (JoyStatus & JOY_PRESS)      // Select current function
			  ((FuncPtr)pgm_read_word(&SettingFunctionPtrs[CurrSFunc]))(); // Run associated function
			else if (JoyStatus & JOY_LEFT)
			  return;
		
			// Show current function onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&SettingFunctionNames[CurrSFunc]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCShowAbout(void)
{
	uint8_t InfoNum = 0;
	
	JoyStatus = 1;
			
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			  (InfoNum == 0)? InfoNum = ARRAY_UPPERBOUND(AboutTextPtrs) : InfoNum--;
			else if (JoyStatus & JOY_DOWN)
			  (InfoNum == ARRAY_UPPERBOUND(AboutTextPtrs))? InfoNum = 0 : InfoNum++;
			else if (JoyStatus & JOY_LEFT)
			  return;

			LCD_puts_f((uint8_t*)pgm_read_word(&AboutTextPtrs[InfoNum]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCAVRISPMode(void)
{
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(AVRISPModeMessage);
	
	V2P_RunStateMachine(AICI_InterpretPacket);
}

void FUNCProgramDataflash(void)
{
	USI_SPIInitMaster();
	DataflashInfo.UseExernalDF = TRUE;
	DFSPIRoutinePointer = USI_SPITransmit;
	
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(DataFlashProgMode);

	V2P_RunStateMachine(PD_InterpretAVRISPPacket);
	   
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
}

void FUNCProgramAVR(void)
{
	uint8_t  DoneFailMessageBuff[19];
	uint8_t  Fault    = ISPCC_NO_FAULT;
	uint8_t  ProgMode = 0;

	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
	SPI_SPIInit();
	DataflashInfo.UseExernalDF = FALSE;
	
	if (!(DF_CheckCorrectOnboardChip()))
	  return;

	MAIN_WaitForJoyRelease();
	
	JoyStatus = 1;                               // Use an invalid joystick value to force the program to write the
	                                             // name of the default command onto the LCD
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_LEFT)
			  return;
			else if (JoyStatus & JOY_PRESS)
			  break;
			else if (JoyStatus & JOY_UP)
			  (ProgMode == 0)? ProgMode = ARRAY_UPPERBOUND(ProgOptions) : ProgMode--;
			else if (JoyStatus & JOY_DOWN)
			  (ProgMode == ARRAY_UPPERBOUND(ProgOptions))? ProgMode = 0 : ProgMode++;

			LCD_puts_f((uint8_t*)pgm_read_word(&ProgOptions[ProgMode])); // Show current function onto the LCD

			MAIN_WaitForJoyRelease();
		}
	}

	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_BASECLOCKSPEED_8MHZ);
	LCD_puts_f(WaitText);

	TIMEOUT_SLEEP_TIMER_OFF();

	USI_SPIInitMaster();
	MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);       // Capture the RESET line of the slave AVR
			
	for (uint8_t PacketB = 0; PacketB < 12; PacketB++) // Read the enter programming mode command bytes
	  PacketBytes[PacketB] = eeprom_read_byte(&EEPROMVars.EnterProgMode[PacketB]);
	
	ISPCC_EnterChipProgrammingMode();            // Try to sync with the slave AVR

	CurrAddress = 0;

	if (PacketBytes[1] == AICB_STATUS_CMD_OK)    // ISPCC_EnterChipProgrammingMode alters the PacketBytes buffer rather than returning a value
	{						
		if (!(ProgMode) || (ProgMode == 7) || (ProgMode == 1) || (ProgMode == 3)) // All, erase chip, flash and eeprom, or program flash mode
		{
			MAIN_ShowProgType('C');
			
			if (!(eeprom_read_byte(&EEPROMVars.EraseCmdStored) == TRUE))
			{
				Fault = ISPCC_FAULT_NOERASE;
				MAIN_ShowError(PSTR("NO ERASE CMD"));
			}
			else
			{
				PM_SendEraseCommand();
			}
		}

		if ((!(ProgMode) || (ProgMode == 1) || (ProgMode == 3)) && (Fault == ISPCC_NO_FAULT)) // All, flash and EEPROM, or program flash mode
		{
			MAIN_ShowProgType('D');

			if (!(PM_GetStoredDataSize(TYPE_FLASH))) // Check to make sure a program is present in memory
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
				MAIN_ShowError(PSTR("NO DATA"));
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_FLASH);
			}
		}
	
		if (!(ProgMode) || (ProgMode == 2) || (ProgMode == 3)) // All, flash and EEPROM, or program EEPROM mode
		{
			MAIN_ShowProgType('E');
				
			if (!(PM_GetStoredDataSize(TYPE_EEPROM))) // Check to make sure EEPROM data is present in memory
			{
				Fault = ISPCC_FAULT_NODATATYPE;
				MAIN_ShowError(PSTR("NO EEPROM"));
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_EEPROM);
			}
		}

		if (!(ProgMode) || (ProgMode == 4) || (ProgMode == 6)) // All, fuse and lock bytes, or program fuse bytes mode
		{
			MAIN_ShowProgType('F');
			
			if (!(eeprom_read_byte(&EEPROMVars.TotalFuseBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
				MAIN_ShowError(PSTR("NO FUSE BYTES"));
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_FUSE);
			}
		}

		if (!(ProgMode) || (ProgMode == 5) || (ProgMode == 6)) // All, fuse and lock bytes, or program lock bytes mode
		{
			if (ProgMode == 6)                           // If fusebytes have already been written, we need to reenter programming mode to latch them
			{
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line of the slave AVR
				MAIN_Delay10MS(1);
				MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);   // Capture the RESET line of the slave AVR
				ISPCC_EnterChipProgrammingMode();        // Try to sync with the slave AVR
			}

			MAIN_ShowProgType('L');
		
			if (!(eeprom_read_byte(&EEPROMVars.TotalLockBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;
				MAIN_ShowError(PSTR("NO LOCK BYTES"));
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_LOCK);
			}
		}

		strcpy_P(DoneFailMessageBuff, PSTR("PROGRAMMING DONE"));

		if (Fault != ISPCC_NO_FAULT)             // Takes less code to just overwrite part of the string on fail
		  strcpy_P(&DoneFailMessageBuff[12], PSTR("FAILED"));

		LCD_puts(DoneFailMessageBuff);

		MAIN_Delay10MS(250);
		MAIN_Delay10MS(200);
	}
	else
	{
		MAIN_ShowError(SyncErrorMessage);
	}
	
	TOUT_SetupSleepTimer();
	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_BASECLOCKSPEED_1MHZ);
	MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);     // Release the RESET line and allow the slave AVR to run	
	USI_SPIOff();
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);       // Set status LEDs to green (ready)
}

void FUNCStoreProgram(void)
{
	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
	SPI_SPIInit();
	DataflashInfo.UseExernalDF = FALSE;
	DF_EnableDataflash(TRUE);

	if (!(DF_CheckCorrectOnboardChip()))
	  return;
			
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(PSTR("*STORAGE MODE*"));

	V2P_RunStateMachine(PM_InterpretAVRISPPacket);
	
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
}

void FUNCClearMem(void)
{
	LCD_puts_f(PSTR("CONFIRM"));
	MAIN_Delay10MS(180);

	LCD_puts_f(PSTR("<N Y>"));

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_LEFT)
			  return;
			else if (JoyStatus & JOY_RIGHT)
			  break;
		}
	}

	MAIN_WaitForJoyRelease();

	LCD_puts_f(WaitText);
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);      // Set status LEDs to orange (busy)

	for (uint16_t EAddr = 0; EAddr < sizeof(EEPROMVars); EAddr++)
	  eeprom_write_byte((uint8_t*)EAddr, 0xFF);

	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);       // Set status LEDs to green (ready)
	LCD_puts_f(PSTR("MEM CLEARED"));
	MAIN_Delay10MS(250);
}

void FUNCSetContrast(void)
{
	uint8_t Buffer[6];
	uint8_t Contrast = (eeprom_read_byte(&EEPROMVars.LCDContrast) & 0x0F); // Ranges from 0-15 so mask retuns 15 on blank EEPROM (0xFF)
	
	JoyStatus = 1;                               // Invalid value to force the LCD to update
	
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				if (Contrast < 15)
				  Contrast++;
			}
			else if (JoyStatus & JOY_DOWN)
			{
				if (Contrast > 1)                // Zero is non-visible, so 1 is the minimum
				  Contrast--;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.LCDContrast, Contrast);
				return;
			}
					
			Buffer[0] = 'C';
			Buffer[1] = 'T';
			Buffer[2] = ' ';

			MAIN_IntToStr((uint16_t)Contrast, &Buffer[3]);
			LCD_puts(Buffer);

			LCD_CONTRAST_LEVEL(Contrast);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCSetISPSpeed(void)
{
	uint8_t CurrSpeed = eeprom_read_byte(&EEPROMVars.SCKDuration);

	if (CurrSpeed > ARRAY_UPPERBOUND(USISpeeds))
	  CurrSpeed = ARRAY_UPPERBOUND(USISpeeds);   // Protection against blank EEPROM

	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				(CurrSpeed == 0)? CurrSpeed = ARRAY_UPPERBOUND(USISpeeds) : CurrSpeed--;
			}
			else if (JoyStatus & JOY_DOWN)
			{
				(CurrSpeed == ARRAY_UPPERBOUND(USISpeeds))? CurrSpeed = 0 : CurrSpeed++;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.SCKDuration, CurrSpeed);
				return;
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f(USISpeeds[CurrSpeed]);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCSetResetMode(void)
{
	uint8_t CurrMode = (eeprom_read_byte(&EEPROMVars.SPIResetMode) & 0x01);

	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if ((JoyStatus & JOY_UP) || (JoyStatus & JOY_DOWN))
			{
				CurrMode ^= 1;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.SPIResetMode, CurrMode);
				return;
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f(SPIResetModes[CurrMode]);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCSetFirmMinorVer(void)
{
	uint8_t VerBuffer[5];
	uint8_t VerMinor = eeprom_read_byte(&EEPROMVars.FirmVerMinor);

	if (VerMinor > 9)
	  VerMinor = V2P_SW_VERSION_MINOR_DEFAULT;
	
	strcpy_P(VerBuffer, PSTR("V2- "));

	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				if (VerMinor < 9)
				  VerMinor++;
			}
			if (JoyStatus & JOY_DOWN)
			{
				if (VerMinor)
				  VerMinor--;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.FirmVerMinor, VerMinor);
				return;
			}
			
			VerBuffer[3] = ('0' + VerMinor);
			LCD_puts(VerBuffer);

			MAIN_WaitForJoyRelease();
		}
	}	
}

void FUNCSetAutoSleepTimeOut(void)
{
	uint8_t SleepTxtBuffer[8];
	uint8_t SleepVal = eeprom_read_byte(&EEPROMVars.AutoSleepValIndex);

	if (SleepVal > ARRAY_UPPERBOUND(AutoSleepTOValues))
	  SleepVal = ARRAY_UPPERBOUND(AutoSleepTOValues);

	strcpy_P(SleepTxtBuffer, PSTR("    SEC"));
	
	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				(SleepVal == 0)? SleepVal = ARRAY_UPPERBOUND(AutoSleepTOValues) : SleepVal--;
			}
			if (JoyStatus & JOY_DOWN)
			{
				(SleepVal == ARRAY_UPPERBOUND(AutoSleepTOValues))? SleepVal = 0 : SleepVal++;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.AutoSleepValIndex, SleepVal);
				TOUT_SetupSleepTimer();
				return;
			}

			if (!(SleepVal))
			{
				LCD_puts_f(PSTR("OFF"));
			}
			else
			{
				MAIN_IntToStr(pgm_read_byte(&AutoSleepTOValues[SleepVal]), &SleepTxtBuffer[0]);
				SleepTxtBuffer[3] = ' ';         // Remove the auto-string termination from the buffer
				LCD_puts(SleepTxtBuffer);
			}

			MAIN_WaitForJoyRelease();
		}
	}	
}

void FUNCSleepMode(void)
{
     5aa:	85 e0       	ldi	r24, 0x05	; 5
     5ac:	83 bf       	out	0x33, r24	; 51
	SMCR    = ((1 << SM1) | (1 << SE));          // Power down sleep mode
	LCDCRA &= ~(1 << LCDEN); 
     5ae:	80 91 e4 00 	lds	r24, 0x00E4
     5b2:	8f 77       	andi	r24, 0x7F	; 127
     5b4:	80 93 e4 00 	sts	0x00E4, r24
	
	MAIN_SETSTATUSLED(MAIN_STATLED_OFF);         // Save battery power - turn off status LED
     5b8:	81 b3       	in	r24, 0x11	; 17
     5ba:	8f 7c       	andi	r24, 0xCF	; 207
     5bc:	81 bb       	out	0x11, r24	; 17
     5be:	01 c0       	rjmp	.+2      	; 0x5c2 <FUNCSleepMode+0x18>

	while (!(JoyStatus & JOY_UP))                // Joystick interrupt wakes the micro
	  SLEEP();
     5c0:	88 95       	sleep
     5c2:	f6 9b       	sbis	0x1e, 6	; 30
     5c4:	fd cf       	rjmp	.-6      	; 0x5c0 <FUNCSleepMode+0x16>
	   
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);       // Turn status LED back on
     5c6:	81 b3       	in	r24, 0x11	; 17
     5c8:	8f 7c       	andi	r24, 0xCF	; 207
     5ca:	80 61       	ori	r24, 0x10	; 16
     5cc:	81 bb       	out	0x11, r24	; 17

	LCDCRA |= (1 << LCDEN);
     5ce:	80 91 e4 00 	lds	r24, 0x00E4
     5d2:	80 68       	ori	r24, 0x80	; 128
     5d4:	80 93 e4 00 	sts	0x00E4, r24
	
	MAIN_WaitForJoyRelease();
     5d8:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     5dc:	08 95       	ret

000005de <FUNCGoBootloader>:
}

void FUNCStorageInfo(void)
{
	uint8_t SelectedItem = 0;

	MAIN_WaitForJoyRelease();

	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & (JOY_UP | JOY_DOWN))
			{
				SelectedItem ^= 1;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				return;
			}
			else if (JoyStatus & JOY_PRESS)
			{
				if (SelectedItem == 1)           // View storage tags
				{
					DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
					SPI_SPIInit();
					DataflashInfo.UseExernalDF = FALSE;
					DF_EnableDataflash(TRUE);

					if (DF_CheckCorrectOnboardChip())
					{
						TM_ShowTags();
						SPI_SPIOFF();
					}
					else if (!(PM_GetStoredDataSize(TYPE_FLASH)))
					{
						DF_EnableDataflash(FALSE);
						SPI_SPIOFF();

						MAIN_ShowError(PSTR("NO STORED PRGM"));
					}	
				}
				else                             // View stored data sizes
				{
					PM_ShowStoredItemSizes();
				}
			}
			
			LCD_puts_f(SIFONames[SelectedItem]);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCGoBootloader(void)
{
     5de:	85 b7       	in	r24, 0x35	; 53
     5e0:	8f 77       	andi	r24, 0x7F	; 127
	uint8_t MD = (MCUCR & ~(1 << JTD));         // Forces compiler to use IN, AND plus two OUTs rather than two lots of IN/AND/OUTs
	MCUCR = MD;                                 // Turn on JTAG via code
     5e2:	85 bf       	out	0x35, r24	; 53
	MCUCR = MD;                                 // Set bit twice as specified in datasheet        
     5e4:	85 bf       	out	0x35, r24	; 53

	TIMEOUT_SLEEP_TIMER_OFF();
     5e6:	10 92 81 00 	sts	0x0081, r1
	
	LCD_puts_f(PSTR("*JTAG ON*"));
     5ea:	88 e7       	ldi	r24, 0x78	; 120
     5ec:	92 e0       	ldi	r25, 0x02	; 2
     5ee:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
	
	MAIN_WaitForJoyRelease();
     5f2:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
	
	WDTCR = ((1<<WDCE) | (1<<WDE));             // Enable Watchdog Timer to give reset after minimum timeout
     5f6:	88 e1       	ldi	r24, 0x18	; 24
     5f8:	80 93 60 00 	sts	0x0060, r24
     5fc:	ff cf       	rjmp	.-2      	; 0x5fc <FUNCGoBootloader+0x1e>

000005fe <FUNCShowAbout>:
     5fe:	1f 93       	push	r17
     600:	81 e0       	ldi	r24, 0x01	; 1
     602:	8e bb       	out	0x1e, r24	; 30
     604:	10 e0       	ldi	r17, 0x00	; 0
     606:	8e b3       	in	r24, 0x1e	; 30
     608:	88 23       	and	r24, r24
     60a:	e9 f3       	breq	.-6      	; 0x606 <FUNCShowAbout+0x8>
     60c:	f6 9b       	sbis	0x1e, 6	; 30
     60e:	06 c0       	rjmp	.+12     	; 0x61c <FUNCShowAbout+0x1e>
     610:	11 23       	and	r17, r17
     612:	11 f4       	brne	.+4      	; 0x618 <FUNCShowAbout+0x1a>
     614:	13 e0       	ldi	r17, 0x03	; 3
     616:	0c c0       	rjmp	.+24     	; 0x630 <FUNCShowAbout+0x32>
     618:	11 50       	subi	r17, 0x01	; 1
     61a:	0a c0       	rjmp	.+20     	; 0x630 <FUNCShowAbout+0x32>
     61c:	f7 9b       	sbis	0x1e, 7	; 30
     61e:	06 c0       	rjmp	.+12     	; 0x62c <FUNCShowAbout+0x2e>
     620:	13 30       	cpi	r17, 0x03	; 3
     622:	11 f4       	brne	.+4      	; 0x628 <FUNCShowAbout+0x2a>
     624:	10 e0       	ldi	r17, 0x00	; 0
     626:	04 c0       	rjmp	.+8      	; 0x630 <FUNCShowAbout+0x32>
     628:	1f 5f       	subi	r17, 0xFF	; 255
     62a:	02 c0       	rjmp	.+4      	; 0x630 <FUNCShowAbout+0x32>
     62c:	f2 99       	sbic	0x1e, 2	; 30
     62e:	0d c0       	rjmp	.+26     	; 0x64a <FUNCShowAbout+0x4c>
     630:	e1 2f       	mov	r30, r17
     632:	ff 27       	eor	r31, r31
     634:	ee 0f       	add	r30, r30
     636:	ff 1f       	adc	r31, r31
     638:	e1 56       	subi	r30, 0x61	; 97
     63a:	ff 4f       	sbci	r31, 0xFF	; 255
     63c:	85 91       	lpm	r24, Z+
     63e:	94 91       	lpm	r25, Z
     640:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     644:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     648:	de cf       	rjmp	.-68     	; 0x606 <FUNCShowAbout+0x8>
     64a:	1f 91       	pop	r17
     64c:	08 95       	ret

0000064e <FUNCChangeSettings>:
     64e:	1f 93       	push	r17
     650:	81 e0       	ldi	r24, 0x01	; 1
     652:	8e bb       	out	0x1e, r24	; 30
     654:	10 e0       	ldi	r17, 0x00	; 0
     656:	8e b3       	in	r24, 0x1e	; 30
     658:	88 23       	and	r24, r24
     65a:	e9 f3       	breq	.-6      	; 0x656 <FUNCChangeSettings+0x8>
     65c:	f6 9b       	sbis	0x1e, 6	; 30
     65e:	06 c0       	rjmp	.+12     	; 0x66c <FUNCChangeSettings+0x1e>
     660:	11 23       	and	r17, r17
     662:	11 f4       	brne	.+4      	; 0x668 <FUNCChangeSettings+0x1a>
     664:	16 e0       	ldi	r17, 0x06	; 6
     666:	19 c0       	rjmp	.+50     	; 0x69a <FUNCChangeSettings+0x4c>
     668:	11 50       	subi	r17, 0x01	; 1
     66a:	17 c0       	rjmp	.+46     	; 0x69a <FUNCChangeSettings+0x4c>
     66c:	f7 9b       	sbis	0x1e, 7	; 30
     66e:	06 c0       	rjmp	.+12     	; 0x67c <FUNCChangeSettings+0x2e>
     670:	16 30       	cpi	r17, 0x06	; 6
     672:	11 f4       	brne	.+4      	; 0x678 <FUNCChangeSettings+0x2a>
     674:	10 e0       	ldi	r17, 0x00	; 0
     676:	11 c0       	rjmp	.+34     	; 0x69a <FUNCChangeSettings+0x4c>
     678:	1f 5f       	subi	r17, 0xFF	; 255
     67a:	0f c0       	rjmp	.+30     	; 0x69a <FUNCChangeSettings+0x4c>
     67c:	f4 9b       	sbis	0x1e, 4	; 30
     67e:	0b c0       	rjmp	.+22     	; 0x696 <FUNCChangeSettings+0x48>
     680:	e1 2f       	mov	r30, r17
     682:	ff 27       	eor	r31, r31
     684:	ee 0f       	add	r30, r30
     686:	ff 1f       	adc	r31, r31
     688:	e6 56       	subi	r30, 0x66	; 102
     68a:	fe 4f       	sbci	r31, 0xFE	; 254
     68c:	85 91       	lpm	r24, Z+
     68e:	94 91       	lpm	r25, Z
     690:	fc 01       	movw	r30, r24
     692:	09 95       	icall
     694:	02 c0       	rjmp	.+4      	; 0x69a <FUNCChangeSettings+0x4c>
     696:	f2 99       	sbic	0x1e, 2	; 30
     698:	0d c0       	rjmp	.+26     	; 0x6b4 <FUNCChangeSettings+0x66>
     69a:	e1 2f       	mov	r30, r17
     69c:	ff 27       	eor	r31, r31
     69e:	ee 0f       	add	r30, r30
     6a0:	ff 1f       	adc	r31, r31
     6a2:	e4 57       	subi	r30, 0x74	; 116
     6a4:	fe 4f       	sbci	r31, 0xFE	; 254
     6a6:	85 91       	lpm	r24, Z+
     6a8:	94 91       	lpm	r25, Z
     6aa:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     6ae:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     6b2:	d1 cf       	rjmp	.-94     	; 0x656 <FUNCChangeSettings+0x8>
     6b4:	1f 91       	pop	r17
     6b6:	08 95       	ret

000006b8 <FUNCSetAutoSleepTimeOut>:
     6b8:	ef 92       	push	r14
     6ba:	ff 92       	push	r15
     6bc:	0f 93       	push	r16
     6be:	cf 93       	push	r28
     6c0:	df 93       	push	r29
     6c2:	cd b7       	in	r28, 0x3d	; 61
     6c4:	de b7       	in	r29, 0x3e	; 62
     6c6:	28 97       	sbiw	r28, 0x08	; 8
     6c8:	0f b6       	in	r0, 0x3f	; 63
     6ca:	f8 94       	cli
     6cc:	de bf       	out	0x3e, r29	; 62
     6ce:	0f be       	out	0x3f, r0	; 63
     6d0:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     6d2:	ab e8       	ldi	r26, 0x8B	; 139
     6d4:	b0 e0       	ldi	r27, 0x00	; 0
     6d6:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
     6da:	80 2d       	mov	r24, r0
     6dc:	08 2f       	mov	r16, r24
     6de:	85 30       	cpi	r24, 0x05	; 5
     6e0:	08 f0       	brcs	.+2      	; 0x6e4 <FUNCSetAutoSleepTimeOut+0x2c>
     6e2:	04 e0       	ldi	r16, 0x04	; 4
     6e4:	65 e9       	ldi	r22, 0x95	; 149
     6e6:	72 e0       	ldi	r23, 0x02	; 2
     6e8:	ce 01       	movw	r24, r28
     6ea:	01 96       	adiw	r24, 0x01	; 1
     6ec:	0e 94 51 1a 	call	0x34a2	; 0x34a2 <strcpy_P>
     6f0:	81 e0       	ldi	r24, 0x01	; 1
     6f2:	8e bb       	out	0x1e, r24	; 30
     6f4:	8e b3       	in	r24, 0x1e	; 30
     6f6:	88 23       	and	r24, r24
     6f8:	e9 f3       	breq	.-6      	; 0x6f4 <FUNCSetAutoSleepTimeOut+0x3c>
     6fa:	f6 9b       	sbis	0x1e, 6	; 30
     6fc:	05 c0       	rjmp	.+10     	; 0x708 <FUNCSetAutoSleepTimeOut+0x50>
     6fe:	00 23       	and	r16, r16
     700:	11 f4       	brne	.+4      	; 0x706 <FUNCSetAutoSleepTimeOut+0x4e>
     702:	04 e0       	ldi	r16, 0x04	; 4
     704:	01 c0       	rjmp	.+2      	; 0x708 <FUNCSetAutoSleepTimeOut+0x50>
     706:	01 50       	subi	r16, 0x01	; 1
     708:	f7 9b       	sbis	0x1e, 7	; 30
     70a:	06 c0       	rjmp	.+12     	; 0x718 <FUNCSetAutoSleepTimeOut+0x60>
     70c:	04 30       	cpi	r16, 0x04	; 4
     70e:	11 f4       	brne	.+4      	; 0x714 <FUNCSetAutoSleepTimeOut+0x5c>
     710:	00 e0       	ldi	r16, 0x00	; 0
     712:	06 c0       	rjmp	.+12     	; 0x720 <FUNCSetAutoSleepTimeOut+0x68>
     714:	0f 5f       	subi	r16, 0xFF	; 255
     716:	02 c0       	rjmp	.+4      	; 0x71c <FUNCSetAutoSleepTimeOut+0x64>
     718:	f2 99       	sbic	0x1e, 2	; 30
     71a:	1d c0       	rjmp	.+58     	; 0x756 <FUNCSetAutoSleepTimeOut+0x9e>
     71c:	00 23       	and	r16, r16
     71e:	29 f4       	brne	.+10     	; 0x72a <FUNCSetAutoSleepTimeOut+0x72>
     720:	81 e9       	ldi	r24, 0x91	; 145
     722:	92 e0       	ldi	r25, 0x02	; 2
     724:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     728:	13 c0       	rjmp	.+38     	; 0x750 <FUNCSetAutoSleepTimeOut+0x98>
     72a:	e0 2f       	mov	r30, r16
     72c:	ff 27       	eor	r31, r31
     72e:	ef 51       	subi	r30, 0x1F	; 31
     730:	fc 4f       	sbci	r31, 0xFC	; 252
     732:	e4 91       	lpm	r30, Z
     734:	7e 01       	movw	r14, r28
     736:	08 94       	sec
     738:	e1 1c       	adc	r14, r1
     73a:	f1 1c       	adc	r15, r1
     73c:	b7 01       	movw	r22, r14
     73e:	8e 2f       	mov	r24, r30
     740:	99 27       	eor	r25, r25
     742:	0e 94 97 02 	call	0x52e	; 0x52e <MAIN_IntToStr>
     746:	80 e2       	ldi	r24, 0x20	; 32
     748:	8c 83       	std	Y+4, r24	; 0x04
     74a:	c7 01       	movw	r24, r14
     74c:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
     750:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     754:	cf cf       	rjmp	.-98     	; 0x6f4 <FUNCSetAutoSleepTimeOut+0x3c>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     756:	ab e8       	ldi	r26, 0x8B	; 139
     758:	b0 e0       	ldi	r27, 0x00	; 0
     75a:	00 2e       	mov	r0, r16
     75c:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
     760:	0e 94 40 0c 	call	0x1880	; 0x1880 <TOUT_SetupSleepTimer>
     764:	28 96       	adiw	r28, 0x08	; 8
     766:	0f b6       	in	r0, 0x3f	; 63
     768:	f8 94       	cli
     76a:	de bf       	out	0x3e, r29	; 62
     76c:	0f be       	out	0x3f, r0	; 63
     76e:	cd bf       	out	0x3d, r28	; 61
     770:	df 91       	pop	r29
     772:	cf 91       	pop	r28
     774:	0f 91       	pop	r16
     776:	ff 90       	pop	r15
     778:	ef 90       	pop	r14
     77a:	08 95       	ret

0000077c <MAIN_ShowError>:
     77c:	cf 93       	push	r28
     77e:	df 93       	push	r29
     780:	cd b7       	in	r28, 0x3d	; 61
     782:	de b7       	in	r29, 0x3e	; 62
     784:	64 97       	sbiw	r28, 0x14	; 20
     786:	0f b6       	in	r0, 0x3f	; 63
     788:	f8 94       	cli
     78a:	de bf       	out	0x3e, r29	; 62
     78c:	0f be       	out	0x3f, r0	; 63
     78e:	cd bf       	out	0x3d, r28	; 61
     790:	25 e4       	ldi	r18, 0x45	; 69
     792:	29 83       	std	Y+1, r18	; 0x01
     794:	2e e3       	ldi	r18, 0x3E	; 62
     796:	2a 83       	std	Y+2, r18	; 0x02
     798:	bc 01       	movw	r22, r24
     79a:	ce 01       	movw	r24, r28
     79c:	03 96       	adiw	r24, 0x03	; 3
     79e:	0e 94 51 1a 	call	0x34a2	; 0x34a2 <strcpy_P>
     7a2:	ce 01       	movw	r24, r28
     7a4:	01 96       	adiw	r24, 0x01	; 1
     7a6:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
     7aa:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     7ae:	f4 9b       	sbis	0x1e, 4	; 30
     7b0:	fe cf       	rjmp	.-4      	; 0x7ae <MAIN_ShowError+0x32>
     7b2:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     7b6:	64 96       	adiw	r28, 0x14	; 20
     7b8:	0f b6       	in	r0, 0x3f	; 63
     7ba:	f8 94       	cli
     7bc:	de bf       	out	0x3e, r29	; 62
     7be:	0f be       	out	0x3f, r0	; 63
     7c0:	cd bf       	out	0x3d, r28	; 61
     7c2:	df 91       	pop	r29
     7c4:	cf 91       	pop	r28
     7c6:	08 95       	ret

000007c8 <FUNCStorageInfo>:
     7c8:	1f 93       	push	r17
     7ca:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     7ce:	81 e0       	ldi	r24, 0x01	; 1
     7d0:	8e bb       	out	0x1e, r24	; 30
     7d2:	10 e0       	ldi	r17, 0x00	; 0
     7d4:	8e b3       	in	r24, 0x1e	; 30
     7d6:	88 23       	and	r24, r24
     7d8:	e9 f3       	breq	.-6      	; 0x7d4 <FUNCStorageInfo+0xc>
     7da:	8e b3       	in	r24, 0x1e	; 30
     7dc:	80 7c       	andi	r24, 0xC0	; 192
     7de:	19 f0       	breq	.+6      	; 0x7e6 <FUNCStorageInfo+0x1e>
     7e0:	81 e0       	ldi	r24, 0x01	; 1
     7e2:	18 27       	eor	r17, r24
     7e4:	36 c0       	rjmp	.+108    	; 0x852 <FUNCStorageInfo+0x8a>
     7e6:	f2 99       	sbic	0x1e, 2	; 30
     7e8:	3f c0       	rjmp	.+126    	; 0x868 <FUNCStorageInfo+0xa0>
     7ea:	f4 9b       	sbis	0x1e, 4	; 30
     7ec:	32 c0       	rjmp	.+100    	; 0x852 <FUNCStorageInfo+0x8a>
     7ee:	11 30       	cpi	r17, 0x01	; 1
     7f0:	71 f5       	brne	.+92     	; 0x84e <FUNCStorageInfo+0x86>
     7f2:	8f ea       	ldi	r24, 0xAF	; 175
     7f4:	99 e0       	ldi	r25, 0x09	; 9
     7f6:	90 93 01 01 	sts	0x0101, r25
     7fa:	80 93 00 01 	sts	0x0100, r24
     7fe:	0e 94 a7 09 	call	0x134e	; 0x134e <SPI_SPIInit>
     802:	10 92 47 01 	sts	0x0147, r1
     806:	81 e0       	ldi	r24, 0x01	; 1
     808:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
     80c:	0e 94 c1 0b 	call	0x1782	; 0x1782 <DF_CheckCorrectOnboardChip>
     810:	88 23       	and	r24, r24
     812:	41 f0       	breq	.+16     	; 0x824 <FUNCStorageInfo+0x5c>
     814:	0e 94 22 1a 	call	0x3444	; 0x3444 <TM_ShowTags>
     818:	80 91 64 00 	lds	r24, 0x0064
     81c:	84 60       	ori	r24, 0x04	; 4
     81e:	80 93 64 00 	sts	0x0064, r24
     822:	17 c0       	rjmp	.+46     	; 0x852 <FUNCStorageInfo+0x8a>
     824:	81 e0       	ldi	r24, 0x01	; 1
     826:	0e 94 f5 14 	call	0x29ea	; 0x29ea <PM_GetStoredDataSize>
     82a:	61 15       	cp	r22, r1
     82c:	71 05       	cpc	r23, r1
     82e:	81 05       	cpc	r24, r1
     830:	91 05       	cpc	r25, r1
     832:	79 f4       	brne	.+30     	; 0x852 <FUNCStorageInfo+0x8a>
     834:	80 e0       	ldi	r24, 0x00	; 0
     836:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
     83a:	80 91 64 00 	lds	r24, 0x0064
     83e:	84 60       	ori	r24, 0x04	; 4
     840:	80 93 64 00 	sts	0x0064, r24
     844:	82 e8       	ldi	r24, 0x82	; 130
     846:	92 e0       	ldi	r25, 0x02	; 2
     848:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
     84c:	02 c0       	rjmp	.+4      	; 0x852 <FUNCStorageInfo+0x8a>
     84e:	0e 94 de 16 	call	0x2dbc	; 0x2dbc <PM_ShowStoredItemSizes>
     852:	8f e0       	ldi	r24, 0x0F	; 15
     854:	18 9f       	mul	r17, r24
     856:	c0 01       	movw	r24, r0
     858:	11 24       	eor	r1, r1
     85a:	86 5a       	subi	r24, 0xA6	; 166
     85c:	9d 4f       	sbci	r25, 0xFD	; 253
     85e:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     862:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     866:	b6 cf       	rjmp	.-148    	; 0x7d4 <FUNCStorageInfo+0xc>
     868:	1f 91       	pop	r17
     86a:	08 95       	ret

0000086c <MAIN_ShowProgType>:
     86c:	ff 92       	push	r15
     86e:	0f 93       	push	r16
     870:	1f 93       	push	r17
     872:	cf 93       	push	r28
     874:	df 93       	push	r29
     876:	cd b7       	in	r28, 0x3d	; 61
     878:	de b7       	in	r29, 0x3e	; 62
     87a:	27 97       	sbiw	r28, 0x07	; 7
     87c:	0f b6       	in	r0, 0x3f	; 63
     87e:	f8 94       	cli
     880:	de bf       	out	0x3e, r29	; 62
     882:	0f be       	out	0x3f, r0	; 63
     884:	cd bf       	out	0x3d, r28	; 61
     886:	f8 2e       	mov	r15, r24
     888:	8e 01       	movw	r16, r28
     88a:	0f 5f       	subi	r16, 0xFF	; 255
     88c:	1f 4f       	sbci	r17, 0xFF	; 255
     88e:	65 e2       	ldi	r22, 0x25	; 37
     890:	73 e0       	ldi	r23, 0x03	; 3
     892:	c8 01       	movw	r24, r16
     894:	0e 94 51 1a 	call	0x34a2	; 0x34a2 <strcpy_P>
     898:	fe 82       	std	Y+6, r15	; 0x06
     89a:	c8 01       	movw	r24, r16
     89c:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
     8a0:	27 96       	adiw	r28, 0x07	; 7
     8a2:	0f b6       	in	r0, 0x3f	; 63
     8a4:	f8 94       	cli
     8a6:	de bf       	out	0x3e, r29	; 62
     8a8:	0f be       	out	0x3f, r0	; 63
     8aa:	cd bf       	out	0x3d, r28	; 61
     8ac:	df 91       	pop	r29
     8ae:	cf 91       	pop	r28
     8b0:	1f 91       	pop	r17
     8b2:	0f 91       	pop	r16
     8b4:	ff 90       	pop	r15
     8b6:	08 95       	ret

000008b8 <FUNCStoreProgram>:
     8b8:	8f ea       	ldi	r24, 0xAF	; 175
     8ba:	99 e0       	ldi	r25, 0x09	; 9
     8bc:	90 93 01 01 	sts	0x0101, r25
     8c0:	80 93 00 01 	sts	0x0100, r24
     8c4:	0e 94 a7 09 	call	0x134e	; 0x134e <SPI_SPIInit>
     8c8:	10 92 47 01 	sts	0x0147, r1
     8cc:	81 e0       	ldi	r24, 0x01	; 1
     8ce:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
     8d2:	0e 94 c1 0b 	call	0x1782	; 0x1782 <DF_CheckCorrectOnboardChip>
     8d6:	88 23       	and	r24, r24
     8d8:	e1 f0       	breq	.+56     	; 0x912 <FUNCStoreProgram+0x5a>
     8da:	87 ea       	ldi	r24, 0xA7	; 167
     8dc:	90 e0       	ldi	r25, 0x00	; 0
     8de:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     8e2:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <OSCCAL_Calibrate>
     8e6:	80 91 c1 00 	lds	r24, 0x00C1
     8ea:	80 78       	andi	r24, 0x80	; 128
     8ec:	88 61       	ori	r24, 0x18	; 24
     8ee:	80 93 c1 00 	sts	0x00C1, r24
     8f2:	8c eb       	ldi	r24, 0xBC	; 188
     8f4:	92 e0       	ldi	r25, 0x02	; 2
     8f6:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     8fa:	82 e5       	ldi	r24, 0x52	; 82
     8fc:	97 e1       	ldi	r25, 0x17	; 23
     8fe:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <V2P_RunStateMachine>
     902:	80 e0       	ldi	r24, 0x00	; 0
     904:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
     908:	80 91 64 00 	lds	r24, 0x0064
     90c:	84 60       	ori	r24, 0x04	; 4
     90e:	80 93 64 00 	sts	0x0064, r24
     912:	08 95       	ret

00000914 <FUNCAVRISPMode>:
     914:	87 ea       	ldi	r24, 0xA7	; 167
     916:	90 e0       	ldi	r25, 0x00	; 0
     918:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     91c:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <OSCCAL_Calibrate>
     920:	e1 ec       	ldi	r30, 0xC1	; 193
     922:	f0 e0       	ldi	r31, 0x00	; 0
     924:	80 81       	ld	r24, Z
     926:	80 78       	andi	r24, 0x80	; 128
     928:	88 61       	ori	r24, 0x18	; 24
     92a:	80 83       	st	Z, r24
     92c:	86 e3       	ldi	r24, 0x36	; 54
     92e:	94 e0       	ldi	r25, 0x04	; 4
     930:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     934:	89 ef       	ldi	r24, 0xF9	; 249
     936:	92 e1       	ldi	r25, 0x12	; 18
     938:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <V2P_RunStateMachine>
     93c:	08 95       	ret

0000093e <FUNCProgramDataflash>:
     93e:	0e 94 2e 0a 	call	0x145c	; 0x145c <USI_SPIInitMaster>
     942:	81 e0       	ldi	r24, 0x01	; 1
     944:	80 93 47 01 	sts	0x0147, r24
     948:	8e ee       	ldi	r24, 0xEE	; 238
     94a:	99 e0       	ldi	r25, 0x09	; 9
     94c:	90 93 01 01 	sts	0x0101, r25
     950:	80 93 00 01 	sts	0x0100, r24
     954:	87 ea       	ldi	r24, 0xA7	; 167
     956:	90 e0       	ldi	r25, 0x00	; 0
     958:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     95c:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <OSCCAL_Calibrate>
     960:	e1 ec       	ldi	r30, 0xC1	; 193
     962:	f0 e0       	ldi	r31, 0x00	; 0
     964:	80 81       	ld	r24, Z
     966:	80 78       	andi	r24, 0x80	; 128
     968:	88 61       	ori	r24, 0x18	; 24
     96a:	80 83       	st	Z, r24
     96c:	89 ef       	ldi	r24, 0xF9	; 249
     96e:	93 e0       	ldi	r25, 0x03	; 3
     970:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     974:	82 e6       	ldi	r24, 0x62	; 98
     976:	9d e0       	ldi	r25, 0x0D	; 13
     978:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <V2P_RunStateMachine>
     97c:	80 e0       	ldi	r24, 0x00	; 0
     97e:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
     982:	e4 e6       	ldi	r30, 0x64	; 100
     984:	f0 e0       	ldi	r31, 0x00	; 0
     986:	80 81       	ld	r24, Z
     988:	84 60       	ori	r24, 0x04	; 4
     98a:	80 83       	st	Z, r24
     98c:	08 95       	ret

0000098e <MAIN_CrashProgram>:
     98e:	8c 01       	movw	r16, r24
     990:	80 91 64 00 	lds	r24, 0x0064
     994:	84 60       	ori	r24, 0x04	; 4
     996:	80 93 64 00 	sts	0x0064, r24
     99a:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <USI_SPIOff>
     99e:	10 92 b0 00 	sts	0x00B0, r1
     9a2:	10 92 70 00 	sts	0x0070, r1
     9a6:	10 92 81 00 	sts	0x0081, r1
     9aa:	80 e8       	ldi	r24, 0x80	; 128
     9ac:	80 93 61 00 	sts	0x0061, r24
     9b0:	83 e0       	ldi	r24, 0x03	; 3
     9b2:	80 93 61 00 	sts	0x0061, r24
     9b6:	10 92 c1 00 	sts	0x00C1, r1
     9ba:	c8 01       	movw	r24, r16
     9bc:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
     9c0:	81 b3       	in	r24, 0x11	; 17
     9c2:	8f 7c       	andi	r24, 0xCF	; 207
     9c4:	80 63       	ori	r24, 0x30	; 48
     9c6:	81 bb       	out	0x11, r24	; 17
     9c8:	82 e3       	ldi	r24, 0x32	; 50
     9ca:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     9ce:	81 b3       	in	r24, 0x11	; 17
     9d0:	90 e2       	ldi	r25, 0x20	; 32
     9d2:	89 27       	eor	r24, r25
     9d4:	f8 cf       	rjmp	.-16     	; 0x9c6 <MAIN_CrashProgram+0x38>

000009d6 <__vector_default>:
     9d6:	8e e1       	ldi	r24, 0x1E	; 30
     9d8:	93 e0       	ldi	r25, 0x03	; 3
     9da:	0e 94 c7 04 	call	0x98e	; 0x98e <MAIN_CrashProgram>

000009de <FUNCProgramAVR>:
     9de:	0f 93       	push	r16
     9e0:	1f 93       	push	r17
     9e2:	cf 93       	push	r28
     9e4:	df 93       	push	r29
     9e6:	cd b7       	in	r28, 0x3d	; 61
     9e8:	de b7       	in	r29, 0x3e	; 62
     9ea:	63 97       	sbiw	r28, 0x13	; 19
     9ec:	0f b6       	in	r0, 0x3f	; 63
     9ee:	f8 94       	cli
     9f0:	de bf       	out	0x3e, r29	; 62
     9f2:	0f be       	out	0x3f, r0	; 63
     9f4:	cd bf       	out	0x3d, r28	; 61
     9f6:	8f ea       	ldi	r24, 0xAF	; 175
     9f8:	99 e0       	ldi	r25, 0x09	; 9
     9fa:	90 93 01 01 	sts	0x0101, r25
     9fe:	80 93 00 01 	sts	0x0100, r24
     a02:	0e 94 a7 09 	call	0x134e	; 0x134e <SPI_SPIInit>
     a06:	10 92 47 01 	sts	0x0147, r1
     a0a:	0e 94 c1 0b 	call	0x1782	; 0x1782 <DF_CheckCorrectOnboardChip>
     a0e:	88 23       	and	r24, r24
     a10:	09 f4       	brne	.+2      	; 0xa14 <FUNCProgramAVR+0x36>
     a12:	1d c1       	rjmp	.+570    	; 0xc4e <FUNCProgramAVR+0x270>
     a14:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     a18:	81 e0       	ldi	r24, 0x01	; 1
     a1a:	8e bb       	out	0x1e, r24	; 30
     a1c:	10 e0       	ldi	r17, 0x00	; 0
     a1e:	8e b3       	in	r24, 0x1e	; 30
     a20:	88 23       	and	r24, r24
     a22:	e9 f3       	breq	.-6      	; 0xa1e <FUNCProgramAVR+0x40>
     a24:	f2 99       	sbic	0x1e, 2	; 30
     a26:	13 c1       	rjmp	.+550    	; 0xc4e <FUNCProgramAVR+0x270>
     a28:	f4 99       	sbic	0x1e, 4	; 30
     a2a:	1c c0       	rjmp	.+56     	; 0xa64 <FUNCProgramAVR+0x86>
     a2c:	f6 9b       	sbis	0x1e, 6	; 30
     a2e:	06 c0       	rjmp	.+12     	; 0xa3c <FUNCProgramAVR+0x5e>
     a30:	11 23       	and	r17, r17
     a32:	11 f4       	brne	.+4      	; 0xa38 <FUNCProgramAVR+0x5a>
     a34:	17 e0       	ldi	r17, 0x07	; 7
     a36:	09 c0       	rjmp	.+18     	; 0xa4a <FUNCProgramAVR+0x6c>
     a38:	11 50       	subi	r17, 0x01	; 1
     a3a:	07 c0       	rjmp	.+14     	; 0xa4a <FUNCProgramAVR+0x6c>
     a3c:	f7 9b       	sbis	0x1e, 7	; 30
     a3e:	05 c0       	rjmp	.+10     	; 0xa4a <FUNCProgramAVR+0x6c>
     a40:	17 30       	cpi	r17, 0x07	; 7
     a42:	11 f4       	brne	.+4      	; 0xa48 <FUNCProgramAVR+0x6a>
     a44:	10 e0       	ldi	r17, 0x00	; 0
     a46:	01 c0       	rjmp	.+2      	; 0xa4a <FUNCProgramAVR+0x6c>
     a48:	1f 5f       	subi	r17, 0xFF	; 255
     a4a:	e1 2f       	mov	r30, r17
     a4c:	ff 27       	eor	r31, r31
     a4e:	ee 0f       	add	r30, r30
     a50:	ff 1f       	adc	r31, r31
     a52:	ea 5e       	subi	r30, 0xEA	; 234
     a54:	fd 4f       	sbci	r31, 0xFD	; 253
     a56:	85 91       	lpm	r24, Z+
     a58:	94 91       	lpm	r25, Z
     a5a:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     a5e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     a62:	dd cf       	rjmp	.-70     	; 0xa1e <FUNCProgramAVR+0x40>
     a64:	80 e8       	ldi	r24, 0x80	; 128
     a66:	80 93 61 00 	sts	0x0061, r24
     a6a:	10 92 61 00 	sts	0x0061, r1
     a6e:	87 ea       	ldi	r24, 0xA7	; 167
     a70:	90 e0       	ldi	r25, 0x00	; 0
     a72:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     a76:	10 92 81 00 	sts	0x0081, r1
     a7a:	0e 94 2e 0a 	call	0x145c	; 0x145c <USI_SPIInitMaster>
     a7e:	80 e0       	ldi	r24, 0x00	; 0
     a80:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     a84:	27 e2       	ldi	r18, 0x27	; 39
     a86:	30 e0       	ldi	r19, 0x00	; 0
     a88:	e1 e9       	ldi	r30, 0x91	; 145
     a8a:	f1 e0       	ldi	r31, 0x01	; 1
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     a8c:	d9 01       	movw	r26, r18
     a8e:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
     a92:	80 2d       	mov	r24, r0
     a94:	81 93       	st	Z+, r24
     a96:	2f 5f       	subi	r18, 0xFF	; 255
     a98:	3f 4f       	sbci	r19, 0xFF	; 255
     a9a:	80 e0       	ldi	r24, 0x00	; 0
     a9c:	23 33       	cpi	r18, 0x33	; 51
     a9e:	38 07       	cpc	r19, r24
     aa0:	a9 f7       	brne	.-22     	; 0xa8c <FUNCProgramAVR+0xae>
     aa2:	0e 94 98 12 	call	0x2530	; 0x2530 <ISPCC_EnterChipProgrammingMode>
     aa6:	10 92 a9 02 	sts	0x02A9, r1
     aaa:	10 92 aa 02 	sts	0x02AA, r1
     aae:	10 92 ab 02 	sts	0x02AB, r1
     ab2:	10 92 ac 02 	sts	0x02AC, r1
     ab6:	80 91 92 01 	lds	r24, 0x0192
     aba:	88 23       	and	r24, r24
     abc:	09 f0       	breq	.+2      	; 0xac0 <FUNCProgramAVR+0xe2>
     abe:	aa c0       	rjmp	.+340    	; 0xc14 <FUNCProgramAVR+0x236>
     ac0:	11 23       	and	r17, r17
     ac2:	31 f0       	breq	.+12     	; 0xad0 <FUNCProgramAVR+0xf2>
     ac4:	17 30       	cpi	r17, 0x07	; 7
     ac6:	21 f0       	breq	.+8      	; 0xad0 <FUNCProgramAVR+0xf2>
     ac8:	11 30       	cpi	r17, 0x01	; 1
     aca:	11 f0       	breq	.+4      	; 0xad0 <FUNCProgramAVR+0xf2>
     acc:	13 30       	cpi	r17, 0x03	; 3
     ace:	91 f4       	brne	.+36     	; 0xaf4 <FUNCProgramAVR+0x116>
     ad0:	83 e4       	ldi	r24, 0x43	; 67
     ad2:	0e 94 36 04 	call	0x86c	; 0x86c <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     ad6:	a7 e1       	ldi	r26, 0x17	; 23
     ad8:	b0 e0       	ldi	r27, 0x00	; 0
     ada:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
     ade:	80 2d       	mov	r24, r0
     ae0:	81 30       	cpi	r24, 0x01	; 1
     ae2:	31 f0       	breq	.+12     	; 0xaf0 <FUNCProgramAVR+0x112>
     ae4:	81 e1       	ldi	r24, 0x11	; 17
     ae6:	93 e0       	ldi	r25, 0x03	; 3
     ae8:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
     aec:	02 e0       	ldi	r16, 0x02	; 2
     aee:	03 c0       	rjmp	.+6      	; 0xaf6 <FUNCProgramAVR+0x118>
     af0:	0e 94 97 15 	call	0x2b2e	; 0x2b2e <PM_SendEraseCommand>
     af4:	00 e0       	ldi	r16, 0x00	; 0
     af6:	12 30       	cpi	r17, 0x02	; 2
     af8:	10 f0       	brcs	.+4      	; 0xafe <FUNCProgramAVR+0x120>
     afa:	13 30       	cpi	r17, 0x03	; 3
     afc:	c1 f4       	brne	.+48     	; 0xb2e <FUNCProgramAVR+0x150>
     afe:	00 23       	and	r16, r16
     b00:	a1 f4       	brne	.+40     	; 0xb2a <FUNCProgramAVR+0x14c>
     b02:	84 e4       	ldi	r24, 0x44	; 68
     b04:	0e 94 36 04 	call	0x86c	; 0x86c <MAIN_ShowProgType>
     b08:	81 e0       	ldi	r24, 0x01	; 1
     b0a:	0e 94 f5 14 	call	0x29ea	; 0x29ea <PM_GetStoredDataSize>
     b0e:	61 15       	cp	r22, r1
     b10:	71 05       	cpc	r23, r1
     b12:	81 05       	cpc	r24, r1
     b14:	91 05       	cpc	r25, r1
     b16:	31 f4       	brne	.+12     	; 0xb24 <FUNCProgramAVR+0x146>
     b18:	89 e0       	ldi	r24, 0x09	; 9
     b1a:	93 e0       	ldi	r25, 0x03	; 3
     b1c:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
     b20:	03 e0       	ldi	r16, 0x03	; 3
     b22:	03 c0       	rjmp	.+6      	; 0xb2a <FUNCProgramAVR+0x14c>
     b24:	81 e0       	ldi	r24, 0x01	; 1
     b26:	0e 94 c3 15 	call	0x2b86	; 0x2b86 <PM_CreateProgrammingPackets>
     b2a:	11 23       	and	r17, r17
     b2c:	21 f0       	breq	.+8      	; 0xb36 <FUNCProgramAVR+0x158>
     b2e:	12 30       	cpi	r17, 0x02	; 2
     b30:	11 f0       	breq	.+4      	; 0xb36 <FUNCProgramAVR+0x158>
     b32:	13 30       	cpi	r17, 0x03	; 3
     b34:	b1 f4       	brne	.+44     	; 0xb62 <FUNCProgramAVR+0x184>
     b36:	85 e4       	ldi	r24, 0x45	; 69
     b38:	0e 94 36 04 	call	0x86c	; 0x86c <MAIN_ShowProgType>
     b3c:	80 e0       	ldi	r24, 0x00	; 0
     b3e:	0e 94 f5 14 	call	0x29ea	; 0x29ea <PM_GetStoredDataSize>
     b42:	61 15       	cp	r22, r1
     b44:	71 05       	cpc	r23, r1
     b46:	81 05       	cpc	r24, r1
     b48:	91 05       	cpc	r25, r1
     b4a:	31 f4       	brne	.+12     	; 0xb58 <FUNCProgramAVR+0x17a>
     b4c:	8f ef       	ldi	r24, 0xFF	; 255
     b4e:	92 e0       	ldi	r25, 0x02	; 2
     b50:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
     b54:	03 e0       	ldi	r16, 0x03	; 3
     b56:	03 c0       	rjmp	.+6      	; 0xb5e <FUNCProgramAVR+0x180>
     b58:	80 e0       	ldi	r24, 0x00	; 0
     b5a:	0e 94 c3 15 	call	0x2b86	; 0x2b86 <PM_CreateProgrammingPackets>
     b5e:	11 23       	and	r17, r17
     b60:	21 f0       	breq	.+8      	; 0xb6a <FUNCProgramAVR+0x18c>
     b62:	14 30       	cpi	r17, 0x04	; 4
     b64:	11 f0       	breq	.+4      	; 0xb6a <FUNCProgramAVR+0x18c>
     b66:	16 30       	cpi	r17, 0x06	; 6
     b68:	a9 f4       	brne	.+42     	; 0xb94 <FUNCProgramAVR+0x1b6>
     b6a:	86 e4       	ldi	r24, 0x46	; 70
     b6c:	0e 94 36 04 	call	0x86c	; 0x86c <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     b70:	a3 e3       	ldi	r26, 0x33	; 51
     b72:	b0 e0       	ldi	r27, 0x00	; 0
     b74:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
     b78:	80 2d       	mov	r24, r0
     b7a:	88 23       	and	r24, r24
     b7c:	31 f4       	brne	.+12     	; 0xb8a <FUNCProgramAVR+0x1ac>
     b7e:	81 ef       	ldi	r24, 0xF1	; 241
     b80:	92 e0       	ldi	r25, 0x02	; 2
     b82:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
     b86:	03 e0       	ldi	r16, 0x03	; 3
     b88:	03 c0       	rjmp	.+6      	; 0xb90 <FUNCProgramAVR+0x1b2>
     b8a:	82 e0       	ldi	r24, 0x02	; 2
     b8c:	0e 94 59 15 	call	0x2ab2	; 0x2ab2 <PM_SendFuseLockBytes>
     b90:	11 23       	and	r17, r17
     b92:	79 f0       	breq	.+30     	; 0xbb2 <FUNCProgramAVR+0x1d4>
     b94:	15 30       	cpi	r17, 0x05	; 5
     b96:	69 f0       	breq	.+26     	; 0xbb2 <FUNCProgramAVR+0x1d4>
     b98:	16 30       	cpi	r17, 0x06	; 6
     b9a:	19 f5       	brne	.+70     	; 0xbe2 <FUNCProgramAVR+0x204>
     b9c:	81 e0       	ldi	r24, 0x01	; 1
     b9e:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     ba2:	81 e0       	ldi	r24, 0x01	; 1
     ba4:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     ba8:	80 e0       	ldi	r24, 0x00	; 0
     baa:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     bae:	0e 94 98 12 	call	0x2530	; 0x2530 <ISPCC_EnterChipProgrammingMode>
     bb2:	8c e4       	ldi	r24, 0x4C	; 76
     bb4:	0e 94 36 04 	call	0x86c	; 0x86c <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     bb8:	a4 e3       	ldi	r26, 0x34	; 52
     bba:	b0 e0       	ldi	r27, 0x00	; 0
     bbc:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
     bc0:	80 2d       	mov	r24, r0
     bc2:	88 23       	and	r24, r24
     bc4:	59 f4       	brne	.+22     	; 0xbdc <FUNCProgramAVR+0x1fe>
     bc6:	83 ee       	ldi	r24, 0xE3	; 227
     bc8:	92 e0       	ldi	r25, 0x02	; 2
     bca:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
     bce:	62 ed       	ldi	r22, 0xD2	; 210
     bd0:	72 e0       	ldi	r23, 0x02	; 2
     bd2:	ce 01       	movw	r24, r28
     bd4:	01 96       	adiw	r24, 0x01	; 1
     bd6:	0e 94 51 1a 	call	0x34a2	; 0x34a2 <strcpy_P>
     bda:	0b c0       	rjmp	.+22     	; 0xbf2 <FUNCProgramAVR+0x214>
     bdc:	83 e0       	ldi	r24, 0x03	; 3
     bde:	0e 94 59 15 	call	0x2ab2	; 0x2ab2 <PM_SendFuseLockBytes>
     be2:	62 ed       	ldi	r22, 0xD2	; 210
     be4:	72 e0       	ldi	r23, 0x02	; 2
     be6:	ce 01       	movw	r24, r28
     be8:	01 96       	adiw	r24, 0x01	; 1
     bea:	0e 94 51 1a 	call	0x34a2	; 0x34a2 <strcpy_P>
     bee:	00 23       	and	r16, r16
     bf0:	31 f0       	breq	.+12     	; 0xbfe <FUNCProgramAVR+0x220>
     bf2:	6b ec       	ldi	r22, 0xCB	; 203
     bf4:	72 e0       	ldi	r23, 0x02	; 2
     bf6:	ce 01       	movw	r24, r28
     bf8:	0d 96       	adiw	r24, 0x0d	; 13
     bfa:	0e 94 51 1a 	call	0x34a2	; 0x34a2 <strcpy_P>
     bfe:	ce 01       	movw	r24, r28
     c00:	01 96       	adiw	r24, 0x01	; 1
     c02:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
     c06:	8a ef       	ldi	r24, 0xFA	; 250
     c08:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     c0c:	88 ec       	ldi	r24, 0xC8	; 200
     c0e:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     c12:	04 c0       	rjmp	.+8      	; 0xc1c <FUNCProgramAVR+0x23e>
     c14:	8b e2       	ldi	r24, 0x2B	; 43
     c16:	94 e0       	ldi	r25, 0x04	; 4
     c18:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
     c1c:	0e 94 40 0c 	call	0x1880	; 0x1880 <TOUT_SetupSleepTimer>
     c20:	80 e8       	ldi	r24, 0x80	; 128
     c22:	80 93 61 00 	sts	0x0061, r24
     c26:	83 e0       	ldi	r24, 0x03	; 3
     c28:	80 93 61 00 	sts	0x0061, r24
     c2c:	81 e0       	ldi	r24, 0x01	; 1
     c2e:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     c32:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <USI_SPIOff>
     c36:	80 e0       	ldi	r24, 0x00	; 0
     c38:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
     c3c:	80 91 64 00 	lds	r24, 0x0064
     c40:	84 60       	ori	r24, 0x04	; 4
     c42:	80 93 64 00 	sts	0x0064, r24
     c46:	81 b3       	in	r24, 0x11	; 17
     c48:	8f 7c       	andi	r24, 0xCF	; 207
     c4a:	80 61       	ori	r24, 0x10	; 16
     c4c:	81 bb       	out	0x11, r24	; 17
     c4e:	63 96       	adiw	r28, 0x13	; 19
     c50:	0f b6       	in	r0, 0x3f	; 63
     c52:	f8 94       	cli
     c54:	de bf       	out	0x3e, r29	; 62
     c56:	0f be       	out	0x3f, r0	; 63
     c58:	cd bf       	out	0x3d, r28	; 61
     c5a:	df 91       	pop	r29
     c5c:	cf 91       	pop	r28
     c5e:	1f 91       	pop	r17
     c60:	0f 91       	pop	r16
     c62:	08 95       	ret

00000c64 <main>:
     c64:	1f 93       	push	r17
     c66:	80 e8       	ldi	r24, 0x80	; 128
     c68:	85 bf       	out	0x35, r24	; 53
     c6a:	85 bf       	out	0x35, r24	; 53
     c6c:	80 bf       	out	0x30, r24	; 48
     c6e:	85 e0       	ldi	r24, 0x05	; 5
     c70:	80 93 64 00 	sts	0x0064, r24
     c74:	80 e3       	ldi	r24, 0x30	; 48
     c76:	80 bb       	out	0x10, r24	; 16
     c78:	87 e2       	ldi	r24, 0x27	; 39
     c7a:	84 b9       	out	0x04, r24	; 4
     c7c:	8f ed       	ldi	r24, 0xDF	; 223
     c7e:	85 b9       	out	0x05, r24	; 5
     c80:	8c e0       	ldi	r24, 0x0C	; 12
     c82:	8e b9       	out	0x0e, r24	; 14
     c84:	80 93 6b 00 	sts	0x006B, r24
     c88:	80 ed       	ldi	r24, 0xD0	; 208
     c8a:	80 93 6c 00 	sts	0x006C, r24
     c8e:	80 ec       	ldi	r24, 0xC0	; 192
     c90:	8d bb       	out	0x1d, r24	; 29
     c92:	8c bb       	out	0x1c, r24	; 28
     c94:	81 b3       	in	r24, 0x11	; 17
     c96:	8f 7c       	andi	r24, 0xCF	; 207
     c98:	80 63       	ori	r24, 0x30	; 48
     c9a:	81 bb       	out	0x11, r24	; 17
     c9c:	81 e0       	ldi	r24, 0x01	; 1
     c9e:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     ca2:	0e 94 67 08 	call	0x10ce	; 0x10ce <LCD_Init>
     ca6:	8f e0       	ldi	r24, 0x0F	; 15
     ca8:	80 93 e7 00 	sts	0x00E7, r24
     cac:	87 ea       	ldi	r24, 0xA7	; 167
     cae:	90 e0       	ldi	r25, 0x00	; 0
     cb0:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     cb4:	78 94       	sei
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     cb6:	ad e8       	ldi	r26, 0x8D	; 141
     cb8:	b0 e0       	ldi	r27, 0x00	; 0
     cba:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
     cbe:	80 2d       	mov	r24, r0
     cc0:	8a 37       	cpi	r24, 0x7A	; 122
     cc2:	89 f0       	breq	.+34     	; 0xce6 <main+0x82>
     cc4:	80 e0       	ldi	r24, 0x00	; 0
     cc6:	90 e0       	ldi	r25, 0x00	; 0
     cc8:	2f ef       	ldi	r18, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     cca:	dc 01       	movw	r26, r24
     ccc:	02 2e       	mov	r0, r18
     cce:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
     cd2:	01 96       	adiw	r24, 0x01	; 1
     cd4:	8e 38       	cpi	r24, 0x8E	; 142
     cd6:	91 05       	cpc	r25, r1
     cd8:	c1 f7       	brne	.-16     	; 0xcca <main+0x66>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     cda:	8a e7       	ldi	r24, 0x7A	; 122
     cdc:	ad e8       	ldi	r26, 0x8D	; 141
     cde:	b0 e0       	ldi	r27, 0x00	; 0
     ce0:	08 2e       	mov	r0, r24
     ce2:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
     ce6:	a9 e8       	ldi	r26, 0x89	; 137
     ce8:	b0 e0       	ldi	r27, 0x00	; 0
     cea:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
     cee:	80 2d       	mov	r24, r0
     cf0:	8f 70       	andi	r24, 0x0F	; 15
     cf2:	80 93 e7 00 	sts	0x00E7, r24
     cf6:	80 e0       	ldi	r24, 0x00	; 0
     cf8:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
     cfc:	0e 94 96 09 	call	0x132c	; 0x132c <USART_Init>
     d00:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <OSCCAL_Calibrate>
     d04:	0e 94 40 0c 	call	0x1880	; 0x1880 <TOUT_SetupSleepTimer>
     d08:	81 b3       	in	r24, 0x11	; 17
     d0a:	8f 7c       	andi	r24, 0xCF	; 207
     d0c:	80 61       	ori	r24, 0x10	; 16
     d0e:	81 bb       	out	0x11, r24	; 17
     d10:	81 e0       	ldi	r24, 0x01	; 1
     d12:	8e bb       	out	0x1e, r24	; 30
     d14:	80 e8       	ldi	r24, 0x80	; 128
     d16:	80 93 61 00 	sts	0x0061, r24
     d1a:	83 e0       	ldi	r24, 0x03	; 3
     d1c:	80 93 61 00 	sts	0x0061, r24
     d20:	10 e0       	ldi	r17, 0x00	; 0
     d22:	8e b3       	in	r24, 0x1e	; 30
     d24:	88 23       	and	r24, r24
     d26:	e9 f3       	breq	.-6      	; 0xd22 <main+0xbe>
     d28:	f6 9b       	sbis	0x1e, 6	; 30
     d2a:	06 c0       	rjmp	.+12     	; 0xd38 <main+0xd4>
     d2c:	11 23       	and	r17, r17
     d2e:	11 f4       	brne	.+4      	; 0xd34 <main+0xd0>
     d30:	16 e0       	ldi	r17, 0x06	; 6
     d32:	1b c0       	rjmp	.+54     	; 0xd6a <main+0x106>
     d34:	11 50       	subi	r17, 0x01	; 1
     d36:	19 c0       	rjmp	.+50     	; 0xd6a <main+0x106>
     d38:	f7 9b       	sbis	0x1e, 7	; 30
     d3a:	06 c0       	rjmp	.+12     	; 0xd48 <main+0xe4>
     d3c:	16 30       	cpi	r17, 0x06	; 6
     d3e:	11 f4       	brne	.+4      	; 0xd44 <main+0xe0>
     d40:	10 e0       	ldi	r17, 0x00	; 0
     d42:	13 c0       	rjmp	.+38     	; 0xd6a <main+0x106>
     d44:	1f 5f       	subi	r17, 0xFF	; 255
     d46:	11 c0       	rjmp	.+34     	; 0xd6a <main+0x106>
     d48:	f4 9b       	sbis	0x1e, 4	; 30
     d4a:	0b c0       	rjmp	.+22     	; 0xd62 <main+0xfe>
     d4c:	e1 2f       	mov	r30, r17
     d4e:	ff 27       	eor	r31, r31
     d50:	ee 0f       	add	r30, r30
     d52:	ff 1f       	adc	r31, r31
     d54:	ef 5e       	subi	r30, 0xEF	; 239
     d56:	fe 4f       	sbci	r31, 0xFE	; 254
     d58:	85 91       	lpm	r24, Z+
     d5a:	94 91       	lpm	r25, Z
     d5c:	fc 01       	movw	r30, r24
     d5e:	09 95       	icall
     d60:	04 c0       	rjmp	.+8      	; 0xd6a <main+0x106>
     d62:	f3 9b       	sbis	0x1e, 3	; 30
     d64:	02 c0       	rjmp	.+4      	; 0xd6a <main+0x106>
     d66:	0e 94 ff 02 	call	0x5fe	; 0x5fe <FUNCShowAbout>
     d6a:	e1 2f       	mov	r30, r17
     d6c:	ff 27       	eor	r31, r31
     d6e:	ee 0f       	add	r30, r30
     d70:	ff 1f       	adc	r31, r31
     d72:	ed 5f       	subi	r30, 0xFD	; 253
     d74:	fe 4f       	sbci	r31, 0xFE	; 254
     d76:	85 91       	lpm	r24, Z+
     d78:	94 91       	lpm	r25, Z
     d7a:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     d7e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     d82:	cf cf       	rjmp	.-98     	; 0xd22 <main+0xbe>

00000d84 <FUNCClearMem>:
     d84:	84 eb       	ldi	r24, 0xB4	; 180
     d86:	92 e0       	ldi	r25, 0x02	; 2
     d88:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     d8c:	84 eb       	ldi	r24, 0xB4	; 180
     d8e:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     d92:	8e ea       	ldi	r24, 0xAE	; 174
     d94:	92 e0       	ldi	r25, 0x02	; 2
     d96:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     d9a:	8e b3       	in	r24, 0x1e	; 30
     d9c:	88 23       	and	r24, r24
     d9e:	e9 f3       	breq	.-6      	; 0xd9a <FUNCClearMem+0x16>
     da0:	f2 99       	sbic	0x1e, 2	; 30
     da2:	22 c0       	rjmp	.+68     	; 0xde8 <FUNCClearMem+0x64>
     da4:	f3 9b       	sbis	0x1e, 3	; 30
     da6:	f9 cf       	rjmp	.-14     	; 0xd9a <FUNCClearMem+0x16>
     da8:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     dac:	87 ea       	ldi	r24, 0xA7	; 167
     dae:	90 e0       	ldi	r25, 0x00	; 0
     db0:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     db4:	81 b3       	in	r24, 0x11	; 17
     db6:	8f 7c       	andi	r24, 0xCF	; 207
     db8:	80 63       	ori	r24, 0x30	; 48
     dba:	81 bb       	out	0x11, r24	; 17
     dbc:	80 e0       	ldi	r24, 0x00	; 0
     dbe:	90 e0       	ldi	r25, 0x00	; 0
     dc0:	2f ef       	ldi	r18, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     dc2:	dc 01       	movw	r26, r24
     dc4:	02 2e       	mov	r0, r18
     dc6:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
     dca:	01 96       	adiw	r24, 0x01	; 1
     dcc:	8e 38       	cpi	r24, 0x8E	; 142
     dce:	91 05       	cpc	r25, r1
     dd0:	c1 f7       	brne	.-16     	; 0xdc2 <FUNCClearMem+0x3e>
     dd2:	81 b3       	in	r24, 0x11	; 17
     dd4:	8f 7c       	andi	r24, 0xCF	; 207
     dd6:	80 61       	ori	r24, 0x10	; 16
     dd8:	81 bb       	out	0x11, r24	; 17
     dda:	82 ea       	ldi	r24, 0xA2	; 162
     ddc:	92 e0       	ldi	r25, 0x02	; 2
     dde:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     de2:	8a ef       	ldi	r24, 0xFA	; 250
     de4:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     de8:	08 95       	ret

00000dea <FUNCSetContrast>:
     dea:	1f 93       	push	r17
     dec:	cf 93       	push	r28
     dee:	df 93       	push	r29
     df0:	cd b7       	in	r28, 0x3d	; 61
     df2:	de b7       	in	r29, 0x3e	; 62
     df4:	26 97       	sbiw	r28, 0x06	; 6
     df6:	0f b6       	in	r0, 0x3f	; 63
     df8:	f8 94       	cli
     dfa:	de bf       	out	0x3e, r29	; 62
     dfc:	0f be       	out	0x3f, r0	; 63
     dfe:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     e00:	a9 e8       	ldi	r26, 0x89	; 137
     e02:	b0 e0       	ldi	r27, 0x00	; 0
     e04:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
     e08:	80 2d       	mov	r24, r0
     e0a:	18 2f       	mov	r17, r24
     e0c:	1f 70       	andi	r17, 0x0F	; 15
     e0e:	81 e0       	ldi	r24, 0x01	; 1
     e10:	8e bb       	out	0x1e, r24	; 30
     e12:	8e b3       	in	r24, 0x1e	; 30
     e14:	88 23       	and	r24, r24
     e16:	e9 f3       	breq	.-6      	; 0xe12 <FUNCSetContrast+0x28>
     e18:	f6 9b       	sbis	0x1e, 6	; 30
     e1a:	04 c0       	rjmp	.+8      	; 0xe24 <FUNCSetContrast+0x3a>
     e1c:	1f 30       	cpi	r17, 0x0F	; 15
     e1e:	50 f4       	brcc	.+20     	; 0xe34 <FUNCSetContrast+0x4a>
     e20:	1f 5f       	subi	r17, 0xFF	; 255
     e22:	08 c0       	rjmp	.+16     	; 0xe34 <FUNCSetContrast+0x4a>
     e24:	f7 9b       	sbis	0x1e, 7	; 30
     e26:	04 c0       	rjmp	.+8      	; 0xe30 <FUNCSetContrast+0x46>
     e28:	12 30       	cpi	r17, 0x02	; 2
     e2a:	20 f0       	brcs	.+8      	; 0xe34 <FUNCSetContrast+0x4a>
     e2c:	11 50       	subi	r17, 0x01	; 1
     e2e:	02 c0       	rjmp	.+4      	; 0xe34 <FUNCSetContrast+0x4a>
     e30:	f2 99       	sbic	0x1e, 2	; 30
     e32:	18 c0       	rjmp	.+48     	; 0xe64 <FUNCSetContrast+0x7a>
     e34:	83 e4       	ldi	r24, 0x43	; 67
     e36:	89 83       	std	Y+1, r24	; 0x01
     e38:	84 e5       	ldi	r24, 0x54	; 84
     e3a:	8a 83       	std	Y+2, r24	; 0x02
     e3c:	80 e2       	ldi	r24, 0x20	; 32
     e3e:	8b 83       	std	Y+3, r24	; 0x03
     e40:	be 01       	movw	r22, r28
     e42:	6c 5f       	subi	r22, 0xFC	; 252
     e44:	7f 4f       	sbci	r23, 0xFF	; 255
     e46:	81 2f       	mov	r24, r17
     e48:	99 27       	eor	r25, r25
     e4a:	0e 94 97 02 	call	0x52e	; 0x52e <MAIN_IntToStr>
     e4e:	ce 01       	movw	r24, r28
     e50:	01 96       	adiw	r24, 0x01	; 1
     e52:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
     e56:	81 2f       	mov	r24, r17
     e58:	8f 70       	andi	r24, 0x0F	; 15
     e5a:	80 93 e7 00 	sts	0x00E7, r24
     e5e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     e62:	d7 cf       	rjmp	.-82     	; 0xe12 <FUNCSetContrast+0x28>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     e64:	a9 e8       	ldi	r26, 0x89	; 137
     e66:	b0 e0       	ldi	r27, 0x00	; 0
     e68:	01 2e       	mov	r0, r17
     e6a:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
     e6e:	26 96       	adiw	r28, 0x06	; 6
     e70:	0f b6       	in	r0, 0x3f	; 63
     e72:	f8 94       	cli
     e74:	de bf       	out	0x3e, r29	; 62
     e76:	0f be       	out	0x3f, r0	; 63
     e78:	cd bf       	out	0x3d, r28	; 61
     e7a:	df 91       	pop	r29
     e7c:	cf 91       	pop	r28
     e7e:	1f 91       	pop	r17
     e80:	08 95       	ret

00000e82 <FUNCSetISPSpeed>:
     e82:	1f 93       	push	r17
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     e84:	a2 e0       	ldi	r26, 0x02	; 2
     e86:	b0 e0       	ldi	r27, 0x00	; 0
     e88:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
     e8c:	80 2d       	mov	r24, r0
     e8e:	18 2f       	mov	r17, r24
     e90:	84 30       	cpi	r24, 0x04	; 4
     e92:	08 f0       	brcs	.+2      	; 0xe96 <FUNCSetISPSpeed+0x14>
     e94:	13 e0       	ldi	r17, 0x03	; 3
     e96:	81 e0       	ldi	r24, 0x01	; 1
     e98:	8e bb       	out	0x1e, r24	; 30
     e9a:	8e b3       	in	r24, 0x1e	; 30
     e9c:	88 23       	and	r24, r24
     e9e:	e9 f3       	breq	.-6      	; 0xe9a <FUNCSetISPSpeed+0x18>
     ea0:	f6 9b       	sbis	0x1e, 6	; 30
     ea2:	06 c0       	rjmp	.+12     	; 0xeb0 <FUNCSetISPSpeed+0x2e>
     ea4:	11 23       	and	r17, r17
     ea6:	11 f4       	brne	.+4      	; 0xeac <FUNCSetISPSpeed+0x2a>
     ea8:	13 e0       	ldi	r17, 0x03	; 3
     eaa:	0c c0       	rjmp	.+24     	; 0xec4 <FUNCSetISPSpeed+0x42>
     eac:	11 50       	subi	r17, 0x01	; 1
     eae:	0a c0       	rjmp	.+20     	; 0xec4 <FUNCSetISPSpeed+0x42>
     eb0:	f7 9b       	sbis	0x1e, 7	; 30
     eb2:	04 c0       	rjmp	.+8      	; 0xebc <FUNCSetISPSpeed+0x3a>
     eb4:	13 30       	cpi	r17, 0x03	; 3
     eb6:	29 f0       	breq	.+10     	; 0xec2 <FUNCSetISPSpeed+0x40>
     eb8:	1f 5f       	subi	r17, 0xFF	; 255
     eba:	04 c0       	rjmp	.+8      	; 0xec4 <FUNCSetISPSpeed+0x42>
     ebc:	f2 9b       	sbis	0x1e, 2	; 30
     ebe:	02 c0       	rjmp	.+4      	; 0xec4 <FUNCSetISPSpeed+0x42>
     ec0:	0c c0       	rjmp	.+24     	; 0xeda <FUNCSetISPSpeed+0x58>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     ec2:	10 e0       	ldi	r17, 0x00	; 0
     ec4:	8a e0       	ldi	r24, 0x0A	; 10
     ec6:	18 9f       	mul	r17, r24
     ec8:	c0 01       	movw	r24, r0
     eca:	11 24       	eor	r1, r1
     ecc:	8a 5d       	subi	r24, 0xDA	; 218
     ece:	9d 4f       	sbci	r25, 0xFD	; 253
     ed0:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     ed4:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     ed8:	e0 cf       	rjmp	.-64     	; 0xe9a <FUNCSetISPSpeed+0x18>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     eda:	a2 e0       	ldi	r26, 0x02	; 2
     edc:	b0 e0       	ldi	r27, 0x00	; 0
     ede:	01 2e       	mov	r0, r17
     ee0:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
     ee4:	1f 91       	pop	r17
     ee6:	08 95       	ret

00000ee8 <FUNCSetResetMode>:
     ee8:	1f 93       	push	r17
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     eea:	ac e8       	ldi	r26, 0x8C	; 140
     eec:	b0 e0       	ldi	r27, 0x00	; 0
     eee:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
     ef2:	80 2d       	mov	r24, r0
     ef4:	18 2f       	mov	r17, r24
     ef6:	11 70       	andi	r17, 0x01	; 1
     ef8:	81 e0       	ldi	r24, 0x01	; 1
     efa:	8e bb       	out	0x1e, r24	; 30
     efc:	8e b3       	in	r24, 0x1e	; 30
     efe:	88 23       	and	r24, r24
     f00:	e9 f3       	breq	.-6      	; 0xefc <FUNCSetResetMode+0x14>
     f02:	f6 99       	sbic	0x1e, 6	; 30
     f04:	02 c0       	rjmp	.+4      	; 0xf0a <FUNCSetResetMode+0x22>
     f06:	f7 9b       	sbis	0x1e, 7	; 30
     f08:	03 c0       	rjmp	.+6      	; 0xf10 <FUNCSetResetMode+0x28>
     f0a:	81 e0       	ldi	r24, 0x01	; 1
     f0c:	18 27       	eor	r17, r24
     f0e:	02 c0       	rjmp	.+4      	; 0xf14 <FUNCSetResetMode+0x2c>
     f10:	f2 99       	sbic	0x1e, 2	; 30
     f12:	0b c0       	rjmp	.+22     	; 0xf2a <FUNCSetResetMode+0x42>
     f14:	86 e0       	ldi	r24, 0x06	; 6
     f16:	18 9f       	mul	r17, r24
     f18:	c0 01       	movw	r24, r0
     f1a:	11 24       	eor	r1, r1
     f1c:	82 5b       	subi	r24, 0xB2	; 178
     f1e:	9d 4f       	sbci	r25, 0xFD	; 253
     f20:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     f24:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     f28:	e9 cf       	rjmp	.-46     	; 0xefc <FUNCSetResetMode+0x14>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     f2a:	ac e8       	ldi	r26, 0x8C	; 140
     f2c:	b0 e0       	ldi	r27, 0x00	; 0
     f2e:	01 2e       	mov	r0, r17
     f30:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
     f34:	1f 91       	pop	r17
     f36:	08 95       	ret

00000f38 <FUNCSetFirmMinorVer>:
     f38:	1f 93       	push	r17
     f3a:	cf 93       	push	r28
     f3c:	df 93       	push	r29
     f3e:	cd b7       	in	r28, 0x3d	; 61
     f40:	de b7       	in	r29, 0x3e	; 62
     f42:	25 97       	sbiw	r28, 0x05	; 5
     f44:	0f b6       	in	r0, 0x3f	; 63
     f46:	f8 94       	cli
     f48:	de bf       	out	0x3e, r29	; 62
     f4a:	0f be       	out	0x3f, r0	; 63
     f4c:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     f4e:	aa e8       	ldi	r26, 0x8A	; 138
     f50:	b0 e0       	ldi	r27, 0x00	; 0
     f52:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
     f56:	80 2d       	mov	r24, r0
     f58:	18 2f       	mov	r17, r24
     f5a:	8a 30       	cpi	r24, 0x0A	; 10
     f5c:	08 f0       	brcs	.+2      	; 0xf60 <FUNCSetFirmMinorVer+0x28>
     f5e:	14 e0       	ldi	r17, 0x04	; 4
     f60:	6d e9       	ldi	r22, 0x9D	; 157
     f62:	72 e0       	ldi	r23, 0x02	; 2
     f64:	ce 01       	movw	r24, r28
     f66:	01 96       	adiw	r24, 0x01	; 1
     f68:	0e 94 51 1a 	call	0x34a2	; 0x34a2 <strcpy_P>
     f6c:	81 e0       	ldi	r24, 0x01	; 1
     f6e:	8e bb       	out	0x1e, r24	; 30
     f70:	8e b3       	in	r24, 0x1e	; 30
     f72:	88 23       	and	r24, r24
     f74:	e9 f3       	breq	.-6      	; 0xf70 <FUNCSetFirmMinorVer+0x38>
     f76:	f6 9b       	sbis	0x1e, 6	; 30
     f78:	03 c0       	rjmp	.+6      	; 0xf80 <FUNCSetFirmMinorVer+0x48>
     f7a:	19 30       	cpi	r17, 0x09	; 9
     f7c:	08 f4       	brcc	.+2      	; 0xf80 <FUNCSetFirmMinorVer+0x48>
     f7e:	1f 5f       	subi	r17, 0xFF	; 255
     f80:	f7 9b       	sbis	0x1e, 7	; 30
     f82:	04 c0       	rjmp	.+8      	; 0xf8c <FUNCSetFirmMinorVer+0x54>
     f84:	11 23       	and	r17, r17
     f86:	21 f0       	breq	.+8      	; 0xf90 <FUNCSetFirmMinorVer+0x58>
     f88:	11 50       	subi	r17, 0x01	; 1
     f8a:	02 c0       	rjmp	.+4      	; 0xf90 <FUNCSetFirmMinorVer+0x58>
     f8c:	f2 99       	sbic	0x1e, 2	; 30
     f8e:	0a c0       	rjmp	.+20     	; 0xfa4 <FUNCSetFirmMinorVer+0x6c>
     f90:	10 5d       	subi	r17, 0xD0	; 208
     f92:	1c 83       	std	Y+4, r17	; 0x04
     f94:	10 53       	subi	r17, 0x30	; 48
     f96:	ce 01       	movw	r24, r28
     f98:	01 96       	adiw	r24, 0x01	; 1
     f9a:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
     f9e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     fa2:	e6 cf       	rjmp	.-52     	; 0xf70 <FUNCSetFirmMinorVer+0x38>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     fa4:	aa e8       	ldi	r26, 0x8A	; 138
     fa6:	b0 e0       	ldi	r27, 0x00	; 0
     fa8:	01 2e       	mov	r0, r17
     faa:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
     fae:	25 96       	adiw	r28, 0x05	; 5
     fb0:	0f b6       	in	r0, 0x3f	; 63
     fb2:	f8 94       	cli
     fb4:	de bf       	out	0x3e, r29	; 62
     fb6:	0f be       	out	0x3f, r0	; 63
     fb8:	cd bf       	out	0x3d, r28	; 61
     fba:	df 91       	pop	r29
     fbc:	cf 91       	pop	r28
     fbe:	1f 91       	pop	r17
     fc0:	08 95       	ret

00000fc2 <OSCCAL_Calibrate>:

volatile uint16_t ActualCount = 0;

void OSCCAL_Calibrate(void)
{
     fc2:	10 92 05 01 	sts	0x0105, r1
     fc6:	10 92 04 01 	sts	0x0104, r1
	uint8_t SREG_Backup;
	uint8_t LoopCount = (0x7F / 2); // Maximum range is 128, and starts from the middle, so 64 is the max number of iterations required
	uint8_t PrevOSCALValues[2];
   
	// Reset ActualCount
	ActualCount = 0;
   
	// Make sure all clock division is turned off (8Mhz RC clock)
	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_BASECLOCKSPEED_8MHZ);
     fca:	80 e8       	ldi	r24, 0x80	; 128
     fcc:	80 93 61 00 	sts	0x0061, r24
     fd0:	10 92 61 00 	sts	0x0061, r1

	// Inital OSCCAL of half its maximum
	OSCCAL = (0x7F / 2);
     fd4:	8f e3       	ldi	r24, 0x3F	; 63
     fd6:	80 93 66 00 	sts	0x0066, r24

	// Save the SREG
	SREG_Backup = SREG;
     fda:	5f b7       	in	r21, 0x3f	; 63
    
	// Disable all timer 1 interrupts
	TIMSK1 = 0;
     fdc:	10 92 6f 00 	sts	0x006F, r1
        
	// Set timer 2 to asyncronous mode (32.768KHz crystal)
	ASSR   = (1 << AS2);
     fe0:	88 e0       	ldi	r24, 0x08	; 8
     fe2:	80 93 b6 00 	sts	0x00B6, r24
        
	// Timer 2 overflow interrupt enable
	TIMSK2 = (1 << TOIE2);
     fe6:	81 e0       	ldi	r24, 0x01	; 1
     fe8:	80 93 70 00 	sts	0x0070, r24

	// Enable interrupts
	sei();
     fec:	78 94       	sei

	// Start both counters with no prescaling
	TCCR1B = (1 << CS10);
     fee:	80 93 81 00 	sts	0x0081, r24
	TCCR2A = (1 << CS20);
     ff2:	80 93 b0 00 	sts	0x00B0, r24
	 	 
	// Previous OSCCAL value of 0
	PrevOSCALValues[0] = 0;

	// Wait until timer 2's external 32.768KHz crystal is stable
	while (ASSR & ((1 << TCN2UB) | (1 << TCR2UB) | (1 << OCR2UB)));
     ff6:	80 91 b6 00 	lds	r24, 0x00B6
     ffa:	99 27       	eor	r25, r25
     ffc:	87 70       	andi	r24, 0x07	; 7
     ffe:	90 70       	andi	r25, 0x00	; 0
    1000:	89 2b       	or	r24, r25
    1002:	c9 f7       	brne	.-14     	; 0xff6 <OSCCAL_Calibrate+0x34>
    
	// Clear the timer values
	TCNT1  = 0;
    1004:	10 92 85 00 	sts	0x0085, r1
    1008:	10 92 84 00 	sts	0x0084, r1
	TCNT2  = 0;
    100c:	10 92 b2 00 	sts	0x00B2, r1
    1010:	2e e3       	ldi	r18, 0x3E	; 62
    1012:	40 e0       	ldi	r20, 0x00	; 0
    1014:	ec ec       	ldi	r30, 0xCC	; 204
    1016:	f4 e6       	ldi	r31, 0x64	; 100
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1018:	cf 01       	movw	r24, r30
    101a:	01 97       	sbiw	r24, 0x01	; 1
    101c:	f1 f7       	brne	.-4      	; 0x101a <OSCCAL_Calibrate+0x58>
    
	while (LoopCount--)
	{
		// Let it take a few readings (14ms, approx 2 readings)
		_delay_ms(14);

		PrevOSCALValues[1] = PrevOSCALValues[0];
		PrevOSCALValues[0] = OSCCAL;
    101e:	30 91 66 00 	lds	r19, 0x0066
        
		if (ActualCount > OSCCAL_TARGETCOUNT)       // Clock is running too fast
    1022:	80 91 04 01 	lds	r24, 0x0104
    1026:	90 91 05 01 	lds	r25, 0x0105
    102a:	81 50       	subi	r24, 0x01	; 1
    102c:	91 4e       	sbci	r25, 0xE1	; 225
    102e:	20 f0       	brcs	.+8      	; 0x1038 <OSCCAL_Calibrate+0x76>
			OSCCAL--;
    1030:	80 91 66 00 	lds	r24, 0x0066
    1034:	81 50       	subi	r24, 0x01	; 1
    1036:	0a c0       	rjmp	.+20     	; 0x104c <OSCCAL_Calibrate+0x8a>
		else if (ActualCount < OSCCAL_TARGETCOUNT) // Clock is running too slow
    1038:	80 91 04 01 	lds	r24, 0x0104
    103c:	90 91 05 01 	lds	r25, 0x0105
    1040:	80 50       	subi	r24, 0x00	; 0
    1042:	91 4e       	sbci	r25, 0xE1	; 225
    1044:	28 f4       	brcc	.+10     	; 0x1050 <OSCCAL_Calibrate+0x8e>
			OSCCAL++;
    1046:	80 91 66 00 	lds	r24, 0x0066
    104a:	8f 5f       	subi	r24, 0xFF	; 255
    104c:	80 93 66 00 	sts	0x0066, r24
		
		// When the routine finds the closest value for the given target count,
		// it will cause the OSCCAL to hover around the closest two values.
		// If the current value is the same as two loops previous, exit the
		// routine as the best value has been found.
		if (OSCCAL == PrevOSCALValues[1])
    1050:	80 91 66 00 	lds	r24, 0x0066
    1054:	84 17       	cp	r24, r20
    1056:	29 f0       	breq	.+10     	; 0x1062 <OSCCAL_Calibrate+0xa0>
    1058:	21 50       	subi	r18, 0x01	; 1
    105a:	2f 3f       	cpi	r18, 0xFF	; 255
    105c:	11 f0       	breq	.+4      	; 0x1062 <OSCCAL_Calibrate+0xa0>
    105e:	43 2f       	mov	r20, r19
    1060:	db cf       	rjmp	.-74     	; 0x1018 <OSCCAL_Calibrate+0x56>
		  break;
	}

	// Disable all timer interrupts
	TIMSK1 = 0;
    1062:	10 92 6f 00 	sts	0x006F, r1
	TIMSK2 = 0;
    1066:	10 92 70 00 	sts	0x0070, r1
    
	// Stop the timers
	TCCR1B = 0x00;
    106a:	10 92 81 00 	sts	0x0081, r1
	TCCR2A = 0x00;
    106e:	10 92 b0 00 	sts	0x00B0, r1

	// Turn off timer 2 asynchronous mode
	ASSR  &= ~(1 << AS2);
    1072:	80 91 b6 00 	lds	r24, 0x00B6
    1076:	87 7f       	andi	r24, 0xF7	; 247
    1078:	80 93 b6 00 	sts	0x00B6, r24

	// Restore SREG
	SREG = SREG_Backup;
    107c:	5f bf       	out	0x3f, r21	; 63
    107e:	08 95       	ret

00001080 <__vector_5>:
        
	return;
}

ISR(TIMER2_OVF_vect, ISR_BLOCK) // Occurs 32768/256 timers per second, or 128Hz
{
    1080:	1f 92       	push	r1
    1082:	0f 92       	push	r0
    1084:	0f b6       	in	r0, 0x3f	; 63
    1086:	0f 92       	push	r0
    1088:	11 24       	eor	r1, r1
    108a:	8f 93       	push	r24
    108c:	9f 93       	push	r25
    108e:	af 93       	push	r26
    1090:	bf 93       	push	r27
    1092:	ef 93       	push	r30
    1094:	ff 93       	push	r31
	// Stop timer 1 so it can be read
	TCCR1B = 0x00;
    1096:	a1 e8       	ldi	r26, 0x81	; 129
    1098:	b0 e0       	ldi	r27, 0x00	; 0
    109a:	1c 92       	st	X, r1
    
	// Record timer 1's value
	ActualCount = TCNT1;
    109c:	e4 e8       	ldi	r30, 0x84	; 132
    109e:	f0 e0       	ldi	r31, 0x00	; 0
    10a0:	80 81       	ld	r24, Z
    10a2:	91 81       	ldd	r25, Z+1	; 0x01
    10a4:	90 93 05 01 	sts	0x0105, r25
    10a8:	80 93 04 01 	sts	0x0104, r24
	     
	// Reset counters and restart timer 1
	TCNT1  = 0;
    10ac:	11 82       	std	Z+1, r1	; 0x01
    10ae:	10 82       	st	Z, r1
	TCNT2  = 0;
    10b0:	10 92 b2 00 	sts	0x00B2, r1
	TCCR1B = (1 << CS10);
    10b4:	81 e0       	ldi	r24, 0x01	; 1
    10b6:	8c 93       	st	X, r24
    10b8:	ff 91       	pop	r31
    10ba:	ef 91       	pop	r30
    10bc:	bf 91       	pop	r27
    10be:	af 91       	pop	r26
    10c0:	9f 91       	pop	r25
    10c2:	8f 91       	pop	r24
    10c4:	0f 90       	pop	r0
    10c6:	0f be       	out	0x3f, r0	; 63
    10c8:	0f 90       	pop	r0
    10ca:	1f 90       	pop	r1
    10cc:	18 95       	reti

000010ce <LCD_Init>:

// ======================================================================================

void LCD_Init(void)
{
    10ce:	8f e0       	ldi	r24, 0x0F	; 15
    10d0:	80 93 e7 00 	sts	0x00E7, r24
	// Set the initial contrast level to maximum:
	LCDCCR = 0x0F;

    // Select asynchronous clock source, enable all COM pins and enable all segment pins:
    LCDCRB  = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
    10d4:	87 eb       	ldi	r24, 0xB7	; 183
    10d6:	80 93 e5 00 	sts	0x00E5, r24

    // Set LCD prescaler to give a framerate of 32Hz:
    LCDFRR  = (7<<LCDCD0);    
    10da:	87 e0       	ldi	r24, 0x07	; 7
    10dc:	80 93 e6 00 	sts	0x00E6, r24

	// Enable LCD and set low power waveform, enable start of frame interrupt:
    LCDCRA  = (1<<LCDEN) | (1<<LCDAB) | (1<<LCDIE);
    10e0:	88 ec       	ldi	r24, 0xC8	; 200
    10e2:	80 93 e4 00 	sts	0x00E4, r24
    10e6:	08 95       	ret

000010e8 <LCD_puts>:
}

void LCD_puts_f(const uint8_t *FlashData)
{
	uint8_t StrBuff[LCD_TEXTBUFFER_SIZE];

	strcpy_P(StrBuff, FlashData);
	LCD_puts(StrBuff);
}

void LCD_puts(const uint8_t *Data)
{
    10e8:	fc 01       	movw	r30, r24
    10ea:	ac e0       	ldi	r26, 0x0C	; 12
    10ec:	b1 e0       	ldi	r27, 0x01	; 1
    10ee:	38 2f       	mov	r19, r24
    10f0:	4f ef       	ldi	r20, 0xFF	; 255
    10f2:	2e 2f       	mov	r18, r30
    10f4:	23 1b       	sub	r18, r19
	uint8_t LoadB;
	
	for (LoadB = 0; LoadB < 20; LoadB++)
	{
		uint8_t CByte = *(Data++);
    10f6:	91 91       	ld	r25, Z+
	
		if ((CByte >= '*') && (CByte <= 'z') && (CByte != ' '))
    10f8:	89 2f       	mov	r24, r25
    10fa:	8a 52       	subi	r24, 0x2A	; 42
    10fc:	81 35       	cpi	r24, 0x51	; 81
    10fe:	10 f4       	brcc	.+4      	; 0x1104 <LCD_puts+0x1c>
		  TextBuffer[LoadB] = (CByte - '*');
    1100:	8c 93       	st	X, r24
    1102:	03 c0       	rjmp	.+6      	; 0x110a <LCD_puts+0x22>
		else if (CByte == 0x00)
    1104:	99 23       	and	r25, r25
    1106:	41 f0       	breq	.+16     	; 0x1118 <LCD_puts+0x30>
		  break;
		else
		  TextBuffer[LoadB] = 0xFF;		
    1108:	4c 93       	st	X, r20
    110a:	2e 2f       	mov	r18, r30
    110c:	23 1b       	sub	r18, r19
    110e:	11 96       	adiw	r26, 0x01	; 1
    1110:	81 e0       	ldi	r24, 0x01	; 1
    1112:	a0 32       	cpi	r26, 0x20	; 32
    1114:	b8 07       	cpc	r27, r24
    1116:	69 f7       	brne	.-38     	; 0x10f2 <LCD_puts+0xa>
	}

	ScrollMode  = ((LoadB > 6)? TRUE : FALSE);
    1118:	10 92 06 01 	sts	0x0106, r1
    111c:	27 30       	cpi	r18, 0x07	; 7
    111e:	18 f0       	brcs	.+6      	; 0x1126 <LCD_puts+0x3e>
    1120:	81 e0       	ldi	r24, 0x01	; 1
    1122:	80 93 06 01 	sts	0x0106, r24
	ScrollCount = 0;
    1126:	10 92 08 01 	sts	0x0108, r1
    112a:	82 2f       	mov	r24, r18
    112c:	90 e0       	ldi	r25, 0x00	; 0
    112e:	3f ef       	ldi	r19, 0xFF	; 255

	for (uint8_t Nulls = 0; Nulls < 7; Nulls++)
		TextBuffer[LoadB++] = 0xFF;
    1130:	e8 2f       	mov	r30, r24
    1132:	ff 27       	eor	r31, r31
    1134:	e4 5f       	subi	r30, 0xF4	; 244
    1136:	fe 4f       	sbci	r31, 0xFE	; 254
    1138:	30 83       	st	Z, r19
    113a:	8f 5f       	subi	r24, 0xFF	; 255
    113c:	9f 5f       	subi	r25, 0xFF	; 255
    113e:	97 30       	cpi	r25, 0x07	; 7
    1140:	b9 f7       	brne	.-18     	; 0x1130 <LCD_puts+0x48>
    1142:	82 2f       	mov	r24, r18
    1144:	89 5f       	subi	r24, 0xF9	; 249
	
	TextBuffer[LoadB] = 0x00;
    1146:	e8 2f       	mov	r30, r24
    1148:	ff 27       	eor	r31, r31
    114a:	e4 5f       	subi	r30, 0xF4	; 244
    114c:	fe 4f       	sbci	r31, 0xFE	; 254
    114e:	10 82       	st	Z, r1
	StrStart   = 0;
    1150:	10 92 0a 01 	sts	0x010A, r1
	StrEnd     = LoadB;	
    1154:	80 93 0b 01 	sts	0x010B, r24
	DelayCount = LCD_DELAYCOUNT_DEFAULT;
    1158:	8a e0       	ldi	r24, 0x0A	; 10
    115a:	80 93 07 01 	sts	0x0107, r24

	UpdateLCD  = TRUE;
    115e:	81 e0       	ldi	r24, 0x01	; 1
    1160:	80 93 09 01 	sts	0x0109, r24
    1164:	08 95       	ret

00001166 <LCD_WriteChar>:
}

void LCD_WriteChar(const uint8_t Byte, const uint8_t Digit)
{
    1166:	8f 3f       	cpi	r24, 0xFF	; 255
    1168:	19 f4       	brne	.+6      	; 0x1170 <LCD_WriteChar+0xa>
	uint16_t SegData  = 0x00;
	uint8_t  *BuffPtr = (&SegBuffer[0] + (Digit >> 1));

	if (Byte != 0xFF)
    116a:	40 e0       	ldi	r20, 0x00	; 0
    116c:	50 e0       	ldi	r21, 0x00	; 0
    116e:	08 c0       	rjmp	.+16     	; 0x1180 <LCD_WriteChar+0x1a>
	  SegData = pgm_read_word(&LCD_SegTable[Byte]);	
    1170:	e8 2f       	mov	r30, r24
    1172:	ff 27       	eor	r31, r31
    1174:	ee 0f       	add	r30, r30
    1176:	ff 1f       	adc	r31, r31
    1178:	e4 5d       	subi	r30, 0xD4	; 212
    117a:	fc 4f       	sbci	r31, 0xFC	; 252
    117c:	45 91       	lpm	r20, Z+
    117e:	54 91       	lpm	r21, Z
    1180:	86 2f       	mov	r24, r22
    1182:	86 95       	lsr	r24
    1184:	e8 2f       	mov	r30, r24
    1186:	ff 27       	eor	r31, r31
    1188:	e9 5d       	subi	r30, 0xD9	; 217
    118a:	fe 4f       	sbci	r31, 0xFE	; 254
    118c:	30 e0       	ldi	r19, 0x00	; 0
    118e:	77 27       	eor	r23, r23
    1190:	61 70       	andi	r22, 0x01	; 1
    1192:	70 70       	andi	r23, 0x00	; 0

	for (uint8_t BNib = 0; BNib < 4; BNib++)
	{
		uint8_t Mask          = 0xF0;
		uint8_t MaskedSegData = (SegData & 0x0000F);
    1194:	24 2f       	mov	r18, r20
    1196:	2f 70       	andi	r18, 0x0F	; 15
	
		if (Digit & 0x01)
    1198:	61 15       	cp	r22, r1
    119a:	71 05       	cpc	r23, r1
    119c:	11 f4       	brne	.+4      	; 0x11a2 <LCD_WriteChar+0x3c>
    119e:	90 ef       	ldi	r25, 0xF0	; 240
    11a0:	03 c0       	rjmp	.+6      	; 0x11a8 <LCD_WriteChar+0x42>
		{
			Mask = 0x0F;
			MaskedSegData <<= 4;
    11a2:	22 95       	swap	r18
    11a4:	20 7f       	andi	r18, 0xF0	; 240
    11a6:	9f e0       	ldi	r25, 0x0F	; 15
		}
		
		*BuffPtr = ((*BuffPtr & Mask) | MaskedSegData);
    11a8:	80 81       	ld	r24, Z
    11aa:	98 23       	and	r25, r24
    11ac:	92 2b       	or	r25, r18
    11ae:	90 83       	st	Z, r25
    11b0:	3f 5f       	subi	r19, 0xFF	; 255
    11b2:	34 30       	cpi	r19, 0x04	; 4
    11b4:	39 f0       	breq	.+14     	; 0x11c4 <LCD_WriteChar+0x5e>

		SegData >>= 4;
    11b6:	84 e0       	ldi	r24, 0x04	; 4
    11b8:	56 95       	lsr	r21
    11ba:	47 95       	ror	r20
    11bc:	8a 95       	dec	r24
    11be:	e1 f7       	brne	.-8      	; 0x11b8 <LCD_WriteChar+0x52>
		BuffPtr  += 5;
    11c0:	35 96       	adiw	r30, 0x05	; 5
    11c2:	e8 cf       	rjmp	.-48     	; 0x1194 <LCD_WriteChar+0x2e>
    11c4:	08 95       	ret

000011c6 <__vector_22>:
	}
}

ISR(LCD_vect, ISR_NOBLOCK)
{
    11c6:	78 94       	sei
    11c8:	1f 92       	push	r1
    11ca:	0f 92       	push	r0
    11cc:	0f b6       	in	r0, 0x3f	; 63
    11ce:	0f 92       	push	r0
    11d0:	11 24       	eor	r1, r1
    11d2:	cf 92       	push	r12
    11d4:	df 92       	push	r13
    11d6:	ff 92       	push	r15
    11d8:	0f 93       	push	r16
    11da:	1f 93       	push	r17
    11dc:	2f 93       	push	r18
    11de:	3f 93       	push	r19
    11e0:	4f 93       	push	r20
    11e2:	5f 93       	push	r21
    11e4:	6f 93       	push	r22
    11e6:	7f 93       	push	r23
    11e8:	8f 93       	push	r24
    11ea:	9f 93       	push	r25
    11ec:	af 93       	push	r26
    11ee:	bf 93       	push	r27
    11f0:	cf 93       	push	r28
    11f2:	df 93       	push	r29
    11f4:	ef 93       	push	r30
    11f6:	ff 93       	push	r31
	if (ScrollMode)
    11f8:	80 91 06 01 	lds	r24, 0x0106
    11fc:	88 23       	and	r24, r24
    11fe:	99 f0       	breq	.+38     	; 0x1226 <__vector_22+0x60>
	{
		if (DelayCount)
    1200:	80 91 07 01 	lds	r24, 0x0107
    1204:	88 23       	and	r24, r24
    1206:	21 f0       	breq	.+8      	; 0x1210 <__vector_22+0x4a>
		{
			DelayCount--;
    1208:	81 50       	subi	r24, 0x01	; 1
    120a:	80 93 07 01 	sts	0x0107, r24
    120e:	0b c0       	rjmp	.+22     	; 0x1226 <__vector_22+0x60>
		}
		else
		{
			if (!(ScrollCount--))
    1210:	80 91 08 01 	lds	r24, 0x0108
    1214:	81 50       	subi	r24, 0x01	; 1
    1216:	80 93 08 01 	sts	0x0108, r24
    121a:	8f 3f       	cpi	r24, 0xFF	; 255
    121c:	21 f4       	brne	.+8      	; 0x1226 <__vector_22+0x60>
			  UpdateLCD = TRUE;
    121e:	81 e0       	ldi	r24, 0x01	; 1
    1220:	80 93 09 01 	sts	0x0109, r24
    1224:	04 c0       	rjmp	.+8      	; 0x122e <__vector_22+0x68>
		}
	}

	if (UpdateLCD)
    1226:	80 91 09 01 	lds	r24, 0x0109
    122a:	88 23       	and	r24, r24
    122c:	41 f1       	breq	.+80     	; 0x127e <__vector_22+0xb8>
	{
		for (uint8_t Character = 0; Character < 6; Character++)
		{
			uint8_t Byte = (StrStart + Character);
    122e:	10 91 0a 01 	lds	r17, 0x010A

			if (Byte >= StrEnd)
    1232:	f0 90 0b 01 	lds	r15, 0x010B
			  Byte = TextBuffer[Byte - StrEnd];
    1236:	cf 2c       	mov	r12, r15
    1238:	dd 24       	eor	r13, r13
    123a:	01 2f       	mov	r16, r17
    123c:	c0 e0       	ldi	r28, 0x00	; 0
    123e:	d0 e0       	ldi	r29, 0x00	; 0
    1240:	6c 2f       	mov	r22, r28
    1242:	e0 2f       	mov	r30, r16
    1244:	ff 27       	eor	r31, r31
    1246:	0f 15       	cp	r16, r15
    1248:	10 f0       	brcs	.+4      	; 0x124e <__vector_22+0x88>
    124a:	ec 19       	sub	r30, r12
    124c:	fd 09       	sbc	r31, r13
			else
			  Byte = TextBuffer[Byte];
    124e:	e4 5f       	subi	r30, 0xF4	; 244
    1250:	fe 4f       	sbci	r31, 0xFE	; 254
    1252:	80 81       	ld	r24, Z
			
			LCD_WriteChar(Byte, Character);
    1254:	0e 94 b3 08 	call	0x1166	; 0x1166 <LCD_WriteChar>
    1258:	21 96       	adiw	r28, 0x01	; 1
    125a:	0f 5f       	subi	r16, 0xFF	; 255
    125c:	c6 30       	cpi	r28, 0x06	; 6
    125e:	d1 05       	cpc	r29, r1
    1260:	79 f7       	brne	.-34     	; 0x1240 <__vector_22+0x7a>
		}
		
		if (StrStart++ == StrEnd)
    1262:	1f 5f       	subi	r17, 0xFF	; 255
    1264:	10 93 0a 01 	sts	0x010A, r17
    1268:	11 50       	subi	r17, 0x01	; 1
    126a:	1f 15       	cp	r17, r15
    126c:	19 f4       	brne	.+6      	; 0x1274 <__vector_22+0xae>
		  StrStart = 1;
    126e:	81 e0       	ldi	r24, 0x01	; 1
    1270:	80 93 0a 01 	sts	0x010A, r24
		
		ScrollCount = LCD_SCROLLCOUNT_DEFAULT;
    1274:	83 e0       	ldi	r24, 0x03	; 3
    1276:	80 93 08 01 	sts	0x0108, r24
		UpdateLCD = FALSE;
    127a:	10 92 09 01 	sts	0x0109, r1
    127e:	a7 e2       	ldi	r26, 0x27	; 39
    1280:	b1 e0       	ldi	r27, 0x01	; 1
    1282:	ec ee       	ldi	r30, 0xEC	; 236
    1284:	f0 e0       	ldi	r31, 0x00	; 0
	}

	for (uint8_t LCDChar = 0; LCDChar < LCD_SEGBUFFER_SIZE; LCDChar++)
	  *(pLCDREG + LCDChar) = SegBuffer[LCDChar];
    1286:	8d 91       	ld	r24, X+
    1288:	81 93       	st	Z+, r24
    128a:	81 e0       	ldi	r24, 0x01	; 1
    128c:	e0 30       	cpi	r30, 0x00	; 0
    128e:	f8 07       	cpc	r31, r24
    1290:	d1 f7       	brne	.-12     	; 0x1286 <__vector_22+0xc0>
    1292:	ff 91       	pop	r31
    1294:	ef 91       	pop	r30
    1296:	df 91       	pop	r29
    1298:	cf 91       	pop	r28
    129a:	bf 91       	pop	r27
    129c:	af 91       	pop	r26
    129e:	9f 91       	pop	r25
    12a0:	8f 91       	pop	r24
    12a2:	7f 91       	pop	r23
    12a4:	6f 91       	pop	r22
    12a6:	5f 91       	pop	r21
    12a8:	4f 91       	pop	r20
    12aa:	3f 91       	pop	r19
    12ac:	2f 91       	pop	r18
    12ae:	1f 91       	pop	r17
    12b0:	0f 91       	pop	r16
    12b2:	ff 90       	pop	r15
    12b4:	df 90       	pop	r13
    12b6:	cf 90       	pop	r12
    12b8:	0f 90       	pop	r0
    12ba:	0f be       	out	0x3f, r0	; 63
    12bc:	0f 90       	pop	r0
    12be:	1f 90       	pop	r1
    12c0:	18 95       	reti

000012c2 <LCD_puts_f>:
    12c2:	0f 93       	push	r16
    12c4:	1f 93       	push	r17
    12c6:	cf 93       	push	r28
    12c8:	df 93       	push	r29
    12ca:	cd b7       	in	r28, 0x3d	; 61
    12cc:	de b7       	in	r29, 0x3e	; 62
    12ce:	64 97       	sbiw	r28, 0x14	; 20
    12d0:	0f b6       	in	r0, 0x3f	; 63
    12d2:	f8 94       	cli
    12d4:	de bf       	out	0x3e, r29	; 62
    12d6:	0f be       	out	0x3f, r0	; 63
    12d8:	cd bf       	out	0x3d, r28	; 61
    12da:	8e 01       	movw	r16, r28
    12dc:	0f 5f       	subi	r16, 0xFF	; 255
    12de:	1f 4f       	sbci	r17, 0xFF	; 255
    12e0:	bc 01       	movw	r22, r24
    12e2:	c8 01       	movw	r24, r16
    12e4:	0e 94 51 1a 	call	0x34a2	; 0x34a2 <strcpy_P>
    12e8:	c8 01       	movw	r24, r16
    12ea:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
    12ee:	64 96       	adiw	r28, 0x14	; 20
    12f0:	0f b6       	in	r0, 0x3f	; 63
    12f2:	f8 94       	cli
    12f4:	de bf       	out	0x3e, r29	; 62
    12f6:	0f be       	out	0x3f, r0	; 63
    12f8:	cd bf       	out	0x3d, r28	; 61
    12fa:	df 91       	pop	r29
    12fc:	cf 91       	pop	r28
    12fe:	1f 91       	pop	r17
    1300:	0f 91       	pop	r16
    1302:	08 95       	ret

00001304 <USART_Tx>:
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_Tx(const char data)
{
    1304:	98 2f       	mov	r25, r24
    while (!(UCSRA & (1 << UDRE)));
    1306:	80 91 c0 00 	lds	r24, 0x00C0
    130a:	85 ff       	sbrs	r24, 5
    130c:	fc cf       	rjmp	.-8      	; 0x1306 <USART_Tx+0x2>
    UDR = data;
    130e:	90 93 c6 00 	sts	0x00C6, r25
    1312:	08 95       	ret

00001314 <USART_Rx>:
}

/*****************************************************************************
*
*   Function name : Usart_Rx
*
*   Returns :       char: byte received
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART
*
*****************************************************************************/
char USART_Rx(void)
{
    1314:	80 91 88 01 	lds	r24, 0x0188
    1318:	88 23       	and	r24, r24
    131a:	21 f4       	brne	.+8      	; 0x1324 <USART_Rx+0x10>
    while (!(BuffElements) && !(PacketTimeOut)) {};
    131c:	80 91 8c 01 	lds	r24, 0x018C
    1320:	88 23       	and	r24, r24
    1322:	c1 f3       	breq	.-16     	; 0x1314 <USART_Rx>
    return BUFF_GetBuffByte();
    1324:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <BUFF_GetBuffByte>
}
    1328:	99 27       	eor	r25, r25
    132a:	08 95       	ret

0000132c <USART_Init>:
    132c:	10 92 c5 00 	sts	0x00C5, r1
    1330:	87 e0       	ldi	r24, 0x07	; 7
    1332:	80 93 c4 00 	sts	0x00C4, r24
    1336:	82 e0       	ldi	r24, 0x02	; 2
    1338:	80 93 c0 00 	sts	0x00C0, r24
    133c:	80 e8       	ldi	r24, 0x80	; 128
    133e:	80 93 c1 00 	sts	0x00C1, r24
    1342:	86 e0       	ldi	r24, 0x06	; 6
    1344:	80 93 c2 00 	sts	0x00C2, r24
    1348:	0e 94 d9 0b 	call	0x17b2	; 0x17b2 <BUFF_InitialiseBuffer>
    134c:	08 95       	ret

0000134e <SPI_SPIInit>:

// ======================================================================================

void SPI_SPIInit(void)
{
    134e:	e4 e6       	ldi	r30, 0x64	; 100
    1350:	f0 e0       	ldi	r31, 0x00	; 0
    1352:	80 81       	ld	r24, Z
    1354:	8b 7f       	andi	r24, 0xFB	; 251
    1356:	80 83       	st	Z, r24
	PRR &= ~(1 << PRSPI);              // Enable the SPI system by clearing the power save register SPI disable bit

	// Master, Sample falling edge (setup rising), Fosc/16 speed (7.3MHz/16 = 467KHz)
	SPCR = ((1 << SPE) | (1 << MSTR) | (1 << CPHA) | (1 << CPOL) | (1 << SPR0));
    1358:	8d e5       	ldi	r24, 0x5D	; 93
    135a:	8c bd       	out	0x2c, r24	; 44
    135c:	08 95       	ret

0000135e <SPI_SPITransmit>:
}

uint8_t SPI_SPITransmit(const uint8_t Data)
{
    135e:	8e bd       	out	0x2e, r24	; 46
	SPDR = Data;                       // Loading a byte into the register starts the transmission
	while (!(SPSR & (1 << SPIF)));    // Wait until transmission completed
    1360:	0d b4       	in	r0, 0x2d	; 45
    1362:	07 fe       	sbrs	r0, 7
    1364:	fd cf       	rjmp	.-6      	; 0x1360 <SPI_SPITransmit+0x2>
	return SPDR;
    1366:	8e b5       	in	r24, 0x2e	; 46
}
    1368:	99 27       	eor	r25, r25
    136a:	08 95       	ret

0000136c <SPI_SPITransmitWord>:

uint8_t SPI_SPITransmitWord(const uint16_t Data)
{
    136c:	9c 01       	movw	r18, r24
	SPI_SPITransmit((uint8_t)(Data >> 8));
    136e:	83 2f       	mov	r24, r19
    1370:	99 27       	eor	r25, r25
    1372:	8e bd       	out	0x2e, r24	; 46
    1374:	0d b4       	in	r0, 0x2d	; 45
    1376:	07 fe       	sbrs	r0, 7
    1378:	fd cf       	rjmp	.-6      	; 0x1374 <SPI_SPITransmitWord+0x8>
    137a:	8e b5       	in	r24, 0x2e	; 46
    137c:	2e bd       	out	0x2e, r18	; 46
    137e:	0d b4       	in	r0, 0x2d	; 45
    1380:	07 fe       	sbrs	r0, 7
    1382:	fd cf       	rjmp	.-6      	; 0x137e <SPI_SPITransmitWord+0x12>
    1384:	8e b5       	in	r24, 0x2e	; 46
	return SPI_SPITransmit((uint8_t)Data);
}
    1386:	99 27       	eor	r25, r25
    1388:	08 95       	ret

0000138a <__vector_17>:
 *  have to stop the timer tick.
 *  For all modes the USIDR contents are stored and flags are updated.
 */
ISR(USI_OVERFLOW_vect, ISR_BLOCK)
{
    138a:	1f 92       	push	r1
    138c:	0f 92       	push	r0
    138e:	0f b6       	in	r0, 0x3f	; 63
    1390:	0f 92       	push	r0
    1392:	11 24       	eor	r1, r1
    1394:	8f 93       	push	r24
    1396:	ef 93       	push	r30
    1398:	ff 93       	push	r31
	// Master must now disable the compare match interrupt
	// to prevent more USI counter clocks.
	TIMSK0 &= ~(1<<OCIE0A);
    139a:	ee e6       	ldi	r30, 0x6E	; 110
    139c:	f0 e0       	ldi	r31, 0x00	; 0
    139e:	80 81       	ld	r24, Z
    13a0:	8d 7f       	andi	r24, 0xFD	; 253
    13a2:	80 83       	st	Z, r24
	
	// Update flags and clear USI counter
	USISR = (1<<USIOIF);
    13a4:	80 e4       	ldi	r24, 0x40	; 64
    13a6:	80 93 b9 00 	sts	0x00B9, r24
	TransferComplete = 1;
    13aa:	81 e0       	ldi	r24, 0x01	; 1
    13ac:	80 93 3c 01 	sts	0x013C, r24

	// Copy USIDR to buffer to prevent overwrite on next transfer.
	StoredUSIDR = USIDR;
    13b0:	80 91 ba 00 	lds	r24, 0x00BA
    13b4:	80 93 3b 01 	sts	0x013B, r24
    13b8:	ff 91       	pop	r31
    13ba:	ef 91       	pop	r30
    13bc:	8f 91       	pop	r24
    13be:	0f 90       	pop	r0
    13c0:	0f be       	out	0x3f, r0	; 63
    13c2:	0f 90       	pop	r0
    13c4:	1f 90       	pop	r1
    13c6:	18 95       	reti

000013c8 <USI_SPIOff>:
}

/*! \brief  Initialize USI as SPI master.
 *
 *  This function sets up all pin directions and module configurations.
 *  Use this function initially or when changing from slave to master mode.
 *  Note that the stored USIDR value is cleared.
 *
 */
void USI_SPIInitMaster()
{
	// Configure port directions.
 	USI_DIR_REG |= (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN);  // Outputs.
	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN);                       // Inputs.
	USI_OUT_REG |= (1<<USI_DATAIN_PIN);                        // Pull-ups.
	USI_OUT_REG &= ~(1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN); // Pull-ups.
	
	// Configure USI to 3-wire master mode with overflow interrupt.
	USICR = USI_CONTROL_REG_FLAGS;

	// Set the compare and prescaler for the requested frequency:
	USI_SPISetSpeed();
	
	// Init driver status register.
	TransferComplete = 0;
	
	StoredUSIDR = 0;
}

void USI_SPIOff(void)
{
    13c8:	8d b1       	in	r24, 0x0d	; 13
    13ca:	8f 7a       	andi	r24, 0xAF	; 175
    13cc:	8d b9       	out	0x0d, r24	; 13
	USI_DIR_REG &= ~((1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN));                        // Inputs.
	USI_OUT_REG &= ~((1<<USI_DATAIN_PIN)  | (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN)); // Pull-ups.
    13ce:	8e b1       	in	r24, 0x0e	; 14
    13d0:	8f 78       	andi	r24, 0x8F	; 143
    13d2:	8e b9       	out	0x0e, r24	; 14
	DDRF  &= ~(1 << 6);
    13d4:	86 98       	cbi	0x10, 6	; 16
	PORTF &= ~(1 << 6);
    13d6:	8e 98       	cbi	0x11, 6	; 17
	
	USI_STOPUSITIMER();
    13d8:	14 bc       	out	0x24, r1	; 36
    13da:	08 95       	ret

000013dc <USI_SPITransmit>:
}

/*! \brief  Put one byte on bus.
 *
 *  Use this function like you would write to the SPDR register in the native SPI module.
 *  Calling this function in master mode starts a transfer, while in slave mode, a
 *  byte will be prepared for the next transfer initiated by the master device.
 *  If a transfer is in progress, this function will set the write collision flag
 *  and return without altering the data registers.
 *
 *  \returns  Value returned by slave.
 */
uint8_t USI_SPITransmit(uint8_t val)
{
    13dc:	10 92 3c 01 	sts	0x013C, r1
	// Reinit flags.
	TransferComplete = 0;

	// Put data in USI data register.
	USIDR = val;
    13e0:	80 93 ba 00 	sts	0x00BA, r24
	
	TIFR0  |= (1<<OCF0A);  // Clear compare match flag.
    13e4:	a9 9a       	sbi	0x15, 1	; 21
	TIMSK0 |= (1<<OCIE0A); // Enable compare match interrupt.
    13e6:	80 91 6e 00 	lds	r24, 0x006E
    13ea:	82 60       	ori	r24, 0x02	; 2
    13ec:	80 93 6e 00 	sts	0x006E, r24

	// Clear the timer 0 value
	TCNT0 = 0;
    13f0:	16 bc       	out	0x26, r1	; 38

	while (!(TransferComplete));
    13f2:	80 91 3c 01 	lds	r24, 0x013C
    13f6:	88 23       	and	r24, r24
    13f8:	e1 f3       	breq	.-8      	; 0x13f2 <USI_SPITransmit+0x16>

	return StoredUSIDR;
    13fa:	80 91 3b 01 	lds	r24, 0x013B
}
    13fe:	99 27       	eor	r25, r25
    1400:	08 95       	ret

00001402 <USI_SPITransmitWord>:

uint8_t USI_SPITransmitWord(const uint16_t val )
{
    1402:	0f 93       	push	r16
    1404:	1f 93       	push	r17
    1406:	8c 01       	movw	r16, r24
	USI_SPITransmit((uint8_t)(val >> 8));
    1408:	81 2f       	mov	r24, r17
    140a:	99 27       	eor	r25, r25
    140c:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
	return USI_SPITransmit((uint8_t)val);
    1410:	80 2f       	mov	r24, r16
    1412:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
}
    1416:	99 27       	eor	r25, r25
    1418:	1f 91       	pop	r17
    141a:	0f 91       	pop	r16
    141c:	08 95       	ret

0000141e <USI_SPISetSpeed>:

void USI_SPIToggleClock(void)
{
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);	
}

void USI_SPISetSpeed()
{
    141e:	42 e0       	ldi	r20, 0x02	; 2
    1420:	50 e0       	ldi	r21, 0x00	; 0
    1422:	29 e9       	ldi	r18, 0x99	; 153
    1424:	33 e0       	ldi	r19, 0x03	; 3
    1426:	f9 01       	movw	r30, r18
    1428:	31 97       	sbiw	r30, 0x01	; 1
	for (uint8_t MatchIndex = 0; MatchIndex < USI_PRESET_SPEEDS; MatchIndex++)
	{
		if ((pgm_read_byte(&USIPSValues[MatchIndex][0]) == eeprom_read_byte(&EEPROMVars.SCKDuration)) || (MatchIndex == (USI_PRESET_SPEEDS - 1)))
    142a:	84 91       	lpm	r24, Z
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    142c:	da 01       	movw	r26, r20
    142e:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
    1432:	90 2d       	mov	r25, r0
    1434:	89 17       	cp	r24, r25
    1436:	21 f0       	breq	.+8      	; 0x1440 <USI_SPISetSpeed+0x22>
    1438:	83 e0       	ldi	r24, 0x03	; 3
    143a:	ee 39       	cpi	r30, 0x9E	; 158
    143c:	f8 07       	cpc	r31, r24
    143e:	31 f4       	brne	.+12     	; 0x144c <USI_SPISetSpeed+0x2e>
		{
			// Init Output Compare Register.
			OCR0A = pgm_read_byte(&USIPSValues[MatchIndex][1]);
    1440:	f9 01       	movw	r30, r18
    1442:	84 91       	lpm	r24, Z
    1444:	87 bd       	out	0x27, r24	; 39

			// Enable 'Clear Timer on Compare match' and set prescaler, which starts the timer
			TCCR0A = ((1<<WGM01) | TC0_PS_1);
    1446:	89 e0       	ldi	r24, 0x09	; 9
    1448:	84 bd       	out	0x24, r24	; 36
    144a:	08 95       	ret
    144c:	32 96       	adiw	r30, 0x02	; 2
    144e:	2e 5f       	subi	r18, 0xFE	; 254
    1450:	3f 4f       	sbci	r19, 0xFF	; 255
    1452:	83 e0       	ldi	r24, 0x03	; 3
    1454:	e0 3a       	cpi	r30, 0xA0	; 160
    1456:	f8 07       	cpc	r31, r24
    1458:	41 f7       	brne	.-48     	; 0x142a <USI_SPISetSpeed+0xc>
    145a:	08 95       	ret

0000145c <USI_SPIInitMaster>:
    145c:	8d b1       	in	r24, 0x0d	; 13
    145e:	80 65       	ori	r24, 0x50	; 80
    1460:	8d b9       	out	0x0d, r24	; 13
    1462:	6d 98       	cbi	0x0d, 5	; 13
    1464:	75 9a       	sbi	0x0e, 5	; 14
    1466:	76 98       	cbi	0x0e, 6	; 14
    1468:	8a e5       	ldi	r24, 0x5A	; 90
    146a:	80 93 b8 00 	sts	0x00B8, r24
    146e:	0e 94 0f 0a 	call	0x141e	; 0x141e <USI_SPISetSpeed>
    1472:	10 92 3c 01 	sts	0x013C, r1
    1476:	10 92 3b 01 	sts	0x013B, r1
    147a:	08 95       	ret

0000147c <USI_SPIToggleClock>:
    147c:	0f 93       	push	r16
    147e:	1f 93       	push	r17
    1480:	81 e0       	ldi	r24, 0x01	; 1
    1482:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    1486:	08 eb       	ldi	r16, 0xB8	; 184
    1488:	10 e0       	ldi	r17, 0x00	; 0
    148a:	f8 01       	movw	r30, r16
    148c:	80 81       	ld	r24, Z
    148e:	81 60       	ori	r24, 0x01	; 1
    1490:	80 83       	st	Z, r24
    1492:	81 e0       	ldi	r24, 0x01	; 1
    1494:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    1498:	f8 01       	movw	r30, r16
    149a:	80 81       	ld	r24, Z
    149c:	81 60       	ori	r24, 0x01	; 1
    149e:	80 83       	st	Z, r24
    14a0:	81 e0       	ldi	r24, 0x01	; 1
    14a2:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    14a6:	1f 91       	pop	r17
    14a8:	0f 91       	pop	r16
    14aa:	08 95       	ret

000014ac <DF_EnableDataflash>:
	DF_WaitWhileBusy();
}

void DF_EnableDataflash(const uint8_t Enabled)
{
    14ac:	90 91 47 01 	lds	r25, 0x0147
	if (Enabled == TRUE)
    14b0:	81 30       	cpi	r24, 0x01	; 1
    14b2:	31 f4       	brne	.+12     	; 0x14c0 <DF_EnableDataflash+0x14>
	{
		if (DataflashInfo.UseExernalDF == TRUE)
    14b4:	91 30       	cpi	r25, 0x01	; 1
    14b6:	11 f4       	brne	.+4      	; 0x14bc <DF_EnableDataflash+0x10>
		  MAIN_ResetCSLine(MAIN_RESETCS_EXTDFACTIVE);
    14b8:	82 e0       	ldi	r24, 0x02	; 2
    14ba:	05 c0       	rjmp	.+10     	; 0x14c6 <DF_EnableDataflash+0x1a>
		else
		  PORTB &= ~(1 << 0);
    14bc:	28 98       	cbi	0x05, 0	; 5
    14be:	08 95       	ret
	}
	else
	{
		if (DataflashInfo.UseExernalDF == TRUE)
    14c0:	91 30       	cpi	r25, 0x01	; 1
    14c2:	21 f4       	brne	.+8      	; 0x14cc <DF_EnableDataflash+0x20>
		  MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);
    14c4:	81 e0       	ldi	r24, 0x01	; 1
    14c6:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
    14ca:	08 95       	ret
		else
		  PORTB |= (1 << 0);
    14cc:	28 9a       	sbi	0x05, 0	; 5
    14ce:	08 95       	ret

000014d0 <DF_ReadBufferByte>:
    14d0:	ef 92       	push	r14
    14d2:	ff 92       	push	r15
    14d4:	0f 93       	push	r16
    14d6:	1f 93       	push	r17
    14d8:	7c 01       	movw	r14, r24
    14da:	00 91 00 01 	lds	r16, 0x0100
    14de:	10 91 01 01 	lds	r17, 0x0101
    14e2:	80 e0       	ldi	r24, 0x00	; 0
    14e4:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    14e8:	81 e0       	ldi	r24, 0x01	; 1
    14ea:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    14ee:	84 e5       	ldi	r24, 0x54	; 84
    14f0:	f8 01       	movw	r30, r16
    14f2:	09 95       	icall
    14f4:	8f 2d       	mov	r24, r15
    14f6:	99 27       	eor	r25, r25
    14f8:	f8 01       	movw	r30, r16
    14fa:	09 95       	icall
    14fc:	8e 2d       	mov	r24, r14
    14fe:	f8 01       	movw	r30, r16
    1500:	09 95       	icall
    1502:	80 e0       	ldi	r24, 0x00	; 0
    1504:	f8 01       	movw	r30, r16
    1506:	09 95       	icall
    1508:	80 e0       	ldi	r24, 0x00	; 0
    150a:	f8 01       	movw	r30, r16
    150c:	09 95       	icall
    150e:	99 27       	eor	r25, r25
    1510:	1f 91       	pop	r17
    1512:	0f 91       	pop	r16
    1514:	ff 90       	pop	r15
    1516:	ef 90       	pop	r14
    1518:	08 95       	ret

0000151a <DF_ContinuousReadEnable>:
    151a:	ef 92       	push	r14
    151c:	ff 92       	push	r15
    151e:	0f 93       	push	r16
    1520:	1f 93       	push	r17
    1522:	cf 93       	push	r28
    1524:	df 93       	push	r29
    1526:	8c 01       	movw	r16, r24
    1528:	7b 01       	movw	r14, r22
    152a:	c0 91 00 01 	lds	r28, 0x0100
    152e:	d0 91 01 01 	lds	r29, 0x0101
    1532:	80 e0       	ldi	r24, 0x00	; 0
    1534:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    1538:	81 e0       	ldi	r24, 0x01	; 1
    153a:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    153e:	88 e6       	ldi	r24, 0x68	; 104
    1540:	fe 01       	movw	r30, r28
    1542:	09 95       	icall
    1544:	8a b5       	in	r24, 0x2a	; 42
    1546:	98 01       	movw	r18, r16
    1548:	02 c0       	rjmp	.+4      	; 0x154e <DF_ContinuousReadEnable+0x34>
    154a:	36 95       	lsr	r19
    154c:	27 95       	ror	r18
    154e:	8a 95       	dec	r24
    1550:	e2 f7       	brpl	.-8      	; 0x154a <DF_ContinuousReadEnable+0x30>
    1552:	c9 01       	movw	r24, r18
    1554:	fe 01       	movw	r30, r28
    1556:	09 95       	icall
    1558:	8b b5       	in	r24, 0x2b	; 43
    155a:	02 c0       	rjmp	.+4      	; 0x1560 <DF_ContinuousReadEnable+0x46>
    155c:	00 0f       	add	r16, r16
    155e:	11 1f       	adc	r17, r17
    1560:	8a 95       	dec	r24
    1562:	e2 f7       	brpl	.-8      	; 0x155c <DF_ContinuousReadEnable+0x42>
    1564:	8f 2d       	mov	r24, r15
    1566:	99 27       	eor	r25, r25
    1568:	80 0f       	add	r24, r16
    156a:	fe 01       	movw	r30, r28
    156c:	09 95       	icall
    156e:	8e 2d       	mov	r24, r14
    1570:	fe 01       	movw	r30, r28
    1572:	09 95       	icall
    1574:	00 e0       	ldi	r16, 0x00	; 0
    1576:	80 e0       	ldi	r24, 0x00	; 0
    1578:	fe 01       	movw	r30, r28
    157a:	09 95       	icall
    157c:	0f 5f       	subi	r16, 0xFF	; 255
    157e:	04 30       	cpi	r16, 0x04	; 4
    1580:	d1 f7       	brne	.-12     	; 0x1576 <DF_ContinuousReadEnable+0x5c>
    1582:	df 91       	pop	r29
    1584:	cf 91       	pop	r28
    1586:	1f 91       	pop	r17
    1588:	0f 91       	pop	r16
    158a:	ff 90       	pop	r15
    158c:	ef 90       	pop	r14
    158e:	08 95       	ret

00001590 <DF_BufferWriteEnable>:
    1590:	ef 92       	push	r14
    1592:	ff 92       	push	r15
    1594:	0f 93       	push	r16
    1596:	1f 93       	push	r17
    1598:	7c 01       	movw	r14, r24
    159a:	00 91 00 01 	lds	r16, 0x0100
    159e:	10 91 01 01 	lds	r17, 0x0101
    15a2:	80 e0       	ldi	r24, 0x00	; 0
    15a4:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    15a8:	81 e0       	ldi	r24, 0x01	; 1
    15aa:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    15ae:	84 e8       	ldi	r24, 0x84	; 132
    15b0:	f8 01       	movw	r30, r16
    15b2:	09 95       	icall
    15b4:	80 e0       	ldi	r24, 0x00	; 0
    15b6:	f8 01       	movw	r30, r16
    15b8:	09 95       	icall
    15ba:	8f 2d       	mov	r24, r15
    15bc:	99 27       	eor	r25, r25
    15be:	f8 01       	movw	r30, r16
    15c0:	09 95       	icall
    15c2:	8e 2d       	mov	r24, r14
    15c4:	f8 01       	movw	r30, r16
    15c6:	09 95       	icall
    15c8:	1f 91       	pop	r17
    15ca:	0f 91       	pop	r16
    15cc:	ff 90       	pop	r15
    15ce:	ef 90       	pop	r14
    15d0:	08 95       	ret

000015d2 <DF_WaitWhileBusy>:
    15d2:	cf 93       	push	r28
    15d4:	df 93       	push	r29
    15d6:	c0 91 00 01 	lds	r28, 0x0100
    15da:	d0 91 01 01 	lds	r29, 0x0101
    15de:	80 e0       	ldi	r24, 0x00	; 0
    15e0:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    15e4:	81 e0       	ldi	r24, 0x01	; 1
    15e6:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    15ea:	87 e5       	ldi	r24, 0x57	; 87
    15ec:	fe 01       	movw	r30, r28
    15ee:	09 95       	icall
    15f0:	80 e0       	ldi	r24, 0x00	; 0
    15f2:	fe 01       	movw	r30, r28
    15f4:	09 95       	icall
    15f6:	87 ff       	sbrs	r24, 7
    15f8:	fb cf       	rjmp	.-10     	; 0x15f0 <DF_WaitWhileBusy+0x1e>
    15fa:	df 91       	pop	r29
    15fc:	cf 91       	pop	r28
    15fe:	08 95       	ret

00001600 <DF_EraseBlock>:
    1600:	ef 92       	push	r14
    1602:	ff 92       	push	r15
    1604:	0f 93       	push	r16
    1606:	1f 93       	push	r17
    1608:	7c 01       	movw	r14, r24
    160a:	00 91 00 01 	lds	r16, 0x0100
    160e:	10 91 01 01 	lds	r17, 0x0101
    1612:	80 e0       	ldi	r24, 0x00	; 0
    1614:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    1618:	81 e0       	ldi	r24, 0x01	; 1
    161a:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    161e:	80 e5       	ldi	r24, 0x50	; 80
    1620:	f8 01       	movw	r30, r16
    1622:	09 95       	icall
    1624:	8f 2d       	mov	r24, r15
    1626:	99 27       	eor	r25, r25
    1628:	f8 01       	movw	r30, r16
    162a:	09 95       	icall
    162c:	8e 2d       	mov	r24, r14
    162e:	f8 01       	movw	r30, r16
    1630:	09 95       	icall
    1632:	80 e0       	ldi	r24, 0x00	; 0
    1634:	f8 01       	movw	r30, r16
    1636:	09 95       	icall
    1638:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <DF_WaitWhileBusy>
    163c:	1f 91       	pop	r17
    163e:	0f 91       	pop	r16
    1640:	ff 90       	pop	r15
    1642:	ef 90       	pop	r14
    1644:	08 95       	ret

00001646 <DF_CopyFlashPageToBuffer>:
    1646:	ef 92       	push	r14
    1648:	ff 92       	push	r15
    164a:	0f 93       	push	r16
    164c:	1f 93       	push	r17
    164e:	8c 01       	movw	r16, r24
    1650:	e0 90 00 01 	lds	r14, 0x0100
    1654:	f0 90 01 01 	lds	r15, 0x0101
    1658:	80 e0       	ldi	r24, 0x00	; 0
    165a:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    165e:	81 e0       	ldi	r24, 0x01	; 1
    1660:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    1664:	83 e5       	ldi	r24, 0x53	; 83
    1666:	f7 01       	movw	r30, r14
    1668:	09 95       	icall
    166a:	8a b5       	in	r24, 0x2a	; 42
    166c:	98 01       	movw	r18, r16
    166e:	02 c0       	rjmp	.+4      	; 0x1674 <DF_CopyFlashPageToBuffer+0x2e>
    1670:	36 95       	lsr	r19
    1672:	27 95       	ror	r18
    1674:	8a 95       	dec	r24
    1676:	e2 f7       	brpl	.-8      	; 0x1670 <DF_CopyFlashPageToBuffer+0x2a>
    1678:	c9 01       	movw	r24, r18
    167a:	f7 01       	movw	r30, r14
    167c:	09 95       	icall
    167e:	8b b5       	in	r24, 0x2b	; 43
    1680:	02 c0       	rjmp	.+4      	; 0x1686 <DF_CopyFlashPageToBuffer+0x40>
    1682:	00 0f       	add	r16, r16
    1684:	11 1f       	adc	r17, r17
    1686:	8a 95       	dec	r24
    1688:	e2 f7       	brpl	.-8      	; 0x1682 <DF_CopyFlashPageToBuffer+0x3c>
    168a:	80 2f       	mov	r24, r16
    168c:	f7 01       	movw	r30, r14
    168e:	09 95       	icall
    1690:	80 e0       	ldi	r24, 0x00	; 0
    1692:	f7 01       	movw	r30, r14
    1694:	09 95       	icall
    1696:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <DF_WaitWhileBusy>
    169a:	1f 91       	pop	r17
    169c:	0f 91       	pop	r16
    169e:	ff 90       	pop	r15
    16a0:	ef 90       	pop	r14
    16a2:	08 95       	ret

000016a4 <DF_CopyBufferToFlashPage>:
    16a4:	ef 92       	push	r14
    16a6:	ff 92       	push	r15
    16a8:	0f 93       	push	r16
    16aa:	1f 93       	push	r17
    16ac:	8c 01       	movw	r16, r24
    16ae:	e0 90 00 01 	lds	r14, 0x0100
    16b2:	f0 90 01 01 	lds	r15, 0x0101
    16b6:	80 e0       	ldi	r24, 0x00	; 0
    16b8:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    16bc:	81 e0       	ldi	r24, 0x01	; 1
    16be:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    16c2:	83 e8       	ldi	r24, 0x83	; 131
    16c4:	f7 01       	movw	r30, r14
    16c6:	09 95       	icall
    16c8:	8a b5       	in	r24, 0x2a	; 42
    16ca:	98 01       	movw	r18, r16
    16cc:	02 c0       	rjmp	.+4      	; 0x16d2 <DF_CopyBufferToFlashPage+0x2e>
    16ce:	36 95       	lsr	r19
    16d0:	27 95       	ror	r18
    16d2:	8a 95       	dec	r24
    16d4:	e2 f7       	brpl	.-8      	; 0x16ce <DF_CopyBufferToFlashPage+0x2a>
    16d6:	c9 01       	movw	r24, r18
    16d8:	f7 01       	movw	r30, r14
    16da:	09 95       	icall
    16dc:	8b b5       	in	r24, 0x2b	; 43
    16de:	02 c0       	rjmp	.+4      	; 0x16e4 <DF_CopyBufferToFlashPage+0x40>
    16e0:	00 0f       	add	r16, r16
    16e2:	11 1f       	adc	r17, r17
    16e4:	8a 95       	dec	r24
    16e6:	e2 f7       	brpl	.-8      	; 0x16e0 <DF_CopyBufferToFlashPage+0x3c>
    16e8:	80 2f       	mov	r24, r16
    16ea:	f7 01       	movw	r30, r14
    16ec:	09 95       	icall
    16ee:	80 e0       	ldi	r24, 0x00	; 0
    16f0:	f7 01       	movw	r30, r14
    16f2:	09 95       	icall
    16f4:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <DF_WaitWhileBusy>
    16f8:	1f 91       	pop	r17
    16fa:	0f 91       	pop	r16
    16fc:	ff 90       	pop	r15
    16fe:	ef 90       	pop	r14
    1700:	08 95       	ret

00001702 <DF_GetChipCharacteristics>:
    1702:	0f 93       	push	r16
    1704:	1f 93       	push	r17
    1706:	00 91 00 01 	lds	r16, 0x0100
    170a:	10 91 01 01 	lds	r17, 0x0101
    170e:	80 e0       	ldi	r24, 0x00	; 0
    1710:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    1714:	81 e0       	ldi	r24, 0x01	; 1
    1716:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    171a:	87 e5       	ldi	r24, 0x57	; 87
    171c:	f8 01       	movw	r30, r16
    171e:	09 95       	icall
    1720:	80 e0       	ldi	r24, 0x00	; 0
    1722:	f8 01       	movw	r30, r16
    1724:	09 95       	icall
    1726:	99 27       	eor	r25, r25
    1728:	88 73       	andi	r24, 0x38	; 56
    172a:	90 70       	andi	r25, 0x00	; 0
    172c:	63 e0       	ldi	r22, 0x03	; 3
    172e:	96 95       	lsr	r25
    1730:	87 95       	ror	r24
    1732:	6a 95       	dec	r22
    1734:	e1 f7       	brne	.-8      	; 0x172e <DF_GetChipCharacteristics+0x2c>
    1736:	fc 01       	movw	r30, r24
    1738:	e0 56       	subi	r30, 0x60	; 96
    173a:	fc 4f       	sbci	r31, 0xFC	; 252
    173c:	e4 91       	lpm	r30, Z
    173e:	4e 2f       	mov	r20, r30
    1740:	55 27       	eor	r21, r21
    1742:	50 93 3e 01 	sts	0x013E, r21
    1746:	40 93 3d 01 	sts	0x013D, r20
    174a:	88 0f       	add	r24, r24
    174c:	99 1f       	adc	r25, r25
    174e:	fc 01       	movw	r30, r24
    1750:	e8 55       	subi	r30, 0x58	; 88
    1752:	fc 4f       	sbci	r31, 0xFC	; 252
    1754:	25 91       	lpm	r18, Z+
    1756:	34 91       	lpm	r19, Z
    1758:	30 93 40 01 	sts	0x0140, r19
    175c:	20 93 3f 01 	sts	0x013F, r18
    1760:	88 54       	subi	r24, 0x48	; 72
    1762:	9c 4f       	sbci	r25, 0xFC	; 252
    1764:	fc 01       	movw	r30, r24
    1766:	25 91       	lpm	r18, Z+
    1768:	34 91       	lpm	r19, Z
    176a:	30 93 42 01 	sts	0x0142, r19
    176e:	20 93 41 01 	sts	0x0141, r18
    1772:	80 e1       	ldi	r24, 0x10	; 16
    1774:	84 1b       	sub	r24, r20
    1776:	8a bd       	out	0x2a, r24	; 42
    1778:	48 50       	subi	r20, 0x08	; 8
    177a:	4b bd       	out	0x2b, r20	; 43
    177c:	1f 91       	pop	r17
    177e:	0f 91       	pop	r16
    1780:	08 95       	ret

00001782 <DF_CheckCorrectOnboardChip>:
    1782:	0e 94 81 0b 	call	0x1702	; 0x1702 <DF_GetChipCharacteristics>
    1786:	80 91 41 01 	lds	r24, 0x0141
    178a:	90 91 42 01 	lds	r25, 0x0142
    178e:	80 50       	subi	r24, 0x00	; 0
    1790:	98 40       	sbci	r25, 0x08	; 8
    1792:	19 f4       	brne	.+6      	; 0x179a <DF_CheckCorrectOnboardChip+0x18>
    1794:	81 e0       	ldi	r24, 0x01	; 1
    1796:	90 e0       	ldi	r25, 0x00	; 0
    1798:	08 95       	ret
    179a:	80 91 64 00 	lds	r24, 0x0064
    179e:	84 60       	ori	r24, 0x04	; 4
    17a0:	80 93 64 00 	sts	0x0064, r24
    17a4:	88 ec       	ldi	r24, 0xC8	; 200
    17a6:	93 e0       	ldi	r25, 0x03	; 3
    17a8:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
    17ac:	80 e0       	ldi	r24, 0x00	; 0
    17ae:	90 e0       	ldi	r25, 0x00	; 0
    17b0:	08 95       	ret

000017b2 <BUFF_InitialiseBuffer>:

// ======================================================================================

void BUFF_InitialiseBuffer(void)
{
    17b2:	10 92 89 01 	sts	0x0189, r1
	InPos  = 0;                            // Set up the IN counter to the start of the buffer
	OutPos = 0;                            // Set up the OUT counter to the start of the buffer
    17b6:	10 92 8a 01 	sts	0x018A, r1

	BuffElements = 0;                      // Reset the buffer elements counter
    17ba:	10 92 88 01 	sts	0x0188, r1
    17be:	08 95       	ret

000017c0 <BUFF_GetBuffByte>:
}

uint8_t BUFF_GetBuffByte(void)
{
    17c0:	80 91 88 01 	lds	r24, 0x0188
    17c4:	88 23       	and	r24, r24
    17c6:	19 f4       	brne	.+6      	; 0x17ce <BUFF_GetBuffByte+0xe>
	if (!(BuffElements))                   // No elements in the buffer
    17c8:	80 e0       	ldi	r24, 0x00	; 0
    17ca:	90 e0       	ldi	r25, 0x00	; 0
    17cc:	08 95       	ret
	  return 0;

	uint8_t RetrievedData = RingBuffer[OutPos++]; // Grab the stored byte into a temp variable
    17ce:	80 91 8a 01 	lds	r24, 0x018A
    17d2:	e8 2f       	mov	r30, r24
    17d4:	ff 27       	eor	r31, r31
    17d6:	e8 5b       	subi	r30, 0xB8	; 184
    17d8:	fe 4f       	sbci	r31, 0xFE	; 254
    17da:	e0 81       	ld	r30, Z
    17dc:	8f 5f       	subi	r24, 0xFF	; 255
    17de:	80 93 8a 01 	sts	0x018A, r24
	BuffElements--;                        // Decrement the total elements variable
    17e2:	80 91 88 01 	lds	r24, 0x0188
    17e6:	81 50       	subi	r24, 0x01	; 1
    17e8:	80 93 88 01 	sts	0x0188, r24
	
	if (OutPos == BUFF_BUFFLEN)
    17ec:	80 91 8a 01 	lds	r24, 0x018A
    17f0:	80 34       	cpi	r24, 0x40	; 64
    17f2:	11 f4       	brne	.+4      	; 0x17f8 <BUFF_GetBuffByte+0x38>
	  OutPos = 0;                        // Wrap pointer if end of array reached
    17f4:	10 92 8a 01 	sts	0x018A, r1
		
	return RetrievedData;                 // Return the retrieved data
    17f8:	8e 2f       	mov	r24, r30
    17fa:	99 27       	eor	r25, r25
}
    17fc:	08 95       	ret

000017fe <__vector_13>:
    17fe:	1f 92       	push	r1
    1800:	0f 92       	push	r0
    1802:	0f b6       	in	r0, 0x3f	; 63
    1804:	0f 92       	push	r0
    1806:	11 24       	eor	r1, r1
    1808:	2f 93       	push	r18
    180a:	3f 93       	push	r19
    180c:	4f 93       	push	r20
    180e:	5f 93       	push	r21
    1810:	6f 93       	push	r22
    1812:	7f 93       	push	r23
    1814:	8f 93       	push	r24
    1816:	9f 93       	push	r25
    1818:	af 93       	push	r26
    181a:	bf 93       	push	r27
    181c:	ef 93       	push	r30
    181e:	ff 93       	push	r31
    1820:	80 91 88 01 	lds	r24, 0x0188
    1824:	80 34       	cpi	r24, 0x40	; 64
    1826:	21 f4       	brne	.+8      	; 0x1830 <__vector_13+0x32>
    1828:	88 ed       	ldi	r24, 0xD8	; 216
    182a:	93 e0       	ldi	r25, 0x03	; 3
    182c:	0e 94 c7 04 	call	0x98e	; 0x98e <MAIN_CrashProgram>
    1830:	80 91 89 01 	lds	r24, 0x0189
    1834:	e8 2f       	mov	r30, r24
    1836:	ff 27       	eor	r31, r31
    1838:	90 91 c6 00 	lds	r25, 0x00C6
    183c:	e8 5b       	subi	r30, 0xB8	; 184
    183e:	fe 4f       	sbci	r31, 0xFE	; 254
    1840:	90 83       	st	Z, r25
    1842:	8f 5f       	subi	r24, 0xFF	; 255
    1844:	80 93 89 01 	sts	0x0189, r24
    1848:	80 91 88 01 	lds	r24, 0x0188
    184c:	8f 5f       	subi	r24, 0xFF	; 255
    184e:	80 93 88 01 	sts	0x0188, r24
    1852:	80 91 89 01 	lds	r24, 0x0189
    1856:	80 34       	cpi	r24, 0x40	; 64
    1858:	11 f4       	brne	.+4      	; 0x185e <__vector_13+0x60>
    185a:	10 92 89 01 	sts	0x0189, r1
    185e:	ff 91       	pop	r31
    1860:	ef 91       	pop	r30
    1862:	bf 91       	pop	r27
    1864:	af 91       	pop	r26
    1866:	9f 91       	pop	r25
    1868:	8f 91       	pop	r24
    186a:	7f 91       	pop	r23
    186c:	6f 91       	pop	r22
    186e:	5f 91       	pop	r21
    1870:	4f 91       	pop	r20
    1872:	3f 91       	pop	r19
    1874:	2f 91       	pop	r18
    1876:	0f 90       	pop	r0
    1878:	0f be       	out	0x3f, r0	; 63
    187a:	0f 90       	pop	r0
    187c:	1f 90       	pop	r1
    187e:	18 95       	reti

00001880 <TOUT_SetupSleepTimer>:

// ======================================================================================

void TOUT_SetupSleepTimer(void)
{
    1880:	ab e8       	ldi	r26, 0x8B	; 139
    1882:	b0 e0       	ldi	r27, 0x00	; 0
    1884:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
    1888:	80 2d       	mov	r24, r0
	uint8_t NewTicksIndex = eeprom_read_byte(&EEPROMVars.AutoSleepValIndex);
    188a:	28 2f       	mov	r18, r24
    188c:	33 27       	eor	r19, r19
    188e:	e2 2f       	mov	r30, r18

	if (NewTicksIndex == 0xFF) // Blank EEPROM protection
    1890:	2f 3f       	cpi	r18, 0xFF	; 255
    1892:	01 f1       	breq	.+64     	; 0x18d4 <TOUT_SetupSleepTimer+0x54>
	  NewTicksIndex = 4;

	TIMSK1 = (1 << TOIE1);
    1894:	81 e0       	ldi	r24, 0x01	; 1
    1896:	80 93 6f 00 	sts	0x006F, r24
	TicksBeforeAutoSleep = (pgm_read_byte(&AutoSleepTOValues[NewTicksIndex]) * 10);
    189a:	ff 27       	eor	r31, r31
    189c:	ef 51       	subi	r30, 0x1F	; 31
    189e:	fc 4f       	sbci	r31, 0xFC	; 252
    18a0:	e4 91       	lpm	r30, Z
    18a2:	8a e0       	ldi	r24, 0x0A	; 10
    18a4:	e8 9f       	mul	r30, r24
    18a6:	c0 01       	movw	r24, r0
    18a8:	11 24       	eor	r1, r1
    18aa:	90 93 90 01 	sts	0x0190, r25
    18ae:	80 93 8f 01 	sts	0x018F, r24

	TIMEOUT_SLEEP_TIMEOUT_RESET();
    18b2:	10 92 8e 01 	sts	0x018E, r1
    18b6:	10 92 8d 01 	sts	0x018D, r1
    18ba:	10 92 85 00 	sts	0x0085, r1
    18be:	10 92 84 00 	sts	0x0084, r1
	
	if (NewTicksIndex)
    18c2:	22 23       	and	r18, r18
    18c4:	21 f0       	breq	.+8      	; 0x18ce <TOUT_SetupSleepTimer+0x4e>
	  TIMEOUT_SLEEP_TIMER_ON();
    18c6:	81 e0       	ldi	r24, 0x01	; 1
    18c8:	80 93 81 00 	sts	0x0081, r24
    18cc:	08 95       	ret
	else
	  TIMEOUT_SLEEP_TIMER_OFF();
    18ce:	10 92 81 00 	sts	0x0081, r1
    18d2:	08 95       	ret
    18d4:	81 e0       	ldi	r24, 0x01	; 1
    18d6:	80 93 6f 00 	sts	0x006F, r24
    18da:	e5 ee       	ldi	r30, 0xE5	; 229
    18dc:	f3 e0       	ldi	r31, 0x03	; 3
    18de:	e4 91       	lpm	r30, Z
    18e0:	8a e0       	ldi	r24, 0x0A	; 10
    18e2:	e8 9f       	mul	r30, r24
    18e4:	c0 01       	movw	r24, r0
    18e6:	11 24       	eor	r1, r1
    18e8:	90 93 90 01 	sts	0x0190, r25
    18ec:	80 93 8f 01 	sts	0x018F, r24
    18f0:	10 92 8e 01 	sts	0x018E, r1
    18f4:	10 92 8d 01 	sts	0x018D, r1
    18f8:	10 92 85 00 	sts	0x0085, r1
    18fc:	10 92 84 00 	sts	0x0084, r1
    1900:	e2 cf       	rjmp	.-60     	; 0x18c6 <TOUT_SetupSleepTimer+0x46>

00001902 <__vector_9>:
    1902:	78 94       	sei
    1904:	1f 92       	push	r1
    1906:	0f 92       	push	r0
    1908:	0f b6       	in	r0, 0x3f	; 63
    190a:	0f 92       	push	r0
    190c:	11 24       	eor	r1, r1
    190e:	2f 93       	push	r18
    1910:	3f 93       	push	r19
    1912:	4f 93       	push	r20
    1914:	5f 93       	push	r21
    1916:	6f 93       	push	r22
    1918:	7f 93       	push	r23
    191a:	8f 93       	push	r24
    191c:	9f 93       	push	r25
    191e:	af 93       	push	r26
    1920:	bf 93       	push	r27
    1922:	ef 93       	push	r30
    1924:	ff 93       	push	r31
    1926:	80 91 8d 01 	lds	r24, 0x018D
    192a:	90 91 8e 01 	lds	r25, 0x018E
    192e:	20 91 8f 01 	lds	r18, 0x018F
    1932:	30 91 90 01 	lds	r19, 0x0190
    1936:	01 96       	adiw	r24, 0x01	; 1
    1938:	90 93 8e 01 	sts	0x018E, r25
    193c:	80 93 8d 01 	sts	0x018D, r24
    1940:	01 97       	sbiw	r24, 0x01	; 1
    1942:	82 17       	cp	r24, r18
    1944:	93 07       	cpc	r25, r19
    1946:	31 f4       	brne	.+12     	; 0x1954 <__vector_9+0x52>
    1948:	10 92 81 00 	sts	0x0081, r1
    194c:	0e 94 d5 02 	call	0x5aa	; 0x5aa <FUNCSleepMode>
    1950:	0e 94 40 0c 	call	0x1880	; 0x1880 <TOUT_SetupSleepTimer>
    1954:	ff 91       	pop	r31
    1956:	ef 91       	pop	r30
    1958:	bf 91       	pop	r27
    195a:	af 91       	pop	r26
    195c:	9f 91       	pop	r25
    195e:	8f 91       	pop	r24
    1960:	7f 91       	pop	r23
    1962:	6f 91       	pop	r22
    1964:	5f 91       	pop	r21
    1966:	4f 91       	pop	r20
    1968:	3f 91       	pop	r19
    196a:	2f 91       	pop	r18
    196c:	0f 90       	pop	r0
    196e:	0f be       	out	0x3f, r0	; 63
    1970:	0f 90       	pop	r0
    1972:	1f 90       	pop	r1
    1974:	18 95       	reti

00001976 <__vector_4>:
    1976:	78 94       	sei
    1978:	1f 92       	push	r1
    197a:	0f 92       	push	r0
    197c:	0f b6       	in	r0, 0x3f	; 63
    197e:	0f 92       	push	r0
    1980:	11 24       	eor	r1, r1
    1982:	2f 93       	push	r18
    1984:	3f 93       	push	r19
    1986:	4f 93       	push	r20
    1988:	5f 93       	push	r21
    198a:	6f 93       	push	r22
    198c:	7f 93       	push	r23
    198e:	8f 93       	push	r24
    1990:	9f 93       	push	r25
    1992:	af 93       	push	r26
    1994:	bf 93       	push	r27
    1996:	ef 93       	push	r30
    1998:	ff 93       	push	r31
    199a:	80 91 8b 01 	lds	r24, 0x018B
    199e:	8f 5f       	subi	r24, 0xFF	; 255
    19a0:	80 93 8b 01 	sts	0x018B, r24
    19a4:	80 91 8b 01 	lds	r24, 0x018B
    19a8:	87 39       	cpi	r24, 0x97	; 151
    19aa:	29 f4       	brne	.+10     	; 0x19b6 <__vector_4+0x40>
    19ac:	10 92 8b 01 	sts	0x018B, r1
    19b0:	81 e0       	ldi	r24, 0x01	; 1
    19b2:	80 93 8c 01 	sts	0x018C, r24
    19b6:	80 91 c0 00 	lds	r24, 0x00C0
    19ba:	83 ff       	sbrs	r24, 3
    19bc:	03 c0       	rjmp	.+6      	; 0x19c4 <__vector_4+0x4e>
    19be:	80 ef       	ldi	r24, 0xF0	; 240
    19c0:	93 e0       	ldi	r25, 0x03	; 3
    19c2:	06 c0       	rjmp	.+12     	; 0x19d0 <__vector_4+0x5a>
    19c4:	80 91 c0 00 	lds	r24, 0x00C0
    19c8:	84 ff       	sbrs	r24, 4
    19ca:	04 c0       	rjmp	.+8      	; 0x19d4 <__vector_4+0x5e>
    19cc:	86 ee       	ldi	r24, 0xE6	; 230
    19ce:	93 e0       	ldi	r25, 0x03	; 3
    19d0:	0e 94 c7 04 	call	0x98e	; 0x98e <MAIN_CrashProgram>
    19d4:	ff 91       	pop	r31
    19d6:	ef 91       	pop	r30
    19d8:	bf 91       	pop	r27
    19da:	af 91       	pop	r26
    19dc:	9f 91       	pop	r25
    19de:	8f 91       	pop	r24
    19e0:	7f 91       	pop	r23
    19e2:	6f 91       	pop	r22
    19e4:	5f 91       	pop	r21
    19e6:	4f 91       	pop	r20
    19e8:	3f 91       	pop	r19
    19ea:	2f 91       	pop	r18
    19ec:	0f 90       	pop	r0
    19ee:	0f be       	out	0x3f, r0	; 63
    19f0:	0f 90       	pop	r0
    19f2:	1f 90       	pop	r1
    19f4:	18 95       	reti

000019f6 <PD_SetupDFAddressCounters>:
	}
}

void PD_SetupDFAddressCounters(void)
{
    19f6:	ef 92       	push	r14
    19f8:	ff 92       	push	r15
    19fa:	0f 93       	push	r16
    19fc:	1f 93       	push	r17
	uint32_t StartAddress = CurrAddress;
    19fe:	20 91 a9 02 	lds	r18, 0x02A9
    1a02:	30 91 aa 02 	lds	r19, 0x02AA
    1a06:	40 91 ab 02 	lds	r20, 0x02AB
    1a0a:	50 91 ac 02 	lds	r21, 0x02AC

	DataflashInfo.CurrPageAddress = 0;
    1a0e:	10 92 44 01 	sts	0x0144, r1
    1a12:	10 92 43 01 	sts	0x0143, r1

	while (StartAddress > DataflashInfo.PageSize)      // This loop is the equivalent of a DIV and a MOD
    1a16:	80 91 3f 01 	lds	r24, 0x013F
    1a1a:	90 91 40 01 	lds	r25, 0x0140
    1a1e:	aa 27       	eor	r26, r26
    1a20:	bb 27       	eor	r27, r27
    1a22:	60 e0       	ldi	r22, 0x00	; 0
    1a24:	70 e0       	ldi	r23, 0x00	; 0
    1a26:	ee 24       	eor	r14, r14
    1a28:	ff 24       	eor	r15, r15
    1a2a:	87 01       	movw	r16, r14
    1a2c:	e8 1a       	sub	r14, r24
    1a2e:	f9 0a       	sbc	r15, r25
    1a30:	0a 0b       	sbc	r16, r26
    1a32:	1b 0b       	sbc	r17, r27
    1a34:	06 c0       	rjmp	.+12     	; 0x1a42 <PD_SetupDFAddressCounters+0x4c>
    1a36:	2e 0d       	add	r18, r14
    1a38:	3f 1d       	adc	r19, r15
    1a3a:	40 1f       	adc	r20, r16
    1a3c:	51 1f       	adc	r21, r17
    1a3e:	6f 5f       	subi	r22, 0xFF	; 255
    1a40:	7f 4f       	sbci	r23, 0xFF	; 255
    1a42:	82 17       	cp	r24, r18
    1a44:	93 07       	cpc	r25, r19
    1a46:	a4 07       	cpc	r26, r20
    1a48:	b5 07       	cpc	r27, r21
    1a4a:	a8 f3       	brcs	.-22     	; 0x1a36 <PD_SetupDFAddressCounters+0x40>
    1a4c:	70 93 44 01 	sts	0x0144, r23
    1a50:	60 93 43 01 	sts	0x0143, r22
	{
		StartAddress -= DataflashInfo.PageSize;         // Subtract one page's worth of bytes from the desired address
		DataflashInfo.CurrPageAddress++;
	}
	
	DataflashInfo.CurrBuffByte = (uint16_t)StartAddress; // The buffer byte is the remainder
    1a54:	30 93 46 01 	sts	0x0146, r19
    1a58:	20 93 45 01 	sts	0x0145, r18
    1a5c:	1f 91       	pop	r17
    1a5e:	0f 91       	pop	r16
    1a60:	ff 90       	pop	r15
    1a62:	ef 90       	pop	r14
    1a64:	08 95       	ret

00001a66 <PD_StoreDataflashByte>:
}

void PD_StoreDataflashByte(const uint8_t Data)
{
    1a66:	1f 93       	push	r17
    1a68:	18 2f       	mov	r17, r24
	if (DataflashInfo.CurrBuffByte == DataflashInfo.PageSize)
    1a6a:	20 91 45 01 	lds	r18, 0x0145
    1a6e:	30 91 46 01 	lds	r19, 0x0146
    1a72:	80 91 3f 01 	lds	r24, 0x013F
    1a76:	90 91 40 01 	lds	r25, 0x0140
    1a7a:	28 17       	cp	r18, r24
    1a7c:	39 07       	cpc	r19, r25
    1a7e:	a1 f4       	brne	.+40     	; 0x1aa8 <PD_StoreDataflashByte+0x42>
	{
		DF_CopyBufferToFlashPage(DataflashInfo.CurrPageAddress++);
    1a80:	80 91 43 01 	lds	r24, 0x0143
    1a84:	90 91 44 01 	lds	r25, 0x0144
    1a88:	01 96       	adiw	r24, 0x01	; 1
    1a8a:	90 93 44 01 	sts	0x0144, r25
    1a8e:	80 93 43 01 	sts	0x0143, r24
    1a92:	01 97       	sbiw	r24, 0x01	; 1
    1a94:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    1a98:	80 e0       	ldi	r24, 0x00	; 0
    1a9a:	90 e0       	ldi	r25, 0x00	; 0
    1a9c:	0e 94 c8 0a 	call	0x1590	; 0x1590 <DF_BufferWriteEnable>
		DataflashInfo.CurrBuffByte = 0;
    1aa0:	10 92 46 01 	sts	0x0146, r1
    1aa4:	10 92 45 01 	sts	0x0145, r1
	}
	
	USI_SPITransmit(Data);                                 // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    1aa8:	81 2f       	mov	r24, r17
    1aaa:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
	DataflashInfo.CurrBuffByte++;
    1aae:	80 91 45 01 	lds	r24, 0x0145
    1ab2:	90 91 46 01 	lds	r25, 0x0146
    1ab6:	01 96       	adiw	r24, 0x01	; 1
    1ab8:	90 93 46 01 	sts	0x0146, r25
    1abc:	80 93 45 01 	sts	0x0145, r24
    1ac0:	1f 91       	pop	r17
    1ac2:	08 95       	ret

00001ac4 <PD_InterpretAVRISPPacket>:
    1ac4:	0f 93       	push	r16
    1ac6:	1f 93       	push	r17
    1ac8:	cf 93       	push	r28
    1aca:	df 93       	push	r29
    1acc:	80 91 91 01 	lds	r24, 0x0191
    1ad0:	86 31       	cpi	r24, 0x16	; 22
    1ad2:	09 f4       	brne	.+2      	; 0x1ad6 <PD_InterpretAVRISPPacket+0x12>
    1ad4:	f1 c0       	rjmp	.+482    	; 0x1cb8 <PD_InterpretAVRISPPacket+0x1f4>
    1ad6:	87 31       	cpi	r24, 0x17	; 23
    1ad8:	90 f4       	brcc	.+36     	; 0x1afe <PD_InterpretAVRISPPacket+0x3a>
    1ada:	82 31       	cpi	r24, 0x12	; 18
    1adc:	09 f4       	brne	.+2      	; 0x1ae0 <PD_InterpretAVRISPPacket+0x1c>
    1ade:	65 c0       	rjmp	.+202    	; 0x1baa <PD_InterpretAVRISPPacket+0xe6>
    1ae0:	83 31       	cpi	r24, 0x13	; 19
    1ae2:	30 f4       	brcc	.+12     	; 0x1af0 <PD_InterpretAVRISPPacket+0x2c>
    1ae4:	80 31       	cpi	r24, 0x10	; 16
    1ae6:	01 f1       	breq	.+64     	; 0x1b28 <PD_InterpretAVRISPPacket+0x64>
    1ae8:	81 31       	cpi	r24, 0x11	; 17
    1aea:	09 f0       	breq	.+2      	; 0x1aee <PD_InterpretAVRISPPacket+0x2a>
    1aec:	2f c1       	rjmp	.+606    	; 0x1d4c <PD_InterpretAVRISPPacket+0x288>
    1aee:	41 c0       	rjmp	.+130    	; 0x1b72 <PD_InterpretAVRISPPacket+0xae>
    1af0:	84 31       	cpi	r24, 0x14	; 20
    1af2:	09 f4       	brne	.+2      	; 0x1af6 <PD_InterpretAVRISPPacket+0x32>
    1af4:	8b c0       	rjmp	.+278    	; 0x1c0c <PD_InterpretAVRISPPacket+0x148>
    1af6:	85 31       	cpi	r24, 0x15	; 21
    1af8:	08 f0       	brcs	.+2      	; 0x1afc <PD_InterpretAVRISPPacket+0x38>
    1afa:	ab c0       	rjmp	.+342    	; 0x1c52 <PD_InterpretAVRISPPacket+0x18e>
    1afc:	80 c0       	rjmp	.+256    	; 0x1bfe <PD_InterpretAVRISPPacket+0x13a>
    1afe:	89 31       	cpi	r24, 0x19	; 25
    1b00:	09 f4       	brne	.+2      	; 0x1b04 <PD_InterpretAVRISPPacket+0x40>
    1b02:	72 c0       	rjmp	.+228    	; 0x1be8 <PD_InterpretAVRISPPacket+0x124>
    1b04:	8a 31       	cpi	r24, 0x1A	; 26
    1b06:	38 f4       	brcc	.+14     	; 0x1b16 <PD_InterpretAVRISPPacket+0x52>
    1b08:	87 31       	cpi	r24, 0x17	; 23
    1b0a:	09 f4       	brne	.+2      	; 0x1b0e <PD_InterpretAVRISPPacket+0x4a>
    1b0c:	6d c0       	rjmp	.+218    	; 0x1be8 <PD_InterpretAVRISPPacket+0x124>
    1b0e:	88 31       	cpi	r24, 0x18	; 24
    1b10:	09 f0       	breq	.+2      	; 0x1b14 <PD_InterpretAVRISPPacket+0x50>
    1b12:	1c c1       	rjmp	.+568    	; 0x1d4c <PD_InterpretAVRISPPacket+0x288>
    1b14:	5b c0       	rjmp	.+182    	; 0x1bcc <PD_InterpretAVRISPPacket+0x108>
    1b16:	8b 31       	cpi	r24, 0x1B	; 27
    1b18:	f1 f1       	breq	.+124    	; 0x1b96 <PD_InterpretAVRISPPacket+0xd2>
    1b1a:	8b 31       	cpi	r24, 0x1B	; 27
    1b1c:	08 f4       	brcc	.+2      	; 0x1b20 <PD_InterpretAVRISPPacket+0x5c>
    1b1e:	56 c0       	rjmp	.+172    	; 0x1bcc <PD_InterpretAVRISPPacket+0x108>
    1b20:	8c 31       	cpi	r24, 0x1C	; 28
    1b22:	09 f0       	breq	.+2      	; 0x1b26 <PD_InterpretAVRISPPacket+0x62>
    1b24:	13 c1       	rjmp	.+550    	; 0x1d4c <PD_InterpretAVRISPPacket+0x288>
    1b26:	52 c0       	rjmp	.+164    	; 0x1bcc <PD_InterpretAVRISPPacket+0x108>
    1b28:	82 e0       	ldi	r24, 0x02	; 2
    1b2a:	90 e0       	ldi	r25, 0x00	; 0
    1b2c:	90 93 a7 02 	sts	0x02A7, r25
    1b30:	80 93 a6 02 	sts	0x02A6, r24
    1b34:	81 e0       	ldi	r24, 0x01	; 1
    1b36:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    1b3a:	0e 94 81 0b 	call	0x1702	; 0x1702 <DF_GetChipCharacteristics>
    1b3e:	80 91 3d 01 	lds	r24, 0x013D
    1b42:	90 91 3e 01 	lds	r25, 0x013E
    1b46:	89 2b       	or	r24, r25
    1b48:	59 f0       	breq	.+22     	; 0x1b60 <PD_InterpretAVRISPPacket+0x9c>
    1b4a:	89 ef       	ldi	r24, 0xF9	; 249
    1b4c:	93 e0       	ldi	r25, 0x03	; 3
    1b4e:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
    1b52:	81 e0       	ldi	r24, 0x01	; 1
    1b54:	80 93 a8 02 	sts	0x02A8, r24
    1b58:	81 b3       	in	r24, 0x11	; 17
    1b5a:	8f 7c       	andi	r24, 0xCF	; 207
    1b5c:	80 62       	ori	r24, 0x20	; 32
    1b5e:	17 c0       	rjmp	.+46     	; 0x1b8e <PD_InterpretAVRISPPacket+0xca>
    1b60:	88 ec       	ldi	r24, 0xC8	; 200
    1b62:	93 e0       	ldi	r25, 0x03	; 3
    1b64:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
    1b68:	80 e0       	ldi	r24, 0x00	; 0
    1b6a:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    1b6e:	80 ec       	ldi	r24, 0xC0	; 192
    1b70:	f4 c0       	rjmp	.+488    	; 0x1d5a <PD_InterpretAVRISPPacket+0x296>
    1b72:	82 e0       	ldi	r24, 0x02	; 2
    1b74:	90 e0       	ldi	r25, 0x00	; 0
    1b76:	90 93 a7 02 	sts	0x02A7, r25
    1b7a:	80 93 a6 02 	sts	0x02A6, r24
    1b7e:	10 92 a8 02 	sts	0x02A8, r1
    1b82:	80 e0       	ldi	r24, 0x00	; 0
    1b84:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    1b88:	81 b3       	in	r24, 0x11	; 17
    1b8a:	8f 7c       	andi	r24, 0xCF	; 207
    1b8c:	80 61       	ori	r24, 0x10	; 16
    1b8e:	81 bb       	out	0x11, r24	; 17
    1b90:	10 92 92 01 	sts	0x0192, r1
    1b94:	e4 c0       	rjmp	.+456    	; 0x1d5e <PD_InterpretAVRISPPacket+0x29a>
    1b96:	84 e0       	ldi	r24, 0x04	; 4
    1b98:	90 e0       	ldi	r25, 0x00	; 0
    1b9a:	90 93 a7 02 	sts	0x02A7, r25
    1b9e:	80 93 a6 02 	sts	0x02A6, r24
    1ba2:	10 92 92 01 	sts	0x0192, r1
    1ba6:	82 e0       	ldi	r24, 0x02	; 2
    1ba8:	1a c0       	rjmp	.+52     	; 0x1bde <PD_InterpretAVRISPPacket+0x11a>
    1baa:	82 e0       	ldi	r24, 0x02	; 2
    1bac:	90 e0       	ldi	r25, 0x00	; 0
    1bae:	90 93 a7 02 	sts	0x02A7, r25
    1bb2:	80 93 a6 02 	sts	0x02A6, r24
    1bb6:	10 92 92 01 	sts	0x0192, r1
    1bba:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <V2P_SendPacket>
    1bbe:	87 ea       	ldi	r24, 0xA7	; 167
    1bc0:	90 e0       	ldi	r25, 0x00	; 0
    1bc2:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
    1bc6:	c0 e0       	ldi	r28, 0x00	; 0
    1bc8:	d0 e0       	ldi	r29, 0x00	; 0
    1bca:	d0 c0       	rjmp	.+416    	; 0x1d6c <PD_InterpretAVRISPPacket+0x2a8>
    1bcc:	84 e0       	ldi	r24, 0x04	; 4
    1bce:	90 e0       	ldi	r25, 0x00	; 0
    1bd0:	90 93 a7 02 	sts	0x02A7, r25
    1bd4:	80 93 a6 02 	sts	0x02A6, r24
    1bd8:	10 92 92 01 	sts	0x0192, r1
    1bdc:	8f ef       	ldi	r24, 0xFF	; 255
    1bde:	80 93 93 01 	sts	0x0193, r24
    1be2:	10 92 94 01 	sts	0x0194, r1
    1be6:	bb c0       	rjmp	.+374    	; 0x1d5e <PD_InterpretAVRISPPacket+0x29a>
    1be8:	83 e0       	ldi	r24, 0x03	; 3
    1bea:	90 e0       	ldi	r25, 0x00	; 0
    1bec:	90 93 a7 02 	sts	0x02A7, r25
    1bf0:	80 93 a6 02 	sts	0x02A6, r24
    1bf4:	10 92 92 01 	sts	0x0192, r1
    1bf8:	10 92 93 01 	sts	0x0193, r1
    1bfc:	b0 c0       	rjmp	.+352    	; 0x1d5e <PD_InterpretAVRISPPacket+0x29a>
    1bfe:	82 e0       	ldi	r24, 0x02	; 2
    1c00:	90 e0       	ldi	r25, 0x00	; 0
    1c02:	90 93 a7 02 	sts	0x02A7, r25
    1c06:	80 93 a6 02 	sts	0x02A6, r24
    1c0a:	c2 cf       	rjmp	.-124    	; 0x1b90 <PD_InterpretAVRISPPacket+0xcc>
    1c0c:	20 91 92 01 	lds	r18, 0x0192
    1c10:	33 27       	eor	r19, r19
    1c12:	32 2f       	mov	r19, r18
    1c14:	22 27       	eor	r18, r18
    1c16:	80 91 93 01 	lds	r24, 0x0193
    1c1a:	99 27       	eor	r25, r25
    1c1c:	28 2b       	or	r18, r24
    1c1e:	39 2b       	or	r19, r25
    1c20:	f9 01       	movw	r30, r18
    1c22:	33 96       	adiw	r30, 0x03	; 3
    1c24:	f0 93 a7 02 	sts	0x02A7, r31
    1c28:	e0 93 a6 02 	sts	0x02A6, r30
    1c2c:	81 e0       	ldi	r24, 0x01	; 1
    1c2e:	90 e0       	ldi	r25, 0x00	; 0
    1c30:	a2 e9       	ldi	r26, 0x92	; 146
    1c32:	b1 e0       	ldi	r27, 0x01	; 1
    1c34:	2f 5f       	subi	r18, 0xFF	; 255
    1c36:	3f 4f       	sbci	r19, 0xFF	; 255
    1c38:	4f ef       	ldi	r20, 0xFF	; 255
    1c3a:	02 c0       	rjmp	.+4      	; 0x1c40 <PD_InterpretAVRISPPacket+0x17c>
    1c3c:	4d 93       	st	X+, r20
    1c3e:	01 96       	adiw	r24, 0x01	; 1
    1c40:	82 17       	cp	r24, r18
    1c42:	93 07       	cpc	r25, r19
    1c44:	d8 f3       	brcs	.-10     	; 0x1c3c <PD_InterpretAVRISPPacket+0x178>
    1c46:	10 92 92 01 	sts	0x0192, r1
    1c4a:	e0 57       	subi	r30, 0x70	; 112
    1c4c:	fe 4f       	sbci	r31, 0xFE	; 254
    1c4e:	10 82       	st	Z, r1
    1c50:	86 c0       	rjmp	.+268    	; 0x1d5e <PD_InterpretAVRISPPacket+0x29a>
    1c52:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <PD_SetupDFAddressCounters>
    1c56:	80 91 43 01 	lds	r24, 0x0143
    1c5a:	90 91 44 01 	lds	r25, 0x0144
    1c5e:	0e 94 23 0b 	call	0x1646	; 0x1646 <DF_CopyFlashPageToBuffer>
    1c62:	80 91 45 01 	lds	r24, 0x0145
    1c66:	90 91 46 01 	lds	r25, 0x0146
    1c6a:	0e 94 c8 0a 	call	0x1590	; 0x1590 <DF_BufferWriteEnable>
    1c6e:	80 91 92 01 	lds	r24, 0x0192
    1c72:	99 27       	eor	r25, r25
    1c74:	d8 2f       	mov	r29, r24
    1c76:	cc 27       	eor	r28, r28
    1c78:	80 91 93 01 	lds	r24, 0x0193
    1c7c:	99 27       	eor	r25, r25
    1c7e:	c8 2b       	or	r28, r24
    1c80:	d9 2b       	or	r29, r25
    1c82:	01 e9       	ldi	r16, 0x91	; 145
    1c84:	11 e0       	ldi	r17, 0x01	; 1
    1c86:	11 c0       	rjmp	.+34     	; 0x1caa <PD_InterpretAVRISPPacket+0x1e6>
    1c88:	f8 01       	movw	r30, r16
    1c8a:	82 85       	ldd	r24, Z+10	; 0x0a
    1c8c:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <PD_StoreDataflashByte>
    1c90:	80 91 45 01 	lds	r24, 0x0145
    1c94:	90 91 46 01 	lds	r25, 0x0146
    1c98:	01 96       	adiw	r24, 0x01	; 1
    1c9a:	90 93 46 01 	sts	0x0146, r25
    1c9e:	80 93 45 01 	sts	0x0145, r24
    1ca2:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <V2P_IncrementCurrAddress>
    1ca6:	0f 5f       	subi	r16, 0xFF	; 255
    1ca8:	1f 4f       	sbci	r17, 0xFF	; 255
    1caa:	ce 01       	movw	r24, r28
    1cac:	8f 56       	subi	r24, 0x6F	; 111
    1cae:	9e 4f       	sbci	r25, 0xFE	; 254
    1cb0:	08 17       	cp	r16, r24
    1cb2:	19 07       	cpc	r17, r25
    1cb4:	49 f7       	brne	.-46     	; 0x1c88 <PD_InterpretAVRISPPacket+0x1c4>
    1cb6:	6c cf       	rjmp	.-296    	; 0x1b90 <PD_InterpretAVRISPPacket+0xcc>
    1cb8:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <PD_SetupDFAddressCounters>
    1cbc:	80 91 43 01 	lds	r24, 0x0143
    1cc0:	90 91 44 01 	lds	r25, 0x0144
    1cc4:	0e 94 23 0b 	call	0x1646	; 0x1646 <DF_CopyFlashPageToBuffer>
    1cc8:	80 91 92 01 	lds	r24, 0x0192
    1ccc:	99 27       	eor	r25, r25
    1cce:	d8 2f       	mov	r29, r24
    1cd0:	cc 27       	eor	r28, r28
    1cd2:	80 91 93 01 	lds	r24, 0x0193
    1cd6:	99 27       	eor	r25, r25
    1cd8:	c8 2b       	or	r28, r24
    1cda:	d9 2b       	or	r29, r25
    1cdc:	01 e9       	ldi	r16, 0x91	; 145
    1cde:	11 e0       	ldi	r17, 0x01	; 1
    1ce0:	25 c0       	rjmp	.+74     	; 0x1d2c <PD_InterpretAVRISPPacket+0x268>
    1ce2:	20 91 45 01 	lds	r18, 0x0145
    1ce6:	30 91 46 01 	lds	r19, 0x0146
    1cea:	80 91 3f 01 	lds	r24, 0x013F
    1cee:	90 91 40 01 	lds	r25, 0x0140
    1cf2:	28 17       	cp	r18, r24
    1cf4:	39 07       	cpc	r19, r25
    1cf6:	41 f4       	brne	.+16     	; 0x1d08 <PD_InterpretAVRISPPacket+0x244>
    1cf8:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <PD_SetupDFAddressCounters>
    1cfc:	80 91 43 01 	lds	r24, 0x0143
    1d00:	90 91 44 01 	lds	r25, 0x0144
    1d04:	0e 94 23 0b 	call	0x1646	; 0x1646 <DF_CopyFlashPageToBuffer>
    1d08:	80 91 45 01 	lds	r24, 0x0145
    1d0c:	90 91 46 01 	lds	r25, 0x0146
    1d10:	01 96       	adiw	r24, 0x01	; 1
    1d12:	90 93 46 01 	sts	0x0146, r25
    1d16:	80 93 45 01 	sts	0x0145, r24
    1d1a:	01 97       	sbiw	r24, 0x01	; 1
    1d1c:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <DF_ReadBufferByte>
    1d20:	f8 01       	movw	r30, r16
    1d22:	82 83       	std	Z+2, r24	; 0x02
    1d24:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <V2P_IncrementCurrAddress>
    1d28:	0f 5f       	subi	r16, 0xFF	; 255
    1d2a:	1f 4f       	sbci	r17, 0xFF	; 255
    1d2c:	ce 01       	movw	r24, r28
    1d2e:	8f 56       	subi	r24, 0x6F	; 111
    1d30:	9e 4f       	sbci	r25, 0xFE	; 254
    1d32:	08 17       	cp	r16, r24
    1d34:	19 07       	cpc	r17, r25
    1d36:	a9 f6       	brne	.-86     	; 0x1ce2 <PD_InterpretAVRISPPacket+0x21e>
    1d38:	23 96       	adiw	r28, 0x03	; 3
    1d3a:	d0 93 a7 02 	sts	0x02A7, r29
    1d3e:	c0 93 a6 02 	sts	0x02A6, r28
    1d42:	10 92 92 01 	sts	0x0192, r1
    1d46:	f8 01       	movw	r30, r16
    1d48:	12 82       	std	Z+2, r1	; 0x02
    1d4a:	09 c0       	rjmp	.+18     	; 0x1d5e <PD_InterpretAVRISPPacket+0x29a>
    1d4c:	81 e0       	ldi	r24, 0x01	; 1
    1d4e:	90 e0       	ldi	r25, 0x00	; 0
    1d50:	90 93 a7 02 	sts	0x02A7, r25
    1d54:	80 93 a6 02 	sts	0x02A6, r24
    1d58:	89 ec       	ldi	r24, 0xC9	; 201
    1d5a:	80 93 92 01 	sts	0x0192, r24
    1d5e:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <V2P_SendPacket>
    1d62:	14 c0       	rjmp	.+40     	; 0x1d8c <PD_InterpretAVRISPPacket+0x2c8>
    1d64:	ce 01       	movw	r24, r28
    1d66:	0e 94 00 0b 	call	0x1600	; 0x1600 <DF_EraseBlock>
    1d6a:	21 96       	adiw	r28, 0x01	; 1
    1d6c:	80 91 41 01 	lds	r24, 0x0141
    1d70:	90 91 42 01 	lds	r25, 0x0142
    1d74:	23 e0       	ldi	r18, 0x03	; 3
    1d76:	96 95       	lsr	r25
    1d78:	87 95       	ror	r24
    1d7a:	2a 95       	dec	r18
    1d7c:	e1 f7       	brne	.-8      	; 0x1d76 <PD_InterpretAVRISPPacket+0x2b2>
    1d7e:	c8 17       	cp	r28, r24
    1d80:	d9 07       	cpc	r29, r25
    1d82:	80 f3       	brcs	.-32     	; 0x1d64 <PD_InterpretAVRISPPacket+0x2a0>
    1d84:	89 ef       	ldi	r24, 0xF9	; 249
    1d86:	93 e0       	ldi	r25, 0x03	; 3
    1d88:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
    1d8c:	df 91       	pop	r29
    1d8e:	cf 91       	pop	r28
    1d90:	1f 91       	pop	r17
    1d92:	0f 91       	pop	r16
    1d94:	08 95       	ret

00001d96 <V2P_GetChecksum>:
	SequenceNum++;
}

uint8_t V2P_GetChecksum()
{
    1d96:	90 91 a4 02 	lds	r25, 0x02A4
    1d9a:	8b e1       	ldi	r24, 0x1B	; 27
    1d9c:	98 27       	eor	r25, r24
	uint8_t CheckSumByte;
	
	/* Checksum for the V2 protocol is comprised of an XOR of all the packet 
      bytes, including the start, sequence number, size and token bytes.    */
	
	CheckSumByte  = AICB_MESSAGE_START;
	CheckSumByte ^= SequenceNum;
	CheckSumByte ^= (uint8_t)(MessageSize >> 8);
    1d9e:	40 91 a6 02 	lds	r20, 0x02A6
    1da2:	50 91 a7 02 	lds	r21, 0x02A7
    1da6:	94 27       	eor	r25, r20
	CheckSumByte ^= (uint8_t)(MessageSize & 0xFF);
    1da8:	25 2f       	mov	r18, r21
    1daa:	33 27       	eor	r19, r19
    1dac:	8e e0       	ldi	r24, 0x0E	; 14
    1dae:	82 27       	eor	r24, r18
	CheckSumByte ^= AICB_TOKEN;
    1db0:	98 27       	eor	r25, r24
    1db2:	20 e0       	ldi	r18, 0x00	; 0
    1db4:	30 e0       	ldi	r19, 0x00	; 0
    1db6:	e1 e9       	ldi	r30, 0x91	; 145
    1db8:	f1 e0       	ldi	r31, 0x01	; 1
    1dba:	04 c0       	rjmp	.+8      	; 0x1dc4 <V2P_GetChecksum+0x2e>
	
	for (uint16_t CByteIndex = 0; CByteIndex < MessageSize; CByteIndex++)
	   CheckSumByte ^= PacketBytes[CByteIndex];
    1dbc:	81 91       	ld	r24, Z+
    1dbe:	98 27       	eor	r25, r24
    1dc0:	2f 5f       	subi	r18, 0xFF	; 255
    1dc2:	3f 4f       	sbci	r19, 0xFF	; 255
    1dc4:	24 17       	cp	r18, r20
    1dc6:	35 07       	cpc	r19, r21
    1dc8:	c9 f7       	brne	.-14     	; 0x1dbc <V2P_GetChecksum+0x26>

	return CheckSumByte;
}
    1dca:	89 2f       	mov	r24, r25
    1dcc:	99 27       	eor	r25, r25
    1dce:	08 95       	ret

00001dd0 <V2P_IncrementCurrAddress>:

void V2P_GetSetParamater(void)
{
	uint8_t Param_Name = PacketBytes[1];    // Save the parameter number

	MessageSize = 3;                        // Set the default response message size to 3 bytes     
	PacketBytes[1] = AICB_STATUS_CMD_OK;    // Set the default response to OK

	switch (Param_Name)                     // Switch based on the recieved parameter byte
	{
		case AICB_PARAM_BUILD_NUMBER_LOW:
			PacketBytes[2] = VERSION_MINOR;

			break;
		case AICB_PARAM_BUILD_NUMBER_HIGH:
			PacketBytes[2] = VERSION_MAJOR;

			break;
		case AICB_PARAM_HARDWARE_VERSION:
			PacketBytes[2] = V2P_HW_VERSION;

			break;
		case AICB_PARAM_SW_MAJOR:
			PacketBytes[2] = V2P_SW_VERSION_MAJOR;

			break;
		case AICB_PARAM_SW_MINOR:
			PacketBytes[2] = ((eeprom_read_byte(&EEPROMVars.FirmVerMinor) == 0xFF)? V2P_SW_VERSION_MINOR_DEFAULT : eeprom_read_byte(&EEPROMVars.FirmVerMinor));

			break;
		case AICB_PARAM_CONTROLLER_INIT:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = Param_ControllerInit;
			}
			else
			{
				MessageSize = 2;
				Param_ControllerInit = PacketBytes[2];
			}
			
			break;
		case AICB_PARAM_SCK_DURATION:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.SCKDuration);
			}
			else
			{
				MessageSize = 2;
				eeprom_write_byte(&EEPROMVars.SCKDuration, PacketBytes[2]);
				USI_SPISetSpeed();          // Re-Initialise the USI system with the new frequency
			}
					
			break;
		case AICB_PARAM_RESET_POLARITY:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.ResetPolarity);		
			}
			else
			{
				MessageSize = 2;
				eeprom_write_byte(&EEPROMVars.ResetPolarity, PacketBytes[2]);
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Change takes effect immediatly
			}
			
			break;
		case AICB_PARAM_OSC_PSCALE:
		case AICB_PARAM_OSC_CMATCH:
			/* Despite not supporting these parameters (STK500 only), the AVR Studio programmer
			   sends them along with the SCK duration. A OK must be returned or the sequence will fail
			   and the SCK duration byte will not be sent.                                             */
		
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			  PacketBytes[2] = 0;             // If the command is a read, return a 0 for both parameters
			else
			  MessageSize = 2;                // Otherwise just send back an OK if the command is a set		
			
			break;
		default:                             // Unrecognised parameter
			MessageSize = 2;
			PacketBytes[1] = AICB_STATUS_CMD_FAILED;			
	}
	
	V2P_SendPacket();
}

void V2P_IncrementCurrAddress(void)
{
    1dd0:	80 91 a9 02 	lds	r24, 0x02A9
    1dd4:	90 91 aa 02 	lds	r25, 0x02AA
    1dd8:	a0 91 ab 02 	lds	r26, 0x02AB
    1ddc:	b0 91 ac 02 	lds	r27, 0x02AC
    1de0:	01 96       	adiw	r24, 0x01	; 1
    1de2:	a1 1d       	adc	r26, r1
    1de4:	b1 1d       	adc	r27, r1
    1de6:	80 93 a9 02 	sts	0x02A9, r24
    1dea:	90 93 aa 02 	sts	0x02AA, r25
    1dee:	a0 93 ab 02 	sts	0x02AB, r26
    1df2:	b0 93 ac 02 	sts	0x02AC, r27
    1df6:	08 95       	ret

00001df8 <V2P_CheckForExtendedAddress>:
	// Incrementing a 32-bit unsigned variable takes a lot of code. Because much of the code is
	// not very time critical (much of it is waiting for the hardware), i've chosen to waste
	// a few extra cycles per increment and save a good 60 bytes or so of code space by putting
	// the incrmement inside a function.

	CurrAddress++;
}

void V2P_CheckForExtendedAddress(void)
{
    1df8:	80 91 a9 02 	lds	r24, 0x02A9
    1dfc:	90 91 aa 02 	lds	r25, 0x02AA
    1e00:	a0 91 ab 02 	lds	r26, 0x02AB
    1e04:	b0 91 ac 02 	lds	r27, 0x02AC
    1e08:	b7 ff       	sbrs	r27, 7
    1e0a:	1e c0       	rjmp	.+60     	; 0x1e48 <V2P_CheckForExtendedAddress+0x50>
	if (CurrAddress & V2P_LOAD_EXTENDED_ADDR_FLAG)     // MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
	{
		USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);   // Load extended address command
    1e0c:	8d e4       	ldi	r24, 0x4D	; 77
    1e0e:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1e12:	80 e0       	ldi	r24, 0x00	; 0
    1e14:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
		USI_SPITransmit((CurrAddress & V2P_LOAD_EXTENDED_ADDR_MASK) >> V2P_LOAD_EXTENDED_ADDR_SHIFT);
    1e18:	80 91 ab 02 	lds	r24, 0x02AB
    1e1c:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1e20:	80 e0       	ldi	r24, 0x00	; 0
    1e22:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
		
		CurrAddress &= ~(V2P_LOAD_EXTENDED_ADDR_FLAG); // Clear the flag
    1e26:	80 91 a9 02 	lds	r24, 0x02A9
    1e2a:	90 91 aa 02 	lds	r25, 0x02AA
    1e2e:	a0 91 ab 02 	lds	r26, 0x02AB
    1e32:	b0 91 ac 02 	lds	r27, 0x02AC
    1e36:	bf 77       	andi	r27, 0x7F	; 127
    1e38:	80 93 a9 02 	sts	0x02A9, r24
    1e3c:	90 93 aa 02 	sts	0x02AA, r25
    1e40:	a0 93 ab 02 	sts	0x02AB, r26
    1e44:	b0 93 ac 02 	sts	0x02AC, r27
    1e48:	08 95       	ret

00001e4a <V2P_SendPacket>:
    1e4a:	0f 93       	push	r16
    1e4c:	1f 93       	push	r17
    1e4e:	cf 93       	push	r28
    1e50:	df 93       	push	r29
    1e52:	8b e1       	ldi	r24, 0x1B	; 27
    1e54:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e58:	80 91 a4 02 	lds	r24, 0x02A4
    1e5c:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e60:	80 91 a7 02 	lds	r24, 0x02A7
    1e64:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e68:	80 91 a6 02 	lds	r24, 0x02A6
    1e6c:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e70:	8e e0       	ldi	r24, 0x0E	; 14
    1e72:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e76:	c0 e0       	ldi	r28, 0x00	; 0
    1e78:	d0 e0       	ldi	r29, 0x00	; 0
    1e7a:	01 e9       	ldi	r16, 0x91	; 145
    1e7c:	11 e0       	ldi	r17, 0x01	; 1
    1e7e:	06 c0       	rjmp	.+12     	; 0x1e8c <V2P_SendPacket+0x42>
    1e80:	f8 01       	movw	r30, r16
    1e82:	81 91       	ld	r24, Z+
    1e84:	8f 01       	movw	r16, r30
    1e86:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e8a:	21 96       	adiw	r28, 0x01	; 1
    1e8c:	80 91 a6 02 	lds	r24, 0x02A6
    1e90:	90 91 a7 02 	lds	r25, 0x02A7
    1e94:	c8 17       	cp	r28, r24
    1e96:	d9 07       	cpc	r29, r25
    1e98:	98 f3       	brcs	.-26     	; 0x1e80 <V2P_SendPacket+0x36>
    1e9a:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <V2P_GetChecksum>
    1e9e:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1ea2:	80 91 a4 02 	lds	r24, 0x02A4
    1ea6:	90 91 a5 02 	lds	r25, 0x02A5
    1eaa:	01 96       	adiw	r24, 0x01	; 1
    1eac:	90 93 a5 02 	sts	0x02A5, r25
    1eb0:	80 93 a4 02 	sts	0x02A4, r24
    1eb4:	df 91       	pop	r29
    1eb6:	cf 91       	pop	r28
    1eb8:	1f 91       	pop	r17
    1eba:	0f 91       	pop	r16
    1ebc:	08 95       	ret

00001ebe <V2P_GetSetParamater>:
    1ebe:	20 91 92 01 	lds	r18, 0x0192
    1ec2:	83 e0       	ldi	r24, 0x03	; 3
    1ec4:	90 e0       	ldi	r25, 0x00	; 0
    1ec6:	90 93 a7 02 	sts	0x02A7, r25
    1eca:	80 93 a6 02 	sts	0x02A6, r24
    1ece:	10 92 92 01 	sts	0x0192, r1
    1ed2:	22 39       	cpi	r18, 0x92	; 146
    1ed4:	21 f1       	breq	.+72     	; 0x1f1e <V2P_GetSetParamater+0x60>
    1ed6:	23 39       	cpi	r18, 0x93	; 147
    1ed8:	70 f4       	brcc	.+28     	; 0x1ef6 <V2P_GetSetParamater+0x38>
    1eda:	21 38       	cpi	r18, 0x81	; 129
    1edc:	d1 f0       	breq	.+52     	; 0x1f12 <V2P_GetSetParamater+0x54>
    1ede:	22 38       	cpi	r18, 0x82	; 130
    1ee0:	20 f4       	brcc	.+8      	; 0x1eea <V2P_GetSetParamater+0x2c>
    1ee2:	20 38       	cpi	r18, 0x80	; 128
    1ee4:	09 f0       	breq	.+2      	; 0x1ee8 <V2P_GetSetParamater+0x2a>
    1ee6:	74 c0       	rjmp	.+232    	; 0x1fd0 <V2P_GetSetParamater+0x112>
    1ee8:	22 c0       	rjmp	.+68     	; 0x1f2e <V2P_GetSetParamater+0x70>
    1eea:	20 39       	cpi	r18, 0x90	; 144
    1eec:	b1 f0       	breq	.+44     	; 0x1f1a <V2P_GetSetParamater+0x5c>
    1eee:	21 39       	cpi	r18, 0x91	; 145
    1ef0:	09 f0       	breq	.+2      	; 0x1ef4 <V2P_GetSetParamater+0x36>
    1ef2:	6e c0       	rjmp	.+220    	; 0x1fd0 <V2P_GetSetParamater+0x112>
    1ef4:	12 c0       	rjmp	.+36     	; 0x1f1a <V2P_GetSetParamater+0x5c>
    1ef6:	28 39       	cpi	r18, 0x98	; 152
    1ef8:	81 f1       	breq	.+96     	; 0x1f5a <V2P_GetSetParamater+0x9c>
    1efa:	29 39       	cpi	r18, 0x99	; 153
    1efc:	20 f4       	brcc	.+8      	; 0x1f06 <V2P_GetSetParamater+0x48>
    1efe:	26 39       	cpi	r18, 0x96	; 150
    1f00:	08 f4       	brcc	.+2      	; 0x1f04 <V2P_GetSetParamater+0x46>
    1f02:	66 c0       	rjmp	.+204    	; 0x1fd0 <V2P_GetSetParamater+0x112>
    1f04:	57 c0       	rjmp	.+174    	; 0x1fb4 <V2P_GetSetParamater+0xf6>
    1f06:	2e 39       	cpi	r18, 0x9E	; 158
    1f08:	e1 f1       	breq	.+120    	; 0x1f82 <V2P_GetSetParamater+0xc4>
    1f0a:	2f 39       	cpi	r18, 0x9F	; 159
    1f0c:	09 f0       	breq	.+2      	; 0x1f10 <V2P_GetSetParamater+0x52>
    1f0e:	60 c0       	rjmp	.+192    	; 0x1fd0 <V2P_GetSetParamater+0x112>
    1f10:	12 c0       	rjmp	.+36     	; 0x1f36 <V2P_GetSetParamater+0x78>
    1f12:	81 e0       	ldi	r24, 0x01	; 1
    1f14:	80 93 93 01 	sts	0x0193, r24
    1f18:	64 c0       	rjmp	.+200    	; 0x1fe2 <V2P_GetSetParamater+0x124>
    1f1a:	82 e0       	ldi	r24, 0x02	; 2
    1f1c:	fb cf       	rjmp	.-10     	; 0x1f14 <V2P_GetSetParamater+0x56>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1f1e:	2a e8       	ldi	r18, 0x8A	; 138
    1f20:	30 e0       	ldi	r19, 0x00	; 0
    1f22:	d9 01       	movw	r26, r18
    1f24:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
    1f28:	80 2d       	mov	r24, r0
    1f2a:	8f 3f       	cpi	r24, 0xFF	; 255
    1f2c:	11 f4       	brne	.+4      	; 0x1f32 <V2P_GetSetParamater+0x74>
    1f2e:	84 e0       	ldi	r24, 0x04	; 4
    1f30:	f1 cf       	rjmp	.-30     	; 0x1f14 <V2P_GetSetParamater+0x56>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1f32:	d9 01       	movw	r26, r18
    1f34:	2c c0       	rjmp	.+88     	; 0x1f8e <V2P_GetSetParamater+0xd0>
    1f36:	80 91 91 01 	lds	r24, 0x0191
    1f3a:	83 30       	cpi	r24, 0x03	; 3
    1f3c:	19 f4       	brne	.+6      	; 0x1f44 <V2P_GetSetParamater+0x86>
    1f3e:	80 91 ad 02 	lds	r24, 0x02AD
    1f42:	e8 cf       	rjmp	.-48     	; 0x1f14 <V2P_GetSetParamater+0x56>
    1f44:	82 e0       	ldi	r24, 0x02	; 2
    1f46:	90 e0       	ldi	r25, 0x00	; 0
    1f48:	90 93 a7 02 	sts	0x02A7, r25
    1f4c:	80 93 a6 02 	sts	0x02A6, r24
    1f50:	80 91 93 01 	lds	r24, 0x0193
    1f54:	80 93 ad 02 	sts	0x02AD, r24
    1f58:	44 c0       	rjmp	.+136    	; 0x1fe2 <V2P_GetSetParamater+0x124>
    1f5a:	80 91 91 01 	lds	r24, 0x0191
    1f5e:	a2 e0       	ldi	r26, 0x02	; 2
    1f60:	b0 e0       	ldi	r27, 0x00	; 0
    1f62:	83 30       	cpi	r24, 0x03	; 3
    1f64:	a1 f0       	breq	.+40     	; 0x1f8e <V2P_GetSetParamater+0xd0>
    1f66:	82 e0       	ldi	r24, 0x02	; 2
    1f68:	90 e0       	ldi	r25, 0x00	; 0
    1f6a:	90 93 a7 02 	sts	0x02A7, r25
    1f6e:	80 93 a6 02 	sts	0x02A6, r24

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    1f72:	80 91 93 01 	lds	r24, 0x0193
    1f76:	08 2e       	mov	r0, r24
    1f78:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
    1f7c:	0e 94 0f 0a 	call	0x141e	; 0x141e <USI_SPISetSpeed>
    1f80:	30 c0       	rjmp	.+96     	; 0x1fe2 <V2P_GetSetParamater+0x124>
    1f82:	80 91 91 01 	lds	r24, 0x0191
    1f86:	a1 e0       	ldi	r26, 0x01	; 1
    1f88:	b0 e0       	ldi	r27, 0x00	; 0
    1f8a:	83 30       	cpi	r24, 0x03	; 3
    1f8c:	21 f4       	brne	.+8      	; 0x1f96 <V2P_GetSetParamater+0xd8>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1f8e:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
    1f92:	80 2d       	mov	r24, r0
    1f94:	bf cf       	rjmp	.-130    	; 0x1f14 <V2P_GetSetParamater+0x56>
    1f96:	82 e0       	ldi	r24, 0x02	; 2
    1f98:	90 e0       	ldi	r25, 0x00	; 0
    1f9a:	90 93 a7 02 	sts	0x02A7, r25
    1f9e:	80 93 a6 02 	sts	0x02A6, r24

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    1fa2:	80 91 93 01 	lds	r24, 0x0193
    1fa6:	08 2e       	mov	r0, r24
    1fa8:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
    1fac:	81 e0       	ldi	r24, 0x01	; 1
    1fae:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
    1fb2:	17 c0       	rjmp	.+46     	; 0x1fe2 <V2P_GetSetParamater+0x124>
    1fb4:	80 91 91 01 	lds	r24, 0x0191
    1fb8:	83 30       	cpi	r24, 0x03	; 3
    1fba:	19 f4       	brne	.+6      	; 0x1fc2 <V2P_GetSetParamater+0x104>
    1fbc:	10 92 93 01 	sts	0x0193, r1
    1fc0:	10 c0       	rjmp	.+32     	; 0x1fe2 <V2P_GetSetParamater+0x124>
    1fc2:	82 e0       	ldi	r24, 0x02	; 2
    1fc4:	90 e0       	ldi	r25, 0x00	; 0
    1fc6:	90 93 a7 02 	sts	0x02A7, r25
    1fca:	80 93 a6 02 	sts	0x02A6, r24
    1fce:	09 c0       	rjmp	.+18     	; 0x1fe2 <V2P_GetSetParamater+0x124>
    1fd0:	82 e0       	ldi	r24, 0x02	; 2
    1fd2:	90 e0       	ldi	r25, 0x00	; 0
    1fd4:	90 93 a7 02 	sts	0x02A7, r25
    1fd8:	80 93 a6 02 	sts	0x02A6, r24
    1fdc:	80 ec       	ldi	r24, 0xC0	; 192
    1fde:	80 93 92 01 	sts	0x0192, r24
    1fe2:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <V2P_SendPacket>
    1fe6:	08 95       	ret

00001fe8 <V2P_RunStateMachine>:
    1fe8:	cf 92       	push	r12
    1fea:	df 92       	push	r13
    1fec:	ef 92       	push	r14
    1fee:	ff 92       	push	r15
    1ff0:	0f 93       	push	r16
    1ff2:	1f 93       	push	r17
    1ff4:	cf 93       	push	r28
    1ff6:	df 93       	push	r29
    1ff8:	6c 01       	movw	r12, r24
    1ffa:	0e 94 d9 0b 	call	0x17b2	; 0x17b2 <BUFF_InitialiseBuffer>
    1ffe:	10 92 81 00 	sts	0x0081, r1
    2002:	10 92 a8 02 	sts	0x02A8, r1
    2006:	10 92 a9 02 	sts	0x02A9, r1
    200a:	10 92 aa 02 	sts	0x02AA, r1
    200e:	10 92 ab 02 	sts	0x02AB, r1
    2012:	10 92 ac 02 	sts	0x02AC, r1
    2016:	10 e0       	ldi	r17, 0x00	; 0
    2018:	73 c0       	rjmp	.+230    	; 0x2100 <V2P_RunStateMachine+0x118>
    201a:	12 e0       	ldi	r17, 0x02	; 2
    201c:	01 c0       	rjmp	.+2      	; 0x2020 <V2P_RunStateMachine+0x38>
    201e:	19 e0       	ldi	r17, 0x09	; 9
    2020:	80 91 8c 01 	lds	r24, 0x018C
    2024:	81 30       	cpi	r24, 0x01	; 1
    2026:	09 f4       	brne	.+2      	; 0x202a <V2P_RunStateMachine+0x42>
    2028:	0e c1       	rjmp	.+540    	; 0x2246 <V2P_RunStateMachine+0x25e>
    202a:	11 23       	and	r17, r17
    202c:	81 f1       	breq	.+96     	; 0x208e <V2P_RunStateMachine+0xa6>
    202e:	10 92 8c 01 	sts	0x018C, r1
    2032:	10 92 8b 01 	sts	0x018B, r1
    2036:	10 92 b2 00 	sts	0x00B2, r1
    203a:	80 ef       	ldi	r24, 0xF0	; 240
    203c:	80 93 b3 00 	sts	0x00B3, r24
    2040:	82 e0       	ldi	r24, 0x02	; 2
    2042:	80 93 70 00 	sts	0x0070, r24
    2046:	8f e0       	ldi	r24, 0x0F	; 15
    2048:	80 93 b0 00 	sts	0x00B0, r24
    204c:	15 30       	cpi	r17, 0x05	; 5
    204e:	09 f4       	brne	.+2      	; 0x2052 <V2P_RunStateMachine+0x6a>
    2050:	5a c0       	rjmp	.+180    	; 0x2106 <V2P_RunStateMachine+0x11e>
    2052:	16 30       	cpi	r17, 0x06	; 6
    2054:	70 f4       	brcc	.+28     	; 0x2072 <V2P_RunStateMachine+0x8a>
    2056:	12 30       	cpi	r17, 0x02	; 2
    2058:	69 f1       	breq	.+90     	; 0x20b4 <V2P_RunStateMachine+0xcc>
    205a:	13 30       	cpi	r17, 0x03	; 3
    205c:	28 f4       	brcc	.+10     	; 0x2068 <V2P_RunStateMachine+0x80>
    205e:	11 23       	and	r17, r17
    2060:	b1 f0       	breq	.+44     	; 0x208e <V2P_RunStateMachine+0xa6>
    2062:	11 30       	cpi	r17, 0x01	; 1
    2064:	e9 f6       	brne	.-70     	; 0x2020 <V2P_RunStateMachine+0x38>
    2066:	20 c0       	rjmp	.+64     	; 0x20a8 <V2P_RunStateMachine+0xc0>
    2068:	13 30       	cpi	r17, 0x03	; 3
    206a:	69 f1       	breq	.+90     	; 0x20c6 <V2P_RunStateMachine+0xde>
    206c:	14 30       	cpi	r17, 0x04	; 4
    206e:	c1 f6       	brne	.-80     	; 0x2020 <V2P_RunStateMachine+0x38>
    2070:	35 c0       	rjmp	.+106    	; 0x20dc <V2P_RunStateMachine+0xf4>
    2072:	18 30       	cpi	r17, 0x08	; 8
    2074:	09 f4       	brne	.+2      	; 0x2078 <V2P_RunStateMachine+0x90>
    2076:	f4 c0       	rjmp	.+488    	; 0x2260 <V2P_RunStateMachine+0x278>
    2078:	19 30       	cpi	r17, 0x09	; 9
    207a:	30 f4       	brcc	.+12     	; 0x2088 <V2P_RunStateMachine+0xa0>
    207c:	16 30       	cpi	r17, 0x06	; 6
    207e:	09 f4       	brne	.+2      	; 0x2082 <V2P_RunStateMachine+0x9a>
    2080:	49 c0       	rjmp	.+146    	; 0x2114 <V2P_RunStateMachine+0x12c>
    2082:	17 30       	cpi	r17, 0x07	; 7
    2084:	69 f6       	brne	.-102    	; 0x2020 <V2P_RunStateMachine+0x38>
    2086:	57 c0       	rjmp	.+174    	; 0x2136 <V2P_RunStateMachine+0x14e>
    2088:	1c 30       	cpi	r17, 0x0C	; 12
    208a:	50 f6       	brcc	.-108    	; 0x2020 <V2P_RunStateMachine+0x38>
    208c:	d6 c0       	rjmp	.+428    	; 0x223a <V2P_RunStateMachine+0x252>
    208e:	80 91 88 01 	lds	r24, 0x0188
    2092:	81 11       	cpse	r24, r1
    2094:	81 e0       	ldi	r24, 0x01	; 1
    2096:	18 2f       	mov	r17, r24
    2098:	f2 9b       	sbis	0x1e, 2	; 30
    209a:	c2 cf       	rjmp	.-124    	; 0x2020 <V2P_RunStateMachine+0x38>
    209c:	80 91 a8 02 	lds	r24, 0x02A8
    20a0:	88 23       	and	r24, r24
    20a2:	09 f0       	breq	.+2      	; 0x20a6 <V2P_RunStateMachine+0xbe>
    20a4:	bd cf       	rjmp	.-134    	; 0x2020 <V2P_RunStateMachine+0x38>
    20a6:	e6 c0       	rjmp	.+460    	; 0x2274 <V2P_RunStateMachine+0x28c>
    20a8:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    20ac:	8b 31       	cpi	r24, 0x1B	; 27
    20ae:	09 f0       	breq	.+2      	; 0x20b2 <V2P_RunStateMachine+0xca>
    20b0:	b6 cf       	rjmp	.-148    	; 0x201e <V2P_RunStateMachine+0x36>
    20b2:	b3 cf       	rjmp	.-154    	; 0x201a <V2P_RunStateMachine+0x32>
    20b4:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    20b8:	99 27       	eor	r25, r25
    20ba:	90 93 a5 02 	sts	0x02A5, r25
    20be:	80 93 a4 02 	sts	0x02A4, r24
    20c2:	13 e0       	ldi	r17, 0x03	; 3
    20c4:	ad cf       	rjmp	.-166    	; 0x2020 <V2P_RunStateMachine+0x38>
    20c6:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    20ca:	99 27       	eor	r25, r25
    20cc:	98 2f       	mov	r25, r24
    20ce:	88 27       	eor	r24, r24
    20d0:	90 93 a7 02 	sts	0x02A7, r25
    20d4:	80 93 a6 02 	sts	0x02A6, r24
    20d8:	14 e0       	ldi	r17, 0x04	; 4
    20da:	a2 cf       	rjmp	.-188    	; 0x2020 <V2P_RunStateMachine+0x38>
    20dc:	00 91 a6 02 	lds	r16, 0x02A6
    20e0:	10 91 a7 02 	lds	r17, 0x02A7
    20e4:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    20e8:	99 27       	eor	r25, r25
    20ea:	80 2b       	or	r24, r16
    20ec:	91 2b       	or	r25, r17
    20ee:	90 93 a7 02 	sts	0x02A7, r25
    20f2:	80 93 a6 02 	sts	0x02A6, r24
    20f6:	83 51       	subi	r24, 0x13	; 19
    20f8:	91 40       	sbci	r25, 0x01	; 1
    20fa:	08 f0       	brcs	.+2      	; 0x20fe <V2P_RunStateMachine+0x116>
    20fc:	90 cf       	rjmp	.-224    	; 0x201e <V2P_RunStateMachine+0x36>
    20fe:	15 e0       	ldi	r17, 0x05	; 5
    2100:	c0 e0       	ldi	r28, 0x00	; 0
    2102:	d0 e0       	ldi	r29, 0x00	; 0
    2104:	8d cf       	rjmp	.-230    	; 0x2020 <V2P_RunStateMachine+0x38>
    2106:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    210a:	8e 30       	cpi	r24, 0x0E	; 14
    210c:	09 f0       	breq	.+2      	; 0x2110 <V2P_RunStateMachine+0x128>
    210e:	87 cf       	rjmp	.-242    	; 0x201e <V2P_RunStateMachine+0x36>
    2110:	16 e0       	ldi	r17, 0x06	; 6
    2112:	86 cf       	rjmp	.-244    	; 0x2020 <V2P_RunStateMachine+0x38>
    2114:	80 91 a6 02 	lds	r24, 0x02A6
    2118:	90 91 a7 02 	lds	r25, 0x02A7
    211c:	c8 17       	cp	r28, r24
    211e:	d9 07       	cpc	r29, r25
    2120:	11 f4       	brne	.+4      	; 0x2126 <V2P_RunStateMachine+0x13e>
    2122:	17 e0       	ldi	r17, 0x07	; 7
    2124:	7d cf       	rjmp	.-262    	; 0x2020 <V2P_RunStateMachine+0x38>
    2126:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    212a:	fe 01       	movw	r30, r28
    212c:	ef 56       	subi	r30, 0x6F	; 111
    212e:	fe 4f       	sbci	r31, 0xFE	; 254
    2130:	80 83       	st	Z, r24
    2132:	21 96       	adiw	r28, 0x01	; 1
    2134:	75 cf       	rjmp	.-278    	; 0x2020 <V2P_RunStateMachine+0x38>
    2136:	80 91 8c 01 	lds	r24, 0x018C
    213a:	88 23       	and	r24, r24
    213c:	09 f0       	breq	.+2      	; 0x2140 <V2P_RunStateMachine+0x158>
    213e:	70 cf       	rjmp	.-288    	; 0x2020 <V2P_RunStateMachine+0x38>
    2140:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <V2P_GetChecksum>
    2144:	18 2f       	mov	r17, r24
    2146:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    214a:	18 17       	cp	r17, r24
    214c:	11 f0       	breq	.+4      	; 0x2152 <V2P_RunStateMachine+0x16a>
    214e:	1b e0       	ldi	r17, 0x0B	; 11
    2150:	67 cf       	rjmp	.-306    	; 0x2020 <V2P_RunStateMachine+0x38>
    2152:	80 91 91 01 	lds	r24, 0x0191
    2156:	84 30       	cpi	r24, 0x04	; 4
    2158:	38 f4       	brcc	.+14     	; 0x2168 <V2P_RunStateMachine+0x180>
    215a:	82 30       	cpi	r24, 0x02	; 2
    215c:	08 f0       	brcs	.+2      	; 0x2160 <V2P_RunStateMachine+0x178>
    215e:	66 c0       	rjmp	.+204    	; 0x222c <V2P_RunStateMachine+0x244>
    2160:	81 30       	cpi	r24, 0x01	; 1
    2162:	09 f0       	breq	.+2      	; 0x2166 <V2P_RunStateMachine+0x17e>
    2164:	66 c0       	rjmp	.+204    	; 0x2232 <V2P_RunStateMachine+0x24a>
    2166:	06 c0       	rjmp	.+12     	; 0x2174 <V2P_RunStateMachine+0x18c>
    2168:	86 30       	cpi	r24, 0x06	; 6
    216a:	01 f1       	breq	.+64     	; 0x21ac <V2P_RunStateMachine+0x1c4>
    216c:	87 30       	cpi	r24, 0x07	; 7
    216e:	09 f0       	breq	.+2      	; 0x2172 <V2P_RunStateMachine+0x18a>
    2170:	60 c0       	rjmp	.+192    	; 0x2232 <V2P_RunStateMachine+0x24a>
    2172:	12 c0       	rjmp	.+36     	; 0x2198 <V2P_RunStateMachine+0x1b0>
    2174:	8b e0       	ldi	r24, 0x0B	; 11
    2176:	90 e0       	ldi	r25, 0x00	; 0
    2178:	90 93 a7 02 	sts	0x02A7, r25
    217c:	80 93 a6 02 	sts	0x02A6, r24
    2180:	ea e0       	ldi	r30, 0x0A	; 10
    2182:	f4 e0       	ldi	r31, 0x04	; 4
    2184:	a1 e9       	ldi	r26, 0x91	; 145
    2186:	b1 e0       	ldi	r27, 0x01	; 1
    2188:	84 91       	lpm	r24, Z
    218a:	8d 93       	st	X+, r24
    218c:	31 96       	adiw	r30, 0x01	; 1
    218e:	81 e0       	ldi	r24, 0x01	; 1
    2190:	ac 39       	cpi	r26, 0x9C	; 156
    2192:	b8 07       	cpc	r27, r24
    2194:	c9 f7       	brne	.-14     	; 0x2188 <V2P_RunStateMachine+0x1a0>
    2196:	47 c0       	rjmp	.+142    	; 0x2226 <V2P_RunStateMachine+0x23e>
    2198:	82 e0       	ldi	r24, 0x02	; 2
    219a:	90 e0       	ldi	r25, 0x00	; 0
    219c:	90 93 a7 02 	sts	0x02A7, r25
    21a0:	80 93 a6 02 	sts	0x02A6, r24
    21a4:	80 ec       	ldi	r24, 0xC0	; 192
    21a6:	80 93 92 01 	sts	0x0192, r24
    21aa:	3d c0       	rjmp	.+122    	; 0x2226 <V2P_RunStateMachine+0x23e>
    21ac:	82 e0       	ldi	r24, 0x02	; 2
    21ae:	90 e0       	ldi	r25, 0x00	; 0
    21b0:	90 93 a7 02 	sts	0x02A7, r25
    21b4:	80 93 a6 02 	sts	0x02A6, r24
    21b8:	0e 94 fc 0e 	call	0x1df8	; 0x1df8 <V2P_CheckForExtendedAddress>
    21bc:	e0 90 94 01 	lds	r14, 0x0194
    21c0:	ff 24       	eor	r15, r15
    21c2:	00 27       	eor	r16, r16
    21c4:	11 27       	eor	r17, r17
    21c6:	10 2f       	mov	r17, r16
    21c8:	0f 2d       	mov	r16, r15
    21ca:	fe 2c       	mov	r15, r14
    21cc:	ee 24       	eor	r14, r14
    21ce:	20 91 92 01 	lds	r18, 0x0192
    21d2:	33 27       	eor	r19, r19
    21d4:	44 27       	eor	r20, r20
    21d6:	55 27       	eor	r21, r21
    21d8:	52 2f       	mov	r21, r18
    21da:	44 27       	eor	r20, r20
    21dc:	33 27       	eor	r19, r19
    21de:	22 27       	eor	r18, r18
    21e0:	80 91 93 01 	lds	r24, 0x0193
    21e4:	99 27       	eor	r25, r25
    21e6:	aa 27       	eor	r26, r26
    21e8:	bb 27       	eor	r27, r27
    21ea:	dc 01       	movw	r26, r24
    21ec:	99 27       	eor	r25, r25
    21ee:	88 27       	eor	r24, r24
    21f0:	28 2b       	or	r18, r24
    21f2:	39 2b       	or	r19, r25
    21f4:	4a 2b       	or	r20, r26
    21f6:	5b 2b       	or	r21, r27
    21f8:	80 91 95 01 	lds	r24, 0x0195
    21fc:	99 27       	eor	r25, r25
    21fe:	aa 27       	eor	r26, r26
    2200:	bb 27       	eor	r27, r27
    2202:	28 2b       	or	r18, r24
    2204:	39 2b       	or	r19, r25
    2206:	4a 2b       	or	r20, r26
    2208:	5b 2b       	or	r21, r27
    220a:	e2 2a       	or	r14, r18
    220c:	f3 2a       	or	r15, r19
    220e:	04 2b       	or	r16, r20
    2210:	15 2b       	or	r17, r21
    2212:	e0 92 a9 02 	sts	0x02A9, r14
    2216:	f0 92 aa 02 	sts	0x02AA, r15
    221a:	00 93 ab 02 	sts	0x02AB, r16
    221e:	10 93 ac 02 	sts	0x02AC, r17
    2222:	10 92 92 01 	sts	0x0192, r1
    2226:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <V2P_SendPacket>
    222a:	05 c0       	rjmp	.+10     	; 0x2236 <V2P_RunStateMachine+0x24e>
    222c:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <V2P_GetSetParamater>
    2230:	02 c0       	rjmp	.+4      	; 0x2236 <V2P_RunStateMachine+0x24e>
    2232:	f6 01       	movw	r30, r12
    2234:	09 95       	icall
    2236:	18 e0       	ldi	r17, 0x08	; 8
    2238:	f3 ce       	rjmp	.-538    	; 0x2020 <V2P_RunStateMachine+0x38>
    223a:	1b 30       	cpi	r17, 0x0B	; 11
    223c:	11 f4       	brne	.+4      	; 0x2242 <V2P_RunStateMachine+0x25a>
    223e:	81 ec       	ldi	r24, 0xC1	; 193
    2240:	05 c0       	rjmp	.+10     	; 0x224c <V2P_RunStateMachine+0x264>
    2242:	1a 30       	cpi	r17, 0x0A	; 10
    2244:	11 f4       	brne	.+4      	; 0x224a <V2P_RunStateMachine+0x262>
    2246:	80 e8       	ldi	r24, 0x80	; 128
    2248:	01 c0       	rjmp	.+2      	; 0x224c <V2P_RunStateMachine+0x264>
    224a:	80 ec       	ldi	r24, 0xC0	; 192
    224c:	80 93 92 01 	sts	0x0192, r24
    2250:	82 e0       	ldi	r24, 0x02	; 2
    2252:	90 e0       	ldi	r25, 0x00	; 0
    2254:	90 93 a7 02 	sts	0x02A7, r25
    2258:	80 93 a6 02 	sts	0x02A6, r24
    225c:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <V2P_SendPacket>
    2260:	10 92 8c 01 	sts	0x018C, r1
    2264:	0e 94 d9 0b 	call	0x17b2	; 0x17b2 <BUFF_InitialiseBuffer>
    2268:	10 92 b0 00 	sts	0x00B0, r1
    226c:	10 92 70 00 	sts	0x0070, r1
    2270:	10 e0       	ldi	r17, 0x00	; 0
    2272:	d6 ce       	rjmp	.-596    	; 0x2020 <V2P_RunStateMachine+0x38>
    2274:	80 e8       	ldi	r24, 0x80	; 128
    2276:	80 93 61 00 	sts	0x0061, r24
    227a:	83 e0       	ldi	r24, 0x03	; 3
    227c:	80 93 61 00 	sts	0x0061, r24
    2280:	10 92 c1 00 	sts	0x00C1, r1
    2284:	0e 94 40 0c 	call	0x1880	; 0x1880 <TOUT_SetupSleepTimer>
    2288:	df 91       	pop	r29
    228a:	cf 91       	pop	r28
    228c:	1f 91       	pop	r17
    228e:	0f 91       	pop	r16
    2290:	ff 90       	pop	r15
    2292:	ef 90       	pop	r14
    2294:	df 90       	pop	r13
    2296:	cf 90       	pop	r12
    2298:	08 95       	ret

0000229a <ISPCC_PollForProgComplete>:
	}
}

void ISPCC_PollForProgComplete(const uint8_t PollData, uint16_t PollAddr)
{
    229a:	1f 93       	push	r17
    229c:	cf 93       	push	r28
    229e:	df 93       	push	r29
    22a0:	eb 01       	movw	r28, r22
	uint8_t PollType;
	uint8_t ProgCommand;

	if (PollData & ISPCC_PROG_MODE_PAGE)
    22a2:	99 27       	eor	r25, r25
    22a4:	80 ff       	sbrs	r24, 0
    22a6:	08 c0       	rjmp	.+16     	; 0x22b8 <ISPCC_PollForProgComplete+0x1e>
	   PollType = ((PollData & ISPCC_PAGE_POLLTYPE_MASK) >> ISPCC_PAGE_POLLTYPE_MASKSHIFT);
    22a8:	80 77       	andi	r24, 0x70	; 112
    22aa:	90 70       	andi	r25, 0x00	; 0
    22ac:	34 e0       	ldi	r19, 0x04	; 4
    22ae:	95 95       	asr	r25
    22b0:	87 95       	ror	r24
    22b2:	3a 95       	dec	r19
    22b4:	e1 f7       	brne	.-8      	; 0x22ae <ISPCC_PollForProgComplete+0x14>
    22b6:	04 c0       	rjmp	.+8      	; 0x22c0 <ISPCC_PollForProgComplete+0x26>
	else
	   PollType = ((PollData & ISPCC_WORD_POLLTYPE_MASK) >> ISPCC_WORD_POLLTYPE_MASKSHIFT);	
    22b8:	8e 70       	andi	r24, 0x0E	; 14
    22ba:	90 70       	andi	r25, 0x00	; 0
    22bc:	95 95       	asr	r25
    22be:	87 95       	ror	r24

	switch (PollType & ISPCC_POLLTYPE_MASK)
    22c0:	99 27       	eor	r25, r25
    22c2:	87 70       	andi	r24, 0x07	; 7
    22c4:	90 70       	andi	r25, 0x00	; 0
    22c6:	82 30       	cpi	r24, 0x02	; 2
    22c8:	91 05       	cpc	r25, r1
    22ca:	19 f0       	breq	.+6      	; 0x22d2 <ISPCC_PollForProgComplete+0x38>
    22cc:	04 97       	sbiw	r24, 0x04	; 4
    22ce:	41 f5       	brne	.+80     	; 0x2320 <ISPCC_PollForProgComplete+0x86>
    22d0:	1c c0       	rjmp	.+56     	; 0x230a <ISPCC_PollForProgComplete+0x70>
	{
		case ISPCC_POLLTYPE_DATA:
			ProgCommand = PacketBytes[7];
    22d2:	10 91 98 01 	lds	r17, 0x0198
			
			if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP) // Flash uses word addresses
    22d6:	80 91 91 01 	lds	r24, 0x0191
    22da:	83 31       	cpi	r24, 0x13	; 19
    22dc:	41 f4       	brne	.+16     	; 0x22ee <ISPCC_PollForProgComplete+0x54>
			{
				ProgCommand  |= ((PollAddr & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ);
    22de:	c0 ff       	sbrs	r28, 0
    22e0:	02 c0       	rjmp	.+4      	; 0x22e6 <ISPCC_PollForProgComplete+0x4c>
    22e2:	88 e0       	ldi	r24, 0x08	; 8
    22e4:	01 c0       	rjmp	.+2      	; 0x22e8 <ISPCC_PollForProgComplete+0x4e>
    22e6:	80 e0       	ldi	r24, 0x00	; 0
    22e8:	18 2b       	or	r17, r24
				PollAddr    >>= 1;
    22ea:	d6 95       	lsr	r29
    22ec:	c7 95       	ror	r28
			}

			do
			{
				USI_SPITransmit(ProgCommand);
    22ee:	81 2f       	mov	r24, r17
    22f0:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
				USI_SPITransmitWord(PollAddr);
    22f4:	ce 01       	movw	r24, r28
    22f6:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
			}
			while (USI_SPITransmit(0x00) == PacketBytes[8]);
    22fa:	80 e0       	ldi	r24, 0x00	; 0
    22fc:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    2300:	90 91 99 01 	lds	r25, 0x0199
    2304:	89 17       	cp	r24, r25
    2306:	81 f4       	brne	.+32     	; 0x2328 <ISPCC_PollForProgComplete+0x8e>
    2308:	f2 cf       	rjmp	.-28     	; 0x22ee <ISPCC_PollForProgComplete+0x54>
						
			break;
		case ISPCC_POLLTYPE_READY:
			do
			   USI_SPITransmitWord(0xF000);
    230a:	80 e0       	ldi	r24, 0x00	; 0
    230c:	90 ef       	ldi	r25, 0xF0	; 240
    230e:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
			while (USI_SPITransmitWord(0x0000) & ISPCC_POLL_BUSYFLAG);
    2312:	80 e0       	ldi	r24, 0x00	; 0
    2314:	90 e0       	ldi	r25, 0x00	; 0
    2316:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
    231a:	80 ff       	sbrs	r24, 0
    231c:	05 c0       	rjmp	.+10     	; 0x2328 <ISPCC_PollForProgComplete+0x8e>
    231e:	f5 cf       	rjmp	.-22     	; 0x230a <ISPCC_PollForProgComplete+0x70>

			break;
		default:                                      // Default is Wait polling
			MAIN_Delay1MS(PacketBytes[4]);	
    2320:	80 91 95 01 	lds	r24, 0x0195
    2324:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2328:	df 91       	pop	r29
    232a:	cf 91       	pop	r28
    232c:	1f 91       	pop	r17
    232e:	08 95       	ret

00002330 <ISPCC_ProgramChip>:
    2330:	4f 92       	push	r4
    2332:	5f 92       	push	r5
    2334:	6f 92       	push	r6
    2336:	7f 92       	push	r7
    2338:	8f 92       	push	r8
    233a:	9f 92       	push	r9
    233c:	af 92       	push	r10
    233e:	bf 92       	push	r11
    2340:	cf 92       	push	r12
    2342:	df 92       	push	r13
    2344:	ef 92       	push	r14
    2346:	ff 92       	push	r15
    2348:	0f 93       	push	r16
    234a:	1f 93       	push	r17
    234c:	cf 93       	push	r28
    234e:	df 93       	push	r29
    2350:	b0 90 94 01 	lds	r11, 0x0194
    2354:	a0 90 96 01 	lds	r10, 0x0196
    2358:	40 90 a9 02 	lds	r4, 0x02A9
    235c:	50 90 aa 02 	lds	r5, 0x02AA
    2360:	60 90 ab 02 	lds	r6, 0x02AB
    2364:	70 90 ac 02 	lds	r7, 0x02AC
    2368:	80 91 92 01 	lds	r24, 0x0192
    236c:	99 27       	eor	r25, r25
    236e:	98 2e       	mov	r9, r24
    2370:	88 24       	eor	r8, r8
    2372:	80 91 93 01 	lds	r24, 0x0193
    2376:	99 27       	eor	r25, r25
    2378:	88 2a       	or	r8, r24
    237a:	99 2a       	or	r9, r25
    237c:	e0 90 91 01 	lds	r14, 0x0191
    2380:	b0 fc       	sbrc	r11, 0
    2382:	09 c0       	rjmp	.+18     	; 0x2396 <ISPCC_ProgramChip+0x66>
    2384:	c0 e0       	ldi	r28, 0x00	; 0
    2386:	d0 e0       	ldi	r29, 0x00	; 0
    2388:	cc 24       	eor	r12, r12
    238a:	dd 24       	eor	r13, r13
    238c:	7b e9       	ldi	r23, 0x9B	; 155
    238e:	67 2e       	mov	r6, r23
    2390:	71 e0       	ldi	r23, 0x01	; 1
    2392:	77 2e       	mov	r7, r23
    2394:	ac c0       	rjmp	.+344    	; 0x24ee <ISPCC_ProgramChip+0x1be>
    2396:	c0 e0       	ldi	r28, 0x00	; 0
    2398:	d0 e0       	ldi	r29, 0x00	; 0
    239a:	00 e0       	ldi	r16, 0x00	; 0
    239c:	10 e0       	ldi	r17, 0x00	; 0
    239e:	6b e9       	ldi	r22, 0x9B	; 155
    23a0:	c6 2e       	mov	r12, r22
    23a2:	61 e0       	ldi	r22, 0x01	; 1
    23a4:	d6 2e       	mov	r13, r22
    23a6:	41 c0       	rjmp	.+130    	; 0x242a <ISPCC_ProgramChip+0xfa>
    23a8:	f6 01       	movw	r30, r12
    23aa:	f0 80       	ld	r15, Z
    23ac:	f3 e1       	ldi	r31, 0x13	; 19
    23ae:	ef 16       	cp	r14, r31
    23b0:	39 f4       	brne	.+14     	; 0x23c0 <ISPCC_ProgramChip+0x90>
    23b2:	00 ff       	sbrs	r16, 0
    23b4:	02 c0       	rjmp	.+4      	; 0x23ba <ISPCC_ProgramChip+0x8a>
    23b6:	88 e0       	ldi	r24, 0x08	; 8
    23b8:	01 c0       	rjmp	.+2      	; 0x23bc <ISPCC_ProgramChip+0x8c>
    23ba:	80 e0       	ldi	r24, 0x00	; 0
    23bc:	8a 29       	or	r24, r10
    23be:	01 c0       	rjmp	.+2      	; 0x23c2 <ISPCC_ProgramChip+0x92>
    23c0:	8a 2d       	mov	r24, r10
    23c2:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    23c6:	80 91 a9 02 	lds	r24, 0x02A9
    23ca:	90 91 aa 02 	lds	r25, 0x02AA
    23ce:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
    23d2:	8f 2d       	mov	r24, r15
    23d4:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    23d8:	20 97       	sbiw	r28, 0x00	; 0
    23da:	d9 f4       	brne	.+54     	; 0x2412 <ISPCC_ProgramChip+0xe2>
    23dc:	80 91 99 01 	lds	r24, 0x0199
    23e0:	8f 15       	cp	r24, r15
    23e2:	b9 f0       	breq	.+46     	; 0x2412 <ISPCC_ProgramChip+0xe2>
    23e4:	83 e1       	ldi	r24, 0x13	; 19
    23e6:	e8 16       	cp	r14, r24
    23e8:	49 f0       	breq	.+18     	; 0x23fc <ISPCC_ProgramChip+0xcc>
    23ea:	e5 e1       	ldi	r30, 0x15	; 21
    23ec:	ee 16       	cp	r14, r30
    23ee:	89 f4       	brne	.+34     	; 0x2412 <ISPCC_ProgramChip+0xe2>
    23f0:	80 91 9a 01 	lds	r24, 0x019A
    23f4:	8f 15       	cp	r24, r15
    23f6:	09 f0       	breq	.+2      	; 0x23fa <ISPCC_ProgramChip+0xca>
    23f8:	7f c0       	rjmp	.+254    	; 0x24f8 <ISPCC_ProgramChip+0x1c8>
    23fa:	0b c0       	rjmp	.+22     	; 0x2412 <ISPCC_ProgramChip+0xe2>
    23fc:	c0 91 a9 02 	lds	r28, 0x02A9
    2400:	d0 91 aa 02 	lds	r29, 0x02AA
    2404:	cc 0f       	add	r28, r28
    2406:	dd 1f       	adc	r29, r29
    2408:	c8 01       	movw	r24, r16
    240a:	81 70       	andi	r24, 0x01	; 1
    240c:	90 70       	andi	r25, 0x00	; 0
    240e:	c8 0f       	add	r28, r24
    2410:	d9 1f       	adc	r29, r25
    2412:	00 fd       	sbrc	r16, 0
    2414:	03 c0       	rjmp	.+6      	; 0x241c <ISPCC_ProgramChip+0xec>
    2416:	f5 e1       	ldi	r31, 0x15	; 21
    2418:	ef 16       	cp	r14, r31
    241a:	11 f4       	brne	.+4      	; 0x2420 <ISPCC_ProgramChip+0xf0>
    241c:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <V2P_IncrementCurrAddress>
    2420:	0f 5f       	subi	r16, 0xFF	; 255
    2422:	1f 4f       	sbci	r17, 0xFF	; 255
    2424:	08 94       	sec
    2426:	c1 1c       	adc	r12, r1
    2428:	d1 1c       	adc	r13, r1
    242a:	08 15       	cp	r16, r8
    242c:	19 05       	cpc	r17, r9
    242e:	09 f0       	breq	.+2      	; 0x2432 <ISPCC_ProgramChip+0x102>
    2430:	bb cf       	rjmp	.-138    	; 0x23a8 <ISPCC_ProgramChip+0x78>
    2432:	b7 fe       	sbrs	r11, 7
    2434:	6c c0       	rjmp	.+216    	; 0x250e <ISPCC_ProgramChip+0x1de>
    2436:	80 91 97 01 	lds	r24, 0x0197
    243a:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    243e:	c2 01       	movw	r24, r4
    2440:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
    2444:	80 e0       	ldi	r24, 0x00	; 0
    2446:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    244a:	20 97       	sbiw	r28, 0x00	; 0
    244c:	11 f0       	breq	.+4      	; 0x2452 <ISPCC_ProgramChip+0x122>
    244e:	8b 2d       	mov	r24, r11
    2450:	03 c0       	rjmp	.+6      	; 0x2458 <ISPCC_ProgramChip+0x128>
    2452:	8b 2d       	mov	r24, r11
    2454:	8f 78       	andi	r24, 0x8F	; 143
    2456:	80 61       	ori	r24, 0x10	; 16
    2458:	be 01       	movw	r22, r28
    245a:	0e 94 4d 11 	call	0x229a	; 0x229a <ISPCC_PollForProgComplete>
    245e:	57 c0       	rjmp	.+174    	; 0x250e <ISPCC_ProgramChip+0x1de>
    2460:	f3 01       	movw	r30, r6
    2462:	10 81       	ld	r17, Z
    2464:	f3 e1       	ldi	r31, 0x13	; 19
    2466:	ef 16       	cp	r14, r31
    2468:	39 f4       	brne	.+14     	; 0x2478 <ISPCC_ProgramChip+0x148>
    246a:	c0 fe       	sbrs	r12, 0
    246c:	02 c0       	rjmp	.+4      	; 0x2472 <ISPCC_ProgramChip+0x142>
    246e:	88 e0       	ldi	r24, 0x08	; 8
    2470:	01 c0       	rjmp	.+2      	; 0x2474 <ISPCC_ProgramChip+0x144>
    2472:	80 e0       	ldi	r24, 0x00	; 0
    2474:	8a 29       	or	r24, r10
    2476:	01 c0       	rjmp	.+2      	; 0x247a <ISPCC_ProgramChip+0x14a>
    2478:	8a 2d       	mov	r24, r10
    247a:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    247e:	80 91 a9 02 	lds	r24, 0x02A9
    2482:	90 91 aa 02 	lds	r25, 0x02AA
    2486:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
    248a:	81 2f       	mov	r24, r17
    248c:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    2490:	80 91 99 01 	lds	r24, 0x0199
    2494:	81 17       	cp	r24, r17
    2496:	b9 f0       	breq	.+46     	; 0x24c6 <ISPCC_ProgramChip+0x196>
    2498:	83 e1       	ldi	r24, 0x13	; 19
    249a:	e8 16       	cp	r14, r24
    249c:	41 f0       	breq	.+16     	; 0x24ae <ISPCC_ProgramChip+0x17e>
    249e:	e5 e1       	ldi	r30, 0x15	; 21
    24a0:	ee 16       	cp	r14, r30
    24a2:	89 f4       	brne	.+34     	; 0x24c6 <ISPCC_ProgramChip+0x196>
    24a4:	80 91 9a 01 	lds	r24, 0x019A
    24a8:	81 17       	cp	r24, r17
    24aa:	59 f5       	brne	.+86     	; 0x2502 <ISPCC_ProgramChip+0x1d2>
    24ac:	0c c0       	rjmp	.+24     	; 0x24c6 <ISPCC_ProgramChip+0x196>
    24ae:	c0 91 a9 02 	lds	r28, 0x02A9
    24b2:	d0 91 aa 02 	lds	r29, 0x02AA
    24b6:	cc 0f       	add	r28, r28
    24b8:	dd 1f       	adc	r29, r29
    24ba:	c6 01       	movw	r24, r12
    24bc:	81 70       	andi	r24, 0x01	; 1
    24be:	90 70       	andi	r25, 0x00	; 0
    24c0:	c8 0f       	add	r28, r24
    24c2:	d9 1f       	adc	r29, r25
    24c4:	22 c0       	rjmp	.+68     	; 0x250a <ISPCC_ProgramChip+0x1da>
    24c6:	1b 2d       	mov	r17, r11
    24c8:	11 7f       	andi	r17, 0xF1	; 241
    24ca:	12 60       	ori	r17, 0x02	; 2
    24cc:	c0 fc       	sbrc	r12, 0
    24ce:	03 c0       	rjmp	.+6      	; 0x24d6 <ISPCC_ProgramChip+0x1a6>
    24d0:	f5 e1       	ldi	r31, 0x15	; 21
    24d2:	ef 16       	cp	r14, r31
    24d4:	11 f4       	brne	.+4      	; 0x24da <ISPCC_ProgramChip+0x1aa>
    24d6:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <V2P_IncrementCurrAddress>
    24da:	be 01       	movw	r22, r28
    24dc:	81 2f       	mov	r24, r17
    24de:	0e 94 4d 11 	call	0x229a	; 0x229a <ISPCC_PollForProgComplete>
    24e2:	08 94       	sec
    24e4:	c1 1c       	adc	r12, r1
    24e6:	d1 1c       	adc	r13, r1
    24e8:	08 94       	sec
    24ea:	61 1c       	adc	r6, r1
    24ec:	71 1c       	adc	r7, r1
    24ee:	c8 14       	cp	r12, r8
    24f0:	d9 04       	cpc	r13, r9
    24f2:	09 f0       	breq	.+2      	; 0x24f6 <ISPCC_ProgramChip+0x1c6>
    24f4:	b5 cf       	rjmp	.-150    	; 0x2460 <ISPCC_ProgramChip+0x130>
    24f6:	0b c0       	rjmp	.+22     	; 0x250e <ISPCC_ProgramChip+0x1de>
    24f8:	c0 91 a9 02 	lds	r28, 0x02A9
    24fc:	d0 91 aa 02 	lds	r29, 0x02AA
    2500:	88 cf       	rjmp	.-240    	; 0x2412 <ISPCC_ProgramChip+0xe2>
    2502:	c0 91 a9 02 	lds	r28, 0x02A9
    2506:	d0 91 aa 02 	lds	r29, 0x02AA
    250a:	1b 2d       	mov	r17, r11
    250c:	df cf       	rjmp	.-66     	; 0x24cc <ISPCC_ProgramChip+0x19c>
    250e:	df 91       	pop	r29
    2510:	cf 91       	pop	r28
    2512:	1f 91       	pop	r17
    2514:	0f 91       	pop	r16
    2516:	ff 90       	pop	r15
    2518:	ef 90       	pop	r14
    251a:	df 90       	pop	r13
    251c:	cf 90       	pop	r12
    251e:	bf 90       	pop	r11
    2520:	af 90       	pop	r10
    2522:	9f 90       	pop	r9
    2524:	8f 90       	pop	r8
    2526:	7f 90       	pop	r7
    2528:	6f 90       	pop	r6
    252a:	5f 90       	pop	r5
    252c:	4f 90       	pop	r4
    252e:	08 95       	ret

00002530 <ISPCC_EnterChipProgrammingMode>:
    2530:	ff 92       	push	r15
    2532:	0f 93       	push	r16
    2534:	1f 93       	push	r17
    2536:	00 91 96 01 	lds	r16, 0x0196
    253a:	10 91 95 01 	lds	r17, 0x0195
    253e:	81 b3       	in	r24, 0x11	; 17
    2540:	8f 7c       	andi	r24, 0xCF	; 207
    2542:	80 63       	ori	r24, 0x30	; 48
    2544:	81 bb       	out	0x11, r24	; 17
    2546:	80 91 93 01 	lds	r24, 0x0193
    254a:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    254e:	81 2f       	mov	r24, r17
    2550:	81 50       	subi	r24, 0x01	; 1
    2552:	84 36       	cpi	r24, 0x64	; 100
    2554:	08 f4       	brcc	.+2      	; 0x2558 <ISPCC_EnterChipProgrammingMode+0x28>
    2556:	40 c0       	rjmp	.+128    	; 0x25d8 <ISPCC_EnterChipProgrammingMode+0xa8>
    2558:	18 e1       	ldi	r17, 0x18	; 24
    255a:	3e c0       	rjmp	.+124    	; 0x25d8 <ISPCC_EnterChipProgrammingMode+0xa8>
    255c:	80 91 99 01 	lds	r24, 0x0199
    2560:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    2564:	80 2f       	mov	r24, r16
    2566:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    256a:	80 91 9a 01 	lds	r24, 0x019A
    256e:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    2572:	80 2f       	mov	r24, r16
    2574:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2578:	80 91 9b 01 	lds	r24, 0x019B
    257c:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    2580:	f8 2e       	mov	r15, r24
    2582:	80 2f       	mov	r24, r16
    2584:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2588:	80 91 98 01 	lds	r24, 0x0198
    258c:	83 30       	cpi	r24, 0x03	; 3
    258e:	29 f4       	brne	.+10     	; 0x259a <ISPCC_EnterChipProgrammingMode+0x6a>
    2590:	80 91 9c 01 	lds	r24, 0x019C
    2594:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    2598:	05 c0       	rjmp	.+10     	; 0x25a4 <ISPCC_EnterChipProgrammingMode+0x74>
    259a:	80 91 9c 01 	lds	r24, 0x019C
    259e:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    25a2:	f8 2e       	mov	r15, r24
    25a4:	80 91 98 01 	lds	r24, 0x0198
    25a8:	88 23       	and	r24, r24
    25aa:	21 f0       	breq	.+8      	; 0x25b4 <ISPCC_EnterChipProgrammingMode+0x84>
    25ac:	80 91 97 01 	lds	r24, 0x0197
    25b0:	f8 16       	cp	r15, r24
    25b2:	69 f4       	brne	.+26     	; 0x25ce <ISPCC_EnterChipProgrammingMode+0x9e>
    25b4:	80 2f       	mov	r24, r16
    25b6:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    25ba:	81 e0       	ldi	r24, 0x01	; 1
    25bc:	80 93 a8 02 	sts	0x02A8, r24
    25c0:	81 b3       	in	r24, 0x11	; 17
    25c2:	8f 7c       	andi	r24, 0xCF	; 207
    25c4:	80 62       	ori	r24, 0x20	; 32
    25c6:	81 bb       	out	0x11, r24	; 17
    25c8:	10 92 92 01 	sts	0x0192, r1
    25cc:	0e c0       	rjmp	.+28     	; 0x25ea <ISPCC_EnterChipProgrammingMode+0xba>
    25ce:	80 2f       	mov	r24, r16
    25d0:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    25d4:	0e 94 3e 0a 	call	0x147c	; 0x147c <USI_SPIToggleClock>
    25d8:	11 50       	subi	r17, 0x01	; 1
    25da:	00 f6       	brcc	.-128    	; 0x255c <ISPCC_EnterChipProgrammingMode+0x2c>
    25dc:	81 b3       	in	r24, 0x11	; 17
    25de:	8f 7c       	andi	r24, 0xCF	; 207
    25e0:	80 61       	ori	r24, 0x10	; 16
    25e2:	81 bb       	out	0x11, r24	; 17
    25e4:	80 ec       	ldi	r24, 0xC0	; 192
    25e6:	80 93 92 01 	sts	0x0192, r24
    25ea:	1f 91       	pop	r17
    25ec:	0f 91       	pop	r16
    25ee:	ff 90       	pop	r15
    25f0:	08 95       	ret

000025f2 <AICI_InterpretPacket>:

// ======================================================================================

void AICI_InterpretPacket(void)
{
    25f2:	df 92       	push	r13
    25f4:	ef 92       	push	r14
    25f6:	ff 92       	push	r15
    25f8:	0f 93       	push	r16
    25fa:	1f 93       	push	r17
    25fc:	cf 93       	push	r28
    25fe:	df 93       	push	r29
	switch (PacketBytes[0])
    2600:	80 91 91 01 	lds	r24, 0x0191
    2604:	86 31       	cpi	r24, 0x16	; 22
    2606:	09 f4       	brne	.+2      	; 0x260a <AICI_InterpretPacket+0x18>
    2608:	e5 c0       	rjmp	.+458    	; 0x27d4 <AICI_InterpretPacket+0x1e2>
    260a:	87 31       	cpi	r24, 0x17	; 23
    260c:	78 f4       	brcc	.+30     	; 0x262c <AICI_InterpretPacket+0x3a>
    260e:	82 31       	cpi	r24, 0x12	; 18
    2610:	09 f4       	brne	.+2      	; 0x2614 <AICI_InterpretPacket+0x22>
    2612:	52 c0       	rjmp	.+164    	; 0x26b8 <AICI_InterpretPacket+0xc6>
    2614:	83 31       	cpi	r24, 0x13	; 19
    2616:	30 f4       	brcc	.+12     	; 0x2624 <AICI_InterpretPacket+0x32>
    2618:	80 31       	cpi	r24, 0x10	; 16
    261a:	d9 f0       	breq	.+54     	; 0x2652 <AICI_InterpretPacket+0x60>
    261c:	81 31       	cpi	r24, 0x11	; 17
    261e:	09 f0       	breq	.+2      	; 0x2622 <AICI_InterpretPacket+0x30>
    2620:	2c c1       	rjmp	.+600    	; 0x287a <AICI_InterpretPacket+0x288>
    2622:	30 c0       	rjmp	.+96     	; 0x2684 <AICI_InterpretPacket+0x92>
    2624:	84 31       	cpi	r24, 0x14	; 20
    2626:	09 f0       	breq	.+2      	; 0x262a <AICI_InterpretPacket+0x38>
    2628:	1d c1       	rjmp	.+570    	; 0x2864 <AICI_InterpretPacket+0x272>
    262a:	d4 c0       	rjmp	.+424    	; 0x27d4 <AICI_InterpretPacket+0x1e2>
    262c:	89 31       	cpi	r24, 0x19	; 25
    262e:	09 f4       	brne	.+2      	; 0x2632 <AICI_InterpretPacket+0x40>
    2630:	bd c0       	rjmp	.+378    	; 0x27ac <AICI_InterpretPacket+0x1ba>
    2632:	8a 31       	cpi	r24, 0x1A	; 26
    2634:	38 f4       	brcc	.+14     	; 0x2644 <AICI_InterpretPacket+0x52>
    2636:	87 31       	cpi	r24, 0x17	; 23
    2638:	09 f4       	brne	.+2      	; 0x263c <AICI_InterpretPacket+0x4a>
    263a:	b8 c0       	rjmp	.+368    	; 0x27ac <AICI_InterpretPacket+0x1ba>
    263c:	88 31       	cpi	r24, 0x18	; 24
    263e:	09 f0       	breq	.+2      	; 0x2642 <AICI_InterpretPacket+0x50>
    2640:	1c c1       	rjmp	.+568    	; 0x287a <AICI_InterpretPacket+0x288>
    2642:	95 c0       	rjmp	.+298    	; 0x276e <AICI_InterpretPacket+0x17c>
    2644:	8d 31       	cpi	r24, 0x1D	; 29
    2646:	08 f4       	brcc	.+2      	; 0x264a <AICI_InterpretPacket+0x58>
    2648:	92 c0       	rjmp	.+292    	; 0x276e <AICI_InterpretPacket+0x17c>
    264a:	8d 31       	cpi	r24, 0x1D	; 29
    264c:	09 f0       	breq	.+2      	; 0x2650 <AICI_InterpretPacket+0x5e>
    264e:	15 c1       	rjmp	.+554    	; 0x287a <AICI_InterpretPacket+0x288>
    2650:	56 c0       	rjmp	.+172    	; 0x26fe <AICI_InterpretPacket+0x10c>
	{
		case AICB_CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
    2652:	82 e0       	ldi	r24, 0x02	; 2
    2654:	90 e0       	ldi	r25, 0x00	; 0
    2656:	90 93 a7 02 	sts	0x02A7, r25
    265a:	80 93 a6 02 	sts	0x02A6, r24
			
			USI_SPIInitMaster();
    265e:	0e 94 2e 0a 	call	0x145c	; 0x145c <USI_SPIInitMaster>

			MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);  // Pull the slave AVR's RESET line to active
    2662:	80 e0       	ldi	r24, 0x00	; 0
    2664:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
			ISPCC_EnterChipProgrammingMode();       // Run the Enter Programming Mode routine
    2668:	0e 94 98 12 	call	0x2530	; 0x2530 <ISPCC_EnterChipProgrammingMode>

			if (InProgrammingMode)
    266c:	80 91 a8 02 	lds	r24, 0x02A8
    2670:	88 23       	and	r24, r24
    2672:	19 f0       	breq	.+6      	; 0x267a <AICI_InterpretPacket+0x88>
			   LCD_puts_f(AVRISPModeMessage);
    2674:	86 e3       	ldi	r24, 0x36	; 54
    2676:	94 e0       	ldi	r25, 0x04	; 4
    2678:	02 c0       	rjmp	.+4      	; 0x267e <AICI_InterpretPacket+0x8c>
			else
			   LCD_puts_f(SyncErrorMessage);
    267a:	8b e2       	ldi	r24, 0x2B	; 43
    267c:	94 e0       	ldi	r25, 0x04	; 4
    267e:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
    2682:	04 c1       	rjmp	.+520    	; 0x288c <AICI_InterpretPacket+0x29a>
			
			break;
		case AICB_CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;
    2684:	82 e0       	ldi	r24, 0x02	; 2
    2686:	90 e0       	ldi	r25, 0x00	; 0
    2688:	90 93 a7 02 	sts	0x02A7, r25
    268c:	80 93 a6 02 	sts	0x02A6, r24

			MAIN_Delay1MS(PacketBytes[1]);           // Wait for the "PreDelay" amount specified in the packet
    2690:	80 91 92 01 	lds	r24, 0x0192
    2694:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Non programming mode = green status led
    2698:	81 b3       	in	r24, 0x11	; 17
    269a:	8f 7c       	andi	r24, 0xCF	; 207
    269c:	80 61       	ori	r24, 0x10	; 16
    269e:	81 bb       	out	0x11, r24	; 17
			InProgrammingMode = FALSE;
    26a0:	10 92 a8 02 	sts	0x02A8, r1
			MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run
    26a4:	81 e0       	ldi	r24, 0x01	; 1
    26a6:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
			MAIN_Delay1MS(PacketBytes[2]);           // Wait for the "PostDelay" amount specified in the packet
    26aa:	80 91 93 01 	lds	r24, 0x0193
    26ae:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
			
			USI_SPIOff();
    26b2:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <USI_SPIOff>
    26b6:	de c0       	rjmp	.+444    	; 0x2874 <AICI_InterpretPacket+0x282>

			PacketBytes[1] = AICB_STATUS_CMD_OK;     // Return OK

			break;
		case AICB_CMD_CHIP_ERASE_ISP:
			MessageSize = 2;
    26b8:	82 e0       	ldi	r24, 0x02	; 2
    26ba:	90 e0       	ldi	r25, 0x00	; 0
    26bc:	90 93 a7 02 	sts	0x02A7, r25
    26c0:	80 93 a6 02 	sts	0x02A6, r24
    26c4:	c4 e9       	ldi	r28, 0x94	; 148
    26c6:	d1 e0       	ldi	r29, 0x01	; 1
			
			for (uint8_t PacketB = 3; PacketB <= 6; PacketB++) // Send the erase commands to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    26c8:	89 91       	ld	r24, Y+
    26ca:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    26ce:	81 e0       	ldi	r24, 0x01	; 1
    26d0:	c8 39       	cpi	r28, 0x98	; 152
    26d2:	d8 07       	cpc	r29, r24
    26d4:	c9 f7       	brne	.-14     	; 0x26c8 <AICI_InterpretPacket+0xd6>

			if (PacketBytes[2])                       // Poll mode, value of 1 indicates a busy flag wait
    26d6:	80 91 93 01 	lds	r24, 0x0193
    26da:	88 23       	and	r24, r24
    26dc:	59 f0       	breq	.+22     	; 0x26f4 <AICI_InterpretPacket+0x102>
			{
				do
					USI_SPITransmitWord(0xF000);
    26de:	80 e0       	ldi	r24, 0x00	; 0
    26e0:	90 ef       	ldi	r25, 0xF0	; 240
    26e2:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
				while (USI_SPITransmitWord(0x0000) & 0x01);
    26e6:	80 e0       	ldi	r24, 0x00	; 0
    26e8:	90 e0       	ldi	r25, 0x00	; 0
    26ea:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
    26ee:	80 ff       	sbrs	r24, 0
    26f0:	c1 c0       	rjmp	.+386    	; 0x2874 <AICI_InterpretPacket+0x282>
    26f2:	f5 cf       	rjmp	.-22     	; 0x26de <AICI_InterpretPacket+0xec>
			}
			else                                      // Poll mode flag of 0 indicates a predefined delay
			{
				MAIN_Delay1MS(PacketBytes[1]);         // Wait the specified interval to ensure erase complete
    26f4:	80 91 92 01 	lds	r24, 0x0192
    26f8:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    26fc:	bb c0       	rjmp	.+374    	; 0x2874 <AICI_InterpretPacket+0x282>
			}
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Always return OK
			
			break;
		case AICB_CMD_SPI_MULTI:
				MessageSize = (3 + PacketBytes[2]);    // Number of recieved bytes, plus two OKs and the command byte
    26fe:	f0 90 93 01 	lds	r15, 0x0193
    2702:	8f 2d       	mov	r24, r15
    2704:	99 27       	eor	r25, r25
    2706:	03 96       	adiw	r24, 0x03	; 3
    2708:	90 93 a7 02 	sts	0x02A7, r25
    270c:	80 93 a6 02 	sts	0x02A6, r24
		
				uint8_t TxBytes      = PacketBytes[1]; // \. The packet data is overwritten during the transfer. Because
    2710:	d0 90 92 01 	lds	r13, 0x0192
				uint8_t RxStartByte  = PacketBytes[2]; // |  of this each data byte must be stored into temp variables
				uint8_t RxBytes      = PacketBytes[3]; // /  so that their contents are not lost.
    2714:	e0 90 94 01 	lds	r14, 0x0194
    2718:	11 e0       	ldi	r17, 0x01	; 1
    271a:	01 e0       	ldi	r16, 0x01	; 1
    271c:	12 c0       	rjmp	.+36     	; 0x2742 <AICI_InterpretPacket+0x150>
				uint8_t RxByteNum    = 1;
				uint8_t TxByteNum    = 1;
				uint8_t RecievedByte = 0;

				while (TxByteNum++ < TxBytes)          // Still bytes to transfer
    271e:	0f 5f       	subi	r16, 0xFF	; 255
				{
					RecievedByte = USI_SPITransmit(PacketBytes[3 + TxByteNum]); // Transmit the byte, store the answer
    2720:	e0 2f       	mov	r30, r16
    2722:	ff 27       	eor	r31, r31
    2724:	ef 56       	subi	r30, 0x6F	; 111
    2726:	fe 4f       	sbci	r31, 0xFE	; 254
    2728:	83 81       	ldd	r24, Z+3	; 0x03
    272a:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>

					if ((TxByteNum >= RxStartByte) && (RxByteNum < RxBytes))
    272e:	0f 15       	cp	r16, r15
    2730:	40 f0       	brcs	.+16     	; 0x2742 <AICI_InterpretPacket+0x150>
    2732:	1e 15       	cp	r17, r14
    2734:	30 f4       	brcc	.+12     	; 0x2742 <AICI_InterpretPacket+0x150>
					   PacketBytes[2 + RxByteNum++] = RecievedByte;
    2736:	e1 2f       	mov	r30, r17
    2738:	ff 27       	eor	r31, r31
    273a:	ef 56       	subi	r30, 0x6F	; 111
    273c:	fe 4f       	sbci	r31, 0xFE	; 254
    273e:	82 83       	std	Z+2, r24	; 0x02
    2740:	1f 5f       	subi	r17, 0xFF	; 255
    2742:	0d 15       	cp	r16, r13
    2744:	60 f3       	brcs	.-40     	; 0x271e <AICI_InterpretPacket+0x12c>
    2746:	06 c0       	rjmp	.+12     	; 0x2754 <AICI_InterpretPacket+0x162>
				}

				while (RxByteNum++ < RxBytes)                         // Still more bytes to recieve
				   PacketBytes[2 + RxByteNum] = USI_SPITransmit(0x00); // its answer to be recorded (or more bytes than sent need responses), send dummy bytes to fetch the response(s)
    2748:	80 e0       	ldi	r24, 0x00	; 0
    274a:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    274e:	cf 56       	subi	r28, 0x6F	; 111
    2750:	de 4f       	sbci	r29, 0xFE	; 254
    2752:	8a 83       	std	Y+2, r24	; 0x02
    2754:	1f 5f       	subi	r17, 0xFF	; 255
    2756:	81 2f       	mov	r24, r17
    2758:	81 50       	subi	r24, 0x01	; 1
    275a:	c1 2f       	mov	r28, r17
    275c:	dd 27       	eor	r29, r29
    275e:	8e 15       	cp	r24, r14
    2760:	98 f3       	brcs	.-26     	; 0x2748 <AICI_InterpretPacket+0x156>

				PacketBytes[1]             = AICB_STATUS_CMD_OK; // Data should be encompassed
    2762:	10 92 92 01 	sts	0x0192, r1
				PacketBytes[3 + RxByteNum] = AICB_STATUS_CMD_OK; //  by STATS_CMD_OKs
    2766:	cf 56       	subi	r28, 0x6F	; 111
    2768:	de 4f       	sbci	r29, 0xFE	; 254
    276a:	1b 82       	std	Y+3, r1	; 0x03
    276c:	8f c0       	rjmp	.+286    	; 0x288c <AICI_InterpretPacket+0x29a>

				break;
		case AICB_CMD_READ_SIGNATURE_ISP:
		case AICB_CMD_READ_FUSE_ISP:
		case AICB_CMD_READ_LOCK_ISP:
		case AICB_CMD_READ_OSCCAL_ISP:
			MessageSize = 4;
    276e:	84 e0       	ldi	r24, 0x04	; 4
    2770:	90 e0       	ldi	r25, 0x00	; 0
    2772:	90 93 a7 02 	sts	0x02A7, r25
    2776:	80 93 a6 02 	sts	0x02A6, r24
    277a:	c1 e0       	ldi	r28, 0x01	; 1
    277c:	d0 e0       	ldi	r29, 0x00	; 0
    277e:	03 e9       	ldi	r16, 0x93	; 147
    2780:	11 e0       	ldi	r17, 0x01	; 1
	
			for (uint8_t ByteNum = 1; ByteNum <= 4; ByteNum++)
			{
				uint8_t Response = USI_SPITransmit(PacketBytes[1 + ByteNum]); // Transmit the four signature request bytes
    2782:	f8 01       	movw	r30, r16
    2784:	81 91       	ld	r24, Z+
    2786:	8f 01       	movw	r16, r30
    2788:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    278c:	98 2f       	mov	r25, r24

				if (ByteNum == PacketBytes[1])         // If the current byte is the requested signature byte, save the reponse in the packet
    278e:	80 91 92 01 	lds	r24, 0x0192
    2792:	8c 17       	cp	r24, r28
    2794:	11 f4       	brne	.+4      	; 0x279a <AICI_InterpretPacket+0x1a8>
					PacketBytes[2] = Response;
    2796:	90 93 93 01 	sts	0x0193, r25
    279a:	21 96       	adiw	r28, 0x01	; 1
    279c:	c5 30       	cpi	r28, 0x05	; 5
    279e:	d1 05       	cpc	r29, r1
    27a0:	81 f7       	brne	.-32     	; 0x2782 <AICI_InterpretPacket+0x190>
			}

			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Data byte is encased in CMD_OKs
    27a2:	10 92 92 01 	sts	0x0192, r1
			PacketBytes[3] = AICB_STATUS_CMD_OK;       // Data byte is encased in CMD_OKs
    27a6:	10 92 94 01 	sts	0x0194, r1
    27aa:	70 c0       	rjmp	.+224    	; 0x288c <AICI_InterpretPacket+0x29a>

			break;
		case AICB_CMD_PROGRAM_FUSE_ISP:
		case AICB_CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;
    27ac:	83 e0       	ldi	r24, 0x03	; 3
    27ae:	90 e0       	ldi	r25, 0x00	; 0
    27b0:	90 93 a7 02 	sts	0x02A7, r25
    27b4:	80 93 a6 02 	sts	0x02A6, r24
    27b8:	c2 e9       	ldi	r28, 0x92	; 146
    27ba:	d1 e0       	ldi	r29, 0x01	; 1
			
			for (uint8_t PacketB = 1; PacketB <= 4; PacketB++) // Send the lock-byte values to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    27bc:	89 91       	ld	r24, Y+
    27be:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    27c2:	f1 e0       	ldi	r31, 0x01	; 1
    27c4:	c6 39       	cpi	r28, 0x96	; 150
    27c6:	df 07       	cpc	r29, r31
    27c8:	c9 f7       	brne	.-14     	; 0x27bc <AICI_InterpretPacket+0x1ca>

			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Two CMD_OKs are always returned
    27ca:	10 92 92 01 	sts	0x0192, r1
			PacketBytes[2] = AICB_STATUS_CMD_OK;       // Two CMD_OKs are always returned
    27ce:	10 92 93 01 	sts	0x0193, r1
    27d2:	5c c0       	rjmp	.+184    	; 0x288c <AICI_InterpretPacket+0x29a>

			break;
		case AICB_CMD_READ_FLASH_ISP:
		case AICB_CMD_READ_EEPROM_ISP:
			MessageSize = 0;                           // Here to prevent compiler from complaining if a var dec appears straight after a case

			uint8_t  ReadCommand = PacketBytes[3];
    27d4:	d0 90 94 01 	lds	r13, 0x0194
			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8) // Load in the number of bytes that is to
			                     | PacketBytes[2];                 // be read into a temp variable (MSB first)
    27d8:	80 91 92 01 	lds	r24, 0x0192
    27dc:	99 27       	eor	r25, r25
    27de:	d8 2f       	mov	r29, r24
    27e0:	cc 27       	eor	r28, r28
    27e2:	80 91 93 01 	lds	r24, 0x0193
    27e6:	99 27       	eor	r25, r25
    27e8:	c8 2b       	or	r28, r24
    27ea:	d9 2b       	or	r29, r25

			MessageSize = BytesToRead + 3;
    27ec:	23 96       	adiw	r28, 0x03	; 3
    27ee:	d0 93 a7 02 	sts	0x02A7, r29
    27f2:	c0 93 a6 02 	sts	0x02A6, r28
    27f6:	23 97       	sbiw	r28, 0x03	; 3
    27f8:	00 e0       	ldi	r16, 0x00	; 0
    27fa:	10 e0       	ldi	r17, 0x00	; 0
    27fc:	83 e9       	ldi	r24, 0x93	; 147
    27fe:	e8 2e       	mov	r14, r24
    2800:	81 e0       	ldi	r24, 0x01	; 1
    2802:	f8 2e       	mov	r15, r24
    2804:	26 c0       	rjmp	.+76     	; 0x2852 <AICI_InterpretPacket+0x260>

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
				if (PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)  // Flash read mode - word addresses so MSB/LSB masking nessesary
    2806:	80 91 91 01 	lds	r24, 0x0191
    280a:	84 31       	cpi	r24, 0x14	; 20
    280c:	39 f4       	brne	.+14     	; 0x281c <AICI_InterpretPacket+0x22a>
				{
					USI_SPITransmit(ReadCommand | ((ReadByte & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ));
    280e:	00 ff       	sbrs	r16, 0
    2810:	02 c0       	rjmp	.+4      	; 0x2816 <AICI_InterpretPacket+0x224>
    2812:	88 e0       	ldi	r24, 0x08	; 8
    2814:	01 c0       	rjmp	.+2      	; 0x2818 <AICI_InterpretPacket+0x226>
    2816:	80 e0       	ldi	r24, 0x00	; 0
    2818:	8d 29       	or	r24, r13
    281a:	01 c0       	rjmp	.+2      	; 0x281e <AICI_InterpretPacket+0x22c>
				}
				else                                       // EEPROM read mode, address is in bytes and so no masking nessesary
				{
					USI_SPITransmit(ReadCommand);
    281c:	8d 2d       	mov	r24, r13
    281e:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
				}
				
				USI_SPITransmitWord(CurrAddress);          // Transmit the current address to the slave AVR
    2822:	80 91 a9 02 	lds	r24, 0x02A9
    2826:	90 91 aa 02 	lds	r25, 0x02AA
    282a:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>

				PacketBytes[2 + ReadByte] = USI_SPITransmit(0x00); // Read in the byte stored at the requested location
    282e:	80 e0       	ldi	r24, 0x00	; 0
    2830:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    2834:	f7 01       	movw	r30, r14
    2836:	80 83       	st	Z, r24

				if ((ReadByte & 0x01) || (PacketBytes[0] == AICB_CMD_READ_EEPROM_ISP)) // Flash addresses are given in words; only increment on the odd byte if reading the flash.
    2838:	00 fd       	sbrc	r16, 0
    283a:	04 c0       	rjmp	.+8      	; 0x2844 <AICI_InterpretPacket+0x252>
    283c:	80 91 91 01 	lds	r24, 0x0191
    2840:	86 31       	cpi	r24, 0x16	; 22
    2842:	11 f4       	brne	.+4      	; 0x2848 <AICI_InterpretPacket+0x256>
				{
					V2P_IncrementCurrAddress();             // Increment the address counter
    2844:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <V2P_IncrementCurrAddress>
    2848:	0f 5f       	subi	r16, 0xFF	; 255
    284a:	1f 4f       	sbci	r17, 0xFF	; 255
    284c:	08 94       	sec
    284e:	e1 1c       	adc	r14, r1
    2850:	f1 1c       	adc	r15, r1
    2852:	0c 17       	cp	r16, r28
    2854:	1d 07       	cpc	r17, r29
    2856:	b9 f6       	brne	.-82     	; 0x2806 <AICI_InterpretPacket+0x214>
				}
				else
				{
					if ((CurrAddress & 0x00FF0000) & !(CurrAddress & 0x0000FFFF))
					{
						CurrAddress |= (1UL << 31);        // Set MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
						V2P_CheckForExtendedAddress();
					}
				}
			}
			
			PacketBytes[1]               = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    2858:	10 92 92 01 	sts	0x0192, r1
			PacketBytes[2 + BytesToRead] = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    285c:	cf 56       	subi	r28, 0x6F	; 111
    285e:	de 4f       	sbci	r29, 0xFE	; 254
    2860:	1a 82       	std	Y+2, r1	; 0x02
    2862:	14 c0       	rjmp	.+40     	; 0x288c <AICI_InterpretPacket+0x29a>

			break;
		case AICB_CMD_PROGRAM_FLASH_ISP:
		case AICB_CMD_PROGRAM_EEPROM_ISP:
			ISPCC_ProgramChip();                         // Program the bytes into the chip
    2864:	0e 94 98 11 	call	0x2330	; 0x2330 <ISPCC_ProgramChip>
			
			MessageSize = 2;
    2868:	82 e0       	ldi	r24, 0x02	; 2
    286a:	90 e0       	ldi	r25, 0x00	; 0
    286c:	90 93 a7 02 	sts	0x02A7, r25
    2870:	80 93 a6 02 	sts	0x02A6, r24

			PacketBytes[1] = AICB_STATUS_CMD_OK;
    2874:	10 92 92 01 	sts	0x0192, r1
    2878:	09 c0       	rjmp	.+18     	; 0x288c <AICI_InterpretPacket+0x29a>
			
			break;
		default:                                        // Unknown command, return error
			MessageSize = 1;
    287a:	81 e0       	ldi	r24, 0x01	; 1
    287c:	90 e0       	ldi	r25, 0x00	; 0
    287e:	90 93 a7 02 	sts	0x02A7, r25
    2882:	80 93 a6 02 	sts	0x02A6, r24
			
			PacketBytes[1] = AICB_STATUS_CMD_UNKNOWN;
    2886:	89 ec       	ldi	r24, 0xC9	; 201
    2888:	80 93 92 01 	sts	0x0192, r24
	}

	V2P_SendPacket();                                    // Send the response packet
    288c:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <V2P_SendPacket>
    2890:	df 91       	pop	r29
    2892:	cf 91       	pop	r28
    2894:	1f 91       	pop	r17
    2896:	0f 91       	pop	r16
    2898:	ff 90       	pop	r15
    289a:	ef 90       	pop	r14
    289c:	df 90       	pop	r13
    289e:	08 95       	ret

000028a0 <PM_SetupDFAddressCounters>:
	  return ProgDataSize;
}

void PM_SetupDFAddressCounters(const uint8_t Type)
{
    28a0:	80 93 02 01 	sts	0x0102, r24
	uint32_t StartAddress;
	
	MemoryType  = Type;
	GPageLength = 0;
    28a4:	10 92 b0 02 	sts	0x02B0, r1
    28a8:	10 92 af 02 	sts	0x02AF, r1
    28ac:	20 91 a9 02 	lds	r18, 0x02A9
    28b0:	30 91 aa 02 	lds	r19, 0x02AA
    28b4:	40 91 ab 02 	lds	r20, 0x02AB
    28b8:	50 91 ac 02 	lds	r21, 0x02AC

	if (Type == TYPE_FLASH)                                              // Type 1 = Flash
    28bc:	81 30       	cpi	r24, 0x01	; 1
    28be:	39 f4       	brne	.+14     	; 0x28ce <PM_SetupDFAddressCounters+0x2e>
	  StartAddress = (CurrAddress << 1);                                 // Convert flash word address to byte address
    28c0:	da 01       	movw	r26, r20
    28c2:	c9 01       	movw	r24, r18
    28c4:	88 0f       	add	r24, r24
    28c6:	99 1f       	adc	r25, r25
    28c8:	aa 1f       	adc	r26, r26
    28ca:	bb 1f       	adc	r27, r27
    28cc:	06 c0       	rjmp	.+12     	; 0x28da <PM_SetupDFAddressCounters+0x3a>
	else
	  StartAddress = CurrAddress + PM_EEPROM_OFFSET;                     // EEPROM uses byte addresses, and starts at the 257th kilobyte in Dataflash
    28ce:	da 01       	movw	r26, r20
    28d0:	c9 01       	movw	r24, r18
    28d2:	80 50       	subi	r24, 0x00	; 0
    28d4:	9c 4f       	sbci	r25, 0xFC	; 252
    28d6:	ab 4f       	sbci	r26, 0xFB	; 251
    28d8:	bf 4f       	sbci	r27, 0xFF	; 255
	
	DataflashInfo.CurrPageAddress = 0;
    28da:	10 92 44 01 	sts	0x0144, r1
    28de:	10 92 43 01 	sts	0x0143, r1
    28e2:	20 e0       	ldi	r18, 0x00	; 0
    28e4:	30 e0       	ldi	r19, 0x00	; 0
    28e6:	06 c0       	rjmp	.+12     	; 0x28f4 <PM_SetupDFAddressCounters+0x54>

	while (StartAddress >= DF_INTERNALDF_BUFFBYTES)                     // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DF_INTERNALDF_BUFFBYTES;                         // Subtract one page's worth of bytes from the desired address
    28e8:	88 50       	subi	r24, 0x08	; 8
    28ea:	91 40       	sbci	r25, 0x01	; 1
    28ec:	a0 40       	sbci	r26, 0x00	; 0
    28ee:	b0 40       	sbci	r27, 0x00	; 0
    28f0:	2f 5f       	subi	r18, 0xFF	; 255
    28f2:	3f 4f       	sbci	r19, 0xFF	; 255
    28f4:	88 30       	cpi	r24, 0x08	; 8
    28f6:	41 e0       	ldi	r20, 0x01	; 1
    28f8:	94 07       	cpc	r25, r20
    28fa:	40 e0       	ldi	r20, 0x00	; 0
    28fc:	a4 07       	cpc	r26, r20
    28fe:	40 e0       	ldi	r20, 0x00	; 0
    2900:	b4 07       	cpc	r27, r20
    2902:	90 f7       	brcc	.-28     	; 0x28e8 <PM_SetupDFAddressCounters+0x48>
    2904:	30 93 44 01 	sts	0x0144, r19
    2908:	20 93 43 01 	sts	0x0143, r18
		DataflashInfo.CurrPageAddress++;
	}
	
	DataflashInfo.CurrBuffByte = (uint16_t)StartAddress;                 // The buffer byte is the remainder
    290c:	90 93 46 01 	sts	0x0146, r25
    2910:	80 93 45 01 	sts	0x0145, r24
    2914:	08 95       	ret

00002916 <PM_CheckEndOfFuseLockData>:
}

void PM_StoreProgramByte(const uint8_t Data)
{
	if (DataflashInfo.CurrBuffByte == DF_INTERNALDF_BUFFBYTES)
	{
		DF_CopyBufferToFlashPage(DataflashInfo.CurrPageAddress++);
		DF_BufferWriteEnable(0);
		DataflashInfo.CurrBuffByte = 0;
	}
	
	SPI_SPITransmit(Data);                                               // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
	DataflashInfo.CurrBuffByte++;
	GPageLength++;
}

void PM_InterpretAVRISPPacket(void)
{
	uint8_t* EEPROMAddress;

	switch (PacketBytes[0])
	{
		case AICB_CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
						
			for (uint8_t PacketB = 0; PacketB <= 11; PacketB++)          // Save the enter programming mode command bytes
			  eeprom_write_byte(&EEPROMVars.EnterProgMode[PacketB], PacketBytes[PacketB]);
			
			InProgrammingMode = TRUE;                                    // Set the flag, prevent the user from exiting the V2P state machine			
			CurrentMode = PM_NO_SETUP;                                   // Clear the current mode variable

			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = AICB_STATUS_CMD_OK;

			break;			
		case AICB_CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;

			PM_CheckEndOfFuseLockData();                                 // Check for remaining bytes to be stored and general cleanup
			
			InProgrammingMode = FALSE;                                   // Clear the flag, allow the user to exit the V2P state machine

			DF_EnableDataflash(FALSE);

			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
			PacketBytes[1] = AICB_STATUS_CMD_OK;

			break;
		case AICB_CMD_READ_SIGNATURE_ISP:
			MessageSize = 4;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                          // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x01;                                        // Signature bytes all return "01" in storage mode
			PacketBytes[3] = AICB_STATUS_CMD_OK;                          // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_CHIP_ERASE_ISP:
			MessageSize = 2;

			for (uint8_t PacketB = 1; PacketB < 7; PacketB++)             // Save the erase chip command bytes to EEPROM
			  eeprom_write_byte(&EEPROMVars.EraseChip[PacketB], PacketBytes[PacketB]);

			for (uint8_t Byte = 0; Byte < 4; Byte++)                      // Clear the program and EEPROM size counters
			{
				eeprom_write_byte(&EEPROMVars.DataSize[Byte], 0x00);
				eeprom_write_byte(&EEPROMVars.EEPROMSize[Byte], 0x00);
			}
						
			eeprom_write_byte(&EEPROMVars.EraseCmdStored, TRUE);
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;
			
			break;
		case AICB_CMD_READ_OSCCAL_ISP:
			MessageSize = 4;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x00;                                      // Return 0x00 for the OSCCAL byte
			PacketBytes[3] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_READ_FUSE_ISP:
		case AICB_CMD_READ_LOCK_ISP:
			MessageSize = 4;
	
			if (CurrentMode != PM_LOCKFUSEBITS_READ)                    // First lock or fuse byte being read, set the EEPROM pointer
			{
				PM_CheckEndOfFuseLockData();                            // Check for remaining bytes to be stored and general cleanup
				
				DataflashInfo.CurrBuffByte = 0;
				CurrentMode  = PM_LOCKFUSEBITS_READ;
			}
			
			if (DataflashInfo.CurrBuffByte > eeprom_read_byte((PacketBytes[0] == AICB_CMD_READ_FUSE_ISP)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes))  // Trying to read more fuse/lock bytes than are stored in memory
			{
				PacketBytes[2] = 0xFF;                                 // Return 0xFF for the fuse/lock byte
			}
			else
			{
				PacketBytes[2] = eeprom_read_byte((uint8_t*)(((PacketBytes[0] == AICB_CMD_READ_FUSE_ISP)? &EEPROMVars.FuseBytes : &EEPROMVars.LockBytes) // Starting location
									                         + (DataflashInfo.CurrBuffByte << 2) + (PacketBytes[1] - 1)));                               // The start position of the actual fuse/lock byte to read (4 bytes each));
			}

			DataflashInfo.CurrBuffByte++;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                       // Data byte is encased in CMD_OKs
			PacketBytes[3] = AICB_STATUS_CMD_OK;                       // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_PROGRAM_FUSE_ISP:
		case AICB_CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;

			if (CurrentMode != PM_LOCKFUSEBITS_WRITE)                  // First lock or fuse byte being written, set the EEPROM pointer
			{
				CurrentMode   = PM_LOCKFUSEBITS_WRITE;
				DataflashInfo.CurrBuffByte  = 0;                       // CurrBuffByte is used to store the total fuse/lock bytes written
			}

			if (PacketBytes[0] == AICB_CMD_PROGRAM_FUSE_ISP)
			{
				EEPROMAddress = (uint8_t*)(&EEPROMVars.FuseBytes + (DataflashInfo.CurrBuffByte << 2));
				MemoryType    = TYPE_FUSE;
			}
			else
			{
				EEPROMAddress = (uint8_t*)(&EEPROMVars.LockBytes + (DataflashInfo.CurrBuffByte << 2));
				MemoryType    = TYPE_LOCK;
			}				
			
			if (DataflashInfo.CurrBuffByte < PM_MAX_FUSELOCKBITS)
			{
				for (uint8_t FLByte = 1; FLByte <= 4; FLByte++)
				{
					eeprom_write_byte(EEPROMAddress, PacketBytes[FLByte]);
					EEPROMAddress++;
				}

				DataflashInfo.CurrBuffByte++;                          // Increment the total fuse/lock bytes written counter
			}
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;                       // Two CMD_OKs are always returned
			PacketBytes[2] = AICB_STATUS_CMD_OK;                       // Two CMD_OKs are always returned

			break;
		case AICB_CMD_PROGRAM_FLASH_ISP:
		case AICB_CMD_PROGRAM_EEPROM_ISP:
			MessageSize = 2;

			if (CurrentMode != PM_DATAFLASH_WRITE)                      // First programming packet
			{
				if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP)       // Flash programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram; // Set the eeprom address to the Program command bytes location
					PM_SetupDFAddressCounters(TYPE_FLASH);
				}
				else                                                    // EEPROM programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;  // Set the eeprom address to the EEPROM command bytes location
					PM_SetupDFAddressCounters(TYPE_EEPROM);
				}
				
				DF_BufferWriteEnable(DataflashInfo.CurrBuffByte);
				CurrentMode = PM_DATAFLASH_WRITE;
				
				for (uint8_t B = 1; B < 10; B++)                        // Save the command bytes
				  eeprom_write_byte(EEPROMAddress, PacketBytes[B]);
			}

			uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
			                      | PacketBytes[2];

			for (uint16_t CurrByte = 0; CurrByte < BytesToWrite; CurrByte++)
				PM_StoreProgramByte(PacketBytes[10 + CurrByte]);

			if (!(GPageLength & PM_PAGELENGTH_FOUNDBIT) && (PacketBytes[3] & ISPCC_PROG_MODE_PAGEDONE) && GPageLength)
			{
				eeprom_write_word(((MemoryType == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength), GPageLength);
		
				GPageLength |= PM_PAGELENGTH_FOUNDBIT;                 // Bit 15 is used to indicate if the length has been found
			}

			PacketBytes[1] = AICB_STATUS_CMD_OK;
		
			break;
		case AICB_CMD_READ_FLASH_ISP:
		case AICB_CMD_READ_EEPROM_ISP:	
			if (CurrentMode != PM_DATAFLASH_READ)
			{
				PM_CheckEndOfFuseLockData();                           // Check for remaining bytes to be stored and general cleanup
				
				PM_SetupDFAddressCounters((PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);
				DF_ContinuousReadEnable(DataflashInfo.CurrPageAddress, DataflashInfo.CurrBuffByte);
				
				CurrentMode = PM_DATAFLASH_READ;
				CurrAddress = 0;
			}

			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8)    // \. Load in the number of bytes that is to
			                     | PacketBytes[2];                    // /  be read into a temp variable (MSB first)
						
			uint16_t BytesInMem  = PM_GetStoredDataSize((PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
			   PacketBytes[2 + ReadByte] = ((CurrAddress < BytesInMem)? SPI_SPITransmit(0x00) : 0xFF); // Read in the next dataflash byte if present
			   V2P_IncrementCurrAddress();
			}
			
			MessageSize = BytesToRead + 3;

			PacketBytes[1]               = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
			PacketBytes[2 + BytesToRead] = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
		
			break;
		default:
			MessageSize = 1;
			
			PacketBytes[1] = AICB_STATUS_CMD_UNKNOWN;
	}

	V2P_SendPacket();                                   // Send the response packet
}

void PM_CheckEndOfFuseLockData(void)
{
    2916:	cf 93       	push	r28
    2918:	df 93       	push	r29
    291a:	cd b7       	in	r28, 0x3d	; 61
    291c:	de b7       	in	r29, 0x3e	; 62
    291e:	24 97       	sbiw	r28, 0x04	; 4
    2920:	0f b6       	in	r0, 0x3f	; 63
    2922:	f8 94       	cli
    2924:	de bf       	out	0x3e, r29	; 62
    2926:	0f be       	out	0x3f, r0	; 63
    2928:	cd bf       	out	0x3d, r28	; 61
	if (CurrentMode == PM_DATAFLASH_WRITE)
    292a:	80 91 ae 02 	lds	r24, 0x02AE
    292e:	81 30       	cpi	r24, 0x01	; 1
    2930:	09 f0       	breq	.+2      	; 0x2934 <PM_CheckEndOfFuseLockData+0x1e>
    2932:	40 c0       	rjmp	.+128    	; 0x29b4 <PM_CheckEndOfFuseLockData+0x9e>
	{
		if (DataflashInfo.CurrBuffByte)                               // Data in the dataflash buffer, pending to be written
    2934:	80 91 45 01 	lds	r24, 0x0145
    2938:	90 91 46 01 	lds	r25, 0x0146
    293c:	89 2b       	or	r24, r25
    293e:	31 f0       	breq	.+12     	; 0x294c <PM_CheckEndOfFuseLockData+0x36>
		  DF_CopyBufferToFlashPage(DataflashInfo.CurrPageAddress);    // Save the remaining buffer bytes
    2940:	80 91 43 01 	lds	r24, 0x0143
    2944:	90 91 44 01 	lds	r25, 0x0144
    2948:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <DF_CopyBufferToFlashPage>

		uint32_t DataSize = ((DataflashInfo.CurrPageAddress * DF_INTERNALDF_BUFFBYTES) + DataflashInfo.CurrBuffByte);
    294c:	20 91 43 01 	lds	r18, 0x0143
    2950:	30 91 44 01 	lds	r19, 0x0144
    2954:	88 e0       	ldi	r24, 0x08	; 8
    2956:	91 e0       	ldi	r25, 0x01	; 1
    2958:	ac 01       	movw	r20, r24
    295a:	24 9f       	mul	r18, r20
    295c:	c0 01       	movw	r24, r0
    295e:	25 9f       	mul	r18, r21
    2960:	90 0d       	add	r25, r0
    2962:	34 9f       	mul	r19, r20
    2964:	90 0d       	add	r25, r0
    2966:	11 24       	eor	r1, r1
    2968:	20 91 45 01 	lds	r18, 0x0145
    296c:	30 91 46 01 	lds	r19, 0x0146
    2970:	82 0f       	add	r24, r18
    2972:	93 1f       	adc	r25, r19
    2974:	9c 01       	movw	r18, r24
    2976:	44 27       	eor	r20, r20
    2978:	55 27       	eor	r21, r21
    297a:	29 83       	std	Y+1, r18	; 0x01
    297c:	3a 83       	std	Y+2, r19	; 0x02
    297e:	4b 83       	std	Y+3, r20	; 0x03
    2980:	5c 83       	std	Y+4, r21	; 0x04

		if (MemoryType == TYPE_FLASH)
    2982:	80 91 02 01 	lds	r24, 0x0102
    2986:	fe 01       	movw	r30, r28
    2988:	31 96       	adiw	r30, 0x01	; 1
    298a:	81 30       	cpi	r24, 0x01	; 1
    298c:	21 f4       	brne	.+8      	; 0x2996 <PM_CheckEndOfFuseLockData+0x80>
            {
              uint8_t len;
              len = (uint8_t) n;

              asm volatile (
    298e:	84 e0       	ldi	r24, 0x04	; 4
    2990:	af e1       	ldi	r26, 0x1F	; 31
    2992:	b0 e0       	ldi	r27, 0x00	; 0
    2994:	0b c0       	rjmp	.+22     	; 0x29ac <PM_CheckEndOfFuseLockData+0x96>
		{
			eeprom_write_block((const void*)&DataSize, (void*)&EEPROMVars.DataSize, sizeof(uint32_t));
		}
		else
		{
			DataSize -= PM_EEPROM_OFFSET;                // Remove DataFlash EEPROM start offset
    2996:	20 50       	subi	r18, 0x00	; 0
    2998:	34 40       	sbci	r19, 0x04	; 4
    299a:	44 40       	sbci	r20, 0x04	; 4
    299c:	50 40       	sbci	r21, 0x00	; 0
    299e:	29 83       	std	Y+1, r18	; 0x01
    29a0:	3a 83       	std	Y+2, r19	; 0x02
    29a2:	4b 83       	std	Y+3, r20	; 0x03
    29a4:	5c 83       	std	Y+4, r21	; 0x04
            {
              uint8_t len;
              len = (uint8_t) n;

              asm volatile (
    29a6:	84 e0       	ldi	r24, 0x04	; 4
    29a8:	a3 e2       	ldi	r26, 0x23	; 35
    29aa:	b0 e0       	ldi	r27, 0x00	; 0
    29ac:	18 2e       	mov	r1, r24
    29ae:	0e 94 b0 1a 	call	0x3560	; 0x3560 <__eeprom_write_block_1F2021>
    29b2:	12 c0       	rjmp	.+36     	; 0x29d8 <PM_CheckEndOfFuseLockData+0xc2>
			eeprom_write_block((const void*)&DataSize, (void*)&EEPROMVars.EEPROMSize, sizeof(uint32_t));
		}
	}
	else if (CurrentMode == PM_LOCKFUSEBITS_WRITE)
    29b4:	83 30       	cpi	r24, 0x03	; 3
    29b6:	81 f4       	brne	.+32     	; 0x29d8 <PM_CheckEndOfFuseLockData+0xc2>
	{
		// CurrBuffByte stores the total number of fuse/lock bytes written in this case:
		eeprom_write_byte(((MemoryType == TYPE_FUSE)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes), DataflashInfo.CurrBuffByte);
    29b8:	20 91 45 01 	lds	r18, 0x0145
    29bc:	30 91 46 01 	lds	r19, 0x0146
    29c0:	80 91 02 01 	lds	r24, 0x0102
    29c4:	82 30       	cpi	r24, 0x02	; 2
    29c6:	19 f4       	brne	.+6      	; 0x29ce <PM_CheckEndOfFuseLockData+0xb8>
    29c8:	a3 e3       	ldi	r26, 0x33	; 51
    29ca:	b0 e0       	ldi	r27, 0x00	; 0
    29cc:	02 c0       	rjmp	.+4      	; 0x29d2 <PM_CheckEndOfFuseLockData+0xbc>
    29ce:	a4 e3       	ldi	r26, 0x34	; 52
    29d0:	b0 e0       	ldi	r27, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    29d2:	02 2e       	mov	r0, r18
    29d4:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
    29d8:	24 96       	adiw	r28, 0x04	; 4
    29da:	0f b6       	in	r0, 0x3f	; 63
    29dc:	f8 94       	cli
    29de:	de bf       	out	0x3e, r29	; 62
    29e0:	0f be       	out	0x3f, r0	; 63
    29e2:	cd bf       	out	0x3d, r28	; 61
    29e4:	df 91       	pop	r29
    29e6:	cf 91       	pop	r28
    29e8:	08 95       	ret

000029ea <PM_GetStoredDataSize>:
    29ea:	cf 93       	push	r28
    29ec:	df 93       	push	r29
    29ee:	cd b7       	in	r28, 0x3d	; 61
    29f0:	de b7       	in	r29, 0x3e	; 62
    29f2:	24 97       	sbiw	r28, 0x04	; 4
    29f4:	0f b6       	in	r0, 0x3f	; 63
    29f6:	f8 94       	cli
    29f8:	de bf       	out	0x3e, r29	; 62
    29fa:	0f be       	out	0x3f, r0	; 63
    29fc:	cd bf       	out	0x3d, r28	; 61
    29fe:	81 30       	cpi	r24, 0x01	; 1
    2a00:	19 f4       	brne	.+6      	; 0x2a08 <PM_GetStoredDataSize+0x1e>
    2a02:	af e1       	ldi	r26, 0x1F	; 31
    2a04:	b0 e0       	ldi	r27, 0x00	; 0
    2a06:	02 c0       	rjmp	.+4      	; 0x2a0c <PM_GetStoredDataSize+0x22>
    2a08:	a3 e2       	ldi	r26, 0x23	; 35
    2a0a:	b0 e0       	ldi	r27, 0x00	; 0
              /* Needed in order to truncate to 8 bit.  */
              uint8_t len;
              len = (uint8_t) n; 

              asm volatile (
    2a0c:	84 e0       	ldi	r24, 0x04	; 4
    2a0e:	fe 01       	movw	r30, r28
    2a10:	31 96       	adiw	r30, 0x01	; 1
    2a12:	18 2e       	mov	r1, r24
    2a14:	0e 94 95 1a 	call	0x352a	; 0x352a <__eeprom_read_block_1F2021>
    2a18:	69 81       	ldd	r22, Y+1	; 0x01
    2a1a:	7a 81       	ldd	r23, Y+2	; 0x02
    2a1c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a1e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a20:	6f 3f       	cpi	r22, 0xFF	; 255
    2a22:	2f ef       	ldi	r18, 0xFF	; 255
    2a24:	72 07       	cpc	r23, r18
    2a26:	2f ef       	ldi	r18, 0xFF	; 255
    2a28:	82 07       	cpc	r24, r18
    2a2a:	2f ef       	ldi	r18, 0xFF	; 255
    2a2c:	92 07       	cpc	r25, r18
    2a2e:	21 f4       	brne	.+8      	; 0x2a38 <PM_GetStoredDataSize+0x4e>
    2a30:	60 e0       	ldi	r22, 0x00	; 0
    2a32:	70 e0       	ldi	r23, 0x00	; 0
    2a34:	80 e0       	ldi	r24, 0x00	; 0
    2a36:	90 e0       	ldi	r25, 0x00	; 0
    2a38:	24 96       	adiw	r28, 0x04	; 4
    2a3a:	0f b6       	in	r0, 0x3f	; 63
    2a3c:	f8 94       	cli
    2a3e:	de bf       	out	0x3e, r29	; 62
    2a40:	0f be       	out	0x3f, r0	; 63
    2a42:	cd bf       	out	0x3d, r28	; 61
    2a44:	df 91       	pop	r29
    2a46:	cf 91       	pop	r28
    2a48:	08 95       	ret

00002a4a <PM_StoreProgramByte>:
    2a4a:	1f 93       	push	r17
    2a4c:	18 2f       	mov	r17, r24
    2a4e:	80 91 45 01 	lds	r24, 0x0145
    2a52:	90 91 46 01 	lds	r25, 0x0146
    2a56:	88 50       	subi	r24, 0x08	; 8
    2a58:	91 40       	sbci	r25, 0x01	; 1
    2a5a:	a1 f4       	brne	.+40     	; 0x2a84 <PM_StoreProgramByte+0x3a>
    2a5c:	80 91 43 01 	lds	r24, 0x0143
    2a60:	90 91 44 01 	lds	r25, 0x0144
    2a64:	01 96       	adiw	r24, 0x01	; 1
    2a66:	90 93 44 01 	sts	0x0144, r25
    2a6a:	80 93 43 01 	sts	0x0143, r24
    2a6e:	01 97       	sbiw	r24, 0x01	; 1
    2a70:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <DF_CopyBufferToFlashPage>
    2a74:	80 e0       	ldi	r24, 0x00	; 0
    2a76:	90 e0       	ldi	r25, 0x00	; 0
    2a78:	0e 94 c8 0a 	call	0x1590	; 0x1590 <DF_BufferWriteEnable>
    2a7c:	10 92 46 01 	sts	0x0146, r1
    2a80:	10 92 45 01 	sts	0x0145, r1
    2a84:	81 2f       	mov	r24, r17
    2a86:	0e 94 af 09 	call	0x135e	; 0x135e <SPI_SPITransmit>
    2a8a:	80 91 45 01 	lds	r24, 0x0145
    2a8e:	90 91 46 01 	lds	r25, 0x0146
    2a92:	01 96       	adiw	r24, 0x01	; 1
    2a94:	90 93 46 01 	sts	0x0146, r25
    2a98:	80 93 45 01 	sts	0x0145, r24
    2a9c:	80 91 af 02 	lds	r24, 0x02AF
    2aa0:	90 91 b0 02 	lds	r25, 0x02B0
    2aa4:	01 96       	adiw	r24, 0x01	; 1
    2aa6:	90 93 b0 02 	sts	0x02B0, r25
    2aaa:	80 93 af 02 	sts	0x02AF, r24
    2aae:	1f 91       	pop	r17
    2ab0:	08 95       	ret

00002ab2 <PM_SendFuseLockBytes>:
	}
}

void PM_SendFuseLockBytes(const uint8_t Type)
{
    2ab2:	ef 92       	push	r14
    2ab4:	ff 92       	push	r15
    2ab6:	0f 93       	push	r16
    2ab8:	1f 93       	push	r17
    2aba:	cf 93       	push	r28
    2abc:	df 93       	push	r29
	uint8_t  TotalBytes;
	uint8_t* EEPROMAddress;

	if (Type == TYPE_FUSE)
    2abe:	82 30       	cpi	r24, 0x02	; 2
    2ac0:	59 f4       	brne	.+22     	; 0x2ad8 <PM_SendFuseLockBytes+0x26>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2ac2:	43 e3       	ldi	r20, 0x33	; 51
    2ac4:	50 e0       	ldi	r21, 0x00	; 0
    2ac6:	da 01       	movw	r26, r20
    2ac8:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
    2acc:	80 2d       	mov	r24, r0
	{
		TotalBytes    = eeprom_read_byte(&EEPROMVars.TotalFuseBytes);
    2ace:	18 2f       	mov	r17, r24
    2ad0:	62 e0       	ldi	r22, 0x02	; 2
    2ad2:	e6 2e       	mov	r14, r22
    2ad4:	f1 2c       	mov	r15, r1
    2ad6:	0a c0       	rjmp	.+20     	; 0x2aec <PM_SendFuseLockBytes+0x3a>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2ad8:	44 e3       	ldi	r20, 0x34	; 52
    2ada:	50 e0       	ldi	r21, 0x00	; 0
    2adc:	da 01       	movw	r26, r20
    2ade:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
    2ae2:	80 2d       	mov	r24, r0
		EEPROMAddress = EEPROMVars.FuseBytes;
	}
	else
	{
		TotalBytes    = eeprom_read_byte(&EEPROMVars.TotalLockBytes);
    2ae4:	18 2f       	mov	r17, r24
    2ae6:	39 e2       	ldi	r19, 0x29	; 41
    2ae8:	e3 2e       	mov	r14, r19
    2aea:	f1 2c       	mov	r15, r1
    2aec:	e4 0e       	add	r14, r20
    2aee:	f5 1e       	adc	r15, r21
    2af0:	15 c0       	rjmp	.+42     	; 0x2b1c <PM_SendFuseLockBytes+0x6a>
    2af2:	e7 01       	movw	r28, r14
    2af4:	00 e0       	ldi	r16, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2af6:	de 01       	movw	r26, r28
    2af8:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
    2afc:	80 2d       	mov	r24, r0
		EEPROMAddress = EEPROMVars.LockBytes;	
	}

	while (TotalBytes--)                              // Write each of the fuse/lock bytes stored in memory to the slave AVR
	{
		for (uint8_t CommandByte = 0; CommandByte < 4; CommandByte++)      // Write each individual command byte
		{
			USI_SPITransmit(eeprom_read_byte(EEPROMAddress));
    2afe:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
			EEPROMAddress++;
    2b02:	21 96       	adiw	r28, 0x01	; 1
    2b04:	0f 5f       	subi	r16, 0xFF	; 255
    2b06:	04 30       	cpi	r16, 0x04	; 4
    2b08:	b1 f7       	brne	.-20     	; 0x2af6 <PM_SendFuseLockBytes+0x44>
    2b0a:	84 e0       	ldi	r24, 0x04	; 4
    2b0c:	90 e0       	ldi	r25, 0x00	; 0
    2b0e:	e8 0e       	add	r14, r24
    2b10:	f9 1e       	adc	r15, r25
		}
		
		// Add some delay before programming next byte, if there is one:
		if (TotalBytes)
    2b12:	11 23       	and	r17, r17
    2b14:	19 f0       	breq	.+6      	; 0x2b1c <PM_SendFuseLockBytes+0x6a>
		  MAIN_Delay10MS(5);
    2b16:	85 e0       	ldi	r24, 0x05	; 5
    2b18:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
    2b1c:	11 50       	subi	r17, 0x01	; 1
    2b1e:	48 f7       	brcc	.-46     	; 0x2af2 <PM_SendFuseLockBytes+0x40>
    2b20:	df 91       	pop	r29
    2b22:	cf 91       	pop	r28
    2b24:	1f 91       	pop	r17
    2b26:	0f 91       	pop	r16
    2b28:	ff 90       	pop	r15
    2b2a:	ef 90       	pop	r14
    2b2c:	08 95       	ret

00002b2e <PM_SendEraseCommand>:
	}
}

void PM_SendEraseCommand(void)
{			
    2b2e:	cf 93       	push	r28
    2b30:	df 93       	push	r29
    2b32:	cb e1       	ldi	r28, 0x1B	; 27
    2b34:	d0 e0       	ldi	r29, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2b36:	de 01       	movw	r26, r28
    2b38:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
    2b3c:	80 2d       	mov	r24, r0
	for (uint8_t B = 3; B < 7 ; B++)                  // Read out the erase chip command bytes
	  USI_SPITransmit(eeprom_read_byte(&EEPROMVars.EraseChip[B])); // Send the erase chip commands
    2b3e:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    2b42:	21 96       	adiw	r28, 0x01	; 1
    2b44:	80 e0       	ldi	r24, 0x00	; 0
    2b46:	cf 31       	cpi	r28, 0x1F	; 31
    2b48:	d8 07       	cpc	r29, r24
    2b4a:	a9 f7       	brne	.-22     	; 0x2b36 <PM_SendEraseCommand+0x8>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2b4c:	25 97       	sbiw	r28, 0x05	; 5
    2b4e:	de 01       	movw	r26, r28
    2b50:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
    2b54:	80 2d       	mov	r24, r0
    2b56:	25 96       	adiw	r28, 0x05	; 5
			
	if (eeprom_read_byte(&EEPROMVars.EraseChip[2]))   // Value of 1 indicates a busy flag test
    2b58:	88 23       	and	r24, r24
    2b5a:	59 f0       	breq	.+22     	; 0x2b72 <PM_SendEraseCommand+0x44>
	{
		do
			USI_SPITransmitWord(0xF000);
    2b5c:	80 e0       	ldi	r24, 0x00	; 0
    2b5e:	90 ef       	ldi	r25, 0xF0	; 240
    2b60:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
		while (USI_SPITransmitWord(0x0000) & 0x01);
    2b64:	80 e0       	ldi	r24, 0x00	; 0
    2b66:	90 e0       	ldi	r25, 0x00	; 0
    2b68:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
    2b6c:	80 ff       	sbrs	r24, 0
    2b6e:	08 c0       	rjmp	.+16     	; 0x2b80 <PM_SendEraseCommand+0x52>
    2b70:	f5 cf       	rjmp	.-22     	; 0x2b5c <PM_SendEraseCommand+0x2e>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2b72:	26 97       	sbiw	r28, 0x06	; 6
    2b74:	de 01       	movw	r26, r28
    2b76:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
    2b7a:	80 2d       	mov	r24, r0
	}
	else                                              // Cleared flag means use a predefined delay
	{		
		MAIN_Delay1MS(eeprom_read_byte(&EEPROMVars.EraseChip[1])); // Wait the erase delay
    2b7c:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2b80:	df 91       	pop	r29
    2b82:	cf 91       	pop	r28
    2b84:	08 95       	ret

00002b86 <PM_CreateProgrammingPackets>:
	}
}

void PM_CreateProgrammingPackets(const uint8_t Type)
{			
    2b86:	3f 92       	push	r3
    2b88:	4f 92       	push	r4
    2b8a:	5f 92       	push	r5
    2b8c:	6f 92       	push	r6
    2b8e:	7f 92       	push	r7
    2b90:	8f 92       	push	r8
    2b92:	9f 92       	push	r9
    2b94:	af 92       	push	r10
    2b96:	bf 92       	push	r11
    2b98:	cf 92       	push	r12
    2b9a:	df 92       	push	r13
    2b9c:	ef 92       	push	r14
    2b9e:	ff 92       	push	r15
    2ba0:	0f 93       	push	r16
    2ba2:	1f 93       	push	r17
    2ba4:	cf 93       	push	r28
    2ba6:	df 93       	push	r29
    2ba8:	18 2f       	mov	r17, r24
	uint32_t BytesRead       = 0;
	uint32_t BytesToRead     = PM_GetStoredDataSize(Type);      // Get the byte size of the stored program
    2baa:	0e 94 f5 14 	call	0x29ea	; 0x29ea <PM_GetStoredDataSize>
    2bae:	2b 01       	movw	r4, r22
    2bb0:	3c 01       	movw	r6, r24
	uint16_t BytesPerProgram;
	uint16_t PageLength;
	uint8_t* EEPROMAddress;
	uint8_t  ContinuedPage   = FALSE;

	PageLength  = eeprom_read_word((Type == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength);
    2bb2:	11 30       	cpi	r17, 0x01	; 1
    2bb4:	09 f0       	breq	.+2      	; 0x2bb8 <PM_CreateProgrammingPackets+0x32>
    2bb6:	d7 c0       	rjmp	.+430    	; 0x2d66 <PM_CreateProgrammingPackets+0x1e0>
eeprom_read_word (const uint16_t *addr)
{
  uint16_t result;

  asm ( 
    2bb8:	a5 e8       	ldi	r26, 0x85	; 133
    2bba:	b0 e0       	ldi	r27, 0x00	; 0
    2bbc:	0e 94 9a 1a 	call	0x3534	; 0x3534 <__eeprom_read_word_1F2021>
    2bc0:	4f 01       	movw	r8, r30
	CurrAddress = 0;
    2bc2:	10 92 a9 02 	sts	0x02A9, r1
    2bc6:	10 92 aa 02 	sts	0x02AA, r1
    2bca:	10 92 ab 02 	sts	0x02AB, r1
    2bce:	10 92 ac 02 	sts	0x02AC, r1

	if (Type == TYPE_FLASH)
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram;       // Set the EEPROM pointer to the write flash command bytes location
		DF_ContinuousReadEnable(0, 0);
    2bd2:	60 e0       	ldi	r22, 0x00	; 0
    2bd4:	70 e0       	ldi	r23, 0x00	; 0
    2bd6:	80 e0       	ldi	r24, 0x00	; 0
    2bd8:	90 e0       	ldi	r25, 0x00	; 0
    2bda:	0e 94 8d 0a 	call	0x151a	; 0x151a <DF_ContinuousReadEnable>
		PacketBytes[0] = AICB_CMD_PROGRAM_FLASH_ISP;
    2bde:	83 e1       	ldi	r24, 0x13	; 19
    2be0:	80 93 91 01 	sts	0x0191, r24
    2be4:	23 e0       	ldi	r18, 0x03	; 3
    2be6:	30 e0       	ldi	r19, 0x00	; 0
    2be8:	e1 e9       	ldi	r30, 0x91	; 145
    2bea:	f1 e0       	ldi	r31, 0x01	; 1
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2bec:	d9 01       	movw	r26, r18
    2bee:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
    2bf2:	80 2d       	mov	r24, r0
	}
	else
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;        // Set the EEPROM pointer to the write EEPROM command bytes location
		DF_ContinuousReadEnable(PM_EEPROM_OFFSET / DF_INTERNALDF_BUFFBYTES, PM_EEPROM_OFFSET % DF_INTERNALDF_BUFFBYTES); // Start read from the EEPROM offset location
		PacketBytes[0] = AICB_CMD_PROGRAM_EEPROM_ISP;
	}

	for (uint8_t B = 0; B < 9 ; B++)                  // Load in the write data command bytes
	{
		PacketBytes[B] = eeprom_read_byte(EEPROMAddress); // Synthesise a write packet header
    2bf4:	81 93       	st	Z+, r24
		EEPROMAddress++;                               // Increment the EEPROM location counter
    2bf6:	2f 5f       	subi	r18, 0xFF	; 255
    2bf8:	3f 4f       	sbci	r19, 0xFF	; 255
    2bfa:	81 e0       	ldi	r24, 0x01	; 1
    2bfc:	ea 39       	cpi	r30, 0x9A	; 154
    2bfe:	f8 07       	cpc	r31, r24
    2c00:	a9 f7       	brne	.-22     	; 0x2bec <PM_CreateProgrammingPackets+0x66>
	}
	
	BytesPerProgram = ((uint16_t)PacketBytes[1] << 8)
    2c02:	80 91 92 01 	lds	r24, 0x0192
    2c06:	99 27       	eor	r25, r25
    2c08:	d8 2f       	mov	r29, r24
    2c0a:	cc 27       	eor	r28, r28
    2c0c:	80 91 93 01 	lds	r24, 0x0193
    2c10:	99 27       	eor	r25, r25
    2c12:	c8 2b       	or	r28, r24
    2c14:	d9 2b       	or	r29, r25
    2c16:	aa 24       	eor	r10, r10
    2c18:	bb 24       	eor	r11, r11
    2c1a:	65 01       	movw	r12, r10
    2c1c:	33 24       	eor	r3, r3
    2c1e:	9c c0       	rjmp	.+312    	; 0x2d58 <PM_CreateProgrammingPackets+0x1d2>
	                | PacketBytes[2];

	while (BytesRead < BytesToRead)
	{
		if (PacketBytes[3] & ISPCC_PROG_MODE_PAGE)
    2c20:	80 91 94 01 	lds	r24, 0x0194
    2c24:	80 ff       	sbrs	r24, 0
    2c26:	4b c0       	rjmp	.+150    	; 0x2cbe <PM_CreateProgrammingPackets+0x138>
		{
			if (PageLength > 160) // Max 160 bytes at a time
    2c28:	91 ea       	ldi	r25, 0xA1	; 161
    2c2a:	89 16       	cp	r8, r25
    2c2c:	91 04       	cpc	r9, r1
    2c2e:	18 f4       	brcc	.+6      	; 0x2c36 <PM_CreateProgrammingPackets+0xb0>
    2c30:	01 e9       	ldi	r16, 0x91	; 145
    2c32:	11 e0       	ldi	r17, 0x01	; 1
    2c34:	2f c0       	rjmp	.+94     	; 0x2c94 <PM_CreateProgrammingPackets+0x10e>
			{
				if (!(ContinuedPage))                      // Start of a new page, program in the first 150 bytes
    2c36:	33 20       	and	r3, r3
    2c38:	41 f4       	brne	.+16     	; 0x2c4a <PM_CreateProgrammingPackets+0xc4>
				{
					BytesPerProgram = 160;
					PacketBytes[3] &= ~ISPCC_PROG_MODE_PAGEDONE;		
    2c3a:	8f 77       	andi	r24, 0x7F	; 127
    2c3c:	80 93 94 01 	sts	0x0194, r24
    2c40:	c0 ea       	ldi	r28, 0xA0	; 160
    2c42:	d0 e0       	ldi	r29, 0x00	; 0
    2c44:	11 e0       	ldi	r17, 0x01	; 1
    2c46:	31 2e       	mov	r3, r17
    2c48:	07 c0       	rjmp	.+14     	; 0x2c58 <PM_CreateProgrammingPackets+0xd2>
					ContinuedPage = TRUE;
				}
				else                                       // Middle of a page, program in the remainder
				{
					BytesPerProgram = PageLength - 160;
    2c4a:	e4 01       	movw	r28, r8
    2c4c:	c0 5a       	subi	r28, 0xA0	; 160
    2c4e:	d0 40       	sbci	r29, 0x00	; 0
					PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
    2c50:	80 68       	ori	r24, 0x80	; 128
    2c52:	80 93 94 01 	sts	0x0194, r24
    2c56:	33 24       	eor	r3, r3
    2c58:	01 e9       	ldi	r16, 0x91	; 145
    2c5a:	11 e0       	ldi	r17, 0x01	; 1
    2c5c:	07 c0       	rjmp	.+14     	; 0x2c6c <PM_CreateProgrammingPackets+0xe6>
					ContinuedPage = FALSE;
				}
				
				for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page				
    2c5e:	80 e0       	ldi	r24, 0x00	; 0
    2c60:	0e 94 af 09 	call	0x135e	; 0x135e <SPI_SPITransmit>
    2c64:	f8 01       	movw	r30, r16
    2c66:	82 87       	std	Z+10, r24	; 0x0a
    2c68:	0f 5f       	subi	r16, 0xFF	; 255
    2c6a:	1f 4f       	sbci	r17, 0xFF	; 255
    2c6c:	ce 01       	movw	r24, r28
    2c6e:	8f 56       	subi	r24, 0x6F	; 111
    2c70:	9e 4f       	sbci	r25, 0xFE	; 254
    2c72:	08 17       	cp	r16, r24
    2c74:	19 07       	cpc	r17, r25
    2c76:	99 f7       	brne	.-26     	; 0x2c5e <PM_CreateProgrammingPackets+0xd8>

				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);
    2c78:	8d 2f       	mov	r24, r29
    2c7a:	99 27       	eor	r25, r25
    2c7c:	80 93 92 01 	sts	0x0192, r24
				PacketBytes[2] = (uint8_t)(BytesPerProgram);
    2c80:	c0 93 93 01 	sts	0x0193, r28
    2c84:	41 c0       	rjmp	.+130    	; 0x2d08 <PM_CreateProgrammingPackets+0x182>

				BytesRead += BytesPerProgram;                         // Increment the counter
			}
			else
			{
				for (uint16_t LoadB = 0; LoadB < PageLength; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page
    2c86:	80 e0       	ldi	r24, 0x00	; 0
    2c88:	0e 94 af 09 	call	0x135e	; 0x135e <SPI_SPITransmit>
    2c8c:	f8 01       	movw	r30, r16
    2c8e:	82 87       	std	Z+10, r24	; 0x0a
    2c90:	0f 5f       	subi	r16, 0xFF	; 255
    2c92:	1f 4f       	sbci	r17, 0xFF	; 255
    2c94:	c4 01       	movw	r24, r8
    2c96:	8f 56       	subi	r24, 0x6F	; 111
    2c98:	9e 4f       	sbci	r25, 0xFE	; 254
    2c9a:	08 17       	cp	r16, r24
    2c9c:	19 07       	cpc	r17, r25
    2c9e:	99 f7       	brne	.-26     	; 0x2c86 <PM_CreateProgrammingPackets+0x100>
			
				PacketBytes[1]  = (uint8_t)(PageLength >> 8);
    2ca0:	89 2d       	mov	r24, r9
    2ca2:	99 27       	eor	r25, r25
    2ca4:	80 93 92 01 	sts	0x0192, r24
				PacketBytes[2]  = (uint8_t)(PageLength);
    2ca8:	80 92 93 01 	sts	0x0193, r8
				PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
    2cac:	80 91 94 01 	lds	r24, 0x0194
    2cb0:	80 68       	ori	r24, 0x80	; 128
    2cb2:	80 93 94 01 	sts	0x0194, r24

				BytesRead += PageLength;                            // Increment the counter
    2cb6:	c4 01       	movw	r24, r8
    2cb8:	aa 27       	eor	r26, r26
    2cba:	bb 27       	eor	r27, r27
    2cbc:	28 c0       	rjmp	.+80     	; 0x2d0e <PM_CreateProgrammingPackets+0x188>
			}
		}
		else
		{
			if ((BytesRead + BytesPerProgram) > BytesToRead)        // Less than a whole BytesPerProgram left of data to write
    2cbe:	ce 01       	movw	r24, r28
    2cc0:	aa 27       	eor	r26, r26
    2cc2:	bb 27       	eor	r27, r27
    2cc4:	8a 0d       	add	r24, r10
    2cc6:	9b 1d       	adc	r25, r11
    2cc8:	ac 1d       	adc	r26, r12
    2cca:	bd 1d       	adc	r27, r13
    2ccc:	48 16       	cp	r4, r24
    2cce:	59 06       	cpc	r5, r25
    2cd0:	6a 06       	cpc	r6, r26
    2cd2:	7b 06       	cpc	r7, r27
    2cd4:	48 f4       	brcc	.+18     	; 0x2ce8 <PM_CreateProgrammingPackets+0x162>
			{
				BytesPerProgram = BytesToRead - BytesRead;          // Next lot of bytes will be the remaining data length
    2cd6:	e2 01       	movw	r28, r4
    2cd8:	ca 19       	sub	r28, r10
    2cda:	db 09       	sbc	r29, r11
				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);   // \. Save the new length
    2cdc:	8d 2f       	mov	r24, r29
    2cde:	99 27       	eor	r25, r25
    2ce0:	80 93 92 01 	sts	0x0192, r24
				PacketBytes[2] = (uint8_t)(BytesPerProgram);        // /  into the data packet
    2ce4:	c0 93 93 01 	sts	0x0193, r28
    2ce8:	01 e9       	ldi	r16, 0x91	; 145
    2cea:	11 e0       	ldi	r17, 0x01	; 1
    2cec:	07 c0       	rjmp	.+14     	; 0x2cfc <PM_CreateProgrammingPackets+0x176>
			}

			for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
				PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);    // Load in the page
    2cee:	80 e0       	ldi	r24, 0x00	; 0
    2cf0:	0e 94 af 09 	call	0x135e	; 0x135e <SPI_SPITransmit>
    2cf4:	f8 01       	movw	r30, r16
    2cf6:	82 87       	std	Z+10, r24	; 0x0a
    2cf8:	0f 5f       	subi	r16, 0xFF	; 255
    2cfa:	1f 4f       	sbci	r17, 0xFF	; 255
    2cfc:	ce 01       	movw	r24, r28
    2cfe:	8f 56       	subi	r24, 0x6F	; 111
    2d00:	9e 4f       	sbci	r25, 0xFE	; 254
    2d02:	08 17       	cp	r16, r24
    2d04:	19 07       	cpc	r17, r25
    2d06:	99 f7       	brne	.-26     	; 0x2cee <PM_CreateProgrammingPackets+0x168>
			
			BytesRead += BytesPerProgram;                           // Increment the counter
    2d08:	ce 01       	movw	r24, r28
    2d0a:	aa 27       	eor	r26, r26
    2d0c:	bb 27       	eor	r27, r27
    2d0e:	a8 0e       	add	r10, r24
    2d10:	b9 1e       	adc	r11, r25
    2d12:	ca 1e       	adc	r12, r26
    2d14:	db 1e       	adc	r13, r27
		}
	
		if (!(BytesRead & 0xFFFF) && (BytesRead & 0x00FF0000))      // Extended address required
    2d16:	a1 14       	cp	r10, r1
    2d18:	b1 04       	cpc	r11, r1
    2d1a:	e1 f4       	brne	.+56     	; 0x2d54 <PM_CreateProgrammingPackets+0x1ce>
    2d1c:	e1 2c       	mov	r14, r1
    2d1e:	f1 2c       	mov	r15, r1
    2d20:	ef ef       	ldi	r30, 0xFF	; 255
    2d22:	0e 2f       	mov	r16, r30
    2d24:	11 2d       	mov	r17, r1
    2d26:	ea 20       	and	r14, r10
    2d28:	fb 20       	and	r15, r11
    2d2a:	0c 21       	and	r16, r12
    2d2c:	1d 21       	and	r17, r13
    2d2e:	e1 14       	cp	r14, r1
    2d30:	f1 04       	cpc	r15, r1
    2d32:	01 05       	cpc	r16, r1
    2d34:	11 05       	cpc	r17, r1
    2d36:	71 f0       	breq	.+28     	; 0x2d54 <PM_CreateProgrammingPackets+0x1ce>
		{
			USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);            // Load extended address command
    2d38:	8d e4       	ldi	r24, 0x4D	; 77
    2d3a:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
			USI_SPITransmit(0x00);
    2d3e:	80 e0       	ldi	r24, 0x00	; 0
    2d40:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
			USI_SPITransmit((BytesRead & 0x00FF0000) >> 16);        // The 3rd byte of the long holds the extended address
    2d44:	c8 01       	movw	r24, r16
    2d46:	aa 27       	eor	r26, r26
    2d48:	bb 27       	eor	r27, r27
    2d4a:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
			USI_SPITransmit(0x00);
    2d4e:	80 e0       	ldi	r24, 0x00	; 0
    2d50:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
		}

		ISPCC_ProgramChip();                                        // Start the program cycle
    2d54:	0e 94 98 11 	call	0x2330	; 0x2330 <ISPCC_ProgramChip>
    2d58:	a4 14       	cp	r10, r4
    2d5a:	b5 04       	cpc	r11, r5
    2d5c:	c6 04       	cpc	r12, r6
    2d5e:	d7 04       	cpc	r13, r7
    2d60:	08 f4       	brcc	.+2      	; 0x2d64 <PM_CreateProgrammingPackets+0x1de>
    2d62:	5e cf       	rjmp	.-324    	; 0x2c20 <PM_CreateProgrammingPackets+0x9a>
    2d64:	19 c0       	rjmp	.+50     	; 0x2d98 <PM_CreateProgrammingPackets+0x212>
eeprom_read_word (const uint16_t *addr)
{
  uint16_t result;

  asm ( 
    2d66:	a7 e8       	ldi	r26, 0x87	; 135
    2d68:	b0 e0       	ldi	r27, 0x00	; 0
    2d6a:	0e 94 9a 1a 	call	0x3534	; 0x3534 <__eeprom_read_word_1F2021>
    2d6e:	4f 01       	movw	r8, r30
    2d70:	10 92 a9 02 	sts	0x02A9, r1
    2d74:	10 92 aa 02 	sts	0x02AA, r1
    2d78:	10 92 ab 02 	sts	0x02AB, r1
    2d7c:	10 92 ac 02 	sts	0x02AC, r1
    2d80:	60 ee       	ldi	r22, 0xE0	; 224
    2d82:	70 e0       	ldi	r23, 0x00	; 0
    2d84:	84 ee       	ldi	r24, 0xE4	; 228
    2d86:	93 e0       	ldi	r25, 0x03	; 3
    2d88:	0e 94 8d 0a 	call	0x151a	; 0x151a <DF_ContinuousReadEnable>
    2d8c:	85 e1       	ldi	r24, 0x15	; 21
    2d8e:	80 93 91 01 	sts	0x0191, r24
    2d92:	2d e0       	ldi	r18, 0x0D	; 13
    2d94:	30 e0       	ldi	r19, 0x00	; 0
    2d96:	28 cf       	rjmp	.-432    	; 0x2be8 <PM_CreateProgrammingPackets+0x62>
    2d98:	df 91       	pop	r29
    2d9a:	cf 91       	pop	r28
    2d9c:	1f 91       	pop	r17
    2d9e:	0f 91       	pop	r16
    2da0:	ff 90       	pop	r15
    2da2:	ef 90       	pop	r14
    2da4:	df 90       	pop	r13
    2da6:	cf 90       	pop	r12
    2da8:	bf 90       	pop	r11
    2daa:	af 90       	pop	r10
    2dac:	9f 90       	pop	r9
    2dae:	8f 90       	pop	r8
    2db0:	7f 90       	pop	r7
    2db2:	6f 90       	pop	r6
    2db4:	5f 90       	pop	r5
    2db6:	4f 90       	pop	r4
    2db8:	3f 90       	pop	r3
    2dba:	08 95       	ret

00002dbc <PM_ShowStoredItemSizes>:
	}
}

void PM_ShowStoredItemSizes(void)
{
    2dbc:	1f 93       	push	r17
    2dbe:	cf 93       	push	r28
    2dc0:	df 93       	push	r29
    2dc2:	cd b7       	in	r28, 0x3d	; 61
    2dc4:	de b7       	in	r29, 0x3e	; 62
    2dc6:	2e 97       	sbiw	r28, 0x0e	; 14
    2dc8:	0f b6       	in	r0, 0x3f	; 63
    2dca:	f8 94       	cli
    2dcc:	de bf       	out	0x3e, r29	; 62
    2dce:	0f be       	out	0x3f, r0	; 63
    2dd0:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[14];
	uint8_t ItemInfoIndex = 0;
	uint8_t TempB;
	
	JoyStatus = 1;
    2dd2:	81 e0       	ldi	r24, 0x01	; 1
    2dd4:	8e bb       	out	0x1e, r24	; 30
    2dd6:	10 e0       	ldi	r17, 0x00	; 0
	
	for (;;)
	{
		if (JoyStatus)                           // Joystick is in the non-center position
    2dd8:	8e b3       	in	r24, 0x1e	; 30
    2dda:	88 23       	and	r24, r24
    2ddc:	e9 f3       	breq	.-6      	; 0x2dd8 <PM_ShowStoredItemSizes+0x1c>
		{
			if (JoyStatus & JOY_UP)              // Previous item
    2dde:	f6 9b       	sbis	0x1e, 6	; 30
    2de0:	04 c0       	rjmp	.+8      	; 0x2dea <PM_ShowStoredItemSizes+0x2e>
				(ItemInfoIndex == 0)? ItemInfoIndex = 3 : ItemInfoIndex--;
    2de2:	11 23       	and	r17, r17
    2de4:	81 f1       	breq	.+96     	; 0x2e46 <PM_ShowStoredItemSizes+0x8a>
    2de6:	11 50       	subi	r17, 0x01	; 1
    2de8:	0a c0       	rjmp	.+20     	; 0x2dfe <PM_ShowStoredItemSizes+0x42>
			else if (JoyStatus & JOY_DOWN)      // Next item
    2dea:	f7 9b       	sbis	0x1e, 7	; 30
    2dec:	06 c0       	rjmp	.+12     	; 0x2dfa <PM_ShowStoredItemSizes+0x3e>
				(ItemInfoIndex == 3)? ItemInfoIndex = 0 : ItemInfoIndex++;
    2dee:	13 30       	cpi	r17, 0x03	; 3
    2df0:	11 f4       	brne	.+4      	; 0x2df6 <PM_ShowStoredItemSizes+0x3a>
    2df2:	10 e0       	ldi	r17, 0x00	; 0
    2df4:	0d c0       	rjmp	.+26     	; 0x2e10 <PM_ShowStoredItemSizes+0x54>
    2df6:	1f 5f       	subi	r17, 0xFF	; 255
    2df8:	02 c0       	rjmp	.+4      	; 0x2dfe <PM_ShowStoredItemSizes+0x42>
			else if (JoyStatus & JOY_LEFT)
    2dfa:	f2 99       	sbic	0x1e, 2	; 30
    2dfc:	49 c0       	rjmp	.+146    	; 0x2e90 <PM_ShowStoredItemSizes+0xd4>
				return;
		
			switch (ItemInfoIndex)
    2dfe:	11 30       	cpi	r17, 0x01	; 1
    2e00:	79 f0       	breq	.+30     	; 0x2e20 <PM_ShowStoredItemSizes+0x64>
    2e02:	11 30       	cpi	r17, 0x01	; 1
    2e04:	28 f0       	brcs	.+10     	; 0x2e10 <PM_ShowStoredItemSizes+0x54>
    2e06:	12 30       	cpi	r17, 0x02	; 2
    2e08:	a9 f0       	breq	.+42     	; 0x2e34 <PM_ShowStoredItemSizes+0x78>
    2e0a:	13 30       	cpi	r17, 0x03	; 3
    2e0c:	d1 f5       	brne	.+116    	; 0x2e82 <PM_ShowStoredItemSizes+0xc6>
    2e0e:	1c c0       	rjmp	.+56     	; 0x2e48 <PM_ShowStoredItemSizes+0x8c>
			{
				case 0:
					strcpy_P(Buffer, PSTR("DATA-"));
    2e10:	68 e5       	ldi	r22, 0x58	; 88
    2e12:	74 e0       	ldi	r23, 0x04	; 4
    2e14:	ce 01       	movw	r24, r28
    2e16:	01 96       	adiw	r24, 0x01	; 1
    2e18:	0e 94 51 1a 	call	0x34a2	; 0x34a2 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_FLASH), &Buffer[5], 10);
    2e1c:	81 e0       	ldi	r24, 0x01	; 1
    2e1e:	07 c0       	rjmp	.+14     	; 0x2e2e <PM_ShowStoredItemSizes+0x72>
					break;
				case 1:
					strcpy_P(Buffer, PSTR("EPRM-"));
    2e20:	62 e5       	ldi	r22, 0x52	; 82
    2e22:	74 e0       	ldi	r23, 0x04	; 4
    2e24:	ce 01       	movw	r24, r28
    2e26:	01 96       	adiw	r24, 0x01	; 1
    2e28:	0e 94 51 1a 	call	0x34a2	; 0x34a2 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_EEPROM), &Buffer[5], 10);
    2e2c:	80 e0       	ldi	r24, 0x00	; 0
    2e2e:	0e 94 f5 14 	call	0x29ea	; 0x29ea <PM_GetStoredDataSize>
    2e32:	20 c0       	rjmp	.+64     	; 0x2e74 <PM_ShowStoredItemSizes+0xb8>
					break;
				case 2:
					strcpy_P(Buffer, PSTR("FUSE-"));
    2e34:	6c e4       	ldi	r22, 0x4C	; 76
    2e36:	74 e0       	ldi	r23, 0x04	; 4
    2e38:	ce 01       	movw	r24, r28
    2e3a:	01 96       	adiw	r24, 0x01	; 1
    2e3c:	0e 94 51 1a 	call	0x34a2	; 0x34a2 <strcpy_P>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2e40:	a3 e3       	ldi	r26, 0x33	; 51
    2e42:	b0 e0       	ldi	r27, 0x00	; 0
    2e44:	09 c0       	rjmp	.+18     	; 0x2e58 <PM_ShowStoredItemSizes+0x9c>
					TempB = eeprom_read_byte(&EEPROMVars.TotalFuseBytes);
					ultoa(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5], 10);
					break;
    2e46:	13 e0       	ldi	r17, 0x03	; 3
				case 3:
					strcpy_P(Buffer, PSTR("LOCK-"));
    2e48:	66 e4       	ldi	r22, 0x46	; 70
    2e4a:	74 e0       	ldi	r23, 0x04	; 4
    2e4c:	ce 01       	movw	r24, r28
    2e4e:	01 96       	adiw	r24, 0x01	; 1
    2e50:	0e 94 51 1a 	call	0x34a2	; 0x34a2 <strcpy_P>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2e54:	a4 e3       	ldi	r26, 0x34	; 52
    2e56:	b0 e0       	ldi	r27, 0x00	; 0
    2e58:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
    2e5c:	80 2d       	mov	r24, r0
					TempB = eeprom_read_byte(&EEPROMVars.TotalLockBytes);
					ultoa(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5], 10);
    2e5e:	8f 3f       	cpi	r24, 0xFF	; 255
    2e60:	29 f4       	brne	.+10     	; 0x2e6c <PM_ShowStoredItemSizes+0xb0>
    2e62:	60 e0       	ldi	r22, 0x00	; 0
    2e64:	70 e0       	ldi	r23, 0x00	; 0
    2e66:	80 e0       	ldi	r24, 0x00	; 0
    2e68:	90 e0       	ldi	r25, 0x00	; 0
    2e6a:	04 c0       	rjmp	.+8      	; 0x2e74 <PM_ShowStoredItemSizes+0xb8>
    2e6c:	68 2f       	mov	r22, r24
    2e6e:	77 27       	eor	r23, r23
    2e70:	88 27       	eor	r24, r24
    2e72:	99 27       	eor	r25, r25
    2e74:	2a e0       	ldi	r18, 0x0A	; 10
    2e76:	30 e0       	ldi	r19, 0x00	; 0
    2e78:	ae 01       	movw	r20, r28
    2e7a:	4a 5f       	subi	r20, 0xFA	; 250
    2e7c:	5f 4f       	sbci	r21, 0xFF	; 255
    2e7e:	0e 94 58 1a 	call	0x34b0	; 0x34b0 <ultoa>
			}
	
			LCD_puts(Buffer);
    2e82:	ce 01       	movw	r24, r28
    2e84:	01 96       	adiw	r24, 0x01	; 1
    2e86:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>

			MAIN_WaitForJoyRelease();
    2e8a:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
    2e8e:	a4 cf       	rjmp	.-184    	; 0x2dd8 <PM_ShowStoredItemSizes+0x1c>
    2e90:	2e 96       	adiw	r28, 0x0e	; 14
    2e92:	0f b6       	in	r0, 0x3f	; 63
    2e94:	f8 94       	cli
    2e96:	de bf       	out	0x3e, r29	; 62
    2e98:	0f be       	out	0x3f, r0	; 63
    2e9a:	cd bf       	out	0x3d, r28	; 61
    2e9c:	df 91       	pop	r29
    2e9e:	cf 91       	pop	r28
    2ea0:	1f 91       	pop	r17
    2ea2:	08 95       	ret

00002ea4 <PM_InterpretAVRISPPacket>:
    2ea4:	ef 92       	push	r14
    2ea6:	ff 92       	push	r15
    2ea8:	0f 93       	push	r16
    2eaa:	1f 93       	push	r17
    2eac:	cf 93       	push	r28
    2eae:	df 93       	push	r29
    2eb0:	20 91 91 01 	lds	r18, 0x0191
    2eb4:	26 31       	cpi	r18, 0x16	; 22
    2eb6:	09 f4       	brne	.+2      	; 0x2eba <PM_InterpretAVRISPPacket+0x16>
    2eb8:	ad c1       	rjmp	.+858    	; 0x3214 <PM_InterpretAVRISPPacket+0x370>
    2eba:	27 31       	cpi	r18, 0x17	; 23
    2ebc:	78 f4       	brcc	.+30     	; 0x2edc <PM_InterpretAVRISPPacket+0x38>
    2ebe:	22 31       	cpi	r18, 0x12	; 18
    2ec0:	09 f4       	brne	.+2      	; 0x2ec4 <PM_InterpretAVRISPPacket+0x20>
    2ec2:	5f c0       	rjmp	.+190    	; 0x2f82 <PM_InterpretAVRISPPacket+0xde>
    2ec4:	23 31       	cpi	r18, 0x13	; 19
    2ec6:	30 f4       	brcc	.+12     	; 0x2ed4 <PM_InterpretAVRISPPacket+0x30>
    2ec8:	20 31       	cpi	r18, 0x10	; 16
    2eca:	e9 f0       	breq	.+58     	; 0x2f06 <PM_InterpretAVRISPPacket+0x62>
    2ecc:	21 31       	cpi	r18, 0x11	; 17
    2ece:	09 f0       	breq	.+2      	; 0x2ed2 <PM_InterpretAVRISPPacket+0x2e>
    2ed0:	07 c2       	rjmp	.+1038   	; 0x32e0 <PM_InterpretAVRISPPacket+0x43c>
    2ed2:	37 c0       	rjmp	.+110    	; 0x2f42 <PM_InterpretAVRISPPacket+0x9e>
    2ed4:	24 31       	cpi	r18, 0x14	; 20
    2ed6:	09 f0       	breq	.+2      	; 0x2eda <PM_InterpretAVRISPPacket+0x36>
    2ed8:	35 c1       	rjmp	.+618    	; 0x3144 <PM_InterpretAVRISPPacket+0x2a0>
    2eda:	9c c1       	rjmp	.+824    	; 0x3214 <PM_InterpretAVRISPPacket+0x370>
    2edc:	29 31       	cpi	r18, 0x19	; 25
    2ede:	09 f4       	brne	.+2      	; 0x2ee2 <PM_InterpretAVRISPPacket+0x3e>
    2ee0:	de c0       	rjmp	.+444    	; 0x309e <PM_InterpretAVRISPPacket+0x1fa>
    2ee2:	2a 31       	cpi	r18, 0x1A	; 26
    2ee4:	38 f4       	brcc	.+14     	; 0x2ef4 <PM_InterpretAVRISPPacket+0x50>
    2ee6:	27 31       	cpi	r18, 0x17	; 23
    2ee8:	09 f4       	brne	.+2      	; 0x2eec <PM_InterpretAVRISPPacket+0x48>
    2eea:	d9 c0       	rjmp	.+434    	; 0x309e <PM_InterpretAVRISPPacket+0x1fa>
    2eec:	28 31       	cpi	r18, 0x18	; 24
    2eee:	09 f0       	breq	.+2      	; 0x2ef2 <PM_InterpretAVRISPPacket+0x4e>
    2ef0:	f7 c1       	rjmp	.+1006   	; 0x32e0 <PM_InterpretAVRISPPacket+0x43c>
    2ef2:	83 c0       	rjmp	.+262    	; 0x2ffa <PM_InterpretAVRISPPacket+0x156>
    2ef4:	2b 31       	cpi	r18, 0x1B	; 27
    2ef6:	c9 f1       	breq	.+114    	; 0x2f6a <PM_InterpretAVRISPPacket+0xc6>
    2ef8:	2b 31       	cpi	r18, 0x1B	; 27
    2efa:	08 f4       	brcc	.+2      	; 0x2efe <PM_InterpretAVRISPPacket+0x5a>
    2efc:	7e c0       	rjmp	.+252    	; 0x2ffa <PM_InterpretAVRISPPacket+0x156>
    2efe:	2c 31       	cpi	r18, 0x1C	; 28
    2f00:	09 f0       	breq	.+2      	; 0x2f04 <PM_InterpretAVRISPPacket+0x60>
    2f02:	ee c1       	rjmp	.+988    	; 0x32e0 <PM_InterpretAVRISPPacket+0x43c>
    2f04:	6d c0       	rjmp	.+218    	; 0x2fe0 <PM_InterpretAVRISPPacket+0x13c>
    2f06:	82 e0       	ldi	r24, 0x02	; 2
    2f08:	90 e0       	ldi	r25, 0x00	; 0
    2f0a:	90 93 a7 02 	sts	0x02A7, r25
    2f0e:	80 93 a6 02 	sts	0x02A6, r24
    2f12:	e1 e9       	ldi	r30, 0x91	; 145
    2f14:	f1 e0       	ldi	r31, 0x01	; 1
    2f16:	27 e2       	ldi	r18, 0x27	; 39
    2f18:	30 e0       	ldi	r19, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2f1a:	81 91       	ld	r24, Z+
    2f1c:	d9 01       	movw	r26, r18
    2f1e:	08 2e       	mov	r0, r24
    2f20:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
    2f24:	2f 5f       	subi	r18, 0xFF	; 255
    2f26:	3f 4f       	sbci	r19, 0xFF	; 255
    2f28:	81 e0       	ldi	r24, 0x01	; 1
    2f2a:	ed 39       	cpi	r30, 0x9D	; 157
    2f2c:	f8 07       	cpc	r31, r24
    2f2e:	a9 f7       	brne	.-22     	; 0x2f1a <PM_InterpretAVRISPPacket+0x76>
    2f30:	81 e0       	ldi	r24, 0x01	; 1
    2f32:	80 93 a8 02 	sts	0x02A8, r24
    2f36:	10 92 ae 02 	sts	0x02AE, r1
    2f3a:	81 b3       	in	r24, 0x11	; 17
    2f3c:	8f 7c       	andi	r24, 0xCF	; 207
    2f3e:	80 62       	ori	r24, 0x20	; 32
    2f40:	10 c0       	rjmp	.+32     	; 0x2f62 <PM_InterpretAVRISPPacket+0xbe>
    2f42:	82 e0       	ldi	r24, 0x02	; 2
    2f44:	90 e0       	ldi	r25, 0x00	; 0
    2f46:	90 93 a7 02 	sts	0x02A7, r25
    2f4a:	80 93 a6 02 	sts	0x02A6, r24
    2f4e:	0e 94 8b 14 	call	0x2916	; 0x2916 <PM_CheckEndOfFuseLockData>
    2f52:	10 92 a8 02 	sts	0x02A8, r1
    2f56:	80 e0       	ldi	r24, 0x00	; 0
    2f58:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    2f5c:	81 b3       	in	r24, 0x11	; 17
    2f5e:	8f 7c       	andi	r24, 0xCF	; 207
    2f60:	80 61       	ori	r24, 0x10	; 16
    2f62:	81 bb       	out	0x11, r24	; 17
    2f64:	10 92 92 01 	sts	0x0192, r1
    2f68:	c4 c1       	rjmp	.+904    	; 0x32f2 <PM_InterpretAVRISPPacket+0x44e>
    2f6a:	84 e0       	ldi	r24, 0x04	; 4
    2f6c:	90 e0       	ldi	r25, 0x00	; 0
    2f6e:	90 93 a7 02 	sts	0x02A7, r25
    2f72:	80 93 a6 02 	sts	0x02A6, r24
    2f76:	10 92 92 01 	sts	0x0192, r1
    2f7a:	81 e0       	ldi	r24, 0x01	; 1
    2f7c:	80 93 93 01 	sts	0x0193, r24
    2f80:	39 c0       	rjmp	.+114    	; 0x2ff4 <PM_InterpretAVRISPPacket+0x150>
    2f82:	82 e0       	ldi	r24, 0x02	; 2
    2f84:	90 e0       	ldi	r25, 0x00	; 0
    2f86:	90 93 a7 02 	sts	0x02A7, r25
    2f8a:	80 93 a6 02 	sts	0x02A6, r24
    2f8e:	e2 e9       	ldi	r30, 0x92	; 146
    2f90:	f1 e0       	ldi	r31, 0x01	; 1
    2f92:	29 e1       	ldi	r18, 0x19	; 25
    2f94:	30 e0       	ldi	r19, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2f96:	81 91       	ld	r24, Z+
    2f98:	d9 01       	movw	r26, r18
    2f9a:	08 2e       	mov	r0, r24
    2f9c:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
    2fa0:	2f 5f       	subi	r18, 0xFF	; 255
    2fa2:	3f 4f       	sbci	r19, 0xFF	; 255
    2fa4:	91 e0       	ldi	r25, 0x01	; 1
    2fa6:	e8 39       	cpi	r30, 0x98	; 152
    2fa8:	f9 07       	cpc	r31, r25
    2faa:	a9 f7       	brne	.-22     	; 0x2f96 <PM_InterpretAVRISPPacket+0xf2>
    2fac:	2f e1       	ldi	r18, 0x1F	; 31
    2fae:	30 e0       	ldi	r19, 0x00	; 0
    2fb0:	80 e0       	ldi	r24, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2fb2:	d9 01       	movw	r26, r18
    2fb4:	08 2e       	mov	r0, r24
    2fb6:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
    2fba:	d9 01       	movw	r26, r18
    2fbc:	14 96       	adiw	r26, 0x04	; 4
    2fbe:	08 2e       	mov	r0, r24
    2fc0:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
    2fc4:	2f 5f       	subi	r18, 0xFF	; 255
    2fc6:	3f 4f       	sbci	r19, 0xFF	; 255
    2fc8:	e0 e0       	ldi	r30, 0x00	; 0
    2fca:	23 32       	cpi	r18, 0x23	; 35
    2fcc:	3e 07       	cpc	r19, r30
    2fce:	89 f7       	brne	.-30     	; 0x2fb2 <PM_InterpretAVRISPPacket+0x10e>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2fd0:	81 e0       	ldi	r24, 0x01	; 1
    2fd2:	2c 50       	subi	r18, 0x0C	; 12
    2fd4:	30 40       	sbci	r19, 0x00	; 0
    2fd6:	d9 01       	movw	r26, r18
    2fd8:	08 2e       	mov	r0, r24
    2fda:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
    2fde:	c2 cf       	rjmp	.-124    	; 0x2f64 <PM_InterpretAVRISPPacket+0xc0>
    2fe0:	84 e0       	ldi	r24, 0x04	; 4
    2fe2:	90 e0       	ldi	r25, 0x00	; 0
    2fe4:	90 93 a7 02 	sts	0x02A7, r25
    2fe8:	80 93 a6 02 	sts	0x02A6, r24
    2fec:	10 92 92 01 	sts	0x0192, r1
    2ff0:	10 92 93 01 	sts	0x0193, r1
    2ff4:	10 92 94 01 	sts	0x0194, r1
    2ff8:	7c c1       	rjmp	.+760    	; 0x32f2 <PM_InterpretAVRISPPacket+0x44e>
    2ffa:	84 e0       	ldi	r24, 0x04	; 4
    2ffc:	90 e0       	ldi	r25, 0x00	; 0
    2ffe:	90 93 a7 02 	sts	0x02A7, r25
    3002:	80 93 a6 02 	sts	0x02A6, r24
    3006:	80 91 ae 02 	lds	r24, 0x02AE
    300a:	84 30       	cpi	r24, 0x04	; 4
    300c:	49 f0       	breq	.+18     	; 0x3020 <PM_InterpretAVRISPPacket+0x17c>
    300e:	0e 94 8b 14 	call	0x2916	; 0x2916 <PM_CheckEndOfFuseLockData>
    3012:	10 92 46 01 	sts	0x0146, r1
    3016:	10 92 45 01 	sts	0x0145, r1
    301a:	84 e0       	ldi	r24, 0x04	; 4
    301c:	80 93 ae 02 	sts	0x02AE, r24
    3020:	40 91 45 01 	lds	r20, 0x0145
    3024:	50 91 46 01 	lds	r21, 0x0146
    3028:	20 91 91 01 	lds	r18, 0x0191
    302c:	28 31       	cpi	r18, 0x18	; 24
    302e:	19 f0       	breq	.+6      	; 0x3036 <PM_InterpretAVRISPPacket+0x192>
    3030:	a4 e3       	ldi	r26, 0x34	; 52
    3032:	b0 e0       	ldi	r27, 0x00	; 0
    3034:	02 c0       	rjmp	.+4      	; 0x303a <PM_InterpretAVRISPPacket+0x196>
    3036:	a3 e3       	ldi	r26, 0x33	; 51
    3038:	b0 e0       	ldi	r27, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    303a:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
    303e:	80 2d       	mov	r24, r0
    3040:	99 27       	eor	r25, r25
    3042:	84 17       	cp	r24, r20
    3044:	95 07       	cpc	r25, r21
    3046:	10 f4       	brcc	.+4      	; 0x304c <PM_InterpretAVRISPPacket+0x1a8>
    3048:	8f ef       	ldi	r24, 0xFF	; 255
    304a:	1e c0       	rjmp	.+60     	; 0x3088 <PM_InterpretAVRISPPacket+0x1e4>
    304c:	28 31       	cpi	r18, 0x18	; 24
    304e:	19 f4       	brne	.+6      	; 0x3056 <PM_InterpretAVRISPPacket+0x1b2>
    3050:	25 e3       	ldi	r18, 0x35	; 53
    3052:	30 e0       	ldi	r19, 0x00	; 0
    3054:	02 c0       	rjmp	.+4      	; 0x305a <PM_InterpretAVRISPPacket+0x1b6>
    3056:	2d e5       	ldi	r18, 0x5D	; 93
    3058:	30 e0       	ldi	r19, 0x00	; 0
    305a:	80 ea       	ldi	r24, 0xA0	; 160
    305c:	90 e0       	ldi	r25, 0x00	; 0
    305e:	48 9f       	mul	r20, r24
    3060:	d0 01       	movw	r26, r0
    3062:	49 9f       	mul	r20, r25
    3064:	b0 0d       	add	r27, r0
    3066:	58 9f       	mul	r21, r24
    3068:	b0 0d       	add	r27, r0
    306a:	11 24       	eor	r1, r1
    306c:	a2 0f       	add	r26, r18
    306e:	b3 1f       	adc	r27, r19
    3070:	80 91 92 01 	lds	r24, 0x0192
    3074:	28 e2       	ldi	r18, 0x28	; 40
    3076:	82 9f       	mul	r24, r18
    3078:	c0 01       	movw	r24, r0
    307a:	11 24       	eor	r1, r1
    307c:	a8 0f       	add	r26, r24
    307e:	b9 1f       	adc	r27, r25
    3080:	98 97       	sbiw	r26, 0x28	; 40
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    3082:	0e 94 8d 1a 	call	0x351a	; 0x351a <__eeprom_read_byte_1F2021>
    3086:	80 2d       	mov	r24, r0
    3088:	80 93 93 01 	sts	0x0193, r24
    308c:	4f 5f       	subi	r20, 0xFF	; 255
    308e:	5f 4f       	sbci	r21, 0xFF	; 255
    3090:	50 93 46 01 	sts	0x0146, r21
    3094:	40 93 45 01 	sts	0x0145, r20
    3098:	10 92 92 01 	sts	0x0192, r1
    309c:	ab cf       	rjmp	.-170    	; 0x2ff4 <PM_InterpretAVRISPPacket+0x150>
    309e:	83 e0       	ldi	r24, 0x03	; 3
    30a0:	90 e0       	ldi	r25, 0x00	; 0
    30a2:	90 93 a7 02 	sts	0x02A7, r25
    30a6:	80 93 a6 02 	sts	0x02A6, r24
    30aa:	80 91 ae 02 	lds	r24, 0x02AE
    30ae:	83 30       	cpi	r24, 0x03	; 3
    30b0:	39 f0       	breq	.+14     	; 0x30c0 <PM_InterpretAVRISPPacket+0x21c>
    30b2:	83 e0       	ldi	r24, 0x03	; 3
    30b4:	80 93 ae 02 	sts	0x02AE, r24
    30b8:	10 92 46 01 	sts	0x0146, r1
    30bc:	10 92 45 01 	sts	0x0145, r1
    30c0:	40 91 45 01 	lds	r20, 0x0145
    30c4:	50 91 46 01 	lds	r21, 0x0146
    30c8:	27 31       	cpi	r18, 0x17	; 23
    30ca:	69 f4       	brne	.+26     	; 0x30e6 <PM_InterpretAVRISPPacket+0x242>
    30cc:	80 ea       	ldi	r24, 0xA0	; 160
    30ce:	90 e0       	ldi	r25, 0x00	; 0
    30d0:	48 9f       	mul	r20, r24
    30d2:	90 01       	movw	r18, r0
    30d4:	49 9f       	mul	r20, r25
    30d6:	30 0d       	add	r19, r0
    30d8:	58 9f       	mul	r21, r24
    30da:	30 0d       	add	r19, r0
    30dc:	11 24       	eor	r1, r1
    30de:	2b 5c       	subi	r18, 0xCB	; 203
    30e0:	3f 4f       	sbci	r19, 0xFF	; 255
    30e2:	82 e0       	ldi	r24, 0x02	; 2
    30e4:	0c c0       	rjmp	.+24     	; 0x30fe <PM_InterpretAVRISPPacket+0x25a>
    30e6:	80 ea       	ldi	r24, 0xA0	; 160
    30e8:	90 e0       	ldi	r25, 0x00	; 0
    30ea:	48 9f       	mul	r20, r24
    30ec:	90 01       	movw	r18, r0
    30ee:	49 9f       	mul	r20, r25
    30f0:	30 0d       	add	r19, r0
    30f2:	58 9f       	mul	r21, r24
    30f4:	30 0d       	add	r19, r0
    30f6:	11 24       	eor	r1, r1
    30f8:	23 5a       	subi	r18, 0xA3	; 163
    30fa:	3f 4f       	sbci	r19, 0xFF	; 255
    30fc:	83 e0       	ldi	r24, 0x03	; 3
    30fe:	80 93 02 01 	sts	0x0102, r24
    3102:	80 91 45 01 	lds	r24, 0x0145
    3106:	90 91 46 01 	lds	r25, 0x0146
    310a:	0a 97       	sbiw	r24, 0x0a	; 10
    310c:	b0 f4       	brcc	.+44     	; 0x313a <PM_InterpretAVRISPPacket+0x296>
    310e:	e2 e9       	ldi	r30, 0x92	; 146
    3110:	f1 e0       	ldi	r31, 0x01	; 1

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    3112:	81 91       	ld	r24, Z+
    3114:	d9 01       	movw	r26, r18
    3116:	08 2e       	mov	r0, r24
    3118:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
    311c:	2f 5f       	subi	r18, 0xFF	; 255
    311e:	3f 4f       	sbci	r19, 0xFF	; 255
    3120:	81 e0       	ldi	r24, 0x01	; 1
    3122:	e6 39       	cpi	r30, 0x96	; 150
    3124:	f8 07       	cpc	r31, r24
    3126:	a9 f7       	brne	.-22     	; 0x3112 <PM_InterpretAVRISPPacket+0x26e>
    3128:	80 91 45 01 	lds	r24, 0x0145
    312c:	90 91 46 01 	lds	r25, 0x0146
    3130:	01 96       	adiw	r24, 0x01	; 1
    3132:	90 93 46 01 	sts	0x0146, r25
    3136:	80 93 45 01 	sts	0x0145, r24
    313a:	10 92 92 01 	sts	0x0192, r1
    313e:	10 92 93 01 	sts	0x0193, r1
    3142:	d7 c0       	rjmp	.+430    	; 0x32f2 <PM_InterpretAVRISPPacket+0x44e>
    3144:	82 e0       	ldi	r24, 0x02	; 2
    3146:	90 e0       	ldi	r25, 0x00	; 0
    3148:	90 93 a7 02 	sts	0x02A7, r25
    314c:	80 93 a6 02 	sts	0x02A6, r24
    3150:	80 91 ae 02 	lds	r24, 0x02AE
    3154:	81 30       	cpi	r24, 0x01	; 1
    3156:	09 f1       	breq	.+66     	; 0x319a <PM_InterpretAVRISPPacket+0x2f6>
    3158:	23 31       	cpi	r18, 0x13	; 19
    315a:	31 f4       	brne	.+12     	; 0x3168 <PM_InterpretAVRISPPacket+0x2c4>
    315c:	81 e0       	ldi	r24, 0x01	; 1
    315e:	0e 94 50 14 	call	0x28a0	; 0x28a0 <PM_SetupDFAddressCounters>
    3162:	c3 e0       	ldi	r28, 0x03	; 3
    3164:	d0 e0       	ldi	r29, 0x00	; 0
    3166:	05 c0       	rjmp	.+10     	; 0x3172 <PM_InterpretAVRISPPacket+0x2ce>
    3168:	80 e0       	ldi	r24, 0x00	; 0
    316a:	0e 94 50 14 	call	0x28a0	; 0x28a0 <PM_SetupDFAddressCounters>
    316e:	cd e0       	ldi	r28, 0x0D	; 13
    3170:	d0 e0       	ldi	r29, 0x00	; 0
    3172:	80 91 45 01 	lds	r24, 0x0145
    3176:	90 91 46 01 	lds	r25, 0x0146
    317a:	0e 94 c8 0a 	call	0x1590	; 0x1590 <DF_BufferWriteEnable>
    317e:	81 e0       	ldi	r24, 0x01	; 1
    3180:	80 93 ae 02 	sts	0x02AE, r24
    3184:	e2 e9       	ldi	r30, 0x92	; 146
    3186:	f1 e0       	ldi	r31, 0x01	; 1

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    3188:	81 91       	ld	r24, Z+
    318a:	de 01       	movw	r26, r28
    318c:	08 2e       	mov	r0, r24
    318e:	0e 94 9f 1a 	call	0x353e	; 0x353e <__eeprom_write_byte_1F2021>
    3192:	91 e0       	ldi	r25, 0x01	; 1
    3194:	eb 39       	cpi	r30, 0x9B	; 155
    3196:	f9 07       	cpc	r31, r25
    3198:	b9 f7       	brne	.-18     	; 0x3188 <PM_InterpretAVRISPPacket+0x2e4>
    319a:	80 91 92 01 	lds	r24, 0x0192
    319e:	99 27       	eor	r25, r25
    31a0:	d8 2f       	mov	r29, r24
    31a2:	cc 27       	eor	r28, r28
    31a4:	80 91 93 01 	lds	r24, 0x0193
    31a8:	99 27       	eor	r25, r25
    31aa:	c8 2b       	or	r28, r24
    31ac:	d9 2b       	or	r29, r25
    31ae:	01 e9       	ldi	r16, 0x91	; 145
    31b0:	11 e0       	ldi	r17, 0x01	; 1
    31b2:	06 c0       	rjmp	.+12     	; 0x31c0 <PM_InterpretAVRISPPacket+0x31c>
    31b4:	f8 01       	movw	r30, r16
    31b6:	82 85       	ldd	r24, Z+10	; 0x0a
    31b8:	0e 94 25 15 	call	0x2a4a	; 0x2a4a <PM_StoreProgramByte>
    31bc:	0f 5f       	subi	r16, 0xFF	; 255
    31be:	1f 4f       	sbci	r17, 0xFF	; 255
    31c0:	ce 01       	movw	r24, r28
    31c2:	8f 56       	subi	r24, 0x6F	; 111
    31c4:	9e 4f       	sbci	r25, 0xFE	; 254
    31c6:	08 17       	cp	r16, r24
    31c8:	19 07       	cpc	r17, r25
    31ca:	a1 f7       	brne	.-24     	; 0x31b4 <PM_InterpretAVRISPPacket+0x310>
    31cc:	20 91 af 02 	lds	r18, 0x02AF
    31d0:	30 91 b0 02 	lds	r19, 0x02B0
    31d4:	37 fd       	sbrc	r19, 7
    31d6:	c6 ce       	rjmp	.-628    	; 0x2f64 <PM_InterpretAVRISPPacket+0xc0>
    31d8:	80 91 94 01 	lds	r24, 0x0194
    31dc:	87 ff       	sbrs	r24, 7
    31de:	c2 ce       	rjmp	.-636    	; 0x2f64 <PM_InterpretAVRISPPacket+0xc0>
    31e0:	21 15       	cp	r18, r1
    31e2:	31 05       	cpc	r19, r1
    31e4:	09 f4       	brne	.+2      	; 0x31e8 <PM_InterpretAVRISPPacket+0x344>
    31e6:	be ce       	rjmp	.-644    	; 0x2f64 <PM_InterpretAVRISPPacket+0xc0>
    31e8:	80 91 02 01 	lds	r24, 0x0102
    31ec:	81 30       	cpi	r24, 0x01	; 1
    31ee:	19 f4       	brne	.+6      	; 0x31f6 <PM_InterpretAVRISPPacket+0x352>
    31f0:	a5 e8       	ldi	r26, 0x85	; 133
    31f2:	b0 e0       	ldi	r27, 0x00	; 0
    31f4:	02 c0       	rjmp	.+4      	; 0x31fa <PM_InterpretAVRISPPacket+0x356>
    31f6:	a7 e8       	ldi	r26, 0x87	; 135
    31f8:	b0 e0       	ldi	r27, 0x00	; 0

void 
eeprom_write_word (uint16_t *addr,uint16_t value)
{
  asm volatile (
    31fa:	09 01       	movw	r0, r18
    31fc:	0e 94 ab 1a 	call	0x3556	; 0x3556 <__eeprom_write_word_1F2021>
    3200:	80 91 af 02 	lds	r24, 0x02AF
    3204:	90 91 b0 02 	lds	r25, 0x02B0
    3208:	90 68       	ori	r25, 0x80	; 128
    320a:	90 93 b0 02 	sts	0x02B0, r25
    320e:	80 93 af 02 	sts	0x02AF, r24
    3212:	a8 ce       	rjmp	.-688    	; 0x2f64 <PM_InterpretAVRISPPacket+0xc0>
    3214:	80 91 ae 02 	lds	r24, 0x02AE
    3218:	82 30       	cpi	r24, 0x02	; 2
    321a:	01 f1       	breq	.+64     	; 0x325c <PM_InterpretAVRISPPacket+0x3b8>
    321c:	0e 94 8b 14 	call	0x2916	; 0x2916 <PM_CheckEndOfFuseLockData>
    3220:	90 e0       	ldi	r25, 0x00	; 0
    3222:	80 91 91 01 	lds	r24, 0x0191
    3226:	84 31       	cpi	r24, 0x14	; 20
    3228:	09 f4       	brne	.+2      	; 0x322c <PM_InterpretAVRISPPacket+0x388>
    322a:	91 e0       	ldi	r25, 0x01	; 1
    322c:	89 2f       	mov	r24, r25
    322e:	0e 94 50 14 	call	0x28a0	; 0x28a0 <PM_SetupDFAddressCounters>
    3232:	60 91 45 01 	lds	r22, 0x0145
    3236:	70 91 46 01 	lds	r23, 0x0146
    323a:	80 91 43 01 	lds	r24, 0x0143
    323e:	90 91 44 01 	lds	r25, 0x0144
    3242:	0e 94 8d 0a 	call	0x151a	; 0x151a <DF_ContinuousReadEnable>
    3246:	82 e0       	ldi	r24, 0x02	; 2
    3248:	80 93 ae 02 	sts	0x02AE, r24
    324c:	10 92 a9 02 	sts	0x02A9, r1
    3250:	10 92 aa 02 	sts	0x02AA, r1
    3254:	10 92 ab 02 	sts	0x02AB, r1
    3258:	10 92 ac 02 	sts	0x02AC, r1
    325c:	80 91 92 01 	lds	r24, 0x0192
    3260:	99 27       	eor	r25, r25
    3262:	d8 2f       	mov	r29, r24
    3264:	cc 27       	eor	r28, r28
    3266:	80 91 93 01 	lds	r24, 0x0193
    326a:	99 27       	eor	r25, r25
    326c:	c8 2b       	or	r28, r24
    326e:	d9 2b       	or	r29, r25
    3270:	90 e0       	ldi	r25, 0x00	; 0
    3272:	80 91 91 01 	lds	r24, 0x0191
    3276:	84 31       	cpi	r24, 0x14	; 20
    3278:	09 f4       	brne	.+2      	; 0x327c <PM_InterpretAVRISPPacket+0x3d8>
    327a:	91 e0       	ldi	r25, 0x01	; 1
    327c:	89 2f       	mov	r24, r25
    327e:	0e 94 f5 14 	call	0x29ea	; 0x29ea <PM_GetStoredDataSize>
    3282:	7b 01       	movw	r14, r22
    3284:	01 e9       	ldi	r16, 0x91	; 145
    3286:	11 e0       	ldi	r17, 0x01	; 1
    3288:	1b c0       	rjmp	.+54     	; 0x32c0 <PM_InterpretAVRISPPacket+0x41c>
    328a:	97 01       	movw	r18, r14
    328c:	44 27       	eor	r20, r20
    328e:	55 27       	eor	r21, r21
    3290:	80 91 a9 02 	lds	r24, 0x02A9
    3294:	90 91 aa 02 	lds	r25, 0x02AA
    3298:	a0 91 ab 02 	lds	r26, 0x02AB
    329c:	b0 91 ac 02 	lds	r27, 0x02AC
    32a0:	82 17       	cp	r24, r18
    32a2:	93 07       	cpc	r25, r19
    32a4:	a4 07       	cpc	r26, r20
    32a6:	b5 07       	cpc	r27, r21
    32a8:	10 f0       	brcs	.+4      	; 0x32ae <PM_InterpretAVRISPPacket+0x40a>
    32aa:	8f ef       	ldi	r24, 0xFF	; 255
    32ac:	03 c0       	rjmp	.+6      	; 0x32b4 <PM_InterpretAVRISPPacket+0x410>
    32ae:	80 e0       	ldi	r24, 0x00	; 0
    32b0:	0e 94 af 09 	call	0x135e	; 0x135e <SPI_SPITransmit>
    32b4:	f8 01       	movw	r30, r16
    32b6:	82 83       	std	Z+2, r24	; 0x02
    32b8:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <V2P_IncrementCurrAddress>
    32bc:	0f 5f       	subi	r16, 0xFF	; 255
    32be:	1f 4f       	sbci	r17, 0xFF	; 255
    32c0:	ce 01       	movw	r24, r28
    32c2:	8f 56       	subi	r24, 0x6F	; 111
    32c4:	9e 4f       	sbci	r25, 0xFE	; 254
    32c6:	08 17       	cp	r16, r24
    32c8:	19 07       	cpc	r17, r25
    32ca:	f9 f6       	brne	.-66     	; 0x328a <PM_InterpretAVRISPPacket+0x3e6>
    32cc:	23 96       	adiw	r28, 0x03	; 3
    32ce:	d0 93 a7 02 	sts	0x02A7, r29
    32d2:	c0 93 a6 02 	sts	0x02A6, r28
    32d6:	10 92 92 01 	sts	0x0192, r1
    32da:	f8 01       	movw	r30, r16
    32dc:	12 82       	std	Z+2, r1	; 0x02
    32de:	09 c0       	rjmp	.+18     	; 0x32f2 <PM_InterpretAVRISPPacket+0x44e>
    32e0:	81 e0       	ldi	r24, 0x01	; 1
    32e2:	90 e0       	ldi	r25, 0x00	; 0
    32e4:	90 93 a7 02 	sts	0x02A7, r25
    32e8:	80 93 a6 02 	sts	0x02A6, r24
    32ec:	89 ec       	ldi	r24, 0xC9	; 201
    32ee:	80 93 92 01 	sts	0x0192, r24
    32f2:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <V2P_SendPacket>
    32f6:	df 91       	pop	r29
    32f8:	cf 91       	pop	r28
    32fa:	1f 91       	pop	r17
    32fc:	0f 91       	pop	r16
    32fe:	ff 90       	pop	r15
    3300:	ef 90       	pop	r14
    3302:	08 95       	ret

00003304 <TM_FindNextTag>:
	DF_EnableDataflash(FALSE);
}

void TM_FindNextTag(void)
{
    3304:	cf 92       	push	r12
    3306:	df 92       	push	r13
    3308:	ef 92       	push	r14
    330a:	ff 92       	push	r15
    330c:	0f 93       	push	r16
    330e:	1f 93       	push	r17
    3310:	cf 93       	push	r28
    3312:	df 93       	push	r29
    3314:	cd b7       	in	r28, 0x3d	; 61
    3316:	de b7       	in	r29, 0x3e	; 62
    3318:	69 97       	sbiw	r28, 0x19	; 25
    331a:	0f b6       	in	r0, 0x3f	; 63
    331c:	f8 94       	cli
    331e:	de bf       	out	0x3e, r29	; 62
    3320:	0f be       	out	0x3f, r0	; 63
    3322:	cd bf       	out	0x3d, r28	; 61
	uint8_t  Buffer[21];
	uint8_t  HeadBuff[4]      = BT_TAGHEADER;
    3324:	80 e4       	ldi	r24, 0x40	; 64
    3326:	89 83       	std	Y+1, r24	; 0x01
    3328:	88 e2       	ldi	r24, 0x28	; 40
    332a:	8a 83       	std	Y+2, r24	; 0x02
    332c:	83 e2       	ldi	r24, 0x23	; 35
    332e:	8b 83       	std	Y+3, r24	; 0x03
    3330:	89 e2       	ldi	r24, 0x29	; 41
    3332:	8c 83       	std	Y+4, r24	; 0x04
	uint32_t ProgDataSize     = PM_GetStoredDataSize(TYPE_FLASH);
    3334:	81 e0       	ldi	r24, 0x01	; 1
    3336:	0e 94 f5 14 	call	0x29ea	; 0x29ea <PM_GetStoredDataSize>
    333a:	6b 01       	movw	r12, r22
    333c:	7c 01       	movw	r14, r24
	uint8_t  TotalOkHeadBytes = 0;
	uint8_t  TagByte;
	uint8_t  BytesRead;
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);    // Orange = busy
    333e:	81 b3       	in	r24, 0x11	; 17
    3340:	8f 7c       	andi	r24, 0xCF	; 207
    3342:	80 63       	ori	r24, 0x30	; 48
    3344:	81 bb       	out	0x11, r24	; 17

	while (DFPos < ProgDataSize)
	{
		BytesRead = 1;
		
		TagByte = SPI_SPITransmit(0x00);       // Get next byte from dataflash
		if (TagByte == HeadBuff[TotalOkHeadBytes++])
		{
			if (TotalOkHeadBytes == 4)
			{
				uint8_t HB;
			
				for (HB = 0; HB < 20; HB++)
				{
					TagByte = SPI_SPITransmit(0x00);
					Buffer[HB] = TagByte;
					
					if (TagByte == 0x00)
					  break;
				}
				
				Buffer[20] = '\0';             // Make sure string is null-terminated

				TagExists = TRUE;
				BytesRead = (HB + 2);

				LCD_puts(Buffer);
				MAIN_SETSTATUSLED(MAIN_STATLED_GREEN); // Green = ready
				return;
			}
		}
		else
		{
			TotalOkHeadBytes = ((TagByte == HeadBuff[0])? 1 : 0);
    3346:	09 81       	ldd	r16, Y+1	; 0x01
    3348:	10 e0       	ldi	r17, 0x00	; 0
    334a:	42 c0       	rjmp	.+132    	; 0x33d0 <TM_FindNextTag+0xcc>
    334c:	80 e0       	ldi	r24, 0x00	; 0
    334e:	0e 94 af 09 	call	0x135e	; 0x135e <SPI_SPITransmit>
    3352:	98 2f       	mov	r25, r24
    3354:	fe 01       	movw	r30, r28
    3356:	e1 0f       	add	r30, r17
    3358:	f1 1d       	adc	r31, r1
    335a:	81 81       	ldd	r24, Z+1	; 0x01
    335c:	98 17       	cp	r25, r24
    335e:	09 f5       	brne	.+66     	; 0x33a2 <TM_FindNextTag+0x9e>
    3360:	1f 5f       	subi	r17, 0xFF	; 255
    3362:	14 30       	cpi	r17, 0x04	; 4
    3364:	11 f5       	brne	.+68     	; 0x33aa <TM_FindNextTag+0xa6>
    3366:	8e 01       	movw	r16, r28
    3368:	0b 5f       	subi	r16, 0xFB	; 251
    336a:	1f 4f       	sbci	r17, 0xFF	; 255
    336c:	80 e0       	ldi	r24, 0x00	; 0
    336e:	0e 94 af 09 	call	0x135e	; 0x135e <SPI_SPITransmit>
    3372:	f8 01       	movw	r30, r16
    3374:	80 83       	st	Z, r24
    3376:	88 23       	and	r24, r24
    3378:	39 f0       	breq	.+14     	; 0x3388 <TM_FindNextTag+0x84>
    337a:	0f 5f       	subi	r16, 0xFF	; 255
    337c:	1f 4f       	sbci	r17, 0xFF	; 255
    337e:	ce 01       	movw	r24, r28
    3380:	49 96       	adiw	r24, 0x19	; 25
    3382:	08 17       	cp	r16, r24
    3384:	19 07       	cpc	r17, r25
    3386:	91 f7       	brne	.-28     	; 0x336c <TM_FindNextTag+0x68>
    3388:	19 8e       	std	Y+25, r1	; 0x19
    338a:	81 e0       	ldi	r24, 0x01	; 1
    338c:	80 93 b1 02 	sts	0x02B1, r24
    3390:	ce 01       	movw	r24, r28
    3392:	05 96       	adiw	r24, 0x05	; 5
    3394:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
    3398:	81 b3       	in	r24, 0x11	; 17
    339a:	8f 7c       	andi	r24, 0xCF	; 207
    339c:	80 61       	ori	r24, 0x10	; 16
    339e:	81 bb       	out	0x11, r24	; 17
    33a0:	42 c0       	rjmp	.+132    	; 0x3426 <TM_FindNextTag+0x122>
    33a2:	10 e0       	ldi	r17, 0x00	; 0
    33a4:	90 17       	cp	r25, r16
    33a6:	09 f4       	brne	.+2      	; 0x33aa <TM_FindNextTag+0xa6>
    33a8:	11 e0       	ldi	r17, 0x01	; 1
		}

		DFPos += BytesRead;
    33aa:	80 91 b2 02 	lds	r24, 0x02B2
    33ae:	90 91 b3 02 	lds	r25, 0x02B3
    33b2:	a0 91 b4 02 	lds	r26, 0x02B4
    33b6:	b0 91 b5 02 	lds	r27, 0x02B5
    33ba:	01 96       	adiw	r24, 0x01	; 1
    33bc:	a1 1d       	adc	r26, r1
    33be:	b1 1d       	adc	r27, r1
    33c0:	80 93 b2 02 	sts	0x02B2, r24
    33c4:	90 93 b3 02 	sts	0x02B3, r25
    33c8:	a0 93 b4 02 	sts	0x02B4, r26
    33cc:	b0 93 b5 02 	sts	0x02B5, r27
    33d0:	80 91 b2 02 	lds	r24, 0x02B2
    33d4:	90 91 b3 02 	lds	r25, 0x02B3
    33d8:	a0 91 b4 02 	lds	r26, 0x02B4
    33dc:	b0 91 b5 02 	lds	r27, 0x02B5
    33e0:	8c 15       	cp	r24, r12
    33e2:	9d 05       	cpc	r25, r13
    33e4:	ae 05       	cpc	r26, r14
    33e6:	bf 05       	cpc	r27, r15
    33e8:	08 f4       	brcc	.+2      	; 0x33ec <TM_FindNextTag+0xe8>
    33ea:	b0 cf       	rjmp	.-160    	; 0x334c <TM_FindNextTag+0x48>
	}
	
	DF_ContinuousReadEnable(0, 0);
    33ec:	60 e0       	ldi	r22, 0x00	; 0
    33ee:	70 e0       	ldi	r23, 0x00	; 0
    33f0:	80 e0       	ldi	r24, 0x00	; 0
    33f2:	90 e0       	ldi	r25, 0x00	; 0
    33f4:	0e 94 8d 0a 	call	0x151a	; 0x151a <DF_ContinuousReadEnable>
	DFPos = 0;
    33f8:	10 92 b2 02 	sts	0x02B2, r1
    33fc:	10 92 b3 02 	sts	0x02B3, r1
    3400:	10 92 b4 02 	sts	0x02B4, r1
    3404:	10 92 b5 02 	sts	0x02B5, r1
	
	if (TagExists == FALSE)
    3408:	80 91 b1 02 	lds	r24, 0x02B1
    340c:	88 23       	and	r24, r24
    340e:	49 f4       	brne	.+18     	; 0x3422 <TM_FindNextTag+0x11e>
	{
		MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);  // Green = ready
    3410:	81 b3       	in	r24, 0x11	; 17
    3412:	8f 7c       	andi	r24, 0xCF	; 207
    3414:	80 61       	ori	r24, 0x10	; 16
    3416:	81 bb       	out	0x11, r24	; 17
		MAIN_ShowError(PSTR("NO TAGS"));
    3418:	8e e5       	ldi	r24, 0x5E	; 94
    341a:	94 e0       	ldi	r25, 0x04	; 4
    341c:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
    3420:	02 c0       	rjmp	.+4      	; 0x3426 <TM_FindNextTag+0x122>
	}
	else
	{
		/* The following line _is_ recursion, but the function will only ever call itself
		   a maximum of one time. The function will call itself upon skipping from the last
		   tag stored in the program data to the first; to guard against infinite recursion
		   if no tags are present, the system will error out if the TagExists flag is empty
		   after a full data read. Once a tag has been read and displayed onto the LCD, the
           function returns to the main tag handling routine.                               */
		TM_FindNextTag();
    3422:	0e 94 82 19 	call	0x3304	; 0x3304 <TM_FindNextTag>
    3426:	69 96       	adiw	r28, 0x19	; 25
    3428:	0f b6       	in	r0, 0x3f	; 63
    342a:	f8 94       	cli
    342c:	de bf       	out	0x3e, r29	; 62
    342e:	0f be       	out	0x3f, r0	; 63
    3430:	cd bf       	out	0x3d, r28	; 61
    3432:	df 91       	pop	r29
    3434:	cf 91       	pop	r28
    3436:	1f 91       	pop	r17
    3438:	0f 91       	pop	r16
    343a:	ff 90       	pop	r15
    343c:	ef 90       	pop	r14
    343e:	df 90       	pop	r13
    3440:	cf 90       	pop	r12
    3442:	08 95       	ret

00003444 <TM_ShowTags>:
    3444:	60 e0       	ldi	r22, 0x00	; 0
    3446:	70 e0       	ldi	r23, 0x00	; 0
    3448:	80 e0       	ldi	r24, 0x00	; 0
    344a:	90 e0       	ldi	r25, 0x00	; 0
    344c:	0e 94 8d 0a 	call	0x151a	; 0x151a <DF_ContinuousReadEnable>
    3450:	10 92 b1 02 	sts	0x02B1, r1
    3454:	10 92 b2 02 	sts	0x02B2, r1
    3458:	10 92 b3 02 	sts	0x02B3, r1
    345c:	10 92 b4 02 	sts	0x02B4, r1
    3460:	10 92 b5 02 	sts	0x02B5, r1
    3464:	0e 94 82 19 	call	0x3304	; 0x3304 <TM_FindNextTag>
    3468:	80 91 b1 02 	lds	r24, 0x02B1
    346c:	88 23       	and	r24, r24
    346e:	71 f0       	breq	.+28     	; 0x348c <TM_ShowTags+0x48>
    3470:	8e b3       	in	r24, 0x1e	; 30
    3472:	88 23       	and	r24, r24
    3474:	e9 f3       	breq	.-6      	; 0x3470 <TM_ShowTags+0x2c>
    3476:	f7 9b       	sbis	0x1e, 7	; 30
    3478:	03 c0       	rjmp	.+6      	; 0x3480 <TM_ShowTags+0x3c>
    347a:	0e 94 82 19 	call	0x3304	; 0x3304 <TM_FindNextTag>
    347e:	02 c0       	rjmp	.+4      	; 0x3484 <TM_ShowTags+0x40>
    3480:	f2 99       	sbic	0x1e, 2	; 30
    3482:	03 c0       	rjmp	.+6      	; 0x348a <TM_ShowTags+0x46>
    3484:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
    3488:	f3 cf       	rjmp	.-26     	; 0x3470 <TM_ShowTags+0x2c>
    348a:	80 e0       	ldi	r24, 0x00	; 0
    348c:	0e 94 56 0a 	call	0x14ac	; 0x14ac <DF_EnableDataflash>
    3490:	08 95       	ret

00003492 <__vector_2>:
.global PCINT0_vect             ; Pin change 0 (joystick)
.global PCINT1_vect             ; Pin change 1 (joystick)

PCINT0_vect:
  jmp PCINT1_vect
    3492:	0c 94 b6 02 	jmp	0x56c	; 0x56c <__vector_3>

00003496 <__vector_10>:

.global TIMER0_COMP_vect             ; Timer 0 compare

TIMER0_COMP_vect:
  push r24
    3496:	8f 93       	push	r24
  ldi r24, (USI_CONTROL_REG_FLAGS | (1<<USITC))
    3498:	8b e5       	ldi	r24, 0x5B	; 91
  sts _SFR_MEM_ADDR(USICR), r24
    349a:	80 93 b8 00 	sts	0x00B8, r24
  pop r24
    349e:	8f 91       	pop	r24
  reti
    34a0:	18 95       	reti

000034a2 <strcpy_P>:
    34a2:	fb 01       	movw	r30, r22
    34a4:	dc 01       	movw	r26, r24
    34a6:	05 90       	lpm	r0, Z+
    34a8:	0d 92       	st	X+, r0
    34aa:	00 20       	and	r0, r0
    34ac:	e1 f7       	brne	.-8      	; 0x34a6 <strcpy_P+0x4>
    34ae:	08 95       	ret

000034b0 <ultoa>:
    34b0:	fa 01       	movw	r30, r20
    34b2:	cf 93       	push	r28
    34b4:	ff 93       	push	r31
    34b6:	ef 93       	push	r30
    34b8:	22 30       	cpi	r18, 0x02	; 2
    34ba:	cc f0       	brlt	.+50     	; 0x34ee <ultoa+0x3e>
    34bc:	25 32       	cpi	r18, 0x25	; 37
    34be:	bc f4       	brge	.+46     	; 0x34ee <ultoa+0x3e>
    34c0:	c2 2f       	mov	r28, r18
    34c2:	2c 2f       	mov	r18, r28
    34c4:	33 27       	eor	r19, r19
    34c6:	44 27       	eor	r20, r20
    34c8:	55 27       	eor	r21, r21
    34ca:	ff 93       	push	r31
    34cc:	ef 93       	push	r30
    34ce:	0e 94 b5 1a 	call	0x356a	; 0x356a <__udivmodsi4>
    34d2:	ef 91       	pop	r30
    34d4:	ff 91       	pop	r31
    34d6:	60 5d       	subi	r22, 0xD0	; 208
    34d8:	6a 33       	cpi	r22, 0x3A	; 58
    34da:	0c f0       	brlt	.+2      	; 0x34de <ultoa+0x2e>
    34dc:	69 5d       	subi	r22, 0xD9	; 217
    34de:	61 93       	st	Z+, r22
    34e0:	b9 01       	movw	r22, r18
    34e2:	ca 01       	movw	r24, r20
    34e4:	60 50       	subi	r22, 0x00	; 0
    34e6:	70 40       	sbci	r23, 0x00	; 0
    34e8:	80 40       	sbci	r24, 0x00	; 0
    34ea:	90 40       	sbci	r25, 0x00	; 0
    34ec:	51 f7       	brne	.-44     	; 0x34c2 <ultoa+0x12>
    34ee:	10 82       	st	Z, r1
    34f0:	8f 91       	pop	r24
    34f2:	9f 91       	pop	r25
    34f4:	cf 91       	pop	r28
    34f6:	0c 94 7d 1a 	jmp	0x34fa	; 0x34fa <strrev>

000034fa <strrev>:
    34fa:	dc 01       	movw	r26, r24
    34fc:	fc 01       	movw	r30, r24
    34fe:	01 90       	ld	r0, Z+
    3500:	00 20       	and	r0, r0
    3502:	e9 f7       	brne	.-6      	; 0x34fe <strrev+0x4>
    3504:	32 97       	sbiw	r30, 0x02	; 2
    3506:	ae 17       	cp	r26, r30
    3508:	bf 07       	cpc	r27, r31
    350a:	30 f4       	brcc	.+12     	; 0x3518 <strrev+0x1e>
    350c:	7c 91       	ld	r23, X
    350e:	60 81       	ld	r22, Z
    3510:	70 83       	st	Z, r23
    3512:	31 97       	sbiw	r30, 0x01	; 1
    3514:	6d 93       	st	X+, r22
    3516:	f7 cf       	rjmp	.-18     	; 0x3506 <strrev+0xc>
    3518:	08 95       	ret

0000351a <__eeprom_read_byte_1F2021>:
    351a:	f9 99       	sbic	0x1f, 1	; 31
    351c:	fe cf       	rjmp	.-4      	; 0x351a <__eeprom_read_byte_1F2021>
    351e:	b2 bd       	out	0x22, r27	; 34
    3520:	a1 bd       	out	0x21, r26	; 33
    3522:	f8 9a       	sbi	0x1f, 0	; 31
    3524:	11 96       	adiw	r26, 0x01	; 1
    3526:	00 b4       	in	r0, 0x20	; 32
    3528:	08 95       	ret

0000352a <__eeprom_read_block_1F2021>:
    352a:	f7 df       	rcall	.-18     	; 0x351a <__eeprom_read_byte_1F2021>
    352c:	01 92       	st	Z+, r0
    352e:	1a 94       	dec	r1
    3530:	e1 f7       	brne	.-8      	; 0x352a <__eeprom_read_block_1F2021>
    3532:	08 95       	ret

00003534 <__eeprom_read_word_1F2021>:
    3534:	f2 df       	rcall	.-28     	; 0x351a <__eeprom_read_byte_1F2021>
    3536:	e0 2d       	mov	r30, r0
    3538:	f0 df       	rcall	.-32     	; 0x351a <__eeprom_read_byte_1F2021>
    353a:	f0 2d       	mov	r31, r0
    353c:	08 95       	ret

0000353e <__eeprom_write_byte_1F2021>:
    353e:	f9 99       	sbic	0x1f, 1	; 31
    3540:	fe cf       	rjmp	.-4      	; 0x353e <__eeprom_write_byte_1F2021>
    3542:	b2 bd       	out	0x22, r27	; 34
    3544:	a1 bd       	out	0x21, r26	; 33
    3546:	00 bc       	out	0x20, r0	; 32
    3548:	11 96       	adiw	r26, 0x01	; 1
    354a:	0f b6       	in	r0, 0x3f	; 63
    354c:	f8 94       	cli
    354e:	fa 9a       	sbi	0x1f, 2	; 31
    3550:	f9 9a       	sbi	0x1f, 1	; 31
    3552:	0f be       	out	0x3f, r0	; 63
    3554:	08 95       	ret

00003556 <__eeprom_write_word_1F2021>:
    3556:	f3 df       	rcall	.-26     	; 0x353e <__eeprom_write_byte_1F2021>
    3558:	01 2c       	mov	r0, r1
    355a:	f1 df       	rcall	.-30     	; 0x353e <__eeprom_write_byte_1F2021>
    355c:	11 24       	eor	r1, r1
    355e:	08 95       	ret

00003560 <__eeprom_write_block_1F2021>:
    3560:	01 90       	ld	r0, Z+
    3562:	ed df       	rcall	.-38     	; 0x353e <__eeprom_write_byte_1F2021>
    3564:	1a 94       	dec	r1
    3566:	e1 f7       	brne	.-8      	; 0x3560 <__eeprom_write_block_1F2021>
    3568:	08 95       	ret

0000356a <__udivmodsi4>:
    356a:	a1 e2       	ldi	r26, 0x21	; 33
    356c:	1a 2e       	mov	r1, r26
    356e:	aa 1b       	sub	r26, r26
    3570:	bb 1b       	sub	r27, r27
    3572:	fd 01       	movw	r30, r26
    3574:	0d c0       	rjmp	.+26     	; 0x3590 <__udivmodsi4_ep>

00003576 <__udivmodsi4_loop>:
    3576:	aa 1f       	adc	r26, r26
    3578:	bb 1f       	adc	r27, r27
    357a:	ee 1f       	adc	r30, r30
    357c:	ff 1f       	adc	r31, r31
    357e:	a2 17       	cp	r26, r18
    3580:	b3 07       	cpc	r27, r19
    3582:	e4 07       	cpc	r30, r20
    3584:	f5 07       	cpc	r31, r21
    3586:	20 f0       	brcs	.+8      	; 0x3590 <__udivmodsi4_ep>
    3588:	a2 1b       	sub	r26, r18
    358a:	b3 0b       	sbc	r27, r19
    358c:	e4 0b       	sbc	r30, r20
    358e:	f5 0b       	sbc	r31, r21

00003590 <__udivmodsi4_ep>:
    3590:	66 1f       	adc	r22, r22
    3592:	77 1f       	adc	r23, r23
    3594:	88 1f       	adc	r24, r24
    3596:	99 1f       	adc	r25, r25
    3598:	1a 94       	dec	r1
    359a:	69 f7       	brne	.-38     	; 0x3576 <__udivmodsi4_loop>
    359c:	60 95       	com	r22
    359e:	70 95       	com	r23
    35a0:	80 95       	com	r24
    35a2:	90 95       	com	r25
    35a4:	9b 01       	movw	r18, r22
    35a6:	ac 01       	movw	r20, r24
    35a8:	bd 01       	movw	r22, r26
    35aa:	cf 01       	movw	r24, r30
    35ac:	08 95       	ret

000035ae <_exit>:
    35ae:	ff cf       	rjmp	.-2      	; 0x35ae <_exit>
