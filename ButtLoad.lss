
ButtLoad.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  00003538  000035ec  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003538  00000000  00000000  000000b4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b4  00800104  00800104  000035f0  2**0
                  ALLOC
  3 .noinit       00000000  008002b8  008002b8  00003679  2**0
                  CONTENTS
  4 .eeprom       00000089  00810000  00810000  000035f0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  5 .stab         000003e4  00000000  00000000  0000367c  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      000000fb  00000000  00000000  00003a60  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 0000012c  00000000  00000000  00003b5b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000d49  00000000  00000000  00003c87  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000041ec  00000000  00000000  000049d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000100a  00000000  00000000  00008bbc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000033aa  00000000  00000000  00009bc6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0000114f  00000000  00000000  0000cf70  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 11 02 	jmp	0x422 <__init>
       4:	0c 94 2c 02 	jmp	0x458 <__bad_interrupt>
       8:	0c 94 0e 1a 	jmp	0x341c <__vector_2>
       c:	0c 94 91 03 	jmp	0x722 <__vector_3>
      10:	0c 94 c9 0b 	jmp	0x1792 <__vector_4>
      14:	0c 94 e6 07 	jmp	0xfcc <__vector_5>
      18:	0c 94 2c 02 	jmp	0x458 <__bad_interrupt>
      1c:	0c 94 2c 02 	jmp	0x458 <__bad_interrupt>
      20:	0c 94 2c 02 	jmp	0x458 <__bad_interrupt>
      24:	0c 94 0d 0c 	jmp	0x181a <__vector_9>
      28:	0c 94 10 1a 	jmp	0x3420 <__vector_10>
      2c:	0c 94 2c 02 	jmp	0x458 <__bad_interrupt>
      30:	0c 94 2c 02 	jmp	0x458 <__bad_interrupt>
      34:	0c 94 4f 0b 	jmp	0x169e <__vector_13>
      38:	0c 94 2c 02 	jmp	0x458 <__bad_interrupt>
      3c:	0c 94 2c 02 	jmp	0x458 <__bad_interrupt>
      40:	0c 94 2c 02 	jmp	0x458 <__bad_interrupt>
      44:	0c 94 48 09 	jmp	0x1290 <__vector_17>
      48:	0c 94 2c 02 	jmp	0x458 <__bad_interrupt>
      4c:	0c 94 2c 02 	jmp	0x458 <__bad_interrupt>
      50:	0c 94 2c 02 	jmp	0x458 <__bad_interrupt>
      54:	0c 94 2c 02 	jmp	0x458 <__bad_interrupt>
      58:	0c 94 93 08 	jmp	0x1126 <__vector_22>

0000005c <SIFONames>:
      5c:	53 54 4f 52 41 47 45 20 53 49 5a 45 53 20 56 49     STORAGE SIZES VI
      6c:	45 57 20 44 41 54 41 20 54 41 47 53                 EW DATA TAGS

00000078 <USISpeeds>:
      78:	20 35 37 31 35 33 20 48 5a 20 38 36 37 33 38 20      57153 HZ 86738 
      88:	48 5a 31 31 33 34 32 37 20 48 5a 32 31 30 36 35     HZ113427 HZ21065
      98:	31 20 48 5a                                         1 HZ

0000009c <ProgOptions>:
      9c:	05 01 f9 00 e9 00 d9 00 c9 00 b5 00 aa 00           ..............

000000aa <PRG_C>:
      aa:	45 52 41 53 45 20 4f 4e 4c 59 00                    ERASE ONLY.

000000b5 <PRG_FL>:
      b5:	46 55 53 45 20 41 4e 44 20 4c 4f 43 4b 20 42 59     FUSE AND LOCK BY
      c5:	54 45 53 00                                         TES.

000000c9 <PRG_L>:
      c9:	4c 4f 43 4b 20 42 59 54 45 53 20 4f 4e 4c 59 00     LOCK BYTES ONLY.

000000d9 <PRG_F>:
      d9:	46 55 53 45 20 42 59 54 45 53 20 4f 4e 4c 59 00     FUSE BYTES ONLY.

000000e9 <PRG_DE>:
      e9:	44 41 54 41 20 41 4e 44 20 45 45 50 52 4f 4d 00     DATA AND EEPROM.

000000f9 <PRG_E>:
      f9:	45 45 50 52 4f 4d 20 4f 4e 4c 59 00                 EEPROM ONLY.

00000105 <PRG_D>:
     105:	44 41 54 41 20 4f 4e 4c 59 00                       DATA ONLY.

0000010f <SettingFunctionPtrs>:
     10f:	cf 05 22 06 5a 06 a6 06 9b 05 73 07                 ..".Z.....s.

0000011b <SettingFunctionNames>:
     11b:	78 01 6a 01 59 01 47 01 3a 01 27 01                 x.j.Y.G.:.'.

00000127 <SFunc_GOBOOTLOADER>:
     127:	4a 55 4d 50 20 54 4f 20 42 4f 4f 54 4c 4f 41 44     JUMP TO BOOTLOAD
     137:	45 52 00                                            ER.

0000013a <SFunc_CLEARMEM>:
     13a:	43 4c 45 41 52 20 4d 45 4d 4f 52 59 00              CLEAR MEMORY.

00000147 <SFunc_SETAUTOSLEEPTO>:
     147:	53 45 54 20 53 4c 45 45 50 20 54 49 4d 45 4f 55     SET SLEEP TIMEOU
     157:	54 00                                               T.

00000159 <SFunc_SETFIRMMINOR>:
     159:	53 45 54 20 46 49 52 4d 20 56 45 52 53 49 4f 4e     SET FIRM VERSION
	...

0000016a <SFunc_SETSPISPEED>:
     16a:	53 45 54 20 53 50 49 20 53 50 45 45 44 00           SET SPI SPEED.

00000178 <SFunc_SETCONTRAST>:
     178:	53 45 54 20 43 4f 4e 54 52 41 53 54 00              SET CONTRAST.

00000185 <MainFunctionPtrs>:
     185:	ea 03 69 05 34 04 03 04 1d 07 b5 03 09 07           ..i.4.........

00000193 <MainFunctionNames>:
     193:	ea 01 df 01 d3 01 c4 01 b5 01 ac 01 a1 01           ..............

000001a1 <Func_SLEEP>:
     1a1:	53 4c 45 45 50 20 4d 4f 44 45 00                    SLEEP MODE.

000001ac <Func_SETTINGS>:
     1ac:	53 45 54 54 49 4e 47 53 00                          SETTINGS.

000001b5 <Func_PRGMSTOREINFO>:
     1b5:	44 41 54 41 53 54 4f 52 45 20 49 4e 46 4f 00        DATASTORE INFO.

000001c4 <Func_PRGMDATAFLASH>:
     1c4:	44 41 54 41 46 4c 41 53 48 20 50 52 47 4d 00        DATAFLASH PRGM.

000001d3 <Func_PRGMAVR>:
     1d3:	50 52 4f 47 52 41 4d 20 41 56 52 00                 PROGRAM AVR.

000001df <Func_STOREPRGM>:
     1df:	53 54 4f 52 45 20 50 52 47 4d 00                    STORE PRGM.

000001ea <Func_ISPPRGM>:
     1ea:	41 56 52 49 53 50 20 4d 4f 44 45 00                 AVRISP MODE.

000001f6 <AboutTextPtrs>:
     1f6:	21 02 1c 02 0d 02 fe 01                             !.......

000001fe <CopyRight>:
     1fe:	3c 43 3e 20 32 30 30 36 20 2d 20 47 50 4c 00        <C> 2006 - GPL.

0000020d <AuthorName>:
     20d:	42 59 20 44 45 41 4e 20 43 41 4d 45 52 41 00        BY DEAN CAMERA.

0000021c <VersionInfo>:
     21c:	56 31 2d 34 00                                      V1-4.

00000221 <ProgrammerName>:
     221:	42 55 54 54 4c 4f 41 44 00                          BUTTLOAD.

0000022a <WaitText>:
     22a:	2a 57 41 49 54 2a 00                                *WAIT*.

00000231 <BUTTTAG_Author>:
     231:	40 28 23 29 42 59 20 44 45 41 4e 20 43 41 4d 45     @(#)BY DEAN CAME
     241:	52 41 00                                            RA.

00000244 <BUTTTAG_Name>:
     244:	40 28 23 29 42 55 54 54 4c 4f 41 44 20 41 56 52     @(#)BUTTLOAD AVR
     254:	49 53 50 00                                         ISP.

00000258 <__c.17>:
     258:	50 52 47 3e 20 20 00                                PRG>  .

0000025f <__c.16>:
     25f:	42 41 44 49 53 52 00                                BADISR.

00000266 <__c.9>:
     266:	4e 4f 20 45 52 41 53 45 20 43 4d 44 00              NO ERASE CMD.

00000273 <__c.10>:
     273:	4e 4f 20 44 41 54 41 00                             NO DATA.

0000027b <__c.11>:
     27b:	4e 4f 20 45 45 50 52 4f 4d 00                       NO EEPROM.

00000285 <__c.12>:
     285:	4e 4f 20 46 55 53 45 20 42 59 54 45 53 00           NO FUSE BYTES.

00000293 <__c.13>:
     293:	4e 4f 20 4c 4f 43 4b 20 42 59 54 45 53 00           NO LOCK BYTES.

000002a1 <__c.14>:
     2a1:	50 52 4f 47 52 41 4d 4d 49 4e 47 20 44 4f 4e 45     PROGRAMMING DONE
	...

000002b2 <__c.15>:
     2b2:	46 41 49 4c 45 44 00                                FAILED.

000002b9 <__c.8>:
     2b9:	2a 53 54 4f 52 41 47 45 20 4d 4f 44 45 2a 00        *STORAGE MODE*.

000002c8 <__c.5>:
     2c8:	43 4f 4e 46 49 52 4d 00                             CONFIRM.

000002d0 <__c.6>:
     2d0:	3c 4e 20 59 3e 00                                   <N Y>.

000002d6 <__c.7>:
     2d6:	4d 45 4d 20 43 4c 45 41 52 45 44 00                 MEM CLEARED.

000002e2 <__c.4>:
     2e2:	56 32 2d 20 00                                      V2- .

000002e7 <__c.2>:
     2e7:	20 20 20 20 53 45 43 00                                 SEC.

000002ef <__c.3>:
     2ef:	4f 46 46 00                                         OFF.

000002f3 <__c.1>:
     2f3:	4e 4f 20 53 54 4f 52 45 44 20 50 52 47 4d 00        NO STORED PRGM.

00000302 <__c.0>:
     302:	2a 4a 54 41 47 20 4f 4e 2a 00                       *JTAG ON*.

0000030c <LCD_SegTable>:
     30c:	a8 ea 80 2a 00 40 00 0a 51 0a 08 40 59 55 18 01     ...*.@..Q..@YU..
     31c:	11 1e 11 1b 50 0b 41 1b 41 1f 11 01 51 1f 51 1b     ....P.A.A...Q.Q.
     32c:	00 00 00 00 08 80 00 1a 20 40 00 00 00 00 51 0f     ........ @....Q.
     33c:	91 39 41 14 91 31 41 1e 41 0e 41 1d 50 0f 80 20     .9A..1A.A.A.P.. 
     34c:	10 15 48 86 40 14 78 05 70 85 51 15 51 0e 51 95     ..H.@.x.p.Q.Q.Q.
     35c:	51 8e 21 90 81 20 50 15 48 44 50 c5 28 c0 28 20     Q.!.. P.HDP.(.( 
     36c:	09 50 41 14 20 80 11 11 00 00 00 10                 .PA. .......

00000378 <USIPSValues>:
     378:	03 80 02 54 01 40 00 22                             ...T.@."

00000380 <DataFlashError>:
     380:	44 41 54 41 46 4c 41 53 48 20 45 52 52 4f 52 00     DATAFLASH ERROR.

00000390 <DF_Pages>:
     390:	00 01 00 02 00 04 00 08 00 10 00 10 00 20 00 20     ............. . 

000003a0 <DF_PageSize>:
     3a0:	08 01 08 01 08 01 08 01 08 01 10 02 10 02 20 04     .............. .

000003b0 <DF_PageBits>:
     3b0:	09 09 09 09 09 0a 0a 0b                             ........

000003b8 <__c.0>:
     3b8:	42 55 46 46 20 4f 56 45 52 46 4c 4f 57 00           BUFF OVERFLOW.

000003c6 <AutoSleepTOValues>:
     3c6:	00 0f 1e 3c 78                                      ...<x

000003cb <DataFlashProgMode>:
     3cb:	2a 44 41 54 41 46 4c 41 53 48 20 4d 4f 44 45 2a     *DATAFLASH MODE*
	...

000003dc <SignonResponse>:
     3dc:	01 00 08 41 56 52 49 53 50 5f 32                    ...AVRISP_2

000003e7 <SyncErrorMessage>:
     3e7:	53 59 4e 43 20 45 52 52 4f 52 00                    SYNC ERROR.

000003f2 <AVRISPModeMessage>:
     3f2:	2a 41 54 41 56 52 49 53 50 20 4d 4f 44 45 2a 00     *ATAVRISP MODE*.

00000402 <__c.0>:
     402:	44 41 54 41 2d 00                                   DATA-.

00000408 <__c.1>:
     408:	45 50 52 4d 2d 00                                   EPRM-.

0000040e <__c.2>:
     40e:	46 55 53 45 2d 00                                   FUSE-.

00000414 <__c.3>:
     414:	4c 4f 43 4b 2d 00                                   LOCK-.

0000041a <__c.0>:
     41a:	4e 4f 20 54 41 47 53 00                             NO TAGS.

00000422 <__init>:
     422:	11 24       	eor	r1, r1
     424:	1f be       	out	0x3f, r1	; 63
     426:	cf ef       	ldi	r28, 0xFF	; 255
     428:	d4 e0       	ldi	r29, 0x04	; 4
     42a:	de bf       	out	0x3e, r29	; 62
     42c:	cd bf       	out	0x3d, r28	; 61

0000042e <__do_copy_data>:
     42e:	11 e0       	ldi	r17, 0x01	; 1
     430:	a0 e0       	ldi	r26, 0x00	; 0
     432:	b1 e0       	ldi	r27, 0x01	; 1
     434:	e8 e3       	ldi	r30, 0x38	; 56
     436:	f5 e3       	ldi	r31, 0x35	; 53
     438:	02 c0       	rjmp	.+4      	; 0x43e <.do_copy_data_start>

0000043a <.do_copy_data_loop>:
     43a:	05 90       	lpm	r0, Z+
     43c:	0d 92       	st	X+, r0

0000043e <.do_copy_data_start>:
     43e:	a4 30       	cpi	r26, 0x04	; 4
     440:	b1 07       	cpc	r27, r17
     442:	d9 f7       	brne	.-10     	; 0x43a <.do_copy_data_loop>

00000444 <__do_clear_bss>:
     444:	12 e0       	ldi	r17, 0x02	; 2
     446:	a4 e0       	ldi	r26, 0x04	; 4
     448:	b1 e0       	ldi	r27, 0x01	; 1
     44a:	01 c0       	rjmp	.+2      	; 0x44e <.do_clear_bss_start>

0000044c <.do_clear_bss_loop>:
     44c:	1d 92       	st	X+, r1

0000044e <.do_clear_bss_start>:
     44e:	a8 3b       	cpi	r26, 0xB8	; 184
     450:	b1 07       	cpc	r27, r17
     452:	e1 f7       	brne	.-8      	; 0x44c <.do_clear_bss_loop>
     454:	0c 94 72 02 	jmp	0x4e4 <main>

00000458 <__bad_interrupt>:
     458:	0c 94 b0 03 	jmp	0x760 <__vector_default>

0000045c <MAIN_Delay10MS>:

// ======================================================================================

void MAIN_Delay10MS(uint8_t loops)
{
     45c:	cf 93       	push	r28
     45e:	df 93       	push	r29
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     460:	28 2f       	mov	r18, r24
     462:	21 50       	subi	r18, 0x01	; 1
     464:	2f 3f       	cpi	r18, 0xFF	; 255
     466:	49 f0       	breq	.+18     	; 0x47a <MAIN_Delay10MS+0x1e>
     468:	a0 e0       	ldi	r26, 0x00	; 0
     46a:	b8 e4       	ldi	r27, 0x48	; 72
     46c:	c0 e0       	ldi	r28, 0x00	; 0
     46e:	d0 e0       	ldi	r29, 0x00	; 0
     470:	cd 01       	movw	r24, r26
     472:	01 97       	sbiw	r24, 0x01	; 1
     474:	f1 f7       	brne	.-4      	; 0x472 <MAIN_Delay10MS+0x16>
     476:	21 50       	subi	r18, 0x01	; 1
     478:	d8 f7       	brcc	.-10     	; 0x470 <MAIN_Delay10MS+0x14>
     47a:	df 91       	pop	r29
     47c:	cf 91       	pop	r28
     47e:	08 95       	ret

00000480 <MAIN_WaitForJoyRelease>:
  /* Prevents the use of floating point libraries. Delaying in groups of
     10ms increases accuracy by reducing the time overhead for each loop
     interation of the while.                                            */

	while (loops--)
	  _delay_ms(10);
}

void MAIN_Delay1MS(uint8_t loops)
{
  /* Prevents the use of floating point libraries. Less accurate than the
     Delay10MS routine, but nessesary for many commands. The overhead required
     to call the routine is substantially less than the overhead required to
     calculate the float at compile time, so this actually saves execution time. */

	while (loops--)
	  _delay_ms(1);
}

void MAIN_ResetCSLine(const uint8_t ActiveInactive)
{
	/* ActiveInactive controls the /Reset line to an AVR device or external dataflash
	/CS line. If the reset polarity parameter is a 0 then interfacing with AT89
	devices which has an active high reset. Pins are tristated when inactive.         */
	
	switch (ActiveInactive)
	{
		case MAIN_RESETCS_ACTIVE:      // The target RESET line may be either active high or low.
			DDRF |= (1 << 6);
		
			if (!(eeprom_read_byte(&EEPROMVars.ResetPolarity))) // Translate to correct logic level for target device type
			  PORTF |=  (1 << 6);
			else
			  PORTF &= ~(1 << 6);
		
			break;
		case MAIN_RESETCS_EXTDFACTIVE: // Dataflashes are always active low.
			DDRF  |=  (1 << 6);
			PORTF &= ~(1 << 6);
			
			break;
		case MAIN_RESETCS_INACTIVE:    // Both modes tristate the pins when inactive.
			DDRF  &= ~(1 << 6);
			PORTF &= ~(1 << 6);
	}
}

void MAIN_WaitForJoyRelease(void)
{
	while (1)
	{
		while (JoyStatus) {};                   // Wait until joystick released
     480:	8e b3       	in	r24, 0x1e	; 30
     482:	88 23       	and	r24, r24
     484:	e9 f7       	brne	.-6      	; 0x480 <MAIN_WaitForJoyRelease>

		MAIN_Delay10MS(1);
     486:	81 e0       	ldi	r24, 0x01	; 1
     488:	0e 94 2e 02 	call	0x45c <MAIN_Delay10MS>

		if (!(JoyStatus))                       // Joystick still released (not bouncing), return
     48c:	8e b3       	in	r24, 0x1e	; 30
     48e:	88 23       	and	r24, r24
     490:	b9 f7       	brne	.-18     	; 0x480 <MAIN_WaitForJoyRelease>
     492:	08 95       	ret

00000494 <FUNCShowAbout>:
		  return;
	}
}

void MAIN_IntToStr(uint16_t IntV, uint8_t* Buff)
{
	// Shows leading zeros, unlike itoa.

	uint8_t Temp = 0;
	
	while (IntV >= 100)
	{
		Temp++;
		IntV -= 100;
	}

	*(Buff++) = '0' + Temp;
	
	Temp = 0;
	
	while (IntV >= 10)
	{
		Temp++;
		IntV -= 10;
	}
		
	*(Buff++) = '0' + Temp;
	*(Buff++) = '0' + IntV;
	*(Buff)   = '\0';
}

void MAIN_ShowProgType(const uint8_t Letter)
{
	uint8_t ProgTypeBuffer[7];

	strcpy_P(ProgTypeBuffer, PSTR("PRG>  "));
	ProgTypeBuffer[5] = Letter;
	
	LCD_puts(ProgTypeBuffer);
}

void MAIN_ShowError(const uint8_t *pFlashStr)
{
	uint8_t ErrorBuff[LCD_TEXTBUFFER_SIZE];   // New buffer, LCD text buffer size
	
	ErrorBuff[0] = 'E';
	ErrorBuff[1] = '>';

	strcpy_P(&ErrorBuff[2], pFlashStr);       // WARNING: If error text is larger than (TEXTBUFFER_SIZE - 2),
	                                          // this will overflow the buffer and probably crash the micro!
	LCD_puts(ErrorBuff);
	
	MAIN_WaitForJoyRelease();
	while (!(JoyStatus & JOY_PRESS)) {};
	MAIN_WaitForJoyRelease();
}

// ======================================================================================

ISR(PCINT1_vect, ISR_NOBLOCK)                 // Joystick routine; PCINT0_vect is bound to this also via JoystickInterrupt.S
{
	JoyStatus = (~PINB & JOY_BMASK)
	          | (~PINE & JOY_EMASK);
			  
	TIMEOUT_SLEEP_TIMEOUT_RESET();
}

ISR(BADISR_vect, ISR_NAKED)                   // Bad ISR routine; should never be called, here for safety
{
	MAIN_ShowError(PSTR("BADISR"));
	while (1) {};
}

// ======================================================================================

void FUNCChangeSettings(void)
{
	uint8_t CurrSFunc = 0;
	
	JoyStatus = 1;

	while (1)
	{
		if (JoyStatus)                         // Joystick is in the non-center position
		{
			if (JoyStatus & JOY_UP)            // Previous function
			  (CurrSFunc == 0)? CurrSFunc = 5 : CurrSFunc--;
			else if (JoyStatus & JOY_DOWN)     // Next function
			  (CurrSFunc == 5)? CurrSFunc = 0 : CurrSFunc++;
			else if (JoyStatus & JOY_PRESS)    // Select current function
			  ((FuncPtr)pgm_read_word(&SettingFunctionPtrs[CurrSFunc]))(); // Run associated function
			else if (JoyStatus & JOY_LEFT)
			  return;
		
			// Show current function onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&SettingFunctionNames[CurrSFunc]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCShowAbout(void)
{
     494:	cf 93       	push	r28
	uint8_t InfoNum = 0;
     496:	c0 e0       	ldi	r28, 0x00	; 0
	
	JoyStatus = 1;
     498:	81 e0       	ldi	r24, 0x01	; 1
     49a:	8e bb       	out	0x1e, r24	; 30
			
	while (1)
	{
		if (JoyStatus)
     49c:	8e b3       	in	r24, 0x1e	; 30
     49e:	88 23       	and	r24, r24
     4a0:	e9 f3       	breq	.-6      	; 0x49c <FUNCShowAbout+0x8>
		{
			if (JoyStatus & JOY_UP)
     4a2:	f6 9b       	sbis	0x1e, 6	; 30
     4a4:	06 c0       	rjmp	.+12     	; 0x4b2 <FUNCShowAbout+0x1e>
			  (InfoNum == 0)? InfoNum = 3 : InfoNum--;
     4a6:	cc 23       	and	r28, r28
     4a8:	11 f4       	brne	.+4      	; 0x4ae <FUNCShowAbout+0x1a>
     4aa:	c3 e0       	ldi	r28, 0x03	; 3
     4ac:	0c c0       	rjmp	.+24     	; 0x4c6 <FUNCShowAbout+0x32>
     4ae:	c1 50       	subi	r28, 0x01	; 1
     4b0:	0a c0       	rjmp	.+20     	; 0x4c6 <FUNCShowAbout+0x32>
			else if (JoyStatus & JOY_DOWN)
     4b2:	f7 9b       	sbis	0x1e, 7	; 30
     4b4:	06 c0       	rjmp	.+12     	; 0x4c2 <FUNCShowAbout+0x2e>
			  (InfoNum == 3)? InfoNum = 0 : InfoNum++;
     4b6:	c3 30       	cpi	r28, 0x03	; 3
     4b8:	11 f4       	brne	.+4      	; 0x4be <FUNCShowAbout+0x2a>
     4ba:	c0 e0       	ldi	r28, 0x00	; 0
     4bc:	04 c0       	rjmp	.+8      	; 0x4c6 <FUNCShowAbout+0x32>
     4be:	cf 5f       	subi	r28, 0xFF	; 255
     4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <FUNCShowAbout+0x32>
			else if (JoyStatus & JOY_LEFT)
     4c2:	f2 99       	sbic	0x1e, 2	; 30
     4c4:	0d c0       	rjmp	.+26     	; 0x4e0 <FUNCShowAbout+0x4c>
			  return;

			LCD_puts_f((uint8_t*)pgm_read_word(&AboutTextPtrs[InfoNum]));
     4c6:	ec 2f       	mov	r30, r28
     4c8:	ff 27       	eor	r31, r31
     4ca:	ee 0f       	add	r30, r30
     4cc:	ff 1f       	adc	r31, r31
     4ce:	ea 50       	subi	r30, 0x0A	; 10
     4d0:	fe 4f       	sbci	r31, 0xFE	; 254
     4d2:	85 91       	lpm	r24, Z+
     4d4:	94 91       	lpm	r25, Z
     4d6:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     4da:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>
     4de:	de cf       	rjmp	.-68     	; 0x49c <FUNCShowAbout+0x8>
     4e0:	cf 91       	pop	r28
     4e2:	08 95       	ret

000004e4 <main>:
     4e4:	cf ef       	ldi	r28, 0xFF	; 255
     4e6:	d4 e0       	ldi	r29, 0x04	; 4
     4e8:	de bf       	out	0x3e, r29	; 62
     4ea:	cd bf       	out	0x3d, r28	; 61
     4ec:	c0 e0       	ldi	r28, 0x00	; 0
     4ee:	80 e8       	ldi	r24, 0x80	; 128
     4f0:	80 bf       	out	0x30, r24	; 48
     4f2:	85 e0       	ldi	r24, 0x05	; 5
     4f4:	80 93 64 00 	sts	0x0064, r24
     4f8:	80 e3       	ldi	r24, 0x30	; 48
     4fa:	80 bb       	out	0x10, r24	; 16
     4fc:	87 e2       	ldi	r24, 0x27	; 39
     4fe:	84 b9       	out	0x04, r24	; 4
     500:	8f ed       	ldi	r24, 0xDF	; 223
     502:	85 b9       	out	0x05, r24	; 5
     504:	8c e0       	ldi	r24, 0x0C	; 12
     506:	8e b9       	out	0x0e, r24	; 14
     508:	80 93 6b 00 	sts	0x006B, r24
     50c:	80 ed       	ldi	r24, 0xD0	; 208
     50e:	80 93 6c 00 	sts	0x006C, r24
     512:	80 ec       	ldi	r24, 0xC0	; 192
     514:	8d bb       	out	0x1d, r24	; 29
     516:	8c bb       	out	0x1c, r24	; 28
     518:	81 b3       	in	r24, 0x11	; 17
     51a:	8f 7c       	andi	r24, 0xCF	; 207
     51c:	80 62       	ori	r24, 0x20	; 32
     51e:	81 bb       	out	0x11, r24	; 17
     520:	0e 94 07 08 	call	0x100e <LCD_Init>
     524:	8f e0       	ldi	r24, 0x0F	; 15
     526:	80 93 e7 00 	sts	0x00E7, r24
     52a:	8a e2       	ldi	r24, 0x2A	; 42
     52c:	92 e0       	ldi	r25, 0x02	; 2
     52e:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>
     532:	78 94       	sei
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     534:	28 e8       	ldi	r18, 0x88	; 136
     536:	30 e0       	ldi	r19, 0x00	; 0
  uint8_t result;
  asm volatile
     538:	d9 01       	movw	r26, r18
     53a:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
     53e:	80 2d       	mov	r24, r0
     540:	8a 37       	cpi	r24, 0x7A	; 122
     542:	89 f0       	breq	.+34     	; 0x566 <__stack+0x67>
     544:	80 e0       	ldi	r24, 0x00	; 0
     546:	90 e0       	ldi	r25, 0x00	; 0
     548:	4f ef       	ldi	r20, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     54a:	dc 01       	movw	r26, r24
     54c:	04 2e       	mov	r0, r20
     54e:	0e 94 64 1a 	call	0x34c8 <__eeprom_write_byte_1F2021>
     552:	01 96       	adiw	r24, 0x01	; 1
     554:	52 e0       	ldi	r21, 0x02	; 2
     556:	80 30       	cpi	r24, 0x00	; 0
     558:	95 07       	cpc	r25, r21
     55a:	b8 f3       	brcs	.-18     	; 0x54a <__stack+0x4b>
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
     55c:	8a e7       	ldi	r24, 0x7A	; 122
  asm volatile (
     55e:	d9 01       	movw	r26, r18
     560:	08 2e       	mov	r0, r24
     562:	0e 94 64 1a 	call	0x34c8 <__eeprom_write_byte_1F2021>
     566:	a5 e8       	ldi	r26, 0x85	; 133
     568:	b0 e0       	ldi	r27, 0x00	; 0
     56a:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
     56e:	80 2d       	mov	r24, r0
     570:	8f 70       	andi	r24, 0x0F	; 15
     572:	80 93 e7 00 	sts	0x00E7, r24
     576:	80 e0       	ldi	r24, 0x00	; 0
     578:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
     57c:	81 b3       	in	r24, 0x11	; 17
     57e:	80 63       	ori	r24, 0x30	; 48
     580:	81 bb       	out	0x11, r24	; 17
     582:	0e 94 04 09 	call	0x1208 <USART_Init>
     586:	0e 94 81 07 	call	0xf02 <OSCCAL_Calibrate>
     58a:	0e 94 e4 0b 	call	0x17c8 <TOUT_SetupSleepTimer>
     58e:	81 b3       	in	r24, 0x11	; 17
     590:	8f 7c       	andi	r24, 0xCF	; 207
     592:	80 61       	ori	r24, 0x10	; 16
     594:	81 bb       	out	0x11, r24	; 17
     596:	81 e0       	ldi	r24, 0x01	; 1
     598:	8e bb       	out	0x1e, r24	; 30
     59a:	80 e8       	ldi	r24, 0x80	; 128
     59c:	80 93 61 00 	sts	0x0061, r24
     5a0:	83 e0       	ldi	r24, 0x03	; 3
     5a2:	80 93 61 00 	sts	0x0061, r24
     5a6:	8e b3       	in	r24, 0x1e	; 30
     5a8:	88 23       	and	r24, r24
     5aa:	e9 f3       	breq	.-6      	; 0x5a6 <__stack+0xa7>
     5ac:	f6 9b       	sbis	0x1e, 6	; 30
     5ae:	06 c0       	rjmp	.+12     	; 0x5bc <__stack+0xbd>
     5b0:	cc 23       	and	r28, r28
     5b2:	11 f4       	brne	.+4      	; 0x5b8 <__stack+0xb9>
     5b4:	c6 e0       	ldi	r28, 0x06	; 6
     5b6:	1b c0       	rjmp	.+54     	; 0x5ee <__stack+0xef>
     5b8:	c1 50       	subi	r28, 0x01	; 1
     5ba:	19 c0       	rjmp	.+50     	; 0x5ee <__stack+0xef>
     5bc:	f7 9b       	sbis	0x1e, 7	; 30
     5be:	06 c0       	rjmp	.+12     	; 0x5cc <__stack+0xcd>
     5c0:	c6 30       	cpi	r28, 0x06	; 6
     5c2:	11 f4       	brne	.+4      	; 0x5c8 <__stack+0xc9>
     5c4:	c0 e0       	ldi	r28, 0x00	; 0
     5c6:	13 c0       	rjmp	.+38     	; 0x5ee <__stack+0xef>
     5c8:	cf 5f       	subi	r28, 0xFF	; 255
     5ca:	11 c0       	rjmp	.+34     	; 0x5ee <__stack+0xef>
     5cc:	f4 9b       	sbis	0x1e, 4	; 30
     5ce:	0b c0       	rjmp	.+22     	; 0x5e6 <__stack+0xe7>
     5d0:	ec 2f       	mov	r30, r28
     5d2:	ff 27       	eor	r31, r31
     5d4:	ee 0f       	add	r30, r30
     5d6:	ff 1f       	adc	r31, r31
     5d8:	eb 57       	subi	r30, 0x7B	; 123
     5da:	fe 4f       	sbci	r31, 0xFE	; 254
     5dc:	85 91       	lpm	r24, Z+
     5de:	94 91       	lpm	r25, Z
     5e0:	fc 01       	movw	r30, r24
     5e2:	09 95       	icall
     5e4:	04 c0       	rjmp	.+8      	; 0x5ee <__stack+0xef>
     5e6:	f3 9b       	sbis	0x1e, 3	; 30
     5e8:	02 c0       	rjmp	.+4      	; 0x5ee <__stack+0xef>
     5ea:	0e 94 4a 02 	call	0x494 <FUNCShowAbout>
     5ee:	ec 2f       	mov	r30, r28
     5f0:	ff 27       	eor	r31, r31
     5f2:	ee 0f       	add	r30, r30
     5f4:	ff 1f       	adc	r31, r31
     5f6:	ed 56       	subi	r30, 0x6D	; 109
     5f8:	fe 4f       	sbci	r31, 0xFE	; 254
     5fa:	85 91       	lpm	r24, Z+
     5fc:	94 91       	lpm	r25, Z
     5fe:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>
     602:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>
     606:	cf cf       	rjmp	.-98     	; 0x5a6 <__stack+0xa7>

00000608 <MAIN_Delay1MS>:
     608:	cf 93       	push	r28
     60a:	df 93       	push	r29
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     60c:	28 2f       	mov	r18, r24
     60e:	21 50       	subi	r18, 0x01	; 1
     610:	2f 3f       	cpi	r18, 0xFF	; 255
     612:	49 f0       	breq	.+18     	; 0x626 <MAIN_Delay1MS+0x1e>
     614:	a3 e3       	ldi	r26, 0x33	; 51
     616:	b7 e0       	ldi	r27, 0x07	; 7
     618:	c0 e0       	ldi	r28, 0x00	; 0
     61a:	d0 e0       	ldi	r29, 0x00	; 0
     61c:	cd 01       	movw	r24, r26
     61e:	01 97       	sbiw	r24, 0x01	; 1
     620:	f1 f7       	brne	.-4      	; 0x61e <MAIN_Delay1MS+0x16>
     622:	21 50       	subi	r18, 0x01	; 1
     624:	d8 f7       	brcc	.-10     	; 0x61c <MAIN_Delay1MS+0x14>
     626:	df 91       	pop	r29
     628:	cf 91       	pop	r28
     62a:	08 95       	ret

0000062c <MAIN_ResetCSLine>:
     62c:	99 27       	eor	r25, r25
     62e:	81 30       	cpi	r24, 0x01	; 1
     630:	91 05       	cpc	r25, r1
     632:	b1 f0       	breq	.+44     	; 0x660 <MAIN_ResetCSLine+0x34>
     634:	82 30       	cpi	r24, 0x02	; 2
     636:	91 05       	cpc	r25, r1
     638:	1c f4       	brge	.+6      	; 0x640 <MAIN_ResetCSLine+0x14>
     63a:	89 2b       	or	r24, r25
     63c:	21 f0       	breq	.+8      	; 0x646 <MAIN_ResetCSLine+0x1a>
     63e:	08 95       	ret
     640:	02 97       	sbiw	r24, 0x02	; 2
     642:	59 f0       	breq	.+22     	; 0x65a <MAIN_ResetCSLine+0x2e>
     644:	08 95       	ret
     646:	86 9a       	sbi	0x10, 6	; 16
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     648:	a0 e0       	ldi	r26, 0x00	; 0
     64a:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     64c:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
     650:	80 2d       	mov	r24, r0
     652:	88 23       	and	r24, r24
     654:	19 f4       	brne	.+6      	; 0x65c <MAIN_ResetCSLine+0x30>
     656:	8e 9a       	sbi	0x11, 6	; 17
     658:	08 95       	ret
     65a:	86 9a       	sbi	0x10, 6	; 16
     65c:	8e 98       	cbi	0x11, 6	; 17
     65e:	08 95       	ret
     660:	86 98       	cbi	0x10, 6	; 16
     662:	fc cf       	rjmp	.-8      	; 0x65c <MAIN_ResetCSLine+0x30>

00000664 <MAIN_IntToStr>:
     664:	fb 01       	movw	r30, r22
     666:	20 e0       	ldi	r18, 0x00	; 0
     668:	84 36       	cpi	r24, 0x64	; 100
     66a:	91 05       	cpc	r25, r1
     66c:	20 f0       	brcs	.+8      	; 0x676 <MAIN_IntToStr+0x12>
     66e:	2f 5f       	subi	r18, 0xFF	; 255
     670:	84 56       	subi	r24, 0x64	; 100
     672:	90 40       	sbci	r25, 0x00	; 0
     674:	f9 cf       	rjmp	.-14     	; 0x668 <MAIN_IntToStr+0x4>
     676:	20 5d       	subi	r18, 0xD0	; 208
     678:	21 93       	st	Z+, r18
     67a:	20 e0       	ldi	r18, 0x00	; 0
     67c:	8a 30       	cpi	r24, 0x0A	; 10
     67e:	91 05       	cpc	r25, r1
     680:	18 f0       	brcs	.+6      	; 0x688 <MAIN_IntToStr+0x24>
     682:	2f 5f       	subi	r18, 0xFF	; 255
     684:	0a 97       	sbiw	r24, 0x0a	; 10
     686:	fa cf       	rjmp	.-12     	; 0x67c <MAIN_IntToStr+0x18>
     688:	20 5d       	subi	r18, 0xD0	; 208
     68a:	21 93       	st	Z+, r18
     68c:	80 5d       	subi	r24, 0xD0	; 208
     68e:	81 93       	st	Z+, r24
     690:	10 82       	st	Z, r1
     692:	08 95       	ret

00000694 <MAIN_ShowProgType>:
     694:	1f 93       	push	r17
     696:	cf 93       	push	r28
     698:	df 93       	push	r29
     69a:	cd b7       	in	r28, 0x3d	; 61
     69c:	de b7       	in	r29, 0x3e	; 62
     69e:	27 97       	sbiw	r28, 0x07	; 7
     6a0:	0f b6       	in	r0, 0x3f	; 63
     6a2:	f8 94       	cli
     6a4:	de bf       	out	0x3e, r29	; 62
     6a6:	0f be       	out	0x3f, r0	; 63
     6a8:	cd bf       	out	0x3d, r28	; 61
     6aa:	18 2f       	mov	r17, r24
     6ac:	68 e5       	ldi	r22, 0x58	; 88
     6ae:	72 e0       	ldi	r23, 0x02	; 2
     6b0:	ce 01       	movw	r24, r28
     6b2:	01 96       	adiw	r24, 0x01	; 1
     6b4:	0e 94 16 1a 	call	0x342c <strcpy_P>
     6b8:	1e 83       	std	Y+6, r17	; 0x06
     6ba:	ce 01       	movw	r24, r28
     6bc:	01 96       	adiw	r24, 0x01	; 1
     6be:	0e 94 14 08 	call	0x1028 <LCD_puts>
     6c2:	27 96       	adiw	r28, 0x07	; 7
     6c4:	0f b6       	in	r0, 0x3f	; 63
     6c6:	f8 94       	cli
     6c8:	de bf       	out	0x3e, r29	; 62
     6ca:	0f be       	out	0x3f, r0	; 63
     6cc:	cd bf       	out	0x3d, r28	; 61
     6ce:	df 91       	pop	r29
     6d0:	cf 91       	pop	r28
     6d2:	1f 91       	pop	r17
     6d4:	08 95       	ret

000006d6 <MAIN_ShowError>:
     6d6:	cf 93       	push	r28
     6d8:	df 93       	push	r29
     6da:	cd b7       	in	r28, 0x3d	; 61
     6dc:	de b7       	in	r29, 0x3e	; 62
     6de:	64 97       	sbiw	r28, 0x14	; 20
     6e0:	0f b6       	in	r0, 0x3f	; 63
     6e2:	f8 94       	cli
     6e4:	de bf       	out	0x3e, r29	; 62
     6e6:	0f be       	out	0x3f, r0	; 63
     6e8:	cd bf       	out	0x3d, r28	; 61
     6ea:	25 e4       	ldi	r18, 0x45	; 69
     6ec:	29 83       	std	Y+1, r18	; 0x01
     6ee:	2e e3       	ldi	r18, 0x3E	; 62
     6f0:	2a 83       	std	Y+2, r18	; 0x02
     6f2:	bc 01       	movw	r22, r24
     6f4:	ce 01       	movw	r24, r28
     6f6:	03 96       	adiw	r24, 0x03	; 3
     6f8:	0e 94 16 1a 	call	0x342c <strcpy_P>
     6fc:	ce 01       	movw	r24, r28
     6fe:	01 96       	adiw	r24, 0x01	; 1
     700:	0e 94 14 08 	call	0x1028 <LCD_puts>
     704:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>
     708:	f4 9b       	sbis	0x1e, 4	; 30
     70a:	fe cf       	rjmp	.-4      	; 0x708 <MAIN_ShowError+0x32>
     70c:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>
     710:	64 96       	adiw	r28, 0x14	; 20
     712:	0f b6       	in	r0, 0x3f	; 63
     714:	f8 94       	cli
     716:	de bf       	out	0x3e, r29	; 62
     718:	0f be       	out	0x3f, r0	; 63
     71a:	cd bf       	out	0x3d, r28	; 61
     71c:	df 91       	pop	r29
     71e:	cf 91       	pop	r28
     720:	08 95       	ret

00000722 <__vector_3>:
     722:	78 94       	sei
     724:	1f 92       	push	r1
     726:	0f 92       	push	r0
     728:	0f b6       	in	r0, 0x3f	; 63
     72a:	0f 92       	push	r0
     72c:	11 24       	eor	r1, r1
     72e:	8f 93       	push	r24
     730:	9f 93       	push	r25
     732:	93 b1       	in	r25, 0x03	; 3
     734:	90 95       	com	r25
     736:	90 7d       	andi	r25, 0xD0	; 208
     738:	8c b1       	in	r24, 0x0c	; 12
     73a:	80 95       	com	r24
     73c:	8c 70       	andi	r24, 0x0C	; 12
     73e:	98 2b       	or	r25, r24
     740:	9e bb       	out	0x1e, r25	; 30
     742:	10 92 3e 01 	sts	0x013E, r1
     746:	10 92 3d 01 	sts	0x013D, r1
     74a:	10 92 85 00 	sts	0x0085, r1
     74e:	10 92 84 00 	sts	0x0084, r1
     752:	9f 91       	pop	r25
     754:	8f 91       	pop	r24
     756:	0f 90       	pop	r0
     758:	0f be       	out	0x3f, r0	; 63
     75a:	0f 90       	pop	r0
     75c:	1f 90       	pop	r1
     75e:	18 95       	reti

00000760 <__vector_default>:
     760:	8f e5       	ldi	r24, 0x5F	; 95
     762:	92 e0       	ldi	r25, 0x02	; 2
     764:	0e 94 6b 03 	call	0x6d6 <MAIN_ShowError>
     768:	ff cf       	rjmp	.-2      	; 0x768 <__vector_default+0x8>

0000076a <FUNCChangeSettings>:
     76a:	cf 93       	push	r28
     76c:	c0 e0       	ldi	r28, 0x00	; 0
     76e:	81 e0       	ldi	r24, 0x01	; 1
     770:	8e bb       	out	0x1e, r24	; 30
     772:	8e b3       	in	r24, 0x1e	; 30
     774:	88 23       	and	r24, r24
     776:	e9 f3       	breq	.-6      	; 0x772 <FUNCChangeSettings+0x8>
     778:	f6 9b       	sbis	0x1e, 6	; 30
     77a:	06 c0       	rjmp	.+12     	; 0x788 <FUNCChangeSettings+0x1e>
     77c:	cc 23       	and	r28, r28
     77e:	11 f4       	brne	.+4      	; 0x784 <FUNCChangeSettings+0x1a>
     780:	c5 e0       	ldi	r28, 0x05	; 5
     782:	19 c0       	rjmp	.+50     	; 0x7b6 <FUNCChangeSettings+0x4c>
     784:	c1 50       	subi	r28, 0x01	; 1
     786:	17 c0       	rjmp	.+46     	; 0x7b6 <FUNCChangeSettings+0x4c>
     788:	f7 9b       	sbis	0x1e, 7	; 30
     78a:	06 c0       	rjmp	.+12     	; 0x798 <FUNCChangeSettings+0x2e>
     78c:	c5 30       	cpi	r28, 0x05	; 5
     78e:	11 f4       	brne	.+4      	; 0x794 <FUNCChangeSettings+0x2a>
     790:	c0 e0       	ldi	r28, 0x00	; 0
     792:	11 c0       	rjmp	.+34     	; 0x7b6 <FUNCChangeSettings+0x4c>
     794:	cf 5f       	subi	r28, 0xFF	; 255
     796:	0f c0       	rjmp	.+30     	; 0x7b6 <FUNCChangeSettings+0x4c>
     798:	f4 9b       	sbis	0x1e, 4	; 30
     79a:	0b c0       	rjmp	.+22     	; 0x7b2 <FUNCChangeSettings+0x48>
     79c:	ec 2f       	mov	r30, r28
     79e:	ff 27       	eor	r31, r31
     7a0:	ee 0f       	add	r30, r30
     7a2:	ff 1f       	adc	r31, r31
     7a4:	e1 5f       	subi	r30, 0xF1	; 241
     7a6:	fe 4f       	sbci	r31, 0xFE	; 254
     7a8:	85 91       	lpm	r24, Z+
     7aa:	94 91       	lpm	r25, Z
     7ac:	fc 01       	movw	r30, r24
     7ae:	09 95       	icall
     7b0:	02 c0       	rjmp	.+4      	; 0x7b6 <FUNCChangeSettings+0x4c>
     7b2:	f2 99       	sbic	0x1e, 2	; 30
     7b4:	0d c0       	rjmp	.+26     	; 0x7d0 <FUNCChangeSettings+0x66>
     7b6:	ec 2f       	mov	r30, r28
     7b8:	ff 27       	eor	r31, r31
     7ba:	ee 0f       	add	r30, r30
     7bc:	ff 1f       	adc	r31, r31
     7be:	e5 5e       	subi	r30, 0xE5	; 229
     7c0:	fe 4f       	sbci	r31, 0xFE	; 254
     7c2:	85 91       	lpm	r24, Z+
     7c4:	94 91       	lpm	r25, Z
     7c6:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>
     7ca:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>
     7ce:	d1 cf       	rjmp	.-94     	; 0x772 <FUNCChangeSettings+0x8>
     7d0:	cf 91       	pop	r28
     7d2:	08 95       	ret

000007d4 <FUNCAVRISPMode>:
		}
	}
}

void FUNCAVRISPMode(void)
{
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
     7d4:	8a e2       	ldi	r24, 0x2A	; 42
     7d6:	92 e0       	ldi	r25, 0x02	; 2
     7d8:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>
     7dc:	0e 94 81 07 	call	0xf02 <OSCCAL_Calibrate>
     7e0:	80 91 c1 00 	lds	r24, 0x00C1
     7e4:	80 78       	andi	r24, 0x80	; 128
     7e6:	88 61       	ori	r24, 0x18	; 24
     7e8:	80 93 c1 00 	sts	0x00C1, r24

	LCD_puts_f(AVRISPModeMessage);
     7ec:	82 ef       	ldi	r24, 0xF2	; 242
     7ee:	93 e0       	ldi	r25, 0x03	; 3
     7f0:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>
	
	InterpretPacketRoutine = (FuncPtr)AICI_InterpretPacket;
     7f4:	8e e6       	ldi	r24, 0x6E	; 110
     7f6:	92 e1       	ldi	r25, 0x12	; 18
     7f8:	90 93 03 01 	sts	0x0103, r25
     7fc:	80 93 02 01 	sts	0x0102, r24
	V2P_RunStateMachine();
     800:	0e 94 73 0f 	call	0x1ee6 <V2P_RunStateMachine>
     804:	08 95       	ret

00000806 <FUNCProgramDataflash>:
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     806:	a1 e0       	ldi	r26, 0x01	; 1
     808:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     80a:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
     80e:	80 2d       	mov	r24, r0
     810:	0e 94 7e 09 	call	0x12fc <USI_SPIInitMaster>
}

void FUNCProgramDataflash(void)
{
	USI_SPIInitMaster(eeprom_read_byte(&EEPROMVars.SCKDuration));
	UseExernalDF = TRUE;
     814:	81 e0       	ldi	r24, 0x01	; 1
     816:	80 93 65 02 	sts	0x0265, r24
	DFSPIRoutinePointer = USI_SPITransmit;
     81a:	88 e9       	ldi	r24, 0x98	; 152
     81c:	99 e0       	ldi	r25, 0x09	; 9
     81e:	90 93 01 01 	sts	0x0101, r25
     822:	80 93 00 01 	sts	0x0100, r24
	
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
     826:	8a e2       	ldi	r24, 0x2A	; 42
     828:	92 e0       	ldi	r25, 0x02	; 2
     82a:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>
     82e:	0e 94 81 07 	call	0xf02 <OSCCAL_Calibrate>
     832:	80 91 c1 00 	lds	r24, 0x00C1
     836:	80 78       	andi	r24, 0x80	; 128
     838:	88 61       	ori	r24, 0x18	; 24
     83a:	80 93 c1 00 	sts	0x00C1, r24

	LCD_puts_f(DataFlashProgMode);
     83e:	8b ec       	ldi	r24, 0xCB	; 203
     840:	93 e0       	ldi	r25, 0x03	; 3
     842:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>

	InterpretPacketRoutine = (FuncPtr)PD_InterpretAVRISPPacket;
     846:	84 ea       	ldi	r24, 0xA4	; 164
     848:	9c e0       	ldi	r25, 0x0C	; 12
     84a:	90 93 03 01 	sts	0x0103, r25
     84e:	80 93 02 01 	sts	0x0102, r24
	V2P_RunStateMachine();
     852:	0e 94 73 0f 	call	0x1ee6 <V2P_RunStateMachine>
	   
	DF_EnableDataflash(FALSE);
     856:	80 e0       	ldi	r24, 0x00	; 0
     858:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
	SPI_SPIOFF();
     85c:	80 91 64 00 	lds	r24, 0x0064
     860:	84 60       	ori	r24, 0x04	; 4
     862:	80 93 64 00 	sts	0x0064, r24
     866:	08 95       	ret

00000868 <FUNCProgramAVR>:
}

void FUNCProgramAVR(void)
{
     868:	0f 93       	push	r16
     86a:	1f 93       	push	r17
     86c:	cf 93       	push	r28
     86e:	df 93       	push	r29
     870:	cd b7       	in	r28, 0x3d	; 61
     872:	de b7       	in	r29, 0x3e	; 62
     874:	63 97       	sbiw	r28, 0x13	; 19
     876:	0f b6       	in	r0, 0x3f	; 63
     878:	f8 94       	cli
     87a:	de bf       	out	0x3e, r29	; 62
     87c:	0f be       	out	0x3f, r0	; 63
     87e:	cd bf       	out	0x3d, r28	; 61
	uint8_t  DoneFailMessageBuff[19];
	uint8_t  Fault = ISPCC_NO_FAULT;
     880:	00 e0       	ldi	r16, 0x00	; 0
	uint8_t  ProgMode = 0;
     882:	10 2f       	mov	r17, r16

	SPI_SPIInit();
     884:	0e 94 29 09 	call	0x1252 <SPI_SPIInit>
	UseExernalDF = FALSE;
     888:	00 93 65 02 	sts	0x0265, r16
	DFSPIRoutinePointer = SPI_SPITransmit;
     88c:	83 e3       	ldi	r24, 0x33	; 51
     88e:	99 e0       	ldi	r25, 0x09	; 9
     890:	90 93 01 01 	sts	0x0101, r25
     894:	80 93 00 01 	sts	0x0100, r24
	
	if (!(DF_CheckCorrectOnboardChip()))
     898:	0e 94 37 0b 	call	0x166e <DF_CheckCorrectOnboardChip>
     89c:	88 23       	and	r24, r24
     89e:	09 f4       	brne	.+2      	; 0x8a2 <FUNCProgramAVR+0x3a>
     8a0:	0d c1       	rjmp	.+538    	; 0xabc <FUNCProgramAVR+0x254>
	  return;

	MAIN_WaitForJoyRelease();
     8a2:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>
	
	JoyStatus = 1;                              // Use an invalid joystick value to force the program to write the
     8a6:	81 e0       	ldi	r24, 0x01	; 1
     8a8:	8e bb       	out	0x1e, r24	; 30
	                                            // name of the default command onto the LCD
	while (1)
	{
		if (JoyStatus)
     8aa:	8e b3       	in	r24, 0x1e	; 30
     8ac:	88 23       	and	r24, r24
     8ae:	e9 f3       	breq	.-6      	; 0x8aa <FUNCProgramAVR+0x42>
		{
			if (JoyStatus & JOY_LEFT)
     8b0:	f2 99       	sbic	0x1e, 2	; 30
     8b2:	04 c1       	rjmp	.+520    	; 0xabc <FUNCProgramAVR+0x254>
			  return;
			else if (JoyStatus & JOY_PRESS)
     8b4:	f4 99       	sbic	0x1e, 4	; 30
     8b6:	1c c0       	rjmp	.+56     	; 0x8f0 <FUNCProgramAVR+0x88>
			  break;
			else if (JoyStatus & JOY_UP)
     8b8:	f6 9b       	sbis	0x1e, 6	; 30
     8ba:	06 c0       	rjmp	.+12     	; 0x8c8 <FUNCProgramAVR+0x60>
			  (ProgMode == 0)? ProgMode = 6 : ProgMode--;
     8bc:	11 23       	and	r17, r17
     8be:	11 f4       	brne	.+4      	; 0x8c4 <FUNCProgramAVR+0x5c>
     8c0:	16 e0       	ldi	r17, 0x06	; 6
     8c2:	09 c0       	rjmp	.+18     	; 0x8d6 <FUNCProgramAVR+0x6e>
     8c4:	11 50       	subi	r17, 0x01	; 1
     8c6:	07 c0       	rjmp	.+14     	; 0x8d6 <FUNCProgramAVR+0x6e>
			else if (JoyStatus & JOY_DOWN)
     8c8:	f7 9b       	sbis	0x1e, 7	; 30
     8ca:	05 c0       	rjmp	.+10     	; 0x8d6 <FUNCProgramAVR+0x6e>
			  (ProgMode == 6)? ProgMode = 0 : ProgMode++;
     8cc:	16 30       	cpi	r17, 0x06	; 6
     8ce:	11 f4       	brne	.+4      	; 0x8d4 <FUNCProgramAVR+0x6c>
     8d0:	10 e0       	ldi	r17, 0x00	; 0
     8d2:	01 c0       	rjmp	.+2      	; 0x8d6 <FUNCProgramAVR+0x6e>
     8d4:	1f 5f       	subi	r17, 0xFF	; 255

			LCD_puts_f((uint8_t*)pgm_read_word(&ProgOptions[ProgMode])); // Show current function onto the LCD
     8d6:	e1 2f       	mov	r30, r17
     8d8:	ff 27       	eor	r31, r31
     8da:	ee 0f       	add	r30, r30
     8dc:	ff 1f       	adc	r31, r31
     8de:	e4 56       	subi	r30, 0x64	; 100
     8e0:	ff 4f       	sbci	r31, 0xFF	; 255
     8e2:	85 91       	lpm	r24, Z+
     8e4:	94 91       	lpm	r25, Z
     8e6:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     8ea:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>
     8ee:	dd cf       	rjmp	.-70     	; 0x8aa <FUNCProgramAVR+0x42>
		}
	}

	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);                // Orange = busy
     8f0:	81 b3       	in	r24, 0x11	; 17
     8f2:	80 63       	ori	r24, 0x30	; 48
     8f4:	81 bb       	out	0x11, r24	; 17
	LCD_puts_f(WaitText);
     8f6:	8a e2       	ldi	r24, 0x2A	; 42
     8f8:	92 e0       	ldi	r25, 0x02	; 2
     8fa:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     8fe:	a1 e0       	ldi	r26, 0x01	; 1
     900:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     902:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
     906:	80 2d       	mov	r24, r0
     908:	0e 94 7e 09 	call	0x12fc <USI_SPIInitMaster>

	USI_SPIInitMaster(eeprom_read_byte(&EEPROMVars.SCKDuration));
	MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE); // Capture the RESET line of the slave AVR
     90c:	80 e0       	ldi	r24, 0x00	; 0
     90e:	0e 94 16 03 	call	0x62c <MAIN_ResetCSLine>
     912:	eb e4       	ldi	r30, 0x4B	; 75
     914:	f1 e0       	ldi	r31, 0x01	; 1
     916:	20 e0       	ldi	r18, 0x00	; 0
     918:	30 e0       	ldi	r19, 0x00	; 0
     91a:	9b e0       	ldi	r25, 0x0B	; 11
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     91c:	d9 01       	movw	r26, r18
     91e:	ad 5d       	subi	r26, 0xDD	; 221
     920:	bf 4f       	sbci	r27, 0xFF	; 255
  uint8_t result;
  asm volatile
     922:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
     926:	80 2d       	mov	r24, r0
     928:	81 93       	st	Z+, r24
			
	for (uint8_t PacketB = 0; PacketB <= 11; PacketB++) // Read the enter programming mode command bytes
     92a:	91 50       	subi	r25, 0x01	; 1
     92c:	2f 5f       	subi	r18, 0xFF	; 255
     92e:	3f 4f       	sbci	r19, 0xFF	; 255
     930:	97 ff       	sbrs	r25, 7
     932:	f4 cf       	rjmp	.-24     	; 0x91c <FUNCProgramAVR+0xb4>
	  PacketBytes[PacketB] = eeprom_read_byte(&EEPROMVars.EnterProgMode[PacketB]);
	
	ISPCC_EnterChipProgrammingMode();    // Try to sync with the slave AVR
     934:	0e 94 de 10 	call	0x21bc <ISPCC_EnterChipProgrammingMode>

	CurrAddress = 0;
     938:	10 92 42 01 	sts	0x0142, r1
     93c:	10 92 43 01 	sts	0x0143, r1
     940:	10 92 44 01 	sts	0x0144, r1
     944:	10 92 45 01 	sts	0x0145, r1

	if (PacketBytes[1] == STATUS_CMD_OK) // ISPCC_EnterChipProgrammingMode alters the PacketBytes buffer rather than returning a value
     948:	80 91 4c 01 	lds	r24, 0x014C
     94c:	88 23       	and	r24, r24
     94e:	09 f0       	breq	.+2      	; 0x952 <FUNCProgramAVR+0xea>
     950:	a0 c0       	rjmp	.+320    	; 0xa92 <FUNCProgramAVR+0x22a>
	{						
		if ((ProgMode == 6) || (ProgMode == 0) || (ProgMode == 2)) // Erase chip, or program flash mode
     952:	16 30       	cpi	r17, 0x06	; 6
     954:	21 f0       	breq	.+8      	; 0x95e <FUNCProgramAVR+0xf6>
     956:	11 23       	and	r17, r17
     958:	11 f0       	breq	.+4      	; 0x95e <FUNCProgramAVR+0xf6>
     95a:	12 30       	cpi	r17, 0x02	; 2
     95c:	91 f4       	brne	.+36     	; 0x982 <FUNCProgramAVR+0x11a>
		{
			MAIN_ShowProgType('C');
     95e:	83 e4       	ldi	r24, 0x43	; 67
     960:	0e 94 4a 03 	call	0x694 <MAIN_ShowProgType>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     964:	a4 e1       	ldi	r26, 0x14	; 20
     966:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     968:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
     96c:	80 2d       	mov	r24, r0
     96e:	81 30       	cpi	r24, 0x01	; 1
     970:	31 f0       	breq	.+12     	; 0x97e <FUNCProgramAVR+0x116>
			
			if (!(eeprom_read_byte(&EEPROMVars.EraseCmdStored) == TRUE))
			{
				Fault = ISPCC_FAULT_NOERASE;
     972:	02 e0       	ldi	r16, 0x02	; 2
				MAIN_ShowError(PSTR("NO ERASE CMD"));
     974:	86 e6       	ldi	r24, 0x66	; 102
     976:	92 e0       	ldi	r25, 0x02	; 2
     978:	0e 94 6b 03 	call	0x6d6 <MAIN_ShowError>
     97c:	02 c0       	rjmp	.+4      	; 0x982 <FUNCProgramAVR+0x11a>
			}
			else
			{
				PM_SendEraseCommand();
     97e:	0e 94 72 17 	call	0x2ee4 <PM_SendEraseCommand>
			}
		}

		if (((ProgMode == 0) || (ProgMode == 2)) && (Fault == ISPCC_NO_FAULT)) // Program flash
     982:	11 23       	and	r17, r17
     984:	11 f0       	breq	.+4      	; 0x98a <FUNCProgramAVR+0x122>
     986:	12 30       	cpi	r17, 0x02	; 2
     988:	b9 f4       	brne	.+46     	; 0x9b8 <FUNCProgramAVR+0x150>
     98a:	00 23       	and	r16, r16
     98c:	a9 f4       	brne	.+42     	; 0x9b8 <FUNCProgramAVR+0x150>
		{
			MAIN_ShowProgType('D');
     98e:	84 e4       	ldi	r24, 0x44	; 68
     990:	0e 94 4a 03 	call	0x694 <MAIN_ShowProgType>

			if (!(PM_GetStoredDataSize(TYPE_FLASH))) // Check to make sure a program is present in memory
     994:	81 e0       	ldi	r24, 0x01	; 1
     996:	0e 94 de 13 	call	0x27bc <PM_GetStoredDataSize>
     99a:	dc 01       	movw	r26, r24
     99c:	cb 01       	movw	r24, r22
     99e:	00 97       	sbiw	r24, 0x00	; 0
     9a0:	a1 05       	cpc	r26, r1
     9a2:	b1 05       	cpc	r27, r1
     9a4:	31 f4       	brne	.+12     	; 0x9b2 <FUNCProgramAVR+0x14a>
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
     9a6:	03 e0       	ldi	r16, 0x03	; 3
				MAIN_ShowError(PSTR("NO DATA"));
     9a8:	83 e7       	ldi	r24, 0x73	; 115
     9aa:	92 e0       	ldi	r25, 0x02	; 2
     9ac:	0e 94 6b 03 	call	0x6d6 <MAIN_ShowError>
     9b0:	03 c0       	rjmp	.+6      	; 0x9b8 <FUNCProgramAVR+0x150>
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_FLASH);
     9b2:	81 e0       	ldi	r24, 0x01	; 1
     9b4:	0e 94 a1 17 	call	0x2f42 <PM_CreateProgrammingPackets>
			}
		}
	
		if ((ProgMode == 1) || (ProgMode == 2)) // Program EEPROM
     9b8:	81 2f       	mov	r24, r17
     9ba:	81 50       	subi	r24, 0x01	; 1
     9bc:	82 30       	cpi	r24, 0x02	; 2
     9be:	a8 f4       	brcc	.+42     	; 0x9ea <FUNCProgramAVR+0x182>
		{
			MAIN_ShowProgType('E');
     9c0:	85 e4       	ldi	r24, 0x45	; 69
     9c2:	0e 94 4a 03 	call	0x694 <MAIN_ShowProgType>
				
			if (!(PM_GetStoredDataSize(TYPE_EEPROM))) // Check to make sure EEPROM data is present in memory
     9c6:	80 e0       	ldi	r24, 0x00	; 0
     9c8:	0e 94 de 13 	call	0x27bc <PM_GetStoredDataSize>
     9cc:	dc 01       	movw	r26, r24
     9ce:	cb 01       	movw	r24, r22
     9d0:	00 97       	sbiw	r24, 0x00	; 0
     9d2:	a1 05       	cpc	r26, r1
     9d4:	b1 05       	cpc	r27, r1
     9d6:	31 f4       	brne	.+12     	; 0x9e4 <FUNCProgramAVR+0x17c>
			{
				Fault = ISPCC_FAULT_NODATATYPE;
     9d8:	03 e0       	ldi	r16, 0x03	; 3
				MAIN_ShowError(PSTR("NO EEPROM"));
     9da:	8b e7       	ldi	r24, 0x7B	; 123
     9dc:	92 e0       	ldi	r25, 0x02	; 2
     9de:	0e 94 6b 03 	call	0x6d6 <MAIN_ShowError>
     9e2:	03 c0       	rjmp	.+6      	; 0x9ea <FUNCProgramAVR+0x182>
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_EEPROM);
     9e4:	80 e0       	ldi	r24, 0x00	; 0
     9e6:	0e 94 a1 17 	call	0x2f42 <PM_CreateProgrammingPackets>
			}
		}

		if ((ProgMode == 3) || (ProgMode == 5)) // Program Fuse bytes
     9ea:	13 30       	cpi	r17, 0x03	; 3
     9ec:	11 f0       	breq	.+4      	; 0x9f2 <FUNCProgramAVR+0x18a>
     9ee:	15 30       	cpi	r17, 0x05	; 5
     9f0:	99 f4       	brne	.+38     	; 0xa18 <FUNCProgramAVR+0x1b0>
		{
			MAIN_ShowProgType('F');
     9f2:	86 e4       	ldi	r24, 0x46	; 70
     9f4:	0e 94 4a 03 	call	0x694 <MAIN_ShowProgType>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     9f8:	af e2       	ldi	r26, 0x2F	; 47
     9fa:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     9fc:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
     a00:	80 2d       	mov	r24, r0
     a02:	88 23       	and	r24, r24
     a04:	31 f4       	brne	.+12     	; 0xa12 <FUNCProgramAVR+0x1aa>
			
			if (!(eeprom_read_byte(&EEPROMVars.TotalFuseBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
     a06:	03 e0       	ldi	r16, 0x03	; 3
				MAIN_ShowError(PSTR("NO FUSE BYTES"));
     a08:	85 e8       	ldi	r24, 0x85	; 133
     a0a:	92 e0       	ldi	r25, 0x02	; 2
     a0c:	0e 94 6b 03 	call	0x6d6 <MAIN_ShowError>
     a10:	03 c0       	rjmp	.+6      	; 0xa18 <FUNCProgramAVR+0x1b0>
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_FUSE);
     a12:	82 e0       	ldi	r24, 0x02	; 2
     a14:	0e 94 41 17 	call	0x2e82 <PM_SendFuseLockBytes>
			}
		}

		if ((ProgMode == 4) || (ProgMode == 5)) // Program Lock bytes
     a18:	81 2f       	mov	r24, r17
     a1a:	84 50       	subi	r24, 0x04	; 4
     a1c:	82 30       	cpi	r24, 0x02	; 2
     a1e:	00 f5       	brcc	.+64     	; 0xa60 <FUNCProgramAVR+0x1f8>
		{
			if (ProgMode == 5)                    // If fusebytes have already been written, we need to reenter programming mode to latch them
     a20:	15 30       	cpi	r17, 0x05	; 5
     a22:	59 f4       	brne	.+22     	; 0xa3a <FUNCProgramAVR+0x1d2>
			{
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line of the slave AVR
     a24:	81 e0       	ldi	r24, 0x01	; 1
     a26:	0e 94 16 03 	call	0x62c <MAIN_ResetCSLine>
				MAIN_Delay10MS(1);
     a2a:	81 e0       	ldi	r24, 0x01	; 1
     a2c:	0e 94 2e 02 	call	0x45c <MAIN_Delay10MS>
				MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE); // Capture the RESET line of the slave AVR
     a30:	80 e0       	ldi	r24, 0x00	; 0
     a32:	0e 94 16 03 	call	0x62c <MAIN_ResetCSLine>
				ISPCC_EnterChipProgrammingMode(); // Try to sync with the slave AVR
     a36:	0e 94 de 10 	call	0x21bc <ISPCC_EnterChipProgrammingMode>
			}

			MAIN_ShowProgType('L');
     a3a:	8c e4       	ldi	r24, 0x4C	; 76
     a3c:	0e 94 4a 03 	call	0x694 <MAIN_ShowProgType>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     a40:	a0 e3       	ldi	r26, 0x30	; 48
     a42:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     a44:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
     a48:	80 2d       	mov	r24, r0
     a4a:	88 23       	and	r24, r24
     a4c:	31 f4       	brne	.+12     	; 0xa5a <FUNCProgramAVR+0x1f2>
		
			if (!(eeprom_read_byte(&EEPROMVars.TotalLockBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;
     a4e:	03 e0       	ldi	r16, 0x03	; 3
				MAIN_ShowError(PSTR("NO LOCK BYTES"));
     a50:	83 e9       	ldi	r24, 0x93	; 147
     a52:	92 e0       	ldi	r25, 0x02	; 2
     a54:	0e 94 6b 03 	call	0x6d6 <MAIN_ShowError>
     a58:	03 c0       	rjmp	.+6      	; 0xa60 <FUNCProgramAVR+0x1f8>
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_LOCK);
     a5a:	83 e0       	ldi	r24, 0x03	; 3
     a5c:	0e 94 41 17 	call	0x2e82 <PM_SendFuseLockBytes>
			}
		}

		strcpy_P(DoneFailMessageBuff, PSTR("PROGRAMMING DONE"));
     a60:	61 ea       	ldi	r22, 0xA1	; 161
     a62:	72 e0       	ldi	r23, 0x02	; 2
     a64:	ce 01       	movw	r24, r28
     a66:	01 96       	adiw	r24, 0x01	; 1
     a68:	0e 94 16 1a 	call	0x342c <strcpy_P>

		if (Fault != ISPCC_NO_FAULT)         // Takes less code to just overwrite part of the string on fail
     a6c:	00 23       	and	r16, r16
     a6e:	31 f0       	breq	.+12     	; 0xa7c <FUNCProgramAVR+0x214>
		  strcpy_P(&DoneFailMessageBuff[12], PSTR("FAILED"));
     a70:	62 eb       	ldi	r22, 0xB2	; 178
     a72:	72 e0       	ldi	r23, 0x02	; 2
     a74:	ce 01       	movw	r24, r28
     a76:	0d 96       	adiw	r24, 0x0d	; 13
     a78:	0e 94 16 1a 	call	0x342c <strcpy_P>

		LCD_puts(DoneFailMessageBuff);
     a7c:	ce 01       	movw	r24, r28
     a7e:	01 96       	adiw	r24, 0x01	; 1
     a80:	0e 94 14 08 	call	0x1028 <LCD_puts>

		MAIN_Delay10MS(255);
     a84:	8f ef       	ldi	r24, 0xFF	; 255
     a86:	0e 94 2e 02 	call	0x45c <MAIN_Delay10MS>
		MAIN_Delay10MS(100);
     a8a:	84 e6       	ldi	r24, 0x64	; 100
     a8c:	0e 94 2e 02 	call	0x45c <MAIN_Delay10MS>
     a90:	04 c0       	rjmp	.+8      	; 0xa9a <FUNCProgramAVR+0x232>
	}
	else
	{
		MAIN_ShowError(SyncErrorMessage);
     a92:	87 ee       	ldi	r24, 0xE7	; 231
     a94:	93 e0       	ldi	r25, 0x03	; 3
     a96:	0e 94 6b 03 	call	0x6d6 <MAIN_ShowError>
	}
	
	MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run	
     a9a:	81 e0       	ldi	r24, 0x01	; 1
     a9c:	0e 94 16 03 	call	0x62c <MAIN_ResetCSLine>
	USI_SPIOff();
     aa0:	0e 94 8e 09 	call	0x131c <USI_SPIOff>
	DF_EnableDataflash(FALSE);
     aa4:	80 e0       	ldi	r24, 0x00	; 0
     aa6:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
	SPI_SPIOFF();
     aaa:	80 91 64 00 	lds	r24, 0x0064
     aae:	84 60       	ori	r24, 0x04	; 4
     ab0:	80 93 64 00 	sts	0x0064, r24
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Green = ready
     ab4:	81 b3       	in	r24, 0x11	; 17
     ab6:	8f 7c       	andi	r24, 0xCF	; 207
     ab8:	80 61       	ori	r24, 0x10	; 16
     aba:	81 bb       	out	0x11, r24	; 17
     abc:	63 96       	adiw	r28, 0x13	; 19
     abe:	0f b6       	in	r0, 0x3f	; 63
     ac0:	f8 94       	cli
     ac2:	de bf       	out	0x3e, r29	; 62
     ac4:	0f be       	out	0x3f, r0	; 63
     ac6:	cd bf       	out	0x3d, r28	; 61
     ac8:	df 91       	pop	r29
     aca:	cf 91       	pop	r28
     acc:	1f 91       	pop	r17
     ace:	0f 91       	pop	r16
     ad0:	08 95       	ret

00000ad2 <FUNCStoreProgram>:
}

void FUNCStoreProgram(void)
{
	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
     ad2:	83 e3       	ldi	r24, 0x33	; 51
     ad4:	99 e0       	ldi	r25, 0x09	; 9
     ad6:	90 93 01 01 	sts	0x0101, r25
     ada:	80 93 00 01 	sts	0x0100, r24
	SPI_SPIInit();
     ade:	0e 94 29 09 	call	0x1252 <SPI_SPIInit>
	UseExernalDF = FALSE;
     ae2:	10 92 65 02 	sts	0x0265, r1
	DF_EnableDataflash(TRUE);
     ae6:	81 e0       	ldi	r24, 0x01	; 1
     ae8:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>

	if (!(DF_CheckCorrectOnboardChip()))
     aec:	0e 94 37 0b 	call	0x166e <DF_CheckCorrectOnboardChip>
     af0:	88 23       	and	r24, r24
     af2:	01 f1       	breq	.+64     	; 0xb34 <FUNCStoreProgram+0x62>
	  return;
			
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
     af4:	8a e2       	ldi	r24, 0x2A	; 42
     af6:	92 e0       	ldi	r25, 0x02	; 2
     af8:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>
     afc:	0e 94 81 07 	call	0xf02 <OSCCAL_Calibrate>
     b00:	80 91 c1 00 	lds	r24, 0x00C1
     b04:	80 78       	andi	r24, 0x80	; 128
     b06:	88 61       	ori	r24, 0x18	; 24
     b08:	80 93 c1 00 	sts	0x00C1, r24

	LCD_puts_f(PSTR("*STORAGE MODE*"));
     b0c:	89 eb       	ldi	r24, 0xB9	; 185
     b0e:	92 e0       	ldi	r25, 0x02	; 2
     b10:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>

	InterpretPacketRoutine = (FuncPtr)PM_InterpretAVRISPPacket;
     b14:	83 ef       	ldi	r24, 0xF3	; 243
     b16:	94 e1       	ldi	r25, 0x14	; 20
     b18:	90 93 03 01 	sts	0x0103, r25
     b1c:	80 93 02 01 	sts	0x0102, r24
	V2P_RunStateMachine();
     b20:	0e 94 73 0f 	call	0x1ee6 <V2P_RunStateMachine>
	DF_EnableDataflash(FALSE);
     b24:	80 e0       	ldi	r24, 0x00	; 0
     b26:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
	SPI_SPIOFF();
     b2a:	80 91 64 00 	lds	r24, 0x0064
     b2e:	84 60       	ori	r24, 0x04	; 4
     b30:	80 93 64 00 	sts	0x0064, r24
     b34:	08 95       	ret

00000b36 <FUNCClearMem>:
}

void FUNCClearMem(void)
{
     b36:	cf 93       	push	r28
     b38:	df 93       	push	r29
	LCD_puts_f(PSTR("CONFIRM"));
     b3a:	88 ec       	ldi	r24, 0xC8	; 200
     b3c:	92 e0       	ldi	r25, 0x02	; 2
     b3e:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>
	MAIN_Delay10MS(180);
     b42:	84 eb       	ldi	r24, 0xB4	; 180
     b44:	0e 94 2e 02 	call	0x45c <MAIN_Delay10MS>

	LCD_puts_f(PSTR("<N Y>"));
     b48:	80 ed       	ldi	r24, 0xD0	; 208
     b4a:	92 e0       	ldi	r25, 0x02	; 2
     b4c:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>

	while (1)
	{
		if (JoyStatus)
     b50:	8e b3       	in	r24, 0x1e	; 30
     b52:	88 23       	and	r24, r24
     b54:	e9 f3       	breq	.-6      	; 0xb50 <FUNCClearMem+0x1a>
		{
			if (JoyStatus & JOY_LEFT)
     b56:	8e b3       	in	r24, 0x1e	; 30
     b58:	99 27       	eor	r25, r25
     b5a:	ec 01       	movw	r28, r24
     b5c:	c4 70       	andi	r28, 0x04	; 4
     b5e:	d0 70       	andi	r29, 0x00	; 0
     b60:	82 fd       	sbrc	r24, 2
     b62:	1a c0       	rjmp	.+52     	; 0xb98 <FUNCClearMem+0x62>
			  return;
			else if (JoyStatus & JOY_RIGHT)
     b64:	f3 9b       	sbis	0x1e, 3	; 30
     b66:	f4 cf       	rjmp	.-24     	; 0xb50 <FUNCClearMem+0x1a>
			  break;
		}
	}

	MAIN_WaitForJoyRelease();
     b68:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>

	LCD_puts_f(WaitText);
     b6c:	8a e2       	ldi	r24, 0x2A	; 42
     b6e:	92 e0       	ldi	r25, 0x02	; 2
     b70:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>

	for (uint16_t EAddr = 0; EAddr < 512; EAddr++)
     b74:	ce 01       	movw	r24, r28
     b76:	2f ef       	ldi	r18, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     b78:	dc 01       	movw	r26, r24
     b7a:	02 2e       	mov	r0, r18
     b7c:	0e 94 64 1a 	call	0x34c8 <__eeprom_write_byte_1F2021>
     b80:	01 96       	adiw	r24, 0x01	; 1
     b82:	32 e0       	ldi	r19, 0x02	; 2
     b84:	80 30       	cpi	r24, 0x00	; 0
     b86:	93 07       	cpc	r25, r19
     b88:	b8 f3       	brcs	.-18     	; 0xb78 <FUNCClearMem+0x42>
	  eeprom_write_byte((uint8_t*)EAddr, 0xFF);

	LCD_puts_f(PSTR("MEM CLEARED"));
     b8a:	86 ed       	ldi	r24, 0xD6	; 214
     b8c:	92 e0       	ldi	r25, 0x02	; 2
     b8e:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>
	MAIN_Delay10MS(255);
     b92:	8f ef       	ldi	r24, 0xFF	; 255
     b94:	0e 94 2e 02 	call	0x45c <MAIN_Delay10MS>
     b98:	df 91       	pop	r29
     b9a:	cf 91       	pop	r28
     b9c:	08 95       	ret

00000b9e <FUNCSetContrast>:
}

void FUNCSetContrast(void)
{
     b9e:	ef 92       	push	r14
     ba0:	ff 92       	push	r15
     ba2:	1f 93       	push	r17
     ba4:	cf 93       	push	r28
     ba6:	df 93       	push	r29
     ba8:	cd b7       	in	r28, 0x3d	; 61
     baa:	de b7       	in	r29, 0x3e	; 62
     bac:	26 97       	sbiw	r28, 0x06	; 6
     bae:	0f b6       	in	r0, 0x3f	; 63
     bb0:	f8 94       	cli
     bb2:	de bf       	out	0x3e, r29	; 62
     bb4:	0f be       	out	0x3f, r0	; 63
     bb6:	cd bf       	out	0x3d, r28	; 61
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     bb8:	85 e8       	ldi	r24, 0x85	; 133
     bba:	e8 2e       	mov	r14, r24
     bbc:	80 e0       	ldi	r24, 0x00	; 0
     bbe:	f8 2e       	mov	r15, r24
  uint8_t result;
  asm volatile
     bc0:	d7 01       	movw	r26, r14
     bc2:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
     bc6:	80 2d       	mov	r24, r0
     bc8:	18 2f       	mov	r17, r24
     bca:	1f 70       	andi	r17, 0x0F	; 15
	uint8_t Buffer[6];
	uint8_t Contrast = (eeprom_read_byte(&EEPROMVars.LCDContrast) & 0x0F); // Ranges from 0-15 so mask retuns 15 on blank EEPROM (0xFF)
	
	JoyStatus = 1;                          // Invalid value to force the LCD to update
     bcc:	81 e0       	ldi	r24, 0x01	; 1
     bce:	8e bb       	out	0x1e, r24	; 30
	
	while (1)
	{
		if (JoyStatus)
     bd0:	8e b3       	in	r24, 0x1e	; 30
     bd2:	88 23       	and	r24, r24
     bd4:	e9 f3       	breq	.-6      	; 0xbd0 <FUNCSetContrast+0x32>
		{
			if (JoyStatus & JOY_UP)
     bd6:	f6 9b       	sbis	0x1e, 6	; 30
     bd8:	04 c0       	rjmp	.+8      	; 0xbe2 <FUNCSetContrast+0x44>
			{
				if (Contrast < 15)
     bda:	1f 30       	cpi	r17, 0x0F	; 15
     bdc:	78 f4       	brcc	.+30     	; 0xbfc <FUNCSetContrast+0x5e>
				  Contrast++;
     bde:	1f 5f       	subi	r17, 0xFF	; 255
     be0:	0d c0       	rjmp	.+26     	; 0xbfc <FUNCSetContrast+0x5e>
			}
			else if (JoyStatus & JOY_DOWN)
     be2:	f7 9b       	sbis	0x1e, 7	; 30
     be4:	04 c0       	rjmp	.+8      	; 0xbee <FUNCSetContrast+0x50>
			{
				if (Contrast > 1)          // Zero is non-visible, so 1 is the minimum
     be6:	12 30       	cpi	r17, 0x02	; 2
     be8:	48 f0       	brcs	.+18     	; 0xbfc <FUNCSetContrast+0x5e>
				  Contrast--;
     bea:	11 50       	subi	r17, 0x01	; 1
     bec:	07 c0       	rjmp	.+14     	; 0xbfc <FUNCSetContrast+0x5e>
			}
			else if (JoyStatus & JOY_LEFT)
     bee:	f2 9b       	sbis	0x1e, 2	; 30
     bf0:	05 c0       	rjmp	.+10     	; 0xbfc <FUNCSetContrast+0x5e>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     bf2:	d7 01       	movw	r26, r14
     bf4:	01 2e       	mov	r0, r17
     bf6:	0e 94 64 1a 	call	0x34c8 <__eeprom_write_byte_1F2021>
			{
				eeprom_write_byte(&EEPROMVars.LCDContrast, Contrast);
				return;
     bfa:	18 c0       	rjmp	.+48     	; 0xc2c <FUNCSetContrast+0x8e>
			}
					
			Buffer[0] = 'C';
     bfc:	83 e4       	ldi	r24, 0x43	; 67
     bfe:	89 83       	std	Y+1, r24	; 0x01
			Buffer[1] = 'T';
     c00:	84 e5       	ldi	r24, 0x54	; 84
     c02:	8a 83       	std	Y+2, r24	; 0x02
			Buffer[2] = ' ';
     c04:	80 e2       	ldi	r24, 0x20	; 32
     c06:	8b 83       	std	Y+3, r24	; 0x03

			MAIN_IntToStr((uint16_t)Contrast, &Buffer[3]);
     c08:	be 01       	movw	r22, r28
     c0a:	6c 5f       	subi	r22, 0xFC	; 252
     c0c:	7f 4f       	sbci	r23, 0xFF	; 255
     c0e:	81 2f       	mov	r24, r17
     c10:	99 27       	eor	r25, r25
     c12:	0e 94 32 03 	call	0x664 <MAIN_IntToStr>
			LCD_puts(Buffer);
     c16:	ce 01       	movw	r24, r28
     c18:	01 96       	adiw	r24, 0x01	; 1
     c1a:	0e 94 14 08 	call	0x1028 <LCD_puts>

			LCD_CONTRAST_LEVEL(Contrast);
     c1e:	81 2f       	mov	r24, r17
     c20:	8f 70       	andi	r24, 0x0F	; 15
     c22:	80 93 e7 00 	sts	0x00E7, r24

			MAIN_WaitForJoyRelease();
     c26:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>
     c2a:	d2 cf       	rjmp	.-92     	; 0xbd0 <FUNCSetContrast+0x32>
     c2c:	26 96       	adiw	r28, 0x06	; 6
     c2e:	0f b6       	in	r0, 0x3f	; 63
     c30:	f8 94       	cli
     c32:	de bf       	out	0x3e, r29	; 62
     c34:	0f be       	out	0x3f, r0	; 63
     c36:	cd bf       	out	0x3d, r28	; 61
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	1f 91       	pop	r17
     c3e:	ff 90       	pop	r15
     c40:	ef 90       	pop	r14
     c42:	08 95       	ret

00000c44 <FUNCSetISPSpeed>:
		}
	}
}

void FUNCSetISPSpeed(void)
{
     c44:	0f 93       	push	r16
     c46:	1f 93       	push	r17
     c48:	cf 93       	push	r28
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     c4a:	01 e0       	ldi	r16, 0x01	; 1
     c4c:	10 e0       	ldi	r17, 0x00	; 0
  uint8_t result;
  asm volatile
     c4e:	d8 01       	movw	r26, r16
     c50:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
     c54:	80 2d       	mov	r24, r0
     c56:	c8 2f       	mov	r28, r24
	uint8_t CurrSpeed = eeprom_read_byte(&EEPROMVars.SCKDuration);

	if (CurrSpeed > (USI_PRESET_SPEEDS - 1)) CurrSpeed = 0; // Protection against blank EEPROM
     c58:	84 30       	cpi	r24, 0x04	; 4
     c5a:	08 f0       	brcs	.+2      	; 0xc5e <FUNCSetISPSpeed+0x1a>
     c5c:	c0 e0       	ldi	r28, 0x00	; 0

	JoyStatus = 1;                         // Invalid value to force the LCD to update
     c5e:	81 e0       	ldi	r24, 0x01	; 1
     c60:	8e bb       	out	0x1e, r24	; 30

	while (1)
	{
		if (JoyStatus)
     c62:	8e b3       	in	r24, 0x1e	; 30
     c64:	88 23       	and	r24, r24
     c66:	e9 f3       	breq	.-6      	; 0xc62 <FUNCSetISPSpeed+0x1e>
		{
			if (JoyStatus & JOY_UP)
     c68:	f6 9b       	sbis	0x1e, 6	; 30
     c6a:	06 c0       	rjmp	.+12     	; 0xc78 <FUNCSetISPSpeed+0x34>
			{
				(CurrSpeed == 0)? CurrSpeed = (USI_PRESET_SPEEDS - 1) : CurrSpeed--;
     c6c:	cc 23       	and	r28, r28
     c6e:	11 f4       	brne	.+4      	; 0xc74 <FUNCSetISPSpeed+0x30>
     c70:	c3 e0       	ldi	r28, 0x03	; 3
     c72:	11 c0       	rjmp	.+34     	; 0xc96 <FUNCSetISPSpeed+0x52>
     c74:	c1 50       	subi	r28, 0x01	; 1
     c76:	0f c0       	rjmp	.+30     	; 0xc96 <FUNCSetISPSpeed+0x52>
			}
			else if (JoyStatus & JOY_DOWN)
     c78:	f7 9b       	sbis	0x1e, 7	; 30
     c7a:	06 c0       	rjmp	.+12     	; 0xc88 <FUNCSetISPSpeed+0x44>
			{
				(CurrSpeed == (USI_PRESET_SPEEDS - 1))? CurrSpeed = 0 : CurrSpeed++;
     c7c:	c3 30       	cpi	r28, 0x03	; 3
     c7e:	11 f4       	brne	.+4      	; 0xc84 <FUNCSetISPSpeed+0x40>
     c80:	c0 e0       	ldi	r28, 0x00	; 0
     c82:	09 c0       	rjmp	.+18     	; 0xc96 <FUNCSetISPSpeed+0x52>
     c84:	cf 5f       	subi	r28, 0xFF	; 255
     c86:	07 c0       	rjmp	.+14     	; 0xc96 <FUNCSetISPSpeed+0x52>
			}
			else if (JoyStatus & JOY_LEFT)
     c88:	f2 9b       	sbis	0x1e, 2	; 30
     c8a:	05 c0       	rjmp	.+10     	; 0xc96 <FUNCSetISPSpeed+0x52>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     c8c:	d8 01       	movw	r26, r16
     c8e:	0c 2e       	mov	r0, r28
     c90:	0e 94 64 1a 	call	0x34c8 <__eeprom_write_byte_1F2021>
			{
				eeprom_write_byte(&EEPROMVars.SCKDuration, CurrSpeed);
				return;
     c94:	0b c0       	rjmp	.+22     	; 0xcac <FUNCSetISPSpeed+0x68>
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f(USISpeeds[CurrSpeed]);
     c96:	89 e0       	ldi	r24, 0x09	; 9
     c98:	c8 9f       	mul	r28, r24
     c9a:	c0 01       	movw	r24, r0
     c9c:	11 24       	eor	r1, r1
     c9e:	88 58       	subi	r24, 0x88	; 136
     ca0:	9f 4f       	sbci	r25, 0xFF	; 255
     ca2:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     ca6:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>
     caa:	db cf       	rjmp	.-74     	; 0xc62 <FUNCSetISPSpeed+0x1e>
     cac:	cf 91       	pop	r28
     cae:	1f 91       	pop	r17
     cb0:	0f 91       	pop	r16
     cb2:	08 95       	ret

00000cb4 <FUNCSetFirmMinorVer>:
		}
	}
}

void FUNCSetFirmMinorVer(void)
{
     cb4:	ef 92       	push	r14
     cb6:	ff 92       	push	r15
     cb8:	1f 93       	push	r17
     cba:	cf 93       	push	r28
     cbc:	df 93       	push	r29
     cbe:	cd b7       	in	r28, 0x3d	; 61
     cc0:	de b7       	in	r29, 0x3e	; 62
     cc2:	25 97       	sbiw	r28, 0x05	; 5
     cc4:	0f b6       	in	r0, 0x3f	; 63
     cc6:	f8 94       	cli
     cc8:	de bf       	out	0x3e, r29	; 62
     cca:	0f be       	out	0x3f, r0	; 63
     ccc:	cd bf       	out	0x3d, r28	; 61
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     cce:	96 e8       	ldi	r25, 0x86	; 134
     cd0:	e9 2e       	mov	r14, r25
     cd2:	90 e0       	ldi	r25, 0x00	; 0
     cd4:	f9 2e       	mov	r15, r25
  uint8_t result;
  asm volatile
     cd6:	d7 01       	movw	r26, r14
     cd8:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
     cdc:	80 2d       	mov	r24, r0
     cde:	18 2f       	mov	r17, r24
	uint8_t VerBuffer[5];
	uint8_t VerMinor = eeprom_read_byte(&EEPROMVars.FirmVerMinor);

	if (VerMinor > 9)
     ce0:	8a 30       	cpi	r24, 0x0A	; 10
     ce2:	08 f0       	brcs	.+2      	; 0xce6 <FUNCSetFirmMinorVer+0x32>
	  VerMinor = V2P_SW_VERSION_MINOR_DEFAULT;
     ce4:	14 e0       	ldi	r17, 0x04	; 4
	
	strcpy_P(VerBuffer, PSTR("V2- "));
     ce6:	62 ee       	ldi	r22, 0xE2	; 226
     ce8:	72 e0       	ldi	r23, 0x02	; 2
     cea:	ce 01       	movw	r24, r28
     cec:	01 96       	adiw	r24, 0x01	; 1
     cee:	0e 94 16 1a 	call	0x342c <strcpy_P>

	JoyStatus = 1;                        // Invalid value to force the LCD to update
     cf2:	81 e0       	ldi	r24, 0x01	; 1
     cf4:	8e bb       	out	0x1e, r24	; 30

	while (1)
	{
		if (JoyStatus)
     cf6:	8e b3       	in	r24, 0x1e	; 30
     cf8:	88 23       	and	r24, r24
     cfa:	e9 f3       	breq	.-6      	; 0xcf6 <FUNCSetFirmMinorVer+0x42>
		{
			if (JoyStatus & JOY_UP)
     cfc:	f6 9b       	sbis	0x1e, 6	; 30
     cfe:	03 c0       	rjmp	.+6      	; 0xd06 <FUNCSetFirmMinorVer+0x52>
			{
				if (VerMinor < 9)
     d00:	19 30       	cpi	r17, 0x09	; 9
     d02:	08 f4       	brcc	.+2      	; 0xd06 <FUNCSetFirmMinorVer+0x52>
				  VerMinor++;
     d04:	1f 5f       	subi	r17, 0xFF	; 255
			}
			if (JoyStatus & JOY_DOWN)
     d06:	f7 9b       	sbis	0x1e, 7	; 30
     d08:	04 c0       	rjmp	.+8      	; 0xd12 <FUNCSetFirmMinorVer+0x5e>
			{
				if (VerMinor)
     d0a:	11 23       	and	r17, r17
     d0c:	49 f0       	breq	.+18     	; 0xd20 <FUNCSetFirmMinorVer+0x6c>
				  VerMinor--;
     d0e:	11 50       	subi	r17, 0x01	; 1
     d10:	07 c0       	rjmp	.+14     	; 0xd20 <FUNCSetFirmMinorVer+0x6c>
			}
			else if (JoyStatus & JOY_LEFT)
     d12:	f2 9b       	sbis	0x1e, 2	; 30
     d14:	05 c0       	rjmp	.+10     	; 0xd20 <FUNCSetFirmMinorVer+0x6c>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     d16:	d7 01       	movw	r26, r14
     d18:	01 2e       	mov	r0, r17
     d1a:	0e 94 64 1a 	call	0x34c8 <__eeprom_write_byte_1F2021>
			{
				eeprom_write_byte(&EEPROMVars.FirmVerMinor, VerMinor);
				return;
     d1e:	0a c0       	rjmp	.+20     	; 0xd34 <FUNCSetFirmMinorVer+0x80>
			}
			
			VerBuffer[3] = ('0' + VerMinor);
     d20:	10 5d       	subi	r17, 0xD0	; 208
     d22:	1c 83       	std	Y+4, r17	; 0x04
     d24:	10 53       	subi	r17, 0x30	; 48
			LCD_puts(VerBuffer);
     d26:	ce 01       	movw	r24, r28
     d28:	01 96       	adiw	r24, 0x01	; 1
     d2a:	0e 94 14 08 	call	0x1028 <LCD_puts>

			MAIN_WaitForJoyRelease();
     d2e:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>
     d32:	e1 cf       	rjmp	.-62     	; 0xcf6 <FUNCSetFirmMinorVer+0x42>
     d34:	25 96       	adiw	r28, 0x05	; 5
     d36:	0f b6       	in	r0, 0x3f	; 63
     d38:	f8 94       	cli
     d3a:	de bf       	out	0x3e, r29	; 62
     d3c:	0f be       	out	0x3f, r0	; 63
     d3e:	cd bf       	out	0x3d, r28	; 61
     d40:	df 91       	pop	r29
     d42:	cf 91       	pop	r28
     d44:	1f 91       	pop	r17
     d46:	ff 90       	pop	r15
     d48:	ef 90       	pop	r14
     d4a:	08 95       	ret

00000d4c <FUNCSetAutoSleepTimeOut>:
		}
	}	
}

void FUNCSetAutoSleepTimeOut(void)
{
     d4c:	ef 92       	push	r14
     d4e:	ff 92       	push	r15
     d50:	1f 93       	push	r17
     d52:	cf 93       	push	r28
     d54:	df 93       	push	r29
     d56:	cd b7       	in	r28, 0x3d	; 61
     d58:	de b7       	in	r29, 0x3e	; 62
     d5a:	28 97       	sbiw	r28, 0x08	; 8
     d5c:	0f b6       	in	r0, 0x3f	; 63
     d5e:	f8 94       	cli
     d60:	de bf       	out	0x3e, r29	; 62
     d62:	0f be       	out	0x3f, r0	; 63
     d64:	cd bf       	out	0x3d, r28	; 61
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     d66:	27 e8       	ldi	r18, 0x87	; 135
     d68:	e2 2e       	mov	r14, r18
     d6a:	20 e0       	ldi	r18, 0x00	; 0
     d6c:	f2 2e       	mov	r15, r18
  uint8_t result;
  asm volatile
     d6e:	d7 01       	movw	r26, r14
     d70:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
     d74:	80 2d       	mov	r24, r0
     d76:	18 2f       	mov	r17, r24
	uint8_t SleepTxtBuffer[8];
	uint8_t SleepVal = eeprom_read_byte(&EEPROMVars.AutoSleepValIndex);

	if (SleepVal > 4)
     d78:	85 30       	cpi	r24, 0x05	; 5
     d7a:	08 f0       	brcs	.+2      	; 0xd7e <FUNCSetAutoSleepTimeOut+0x32>
	  SleepVal = 4;
     d7c:	14 e0       	ldi	r17, 0x04	; 4

	strcpy_P(SleepTxtBuffer, PSTR("    SEC"));
     d7e:	67 ee       	ldi	r22, 0xE7	; 231
     d80:	72 e0       	ldi	r23, 0x02	; 2
     d82:	ce 01       	movw	r24, r28
     d84:	01 96       	adiw	r24, 0x01	; 1
     d86:	0e 94 16 1a 	call	0x342c <strcpy_P>
	
	JoyStatus = 1;                        // Invalid value to force the LCD to update
     d8a:	81 e0       	ldi	r24, 0x01	; 1
     d8c:	8e bb       	out	0x1e, r24	; 30

	while (1)
	{
		if (JoyStatus)
     d8e:	8e b3       	in	r24, 0x1e	; 30
     d90:	88 23       	and	r24, r24
     d92:	e9 f3       	breq	.-6      	; 0xd8e <FUNCSetAutoSleepTimeOut+0x42>
		{
			if (JoyStatus & JOY_UP)
     d94:	f6 9b       	sbis	0x1e, 6	; 30
     d96:	05 c0       	rjmp	.+10     	; 0xda2 <FUNCSetAutoSleepTimeOut+0x56>
			{
				(SleepVal == 0)? SleepVal = 4 : SleepVal--;
     d98:	11 23       	and	r17, r17
     d9a:	11 f4       	brne	.+4      	; 0xda0 <FUNCSetAutoSleepTimeOut+0x54>
     d9c:	14 e0       	ldi	r17, 0x04	; 4
     d9e:	01 c0       	rjmp	.+2      	; 0xda2 <FUNCSetAutoSleepTimeOut+0x56>
     da0:	11 50       	subi	r17, 0x01	; 1
			}
			if (JoyStatus & JOY_DOWN)
     da2:	f7 9b       	sbis	0x1e, 7	; 30
     da4:	06 c0       	rjmp	.+12     	; 0xdb2 <FUNCSetAutoSleepTimeOut+0x66>
			{
				(SleepVal == 4)? SleepVal = 0 : SleepVal++;
     da6:	14 30       	cpi	r17, 0x04	; 4
     da8:	11 f4       	brne	.+4      	; 0xdae <FUNCSetAutoSleepTimeOut+0x62>
     daa:	10 e0       	ldi	r17, 0x00	; 0
     dac:	0d c0       	rjmp	.+26     	; 0xdc8 <FUNCSetAutoSleepTimeOut+0x7c>
     dae:	1f 5f       	subi	r17, 0xFF	; 255
     db0:	09 c0       	rjmp	.+18     	; 0xdc4 <FUNCSetAutoSleepTimeOut+0x78>
			}
			else if (JoyStatus & JOY_LEFT)
     db2:	f2 9b       	sbis	0x1e, 2	; 30
     db4:	07 c0       	rjmp	.+14     	; 0xdc4 <FUNCSetAutoSleepTimeOut+0x78>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     db6:	d7 01       	movw	r26, r14
     db8:	01 2e       	mov	r0, r17
     dba:	0e 94 64 1a 	call	0x34c8 <__eeprom_write_byte_1F2021>
			{
				eeprom_write_byte(&EEPROMVars.AutoSleepValIndex, SleepVal);
				TOUT_SetupSleepTimer();
     dbe:	0e 94 e4 0b 	call	0x17c8 <TOUT_SetupSleepTimer>
				return;
     dc2:	1b c0       	rjmp	.+54     	; 0xdfa <FUNCSetAutoSleepTimeOut+0xae>
			}

			if (!(SleepVal))
     dc4:	11 23       	and	r17, r17
     dc6:	29 f4       	brne	.+10     	; 0xdd2 <FUNCSetAutoSleepTimeOut+0x86>
			{
				LCD_puts_f(PSTR("OFF"));
     dc8:	8f ee       	ldi	r24, 0xEF	; 239
     dca:	92 e0       	ldi	r25, 0x02	; 2
     dcc:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>
     dd0:	11 c0       	rjmp	.+34     	; 0xdf4 <FUNCSetAutoSleepTimeOut+0xa8>
			}
			else
			{
				MAIN_IntToStr(pgm_read_byte(&AutoSleepTOValues[SleepVal]), &SleepTxtBuffer[0]);
     dd2:	e1 2f       	mov	r30, r17
     dd4:	ff 27       	eor	r31, r31
     dd6:	ea 53       	subi	r30, 0x3A	; 58
     dd8:	fc 4f       	sbci	r31, 0xFC	; 252
     dda:	84 91       	lpm	r24, Z
     ddc:	be 01       	movw	r22, r28
     dde:	6f 5f       	subi	r22, 0xFF	; 255
     de0:	7f 4f       	sbci	r23, 0xFF	; 255
     de2:	99 27       	eor	r25, r25
     de4:	0e 94 32 03 	call	0x664 <MAIN_IntToStr>
				SleepTxtBuffer[3] = ' '; // Remove the auto-string termination from the buffer
     de8:	80 e2       	ldi	r24, 0x20	; 32
     dea:	8c 83       	std	Y+4, r24	; 0x04
				LCD_puts(SleepTxtBuffer);
     dec:	ce 01       	movw	r24, r28
     dee:	01 96       	adiw	r24, 0x01	; 1
     df0:	0e 94 14 08 	call	0x1028 <LCD_puts>
			}

			MAIN_WaitForJoyRelease();
     df4:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>
     df8:	ca cf       	rjmp	.-108    	; 0xd8e <FUNCSetAutoSleepTimeOut+0x42>
     dfa:	28 96       	adiw	r28, 0x08	; 8
     dfc:	0f b6       	in	r0, 0x3f	; 63
     dfe:	f8 94       	cli
     e00:	de bf       	out	0x3e, r29	; 62
     e02:	0f be       	out	0x3f, r0	; 63
     e04:	cd bf       	out	0x3d, r28	; 61
     e06:	df 91       	pop	r29
     e08:	cf 91       	pop	r28
     e0a:	1f 91       	pop	r17
     e0c:	ff 90       	pop	r15
     e0e:	ef 90       	pop	r14
     e10:	08 95       	ret

00000e12 <FUNCSleepMode>:
		}
	}	
}

void FUNCSleepMode(void)
{
	SMCR    = ((1 << SM1) | (1 << SE));    // Power down sleep mode
     e12:	85 e0       	ldi	r24, 0x05	; 5
     e14:	83 bf       	out	0x33, r24	; 51
	LCDCRA &= ~(1 << LCDEN); 
     e16:	80 91 e4 00 	lds	r24, 0x00E4
     e1a:	8f 77       	andi	r24, 0x7F	; 127
     e1c:	80 93 e4 00 	sts	0x00E4, r24
	
	while (!(JoyStatus & JOY_UP))         // Joystick interrupt wakes the micro
	  SLEEP();
     e20:	f6 99       	sbic	0x1e, 6	; 30
     e22:	03 c0       	rjmp	.+6      	; 0xe2a <FUNCSleepMode+0x18>
     e24:	88 95       	sleep
     e26:	f6 9b       	sbis	0x1e, 6	; 30
     e28:	fd cf       	rjmp	.-6      	; 0xe24 <FUNCSleepMode+0x12>
	   
	LCDCRA |= (1 << LCDEN);
     e2a:	80 91 e4 00 	lds	r24, 0x00E4
     e2e:	80 68       	ori	r24, 0x80	; 128
     e30:	80 93 e4 00 	sts	0x00E4, r24
	
	MAIN_WaitForJoyRelease();
     e34:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>
     e38:	08 95       	ret

00000e3a <FUNCStorageInfo>:
}

void FUNCStorageInfo(void)
{
     e3a:	1f 93       	push	r17
     e3c:	cf 93       	push	r28
	uint8_t SelectedItem = 0;
     e3e:	10 e0       	ldi	r17, 0x00	; 0

	MAIN_WaitForJoyRelease();
     e40:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>

	JoyStatus = 1;                        // Invalid value to force the LCD to update
     e44:	81 e0       	ldi	r24, 0x01	; 1
     e46:	8e bb       	out	0x1e, r24	; 30

	while (1)
	{
		if (JoyStatus)
     e48:	8e b3       	in	r24, 0x1e	; 30
     e4a:	88 23       	and	r24, r24
     e4c:	e9 f3       	breq	.-6      	; 0xe48 <FUNCStorageInfo+0xe>
		{
			if (JoyStatus & (JOY_UP | JOY_DOWN))
     e4e:	ce b3       	in	r28, 0x1e	; 30
     e50:	c0 7c       	andi	r28, 0xC0	; 192
     e52:	19 f0       	breq	.+6      	; 0xe5a <FUNCStorageInfo+0x20>
			{
				SelectedItem ^= 1;
     e54:	81 e0       	ldi	r24, 0x01	; 1
     e56:	18 27       	eor	r17, r24
     e58:	38 c0       	rjmp	.+112    	; 0xeca <FUNCStorageInfo+0x90>
			}
			else if (JoyStatus & JOY_LEFT)
     e5a:	f2 99       	sbic	0x1e, 2	; 30
     e5c:	41 c0       	rjmp	.+130    	; 0xee0 <FUNCStorageInfo+0xa6>
			{
				return;
			}
			else if (JoyStatus & JOY_PRESS)
     e5e:	f4 9b       	sbis	0x1e, 4	; 30
     e60:	34 c0       	rjmp	.+104    	; 0xeca <FUNCStorageInfo+0x90>
			{
				if (SelectedItem == 1)    // View storage tags
     e62:	11 30       	cpi	r17, 0x01	; 1
     e64:	81 f5       	brne	.+96     	; 0xec6 <FUNCStorageInfo+0x8c>
				{
					DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
     e66:	83 e3       	ldi	r24, 0x33	; 51
     e68:	99 e0       	ldi	r25, 0x09	; 9
     e6a:	90 93 01 01 	sts	0x0101, r25
     e6e:	80 93 00 01 	sts	0x0100, r24
					SPI_SPIInit();
     e72:	0e 94 29 09 	call	0x1252 <SPI_SPIInit>
					UseExernalDF = FALSE;
     e76:	c0 93 65 02 	sts	0x0265, r28
					DF_EnableDataflash(TRUE);
     e7a:	81 2f       	mov	r24, r17
     e7c:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>

					if (DF_CheckCorrectOnboardChip())
     e80:	0e 94 37 0b 	call	0x166e <DF_CheckCorrectOnboardChip>
     e84:	c8 2f       	mov	r28, r24
     e86:	88 23       	and	r24, r24
     e88:	41 f0       	breq	.+16     	; 0xe9a <FUNCStorageInfo+0x60>
					{
						TM_ShowTags();
     e8a:	0e 94 e8 19 	call	0x33d0 <TM_ShowTags>
						SPI_SPIOFF();
     e8e:	80 91 64 00 	lds	r24, 0x0064
     e92:	84 60       	ori	r24, 0x04	; 4
     e94:	80 93 64 00 	sts	0x0064, r24
     e98:	18 c0       	rjmp	.+48     	; 0xeca <FUNCStorageInfo+0x90>
					}
					else if (!(PM_GetStoredDataSize(TYPE_FLASH)))
     e9a:	81 2f       	mov	r24, r17
     e9c:	0e 94 de 13 	call	0x27bc <PM_GetStoredDataSize>
     ea0:	dc 01       	movw	r26, r24
     ea2:	cb 01       	movw	r24, r22
     ea4:	00 97       	sbiw	r24, 0x00	; 0
     ea6:	a1 05       	cpc	r26, r1
     ea8:	b1 05       	cpc	r27, r1
     eaa:	79 f4       	brne	.+30     	; 0xeca <FUNCStorageInfo+0x90>
					{
						DF_EnableDataflash(FALSE);
     eac:	8c 2f       	mov	r24, r28
     eae:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
						SPI_SPIOFF();
     eb2:	80 91 64 00 	lds	r24, 0x0064
     eb6:	84 60       	ori	r24, 0x04	; 4
     eb8:	80 93 64 00 	sts	0x0064, r24

						MAIN_ShowError(PSTR("NO STORED PRGM"));
     ebc:	83 ef       	ldi	r24, 0xF3	; 243
     ebe:	92 e0       	ldi	r25, 0x02	; 2
     ec0:	0e 94 6b 03 	call	0x6d6 <MAIN_ShowError>
     ec4:	02 c0       	rjmp	.+4      	; 0xeca <FUNCStorageInfo+0x90>
					}	
				}
				else                      // View stored data sizes
				{
					PM_ShowStoredItemSizes();
     ec6:	0e 94 c3 18 	call	0x3186 <PM_ShowStoredItemSizes>
				}
			}
			
			LCD_puts_f(SIFONames[SelectedItem]);
     eca:	8e e0       	ldi	r24, 0x0E	; 14
     ecc:	18 9f       	mul	r17, r24
     ece:	c0 01       	movw	r24, r0
     ed0:	11 24       	eor	r1, r1
     ed2:	84 5a       	subi	r24, 0xA4	; 164
     ed4:	9f 4f       	sbci	r25, 0xFF	; 255
     ed6:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     eda:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>
     ede:	b4 cf       	rjmp	.-152    	; 0xe48 <FUNCStorageInfo+0xe>
     ee0:	cf 91       	pop	r28
     ee2:	1f 91       	pop	r17
     ee4:	08 95       	ret

00000ee6 <FUNCGoBootloader>:
		}
	}
}

void FUNCGoBootloader(void)
{
	uint8_t MD = (MCUCR & ~(1 << JTD));   // Forces compiler to use IN, AND plus two OUTs rather than two lots of IN/AND/OUTs
     ee6:	85 b7       	in	r24, 0x35	; 53
     ee8:	8f 77       	andi	r24, 0x7F	; 127
	MCUCR = MD;                           // Turn on JTAG via code
     eea:	85 bf       	out	0x35, r24	; 53
	MCUCR = MD;                           // Set bit twice as specified in datasheet        
     eec:	85 bf       	out	0x35, r24	; 53
	
	LCD_puts_f(PSTR("*JTAG ON*"));
     eee:	82 e0       	ldi	r24, 0x02	; 2
     ef0:	93 e0       	ldi	r25, 0x03	; 3
     ef2:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>
	
	MAIN_WaitForJoyRelease();
     ef6:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>
	
	WDTCR = ((1<<WDCE) | (1<<WDE));       // Enable Watchdog Timer to give reset after minimum timeout
     efa:	88 e1       	ldi	r24, 0x18	; 24
     efc:	80 93 60 00 	sts	0x0060, r24
	while (1) {};                        // Eternal loop - when watchdog resets the AVR it will enter the bootloader
     f00:	ff cf       	rjmp	.-2      	; 0xf00 <FUNCGoBootloader+0x1a>

00000f02 <OSCCAL_Calibrate>:

static volatile uint16_t ActualCount;

void OSCCAL_Calibrate(void)
{
     f02:	cf 93       	push	r28
     f04:	df 93       	push	r29
	uint8_t SREG_Backup;
	uint8_t LoopCount = (0x7F / 2); // Maximum range is 128, and starts from the middle, so 64 is the max number of iterations required
     f06:	4f e3       	ldi	r20, 0x3F	; 63
	uint8_t PrevOSCALValues[2];
   
	// Reset ActualCount
	ActualCount = 0;
     f08:	10 92 05 01 	sts	0x0105, r1
     f0c:	10 92 04 01 	sts	0x0104, r1
   
	// Make sure all clock division is turned off (8Mhz RC clock)
	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_CLOCKSPEED_8MHZ);
     f10:	80 e8       	ldi	r24, 0x80	; 128
     f12:	80 93 61 00 	sts	0x0061, r24
     f16:	10 92 61 00 	sts	0x0061, r1

	// Inital OSCCAL of half its maximum for speed
	OSCCAL = (0x7F / 2);
     f1a:	40 93 66 00 	sts	0x0066, r20

	// Save the SREG
	SREG_Backup = SREG;
     f1e:	5f b7       	in	r21, 0x3f	; 63
    
	// Disable all timer 1 interrupts
	TIMSK1 = 0;
     f20:	10 92 6f 00 	sts	0x006F, r1
        
	// Set timer 2 to asyncronous mode (32.768KHz crystal)
	ASSR   = (1 << AS2);
     f24:	88 e0       	ldi	r24, 0x08	; 8
     f26:	80 93 b6 00 	sts	0x00B6, r24
        
	// Timer 2 overflow interrupt enable
	TIMSK2 = (1 << TOIE2);
     f2a:	81 e0       	ldi	r24, 0x01	; 1
     f2c:	80 93 70 00 	sts	0x0070, r24

	// Enable interrupts
	sei();
     f30:	78 94       	sei

	// Start both counters with no prescaling
	TCCR1B = (1 << CS10);
     f32:	80 93 81 00 	sts	0x0081, r24
	TCCR2A = (1 << CS20);
     f36:	80 93 b0 00 	sts	0x00B0, r24
	 	 
	// Previous OSCCAL value of 0
	PrevOSCALValues[0] = 0;
     f3a:	20 e0       	ldi	r18, 0x00	; 0
     f3c:	30 e0       	ldi	r19, 0x00	; 0

	// Wait until timer 2's external 32.768KHz crystal is stable
	while (ASSR & ((1 << TCN2UB) | (1 << TCR2UB) | (1 << OCR2UB)));
     f3e:	80 91 b6 00 	lds	r24, 0x00B6
     f42:	99 27       	eor	r25, r25
     f44:	87 70       	andi	r24, 0x07	; 7
     f46:	90 70       	andi	r25, 0x00	; 0
     f48:	00 97       	sbiw	r24, 0x00	; 0
     f4a:	c9 f7       	brne	.-14     	; 0xf3e <OSCCAL_Calibrate+0x3c>
    
	// Clear the timer values
	TCNT1  = 0;
     f4c:	90 93 85 00 	sts	0x0085, r25
     f50:	80 93 84 00 	sts	0x0084, r24
	TCNT2  = 0;
     f54:	10 92 b2 00 	sts	0x00B2, r1
    
	while (LoopCount--)
	{
		// Let it take a few readings (14ms, approx 2 readings)
		_delay_ms(14);

		PrevOSCALValues[1] = PrevOSCALValues[0];
		PrevOSCALValues[0] = OSCCAL;
        
		if (ActualCount > OSCCAL_UPPERCOUNTBOUND)       // Clock is running too fast
			OSCCAL--;
		else if (ActualCount < OSCCAL_LOWERCOUNTBOUND) // Clock is running too slow
			OSCCAL++;
		else		                                     // Clock is just right
			break;
		
		// If the routine cannot find a value withing the count tollerance,
		// it will cause the OSCCAL to hover around the closest two values.
		// If the current value is the same as the 2*n previous, exit the
		// routine as the best value has been found.
		if (OSCCAL == PrevOSCALValues[1])
		  break;
     f58:	4e e3       	ldi	r20, 0x3E	; 62
     f5a:	ac ec       	ldi	r26, 0xCC	; 204
     f5c:	b4 e6       	ldi	r27, 0x64	; 100
     f5e:	c0 e0       	ldi	r28, 0x00	; 0
     f60:	d0 e0       	ldi	r29, 0x00	; 0
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     f62:	cd 01       	movw	r24, r26
     f64:	01 97       	sbiw	r24, 0x01	; 1
     f66:	f1 f7       	brne	.-4      	; 0xf64 <OSCCAL_Calibrate+0x62>
     f68:	32 2f       	mov	r19, r18
     f6a:	80 91 66 00 	lds	r24, 0x0066
     f6e:	28 2f       	mov	r18, r24
     f70:	80 91 04 01 	lds	r24, 0x0104
     f74:	90 91 05 01 	lds	r25, 0x0105
     f78:	81 50       	subi	r24, 0x01	; 1
     f7a:	91 4e       	sbci	r25, 0xE1	; 225
     f7c:	20 f0       	brcs	.+8      	; 0xf86 <OSCCAL_Calibrate+0x84>
     f7e:	80 91 66 00 	lds	r24, 0x0066
     f82:	81 50       	subi	r24, 0x01	; 1
     f84:	0a c0       	rjmp	.+20     	; 0xf9a <OSCCAL_Calibrate+0x98>
     f86:	80 91 04 01 	lds	r24, 0x0104
     f8a:	90 91 05 01 	lds	r25, 0x0105
     f8e:	86 5f       	subi	r24, 0xF6	; 246
     f90:	90 4e       	sbci	r25, 0xE0	; 224
     f92:	58 f4       	brcc	.+22     	; 0xfaa <OSCCAL_Calibrate+0xa8>
     f94:	80 91 66 00 	lds	r24, 0x0066
     f98:	8f 5f       	subi	r24, 0xFF	; 255
     f9a:	80 93 66 00 	sts	0x0066, r24
     f9e:	80 91 66 00 	lds	r24, 0x0066
     fa2:	83 17       	cp	r24, r19
     fa4:	11 f0       	breq	.+4      	; 0xfaa <OSCCAL_Calibrate+0xa8>
     fa6:	41 50       	subi	r20, 0x01	; 1
     fa8:	e0 f6       	brcc	.-72     	; 0xf62 <OSCCAL_Calibrate+0x60>
	}

	// Disable all timer interrupts
	TIMSK1 = 0;
     faa:	10 92 6f 00 	sts	0x006F, r1
	TIMSK2 = 0;
     fae:	10 92 70 00 	sts	0x0070, r1
    
	// Stop the timers
	TCCR1B = 0x00;
     fb2:	10 92 81 00 	sts	0x0081, r1
	TCCR2A = 0x00;
     fb6:	10 92 b0 00 	sts	0x00B0, r1

	// Turn off timer 2 asynchronous mode
	ASSR  &= ~(1 << AS2);
     fba:	80 91 b6 00 	lds	r24, 0x00B6
     fbe:	87 7f       	andi	r24, 0xF7	; 247
     fc0:	80 93 b6 00 	sts	0x00B6, r24

	// Restore SREG
	SREG = SREG_Backup;
     fc4:	5f bf       	out	0x3f, r21	; 63
     fc6:	df 91       	pop	r29
     fc8:	cf 91       	pop	r28
     fca:	08 95       	ret

00000fcc <__vector_5>:
        
	return;
}

ISR(TIMER2_OVF_vect, ISR_BLOCK) // Occurs 32768/256 timers per second, or 128Hz
{
     fcc:	1f 92       	push	r1
     fce:	0f 92       	push	r0
     fd0:	0f b6       	in	r0, 0x3f	; 63
     fd2:	0f 92       	push	r0
     fd4:	11 24       	eor	r1, r1
     fd6:	8f 93       	push	r24
     fd8:	9f 93       	push	r25
	// Stop timer 1 so it can be read
	TCCR1B = 0x00;
     fda:	10 92 81 00 	sts	0x0081, r1
    
	// Record timer 1's value
	ActualCount = TCNT1;
     fde:	80 91 84 00 	lds	r24, 0x0084
     fe2:	90 91 85 00 	lds	r25, 0x0085
     fe6:	90 93 05 01 	sts	0x0105, r25
     fea:	80 93 04 01 	sts	0x0104, r24
	     
	// Reset counters and restart timer 1
	TCNT1  = 0;
     fee:	10 92 85 00 	sts	0x0085, r1
     ff2:	10 92 84 00 	sts	0x0084, r1
	TCNT2  = 0;
     ff6:	10 92 b2 00 	sts	0x00B2, r1
	TCCR1B = (1 << CS10);
     ffa:	81 e0       	ldi	r24, 0x01	; 1
     ffc:	80 93 81 00 	sts	0x0081, r24
    1000:	9f 91       	pop	r25
    1002:	8f 91       	pop	r24
    1004:	0f 90       	pop	r0
    1006:	0f be       	out	0x3f, r0	; 63
    1008:	0f 90       	pop	r0
    100a:	1f 90       	pop	r1
    100c:	18 95       	reti

0000100e <LCD_Init>:

void LCD_Init(void)
{
	// Set the initial contrast level to maximum:
	LCDCCR = 0x0F;
    100e:	8f e0       	ldi	r24, 0x0F	; 15
    1010:	80 93 e7 00 	sts	0x00E7, r24

    // Select asynchronous clock source, enable all COM pins and enable all segment pins:
    LCDCRB  = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
    1014:	87 eb       	ldi	r24, 0xB7	; 183
    1016:	80 93 e5 00 	sts	0x00E5, r24

    // Set LCD prescaler to give a framerate of 32Hz:
    LCDFRR  = (7<<LCDCD0);    
    101a:	87 e0       	ldi	r24, 0x07	; 7
    101c:	80 93 e6 00 	sts	0x00E6, r24

	// Enable LCD and set low power waveform, enable start of frame interrupt:
    LCDCRA  = (1<<LCDEN) | (1<<LCDAB) | (1<<LCDIE);
    1020:	88 ec       	ldi	r24, 0xC8	; 200
    1022:	80 93 e4 00 	sts	0x00E4, r24
    1026:	08 95       	ret

00001028 <LCD_puts>:
}

void LCD_puts_f(const uint8_t *FlashData)
{
	uint8_t StrBuff[LCD_TEXTBUFFER_SIZE];

	strcpy_P(StrBuff, FlashData);
	LCD_puts(StrBuff);
}

void LCD_puts(const uint8_t *Data)
{
    1028:	dc 01       	movw	r26, r24
	uint8_t LoadB;
	
	for (LoadB = 0; LoadB < 20; LoadB++)
    102a:	20 e0       	ldi	r18, 0x00	; 0
    102c:	3f ef       	ldi	r19, 0xFF	; 255
    102e:	e6 e0       	ldi	r30, 0x06	; 6
    1030:	f1 e0       	ldi	r31, 0x01	; 1
	{
		uint8_t CByte = *(Data++);
    1032:	9d 91       	ld	r25, X+
	
		if ((CByte >= '*') && (CByte <= 'z') && (CByte != ' '))
    1034:	89 2f       	mov	r24, r25
    1036:	8a 52       	subi	r24, 0x2A	; 42
    1038:	81 35       	cpi	r24, 0x51	; 81
    103a:	10 f4       	brcc	.+4      	; 0x1040 <LCD_puts+0x18>
		  TextBuffer[LoadB] = (CByte - '*');
    103c:	80 83       	st	Z, r24
    103e:	03 c0       	rjmp	.+6      	; 0x1046 <LCD_puts+0x1e>
		else if (CByte == 0x00)
    1040:	99 23       	and	r25, r25
    1042:	29 f0       	breq	.+10     	; 0x104e <LCD_puts+0x26>
		  break;
		else
		  TextBuffer[LoadB] = 0xFF;		
    1044:	30 83       	st	Z, r19
    1046:	2f 5f       	subi	r18, 0xFF	; 255
    1048:	31 96       	adiw	r30, 0x01	; 1
    104a:	24 31       	cpi	r18, 0x14	; 20
    104c:	90 f3       	brcs	.-28     	; 0x1032 <LCD_puts+0xa>
	}

	ScrollMode  = ((LoadB > 6)? TRUE : FALSE);
    104e:	80 e0       	ldi	r24, 0x00	; 0
    1050:	27 30       	cpi	r18, 0x07	; 7
    1052:	08 f0       	brcs	.+2      	; 0x1056 <LCD_puts+0x2e>
    1054:	81 e0       	ldi	r24, 0x01	; 1
    1056:	80 93 37 01 	sts	0x0137, r24
	ScrollCount = 0;
    105a:	10 92 38 01 	sts	0x0138, r1
    105e:	9f ef       	ldi	r25, 0xFF	; 255
    1060:	86 e0       	ldi	r24, 0x06	; 6

	for (uint8_t Nulls = 0; Nulls < 7; Nulls++)
		TextBuffer[LoadB++] = 0xFF;
    1062:	e2 2f       	mov	r30, r18
    1064:	ff 27       	eor	r31, r31
    1066:	ea 5f       	subi	r30, 0xFA	; 250
    1068:	fe 4f       	sbci	r31, 0xFE	; 254
    106a:	90 83       	st	Z, r25
    106c:	2f 5f       	subi	r18, 0xFF	; 255
    106e:	81 50       	subi	r24, 0x01	; 1
    1070:	87 ff       	sbrs	r24, 7
    1072:	f7 cf       	rjmp	.-18     	; 0x1062 <LCD_puts+0x3a>
	
	TextBuffer[LoadB] = 0x00;
    1074:	e2 2f       	mov	r30, r18
    1076:	ff 27       	eor	r31, r31
    1078:	ea 5f       	subi	r30, 0xFA	; 250
    107a:	fe 4f       	sbci	r31, 0xFE	; 254
    107c:	10 82       	st	Z, r1
	StrStart   = 0;
    107e:	10 92 35 01 	sts	0x0135, r1
	StrEnd     = LoadB;	
    1082:	20 93 36 01 	sts	0x0136, r18
	DelayCount = LCD_DELAYCOUNT_DEFAULT;
    1086:	8a e0       	ldi	r24, 0x0A	; 10
    1088:	80 93 39 01 	sts	0x0139, r24

	UpdateLCD  = TRUE;
    108c:	81 e0       	ldi	r24, 0x01	; 1
    108e:	80 93 3a 01 	sts	0x013A, r24
    1092:	08 95       	ret

00001094 <LCD_puts_f>:
    1094:	cf 93       	push	r28
    1096:	df 93       	push	r29
    1098:	cd b7       	in	r28, 0x3d	; 61
    109a:	de b7       	in	r29, 0x3e	; 62
    109c:	64 97       	sbiw	r28, 0x14	; 20
    109e:	0f b6       	in	r0, 0x3f	; 63
    10a0:	f8 94       	cli
    10a2:	de bf       	out	0x3e, r29	; 62
    10a4:	0f be       	out	0x3f, r0	; 63
    10a6:	cd bf       	out	0x3d, r28	; 61
    10a8:	bc 01       	movw	r22, r24
    10aa:	ce 01       	movw	r24, r28
    10ac:	01 96       	adiw	r24, 0x01	; 1
    10ae:	0e 94 16 1a 	call	0x342c <strcpy_P>
    10b2:	ce 01       	movw	r24, r28
    10b4:	01 96       	adiw	r24, 0x01	; 1
    10b6:	0e 94 14 08 	call	0x1028 <LCD_puts>
    10ba:	64 96       	adiw	r28, 0x14	; 20
    10bc:	0f b6       	in	r0, 0x3f	; 63
    10be:	f8 94       	cli
    10c0:	de bf       	out	0x3e, r29	; 62
    10c2:	0f be       	out	0x3f, r0	; 63
    10c4:	cd bf       	out	0x3d, r28	; 61
    10c6:	df 91       	pop	r29
    10c8:	cf 91       	pop	r28
    10ca:	08 95       	ret

000010cc <LCD_WriteChar>:
}

void LCD_WriteChar(const uint8_t Byte, const uint8_t Digit)
{
    10cc:	e8 2f       	mov	r30, r24
	uint16_t SegData  = 0x00;
    10ce:	20 e0       	ldi	r18, 0x00	; 0
    10d0:	30 e0       	ldi	r19, 0x00	; 0
	uint8_t  *BuffPtr = (&SegBuffer[0] + (Digit >> 1));
    10d2:	86 2f       	mov	r24, r22
    10d4:	86 95       	lsr	r24
    10d6:	a8 2f       	mov	r26, r24
    10d8:	bb 27       	eor	r27, r27
    10da:	af 5d       	subi	r26, 0xDF	; 223
    10dc:	be 4f       	sbci	r27, 0xFE	; 254

	if (Byte != 0xFF)
    10de:	ef 3f       	cpi	r30, 0xFF	; 255
    10e0:	39 f0       	breq	.+14     	; 0x10f0 <LCD_WriteChar+0x24>
	  SegData = pgm_read_word(&LCD_SegTable[Byte]);	
    10e2:	ff 27       	eor	r31, r31
    10e4:	ee 0f       	add	r30, r30
    10e6:	ff 1f       	adc	r31, r31
    10e8:	e4 5f       	subi	r30, 0xF4	; 244
    10ea:	fc 4f       	sbci	r31, 0xFC	; 252
    10ec:	25 91       	lpm	r18, Z+
    10ee:	34 91       	lpm	r19, Z
    10f0:	77 27       	eor	r23, r23
    10f2:	61 70       	andi	r22, 0x01	; 1
    10f4:	70 70       	andi	r23, 0x00	; 0
    10f6:	43 e0       	ldi	r20, 0x03	; 3

	for (uint8_t BNib = 0; BNib < 4; BNib++)
	{
		uint8_t Mask          = 0xF0;
    10f8:	50 ef       	ldi	r21, 0xF0	; 240
		uint8_t MaskedSegData = (SegData & 0x0000F);
    10fa:	92 2f       	mov	r25, r18
    10fc:	9f 70       	andi	r25, 0x0F	; 15
	
		if (Digit & 0x01)
    10fe:	61 15       	cp	r22, r1
    1100:	71 05       	cpc	r23, r1
    1102:	19 f0       	breq	.+6      	; 0x110a <LCD_WriteChar+0x3e>
		{
			Mask = 0x0F;
    1104:	5f e0       	ldi	r21, 0x0F	; 15
			MaskedSegData <<= 4;
    1106:	92 95       	swap	r25
    1108:	90 7f       	andi	r25, 0xF0	; 240
		}
		
		*BuffPtr = ((*BuffPtr & Mask) | MaskedSegData);
    110a:	8c 91       	ld	r24, X
    110c:	85 23       	and	r24, r21
    110e:	89 2b       	or	r24, r25
    1110:	8c 93       	st	X, r24

		SegData >>= 4;
    1112:	84 e0       	ldi	r24, 0x04	; 4
    1114:	36 95       	lsr	r19
    1116:	27 95       	ror	r18
    1118:	8a 95       	dec	r24
    111a:	e1 f7       	brne	.-8      	; 0x1114 <LCD_WriteChar+0x48>
		BuffPtr  += 5;
    111c:	15 96       	adiw	r26, 0x05	; 5
    111e:	41 50       	subi	r20, 0x01	; 1
    1120:	47 ff       	sbrs	r20, 7
    1122:	ea cf       	rjmp	.-44     	; 0x10f8 <LCD_WriteChar+0x2c>
    1124:	08 95       	ret

00001126 <__vector_22>:
	}
}

ISR(LCD_vect, ISR_NOBLOCK)
{
    1126:	78 94       	sei
    1128:	1f 92       	push	r1
    112a:	0f 92       	push	r0
    112c:	0f b6       	in	r0, 0x3f	; 63
    112e:	0f 92       	push	r0
    1130:	11 24       	eor	r1, r1
    1132:	2f 93       	push	r18
    1134:	3f 93       	push	r19
    1136:	4f 93       	push	r20
    1138:	5f 93       	push	r21
    113a:	6f 93       	push	r22
    113c:	7f 93       	push	r23
    113e:	8f 93       	push	r24
    1140:	9f 93       	push	r25
    1142:	af 93       	push	r26
    1144:	bf 93       	push	r27
    1146:	cf 93       	push	r28
    1148:	ef 93       	push	r30
    114a:	ff 93       	push	r31
	if (ScrollMode)
    114c:	80 91 37 01 	lds	r24, 0x0137
    1150:	88 23       	and	r24, r24
    1152:	99 f0       	breq	.+38     	; 0x117a <__vector_22+0x54>
	{
		if (DelayCount)
    1154:	80 91 39 01 	lds	r24, 0x0139
    1158:	88 23       	and	r24, r24
    115a:	21 f0       	breq	.+8      	; 0x1164 <__vector_22+0x3e>
		{
			DelayCount--;
    115c:	81 50       	subi	r24, 0x01	; 1
    115e:	80 93 39 01 	sts	0x0139, r24
    1162:	0b c0       	rjmp	.+22     	; 0x117a <__vector_22+0x54>
		}
		else
		{
			if (!(ScrollCount))
    1164:	80 91 38 01 	lds	r24, 0x0138
    1168:	88 23       	and	r24, r24
    116a:	21 f4       	brne	.+8      	; 0x1174 <__vector_22+0x4e>
			  UpdateLCD = TRUE;
    116c:	81 e0       	ldi	r24, 0x01	; 1
    116e:	80 93 3a 01 	sts	0x013A, r24
    1172:	03 c0       	rjmp	.+6      	; 0x117a <__vector_22+0x54>
			else
			  ScrollCount--;
    1174:	81 50       	subi	r24, 0x01	; 1
    1176:	80 93 38 01 	sts	0x0138, r24
		}
	}

	if (UpdateLCD)
    117a:	80 91 3a 01 	lds	r24, 0x013A
    117e:	88 23       	and	r24, r24
    1180:	39 f1       	breq	.+78     	; 0x11d0 <__vector_22+0xaa>
	{
		for (uint8_t Character = 0; Character < 6; Character++)
    1182:	c0 e0       	ldi	r28, 0x00	; 0
		{
			uint8_t Byte = (StrStart + Character);
    1184:	80 91 35 01 	lds	r24, 0x0135
    1188:	8c 0f       	add	r24, r28

			if (Byte >= StrEnd)
    118a:	90 91 36 01 	lds	r25, 0x0136
    118e:	e8 2f       	mov	r30, r24
    1190:	ff 27       	eor	r31, r31
    1192:	89 17       	cp	r24, r25
    1194:	10 f0       	brcs	.+4      	; 0x119a <__vector_22+0x74>
			  Byte = TextBuffer[Byte - StrEnd];
    1196:	e9 1b       	sub	r30, r25
    1198:	f1 09       	sbc	r31, r1
			else
			  Byte = TextBuffer[Byte];
    119a:	ea 5f       	subi	r30, 0xFA	; 250
    119c:	fe 4f       	sbci	r31, 0xFE	; 254
    119e:	80 81       	ld	r24, Z
			
			LCD_WriteChar(Byte, Character);
    11a0:	6c 2f       	mov	r22, r28
    11a2:	0e 94 66 08 	call	0x10cc <LCD_WriteChar>
    11a6:	cf 5f       	subi	r28, 0xFF	; 255
    11a8:	c6 30       	cpi	r28, 0x06	; 6
    11aa:	60 f3       	brcs	.-40     	; 0x1184 <__vector_22+0x5e>
		}
		
		if (StrStart++ == StrEnd)
    11ac:	80 91 35 01 	lds	r24, 0x0135
    11b0:	98 2f       	mov	r25, r24
    11b2:	8f 5f       	subi	r24, 0xFF	; 255
    11b4:	80 93 35 01 	sts	0x0135, r24
    11b8:	80 91 36 01 	lds	r24, 0x0136
    11bc:	98 17       	cp	r25, r24
    11be:	19 f4       	brne	.+6      	; 0x11c6 <__vector_22+0xa0>
		  StrStart = 1;
    11c0:	81 e0       	ldi	r24, 0x01	; 1
    11c2:	80 93 35 01 	sts	0x0135, r24
		
		ScrollCount = LCD_SCROLLCOUNT_DEFAULT;
    11c6:	83 e0       	ldi	r24, 0x03	; 3
    11c8:	80 93 38 01 	sts	0x0138, r24
		UpdateLCD = FALSE;
    11cc:	10 92 3a 01 	sts	0x013A, r1
    11d0:	ac ee       	ldi	r26, 0xEC	; 236
    11d2:	b0 e0       	ldi	r27, 0x00	; 0
    11d4:	e1 e2       	ldi	r30, 0x21	; 33
    11d6:	f1 e0       	ldi	r31, 0x01	; 1
    11d8:	93 e1       	ldi	r25, 0x13	; 19
	}

	for (uint8_t LCDChar = 0; LCDChar < LCD_SEGBUFFER_SIZE; LCDChar++)
	  *(pLCDREG + LCDChar) = SegBuffer[LCDChar];
    11da:	81 91       	ld	r24, Z+
    11dc:	8d 93       	st	X+, r24
    11de:	91 50       	subi	r25, 0x01	; 1
    11e0:	97 ff       	sbrs	r25, 7
    11e2:	fb cf       	rjmp	.-10     	; 0x11da <__vector_22+0xb4>
    11e4:	ff 91       	pop	r31
    11e6:	ef 91       	pop	r30
    11e8:	cf 91       	pop	r28
    11ea:	bf 91       	pop	r27
    11ec:	af 91       	pop	r26
    11ee:	9f 91       	pop	r25
    11f0:	8f 91       	pop	r24
    11f2:	7f 91       	pop	r23
    11f4:	6f 91       	pop	r22
    11f6:	5f 91       	pop	r21
    11f8:	4f 91       	pop	r20
    11fa:	3f 91       	pop	r19
    11fc:	2f 91       	pop	r18
    11fe:	0f 90       	pop	r0
    1200:	0f be       	out	0x3f, r0	; 63
    1202:	0f 90       	pop	r0
    1204:	1f 90       	pop	r1
    1206:	18 95       	reti

00001208 <USART_Init>:
*****************************************************************************/
void USART_Init(void)
{
    // Set baud rate
    UBRRH = (uint8_t)(USART_BAUDVALUE >> 8);
    1208:	10 92 c5 00 	sts	0x00C5, r1
    UBRRL = (uint8_t)(USART_BAUDVALUE);
    120c:	87 e0       	ldi	r24, 0x07	; 7
    120e:	80 93 c4 00 	sts	0x00C4, r24

    // Double speed
	UCSRA = (USART_DOUBLESPEED << U2X);
    1212:	82 e0       	ldi	r24, 0x02	; 2
    1214:	80 93 c0 00 	sts	0x00C0, r24

    // Enable recieve complete interrupt
	UCSRB = (1 << RXCIE);
    1218:	80 e8       	ldi	r24, 0x80	; 128
    121a:	80 93 c1 00 	sts	0x00C1, r24
	 
    // Async. mode, 8N1
    UCSRC = (3 << UCSZ0);
    121e:	86 e0       	ldi	r24, 0x06	; 6
    1220:	80 93 c2 00 	sts	0x00C2, r24
	 
	 // Initalise ringbuffer
	BUFF_InitialiseBuffer();
    1224:	0e 94 9a 0b 	call	0x1734 <BUFF_InitialiseBuffer>
    1228:	08 95       	ret

0000122a <USART_Tx>:
}

/*****************************************************************************
*
*   Function name : Usart_Tx
*
*   Returns :       None
*
*   Parameters :    char data: byte to send
*
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_Tx(const char data)
{
    122a:	98 2f       	mov	r25, r24
    while (!(UCSRA & (1 << UDRE)));
    122c:	80 91 c0 00 	lds	r24, 0x00C0
    1230:	85 ff       	sbrs	r24, 5
    1232:	fc cf       	rjmp	.-8      	; 0x122c <USART_Tx+0x2>
    UDR = data;
    1234:	90 93 c6 00 	sts	0x00C6, r25
    1238:	08 95       	ret

0000123a <USART_Rx>:
}

/*****************************************************************************
*
*   Function name : Usart_Rx
*
*   Returns :       char: byte received
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART
*
*****************************************************************************/
char USART_Rx(void)
{
    while (!(BuffElements) && !(PacketTimeOut)) {};
    123a:	80 91 b3 02 	lds	r24, 0x02B3
    123e:	88 23       	and	r24, r24
    1240:	21 f4       	brne	.+8      	; 0x124a <USART_Rx+0x10>
    1242:	80 91 3f 01 	lds	r24, 0x013F
    1246:	88 23       	and	r24, r24
    1248:	c1 f3       	breq	.-16     	; 0x123a <USART_Rx>
    return BUFF_GetBuffByte();
    124a:	0e 94 a7 0b 	call	0x174e <BUFF_GetBuffByte>
}
    124e:	99 27       	eor	r25, r25
    1250:	08 95       	ret

00001252 <SPI_SPIInit>:
// ======================================================================================

void SPI_SPIInit(void)
{
	PRR &= ~(1 << PRSPI);              // Enable the SPI system by clearing the power save register SPI disable bit
    1252:	80 91 64 00 	lds	r24, 0x0064
    1256:	8b 7f       	andi	r24, 0xFB	; 251
    1258:	80 93 64 00 	sts	0x0064, r24

	// Master, Sample falling edge (setup rising), Fosc/2 speed (8Mhz/2 = 4MHz)
	SPSR = (1 << SPI2X);
    125c:	81 e0       	ldi	r24, 0x01	; 1
    125e:	8d bd       	out	0x2d, r24	; 45
	SPCR = ((1 << SPE) | (1 << MSTR) | (1 << CPHA) | (1 << CPOL));
    1260:	8c e5       	ldi	r24, 0x5C	; 92
    1262:	8c bd       	out	0x2c, r24	; 44
    1264:	08 95       	ret

00001266 <SPI_SPITransmit>:
}

uint8_t SPI_SPITransmit(const uint8_t Data)
{
	SPDR = Data;                       // Loading a byte into the register starts the transmission
    1266:	8e bd       	out	0x2e, r24	; 46
	while (!(SPSR & (1 << SPIF)));    // Wait until transmission completed
    1268:	0d b4       	in	r0, 0x2d	; 45
    126a:	07 fe       	sbrs	r0, 7
    126c:	fd cf       	rjmp	.-6      	; 0x1268 <SPI_SPITransmit+0x2>
	return SPDR;
    126e:	8e b5       	in	r24, 0x2e	; 46
}
    1270:	99 27       	eor	r25, r25
    1272:	08 95       	ret

00001274 <SPI_SPITransmitWord>:

uint8_t SPI_SPITransmitWord(const uint16_t Data)
{
    1274:	0f 93       	push	r16
    1276:	1f 93       	push	r17
    1278:	8c 01       	movw	r16, r24
	SPI_SPITransmit((uint8_t)(Data >> 8));
    127a:	81 2f       	mov	r24, r17
    127c:	99 27       	eor	r25, r25
    127e:	0e 94 33 09 	call	0x1266 <SPI_SPITransmit>
	return SPI_SPITransmit((uint8_t)Data);
    1282:	80 2f       	mov	r24, r16
    1284:	0e 94 33 09 	call	0x1266 <SPI_SPITransmit>
}
    1288:	99 27       	eor	r25, r25
    128a:	1f 91       	pop	r17
    128c:	0f 91       	pop	r16
    128e:	08 95       	ret

00001290 <__vector_17>:
 *  have to stop the timer tick.
 *  For all modes the USIDR contents are stored and flags are updated.
 */
ISR(USI_OVERFLOW_vect, ISR_BLOCK)
{
    1290:	1f 92       	push	r1
    1292:	0f 92       	push	r0
    1294:	0f b6       	in	r0, 0x3f	; 63
    1296:	0f 92       	push	r0
    1298:	11 24       	eor	r1, r1
    129a:	8f 93       	push	r24
	// Master must now disable the compare match interrupt
	// to prevent more USI counter clocks.
	TIMSK0 &= ~(1<<OCIE0A);
    129c:	80 91 6e 00 	lds	r24, 0x006E
    12a0:	8d 7f       	andi	r24, 0xFD	; 253
    12a2:	80 93 6e 00 	sts	0x006E, r24
	
	// Update flags and clear USI counter
	USISR = (1<<USIOIF);
    12a6:	80 e4       	ldi	r24, 0x40	; 64
    12a8:	80 93 b9 00 	sts	0x00B9, r24
	TransferComplete = 1;
    12ac:	81 e0       	ldi	r24, 0x01	; 1
    12ae:	80 93 63 02 	sts	0x0263, r24

	// Copy USIDR to buffer to prevent overwrite on next transfer.
	storedUSIDR = USIDR;
    12b2:	80 91 ba 00 	lds	r24, 0x00BA
    12b6:	80 93 64 02 	sts	0x0264, r24
    12ba:	8f 91       	pop	r24
    12bc:	0f 90       	pop	r0
    12be:	0f be       	out	0x3f, r0	; 63
    12c0:	0f 90       	pop	r0
    12c2:	1f 90       	pop	r1
    12c4:	18 95       	reti

000012c6 <USI_SPISetSpeed>:
}



/*! \brief  Initialize USI as SPI master.
 *
 *  This function sets up all pin directions and module configurations.
 *  Use this function initially or when changing from slave to master mode.
 *  Note that the stored USIDR value is cleared.
 *
 */
void USI_SPIInitMaster(const uint8_t Freq)
{
	// Configure port directions.
 	USI_DIR_REG |= (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN);  // Outputs.
	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN);                       // Inputs.
	USI_OUT_REG |= (1<<USI_DATAIN_PIN);                        // Pull-ups.
	USI_OUT_REG &= ~(1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN); // Pull-ups.
	
	// Configure USI to 3-wire master mode with overflow interrupt.
	USICR = USI_CONTROL_REG_FLAGS;

	// Set the compare and prescaler for the requested frequency:
	USI_SPISetSpeed(Freq);
	
	// Init driver status register.
	TransferComplete = 0;
	
	storedUSIDR = 0;
}

void USI_SPIOff(void)
{
	USI_DIR_REG &= ~((1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN));                        // Inputs.
	USI_OUT_REG &= ~((1<<USI_DATAIN_PIN)  | (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN)); // Pull-ups.
	DDRF  &= ~(1 << 6);
	PORTF &= ~(1 << 6);
	
	USI_STOPUSITIMER();
}

/*! \brief  Put one byte on bus.
 *
 *  Use this function like you would write to the SPDR register in the native SPI module.
 *  Calling this function in master mode starts a transfer, while in slave mode, a
 *  byte will be prepared for the next transfer initiated by the master device.
 *  If a transfer is in progress, this function will set the write collision flag
 *  and return without altering the data registers.
 *
 *  \returns  Value returned by slave.
 */
uint8_t USI_SPITransmit(uint8_t val)
{
	// Reinit flags.
	TransferComplete = 0;

	// Put data in USI data register.
	USIDR = val;
	
	TIFR0  |= (1<<OCF0A);  // Clear compare match flag.
	TIMSK0 |= (1<<OCIE0A); // Enable compare match interrupt.

	// Clear the timer 0 value
	TCNT0 = 0;

	while (!(TransferComplete));

	return storedUSIDR;
}

uint8_t USI_SPITransmitWord(const uint16_t val )
{
	USI_SPITransmit((uint8_t)(val >> 8));
	return USI_SPITransmit((uint8_t)val);
}

void USI_SPIToggleClock(void)
{
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);	
}

void USI_SPISetSpeed(const uint8_t Freq)
{
    12c6:	48 2f       	mov	r20, r24
	for (uint8_t MatchIndex = 0; MatchIndex < USI_PRESET_SPEEDS; MatchIndex++)
    12c8:	90 e0       	ldi	r25, 0x00	; 0
    12ca:	69 e7       	ldi	r22, 0x79	; 121
    12cc:	73 e0       	ldi	r23, 0x03	; 3
    12ce:	9b 01       	movw	r18, r22
    12d0:	21 50       	subi	r18, 0x01	; 1
    12d2:	30 40       	sbci	r19, 0x00	; 0
	{
		if ((pgm_read_byte(&USIPSValues[MatchIndex][0]) == Freq) || (MatchIndex == (USI_PRESET_SPEEDS - 1)))
    12d4:	f9 01       	movw	r30, r18
    12d6:	84 91       	lpm	r24, Z
    12d8:	84 17       	cp	r24, r20
    12da:	11 f0       	breq	.+4      	; 0x12e0 <USI_SPISetSpeed+0x1a>
    12dc:	93 30       	cpi	r25, 0x03	; 3
    12de:	31 f4       	brne	.+12     	; 0x12ec <USI_SPISetSpeed+0x26>
		{
			// Init Output Compare Register.
			OCR0A = pgm_read_byte(&USIPSValues[MatchIndex][1]);
    12e0:	fb 01       	movw	r30, r22
    12e2:	84 91       	lpm	r24, Z
    12e4:	87 bd       	out	0x27, r24	; 39

			// Enable 'Clear Timer on Compare match' and set prescaler, which starts the timer
			TCCR0A = ((1<<WGM01) | TC0_PS_1);
    12e6:	89 e0       	ldi	r24, 0x09	; 9
    12e8:	84 bd       	out	0x24, r24	; 36
				
			return;
    12ea:	08 95       	ret
    12ec:	9f 5f       	subi	r25, 0xFF	; 255
    12ee:	2e 5f       	subi	r18, 0xFE	; 254
    12f0:	3f 4f       	sbci	r19, 0xFF	; 255
    12f2:	6e 5f       	subi	r22, 0xFE	; 254
    12f4:	7f 4f       	sbci	r23, 0xFF	; 255
    12f6:	94 30       	cpi	r25, 0x04	; 4
    12f8:	68 f3       	brcs	.-38     	; 0x12d4 <USI_SPISetSpeed+0xe>
    12fa:	08 95       	ret

000012fc <USI_SPIInitMaster>:
    12fc:	9d b1       	in	r25, 0x0d	; 13
    12fe:	90 65       	ori	r25, 0x50	; 80
    1300:	9d b9       	out	0x0d, r25	; 13
    1302:	6d 98       	cbi	0x0d, 5	; 13
    1304:	75 9a       	sbi	0x0e, 5	; 14
    1306:	76 98       	cbi	0x0e, 6	; 14
    1308:	9a e5       	ldi	r25, 0x5A	; 90
    130a:	90 93 b8 00 	sts	0x00B8, r25
    130e:	0e 94 63 09 	call	0x12c6 <USI_SPISetSpeed>
    1312:	10 92 63 02 	sts	0x0263, r1
    1316:	10 92 64 02 	sts	0x0264, r1
    131a:	08 95       	ret

0000131c <USI_SPIOff>:
    131c:	8d b1       	in	r24, 0x0d	; 13
    131e:	8f 7a       	andi	r24, 0xAF	; 175
    1320:	8d b9       	out	0x0d, r24	; 13
    1322:	8e b1       	in	r24, 0x0e	; 14
    1324:	8f 78       	andi	r24, 0x8F	; 143
    1326:	8e b9       	out	0x0e, r24	; 14
    1328:	86 98       	cbi	0x10, 6	; 16
    132a:	8e 98       	cbi	0x11, 6	; 17
    132c:	14 bc       	out	0x24, r1	; 36
    132e:	08 95       	ret

00001330 <USI_SPITransmit>:
    1330:	10 92 63 02 	sts	0x0263, r1
    1334:	80 93 ba 00 	sts	0x00BA, r24
    1338:	a9 9a       	sbi	0x15, 1	; 21
    133a:	80 91 6e 00 	lds	r24, 0x006E
    133e:	82 60       	ori	r24, 0x02	; 2
    1340:	80 93 6e 00 	sts	0x006E, r24
    1344:	16 bc       	out	0x26, r1	; 38
    1346:	80 91 63 02 	lds	r24, 0x0263
    134a:	88 23       	and	r24, r24
    134c:	e1 f3       	breq	.-8      	; 0x1346 <USI_SPITransmit+0x16>
    134e:	80 91 64 02 	lds	r24, 0x0264
    1352:	99 27       	eor	r25, r25
    1354:	08 95       	ret

00001356 <USI_SPITransmitWord>:
    1356:	0f 93       	push	r16
    1358:	1f 93       	push	r17
    135a:	8c 01       	movw	r16, r24
    135c:	81 2f       	mov	r24, r17
    135e:	99 27       	eor	r25, r25
    1360:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    1364:	80 2f       	mov	r24, r16
    1366:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    136a:	99 27       	eor	r25, r25
    136c:	1f 91       	pop	r17
    136e:	0f 91       	pop	r16
    1370:	08 95       	ret

00001372 <USI_SPIToggleClock>:
    1372:	81 e0       	ldi	r24, 0x01	; 1
    1374:	0e 94 04 03 	call	0x608 <MAIN_Delay1MS>
    1378:	80 91 b8 00 	lds	r24, 0x00B8
    137c:	81 60       	ori	r24, 0x01	; 1
    137e:	80 93 b8 00 	sts	0x00B8, r24
    1382:	81 e0       	ldi	r24, 0x01	; 1
    1384:	0e 94 04 03 	call	0x608 <MAIN_Delay1MS>
    1388:	80 91 b8 00 	lds	r24, 0x00B8
    138c:	81 60       	ori	r24, 0x01	; 1
    138e:	80 93 b8 00 	sts	0x00B8, r24
    1392:	81 e0       	ldi	r24, 0x01	; 1
    1394:	0e 94 04 03 	call	0x608 <MAIN_Delay1MS>
    1398:	08 95       	ret

0000139a <DF_EnableDataflash>:
	DF_WaitWhileBusy();
}

void DF_EnableDataflash(const uint8_t Enabled)
{
    139a:	90 91 65 02 	lds	r25, 0x0265
	if (Enabled == TRUE)
    139e:	81 30       	cpi	r24, 0x01	; 1
    13a0:	31 f4       	brne	.+12     	; 0x13ae <DF_EnableDataflash+0x14>
	{
		if (UseExernalDF == TRUE)
    13a2:	91 30       	cpi	r25, 0x01	; 1
    13a4:	11 f4       	brne	.+4      	; 0x13aa <DF_EnableDataflash+0x10>
		  MAIN_ResetCSLine(MAIN_RESETCS_EXTDFACTIVE);
    13a6:	82 e0       	ldi	r24, 0x02	; 2
    13a8:	05 c0       	rjmp	.+10     	; 0x13b4 <DF_EnableDataflash+0x1a>
		else
		  PORTB &= ~(1 << 0);
    13aa:	28 98       	cbi	0x05, 0	; 5
    13ac:	08 95       	ret
	}
	else
	{
		if (UseExernalDF == TRUE)
    13ae:	91 30       	cpi	r25, 0x01	; 1
    13b0:	21 f4       	brne	.+8      	; 0x13ba <DF_EnableDataflash+0x20>
		  MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);
    13b2:	89 2f       	mov	r24, r25
    13b4:	0e 94 16 03 	call	0x62c <MAIN_ResetCSLine>
    13b8:	08 95       	ret
		else
		  PORTB |= (1 << 0);
    13ba:	28 9a       	sbi	0x05, 0	; 5
    13bc:	08 95       	ret

000013be <DF_ReadBufferByte>:
    13be:	ef 92       	push	r14
    13c0:	ff 92       	push	r15
    13c2:	0f 93       	push	r16
    13c4:	1f 93       	push	r17
    13c6:	7c 01       	movw	r14, r24
    13c8:	00 91 00 01 	lds	r16, 0x0100
    13cc:	10 91 01 01 	lds	r17, 0x0101
    13d0:	80 e0       	ldi	r24, 0x00	; 0
    13d2:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    13d6:	81 e0       	ldi	r24, 0x01	; 1
    13d8:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    13dc:	84 e5       	ldi	r24, 0x54	; 84
    13de:	f8 01       	movw	r30, r16
    13e0:	09 95       	icall
    13e2:	8f 2d       	mov	r24, r15
    13e4:	99 27       	eor	r25, r25
    13e6:	f8 01       	movw	r30, r16
    13e8:	09 95       	icall
    13ea:	8e 2d       	mov	r24, r14
    13ec:	f8 01       	movw	r30, r16
    13ee:	09 95       	icall
    13f0:	80 e0       	ldi	r24, 0x00	; 0
    13f2:	f8 01       	movw	r30, r16
    13f4:	09 95       	icall
    13f6:	80 e0       	ldi	r24, 0x00	; 0
    13f8:	f8 01       	movw	r30, r16
    13fa:	09 95       	icall
    13fc:	99 27       	eor	r25, r25
    13fe:	1f 91       	pop	r17
    1400:	0f 91       	pop	r16
    1402:	ff 90       	pop	r15
    1404:	ef 90       	pop	r14
    1406:	08 95       	ret

00001408 <DF_ContinuousReadEnable>:
    1408:	ef 92       	push	r14
    140a:	ff 92       	push	r15
    140c:	0f 93       	push	r16
    140e:	1f 93       	push	r17
    1410:	cf 93       	push	r28
    1412:	df 93       	push	r29
    1414:	8c 01       	movw	r16, r24
    1416:	7b 01       	movw	r14, r22
    1418:	c0 91 00 01 	lds	r28, 0x0100
    141c:	d0 91 01 01 	lds	r29, 0x0101
    1420:	80 e0       	ldi	r24, 0x00	; 0
    1422:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    1426:	81 e0       	ldi	r24, 0x01	; 1
    1428:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    142c:	88 e6       	ldi	r24, 0x68	; 104
    142e:	fe 01       	movw	r30, r28
    1430:	09 95       	icall
    1432:	8a b5       	in	r24, 0x2a	; 42
    1434:	98 01       	movw	r18, r16
    1436:	02 c0       	rjmp	.+4      	; 0x143c <DF_ContinuousReadEnable+0x34>
    1438:	36 95       	lsr	r19
    143a:	27 95       	ror	r18
    143c:	8a 95       	dec	r24
    143e:	e2 f7       	brpl	.-8      	; 0x1438 <DF_ContinuousReadEnable+0x30>
    1440:	c9 01       	movw	r24, r18
    1442:	fe 01       	movw	r30, r28
    1444:	09 95       	icall
    1446:	8b b5       	in	r24, 0x2b	; 43
    1448:	98 01       	movw	r18, r16
    144a:	02 c0       	rjmp	.+4      	; 0x1450 <DF_ContinuousReadEnable+0x48>
    144c:	22 0f       	add	r18, r18
    144e:	33 1f       	adc	r19, r19
    1450:	8a 95       	dec	r24
    1452:	e2 f7       	brpl	.-8      	; 0x144c <DF_ContinuousReadEnable+0x44>
    1454:	8f 2d       	mov	r24, r15
    1456:	99 27       	eor	r25, r25
    1458:	82 0f       	add	r24, r18
    145a:	fe 01       	movw	r30, r28
    145c:	09 95       	icall
    145e:	8e 2d       	mov	r24, r14
    1460:	fe 01       	movw	r30, r28
    1462:	09 95       	icall
    1464:	03 e0       	ldi	r16, 0x03	; 3
    1466:	80 e0       	ldi	r24, 0x00	; 0
    1468:	fe 01       	movw	r30, r28
    146a:	09 95       	icall
    146c:	01 50       	subi	r16, 0x01	; 1
    146e:	07 ff       	sbrs	r16, 7
    1470:	fa cf       	rjmp	.-12     	; 0x1466 <DF_ContinuousReadEnable+0x5e>
    1472:	df 91       	pop	r29
    1474:	cf 91       	pop	r28
    1476:	1f 91       	pop	r17
    1478:	0f 91       	pop	r16
    147a:	ff 90       	pop	r15
    147c:	ef 90       	pop	r14
    147e:	08 95       	ret

00001480 <DF_BufferWriteEnable>:
    1480:	ef 92       	push	r14
    1482:	ff 92       	push	r15
    1484:	0f 93       	push	r16
    1486:	1f 93       	push	r17
    1488:	7c 01       	movw	r14, r24
    148a:	00 91 00 01 	lds	r16, 0x0100
    148e:	10 91 01 01 	lds	r17, 0x0101
    1492:	80 e0       	ldi	r24, 0x00	; 0
    1494:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    1498:	81 e0       	ldi	r24, 0x01	; 1
    149a:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    149e:	84 e8       	ldi	r24, 0x84	; 132
    14a0:	f8 01       	movw	r30, r16
    14a2:	09 95       	icall
    14a4:	80 e0       	ldi	r24, 0x00	; 0
    14a6:	f8 01       	movw	r30, r16
    14a8:	09 95       	icall
    14aa:	8f 2d       	mov	r24, r15
    14ac:	99 27       	eor	r25, r25
    14ae:	f8 01       	movw	r30, r16
    14b0:	09 95       	icall
    14b2:	8e 2d       	mov	r24, r14
    14b4:	f8 01       	movw	r30, r16
    14b6:	09 95       	icall
    14b8:	1f 91       	pop	r17
    14ba:	0f 91       	pop	r16
    14bc:	ff 90       	pop	r15
    14be:	ef 90       	pop	r14
    14c0:	08 95       	ret

000014c2 <DF_WaitWhileBusy>:
    14c2:	cf 93       	push	r28
    14c4:	df 93       	push	r29
    14c6:	c0 91 00 01 	lds	r28, 0x0100
    14ca:	d0 91 01 01 	lds	r29, 0x0101
    14ce:	80 e0       	ldi	r24, 0x00	; 0
    14d0:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    14d4:	81 e0       	ldi	r24, 0x01	; 1
    14d6:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    14da:	87 e5       	ldi	r24, 0x57	; 87
    14dc:	fe 01       	movw	r30, r28
    14de:	09 95       	icall
    14e0:	80 e0       	ldi	r24, 0x00	; 0
    14e2:	fe 01       	movw	r30, r28
    14e4:	09 95       	icall
    14e6:	88 23       	and	r24, r24
    14e8:	dc f7       	brge	.-10     	; 0x14e0 <DF_WaitWhileBusy+0x1e>
    14ea:	df 91       	pop	r29
    14ec:	cf 91       	pop	r28
    14ee:	08 95       	ret

000014f0 <DF_EraseBlock>:
    14f0:	ef 92       	push	r14
    14f2:	ff 92       	push	r15
    14f4:	0f 93       	push	r16
    14f6:	1f 93       	push	r17
    14f8:	7c 01       	movw	r14, r24
    14fa:	00 91 00 01 	lds	r16, 0x0100
    14fe:	10 91 01 01 	lds	r17, 0x0101
    1502:	80 e0       	ldi	r24, 0x00	; 0
    1504:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    1508:	81 e0       	ldi	r24, 0x01	; 1
    150a:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    150e:	80 e5       	ldi	r24, 0x50	; 80
    1510:	f8 01       	movw	r30, r16
    1512:	09 95       	icall
    1514:	8f 2d       	mov	r24, r15
    1516:	99 27       	eor	r25, r25
    1518:	f8 01       	movw	r30, r16
    151a:	09 95       	icall
    151c:	8e 2d       	mov	r24, r14
    151e:	f8 01       	movw	r30, r16
    1520:	09 95       	icall
    1522:	80 e0       	ldi	r24, 0x00	; 0
    1524:	f8 01       	movw	r30, r16
    1526:	09 95       	icall
    1528:	0e 94 61 0a 	call	0x14c2 <DF_WaitWhileBusy>
    152c:	1f 91       	pop	r17
    152e:	0f 91       	pop	r16
    1530:	ff 90       	pop	r15
    1532:	ef 90       	pop	r14
    1534:	08 95       	ret

00001536 <DF_CopyFlashPageToBuffer>:
    1536:	ef 92       	push	r14
    1538:	ff 92       	push	r15
    153a:	0f 93       	push	r16
    153c:	1f 93       	push	r17
    153e:	7c 01       	movw	r14, r24
    1540:	00 91 00 01 	lds	r16, 0x0100
    1544:	10 91 01 01 	lds	r17, 0x0101
    1548:	80 e0       	ldi	r24, 0x00	; 0
    154a:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    154e:	81 e0       	ldi	r24, 0x01	; 1
    1550:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    1554:	83 e5       	ldi	r24, 0x53	; 83
    1556:	f8 01       	movw	r30, r16
    1558:	09 95       	icall
    155a:	8a b5       	in	r24, 0x2a	; 42
    155c:	97 01       	movw	r18, r14
    155e:	02 c0       	rjmp	.+4      	; 0x1564 <DF_CopyFlashPageToBuffer+0x2e>
    1560:	36 95       	lsr	r19
    1562:	27 95       	ror	r18
    1564:	8a 95       	dec	r24
    1566:	e2 f7       	brpl	.-8      	; 0x1560 <DF_CopyFlashPageToBuffer+0x2a>
    1568:	c9 01       	movw	r24, r18
    156a:	f8 01       	movw	r30, r16
    156c:	09 95       	icall
    156e:	8b b5       	in	r24, 0x2b	; 43
    1570:	02 c0       	rjmp	.+4      	; 0x1576 <DF_CopyFlashPageToBuffer+0x40>
    1572:	ee 0c       	add	r14, r14
    1574:	ff 1c       	adc	r15, r15
    1576:	8a 95       	dec	r24
    1578:	e2 f7       	brpl	.-8      	; 0x1572 <DF_CopyFlashPageToBuffer+0x3c>
    157a:	c7 01       	movw	r24, r14
    157c:	f8 01       	movw	r30, r16
    157e:	09 95       	icall
    1580:	80 e0       	ldi	r24, 0x00	; 0
    1582:	f8 01       	movw	r30, r16
    1584:	09 95       	icall
    1586:	0e 94 61 0a 	call	0x14c2 <DF_WaitWhileBusy>
    158a:	1f 91       	pop	r17
    158c:	0f 91       	pop	r16
    158e:	ff 90       	pop	r15
    1590:	ef 90       	pop	r14
    1592:	08 95       	ret

00001594 <DF_CopyBufferToFlashPage>:
    1594:	ef 92       	push	r14
    1596:	ff 92       	push	r15
    1598:	0f 93       	push	r16
    159a:	1f 93       	push	r17
    159c:	7c 01       	movw	r14, r24
    159e:	00 91 00 01 	lds	r16, 0x0100
    15a2:	10 91 01 01 	lds	r17, 0x0101
    15a6:	80 e0       	ldi	r24, 0x00	; 0
    15a8:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    15ac:	81 e0       	ldi	r24, 0x01	; 1
    15ae:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    15b2:	83 e8       	ldi	r24, 0x83	; 131
    15b4:	f8 01       	movw	r30, r16
    15b6:	09 95       	icall
    15b8:	8a b5       	in	r24, 0x2a	; 42
    15ba:	97 01       	movw	r18, r14
    15bc:	02 c0       	rjmp	.+4      	; 0x15c2 <DF_CopyBufferToFlashPage+0x2e>
    15be:	36 95       	lsr	r19
    15c0:	27 95       	ror	r18
    15c2:	8a 95       	dec	r24
    15c4:	e2 f7       	brpl	.-8      	; 0x15be <DF_CopyBufferToFlashPage+0x2a>
    15c6:	c9 01       	movw	r24, r18
    15c8:	f8 01       	movw	r30, r16
    15ca:	09 95       	icall
    15cc:	8b b5       	in	r24, 0x2b	; 43
    15ce:	02 c0       	rjmp	.+4      	; 0x15d4 <DF_CopyBufferToFlashPage+0x40>
    15d0:	ee 0c       	add	r14, r14
    15d2:	ff 1c       	adc	r15, r15
    15d4:	8a 95       	dec	r24
    15d6:	e2 f7       	brpl	.-8      	; 0x15d0 <DF_CopyBufferToFlashPage+0x3c>
    15d8:	c7 01       	movw	r24, r14
    15da:	f8 01       	movw	r30, r16
    15dc:	09 95       	icall
    15de:	80 e0       	ldi	r24, 0x00	; 0
    15e0:	f8 01       	movw	r30, r16
    15e2:	09 95       	icall
    15e4:	0e 94 61 0a 	call	0x14c2 <DF_WaitWhileBusy>
    15e8:	1f 91       	pop	r17
    15ea:	0f 91       	pop	r16
    15ec:	ff 90       	pop	r15
    15ee:	ef 90       	pop	r14
    15f0:	08 95       	ret

000015f2 <DF_GetChipCharacteristics>:
    15f2:	0f 93       	push	r16
    15f4:	1f 93       	push	r17
    15f6:	00 91 00 01 	lds	r16, 0x0100
    15fa:	10 91 01 01 	lds	r17, 0x0101
    15fe:	80 e0       	ldi	r24, 0x00	; 0
    1600:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    1604:	81 e0       	ldi	r24, 0x01	; 1
    1606:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    160a:	87 e5       	ldi	r24, 0x57	; 87
    160c:	f8 01       	movw	r30, r16
    160e:	09 95       	icall
    1610:	80 e0       	ldi	r24, 0x00	; 0
    1612:	f8 01       	movw	r30, r16
    1614:	09 95       	icall
    1616:	99 27       	eor	r25, r25
    1618:	88 73       	andi	r24, 0x38	; 56
    161a:	90 70       	andi	r25, 0x00	; 0
    161c:	43 e0       	ldi	r20, 0x03	; 3
    161e:	95 95       	asr	r25
    1620:	87 95       	ror	r24
    1622:	4a 95       	dec	r20
    1624:	e1 f7       	brne	.-8      	; 0x161e <DF_GetChipCharacteristics+0x2c>
    1626:	99 27       	eor	r25, r25
    1628:	fc 01       	movw	r30, r24
    162a:	e0 55       	subi	r30, 0x50	; 80
    162c:	fc 4f       	sbci	r31, 0xFC	; 252
    162e:	44 91       	lpm	r20, Z
    1630:	40 93 68 02 	sts	0x0268, r20
    1634:	9c 01       	movw	r18, r24
    1636:	28 0f       	add	r18, r24
    1638:	39 1f       	adc	r19, r25
    163a:	f9 01       	movw	r30, r18
    163c:	e0 56       	subi	r30, 0x60	; 96
    163e:	fc 4f       	sbci	r31, 0xFC	; 252
    1640:	85 91       	lpm	r24, Z+
    1642:	94 91       	lpm	r25, Z
    1644:	90 93 6a 02 	sts	0x026A, r25
    1648:	80 93 69 02 	sts	0x0269, r24
    164c:	f9 01       	movw	r30, r18
    164e:	e0 57       	subi	r30, 0x70	; 112
    1650:	fc 4f       	sbci	r31, 0xFC	; 252
    1652:	85 91       	lpm	r24, Z+
    1654:	94 91       	lpm	r25, Z
    1656:	90 93 6c 02 	sts	0x026C, r25
    165a:	80 93 6b 02 	sts	0x026B, r24
    165e:	80 e1       	ldi	r24, 0x10	; 16
    1660:	84 1b       	sub	r24, r20
    1662:	8a bd       	out	0x2a, r24	; 42
    1664:	48 50       	subi	r20, 0x08	; 8
    1666:	4b bd       	out	0x2b, r20	; 43
    1668:	1f 91       	pop	r17
    166a:	0f 91       	pop	r16
    166c:	08 95       	ret

0000166e <DF_CheckCorrectOnboardChip>:
    166e:	0e 94 f9 0a 	call	0x15f2 <DF_GetChipCharacteristics>
    1672:	80 91 6b 02 	lds	r24, 0x026B
    1676:	90 91 6c 02 	lds	r25, 0x026C
    167a:	80 50       	subi	r24, 0x00	; 0
    167c:	98 40       	sbci	r25, 0x08	; 8
    167e:	61 f0       	breq	.+24     	; 0x1698 <DF_CheckCorrectOnboardChip+0x2a>
    1680:	80 91 64 00 	lds	r24, 0x0064
    1684:	84 60       	ori	r24, 0x04	; 4
    1686:	80 93 64 00 	sts	0x0064, r24
    168a:	80 e8       	ldi	r24, 0x80	; 128
    168c:	93 e0       	ldi	r25, 0x03	; 3
    168e:	0e 94 6b 03 	call	0x6d6 <MAIN_ShowError>
    1692:	80 e0       	ldi	r24, 0x00	; 0
    1694:	90 e0       	ldi	r25, 0x00	; 0
    1696:	08 95       	ret
    1698:	81 e0       	ldi	r24, 0x01	; 1
    169a:	90 e0       	ldi	r25, 0x00	; 0
    169c:	08 95       	ret

0000169e <__vector_13>:

// ======================================================================================

ISR(USART0_RX_vect, ISR_BLOCK)
{
    169e:	1f 92       	push	r1
    16a0:	0f 92       	push	r0
    16a2:	0f b6       	in	r0, 0x3f	; 63
    16a4:	0f 92       	push	r0
    16a6:	11 24       	eor	r1, r1
    16a8:	2f 93       	push	r18
    16aa:	3f 93       	push	r19
    16ac:	4f 93       	push	r20
    16ae:	5f 93       	push	r21
    16b0:	6f 93       	push	r22
    16b2:	7f 93       	push	r23
    16b4:	8f 93       	push	r24
    16b6:	9f 93       	push	r25
    16b8:	af 93       	push	r26
    16ba:	bf 93       	push	r27
    16bc:	ef 93       	push	r30
    16be:	ff 93       	push	r31
	if (BuffElements == BUFF_BUFFLEN)     // Buffer full
    16c0:	80 91 b3 02 	lds	r24, 0x02B3
    16c4:	80 34       	cpi	r24, 0x40	; 64
    16c6:	29 f4       	brne	.+10     	; 0x16d2 <__vector_13+0x34>
	{
		MAIN_ShowError(PSTR("BUFF OVERFLOW"));
    16c8:	88 eb       	ldi	r24, 0xB8	; 184
    16ca:	93 e0       	ldi	r25, 0x03	; 3
    16cc:	0e 94 6b 03 	call	0x6d6 <MAIN_ShowError>
		return;
    16d0:	20 c0       	rjmp	.+64     	; 0x1712 <__vector_13+0x74>
	}
		
	*StoreLoc = UDR;                      // Store the data
    16d2:	e0 91 af 02 	lds	r30, 0x02AF
    16d6:	f0 91 b0 02 	lds	r31, 0x02B0
    16da:	80 91 c6 00 	lds	r24, 0x00C6
    16de:	80 83       	st	Z, r24

	StoreLoc++;                           // Increment the IN pointer to the next element
    16e0:	40 91 af 02 	lds	r20, 0x02AF
    16e4:	50 91 b0 02 	lds	r21, 0x02B0
    16e8:	9a 01       	movw	r18, r20
    16ea:	2f 5f       	subi	r18, 0xFF	; 255
    16ec:	3f 4f       	sbci	r19, 0xFF	; 255
    16ee:	30 93 b0 02 	sts	0x02B0, r19
    16f2:	20 93 af 02 	sts	0x02AF, r18
	BuffElements++;                       // Increment the total elements variable
    16f6:	80 91 b3 02 	lds	r24, 0x02B3
    16fa:	8f 5f       	subi	r24, 0xFF	; 255
    16fc:	80 93 b3 02 	sts	0x02B3, r24

	if (StoreLoc == (BuffType*)&RingBuffer[BUFF_BUFFLEN])
    1700:	2f 5a       	subi	r18, 0xAF	; 175
    1702:	32 40       	sbci	r19, 0x02	; 2
    1704:	31 f4       	brne	.+12     	; 0x1712 <__vector_13+0x74>
		StoreLoc = (BuffType*)&RingBuffer[0]; // Wrap pointer if end of array reached
    1706:	4f 53       	subi	r20, 0x3F	; 63
    1708:	50 40       	sbci	r21, 0x00	; 0
    170a:	50 93 b0 02 	sts	0x02B0, r21
    170e:	40 93 af 02 	sts	0x02AF, r20
    1712:	ff 91       	pop	r31
    1714:	ef 91       	pop	r30
    1716:	bf 91       	pop	r27
    1718:	af 91       	pop	r26
    171a:	9f 91       	pop	r25
    171c:	8f 91       	pop	r24
    171e:	7f 91       	pop	r23
    1720:	6f 91       	pop	r22
    1722:	5f 91       	pop	r21
    1724:	4f 91       	pop	r20
    1726:	3f 91       	pop	r19
    1728:	2f 91       	pop	r18
    172a:	0f 90       	pop	r0
    172c:	0f be       	out	0x3f, r0	; 63
    172e:	0f 90       	pop	r0
    1730:	1f 90       	pop	r1
    1732:	18 95       	reti

00001734 <BUFF_InitialiseBuffer>:
}	

// ======================================================================================

void BUFF_InitialiseBuffer(void)
{
	StoreLoc    = (BuffType*)&RingBuffer[0]; // Set up the IN pointer to the start of the buffer
    1734:	8f e6       	ldi	r24, 0x6F	; 111
    1736:	92 e0       	ldi	r25, 0x02	; 2
    1738:	90 93 b0 02 	sts	0x02B0, r25
    173c:	80 93 af 02 	sts	0x02AF, r24
	RetrieveLoc = (BuffType*)&RingBuffer[0]; // Set up the OUT pointer to the start of the buffer
    1740:	90 93 b2 02 	sts	0x02B2, r25
    1744:	80 93 b1 02 	sts	0x02B1, r24

	BuffElements = 0;                     // Reset the buffer elements counter
    1748:	10 92 b3 02 	sts	0x02B3, r1
    174c:	08 95       	ret

0000174e <BUFF_GetBuffByte>:
}

BuffType BUFF_GetBuffByte(void)
{
	if (!(BuffElements))                  // No elements in the buffer
    174e:	80 91 b3 02 	lds	r24, 0x02B3
    1752:	88 23       	and	r24, r24
    1754:	19 f4       	brne	.+6      	; 0x175c <BUFF_GetBuffByte+0xe>
		return 0;
    1756:	80 e0       	ldi	r24, 0x00	; 0
    1758:	90 e0       	ldi	r25, 0x00	; 0
    175a:	08 95       	ret

	BuffType RetrievedData = *RetrieveLoc; // Grab the stored byte into a temp variable
    175c:	20 91 b1 02 	lds	r18, 0x02B1
    1760:	30 91 b2 02 	lds	r19, 0x02B2
    1764:	f9 01       	movw	r30, r18
    1766:	91 91       	ld	r25, Z+

	RetrieveLoc++;                         // Increment the OUT pointer to the next element if flag set
    1768:	f0 93 b2 02 	sts	0x02B2, r31
    176c:	e0 93 b1 02 	sts	0x02B1, r30
	BuffElements--;                        // Decrement the total elements variable
    1770:	80 91 b3 02 	lds	r24, 0x02B3
    1774:	81 50       	subi	r24, 0x01	; 1
    1776:	80 93 b3 02 	sts	0x02B3, r24
	
	if (RetrieveLoc == (BuffType*)&RingBuffer[BUFF_BUFFLEN])
    177a:	ef 5a       	subi	r30, 0xAF	; 175
    177c:	f2 40       	sbci	r31, 0x02	; 2
    177e:	31 f4       	brne	.+12     	; 0x178c <BUFF_GetBuffByte+0x3e>
		RetrieveLoc = (BuffType*)&RingBuffer[0]; // Wrap pointer if end of array reached
    1780:	2f 53       	subi	r18, 0x3F	; 63
    1782:	30 40       	sbci	r19, 0x00	; 0
    1784:	30 93 b2 02 	sts	0x02B2, r19
    1788:	20 93 b1 02 	sts	0x02B1, r18
		
	return RetrievedData;                 // Return the retrieved data
    178c:	89 2f       	mov	r24, r25
    178e:	99 27       	eor	r25, r25
}
    1790:	08 95       	ret

00001792 <__vector_4>:
// ======================================================================================

// Packet Timeout = ((F_CPU / 1024) / (240 * TIMEOUT_TICKSBEFORETIMEOUT)) per second
ISR(TIMER2_COMP_vect, ISR_NOBLOCK)
{
    1792:	78 94       	sei
    1794:	1f 92       	push	r1
    1796:	0f 92       	push	r0
    1798:	0f b6       	in	r0, 0x3f	; 63
    179a:	0f 92       	push	r0
    179c:	11 24       	eor	r1, r1
    179e:	8f 93       	push	r24
	if (PacketTimeOutTicks++ == TIMEOUT_PACKET_TIMEOUTTICKS)
    17a0:	80 91 40 01 	lds	r24, 0x0140
    17a4:	8f 5f       	subi	r24, 0xFF	; 255
    17a6:	80 93 40 01 	sts	0x0140, r24
    17aa:	80 91 40 01 	lds	r24, 0x0140
    17ae:	87 39       	cpi	r24, 0x97	; 151
    17b0:	29 f4       	brne	.+10     	; 0x17bc <__vector_4+0x2a>
	{
		PacketTimeOutTicks   = 0;
    17b2:	10 92 40 01 	sts	0x0140, r1
		PacketTimeOut        = TRUE;
    17b6:	81 e0       	ldi	r24, 0x01	; 1
    17b8:	80 93 3f 01 	sts	0x013F, r24
    17bc:	8f 91       	pop	r24
    17be:	0f 90       	pop	r0
    17c0:	0f be       	out	0x3f, r0	; 63
    17c2:	0f 90       	pop	r0
    17c4:	1f 90       	pop	r1
    17c6:	18 95       	reti

000017c8 <TOUT_SetupSleepTimer>:
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    17c8:	a7 e8       	ldi	r26, 0x87	; 135
    17ca:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    17cc:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
    17d0:	80 2d       	mov	r24, r0
    17d2:	28 2f       	mov	r18, r24
	}
}

// Autosleep Timeout = (TIMEOUT_TICKSBEFORETIMEOUT / 10) secs between timeouts
ISR(TIMER1_OVF_vect, ISR_NOBLOCK)
{
	if (SleepTimeOutTicks++ == TicksBeforeAutoSleep)
	{
		TIMEOUT_SLEEP_TIMER_OFF();
		FUNCSleepMode();
		TOUT_SetupSleepTimer();
	}
}

// ======================================================================================

void TOUT_SetupSleepTimer(void)
{
	uint8_t NewTicksIndex = eeprom_read_byte(&EEPROMVars.AutoSleepValIndex);

	if (NewTicksIndex == 0xFF)
    17d4:	8f 3f       	cpi	r24, 0xFF	; 255
    17d6:	09 f4       	brne	.+2      	; 0x17da <TOUT_SetupSleepTimer+0x12>
	  NewTicksIndex = 4;
    17d8:	24 e0       	ldi	r18, 0x04	; 4

	TIMSK1 = (1 << TOIE1);
    17da:	31 e0       	ldi	r19, 0x01	; 1
    17dc:	30 93 6f 00 	sts	0x006F, r19
	TicksBeforeAutoSleep = (pgm_read_byte(&AutoSleepTOValues[NewTicksIndex]) * 10);
    17e0:	e2 2f       	mov	r30, r18
    17e2:	ff 27       	eor	r31, r31
    17e4:	ea 53       	subi	r30, 0x3A	; 58
    17e6:	fc 4f       	sbci	r31, 0xFC	; 252
    17e8:	94 91       	lpm	r25, Z
    17ea:	8a e0       	ldi	r24, 0x0A	; 10
    17ec:	98 9f       	mul	r25, r24
    17ee:	c0 01       	movw	r24, r0
    17f0:	11 24       	eor	r1, r1
    17f2:	90 93 3c 01 	sts	0x013C, r25
    17f6:	80 93 3b 01 	sts	0x013B, r24

	TIMEOUT_SLEEP_TIMEOUT_RESET();
    17fa:	10 92 3e 01 	sts	0x013E, r1
    17fe:	10 92 3d 01 	sts	0x013D, r1
    1802:	10 92 85 00 	sts	0x0085, r1
    1806:	10 92 84 00 	sts	0x0084, r1
	
	if (NewTicksIndex)
    180a:	22 23       	and	r18, r18
    180c:	19 f0       	breq	.+6      	; 0x1814 <TOUT_SetupSleepTimer+0x4c>
	  TIMEOUT_SLEEP_TIMER_ON();
    180e:	30 93 81 00 	sts	0x0081, r19
    1812:	08 95       	ret
	else
	  TIMEOUT_SLEEP_TIMER_OFF();
    1814:	20 93 81 00 	sts	0x0081, r18
    1818:	08 95       	ret

0000181a <__vector_9>:
    181a:	78 94       	sei
    181c:	1f 92       	push	r1
    181e:	0f 92       	push	r0
    1820:	0f b6       	in	r0, 0x3f	; 63
    1822:	0f 92       	push	r0
    1824:	11 24       	eor	r1, r1
    1826:	2f 93       	push	r18
    1828:	3f 93       	push	r19
    182a:	4f 93       	push	r20
    182c:	5f 93       	push	r21
    182e:	6f 93       	push	r22
    1830:	7f 93       	push	r23
    1832:	8f 93       	push	r24
    1834:	9f 93       	push	r25
    1836:	af 93       	push	r26
    1838:	bf 93       	push	r27
    183a:	ef 93       	push	r30
    183c:	ff 93       	push	r31
    183e:	80 91 3d 01 	lds	r24, 0x013D
    1842:	90 91 3e 01 	lds	r25, 0x013E
    1846:	9c 01       	movw	r18, r24
    1848:	01 96       	adiw	r24, 0x01	; 1
    184a:	90 93 3e 01 	sts	0x013E, r25
    184e:	80 93 3d 01 	sts	0x013D, r24
    1852:	80 91 3b 01 	lds	r24, 0x013B
    1856:	90 91 3c 01 	lds	r25, 0x013C
    185a:	28 17       	cp	r18, r24
    185c:	39 07       	cpc	r19, r25
    185e:	31 f4       	brne	.+12     	; 0x186c <__vector_9+0x52>
    1860:	10 92 81 00 	sts	0x0081, r1
    1864:	0e 94 09 07 	call	0xe12 <FUNCSleepMode>
    1868:	0e 94 e4 0b 	call	0x17c8 <TOUT_SetupSleepTimer>
    186c:	ff 91       	pop	r31
    186e:	ef 91       	pop	r30
    1870:	bf 91       	pop	r27
    1872:	af 91       	pop	r26
    1874:	9f 91       	pop	r25
    1876:	8f 91       	pop	r24
    1878:	7f 91       	pop	r23
    187a:	6f 91       	pop	r22
    187c:	5f 91       	pop	r21
    187e:	4f 91       	pop	r20
    1880:	3f 91       	pop	r19
    1882:	2f 91       	pop	r18
    1884:	0f 90       	pop	r0
    1886:	0f be       	out	0x3f, r0	; 63
    1888:	0f 90       	pop	r0
    188a:	1f 90       	pop	r1
    188c:	18 95       	reti

0000188e <PD_SetupDFAddressCounters>:
}

void PD_SetupDFAddressCounters(void)
{
	uint32_t StartAddress = CurrAddress;
    188e:	20 91 42 01 	lds	r18, 0x0142
    1892:	30 91 43 01 	lds	r19, 0x0143
    1896:	40 91 44 01 	lds	r20, 0x0144
    189a:	50 91 45 01 	lds	r21, 0x0145

	CurrPageAddress = 0;
    189e:	10 92 6e 02 	sts	0x026E, r1
    18a2:	10 92 6d 02 	sts	0x026D, r1

	while (StartAddress > DataflashInfo.PageSize)      // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DataflashInfo.PageSize;         // Subtract one page's worth of bytes from the desired address
		CurrPageAddress++;
    18a6:	80 91 69 02 	lds	r24, 0x0269
    18aa:	90 91 6a 02 	lds	r25, 0x026A
    18ae:	aa 27       	eor	r26, r26
    18b0:	bb 27       	eor	r27, r27
    18b2:	82 17       	cp	r24, r18
    18b4:	93 07       	cpc	r25, r19
    18b6:	a4 07       	cpc	r26, r20
    18b8:	b5 07       	cpc	r27, r21
    18ba:	88 f4       	brcc	.+34     	; 0x18de <PD_SetupDFAddressCounters+0x50>
    18bc:	60 e0       	ldi	r22, 0x00	; 0
    18be:	70 e0       	ldi	r23, 0x00	; 0
    18c0:	28 1b       	sub	r18, r24
    18c2:	39 0b       	sbc	r19, r25
    18c4:	4a 0b       	sbc	r20, r26
    18c6:	5b 0b       	sbc	r21, r27
    18c8:	6f 5f       	subi	r22, 0xFF	; 255
    18ca:	7f 4f       	sbci	r23, 0xFF	; 255
    18cc:	82 17       	cp	r24, r18
    18ce:	93 07       	cpc	r25, r19
    18d0:	a4 07       	cpc	r26, r20
    18d2:	b5 07       	cpc	r27, r21
    18d4:	a8 f3       	brcs	.-22     	; 0x18c0 <PD_SetupDFAddressCounters+0x32>
    18d6:	70 93 6e 02 	sts	0x026E, r23
    18da:	60 93 6d 02 	sts	0x026D, r22
	}
	
	CurrBuffByte = (uint16_t)StartAddress;              // The buffer byte is the remainder
    18de:	30 93 67 02 	sts	0x0267, r19
    18e2:	20 93 66 02 	sts	0x0266, r18
    18e6:	08 95       	ret

000018e8 <PD_StoreDataflashByte>:
}

void PD_StoreDataflashByte(const uint8_t Data)
{
    18e8:	cf 93       	push	r28
    18ea:	c8 2f       	mov	r28, r24
	if (CurrBuffByte == DataflashInfo.PageSize)
    18ec:	20 91 66 02 	lds	r18, 0x0266
    18f0:	30 91 67 02 	lds	r19, 0x0267
    18f4:	80 91 69 02 	lds	r24, 0x0269
    18f8:	90 91 6a 02 	lds	r25, 0x026A
    18fc:	28 17       	cp	r18, r24
    18fe:	39 07       	cpc	r19, r25
    1900:	a9 f4       	brne	.+42     	; 0x192c <PD_StoreDataflashByte+0x44>
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
    1902:	80 91 6d 02 	lds	r24, 0x026D
    1906:	90 91 6e 02 	lds	r25, 0x026E
    190a:	9c 01       	movw	r18, r24
    190c:	01 96       	adiw	r24, 0x01	; 1
    190e:	90 93 6e 02 	sts	0x026E, r25
    1912:	80 93 6d 02 	sts	0x026D, r24
    1916:	c9 01       	movw	r24, r18
    1918:	0e 94 ca 0a 	call	0x1594 <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    191c:	80 e0       	ldi	r24, 0x00	; 0
    191e:	90 e0       	ldi	r25, 0x00	; 0
    1920:	0e 94 40 0a 	call	0x1480 <DF_BufferWriteEnable>
		CurrBuffByte = 0;
    1924:	10 92 67 02 	sts	0x0267, r1
    1928:	10 92 66 02 	sts	0x0266, r1
	}
	
	USI_SPITransmit(Data);                                 // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    192c:	8c 2f       	mov	r24, r28
    192e:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
	CurrBuffByte++;
    1932:	80 91 66 02 	lds	r24, 0x0266
    1936:	90 91 67 02 	lds	r25, 0x0267
    193a:	01 96       	adiw	r24, 0x01	; 1
    193c:	90 93 67 02 	sts	0x0267, r25
    1940:	80 93 66 02 	sts	0x0266, r24
    1944:	cf 91       	pop	r28
    1946:	08 95       	ret

00001948 <PD_InterpretAVRISPPacket>:
    1948:	df 92       	push	r13
    194a:	ef 92       	push	r14
    194c:	ff 92       	push	r15
    194e:	0f 93       	push	r16
    1950:	1f 93       	push	r17
    1952:	cf 93       	push	r28
    1954:	df 93       	push	r29
    1956:	dd 24       	eor	r13, r13
    1958:	80 91 4b 01 	lds	r24, 0x014B
    195c:	99 27       	eor	r25, r25
    195e:	86 31       	cpi	r24, 0x16	; 22
    1960:	91 05       	cpc	r25, r1
    1962:	09 f4       	brne	.+2      	; 0x1966 <PD_InterpretAVRISPPacket+0x1e>
    1964:	00 c1       	rjmp	.+512    	; 0x1b66 <PD_InterpretAVRISPPacket+0x21e>
    1966:	87 31       	cpi	r24, 0x17	; 23
    1968:	91 05       	cpc	r25, r1
    196a:	b4 f4       	brge	.+44     	; 0x1998 <PD_InterpretAVRISPPacket+0x50>
    196c:	82 31       	cpi	r24, 0x12	; 18
    196e:	91 05       	cpc	r25, r1
    1970:	09 f4       	brne	.+2      	; 0x1974 <PD_InterpretAVRISPPacket+0x2c>
    1972:	6f c0       	rjmp	.+222    	; 0x1a52 <PD_InterpretAVRISPPacket+0x10a>
    1974:	83 31       	cpi	r24, 0x13	; 19
    1976:	91 05       	cpc	r25, r1
    1978:	3c f4       	brge	.+14     	; 0x1988 <PD_InterpretAVRISPPacket+0x40>
    197a:	80 31       	cpi	r24, 0x10	; 16
    197c:	91 05       	cpc	r25, r1
    197e:	31 f1       	breq	.+76     	; 0x19cc <PD_InterpretAVRISPPacket+0x84>
    1980:	41 97       	sbiw	r24, 0x11	; 17
    1982:	09 f4       	brne	.+2      	; 0x1986 <PD_InterpretAVRISPPacket+0x3e>
    1984:	46 c0       	rjmp	.+140    	; 0x1a12 <PD_InterpretAVRISPPacket+0xca>
    1986:	40 c1       	rjmp	.+640    	; 0x1c08 <PD_InterpretAVRISPPacket+0x2c0>
    1988:	84 31       	cpi	r24, 0x14	; 20
    198a:	91 05       	cpc	r25, r1
    198c:	09 f4       	brne	.+2      	; 0x1990 <PD_InterpretAVRISPPacket+0x48>
    198e:	8a c0       	rjmp	.+276    	; 0x1aa4 <PD_InterpretAVRISPPacket+0x15c>
    1990:	45 97       	sbiw	r24, 0x15	; 21
    1992:	0c f0       	brlt	.+2      	; 0x1996 <PD_InterpretAVRISPPacket+0x4e>
    1994:	af c0       	rjmp	.+350    	; 0x1af4 <PD_InterpretAVRISPPacket+0x1ac>
    1996:	7f c0       	rjmp	.+254    	; 0x1a96 <PD_InterpretAVRISPPacket+0x14e>
    1998:	89 31       	cpi	r24, 0x19	; 25
    199a:	91 05       	cpc	r25, r1
    199c:	09 f4       	brne	.+2      	; 0x19a0 <PD_InterpretAVRISPPacket+0x58>
    199e:	70 c0       	rjmp	.+224    	; 0x1a80 <PD_InterpretAVRISPPacket+0x138>
    19a0:	8a 31       	cpi	r24, 0x1A	; 26
    19a2:	91 05       	cpc	r25, r1
    19a4:	44 f4       	brge	.+16     	; 0x19b6 <PD_InterpretAVRISPPacket+0x6e>
    19a6:	87 31       	cpi	r24, 0x17	; 23
    19a8:	91 05       	cpc	r25, r1
    19aa:	09 f4       	brne	.+2      	; 0x19ae <PD_InterpretAVRISPPacket+0x66>
    19ac:	69 c0       	rjmp	.+210    	; 0x1a80 <PD_InterpretAVRISPPacket+0x138>
    19ae:	48 97       	sbiw	r24, 0x18	; 24
    19b0:	09 f4       	brne	.+2      	; 0x19b4 <PD_InterpretAVRISPPacket+0x6c>
    19b2:	58 c0       	rjmp	.+176    	; 0x1a64 <PD_InterpretAVRISPPacket+0x11c>
    19b4:	29 c1       	rjmp	.+594    	; 0x1c08 <PD_InterpretAVRISPPacket+0x2c0>
    19b6:	8b 31       	cpi	r24, 0x1B	; 27
    19b8:	91 05       	cpc	r25, r1
    19ba:	e9 f1       	breq	.+122    	; 0x1a36 <PD_InterpretAVRISPPacket+0xee>
    19bc:	8b 31       	cpi	r24, 0x1B	; 27
    19be:	91 05       	cpc	r25, r1
    19c0:	0c f4       	brge	.+2      	; 0x19c4 <PD_InterpretAVRISPPacket+0x7c>
    19c2:	50 c0       	rjmp	.+160    	; 0x1a64 <PD_InterpretAVRISPPacket+0x11c>
    19c4:	4c 97       	sbiw	r24, 0x1c	; 28
    19c6:	09 f4       	brne	.+2      	; 0x19ca <PD_InterpretAVRISPPacket+0x82>
    19c8:	4d c0       	rjmp	.+154    	; 0x1a64 <PD_InterpretAVRISPPacket+0x11c>
    19ca:	1e c1       	rjmp	.+572    	; 0x1c08 <PD_InterpretAVRISPPacket+0x2c0>
    19cc:	82 e0       	ldi	r24, 0x02	; 2
    19ce:	90 e0       	ldi	r25, 0x00	; 0
    19d0:	90 93 48 01 	sts	0x0148, r25
    19d4:	80 93 47 01 	sts	0x0147, r24
    19d8:	81 e0       	ldi	r24, 0x01	; 1
    19da:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    19de:	0e 94 f9 0a 	call	0x15f2 <DF_GetChipCharacteristics>
    19e2:	80 91 68 02 	lds	r24, 0x0268
    19e6:	88 23       	and	r24, r24
    19e8:	59 f0       	breq	.+22     	; 0x1a00 <PD_InterpretAVRISPPacket+0xb8>
    19ea:	8b ec       	ldi	r24, 0xCB	; 203
    19ec:	93 e0       	ldi	r25, 0x03	; 3
    19ee:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>
    19f2:	81 e0       	ldi	r24, 0x01	; 1
    19f4:	80 93 46 01 	sts	0x0146, r24
    19f8:	81 b3       	in	r24, 0x11	; 17
    19fa:	8f 7c       	andi	r24, 0xCF	; 207
    19fc:	80 62       	ori	r24, 0x20	; 32
    19fe:	17 c0       	rjmp	.+46     	; 0x1a2e <PD_InterpretAVRISPPacket+0xe6>
    1a00:	80 e8       	ldi	r24, 0x80	; 128
    1a02:	93 e0       	ldi	r25, 0x03	; 3
    1a04:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>
    1a08:	8d 2d       	mov	r24, r13
    1a0a:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    1a0e:	80 ec       	ldi	r24, 0xC0	; 192
    1a10:	02 c1       	rjmp	.+516    	; 0x1c16 <PD_InterpretAVRISPPacket+0x2ce>
    1a12:	82 e0       	ldi	r24, 0x02	; 2
    1a14:	90 e0       	ldi	r25, 0x00	; 0
    1a16:	90 93 48 01 	sts	0x0148, r25
    1a1a:	80 93 47 01 	sts	0x0147, r24
    1a1e:	d0 92 46 01 	sts	0x0146, r13
    1a22:	8d 2d       	mov	r24, r13
    1a24:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    1a28:	81 b3       	in	r24, 0x11	; 17
    1a2a:	8f 7c       	andi	r24, 0xCF	; 207
    1a2c:	80 61       	ori	r24, 0x10	; 16
    1a2e:	81 bb       	out	0x11, r24	; 17
    1a30:	d0 92 4c 01 	sts	0x014C, r13
    1a34:	f2 c0       	rjmp	.+484    	; 0x1c1a <PD_InterpretAVRISPPacket+0x2d2>
    1a36:	84 e0       	ldi	r24, 0x04	; 4
    1a38:	90 e0       	ldi	r25, 0x00	; 0
    1a3a:	90 93 48 01 	sts	0x0148, r25
    1a3e:	80 93 47 01 	sts	0x0147, r24
    1a42:	d0 92 4c 01 	sts	0x014C, r13
    1a46:	82 e0       	ldi	r24, 0x02	; 2
    1a48:	80 93 4d 01 	sts	0x014D, r24
    1a4c:	d0 92 4e 01 	sts	0x014E, r13
    1a50:	e4 c0       	rjmp	.+456    	; 0x1c1a <PD_InterpretAVRISPPacket+0x2d2>
    1a52:	82 e0       	ldi	r24, 0x02	; 2
    1a54:	90 e0       	ldi	r25, 0x00	; 0
    1a56:	90 93 48 01 	sts	0x0148, r25
    1a5a:	80 93 47 01 	sts	0x0147, r24
    1a5e:	e1 e0       	ldi	r30, 0x01	; 1
    1a60:	de 2e       	mov	r13, r30
    1a62:	7e c0       	rjmp	.+252    	; 0x1b60 <PD_InterpretAVRISPPacket+0x218>
    1a64:	84 e0       	ldi	r24, 0x04	; 4
    1a66:	90 e0       	ldi	r25, 0x00	; 0
    1a68:	90 93 48 01 	sts	0x0148, r25
    1a6c:	80 93 47 01 	sts	0x0147, r24
    1a70:	10 92 4c 01 	sts	0x014C, r1
    1a74:	8f ef       	ldi	r24, 0xFF	; 255
    1a76:	80 93 4d 01 	sts	0x014D, r24
    1a7a:	10 92 4e 01 	sts	0x014E, r1
    1a7e:	cd c0       	rjmp	.+410    	; 0x1c1a <PD_InterpretAVRISPPacket+0x2d2>
    1a80:	83 e0       	ldi	r24, 0x03	; 3
    1a82:	90 e0       	ldi	r25, 0x00	; 0
    1a84:	90 93 48 01 	sts	0x0148, r25
    1a88:	80 93 47 01 	sts	0x0147, r24
    1a8c:	10 92 4c 01 	sts	0x014C, r1
    1a90:	10 92 4d 01 	sts	0x014D, r1
    1a94:	c2 c0       	rjmp	.+388    	; 0x1c1a <PD_InterpretAVRISPPacket+0x2d2>
    1a96:	82 e0       	ldi	r24, 0x02	; 2
    1a98:	90 e0       	ldi	r25, 0x00	; 0
    1a9a:	90 93 48 01 	sts	0x0148, r25
    1a9e:	80 93 47 01 	sts	0x0147, r24
    1aa2:	5e c0       	rjmp	.+188    	; 0x1b60 <PD_InterpretAVRISPPacket+0x218>
    1aa4:	80 91 4c 01 	lds	r24, 0x014C
    1aa8:	99 27       	eor	r25, r25
    1aaa:	98 2f       	mov	r25, r24
    1aac:	88 27       	eor	r24, r24
    1aae:	20 91 4d 01 	lds	r18, 0x014D
    1ab2:	33 27       	eor	r19, r19
    1ab4:	82 2b       	or	r24, r18
    1ab6:	93 2b       	or	r25, r19
    1ab8:	03 96       	adiw	r24, 0x03	; 3
    1aba:	90 93 48 01 	sts	0x0148, r25
    1abe:	80 93 47 01 	sts	0x0147, r24
    1ac2:	21 e0       	ldi	r18, 0x01	; 1
    1ac4:	30 e0       	ldi	r19, 0x00	; 0
    1ac6:	02 97       	sbiw	r24, 0x02	; 2
    1ac8:	28 17       	cp	r18, r24
    1aca:	39 07       	cpc	r19, r25
    1acc:	48 f4       	brcc	.+18     	; 0x1ae0 <PD_InterpretAVRISPPacket+0x198>
    1ace:	4f ef       	ldi	r20, 0xFF	; 255
    1ad0:	ec e4       	ldi	r30, 0x4C	; 76
    1ad2:	f1 e0       	ldi	r31, 0x01	; 1
    1ad4:	41 93       	st	Z+, r20
    1ad6:	2f 5f       	subi	r18, 0xFF	; 255
    1ad8:	3f 4f       	sbci	r19, 0xFF	; 255
    1ada:	28 17       	cp	r18, r24
    1adc:	39 07       	cpc	r19, r25
    1ade:	d0 f3       	brcs	.-12     	; 0x1ad4 <PD_InterpretAVRISPPacket+0x18c>
    1ae0:	10 92 4c 01 	sts	0x014C, r1
    1ae4:	e0 91 47 01 	lds	r30, 0x0147
    1ae8:	f0 91 48 01 	lds	r31, 0x0148
    1aec:	e6 5b       	subi	r30, 0xB6	; 182
    1aee:	fe 4f       	sbci	r31, 0xFE	; 254
    1af0:	10 82       	st	Z, r1
    1af2:	93 c0       	rjmp	.+294    	; 0x1c1a <PD_InterpretAVRISPPacket+0x2d2>
    1af4:	0e 94 47 0c 	call	0x188e <PD_SetupDFAddressCounters>
    1af8:	80 91 6d 02 	lds	r24, 0x026D
    1afc:	90 91 6e 02 	lds	r25, 0x026E
    1b00:	0e 94 9b 0a 	call	0x1536 <DF_CopyFlashPageToBuffer>
    1b04:	80 91 66 02 	lds	r24, 0x0266
    1b08:	90 91 67 02 	lds	r25, 0x0267
    1b0c:	0e 94 40 0a 	call	0x1480 <DF_BufferWriteEnable>
    1b10:	80 91 4c 01 	lds	r24, 0x014C
    1b14:	99 27       	eor	r25, r25
    1b16:	d8 2f       	mov	r29, r24
    1b18:	cc 27       	eor	r28, r28
    1b1a:	80 91 4d 01 	lds	r24, 0x014D
    1b1e:	99 27       	eor	r25, r25
    1b20:	c8 2b       	or	r28, r24
    1b22:	d9 2b       	or	r29, r25
    1b24:	00 e0       	ldi	r16, 0x00	; 0
    1b26:	10 e0       	ldi	r17, 0x00	; 0
    1b28:	0c 17       	cp	r16, r28
    1b2a:	1d 07       	cpc	r17, r29
    1b2c:	c8 f4       	brcc	.+50     	; 0x1b60 <PD_InterpretAVRISPPacket+0x218>
    1b2e:	55 e5       	ldi	r21, 0x55	; 85
    1b30:	e5 2e       	mov	r14, r21
    1b32:	51 e0       	ldi	r21, 0x01	; 1
    1b34:	f5 2e       	mov	r15, r21
    1b36:	f7 01       	movw	r30, r14
    1b38:	81 91       	ld	r24, Z+
    1b3a:	7f 01       	movw	r14, r30
    1b3c:	0e 94 74 0c 	call	0x18e8 <PD_StoreDataflashByte>
    1b40:	80 91 66 02 	lds	r24, 0x0266
    1b44:	90 91 67 02 	lds	r25, 0x0267
    1b48:	01 96       	adiw	r24, 0x01	; 1
    1b4a:	90 93 67 02 	sts	0x0267, r25
    1b4e:	80 93 66 02 	sts	0x0266, r24
    1b52:	0e 94 36 0f 	call	0x1e6c <V2P_IncrementCurrAddress>
    1b56:	0f 5f       	subi	r16, 0xFF	; 255
    1b58:	1f 4f       	sbci	r17, 0xFF	; 255
    1b5a:	0c 17       	cp	r16, r28
    1b5c:	1d 07       	cpc	r17, r29
    1b5e:	58 f3       	brcs	.-42     	; 0x1b36 <PD_InterpretAVRISPPacket+0x1ee>
    1b60:	10 92 4c 01 	sts	0x014C, r1
    1b64:	5a c0       	rjmp	.+180    	; 0x1c1a <PD_InterpretAVRISPPacket+0x2d2>
    1b66:	0e 94 47 0c 	call	0x188e <PD_SetupDFAddressCounters>
    1b6a:	80 91 6d 02 	lds	r24, 0x026D
    1b6e:	90 91 6e 02 	lds	r25, 0x026E
    1b72:	0e 94 9b 0a 	call	0x1536 <DF_CopyFlashPageToBuffer>
    1b76:	80 91 4c 01 	lds	r24, 0x014C
    1b7a:	99 27       	eor	r25, r25
    1b7c:	d8 2f       	mov	r29, r24
    1b7e:	cc 27       	eor	r28, r28
    1b80:	80 91 4d 01 	lds	r24, 0x014D
    1b84:	99 27       	eor	r25, r25
    1b86:	c8 2b       	or	r28, r24
    1b88:	d9 2b       	or	r29, r25
    1b8a:	00 e0       	ldi	r16, 0x00	; 0
    1b8c:	10 e0       	ldi	r17, 0x00	; 0
    1b8e:	0c 17       	cp	r16, r28
    1b90:	1d 07       	cpc	r17, r29
    1b92:	70 f5       	brcc	.+92     	; 0x1bf0 <PD_InterpretAVRISPPacket+0x2a8>
    1b94:	3d e4       	ldi	r19, 0x4D	; 77
    1b96:	e3 2e       	mov	r14, r19
    1b98:	31 e0       	ldi	r19, 0x01	; 1
    1b9a:	f3 2e       	mov	r15, r19
    1b9c:	20 91 66 02 	lds	r18, 0x0266
    1ba0:	30 91 67 02 	lds	r19, 0x0267
    1ba4:	80 91 69 02 	lds	r24, 0x0269
    1ba8:	90 91 6a 02 	lds	r25, 0x026A
    1bac:	28 17       	cp	r18, r24
    1bae:	39 07       	cpc	r19, r25
    1bb0:	41 f4       	brne	.+16     	; 0x1bc2 <PD_InterpretAVRISPPacket+0x27a>
    1bb2:	0e 94 47 0c 	call	0x188e <PD_SetupDFAddressCounters>
    1bb6:	80 91 6d 02 	lds	r24, 0x026D
    1bba:	90 91 6e 02 	lds	r25, 0x026E
    1bbe:	0e 94 9b 0a 	call	0x1536 <DF_CopyFlashPageToBuffer>
    1bc2:	80 91 66 02 	lds	r24, 0x0266
    1bc6:	90 91 67 02 	lds	r25, 0x0267
    1bca:	9c 01       	movw	r18, r24
    1bcc:	01 96       	adiw	r24, 0x01	; 1
    1bce:	90 93 67 02 	sts	0x0267, r25
    1bd2:	80 93 66 02 	sts	0x0266, r24
    1bd6:	c9 01       	movw	r24, r18
    1bd8:	0e 94 df 09 	call	0x13be <DF_ReadBufferByte>
    1bdc:	f7 01       	movw	r30, r14
    1bde:	81 93       	st	Z+, r24
    1be0:	7f 01       	movw	r14, r30
    1be2:	0e 94 36 0f 	call	0x1e6c <V2P_IncrementCurrAddress>
    1be6:	0f 5f       	subi	r16, 0xFF	; 255
    1be8:	1f 4f       	sbci	r17, 0xFF	; 255
    1bea:	0c 17       	cp	r16, r28
    1bec:	1d 07       	cpc	r17, r29
    1bee:	b0 f2       	brcs	.-84     	; 0x1b9c <PD_InterpretAVRISPPacket+0x254>
    1bf0:	23 96       	adiw	r28, 0x03	; 3
    1bf2:	d0 93 48 01 	sts	0x0148, r29
    1bf6:	c0 93 47 01 	sts	0x0147, r28
    1bfa:	23 97       	sbiw	r28, 0x03	; 3
    1bfc:	10 92 4c 01 	sts	0x014C, r1
    1c00:	c5 5b       	subi	r28, 0xB5	; 181
    1c02:	de 4f       	sbci	r29, 0xFE	; 254
    1c04:	1a 82       	std	Y+2, r1	; 0x02
    1c06:	09 c0       	rjmp	.+18     	; 0x1c1a <PD_InterpretAVRISPPacket+0x2d2>
    1c08:	81 e0       	ldi	r24, 0x01	; 1
    1c0a:	90 e0       	ldi	r25, 0x00	; 0
    1c0c:	90 93 48 01 	sts	0x0148, r25
    1c10:	80 93 47 01 	sts	0x0147, r24
    1c14:	89 ec       	ldi	r24, 0xC9	; 201
    1c16:	80 93 4c 01 	sts	0x014C, r24
    1c1a:	0e 94 55 0e 	call	0x1caa <V2P_SendPacket>
    1c1e:	dd 20       	and	r13, r13
    1c20:	d9 f0       	breq	.+54     	; 0x1c58 <PD_InterpretAVRISPPacket+0x310>
    1c22:	8a e2       	ldi	r24, 0x2A	; 42
    1c24:	92 e0       	ldi	r25, 0x02	; 2
    1c26:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>
    1c2a:	c0 e0       	ldi	r28, 0x00	; 0
    1c2c:	d0 e0       	ldi	r29, 0x00	; 0
    1c2e:	80 91 6b 02 	lds	r24, 0x026B
    1c32:	90 91 6c 02 	lds	r25, 0x026C
    1c36:	23 e0       	ldi	r18, 0x03	; 3
    1c38:	96 95       	lsr	r25
    1c3a:	87 95       	ror	r24
    1c3c:	2a 95       	dec	r18
    1c3e:	e1 f7       	brne	.-8      	; 0x1c38 <PD_InterpretAVRISPPacket+0x2f0>
    1c40:	c8 17       	cp	r28, r24
    1c42:	d9 07       	cpc	r29, r25
    1c44:	28 f4       	brcc	.+10     	; 0x1c50 <PD_InterpretAVRISPPacket+0x308>
    1c46:	ce 01       	movw	r24, r28
    1c48:	0e 94 78 0a 	call	0x14f0 <DF_EraseBlock>
    1c4c:	21 96       	adiw	r28, 0x01	; 1
    1c4e:	ef cf       	rjmp	.-34     	; 0x1c2e <PD_InterpretAVRISPPacket+0x2e6>
    1c50:	8b ec       	ldi	r24, 0xCB	; 203
    1c52:	93 e0       	ldi	r25, 0x03	; 3
    1c54:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>
    1c58:	df 91       	pop	r29
    1c5a:	cf 91       	pop	r28
    1c5c:	1f 91       	pop	r17
    1c5e:	0f 91       	pop	r16
    1c60:	ff 90       	pop	r15
    1c62:	ef 90       	pop	r14
    1c64:	df 90       	pop	r13
    1c66:	08 95       	ret

00001c68 <V2P_GetChecksum>:
	
	/* Checksum for the V2 protocol is comprised of an XOR of all the packet 
      bytes, including the start, sequence number, size and token bytes.    */
	
	CheckSumByte  = MESSAGE_START;
    1c68:	6b e1       	ldi	r22, 0x1B	; 27
	CheckSumByte ^= SequenceNum;
    1c6a:	80 91 49 01 	lds	r24, 0x0149
    1c6e:	68 27       	eor	r22, r24
	CheckSumByte ^= (uint8_t)(MessageSize >> 8);
    1c70:	20 91 47 01 	lds	r18, 0x0147
    1c74:	30 91 48 01 	lds	r19, 0x0148
    1c78:	83 2f       	mov	r24, r19
    1c7a:	99 27       	eor	r25, r25
    1c7c:	68 27       	eor	r22, r24
	CheckSumByte ^= (uint8_t)(MessageSize);
    1c7e:	80 91 47 01 	lds	r24, 0x0147
    1c82:	68 27       	eor	r22, r24
	CheckSumByte ^= TOKEN;
    1c84:	8e e0       	ldi	r24, 0x0E	; 14
    1c86:	68 27       	eor	r22, r24
	
	for (uint16_t CByteIndex = 0; CByteIndex < MessageSize; CByteIndex++)
    1c88:	40 e0       	ldi	r20, 0x00	; 0
    1c8a:	50 e0       	ldi	r21, 0x00	; 0
    1c8c:	42 17       	cp	r20, r18
    1c8e:	53 07       	cpc	r21, r19
    1c90:	48 f4       	brcc	.+18     	; 0x1ca4 <V2P_GetChecksum+0x3c>
    1c92:	eb e4       	ldi	r30, 0x4B	; 75
    1c94:	f1 e0       	ldi	r31, 0x01	; 1
	   CheckSumByte ^= PacketBytes[CByteIndex];
    1c96:	81 91       	ld	r24, Z+
    1c98:	68 27       	eor	r22, r24
    1c9a:	4f 5f       	subi	r20, 0xFF	; 255
    1c9c:	5f 4f       	sbci	r21, 0xFF	; 255
    1c9e:	42 17       	cp	r20, r18
    1ca0:	53 07       	cpc	r21, r19
    1ca2:	c8 f3       	brcs	.-14     	; 0x1c96 <V2P_GetChecksum+0x2e>

	return CheckSumByte;
}
    1ca4:	86 2f       	mov	r24, r22
    1ca6:	99 27       	eor	r25, r25
    1ca8:	08 95       	ret

00001caa <V2P_SendPacket>:
    1caa:	0f 93       	push	r16
    1cac:	1f 93       	push	r17
    1cae:	cf 93       	push	r28
    1cb0:	df 93       	push	r29
    1cb2:	8b e1       	ldi	r24, 0x1B	; 27
    1cb4:	0e 94 15 09 	call	0x122a <USART_Tx>
    1cb8:	80 91 49 01 	lds	r24, 0x0149
    1cbc:	0e 94 15 09 	call	0x122a <USART_Tx>
    1cc0:	80 91 48 01 	lds	r24, 0x0148
    1cc4:	0e 94 15 09 	call	0x122a <USART_Tx>
    1cc8:	80 91 47 01 	lds	r24, 0x0147
    1ccc:	0e 94 15 09 	call	0x122a <USART_Tx>
    1cd0:	8e e0       	ldi	r24, 0x0E	; 14
    1cd2:	0e 94 15 09 	call	0x122a <USART_Tx>
    1cd6:	c0 e0       	ldi	r28, 0x00	; 0
    1cd8:	d0 e0       	ldi	r29, 0x00	; 0
    1cda:	80 91 47 01 	lds	r24, 0x0147
    1cde:	90 91 48 01 	lds	r25, 0x0148
    1ce2:	c8 17       	cp	r28, r24
    1ce4:	d9 07       	cpc	r29, r25
    1ce6:	78 f4       	brcc	.+30     	; 0x1d06 <V2P_SendPacket+0x5c>
    1ce8:	0b e4       	ldi	r16, 0x4B	; 75
    1cea:	11 e0       	ldi	r17, 0x01	; 1
    1cec:	f8 01       	movw	r30, r16
    1cee:	81 91       	ld	r24, Z+
    1cf0:	8f 01       	movw	r16, r30
    1cf2:	0e 94 15 09 	call	0x122a <USART_Tx>
    1cf6:	21 96       	adiw	r28, 0x01	; 1
    1cf8:	80 91 47 01 	lds	r24, 0x0147
    1cfc:	90 91 48 01 	lds	r25, 0x0148
    1d00:	c8 17       	cp	r28, r24
    1d02:	d9 07       	cpc	r29, r25
    1d04:	98 f3       	brcs	.-26     	; 0x1cec <V2P_SendPacket+0x42>
    1d06:	0e 94 34 0e 	call	0x1c68 <V2P_GetChecksum>
    1d0a:	0e 94 15 09 	call	0x122a <USART_Tx>
    1d0e:	80 91 49 01 	lds	r24, 0x0149
    1d12:	90 91 4a 01 	lds	r25, 0x014A
    1d16:	01 96       	adiw	r24, 0x01	; 1
    1d18:	90 93 4a 01 	sts	0x014A, r25
    1d1c:	80 93 49 01 	sts	0x0149, r24
    1d20:	df 91       	pop	r29
    1d22:	cf 91       	pop	r28
    1d24:	1f 91       	pop	r17
    1d26:	0f 91       	pop	r16
    1d28:	08 95       	ret

00001d2a <V2P_GetSetParamater>:

void V2P_GetSetParamater(void)
{
	uint8_t Param_Name = PacketBytes[1];    // Save the parameter number
    1d2a:	20 91 4c 01 	lds	r18, 0x014C

	MessageSize = 3;                        // Set the default response message size to 3 bytes     
    1d2e:	83 e0       	ldi	r24, 0x03	; 3
    1d30:	90 e0       	ldi	r25, 0x00	; 0
    1d32:	90 93 48 01 	sts	0x0148, r25
    1d36:	80 93 47 01 	sts	0x0147, r24
	PacketBytes[1] = STATUS_CMD_OK;         // Set the default response to OK
    1d3a:	10 92 4c 01 	sts	0x014C, r1

	switch (Param_Name)                    // Switch based on the recieved parameter byte
    1d3e:	33 27       	eor	r19, r19
    1d40:	22 39       	cpi	r18, 0x92	; 146
    1d42:	31 05       	cpc	r19, r1
    1d44:	51 f1       	breq	.+84     	; 0x1d9a <V2P_GetSetParamater+0x70>
    1d46:	23 39       	cpi	r18, 0x93	; 147
    1d48:	31 05       	cpc	r19, r1
    1d4a:	8c f4       	brge	.+34     	; 0x1d6e <V2P_GetSetParamater+0x44>
    1d4c:	21 38       	cpi	r18, 0x81	; 129
    1d4e:	31 05       	cpc	r19, r1
    1d50:	01 f1       	breq	.+64     	; 0x1d92 <V2P_GetSetParamater+0x68>
    1d52:	22 38       	cpi	r18, 0x82	; 130
    1d54:	31 05       	cpc	r19, r1
    1d56:	24 f4       	brge	.+8      	; 0x1d60 <V2P_GetSetParamater+0x36>
    1d58:	20 38       	cpi	r18, 0x80	; 128
    1d5a:	31 05       	cpc	r19, r1
    1d5c:	41 f1       	breq	.+80     	; 0x1dae <V2P_GetSetParamater+0x84>
    1d5e:	7a c0       	rjmp	.+244    	; 0x1e54 <V2P_GetSetParamater+0x12a>
    1d60:	20 39       	cpi	r18, 0x90	; 144
    1d62:	31 05       	cpc	r19, r1
    1d64:	c1 f0       	breq	.+48     	; 0x1d96 <V2P_GetSetParamater+0x6c>
    1d66:	21 39       	cpi	r18, 0x91	; 145
    1d68:	31 05       	cpc	r19, r1
    1d6a:	a9 f0       	breq	.+42     	; 0x1d96 <V2P_GetSetParamater+0x6c>
    1d6c:	73 c0       	rjmp	.+230    	; 0x1e54 <V2P_GetSetParamater+0x12a>
    1d6e:	28 39       	cpi	r18, 0x98	; 152
    1d70:	31 05       	cpc	r19, r1
    1d72:	89 f1       	breq	.+98     	; 0x1dd6 <V2P_GetSetParamater+0xac>
    1d74:	29 39       	cpi	r18, 0x99	; 153
    1d76:	31 05       	cpc	r19, r1
    1d78:	2c f4       	brge	.+10     	; 0x1d84 <V2P_GetSetParamater+0x5a>
    1d7a:	26 39       	cpi	r18, 0x96	; 150
    1d7c:	31 05       	cpc	r19, r1
    1d7e:	0c f4       	brge	.+2      	; 0x1d82 <V2P_GetSetParamater+0x58>
    1d80:	69 c0       	rjmp	.+210    	; 0x1e54 <V2P_GetSetParamater+0x12a>
    1d82:	5a c0       	rjmp	.+180    	; 0x1e38 <V2P_GetSetParamater+0x10e>
    1d84:	2e 39       	cpi	r18, 0x9E	; 158
    1d86:	31 05       	cpc	r19, r1
    1d88:	e1 f1       	breq	.+120    	; 0x1e02 <V2P_GetSetParamater+0xd8>
    1d8a:	2f 39       	cpi	r18, 0x9F	; 159
    1d8c:	31 05       	cpc	r19, r1
    1d8e:	89 f0       	breq	.+34     	; 0x1db2 <V2P_GetSetParamater+0x88>
    1d90:	61 c0       	rjmp	.+194    	; 0x1e54 <V2P_GetSetParamater+0x12a>
	{
		case PARAM_BUILD_NUMBER_LOW:
			PacketBytes[2] = VERSION_MINOR;

			break;
		case PARAM_BUILD_NUMBER_HIGH:
			PacketBytes[2] = VERSION_MAJOR;
    1d92:	81 e0       	ldi	r24, 0x01	; 1
    1d94:	3f c0       	rjmp	.+126    	; 0x1e14 <V2P_GetSetParamater+0xea>

			break;
		case PARAM_HARDWARE_VERSION:
			PacketBytes[2] = V2P_HW_VERSION;

			break;
		case PARAM_SW_MAJOR:
			PacketBytes[2] = V2P_SW_VERSION_MAJOR;
    1d96:	82 e0       	ldi	r24, 0x02	; 2
    1d98:	3d c0       	rjmp	.+122    	; 0x1e14 <V2P_GetSetParamater+0xea>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    1d9a:	a6 e8       	ldi	r26, 0x86	; 134
    1d9c:	b0 e0       	ldi	r27, 0x00	; 0
    1d9e:	9d 01       	movw	r18, r26
  uint8_t result;
  asm volatile
    1da0:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
    1da4:	80 2d       	mov	r24, r0
    1da6:	8f 3f       	cpi	r24, 0xFF	; 255
    1da8:	11 f0       	breq	.+4      	; 0x1dae <V2P_GetSetParamater+0x84>
    1daa:	d9 01       	movw	r26, r18
    1dac:	30 c0       	rjmp	.+96     	; 0x1e0e <V2P_GetSetParamater+0xe4>
    1dae:	84 e0       	ldi	r24, 0x04	; 4
    1db0:	31 c0       	rjmp	.+98     	; 0x1e14 <V2P_GetSetParamater+0xea>

			break;
		case PARAM_SW_MINOR:
			PacketBytes[2] = ((eeprom_read_byte(&EEPROMVars.FirmVerMinor) == 0xFF)? V2P_SW_VERSION_MINOR_DEFAULT : eeprom_read_byte(&EEPROMVars.FirmVerMinor));

			break;
		case PARAM_CONTROLLER_INIT:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1db2:	80 91 4b 01 	lds	r24, 0x014B
    1db6:	83 30       	cpi	r24, 0x03	; 3
    1db8:	19 f4       	brne	.+6      	; 0x1dc0 <V2P_GetSetParamater+0x96>
			{
				PacketBytes[2] = Param_ControllerInit;
    1dba:	80 91 41 01 	lds	r24, 0x0141
    1dbe:	2a c0       	rjmp	.+84     	; 0x1e14 <V2P_GetSetParamater+0xea>
			}
			else
			{
				MessageSize = 2;
    1dc0:	82 e0       	ldi	r24, 0x02	; 2
    1dc2:	90 e0       	ldi	r25, 0x00	; 0
    1dc4:	90 93 48 01 	sts	0x0148, r25
    1dc8:	80 93 47 01 	sts	0x0147, r24
				Param_ControllerInit = PacketBytes[2];
    1dcc:	80 91 4d 01 	lds	r24, 0x014D
    1dd0:	80 93 41 01 	sts	0x0141, r24
			}
			
			break;
    1dd4:	48 c0       	rjmp	.+144    	; 0x1e66 <V2P_GetSetParamater+0x13c>
		case PARAM_SCK_DURATION:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1dd6:	80 91 4b 01 	lds	r24, 0x014B
    1dda:	a1 e0       	ldi	r26, 0x01	; 1
    1ddc:	b0 e0       	ldi	r27, 0x00	; 0
    1dde:	83 30       	cpi	r24, 0x03	; 3
    1de0:	b1 f0       	breq	.+44     	; 0x1e0e <V2P_GetSetParamater+0xe4>
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.SCKDuration);
			}
			else
			{
				MessageSize = 2;
    1de2:	82 e0       	ldi	r24, 0x02	; 2
    1de4:	90 e0       	ldi	r25, 0x00	; 0
    1de6:	90 93 48 01 	sts	0x0148, r25
    1dea:	80 93 47 01 	sts	0x0147, r24
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    1dee:	80 91 4d 01 	lds	r24, 0x014D
  asm volatile (
    1df2:	08 2e       	mov	r0, r24
    1df4:	0e 94 64 1a 	call	0x34c8 <__eeprom_write_byte_1F2021>
				eeprom_write_byte(&EEPROMVars.SCKDuration, PacketBytes[2]);
				USI_SPISetSpeed(PacketBytes[2]); // Re-Initialise the USI system with the new frequency
    1df8:	80 91 4d 01 	lds	r24, 0x014D
    1dfc:	0e 94 63 09 	call	0x12c6 <USI_SPISetSpeed>
			}
					
			break;
    1e00:	32 c0       	rjmp	.+100    	; 0x1e66 <V2P_GetSetParamater+0x13c>
		case PARAM_RESET_POLARITY:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1e02:	80 91 4b 01 	lds	r24, 0x014B
    1e06:	a0 e0       	ldi	r26, 0x00	; 0
    1e08:	b0 e0       	ldi	r27, 0x00	; 0
    1e0a:	83 30       	cpi	r24, 0x03	; 3
    1e0c:	31 f4       	brne	.+12     	; 0x1e1a <V2P_GetSetParamater+0xf0>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1e0e:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
    1e12:	80 2d       	mov	r24, r0
    1e14:	80 93 4d 01 	sts	0x014D, r24
    1e18:	26 c0       	rjmp	.+76     	; 0x1e66 <V2P_GetSetParamater+0x13c>
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.ResetPolarity);		
			}
			else
			{
				MessageSize = 2;
    1e1a:	82 e0       	ldi	r24, 0x02	; 2
    1e1c:	90 e0       	ldi	r25, 0x00	; 0
    1e1e:	90 93 48 01 	sts	0x0148, r25
    1e22:	80 93 47 01 	sts	0x0147, r24
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    1e26:	80 91 4d 01 	lds	r24, 0x014D
  asm volatile (
    1e2a:	08 2e       	mov	r0, r24
    1e2c:	0e 94 64 1a 	call	0x34c8 <__eeprom_write_byte_1F2021>
				eeprom_write_byte(&EEPROMVars.ResetPolarity, PacketBytes[2]);
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Change takes effect immediatly
    1e30:	81 e0       	ldi	r24, 0x01	; 1
    1e32:	0e 94 16 03 	call	0x62c <MAIN_ResetCSLine>
			}
			
			break;
    1e36:	17 c0       	rjmp	.+46     	; 0x1e66 <V2P_GetSetParamater+0x13c>
		case PARAM_OSC_PSCALE:
		case PARAM_OSC_CMATCH:
			/* Despite not supporting these parameters (STK500 only), the AVR Studio programmer
			   sends them along with the SCK duration. A OK must be returned or the sequence will fail
			   and the SCK duration byte will not be sent.                                             */
		
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1e38:	80 91 4b 01 	lds	r24, 0x014B
    1e3c:	83 30       	cpi	r24, 0x03	; 3
    1e3e:	19 f4       	brne	.+6      	; 0x1e46 <V2P_GetSetParamater+0x11c>
			{
			   PacketBytes[2] = 0;            // If the command is a read, return a 0 for both parameters
    1e40:	10 92 4d 01 	sts	0x014D, r1
    1e44:	10 c0       	rjmp	.+32     	; 0x1e66 <V2P_GetSetParamater+0x13c>
			}
			else
			{
				MessageSize = 2;              // Otherwise just send back an OK if the command is a set		
    1e46:	82 e0       	ldi	r24, 0x02	; 2
    1e48:	90 e0       	ldi	r25, 0x00	; 0
    1e4a:	90 93 48 01 	sts	0x0148, r25
    1e4e:	80 93 47 01 	sts	0x0147, r24
			}
			
			break;
    1e52:	09 c0       	rjmp	.+18     	; 0x1e66 <V2P_GetSetParamater+0x13c>
		default:                             // Unrecognised parameter
			MessageSize = 2;
    1e54:	82 e0       	ldi	r24, 0x02	; 2
    1e56:	90 e0       	ldi	r25, 0x00	; 0
    1e58:	90 93 48 01 	sts	0x0148, r25
    1e5c:	80 93 47 01 	sts	0x0147, r24
			PacketBytes[1] = STATUS_CMD_FAILED;			
    1e60:	80 ec       	ldi	r24, 0xC0	; 192
    1e62:	80 93 4c 01 	sts	0x014C, r24
	}
	
	V2P_SendPacket();
    1e66:	0e 94 55 0e 	call	0x1caa <V2P_SendPacket>
    1e6a:	08 95       	ret

00001e6c <V2P_IncrementCurrAddress>:
}

void V2P_IncrementCurrAddress(void)
{
	// Incrementing a 32-bit unsigned variable takes a lot of code. Because much of the code is
	// not very time critical (much of it is waiting for the hardware), i've chosen to waste
	// a few extra cycles per increment and save a good 60 bytes or so of code space by putting
	// the incrmement inside a function.

	CurrAddress++;
    1e6c:	80 91 42 01 	lds	r24, 0x0142
    1e70:	90 91 43 01 	lds	r25, 0x0143
    1e74:	a0 91 44 01 	lds	r26, 0x0144
    1e78:	b0 91 45 01 	lds	r27, 0x0145
    1e7c:	01 96       	adiw	r24, 0x01	; 1
    1e7e:	a1 1d       	adc	r26, r1
    1e80:	b1 1d       	adc	r27, r1
    1e82:	80 93 42 01 	sts	0x0142, r24
    1e86:	90 93 43 01 	sts	0x0143, r25
    1e8a:	a0 93 44 01 	sts	0x0144, r26
    1e8e:	b0 93 45 01 	sts	0x0145, r27
    1e92:	08 95       	ret

00001e94 <V2P_CheckForExtendedAddress>:
}

void V2P_CheckForExtendedAddress(void)
{
	if (CurrAddress & (1UL << 31))                     // MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
    1e94:	80 91 42 01 	lds	r24, 0x0142
    1e98:	90 91 43 01 	lds	r25, 0x0143
    1e9c:	a0 91 44 01 	lds	r26, 0x0144
    1ea0:	b0 91 45 01 	lds	r27, 0x0145
    1ea4:	b7 ff       	sbrs	r27, 7
    1ea6:	1e c0       	rjmp	.+60     	; 0x1ee4 <V2P_CheckForExtendedAddress+0x50>
	{
		USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);   // Load extended address command
    1ea8:	8d e4       	ldi	r24, 0x4D	; 77
    1eaa:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1eae:	80 e0       	ldi	r24, 0x00	; 0
    1eb0:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
		USI_SPITransmit((CurrAddress & 0x00FF0000) >> 16); // The 3rd byte of the long holds the extended address
    1eb4:	80 91 44 01 	lds	r24, 0x0144
    1eb8:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1ebc:	80 e0       	ldi	r24, 0x00	; 0
    1ebe:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
		
		CurrAddress &= ~(1UL << 31);                   // Clear the flag
    1ec2:	80 91 42 01 	lds	r24, 0x0142
    1ec6:	90 91 43 01 	lds	r25, 0x0143
    1eca:	a0 91 44 01 	lds	r26, 0x0144
    1ece:	b0 91 45 01 	lds	r27, 0x0145
    1ed2:	bf 77       	andi	r27, 0x7F	; 127
    1ed4:	80 93 42 01 	sts	0x0142, r24
    1ed8:	90 93 43 01 	sts	0x0143, r25
    1edc:	a0 93 44 01 	sts	0x0144, r26
    1ee0:	b0 93 45 01 	sts	0x0145, r27
    1ee4:	08 95       	ret

00001ee6 <V2P_RunStateMachine>:
    1ee6:	ef 92       	push	r14
    1ee8:	ff 92       	push	r15
    1eea:	0f 93       	push	r16
    1eec:	1f 93       	push	r17
    1eee:	cf 93       	push	r28
    1ef0:	c0 e0       	ldi	r28, 0x00	; 0
    1ef2:	ee 24       	eor	r14, r14
    1ef4:	ff 24       	eor	r15, r15
    1ef6:	0e 94 9a 0b 	call	0x1734 <BUFF_InitialiseBuffer>
    1efa:	c0 93 81 00 	sts	0x0081, r28
    1efe:	c0 93 46 01 	sts	0x0146, r28
    1f02:	10 92 42 01 	sts	0x0142, r1
    1f06:	10 92 43 01 	sts	0x0143, r1
    1f0a:	10 92 44 01 	sts	0x0144, r1
    1f0e:	10 92 45 01 	sts	0x0145, r1
    1f12:	80 91 3f 01 	lds	r24, 0x013F
    1f16:	81 30       	cpi	r24, 0x01	; 1
    1f18:	11 f4       	brne	.+4      	; 0x1f1e <V2P_RunStateMachine+0x38>
    1f1a:	ca e0       	ldi	r28, 0x0A	; 10
    1f1c:	11 c0       	rjmp	.+34     	; 0x1f40 <V2P_RunStateMachine+0x5a>
    1f1e:	cc 23       	and	r28, r28
    1f20:	79 f0       	breq	.+30     	; 0x1f40 <V2P_RunStateMachine+0x5a>
    1f22:	10 92 3f 01 	sts	0x013F, r1
    1f26:	10 92 40 01 	sts	0x0140, r1
    1f2a:	10 92 b2 00 	sts	0x00B2, r1
    1f2e:	80 ef       	ldi	r24, 0xF0	; 240
    1f30:	80 93 b3 00 	sts	0x00B3, r24
    1f34:	82 e0       	ldi	r24, 0x02	; 2
    1f36:	80 93 70 00 	sts	0x0070, r24
    1f3a:	8f e0       	ldi	r24, 0x0F	; 15
    1f3c:	80 93 b0 00 	sts	0x00B0, r24
    1f40:	8c 2f       	mov	r24, r28
    1f42:	99 27       	eor	r25, r25
    1f44:	85 30       	cpi	r24, 0x05	; 5
    1f46:	91 05       	cpc	r25, r1
    1f48:	09 f4       	brne	.+2      	; 0x1f4c <V2P_RunStateMachine+0x66>
    1f4a:	88 c0       	rjmp	.+272    	; 0x205c <V2P_RunStateMachine+0x176>
    1f4c:	86 30       	cpi	r24, 0x06	; 6
    1f4e:	91 05       	cpc	r25, r1
    1f50:	ac f4       	brge	.+42     	; 0x1f7c <V2P_RunStateMachine+0x96>
    1f52:	82 30       	cpi	r24, 0x02	; 2
    1f54:	91 05       	cpc	r25, r1
    1f56:	09 f4       	brne	.+2      	; 0x1f5a <V2P_RunStateMachine+0x74>
    1f58:	58 c0       	rjmp	.+176    	; 0x200a <V2P_RunStateMachine+0x124>
    1f5a:	83 30       	cpi	r24, 0x03	; 3
    1f5c:	91 05       	cpc	r25, r1
    1f5e:	34 f4       	brge	.+12     	; 0x1f6c <V2P_RunStateMachine+0x86>
    1f60:	00 97       	sbiw	r24, 0x00	; 0
    1f62:	99 f1       	breq	.+102    	; 0x1fca <V2P_RunStateMachine+0xe4>
    1f64:	01 97       	sbiw	r24, 0x01	; 1
    1f66:	09 f4       	brne	.+2      	; 0x1f6a <V2P_RunStateMachine+0x84>
    1f68:	4a c0       	rjmp	.+148    	; 0x1ffe <V2P_RunStateMachine+0x118>
    1f6a:	d3 cf       	rjmp	.-90     	; 0x1f12 <V2P_RunStateMachine+0x2c>
    1f6c:	83 30       	cpi	r24, 0x03	; 3
    1f6e:	91 05       	cpc	r25, r1
    1f70:	09 f4       	brne	.+2      	; 0x1f74 <V2P_RunStateMachine+0x8e>
    1f72:	54 c0       	rjmp	.+168    	; 0x201c <V2P_RunStateMachine+0x136>
    1f74:	04 97       	sbiw	r24, 0x04	; 4
    1f76:	09 f4       	brne	.+2      	; 0x1f7a <V2P_RunStateMachine+0x94>
    1f78:	5c c0       	rjmp	.+184    	; 0x2032 <V2P_RunStateMachine+0x14c>
    1f7a:	cb cf       	rjmp	.-106    	; 0x1f12 <V2P_RunStateMachine+0x2c>
    1f7c:	88 30       	cpi	r24, 0x08	; 8
    1f7e:	91 05       	cpc	r25, r1
    1f80:	d1 f0       	breq	.+52     	; 0x1fb6 <V2P_RunStateMachine+0xd0>
    1f82:	89 30       	cpi	r24, 0x09	; 9
    1f84:	91 05       	cpc	r25, r1
    1f86:	44 f4       	brge	.+16     	; 0x1f98 <V2P_RunStateMachine+0xb2>
    1f88:	86 30       	cpi	r24, 0x06	; 6
    1f8a:	91 05       	cpc	r25, r1
    1f8c:	09 f4       	brne	.+2      	; 0x1f90 <V2P_RunStateMachine+0xaa>
    1f8e:	6e c0       	rjmp	.+220    	; 0x206c <V2P_RunStateMachine+0x186>
    1f90:	07 97       	sbiw	r24, 0x07	; 7
    1f92:	09 f4       	brne	.+2      	; 0x1f96 <V2P_RunStateMachine+0xb0>
    1f94:	7f c0       	rjmp	.+254    	; 0x2094 <V2P_RunStateMachine+0x1ae>
    1f96:	bd cf       	rjmp	.-134    	; 0x1f12 <V2P_RunStateMachine+0x2c>
    1f98:	89 30       	cpi	r24, 0x09	; 9
    1f9a:	91 05       	cpc	r25, r1
    1f9c:	09 f4       	brne	.+2      	; 0x1fa0 <V2P_RunStateMachine+0xba>
    1f9e:	ac c0       	rjmp	.+344    	; 0x20f8 <V2P_RunStateMachine+0x212>
    1fa0:	0a 97       	sbiw	r24, 0x0a	; 10
    1fa2:	09 f0       	breq	.+2      	; 0x1fa6 <V2P_RunStateMachine+0xc0>
    1fa4:	b6 cf       	rjmp	.-148    	; 0x1f12 <V2P_RunStateMachine+0x2c>
    1fa6:	82 e0       	ldi	r24, 0x02	; 2
    1fa8:	90 e0       	ldi	r25, 0x00	; 0
    1faa:	90 93 48 01 	sts	0x0148, r25
    1fae:	80 93 47 01 	sts	0x0147, r24
    1fb2:	80 e8       	ldi	r24, 0x80	; 128
    1fb4:	f7 c0       	rjmp	.+494    	; 0x21a4 <V2P_RunStateMachine+0x2be>
    1fb6:	10 92 3f 01 	sts	0x013F, r1
    1fba:	0e 94 9a 0b 	call	0x1734 <BUFF_InitialiseBuffer>
    1fbe:	10 92 b0 00 	sts	0x00B0, r1
    1fc2:	10 92 70 00 	sts	0x0070, r1
    1fc6:	c0 e0       	ldi	r28, 0x00	; 0
    1fc8:	a4 cf       	rjmp	.-184    	; 0x1f12 <V2P_RunStateMachine+0x2c>
    1fca:	80 91 b3 02 	lds	r24, 0x02B3
    1fce:	81 11       	cpse	r24, r1
    1fd0:	c1 e0       	ldi	r28, 0x01	; 1
    1fd2:	f2 9b       	sbis	0x1e, 2	; 30
    1fd4:	9e cf       	rjmp	.-196    	; 0x1f12 <V2P_RunStateMachine+0x2c>
    1fd6:	80 91 46 01 	lds	r24, 0x0146
    1fda:	88 23       	and	r24, r24
    1fdc:	09 f0       	breq	.+2      	; 0x1fe0 <V2P_RunStateMachine+0xfa>
    1fde:	99 cf       	rjmp	.-206    	; 0x1f12 <V2P_RunStateMachine+0x2c>
    1fe0:	80 e8       	ldi	r24, 0x80	; 128
    1fe2:	80 93 61 00 	sts	0x0061, r24
    1fe6:	83 e0       	ldi	r24, 0x03	; 3
    1fe8:	80 93 61 00 	sts	0x0061, r24
    1fec:	80 91 c1 00 	lds	r24, 0x00C1
    1ff0:	80 78       	andi	r24, 0x80	; 128
    1ff2:	80 93 c1 00 	sts	0x00C1, r24
    1ff6:	81 e0       	ldi	r24, 0x01	; 1
    1ff8:	80 93 81 00 	sts	0x0081, r24
    1ffc:	d9 c0       	rjmp	.+434    	; 0x21b0 <V2P_RunStateMachine+0x2ca>
    1ffe:	0e 94 1d 09 	call	0x123a <USART_Rx>
    2002:	8b 31       	cpi	r24, 0x1B	; 27
    2004:	89 f5       	brne	.+98     	; 0x2068 <V2P_RunStateMachine+0x182>
    2006:	c2 e0       	ldi	r28, 0x02	; 2
    2008:	84 cf       	rjmp	.-248    	; 0x1f12 <V2P_RunStateMachine+0x2c>
    200a:	0e 94 1d 09 	call	0x123a <USART_Rx>
    200e:	99 27       	eor	r25, r25
    2010:	90 93 4a 01 	sts	0x014A, r25
    2014:	80 93 49 01 	sts	0x0149, r24
    2018:	c3 e0       	ldi	r28, 0x03	; 3
    201a:	7b cf       	rjmp	.-266    	; 0x1f12 <V2P_RunStateMachine+0x2c>
    201c:	0e 94 1d 09 	call	0x123a <USART_Rx>
    2020:	99 27       	eor	r25, r25
    2022:	98 2f       	mov	r25, r24
    2024:	88 27       	eor	r24, r24
    2026:	90 93 48 01 	sts	0x0148, r25
    202a:	80 93 47 01 	sts	0x0147, r24
    202e:	c4 e0       	ldi	r28, 0x04	; 4
    2030:	70 cf       	rjmp	.-288    	; 0x1f12 <V2P_RunStateMachine+0x2c>
    2032:	0e 94 1d 09 	call	0x123a <USART_Rx>
    2036:	28 2f       	mov	r18, r24
    2038:	33 27       	eor	r19, r19
    203a:	80 91 47 01 	lds	r24, 0x0147
    203e:	90 91 48 01 	lds	r25, 0x0148
    2042:	82 2b       	or	r24, r18
    2044:	93 2b       	or	r25, r19
    2046:	90 93 48 01 	sts	0x0148, r25
    204a:	80 93 47 01 	sts	0x0147, r24
    204e:	83 51       	subi	r24, 0x13	; 19
    2050:	91 40       	sbci	r25, 0x01	; 1
    2052:	50 f4       	brcc	.+20     	; 0x2068 <V2P_RunStateMachine+0x182>
    2054:	c5 e0       	ldi	r28, 0x05	; 5
    2056:	ee 24       	eor	r14, r14
    2058:	ff 24       	eor	r15, r15
    205a:	5b cf       	rjmp	.-330    	; 0x1f12 <V2P_RunStateMachine+0x2c>
    205c:	0e 94 1d 09 	call	0x123a <USART_Rx>
    2060:	8e 30       	cpi	r24, 0x0E	; 14
    2062:	11 f4       	brne	.+4      	; 0x2068 <V2P_RunStateMachine+0x182>
    2064:	c6 e0       	ldi	r28, 0x06	; 6
    2066:	55 cf       	rjmp	.-342    	; 0x1f12 <V2P_RunStateMachine+0x2c>
    2068:	c9 e0       	ldi	r28, 0x09	; 9
    206a:	53 cf       	rjmp	.-346    	; 0x1f12 <V2P_RunStateMachine+0x2c>
    206c:	80 91 47 01 	lds	r24, 0x0147
    2070:	90 91 48 01 	lds	r25, 0x0148
    2074:	e8 16       	cp	r14, r24
    2076:	f9 06       	cpc	r15, r25
    2078:	11 f4       	brne	.+4      	; 0x207e <V2P_RunStateMachine+0x198>
    207a:	c7 e0       	ldi	r28, 0x07	; 7
    207c:	4a cf       	rjmp	.-364    	; 0x1f12 <V2P_RunStateMachine+0x2c>
    207e:	87 01       	movw	r16, r14
    2080:	05 5b       	subi	r16, 0xB5	; 181
    2082:	1e 4f       	sbci	r17, 0xFE	; 254
    2084:	08 94       	sec
    2086:	e1 1c       	adc	r14, r1
    2088:	f1 1c       	adc	r15, r1
    208a:	0e 94 1d 09 	call	0x123a <USART_Rx>
    208e:	f8 01       	movw	r30, r16
    2090:	80 83       	st	Z, r24
    2092:	3f cf       	rjmp	.-386    	; 0x1f12 <V2P_RunStateMachine+0x2c>
    2094:	0e 94 34 0e 	call	0x1c68 <V2P_GetChecksum>
    2098:	18 2f       	mov	r17, r24
    209a:	0e 94 1d 09 	call	0x123a <USART_Rx>
    209e:	18 17       	cp	r17, r24
    20a0:	09 f0       	breq	.+2      	; 0x20a4 <V2P_RunStateMachine+0x1be>
    20a2:	79 c0       	rjmp	.+242    	; 0x2196 <V2P_RunStateMachine+0x2b0>
    20a4:	c0 91 3f 01 	lds	r28, 0x013F
    20a8:	cc 23       	and	r28, r28
    20aa:	09 f0       	breq	.+2      	; 0x20ae <V2P_RunStateMachine+0x1c8>
    20ac:	74 c0       	rjmp	.+232    	; 0x2196 <V2P_RunStateMachine+0x2b0>
    20ae:	80 91 4b 01 	lds	r24, 0x014B
    20b2:	99 27       	eor	r25, r25
    20b4:	84 30       	cpi	r24, 0x04	; 4
    20b6:	91 05       	cpc	r25, r1
    20b8:	3c f4       	brge	.+14     	; 0x20c8 <V2P_RunStateMachine+0x1e2>
    20ba:	82 30       	cpi	r24, 0x02	; 2
    20bc:	91 05       	cpc	r25, r1
    20be:	0c f0       	brlt	.+2      	; 0x20c2 <V2P_RunStateMachine+0x1dc>
    20c0:	61 c0       	rjmp	.+194    	; 0x2184 <V2P_RunStateMachine+0x29e>
    20c2:	01 97       	sbiw	r24, 0x01	; 1
    20c4:	39 f0       	breq	.+14     	; 0x20d4 <V2P_RunStateMachine+0x1ee>
    20c6:	61 c0       	rjmp	.+194    	; 0x218a <V2P_RunStateMachine+0x2a4>
    20c8:	86 30       	cpi	r24, 0x06	; 6
    20ca:	91 05       	cpc	r25, r1
    20cc:	e9 f0       	breq	.+58     	; 0x2108 <V2P_RunStateMachine+0x222>
    20ce:	07 97       	sbiw	r24, 0x07	; 7
    20d0:	99 f0       	breq	.+38     	; 0x20f8 <V2P_RunStateMachine+0x212>
    20d2:	5b c0       	rjmp	.+182    	; 0x218a <V2P_RunStateMachine+0x2a4>
    20d4:	8b e0       	ldi	r24, 0x0B	; 11
    20d6:	90 e0       	ldi	r25, 0x00	; 0
    20d8:	90 93 48 01 	sts	0x0148, r25
    20dc:	80 93 47 01 	sts	0x0147, r24
    20e0:	ab e4       	ldi	r26, 0x4B	; 75
    20e2:	b1 e0       	ldi	r27, 0x01	; 1
    20e4:	ec ed       	ldi	r30, 0xDC	; 220
    20e6:	f3 e0       	ldi	r31, 0x03	; 3
    20e8:	9a e0       	ldi	r25, 0x0A	; 10
    20ea:	84 91       	lpm	r24, Z
    20ec:	8d 93       	st	X+, r24
    20ee:	91 50       	subi	r25, 0x01	; 1
    20f0:	31 96       	adiw	r30, 0x01	; 1
    20f2:	97 ff       	sbrs	r25, 7
    20f4:	fa cf       	rjmp	.-12     	; 0x20ea <V2P_RunStateMachine+0x204>
    20f6:	58 c0       	rjmp	.+176    	; 0x21a8 <V2P_RunStateMachine+0x2c2>
    20f8:	82 e0       	ldi	r24, 0x02	; 2
    20fa:	90 e0       	ldi	r25, 0x00	; 0
    20fc:	90 93 48 01 	sts	0x0148, r25
    2100:	80 93 47 01 	sts	0x0147, r24
    2104:	80 ec       	ldi	r24, 0xC0	; 192
    2106:	4e c0       	rjmp	.+156    	; 0x21a4 <V2P_RunStateMachine+0x2be>
    2108:	82 e0       	ldi	r24, 0x02	; 2
    210a:	90 e0       	ldi	r25, 0x00	; 0
    210c:	90 93 48 01 	sts	0x0148, r25
    2110:	80 93 47 01 	sts	0x0147, r24
    2114:	0e 94 4a 0f 	call	0x1e94 <V2P_CheckForExtendedAddress>
    2118:	80 91 4c 01 	lds	r24, 0x014C
    211c:	99 27       	eor	r25, r25
    211e:	aa 27       	eor	r26, r26
    2120:	bb 27       	eor	r27, r27
    2122:	b8 2f       	mov	r27, r24
    2124:	aa 27       	eor	r26, r26
    2126:	99 27       	eor	r25, r25
    2128:	88 27       	eor	r24, r24
    212a:	20 91 4d 01 	lds	r18, 0x014D
    212e:	33 27       	eor	r19, r19
    2130:	44 27       	eor	r20, r20
    2132:	55 27       	eor	r21, r21
    2134:	a9 01       	movw	r20, r18
    2136:	33 27       	eor	r19, r19
    2138:	22 27       	eor	r18, r18
    213a:	82 2b       	or	r24, r18
    213c:	93 2b       	or	r25, r19
    213e:	a4 2b       	or	r26, r20
    2140:	b5 2b       	or	r27, r21
    2142:	20 91 4e 01 	lds	r18, 0x014E
    2146:	33 27       	eor	r19, r19
    2148:	44 27       	eor	r20, r20
    214a:	55 27       	eor	r21, r21
    214c:	54 2f       	mov	r21, r20
    214e:	43 2f       	mov	r20, r19
    2150:	32 2f       	mov	r19, r18
    2152:	22 27       	eor	r18, r18
    2154:	82 2b       	or	r24, r18
    2156:	93 2b       	or	r25, r19
    2158:	a4 2b       	or	r26, r20
    215a:	b5 2b       	or	r27, r21
    215c:	20 91 4f 01 	lds	r18, 0x014F
    2160:	33 27       	eor	r19, r19
    2162:	44 27       	eor	r20, r20
    2164:	55 27       	eor	r21, r21
    2166:	82 2b       	or	r24, r18
    2168:	93 2b       	or	r25, r19
    216a:	a4 2b       	or	r26, r20
    216c:	b5 2b       	or	r27, r21
    216e:	80 93 42 01 	sts	0x0142, r24
    2172:	90 93 43 01 	sts	0x0143, r25
    2176:	a0 93 44 01 	sts	0x0144, r26
    217a:	b0 93 45 01 	sts	0x0145, r27
    217e:	c0 93 4c 01 	sts	0x014C, r28
    2182:	12 c0       	rjmp	.+36     	; 0x21a8 <V2P_RunStateMachine+0x2c2>
    2184:	0e 94 95 0e 	call	0x1d2a <V2P_GetSetParamater>
    2188:	11 c0       	rjmp	.+34     	; 0x21ac <V2P_RunStateMachine+0x2c6>
    218a:	e0 91 02 01 	lds	r30, 0x0102
    218e:	f0 91 03 01 	lds	r31, 0x0103
    2192:	09 95       	icall
    2194:	0b c0       	rjmp	.+22     	; 0x21ac <V2P_RunStateMachine+0x2c6>
    2196:	82 e0       	ldi	r24, 0x02	; 2
    2198:	90 e0       	ldi	r25, 0x00	; 0
    219a:	90 93 48 01 	sts	0x0148, r25
    219e:	80 93 47 01 	sts	0x0147, r24
    21a2:	81 ec       	ldi	r24, 0xC1	; 193
    21a4:	80 93 4c 01 	sts	0x014C, r24
    21a8:	0e 94 55 0e 	call	0x1caa <V2P_SendPacket>
    21ac:	c8 e0       	ldi	r28, 0x08	; 8
    21ae:	b1 ce       	rjmp	.-670    	; 0x1f12 <V2P_RunStateMachine+0x2c>
    21b0:	cf 91       	pop	r28
    21b2:	1f 91       	pop	r17
    21b4:	0f 91       	pop	r16
    21b6:	ff 90       	pop	r15
    21b8:	ef 90       	pop	r14
    21ba:	08 95       	ret

000021bc <ISPCC_EnterChipProgrammingMode>:

// ======================================================================================

void ISPCC_EnterChipProgrammingMode(void)
{
    21bc:	0f 93       	push	r16
    21be:	1f 93       	push	r17
    21c0:	cf 93       	push	r28
	uint8_t ByteDelay = PacketBytes[5];
    21c2:	10 91 50 01 	lds	r17, 0x0150
	uint8_t Attempts  = PacketBytes[4];
    21c6:	c0 91 4f 01 	lds	r28, 0x014F
	uint8_t Response;

	MAIN_Delay1MS(PacketBytes[2]);         // Wait before continuing, amount specified in the packet
    21ca:	80 91 4d 01 	lds	r24, 0x014D
    21ce:	0e 94 04 03 	call	0x608 <MAIN_Delay1MS>

	if ((!(Attempts)) || (Attempts > 100)) // if no attempts or too high a value is specified, a fixed number is chosen
    21d2:	8c 2f       	mov	r24, r28
    21d4:	81 50       	subi	r24, 0x01	; 1
    21d6:	84 36       	cpi	r24, 0x64	; 100
    21d8:	08 f0       	brcs	.+2      	; 0x21dc <ISPCC_EnterChipProgrammingMode+0x20>
	   Attempts = 24;
    21da:	c8 e1       	ldi	r28, 0x18	; 24
		
	while (Attempts--)
	{
		USI_SPITransmit(PacketBytes[8]);
		MAIN_Delay1MS(ByteDelay);
		USI_SPITransmit(PacketBytes[9]);
		MAIN_Delay1MS(ByteDelay);
			
		Response = USI_SPITransmit(PacketBytes[10]);
		MAIN_Delay1MS(ByteDelay);

		if (PacketBytes[7] == ISPCC_POLL_MODE_AVR)
		  USI_SPITransmit(PacketBytes[11]);
		else
		  Response = USI_SPITransmit(PacketBytes[11]);
				
		if (!(PacketBytes[7]) || (Response == PacketBytes[6])) // Polling disabled, or returned value matches expected poll value
		{
			MAIN_Delay1MS(ByteDelay);

			InProgrammingMode = TRUE;
			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = STATUS_CMD_OK;
			return;
		}
		
		MAIN_Delay1MS(ByteDelay);
		USI_SPIToggleClock();            // Out of sync, shift in one bit and try again
    21dc:	c1 50       	subi	r28, 0x01	; 1
    21de:	cf 3f       	cpi	r28, 0xFF	; 255
    21e0:	09 f4       	brne	.+2      	; 0x21e4 <ISPCC_EnterChipProgrammingMode+0x28>
    21e2:	3f c0       	rjmp	.+126    	; 0x2262 <ISPCC_EnterChipProgrammingMode+0xa6>
    21e4:	80 91 53 01 	lds	r24, 0x0153
    21e8:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    21ec:	81 2f       	mov	r24, r17
    21ee:	0e 94 04 03 	call	0x608 <MAIN_Delay1MS>
    21f2:	80 91 54 01 	lds	r24, 0x0154
    21f6:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    21fa:	81 2f       	mov	r24, r17
    21fc:	0e 94 04 03 	call	0x608 <MAIN_Delay1MS>
    2200:	80 91 55 01 	lds	r24, 0x0155
    2204:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    2208:	08 2f       	mov	r16, r24
    220a:	81 2f       	mov	r24, r17
    220c:	0e 94 04 03 	call	0x608 <MAIN_Delay1MS>
    2210:	80 91 52 01 	lds	r24, 0x0152
    2214:	83 30       	cpi	r24, 0x03	; 3
    2216:	29 f4       	brne	.+10     	; 0x2222 <ISPCC_EnterChipProgrammingMode+0x66>
    2218:	80 91 56 01 	lds	r24, 0x0156
    221c:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    2220:	05 c0       	rjmp	.+10     	; 0x222c <ISPCC_EnterChipProgrammingMode+0x70>
    2222:	80 91 56 01 	lds	r24, 0x0156
    2226:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    222a:	08 2f       	mov	r16, r24
    222c:	80 91 52 01 	lds	r24, 0x0152
    2230:	88 23       	and	r24, r24
    2232:	21 f0       	breq	.+8      	; 0x223c <ISPCC_EnterChipProgrammingMode+0x80>
    2234:	80 91 51 01 	lds	r24, 0x0151
    2238:	08 17       	cp	r16, r24
    223a:	69 f4       	brne	.+26     	; 0x2256 <ISPCC_EnterChipProgrammingMode+0x9a>
    223c:	81 2f       	mov	r24, r17
    223e:	0e 94 04 03 	call	0x608 <MAIN_Delay1MS>
    2242:	81 e0       	ldi	r24, 0x01	; 1
    2244:	80 93 46 01 	sts	0x0146, r24
    2248:	81 b3       	in	r24, 0x11	; 17
    224a:	8f 7c       	andi	r24, 0xCF	; 207
    224c:	80 62       	ori	r24, 0x20	; 32
    224e:	81 bb       	out	0x11, r24	; 17
    2250:	10 92 4c 01 	sts	0x014C, r1
    2254:	0d c0       	rjmp	.+26     	; 0x2270 <ISPCC_EnterChipProgrammingMode+0xb4>
    2256:	81 2f       	mov	r24, r17
    2258:	0e 94 04 03 	call	0x608 <MAIN_Delay1MS>
    225c:	0e 94 b9 09 	call	0x1372 <USI_SPIToggleClock>
    2260:	bd cf       	rjmp	.-134    	; 0x21dc <ISPCC_EnterChipProgrammingMode+0x20>
	}

	// If function hasn't returned by now, all the attempts have failed. Show this by
	// resetting the status leds to green (ready) and send a fail message.

	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
    2262:	81 b3       	in	r24, 0x11	; 17
    2264:	8f 7c       	andi	r24, 0xCF	; 207
    2266:	80 61       	ori	r24, 0x10	; 16
    2268:	81 bb       	out	0x11, r24	; 17
	PacketBytes[1] = STATUS_CMD_FAILED;
    226a:	80 ec       	ldi	r24, 0xC0	; 192
    226c:	80 93 4c 01 	sts	0x014C, r24
    2270:	cf 91       	pop	r28
    2272:	1f 91       	pop	r17
    2274:	0f 91       	pop	r16
    2276:	08 95       	ret

00002278 <ISPCC_PollForProgComplete>:
}

void ISPCC_ProgramChip(void)
{
	uint16_t PollAddress  = 0;
	uint8_t  ProgMode     = PacketBytes[3];
	uint8_t  WriteCommand = PacketBytes[5];
	uint16_t StartAddress = (uint16_t)CurrAddress;
	uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
	                      | PacketBytes[2];
	uint8_t  PollType;
	uint8_t  ByteToWrite;
			
	if (ProgMode & ISPCC_PROG_MODE_PAGE)                 // Page writing mode
	{
		for (uint16_t WriteByte = 0; WriteByte < BytesToWrite; WriteByte++) // Transmit the page bytes
		{
			ByteToWrite = PacketBytes[10 + WriteByte];
		
			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) // Flash write mode - word addresses so MSB/LSB masking 
			   USI_SPITransmit(WriteCommand | ((WriteByte & 0x01)? ISPCC_HIGH_BYTE_WRITE : ISPCC_LOW_BYTE_WRITE));
			else                                         // EEPROM write mode - byte addresses so no masking 
			   USI_SPITransmit(WriteCommand);

			USI_SPITransmitWord(CurrAddress & 0xFFFF);    // Only the LSW of the address should be sent
			USI_SPITransmit(ByteToWrite);                 // Send one of the new bytes to be written

			if (!(PollAddress))
			{
				if ((PacketBytes[8] != ByteToWrite)       // Can do polling
				   && ((PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) || ((PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP) && (PacketBytes[9] != ByteToWrite))))
				{
					PollAddress = (CurrAddress & 0xFFFF); // Save the current address
				
					if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
					   PollAddress = ((PollAddress << 1) + (WriteByte & 0x01));
				}
			}

			// Flash addresses are in words; only increment address on odd byte, OR if it's the EEPROM being programmed (byte addresses)
			if ((WriteByte & 0x01) || (PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP))
			   V2P_IncrementCurrAddress();
		}

		PollType = ProgMode;

		if (ProgMode & ISPCC_PROG_MODE_PAGEDONE)         // If this packet is the end of a page, we need to send the program page command
		{
			USI_SPITransmit(PacketBytes[6]);             // Send the write program memory page command
			USI_SPITransmitWord(StartAddress);           // Send the page address word
			USI_SPITransmit(0x00);

			if (!(PollAddress))                          // No polling address
			   PollType = ((ProgMode & ~ISPCC_PAGE_POLLTYPE_MASK) | ISPCC_PAGE_POLLTYPE_WAIT);

			ISPCC_PollForProgComplete(PollType, PollAddress);
		}
	}
	else                                                 // Flash Word writing mode or EEPROM byte writing mode
	{
		for (uint16_t WriteByte = 0; WriteByte < BytesToWrite; WriteByte++)
		{
			ByteToWrite = PacketBytes[10 + WriteByte];

			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
			   USI_SPITransmit(WriteCommand | ((WriteByte & 0x01)? ISPCC_HIGH_BYTE_WRITE : ISPCC_LOW_BYTE_WRITE));
			else
			   USI_SPITransmit(WriteCommand);					
					
			USI_SPITransmitWord(CurrAddress & 0xFFFF);    // Transmit the current address to the slave AVR
			USI_SPITransmit(ByteToWrite);                 // Send one of the new bytes to be written

			PollType = ProgMode;

			if ((PacketBytes[8] != ByteToWrite)           // Can do polling
			   && ((PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) || ((PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP) && (PacketBytes[9] != ByteToWrite))))
			{
				PollAddress = (CurrAddress & 0xFFFF);     // Save the current address;

				if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
				   PollAddress = ((PollAddress << 1) + (WriteByte & 0x01));
			}
			else
			{
				PollType = ((ProgMode & ~ISPCC_WORD_POLLTYPE_MASK) | ISPCC_WORD_POLLTYPE_WAIT);
			}					

			// Flash addresses are in words; only increment address on the odd byte, OR if it's the EEPROM being programmed (byte addresses)
			if ((WriteByte & 0x01) || (PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP))
			   V2P_IncrementCurrAddress();

			ISPCC_PollForProgComplete(PollType, PollAddress);
		}
	}
}

void ISPCC_PollForProgComplete(const uint8_t PollData, uint16_t PollAddr)
{
    2278:	1f 93       	push	r17
    227a:	cf 93       	push	r28
    227c:	df 93       	push	r29
    227e:	eb 01       	movw	r28, r22
	uint8_t PollType;
	uint8_t ProgCommand;

	if (PollData & ISPCC_PROG_MODE_PAGE)
    2280:	99 27       	eor	r25, r25
    2282:	80 ff       	sbrs	r24, 0
    2284:	08 c0       	rjmp	.+16     	; 0x2296 <ISPCC_PollForProgComplete+0x1e>
	   PollType = ((PollData & ISPCC_PAGE_POLLTYPE_MASK) >> ISPCC_PAGE_POLLTYPE_MASKSHIFT);
    2286:	80 77       	andi	r24, 0x70	; 112
    2288:	90 70       	andi	r25, 0x00	; 0
    228a:	34 e0       	ldi	r19, 0x04	; 4
    228c:	95 95       	asr	r25
    228e:	87 95       	ror	r24
    2290:	3a 95       	dec	r19
    2292:	e1 f7       	brne	.-8      	; 0x228c <ISPCC_PollForProgComplete+0x14>
    2294:	04 c0       	rjmp	.+8      	; 0x229e <ISPCC_PollForProgComplete+0x26>
	else
	   PollType = ((PollData & ISPCC_WORD_POLLTYPE_MASK) >> ISPCC_WORD_POLLTYPE_MASKSHIFT);	
    2296:	8e 70       	andi	r24, 0x0E	; 14
    2298:	90 70       	andi	r25, 0x00	; 0
    229a:	95 95       	asr	r25
    229c:	87 95       	ror	r24

	switch (PollType & ISPCC_POLLTYPE_MASK)
    229e:	99 27       	eor	r25, r25
    22a0:	87 70       	andi	r24, 0x07	; 7
    22a2:	90 70       	andi	r25, 0x00	; 0
    22a4:	82 30       	cpi	r24, 0x02	; 2
    22a6:	91 05       	cpc	r25, r1
    22a8:	19 f0       	breq	.+6      	; 0x22b0 <ISPCC_PollForProgComplete+0x38>
    22aa:	04 97       	sbiw	r24, 0x04	; 4
    22ac:	e1 f0       	breq	.+56     	; 0x22e6 <ISPCC_PollForProgComplete+0x6e>
    22ae:	26 c0       	rjmp	.+76     	; 0x22fc <ISPCC_PollForProgComplete+0x84>
	{
		case ISPCC_POLLTYPE_DATA:
			ProgCommand = PacketBytes[7];
    22b0:	10 91 52 01 	lds	r17, 0x0152
			
			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) // Flash uses word addresses
    22b4:	80 91 4b 01 	lds	r24, 0x014B
    22b8:	83 31       	cpi	r24, 0x13	; 19
    22ba:	39 f4       	brne	.+14     	; 0x22ca <ISPCC_PollForProgComplete+0x52>
			{
				ProgCommand  |= ((PollAddr & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ);
    22bc:	81 2f       	mov	r24, r17
    22be:	99 27       	eor	r25, r25
    22c0:	c0 fd       	sbrc	r28, 0
    22c2:	88 60       	ori	r24, 0x08	; 8
    22c4:	18 2f       	mov	r17, r24
				PollAddr    >>= 1;
    22c6:	d6 95       	lsr	r29
    22c8:	c7 95       	ror	r28
			}

			do
			{
				USI_SPITransmit(ProgCommand);
    22ca:	81 2f       	mov	r24, r17
    22cc:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
				USI_SPITransmitWord(PollAddr);
    22d0:	ce 01       	movw	r24, r28
    22d2:	0e 94 ab 09 	call	0x1356 <USI_SPITransmitWord>
			}
    22d6:	80 e0       	ldi	r24, 0x00	; 0
    22d8:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    22dc:	90 91 53 01 	lds	r25, 0x0153
    22e0:	89 17       	cp	r24, r25
    22e2:	99 f3       	breq	.-26     	; 0x22ca <ISPCC_PollForProgComplete+0x52>
			while (USI_SPITransmit(0x00) == PacketBytes[8]);
						
			break;
    22e4:	0f c0       	rjmp	.+30     	; 0x2304 <ISPCC_PollForProgComplete+0x8c>
		case ISPCC_POLLTYPE_READY:
			do
			   USI_SPITransmitWord(0xF000);
    22e6:	80 e0       	ldi	r24, 0x00	; 0
    22e8:	90 ef       	ldi	r25, 0xF0	; 240
    22ea:	0e 94 ab 09 	call	0x1356 <USI_SPITransmitWord>
    22ee:	80 e0       	ldi	r24, 0x00	; 0
    22f0:	90 e0       	ldi	r25, 0x00	; 0
    22f2:	0e 94 ab 09 	call	0x1356 <USI_SPITransmitWord>
    22f6:	80 fd       	sbrc	r24, 0
    22f8:	f6 cf       	rjmp	.-20     	; 0x22e6 <ISPCC_PollForProgComplete+0x6e>
			while (USI_SPITransmitWord(0x0000) & ISPCC_POLL_BUSYFLAG);

			break;
    22fa:	04 c0       	rjmp	.+8      	; 0x2304 <ISPCC_PollForProgComplete+0x8c>
		default:                                      // Default is Wait polling
			MAIN_Delay1MS(PacketBytes[4]);	
    22fc:	80 91 4f 01 	lds	r24, 0x014F
    2300:	0e 94 04 03 	call	0x608 <MAIN_Delay1MS>
    2304:	df 91       	pop	r29
    2306:	cf 91       	pop	r28
    2308:	1f 91       	pop	r17
    230a:	08 95       	ret

0000230c <ISPCC_ProgramChip>:
    230c:	6f 92       	push	r6
    230e:	7f 92       	push	r7
    2310:	9f 92       	push	r9
    2312:	af 92       	push	r10
    2314:	bf 92       	push	r11
    2316:	cf 92       	push	r12
    2318:	df 92       	push	r13
    231a:	ef 92       	push	r14
    231c:	ff 92       	push	r15
    231e:	0f 93       	push	r16
    2320:	1f 93       	push	r17
    2322:	cf 93       	push	r28
    2324:	df 93       	push	r29
    2326:	00 e0       	ldi	r16, 0x00	; 0
    2328:	10 e0       	ldi	r17, 0x00	; 0
    232a:	90 90 4e 01 	lds	r9, 0x014E
    232e:	c0 90 50 01 	lds	r12, 0x0150
    2332:	60 90 42 01 	lds	r6, 0x0142
    2336:	70 90 43 01 	lds	r7, 0x0143
    233a:	80 91 4c 01 	lds	r24, 0x014C
    233e:	99 27       	eor	r25, r25
    2340:	b8 2e       	mov	r11, r24
    2342:	aa 24       	eor	r10, r10
    2344:	80 91 4d 01 	lds	r24, 0x014D
    2348:	99 27       	eor	r25, r25
    234a:	a8 2a       	or	r10, r24
    234c:	b9 2a       	or	r11, r25
    234e:	90 fe       	sbrs	r9, 0
    2350:	62 c0       	rjmp	.+196    	; 0x2416 <ISPCC_ProgramChip+0x10a>
    2352:	78 01       	movw	r14, r16
    2354:	0a 15       	cp	r16, r10
    2356:	1b 05       	cpc	r17, r11
    2358:	08 f0       	brcs	.+2      	; 0x235c <ISPCC_ProgramChip+0x50>
    235a:	46 c0       	rjmp	.+140    	; 0x23e8 <ISPCC_ProgramChip+0xdc>
    235c:	c5 e5       	ldi	r28, 0x55	; 85
    235e:	d1 e0       	ldi	r29, 0x01	; 1
    2360:	d9 90       	ld	r13, Y+
    2362:	80 91 4b 01 	lds	r24, 0x014B
    2366:	83 31       	cpi	r24, 0x13	; 19
    2368:	31 f4       	brne	.+12     	; 0x2376 <ISPCC_ProgramChip+0x6a>
    236a:	8c 2d       	mov	r24, r12
    236c:	99 27       	eor	r25, r25
    236e:	e0 fe       	sbrs	r14, 0
    2370:	03 c0       	rjmp	.+6      	; 0x2378 <ISPCC_ProgramChip+0x6c>
    2372:	88 60       	ori	r24, 0x08	; 8
    2374:	01 c0       	rjmp	.+2      	; 0x2378 <ISPCC_ProgramChip+0x6c>
    2376:	8c 2d       	mov	r24, r12
    2378:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    237c:	80 91 42 01 	lds	r24, 0x0142
    2380:	90 91 43 01 	lds	r25, 0x0143
    2384:	0e 94 ab 09 	call	0x1356 <USI_SPITransmitWord>
    2388:	8d 2d       	mov	r24, r13
    238a:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    238e:	01 15       	cp	r16, r1
    2390:	11 05       	cpc	r17, r1
    2392:	d9 f4       	brne	.+54     	; 0x23ca <ISPCC_ProgramChip+0xbe>
    2394:	80 91 53 01 	lds	r24, 0x0153
    2398:	8d 15       	cp	r24, r13
    239a:	b9 f0       	breq	.+46     	; 0x23ca <ISPCC_ProgramChip+0xbe>
    239c:	90 91 4b 01 	lds	r25, 0x014B
    23a0:	93 31       	cpi	r25, 0x13	; 19
    23a2:	31 f0       	breq	.+12     	; 0x23b0 <ISPCC_ProgramChip+0xa4>
    23a4:	95 31       	cpi	r25, 0x15	; 21
    23a6:	89 f4       	brne	.+34     	; 0x23ca <ISPCC_ProgramChip+0xbe>
    23a8:	80 91 54 01 	lds	r24, 0x0154
    23ac:	8d 15       	cp	r24, r13
    23ae:	69 f0       	breq	.+26     	; 0x23ca <ISPCC_ProgramChip+0xbe>
    23b0:	00 91 42 01 	lds	r16, 0x0142
    23b4:	10 91 43 01 	lds	r17, 0x0143
    23b8:	93 31       	cpi	r25, 0x13	; 19
    23ba:	39 f4       	brne	.+14     	; 0x23ca <ISPCC_ProgramChip+0xbe>
    23bc:	00 0f       	add	r16, r16
    23be:	11 1f       	adc	r17, r17
    23c0:	c7 01       	movw	r24, r14
    23c2:	81 70       	andi	r24, 0x01	; 1
    23c4:	90 70       	andi	r25, 0x00	; 0
    23c6:	08 0f       	add	r16, r24
    23c8:	19 1f       	adc	r17, r25
    23ca:	e0 fc       	sbrc	r14, 0
    23cc:	04 c0       	rjmp	.+8      	; 0x23d6 <ISPCC_ProgramChip+0xca>
    23ce:	80 91 4b 01 	lds	r24, 0x014B
    23d2:	85 31       	cpi	r24, 0x15	; 21
    23d4:	11 f4       	brne	.+4      	; 0x23da <ISPCC_ProgramChip+0xce>
    23d6:	0e 94 36 0f 	call	0x1e6c <V2P_IncrementCurrAddress>
    23da:	08 94       	sec
    23dc:	e1 1c       	adc	r14, r1
    23de:	f1 1c       	adc	r15, r1
    23e0:	ea 14       	cp	r14, r10
    23e2:	fb 04       	cpc	r15, r11
    23e4:	08 f4       	brcc	.+2      	; 0x23e8 <ISPCC_ProgramChip+0xdc>
    23e6:	bc cf       	rjmp	.-136    	; 0x2360 <ISPCC_ProgramChip+0x54>
    23e8:	c9 2d       	mov	r28, r9
    23ea:	97 fe       	sbrs	r9, 7
    23ec:	69 c0       	rjmp	.+210    	; 0x24c0 <ISPCC_ProgramChip+0x1b4>
    23ee:	80 91 51 01 	lds	r24, 0x0151
    23f2:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    23f6:	c3 01       	movw	r24, r6
    23f8:	0e 94 ab 09 	call	0x1356 <USI_SPITransmitWord>
    23fc:	80 e0       	ldi	r24, 0x00	; 0
    23fe:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    2402:	01 15       	cp	r16, r1
    2404:	11 05       	cpc	r17, r1
    2406:	11 f4       	brne	.+4      	; 0x240c <ISPCC_ProgramChip+0x100>
    2408:	cf 78       	andi	r28, 0x8F	; 143
    240a:	c0 61       	ori	r28, 0x10	; 16
    240c:	b8 01       	movw	r22, r16
    240e:	8c 2f       	mov	r24, r28
    2410:	0e 94 3c 11 	call	0x2278 <ISPCC_PollForProgComplete>
    2414:	55 c0       	rjmp	.+170    	; 0x24c0 <ISPCC_ProgramChip+0x1b4>
    2416:	78 01       	movw	r14, r16
    2418:	0a 15       	cp	r16, r10
    241a:	1b 05       	cpc	r17, r11
    241c:	08 f0       	brcs	.+2      	; 0x2420 <ISPCC_ProgramChip+0x114>
    241e:	50 c0       	rjmp	.+160    	; 0x24c0 <ISPCC_ProgramChip+0x1b4>
    2420:	55 e5       	ldi	r21, 0x55	; 85
    2422:	65 2e       	mov	r6, r21
    2424:	51 e0       	ldi	r21, 0x01	; 1
    2426:	75 2e       	mov	r7, r21
    2428:	f3 01       	movw	r30, r6
    242a:	d1 90       	ld	r13, Z+
    242c:	3f 01       	movw	r6, r30
    242e:	80 91 4b 01 	lds	r24, 0x014B
    2432:	83 31       	cpi	r24, 0x13	; 19
    2434:	31 f4       	brne	.+12     	; 0x2442 <ISPCC_ProgramChip+0x136>
    2436:	8c 2d       	mov	r24, r12
    2438:	99 27       	eor	r25, r25
    243a:	e0 fe       	sbrs	r14, 0
    243c:	03 c0       	rjmp	.+6      	; 0x2444 <ISPCC_ProgramChip+0x138>
    243e:	88 60       	ori	r24, 0x08	; 8
    2440:	01 c0       	rjmp	.+2      	; 0x2444 <ISPCC_ProgramChip+0x138>
    2442:	8c 2d       	mov	r24, r12
    2444:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    2448:	80 91 42 01 	lds	r24, 0x0142
    244c:	90 91 43 01 	lds	r25, 0x0143
    2450:	0e 94 ab 09 	call	0x1356 <USI_SPITransmitWord>
    2454:	8d 2d       	mov	r24, r13
    2456:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    245a:	c9 2d       	mov	r28, r9
    245c:	80 91 53 01 	lds	r24, 0x0153
    2460:	8d 15       	cp	r24, r13
    2462:	c1 f0       	breq	.+48     	; 0x2494 <ISPCC_ProgramChip+0x188>
    2464:	90 91 4b 01 	lds	r25, 0x014B
    2468:	93 31       	cpi	r25, 0x13	; 19
    246a:	31 f0       	breq	.+12     	; 0x2478 <ISPCC_ProgramChip+0x16c>
    246c:	95 31       	cpi	r25, 0x15	; 21
    246e:	91 f4       	brne	.+36     	; 0x2494 <ISPCC_ProgramChip+0x188>
    2470:	80 91 54 01 	lds	r24, 0x0154
    2474:	8d 15       	cp	r24, r13
    2476:	71 f0       	breq	.+28     	; 0x2494 <ISPCC_ProgramChip+0x188>
    2478:	00 91 42 01 	lds	r16, 0x0142
    247c:	10 91 43 01 	lds	r17, 0x0143
    2480:	93 31       	cpi	r25, 0x13	; 19
    2482:	59 f4       	brne	.+22     	; 0x249a <ISPCC_ProgramChip+0x18e>
    2484:	00 0f       	add	r16, r16
    2486:	11 1f       	adc	r17, r17
    2488:	c7 01       	movw	r24, r14
    248a:	81 70       	andi	r24, 0x01	; 1
    248c:	90 70       	andi	r25, 0x00	; 0
    248e:	08 0f       	add	r16, r24
    2490:	19 1f       	adc	r17, r25
    2492:	03 c0       	rjmp	.+6      	; 0x249a <ISPCC_ProgramChip+0x18e>
    2494:	c9 2d       	mov	r28, r9
    2496:	c1 7f       	andi	r28, 0xF1	; 241
    2498:	c2 60       	ori	r28, 0x02	; 2
    249a:	e0 fc       	sbrc	r14, 0
    249c:	04 c0       	rjmp	.+8      	; 0x24a6 <ISPCC_ProgramChip+0x19a>
    249e:	80 91 4b 01 	lds	r24, 0x014B
    24a2:	85 31       	cpi	r24, 0x15	; 21
    24a4:	11 f4       	brne	.+4      	; 0x24aa <ISPCC_ProgramChip+0x19e>
    24a6:	0e 94 36 0f 	call	0x1e6c <V2P_IncrementCurrAddress>
    24aa:	b8 01       	movw	r22, r16
    24ac:	8c 2f       	mov	r24, r28
    24ae:	0e 94 3c 11 	call	0x2278 <ISPCC_PollForProgComplete>
    24b2:	08 94       	sec
    24b4:	e1 1c       	adc	r14, r1
    24b6:	f1 1c       	adc	r15, r1
    24b8:	ea 14       	cp	r14, r10
    24ba:	fb 04       	cpc	r15, r11
    24bc:	08 f4       	brcc	.+2      	; 0x24c0 <ISPCC_ProgramChip+0x1b4>
    24be:	b4 cf       	rjmp	.-152    	; 0x2428 <ISPCC_ProgramChip+0x11c>
    24c0:	df 91       	pop	r29
    24c2:	cf 91       	pop	r28
    24c4:	1f 91       	pop	r17
    24c6:	0f 91       	pop	r16
    24c8:	ff 90       	pop	r15
    24ca:	ef 90       	pop	r14
    24cc:	df 90       	pop	r13
    24ce:	cf 90       	pop	r12
    24d0:	bf 90       	pop	r11
    24d2:	af 90       	pop	r10
    24d4:	9f 90       	pop	r9
    24d6:	7f 90       	pop	r7
    24d8:	6f 90       	pop	r6
    24da:	08 95       	ret

000024dc <AICI_InterpretPacket>:

// ======================================================================================

void AICI_InterpretPacket(void)
{
    24dc:	df 92       	push	r13
    24de:	ef 92       	push	r14
    24e0:	ff 92       	push	r15
    24e2:	0f 93       	push	r16
    24e4:	1f 93       	push	r17
    24e6:	cf 93       	push	r28
    24e8:	df 93       	push	r29
	switch (PacketBytes[0])
    24ea:	80 91 4b 01 	lds	r24, 0x014B
    24ee:	99 27       	eor	r25, r25
    24f0:	86 31       	cpi	r24, 0x16	; 22
    24f2:	91 05       	cpc	r25, r1
    24f4:	09 f4       	brne	.+2      	; 0x24f8 <AICI_InterpretPacket+0x1c>
    24f6:	fb c0       	rjmp	.+502    	; 0x26ee <AICI_InterpretPacket+0x212>
    24f8:	87 31       	cpi	r24, 0x17	; 23
    24fa:	91 05       	cpc	r25, r1
    24fc:	94 f4       	brge	.+36     	; 0x2522 <AICI_InterpretPacket+0x46>
    24fe:	82 31       	cpi	r24, 0x12	; 18
    2500:	91 05       	cpc	r25, r1
    2502:	09 f4       	brne	.+2      	; 0x2506 <AICI_InterpretPacket+0x2a>
    2504:	60 c0       	rjmp	.+192    	; 0x25c6 <AICI_InterpretPacket+0xea>
    2506:	83 31       	cpi	r24, 0x13	; 19
    2508:	91 05       	cpc	r25, r1
    250a:	3c f4       	brge	.+14     	; 0x251a <AICI_InterpretPacket+0x3e>
    250c:	80 31       	cpi	r24, 0x10	; 16
    250e:	91 05       	cpc	r25, r1
    2510:	f9 f0       	breq	.+62     	; 0x2550 <AICI_InterpretPacket+0x74>
    2512:	41 97       	sbiw	r24, 0x11	; 17
    2514:	09 f4       	brne	.+2      	; 0x2518 <AICI_InterpretPacket+0x3c>
    2516:	3d c0       	rjmp	.+122    	; 0x2592 <AICI_InterpretPacket+0xb6>
    2518:	3e c1       	rjmp	.+636    	; 0x2796 <AICI_InterpretPacket+0x2ba>
    251a:	44 97       	sbiw	r24, 0x14	; 20
    251c:	09 f4       	brne	.+2      	; 0x2520 <AICI_InterpretPacket+0x44>
    251e:	e7 c0       	rjmp	.+462    	; 0x26ee <AICI_InterpretPacket+0x212>
    2520:	2f c1       	rjmp	.+606    	; 0x2780 <AICI_InterpretPacket+0x2a4>
    2522:	89 31       	cpi	r24, 0x19	; 25
    2524:	91 05       	cpc	r25, r1
    2526:	09 f4       	brne	.+2      	; 0x252a <AICI_InterpretPacket+0x4e>
    2528:	cc c0       	rjmp	.+408    	; 0x26c2 <AICI_InterpretPacket+0x1e6>
    252a:	8a 31       	cpi	r24, 0x1A	; 26
    252c:	91 05       	cpc	r25, r1
    252e:	44 f4       	brge	.+16     	; 0x2540 <AICI_InterpretPacket+0x64>
    2530:	87 31       	cpi	r24, 0x17	; 23
    2532:	91 05       	cpc	r25, r1
    2534:	09 f4       	brne	.+2      	; 0x2538 <AICI_InterpretPacket+0x5c>
    2536:	c5 c0       	rjmp	.+394    	; 0x26c2 <AICI_InterpretPacket+0x1e6>
    2538:	48 97       	sbiw	r24, 0x18	; 24
    253a:	09 f4       	brne	.+2      	; 0x253e <AICI_InterpretPacket+0x62>
    253c:	a5 c0       	rjmp	.+330    	; 0x2688 <AICI_InterpretPacket+0x1ac>
    253e:	2b c1       	rjmp	.+598    	; 0x2796 <AICI_InterpretPacket+0x2ba>
    2540:	8d 31       	cpi	r24, 0x1D	; 29
    2542:	91 05       	cpc	r25, r1
    2544:	0c f4       	brge	.+2      	; 0x2548 <AICI_InterpretPacket+0x6c>
    2546:	a0 c0       	rjmp	.+320    	; 0x2688 <AICI_InterpretPacket+0x1ac>
    2548:	4d 97       	sbiw	r24, 0x1d	; 29
    254a:	09 f4       	brne	.+2      	; 0x254e <AICI_InterpretPacket+0x72>
    254c:	61 c0       	rjmp	.+194    	; 0x2610 <AICI_InterpretPacket+0x134>
    254e:	23 c1       	rjmp	.+582    	; 0x2796 <AICI_InterpretPacket+0x2ba>
	{
		case CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
    2550:	82 e0       	ldi	r24, 0x02	; 2
    2552:	90 e0       	ldi	r25, 0x00	; 0
    2554:	90 93 48 01 	sts	0x0148, r25
    2558:	80 93 47 01 	sts	0x0147, r24
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    255c:	a1 e0       	ldi	r26, 0x01	; 1
    255e:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    2560:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
    2564:	80 2d       	mov	r24, r0
    2566:	0e 94 7e 09 	call	0x12fc <USI_SPIInitMaster>
			
			USI_SPIInitMaster(eeprom_read_byte(&EEPROMVars.SCKDuration));

			MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);  // Pull the slave AVR's RESET line to active
    256a:	80 e0       	ldi	r24, 0x00	; 0
    256c:	0e 94 16 03 	call	0x62c <MAIN_ResetCSLine>
			MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE); // Orange = Busy
    2570:	81 b3       	in	r24, 0x11	; 17
    2572:	80 63       	ori	r24, 0x30	; 48
    2574:	81 bb       	out	0x11, r24	; 17
			ISPCC_EnterChipProgrammingMode();       // Run the Enter Programming Mode routine
    2576:	0e 94 de 10 	call	0x21bc <ISPCC_EnterChipProgrammingMode>

			if (InProgrammingMode)
    257a:	80 91 46 01 	lds	r24, 0x0146
    257e:	88 23       	and	r24, r24
    2580:	19 f0       	breq	.+6      	; 0x2588 <AICI_InterpretPacket+0xac>
			   LCD_puts_f(AVRISPModeMessage);
    2582:	82 ef       	ldi	r24, 0xF2	; 242
    2584:	93 e0       	ldi	r25, 0x03	; 3
    2586:	02 c0       	rjmp	.+4      	; 0x258c <AICI_InterpretPacket+0xb0>
			else
			   LCD_puts_f(SyncErrorMessage);
    2588:	87 ee       	ldi	r24, 0xE7	; 231
    258a:	93 e0       	ldi	r25, 0x03	; 3
    258c:	0e 94 4a 08 	call	0x1094 <LCD_puts_f>
			
			break;
    2590:	0b c1       	rjmp	.+534    	; 0x27a8 <AICI_InterpretPacket+0x2cc>
		case CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;
    2592:	82 e0       	ldi	r24, 0x02	; 2
    2594:	90 e0       	ldi	r25, 0x00	; 0
    2596:	90 93 48 01 	sts	0x0148, r25
    259a:	80 93 47 01 	sts	0x0147, r24

			MAIN_Delay1MS(PacketBytes[1]);           // Wait for the "PreDelay" amount specified in the packet
    259e:	80 91 4c 01 	lds	r24, 0x014C
    25a2:	0e 94 04 03 	call	0x608 <MAIN_Delay1MS>
			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Non programming mode = green status led
    25a6:	81 b3       	in	r24, 0x11	; 17
    25a8:	8f 7c       	andi	r24, 0xCF	; 207
    25aa:	80 61       	ori	r24, 0x10	; 16
    25ac:	81 bb       	out	0x11, r24	; 17
			InProgrammingMode = FALSE;
    25ae:	10 92 46 01 	sts	0x0146, r1
			MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run
    25b2:	81 e0       	ldi	r24, 0x01	; 1
    25b4:	0e 94 16 03 	call	0x62c <MAIN_ResetCSLine>
			MAIN_Delay1MS(PacketBytes[2]);           // Wait for the "PostDelay" amount specified in the packet
    25b8:	80 91 4d 01 	lds	r24, 0x014D
    25bc:	0e 94 04 03 	call	0x608 <MAIN_Delay1MS>
			
			USI_SPIOff();
    25c0:	0e 94 8e 09 	call	0x131c <USI_SPIOff>
    25c4:	e5 c0       	rjmp	.+458    	; 0x2790 <AICI_InterpretPacket+0x2b4>

			PacketBytes[1] = STATUS_CMD_OK;      // Return OK

			break;
		case CMD_CHIP_ERASE_ISP:
			MessageSize = 2;
    25c6:	82 e0       	ldi	r24, 0x02	; 2
    25c8:	90 e0       	ldi	r25, 0x00	; 0
    25ca:	90 93 48 01 	sts	0x0148, r25
    25ce:	80 93 47 01 	sts	0x0147, r24
			
			for (uint8_t PacketB = 3; PacketB <= 6; PacketB++) // Send the erase commands to the slave AVR
    25d2:	c3 e0       	ldi	r28, 0x03	; 3
    25d4:	0e e4       	ldi	r16, 0x4E	; 78
    25d6:	11 e0       	ldi	r17, 0x01	; 1
				USI_SPITransmit(PacketBytes[PacketB]);
    25d8:	f8 01       	movw	r30, r16
    25da:	81 91       	ld	r24, Z+
    25dc:	8f 01       	movw	r16, r30
    25de:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    25e2:	c1 50       	subi	r28, 0x01	; 1
    25e4:	c7 ff       	sbrs	r28, 7
    25e6:	f8 cf       	rjmp	.-16     	; 0x25d8 <AICI_InterpretPacket+0xfc>

			if (PacketBytes[2])                  // Poll mode, value of 1 indicates a busy flag wait
    25e8:	80 91 4d 01 	lds	r24, 0x014D
    25ec:	88 23       	and	r24, r24
    25ee:	59 f0       	breq	.+22     	; 0x2606 <AICI_InterpretPacket+0x12a>
			{
				do
					USI_SPITransmitWord(0xF000);
    25f0:	80 e0       	ldi	r24, 0x00	; 0
    25f2:	90 ef       	ldi	r25, 0xF0	; 240
    25f4:	0e 94 ab 09 	call	0x1356 <USI_SPITransmitWord>
    25f8:	80 e0       	ldi	r24, 0x00	; 0
    25fa:	90 e0       	ldi	r25, 0x00	; 0
    25fc:	0e 94 ab 09 	call	0x1356 <USI_SPITransmitWord>
    2600:	80 fd       	sbrc	r24, 0
    2602:	f6 cf       	rjmp	.-20     	; 0x25f0 <AICI_InterpretPacket+0x114>
    2604:	c5 c0       	rjmp	.+394    	; 0x2790 <AICI_InterpretPacket+0x2b4>
				while (USI_SPITransmitWord(0x0000) & 0x01);
			}
			else                                // Poll mode flag of 0 indicates a predefined delay
			{
				MAIN_Delay1MS(PacketBytes[1]);   // Wait the specified interval to ensure erase complete
    2606:	80 91 4c 01 	lds	r24, 0x014C
    260a:	0e 94 04 03 	call	0x608 <MAIN_Delay1MS>
    260e:	c0 c0       	rjmp	.+384    	; 0x2790 <AICI_InterpretPacket+0x2b4>
			}
			
			PacketBytes[1] = STATUS_CMD_OK;      // Always return OK
			
			break;
		case CMD_SPI_MULTI:
				MessageSize = (3 + PacketBytes[2]);    // Number of recieved bytes, plus two OKs and the command byte
    2610:	e0 90 4d 01 	lds	r14, 0x014D
    2614:	8e 2d       	mov	r24, r14
    2616:	99 27       	eor	r25, r25
    2618:	03 96       	adiw	r24, 0x03	; 3
    261a:	90 93 48 01 	sts	0x0148, r25
    261e:	80 93 47 01 	sts	0x0147, r24
		
				uint8_t TxBytes      = PacketBytes[1]; // \. The packet data is overwritten during the transfer. Because
    2622:	00 91 4c 01 	lds	r16, 0x014C
				uint8_t RxStartByte  = PacketBytes[2]; // |  of this each data byte must be stored into temp variables
				uint8_t RxBytes      = PacketBytes[3]; // /  so that their contents are not lost.
    2626:	f0 90 4e 01 	lds	r15, 0x014E
				uint8_t RxByteNum    = 1;
    262a:	c1 e0       	ldi	r28, 0x01	; 1
				uint8_t TxByteNum    = 1;
				uint8_t RecievedByte = 0;

				while (TxByteNum++ < TxBytes)          // Still bytes to transfer
				{
					RecievedByte = USI_SPITransmit(PacketBytes[3 + TxByteNum]); // Transmit the byte, store the answer

					if ((TxByteNum >= RxStartByte) && (RxByteNum < RxBytes))
					   PacketBytes[2 + RxByteNum++] = RecievedByte;
    262c:	12 e0       	ldi	r17, 0x02	; 2
    262e:	c0 17       	cp	r28, r16
    2630:	a8 f4       	brcc	.+42     	; 0x265c <AICI_InterpretPacket+0x180>
    2632:	e1 2f       	mov	r30, r17
    2634:	ff 27       	eor	r31, r31
    2636:	e5 5b       	subi	r30, 0xB5	; 181
    2638:	fe 4f       	sbci	r31, 0xFE	; 254
    263a:	83 81       	ldd	r24, Z+3	; 0x03
    263c:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    2640:	1e 15       	cp	r17, r14
    2642:	40 f0       	brcs	.+16     	; 0x2654 <AICI_InterpretPacket+0x178>
    2644:	cf 15       	cp	r28, r15
    2646:	30 f4       	brcc	.+12     	; 0x2654 <AICI_InterpretPacket+0x178>
    2648:	ec 2f       	mov	r30, r28
    264a:	ff 27       	eor	r31, r31
    264c:	e5 5b       	subi	r30, 0xB5	; 181
    264e:	fe 4f       	sbci	r31, 0xFE	; 254
    2650:	82 83       	std	Z+2, r24	; 0x02
    2652:	cf 5f       	subi	r28, 0xFF	; 255
    2654:	81 2f       	mov	r24, r17
    2656:	1f 5f       	subi	r17, 0xFF	; 255
    2658:	80 17       	cp	r24, r16
    265a:	58 f3       	brcs	.-42     	; 0x2632 <AICI_InterpretPacket+0x156>
				}

				while (RxByteNum++ < RxBytes)                         // Still more bytes to recieve
				   PacketBytes[2 + RxByteNum] = USI_SPITransmit(0x00); // its answer to be recorded (or more bytes than sent need responses), send dummy bytes to fetch the response(s)
    265c:	8c 2f       	mov	r24, r28
    265e:	cf 5f       	subi	r28, 0xFF	; 255
    2660:	8f 15       	cp	r24, r15
    2662:	50 f4       	brcc	.+20     	; 0x2678 <AICI_InterpretPacket+0x19c>
    2664:	0c 2f       	mov	r16, r28
    2666:	11 27       	eor	r17, r17
    2668:	05 5b       	subi	r16, 0xB5	; 181
    266a:	1e 4f       	sbci	r17, 0xFE	; 254
    266c:	80 e0       	ldi	r24, 0x00	; 0
    266e:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    2672:	f8 01       	movw	r30, r16
    2674:	82 83       	std	Z+2, r24	; 0x02
    2676:	f2 cf       	rjmp	.-28     	; 0x265c <AICI_InterpretPacket+0x180>

				PacketBytes[1]             = STATUS_CMD_OK; // Data should be encompassed
    2678:	10 92 4c 01 	sts	0x014C, r1
				PacketBytes[3 + RxByteNum] = STATUS_CMD_OK; //  by STATS_CMD_OKs
    267c:	ec 2f       	mov	r30, r28
    267e:	ff 27       	eor	r31, r31
    2680:	e5 5b       	subi	r30, 0xB5	; 181
    2682:	fe 4f       	sbci	r31, 0xFE	; 254
    2684:	13 82       	std	Z+3, r1	; 0x03

				break;
    2686:	90 c0       	rjmp	.+288    	; 0x27a8 <AICI_InterpretPacket+0x2cc>
		case CMD_READ_SIGNATURE_ISP:
		case CMD_READ_FUSE_ISP:
		case CMD_READ_LOCK_ISP:
		case CMD_READ_OSCCAL_ISP:
			MessageSize = 4;
    2688:	84 e0       	ldi	r24, 0x04	; 4
    268a:	90 e0       	ldi	r25, 0x00	; 0
    268c:	90 93 48 01 	sts	0x0148, r25
    2690:	80 93 47 01 	sts	0x0147, r24
	
			for (uint8_t ByteNum = 1; ByteNum <= 4; ByteNum++)
    2694:	c1 e0       	ldi	r28, 0x01	; 1
    2696:	0d e4       	ldi	r16, 0x4D	; 77
    2698:	11 e0       	ldi	r17, 0x01	; 1
			{
				uint8_t Response = USI_SPITransmit(PacketBytes[1 + ByteNum]); // Transmit the four signature request bytes
    269a:	f8 01       	movw	r30, r16
    269c:	81 91       	ld	r24, Z+
    269e:	8f 01       	movw	r16, r30
    26a0:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    26a4:	98 2f       	mov	r25, r24

				if (ByteNum == PacketBytes[1])         // If the current byte is the requested signature byte, save the reponse in the packet
    26a6:	80 91 4c 01 	lds	r24, 0x014C
    26aa:	c8 17       	cp	r28, r24
    26ac:	11 f4       	brne	.+4      	; 0x26b2 <AICI_InterpretPacket+0x1d6>
					PacketBytes[2] = Response;
    26ae:	90 93 4d 01 	sts	0x014D, r25
    26b2:	cf 5f       	subi	r28, 0xFF	; 255
    26b4:	c5 30       	cpi	r28, 0x05	; 5
    26b6:	88 f3       	brcs	.-30     	; 0x269a <AICI_InterpretPacket+0x1be>
			}

			PacketBytes[1] = STATUS_CMD_OK;            // Data byte is encased in CMD_OKs
    26b8:	10 92 4c 01 	sts	0x014C, r1
			PacketBytes[3] = STATUS_CMD_OK;            // Data byte is encased in CMD_OKs
    26bc:	10 92 4e 01 	sts	0x014E, r1

			break;
    26c0:	73 c0       	rjmp	.+230    	; 0x27a8 <AICI_InterpretPacket+0x2cc>
		case CMD_PROGRAM_FUSE_ISP:
		case CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;
    26c2:	83 e0       	ldi	r24, 0x03	; 3
    26c4:	90 e0       	ldi	r25, 0x00	; 0
    26c6:	90 93 48 01 	sts	0x0148, r25
    26ca:	80 93 47 01 	sts	0x0147, r24
    26ce:	0c e4       	ldi	r16, 0x4C	; 76
    26d0:	11 e0       	ldi	r17, 0x01	; 1
    26d2:	c3 e0       	ldi	r28, 0x03	; 3
			
			for (uint8_t PacketB = 1; PacketB <= 4; PacketB++) // Send the lock-byte values to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    26d4:	f8 01       	movw	r30, r16
    26d6:	81 91       	ld	r24, Z+
    26d8:	8f 01       	movw	r16, r30
    26da:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    26de:	c1 50       	subi	r28, 0x01	; 1
    26e0:	c7 ff       	sbrs	r28, 7
    26e2:	f8 cf       	rjmp	.-16     	; 0x26d4 <AICI_InterpretPacket+0x1f8>

			PacketBytes[1] = STATUS_CMD_OK;            // Two CMD_OKs are always returned
    26e4:	10 92 4c 01 	sts	0x014C, r1
			PacketBytes[2] = STATUS_CMD_OK;            // Two CMD_OKs are always returned
    26e8:	10 92 4d 01 	sts	0x014D, r1

			break;
    26ec:	5d c0       	rjmp	.+186    	; 0x27a8 <AICI_InterpretPacket+0x2cc>
		case CMD_READ_FLASH_ISP:
		case CMD_READ_EEPROM_ISP:
			MessageSize = 0;                           // Here to prevent compiler from complaining if a var dec appears straight after a case

			uint8_t  ReadCommand = PacketBytes[3];
    26ee:	d0 90 4e 01 	lds	r13, 0x014E
			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8) // Load in the number of bytes that is to
    26f2:	80 91 4c 01 	lds	r24, 0x014C
    26f6:	99 27       	eor	r25, r25
    26f8:	d8 2f       	mov	r29, r24
    26fa:	cc 27       	eor	r28, r28
    26fc:	80 91 4d 01 	lds	r24, 0x014D
    2700:	99 27       	eor	r25, r25
    2702:	c8 2b       	or	r28, r24
    2704:	d9 2b       	or	r29, r25
			                     | PacketBytes[2];                 // be read into a temp variable (MSB first)

			MessageSize = BytesToRead + 3;
    2706:	23 96       	adiw	r28, 0x03	; 3
    2708:	d0 93 48 01 	sts	0x0148, r29
    270c:	c0 93 47 01 	sts	0x0147, r28
    2710:	23 97       	sbiw	r28, 0x03	; 3

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
    2712:	00 e0       	ldi	r16, 0x00	; 0
    2714:	10 e0       	ldi	r17, 0x00	; 0
    2716:	0c 17       	cp	r16, r28
    2718:	1d 07       	cpc	r17, r29
    271a:	60 f5       	brcc	.+88     	; 0x2774 <AICI_InterpretPacket+0x298>
    271c:	8d e4       	ldi	r24, 0x4D	; 77
    271e:	e8 2e       	mov	r14, r24
    2720:	81 e0       	ldi	r24, 0x01	; 1
    2722:	f8 2e       	mov	r15, r24
			{
				if (PacketBytes[0] == CMD_READ_FLASH_ISP)  // Flash read mode - word addresses so MSB/LSB masking nessesary
    2724:	80 91 4b 01 	lds	r24, 0x014B
    2728:	84 31       	cpi	r24, 0x14	; 20
    272a:	31 f4       	brne	.+12     	; 0x2738 <AICI_InterpretPacket+0x25c>
				{
					USI_SPITransmit(ReadCommand | ((ReadByte & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ));
    272c:	8d 2d       	mov	r24, r13
    272e:	99 27       	eor	r25, r25
    2730:	00 ff       	sbrs	r16, 0
    2732:	03 c0       	rjmp	.+6      	; 0x273a <AICI_InterpretPacket+0x25e>
    2734:	88 60       	ori	r24, 0x08	; 8
    2736:	01 c0       	rjmp	.+2      	; 0x273a <AICI_InterpretPacket+0x25e>
				}
				else                                       // EEPROM read mode, address is in bytes and so no masking nessesary
				{
					USI_SPITransmit(ReadCommand);
    2738:	8d 2d       	mov	r24, r13
    273a:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
				}
				
				USI_SPITransmitWord(CurrAddress);          // Transmit the current address to the slave AVR
    273e:	80 91 42 01 	lds	r24, 0x0142
    2742:	90 91 43 01 	lds	r25, 0x0143
    2746:	0e 94 ab 09 	call	0x1356 <USI_SPITransmitWord>

				PacketBytes[2 + ReadByte] = USI_SPITransmit(0x00); // Read in the byte stored at the requested location
    274a:	80 e0       	ldi	r24, 0x00	; 0
    274c:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    2750:	f7 01       	movw	r30, r14
    2752:	80 83       	st	Z, r24

				if ((ReadByte & 0x01) || (PacketBytes[0] == CMD_READ_EEPROM_ISP)) // Flash addresses are given in words; only increment on the odd byte if reading the flash.
    2754:	00 fd       	sbrc	r16, 0
    2756:	04 c0       	rjmp	.+8      	; 0x2760 <AICI_InterpretPacket+0x284>
    2758:	80 91 4b 01 	lds	r24, 0x014B
    275c:	86 31       	cpi	r24, 0x16	; 22
    275e:	11 f4       	brne	.+4      	; 0x2764 <AICI_InterpretPacket+0x288>
				{
					V2P_IncrementCurrAddress();             // Increment the address counter
    2760:	0e 94 36 0f 	call	0x1e6c <V2P_IncrementCurrAddress>
    2764:	0f 5f       	subi	r16, 0xFF	; 255
    2766:	1f 4f       	sbci	r17, 0xFF	; 255
    2768:	08 94       	sec
    276a:	e1 1c       	adc	r14, r1
    276c:	f1 1c       	adc	r15, r1
    276e:	0c 17       	cp	r16, r28
    2770:	1d 07       	cpc	r17, r29
    2772:	c0 f2       	brcs	.-80     	; 0x2724 <AICI_InterpretPacket+0x248>
				}
				else
				{
					if ((CurrAddress & 0x00FF0000) & !(CurrAddress & 0x0000FFFF))
					{
						CurrAddress |= (1UL << 31);        // Set MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
						V2P_CheckForExtendedAddress();
					}
				}
			}
			
			PacketBytes[1]               = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    2774:	10 92 4c 01 	sts	0x014C, r1
			PacketBytes[2 + BytesToRead] = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    2778:	c5 5b       	subi	r28, 0xB5	; 181
    277a:	de 4f       	sbci	r29, 0xFE	; 254
    277c:	1a 82       	std	Y+2, r1	; 0x02

			break;
    277e:	14 c0       	rjmp	.+40     	; 0x27a8 <AICI_InterpretPacket+0x2cc>
		case CMD_PROGRAM_FLASH_ISP:
		case CMD_PROGRAM_EEPROM_ISP:
			ISPCC_ProgramChip();                          // Program the bytes into the chip
    2780:	0e 94 86 11 	call	0x230c <ISPCC_ProgramChip>
			
			MessageSize = 2;
    2784:	82 e0       	ldi	r24, 0x02	; 2
    2786:	90 e0       	ldi	r25, 0x00	; 0
    2788:	90 93 48 01 	sts	0x0148, r25
    278c:	80 93 47 01 	sts	0x0147, r24

			PacketBytes[1] = STATUS_CMD_OK;
    2790:	10 92 4c 01 	sts	0x014C, r1
			
			break;
    2794:	09 c0       	rjmp	.+18     	; 0x27a8 <AICI_InterpretPacket+0x2cc>
		default:                                        // Unknown command, return error
			MessageSize = 1;
    2796:	81 e0       	ldi	r24, 0x01	; 1
    2798:	90 e0       	ldi	r25, 0x00	; 0
    279a:	90 93 48 01 	sts	0x0148, r25
    279e:	80 93 47 01 	sts	0x0147, r24
			
			PacketBytes[1] = STATUS_CMD_UNKNOWN;
    27a2:	89 ec       	ldi	r24, 0xC9	; 201
    27a4:	80 93 4c 01 	sts	0x014C, r24
	}

	V2P_SendPacket();                                   // Send the response packet
    27a8:	0e 94 55 0e 	call	0x1caa <V2P_SendPacket>
    27ac:	df 91       	pop	r29
    27ae:	cf 91       	pop	r28
    27b0:	1f 91       	pop	r17
    27b2:	0f 91       	pop	r16
    27b4:	ff 90       	pop	r15
    27b6:	ef 90       	pop	r14
    27b8:	df 90       	pop	r13
    27ba:	08 95       	ret

000027bc <PM_GetStoredDataSize>:

// ======================================================================================

uint32_t PM_GetStoredDataSize(const uint8_t Type)
{
    27bc:	cf 93       	push	r28
    27be:	df 93       	push	r29
    27c0:	cd b7       	in	r28, 0x3d	; 61
    27c2:	de b7       	in	r29, 0x3e	; 62
    27c4:	24 97       	sbiw	r28, 0x04	; 4
    27c6:	0f b6       	in	r0, 0x3f	; 63
    27c8:	f8 94       	cli
    27ca:	de bf       	out	0x3e, r29	; 62
    27cc:	0f be       	out	0x3f, r0	; 63
    27ce:	cd bf       	out	0x3d, r28	; 61
	/* This take a **LOT** of code and is accessed several times throughout
	   the program, so I've put it into a seperate function to save on flash. */

	uint32_t ProgDataSize = 0;
    27d0:	19 82       	std	Y+1, r1	; 0x01
    27d2:	1a 82       	std	Y+2, r1	; 0x02
    27d4:	1b 82       	std	Y+3, r1	; 0x03
    27d6:	1c 82       	std	Y+4, r1	; 0x04
void 
eeprom_read_block (void *pointer_ram,
                   const void *pointer_eeprom,
                   size_t n)
{
    27d8:	fe 01       	movw	r30, r28
    27da:	31 96       	adiw	r30, 0x01	; 1
    27dc:	81 30       	cpi	r24, 0x01	; 1
    27de:	19 f4       	brne	.+6      	; 0x27e6 <PM_GetStoredDataSize+0x2a>
    27e0:	ab e1       	ldi	r26, 0x1B	; 27
    27e2:	b0 e0       	ldi	r27, 0x00	; 0
    27e4:	02 c0       	rjmp	.+4      	; 0x27ea <PM_GetStoredDataSize+0x2e>
    27e6:	af e1       	ldi	r26, 0x1F	; 31
    27e8:	b0 e0       	ldi	r27, 0x00	; 0
  if (!__builtin_constant_p (n)
      || n > 256)
    {
      /* make sure size is a 16 bit variable.  */
      uint16_t size = n; 

      asm volatile ( 
            ".%=_start:" CR_TAB
            "sbiw %2,1" CR_TAB
            "brlt .%=_finished" CR_TAB
             XCALL " __eeprom_read_byte_" _REG_LOCATION_SUFFIX CR_TAB
            "st z+,__tmp_reg__" CR_TAB
            "rjmp .%=_start" CR_TAB
            ".%=_finished:" 
          : "=x" (pointer_eeprom),
            "=z" (pointer_ram),
            "+w" (size)
           : "x" (pointer_eeprom), 
             "z" (pointer_ram)
           : "memory");
    }
  else
    {
      if (n != 0)
        {
          if (n == 256)
            {
              asm volatile (
                  XCALL " __eeprom_read_block_" _REG_LOCATION_SUFFIX 
                : "+x" (pointer_eeprom),
                  "=z" (pointer_ram)
                : "z"  (pointer_ram)
                : "memory");
            }
          else
            {
              /* Needed in order to truncate to 8 bit.  */
              uint8_t len;
              len = (uint8_t) n; 
    27ea:	84 e0       	ldi	r24, 0x04	; 4

              asm volatile (
    27ec:	18 2e       	mov	r1, r24
    27ee:	0e 94 5a 1a 	call	0x34b4 <__eeprom_read_block_1F2021>

	eeprom_read_block((void*)&ProgDataSize, (const void*)((Type == TYPE_FLASH)? &EEPROMVars.DataSize : &EEPROMVars.EEPROMSize), sizeof(uint32_t));

	if (ProgDataSize == 0xFFFFFFFF)                                      // Blank EEPROM, return a size  of 0 bytes
    27f2:	89 81       	ldd	r24, Y+1	; 0x01
    27f4:	9a 81       	ldd	r25, Y+2	; 0x02
    27f6:	ab 81       	ldd	r26, Y+3	; 0x03
    27f8:	bc 81       	ldd	r27, Y+4	; 0x04
    27fa:	8f 5f       	subi	r24, 0xFF	; 255
    27fc:	9f 4f       	sbci	r25, 0xFF	; 255
    27fe:	af 4f       	sbci	r26, 0xFF	; 255
    2800:	bf 4f       	sbci	r27, 0xFF	; 255
    2802:	21 f4       	brne	.+8      	; 0x280c <PM_GetStoredDataSize+0x50>
	  ProgDataSize = 0x00;
    2804:	19 82       	std	Y+1, r1	; 0x01
    2806:	1a 82       	std	Y+2, r1	; 0x02
    2808:	1b 82       	std	Y+3, r1	; 0x03
    280a:	1c 82       	std	Y+4, r1	; 0x04

	return ProgDataSize;
    280c:	89 81       	ldd	r24, Y+1	; 0x01
    280e:	9a 81       	ldd	r25, Y+2	; 0x02
    2810:	ab 81       	ldd	r26, Y+3	; 0x03
    2812:	bc 81       	ldd	r27, Y+4	; 0x04
}
    2814:	bc 01       	movw	r22, r24
    2816:	cd 01       	movw	r24, r26
    2818:	24 96       	adiw	r28, 0x04	; 4
    281a:	0f b6       	in	r0, 0x3f	; 63
    281c:	f8 94       	cli
    281e:	de bf       	out	0x3e, r29	; 62
    2820:	0f be       	out	0x3f, r0	; 63
    2822:	cd bf       	out	0x3d, r28	; 61
    2824:	df 91       	pop	r29
    2826:	cf 91       	pop	r28
    2828:	08 95       	ret

0000282a <PM_SetupDFAddressCounters>:

void PM_SetupDFAddressCounters(const uint8_t Type)
{
	uint32_t StartAddress;
	
	MemoryType  = Type;
    282a:	80 93 61 02 	sts	0x0261, r24
	GPageLength = 0;
    282e:	10 92 5f 02 	sts	0x025F, r1
    2832:	10 92 5e 02 	sts	0x025E, r1
    2836:	20 91 42 01 	lds	r18, 0x0142
    283a:	30 91 43 01 	lds	r19, 0x0143
    283e:	40 91 44 01 	lds	r20, 0x0144
    2842:	50 91 45 01 	lds	r21, 0x0145

	if (Type == TYPE_FLASH)                                              // Type 1 = Flash
    2846:	81 30       	cpi	r24, 0x01	; 1
    2848:	39 f4       	brne	.+14     	; 0x2858 <PM_SetupDFAddressCounters+0x2e>
	  StartAddress = (CurrAddress << 1);                               // Convert flash word address to byte address
    284a:	da 01       	movw	r26, r20
    284c:	c9 01       	movw	r24, r18
    284e:	88 0f       	add	r24, r24
    2850:	99 1f       	adc	r25, r25
    2852:	aa 1f       	adc	r26, r26
    2854:	bb 1f       	adc	r27, r27
    2856:	06 c0       	rjmp	.+12     	; 0x2864 <PM_SetupDFAddressCounters+0x3a>
	else
	  StartAddress = CurrAddress + PM_EEPROM_OFFSET;                   // EEPROM uses byte addresses, and starts at the 257th kilobyte in Dataflash
    2858:	da 01       	movw	r26, r20
    285a:	c9 01       	movw	r24, r18
    285c:	80 50       	subi	r24, 0x00	; 0
    285e:	9c 4f       	sbci	r25, 0xFC	; 252
    2860:	ab 4f       	sbci	r26, 0xFB	; 251
    2862:	bf 4f       	sbci	r27, 0xFF	; 255
	
	CurrPageAddress = 0;
    2864:	10 92 6e 02 	sts	0x026E, r1
    2868:	10 92 6d 02 	sts	0x026D, r1

	while (StartAddress >= DF_INTERNALDF_BUFFBYTES)                      // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DF_INTERNALDF_BUFFBYTES;                         // Subtract one page's worth of bytes from the desired address
		CurrPageAddress++;
    286c:	88 30       	cpi	r24, 0x08	; 8
    286e:	21 e0       	ldi	r18, 0x01	; 1
    2870:	92 07       	cpc	r25, r18
    2872:	20 e0       	ldi	r18, 0x00	; 0
    2874:	a2 07       	cpc	r26, r18
    2876:	20 e0       	ldi	r18, 0x00	; 0
    2878:	b2 07       	cpc	r27, r18
    287a:	a0 f0       	brcs	.+40     	; 0x28a4 <PM_SetupDFAddressCounters+0x7a>
    287c:	20 e0       	ldi	r18, 0x00	; 0
    287e:	30 e0       	ldi	r19, 0x00	; 0
    2880:	88 50       	subi	r24, 0x08	; 8
    2882:	91 40       	sbci	r25, 0x01	; 1
    2884:	a0 40       	sbci	r26, 0x00	; 0
    2886:	b0 40       	sbci	r27, 0x00	; 0
    2888:	2f 5f       	subi	r18, 0xFF	; 255
    288a:	3f 4f       	sbci	r19, 0xFF	; 255
    288c:	88 30       	cpi	r24, 0x08	; 8
    288e:	41 e0       	ldi	r20, 0x01	; 1
    2890:	94 07       	cpc	r25, r20
    2892:	40 e0       	ldi	r20, 0x00	; 0
    2894:	a4 07       	cpc	r26, r20
    2896:	40 e0       	ldi	r20, 0x00	; 0
    2898:	b4 07       	cpc	r27, r20
    289a:	90 f7       	brcc	.-28     	; 0x2880 <PM_SetupDFAddressCounters+0x56>
    289c:	30 93 6e 02 	sts	0x026E, r19
    28a0:	20 93 6d 02 	sts	0x026D, r18
	}
	
	CurrBuffByte = (uint16_t)StartAddress;                               // The buffer byte is the remainder
    28a4:	90 93 67 02 	sts	0x0267, r25
    28a8:	80 93 66 02 	sts	0x0266, r24
    28ac:	08 95       	ret

000028ae <PM_StoreProgramByte>:
}

void PM_StoreProgramByte(const uint8_t Data)
{
    28ae:	cf 93       	push	r28
    28b0:	c8 2f       	mov	r28, r24
	if (CurrBuffByte == DF_INTERNALDF_BUFFBYTES)
    28b2:	80 91 66 02 	lds	r24, 0x0266
    28b6:	90 91 67 02 	lds	r25, 0x0267
    28ba:	88 50       	subi	r24, 0x08	; 8
    28bc:	91 40       	sbci	r25, 0x01	; 1
    28be:	a9 f4       	brne	.+42     	; 0x28ea <PM_StoreProgramByte+0x3c>
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
    28c0:	80 91 6d 02 	lds	r24, 0x026D
    28c4:	90 91 6e 02 	lds	r25, 0x026E
    28c8:	9c 01       	movw	r18, r24
    28ca:	01 96       	adiw	r24, 0x01	; 1
    28cc:	90 93 6e 02 	sts	0x026E, r25
    28d0:	80 93 6d 02 	sts	0x026D, r24
    28d4:	c9 01       	movw	r24, r18
    28d6:	0e 94 ca 0a 	call	0x1594 <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    28da:	80 e0       	ldi	r24, 0x00	; 0
    28dc:	90 e0       	ldi	r25, 0x00	; 0
    28de:	0e 94 40 0a 	call	0x1480 <DF_BufferWriteEnable>
		CurrBuffByte = 0;
    28e2:	10 92 67 02 	sts	0x0267, r1
    28e6:	10 92 66 02 	sts	0x0266, r1
	}
	
	SPI_SPITransmit(Data);                                               // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    28ea:	8c 2f       	mov	r24, r28
    28ec:	0e 94 33 09 	call	0x1266 <SPI_SPITransmit>
	CurrBuffByte++;
    28f0:	80 91 66 02 	lds	r24, 0x0266
    28f4:	90 91 67 02 	lds	r25, 0x0267
    28f8:	01 96       	adiw	r24, 0x01	; 1
    28fa:	90 93 67 02 	sts	0x0267, r25
    28fe:	80 93 66 02 	sts	0x0266, r24
	GPageLength++;
    2902:	80 91 5e 02 	lds	r24, 0x025E
    2906:	90 91 5f 02 	lds	r25, 0x025F
    290a:	01 96       	adiw	r24, 0x01	; 1
    290c:	90 93 5f 02 	sts	0x025F, r25
    2910:	80 93 5e 02 	sts	0x025E, r24
    2914:	cf 91       	pop	r28
    2916:	08 95       	ret

00002918 <PM_CheckEndOfFuseLockData>:
}

void PM_InterpretAVRISPPacket(void)
{
	uint8_t* EEPROMAddress;

	switch (PacketBytes[0])
	{
		case CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
						
			for (uint8_t PacketB = 0; PacketB <= 11; PacketB++)          // Save the enter programming mode command bytes
			  eeprom_write_byte(&EEPROMVars.EnterProgMode[PacketB], PacketBytes[PacketB]);
			
			InProgrammingMode = TRUE;                                    // Set the flag, prevent the user from exiting the V2P state machine			
			CurrentMode = PM_NO_SETUP;                                   // Clear the current mode variable

			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = STATUS_CMD_OK;

			break;			
		case CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;

			PM_CheckEndOfFuseLockData();                                 // Check for remaining bytes to be stored and general cleanup
			
			InProgrammingMode = FALSE;                                   // Clear the flag, allow the user to exit the V2P state machine

			DF_EnableDataflash(FALSE);

			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
			PacketBytes[1] = STATUS_CMD_OK;

			break;
		case CMD_READ_SIGNATURE_ISP:
			MessageSize = 4;

			PacketBytes[1] = STATUS_CMD_OK;                              // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x01;                                       // Signature bytes all return "01" in storage mode
			PacketBytes[3] = STATUS_CMD_OK;                              // Data byte is encased in CMD_OKs

			break;
		case CMD_CHIP_ERASE_ISP:
			MessageSize = 2;

			for (uint8_t PacketB = 1; PacketB <= 6; PacketB++)          // Save the erase chip command bytes to EEPROM
			  eeprom_write_byte(&EEPROMVars.EraseChip[PacketB], PacketBytes[PacketB]);

			for (uint8_t Byte = 0; Byte < 8; Byte++)                    // Clear the program and EEPROM size counters
			{
				eeprom_write_byte(&EEPROMVars.DataSize[Byte], 0x00);
				eeprom_write_byte(&EEPROMVars.EEPROMSize[Byte], 0x00);
			}
						
			eeprom_write_byte(&EEPROMVars.EraseCmdStored, TRUE);
			
			PacketBytes[1] = STATUS_CMD_OK;
			
			break;
		case CMD_READ_OSCCAL_ISP:
			MessageSize = 4;

			PacketBytes[1] = STATUS_CMD_OK;                             // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x00;                                      // Return 0x00 for the OSCCAL byte
			PacketBytes[3] = STATUS_CMD_OK;                             // Data byte is encased in CMD_OKs

			break;
		case CMD_READ_FUSE_ISP:
		case CMD_READ_LOCK_ISP:
			MessageSize = 4;
	
			if (CurrentMode != PM_LOCKFUSEBITS_READ)                    // First lock or fuse byte being read, set the EEPROM pointer
			{
				PM_CheckEndOfFuseLockData();                            // Check for remaining bytes to be stored and general cleanup
				
				CurrBuffByte = 0;
				CurrentMode  = PM_LOCKFUSEBITS_READ;
			}
			
			if (CurrBuffByte > eeprom_read_byte((PacketBytes[0] == CMD_READ_FUSE_ISP)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes))  // Trying to read more fuse/lock bytes than are stored in memory
			{
				PacketBytes[2] = 0xFF;                                 // Return 0xFF for the fuse/lock byte
			}
			else
			{
				PacketBytes[2] = eeprom_read_byte((uint8_t*)(((PacketBytes[0] == CMD_READ_FUSE_ISP)? &EEPROMVars.FuseBytes : &EEPROMVars.LockBytes) // Starting location
									                         + (CurrBuffByte << 2) + (PacketBytes[1] - 1)));                                        // The start position of the actual fuse/lock byte to read (4 bytes each));
			}

			PacketBytes[1] = STATUS_CMD_OK;                            // Data byte is encased in CMD_OKs
			PacketBytes[3] = STATUS_CMD_OK;                            // Data byte is encased in CMD_OKs

			CurrBuffByte++;

			break;
		case CMD_PROGRAM_FUSE_ISP:
		case CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;

			if (CurrentMode != PM_LOCKFUSEBITS_WRITE)                  // First lock or fuse byte being written, set the EEPROM pointer
			{
				CurrentMode   = PM_LOCKFUSEBITS_WRITE;
				CurrBuffByte  = 0;                                     // CurrBuffByte is used to store the total fuse/lock bytes written
			}

			if (PacketBytes[0] == CMD_PROGRAM_FUSE_ISP)
			{
				EEPROMAddress = (uint8_t*)(&EEPROMVars.FuseBytes + (CurrBuffByte << 2));
				MemoryType    = TYPE_FUSE;
			}
			else
			{
				EEPROMAddress = (uint8_t*)(&EEPROMVars.LockBytes + (CurrBuffByte << 2));
				MemoryType    = TYPE_LOCK;
			}				
			
			if (CurrBuffByte < PM_MAX_FUSELOCKBITS)
			{
				for (uint8_t FLByte = 1; FLByte <= 4; FLByte++)
				{
					eeprom_write_byte(EEPROMAddress, PacketBytes[FLByte]);
					EEPROMAddress++;
				}

				CurrBuffByte++;                                        // Increment the total fuse/lock bytes written counter
			}
			
			PacketBytes[1] = STATUS_CMD_OK;                            // Two CMD_OKs are always returned
			PacketBytes[2] = STATUS_CMD_OK;                            // Two CMD_OKs are always returned

			break;
		case CMD_PROGRAM_FLASH_ISP:
		case CMD_PROGRAM_EEPROM_ISP:
			MessageSize = 2;

			if (CurrentMode != PM_DATAFLASH_WRITE)                     // First programming packet
			{
				if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)           // Flash programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram; // Set the eeprom address to the Program command bytes location
					PM_SetupDFAddressCounters(TYPE_FLASH);
				}
				else                                                   // EEPROM programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;  // Set the eeprom address to the EEPROM command bytes location
					PM_SetupDFAddressCounters(TYPE_EEPROM);
				}
				
				DF_BufferWriteEnable(CurrBuffByte);
				CurrentMode = PM_DATAFLASH_WRITE;
				
				for (uint8_t B = 1; B <= 9; B++)                       // Save the command bytes
				  eeprom_write_byte(EEPROMAddress, PacketBytes[B]);
			}

			uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
			                      | PacketBytes[2];

			for (uint16_t CurrByte = 0; CurrByte < BytesToWrite; CurrByte++)
				PM_StoreProgramByte(PacketBytes[10 + CurrByte]);

			if (!(GPageLength & PM_PAGELENGTH_FOUNDBIT) && (PacketBytes[3] & ISPCC_PROG_MODE_PAGEDONE) && GPageLength)
			{
				eeprom_write_word(((MemoryType == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength), GPageLength);
		
				GPageLength |= PM_PAGELENGTH_FOUNDBIT;                 // Bit 15 is used to indicate if the length has been found
			}

			PacketBytes[1] = STATUS_CMD_OK;
		
			break;
		case CMD_READ_FLASH_ISP:
		case CMD_READ_EEPROM_ISP:	
			if (CurrentMode != PM_DATAFLASH_READ)
			{
				PM_CheckEndOfFuseLockData();                           // Check for remaining bytes to be stored and general cleanup
				
				PM_SetupDFAddressCounters((PacketBytes[0] == CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);
				DF_ContinuousReadEnable(CurrPageAddress, CurrBuffByte);
				
				CurrentMode = PM_DATAFLASH_READ;
				CurrAddress = 0;
			}

			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8)    // \. Load in the number of bytes that is to
			                     | PacketBytes[2];                    // /  be read into a temp variable (MSB first)
						
			uint16_t BytesInMem  = PM_GetStoredDataSize((PacketBytes[0] == CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
			   PacketBytes[2 + ReadByte] = ((CurrAddress < BytesInMem)? SPI_SPITransmit(0x00) : 0xFF); // Read in the next dataflash byte if present
			   V2P_IncrementCurrAddress();
			}
			
			MessageSize = BytesToRead + 3;

			PacketBytes[1]               = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
			PacketBytes[2 + BytesToRead] = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
		
			break;
		default:
			MessageSize = 1;
			
			PacketBytes[1] = STATUS_CMD_UNKNOWN;
	}

	V2P_SendPacket();                                   // Send the response packet
}

void PM_CheckEndOfFuseLockData(void)
{
    2918:	cf 93       	push	r28
    291a:	df 93       	push	r29
    291c:	cd b7       	in	r28, 0x3d	; 61
    291e:	de b7       	in	r29, 0x3e	; 62
    2920:	24 97       	sbiw	r28, 0x04	; 4
    2922:	0f b6       	in	r0, 0x3f	; 63
    2924:	f8 94       	cli
    2926:	de bf       	out	0x3e, r29	; 62
    2928:	0f be       	out	0x3f, r0	; 63
    292a:	cd bf       	out	0x3d, r28	; 61
	if (CurrentMode == PM_DATAFLASH_WRITE)
    292c:	80 91 60 02 	lds	r24, 0x0260
    2930:	81 30       	cpi	r24, 0x01	; 1
    2932:	09 f0       	breq	.+2      	; 0x2936 <PM_CheckEndOfFuseLockData+0x1e>
    2934:	3f c0       	rjmp	.+126    	; 0x29b4 <PM_CheckEndOfFuseLockData+0x9c>
	{
		if (CurrBuffByte)                               // Data in the dataflash buffer, pending to be written
    2936:	80 91 66 02 	lds	r24, 0x0266
    293a:	90 91 67 02 	lds	r25, 0x0267
    293e:	89 2b       	or	r24, r25
    2940:	31 f0       	breq	.+12     	; 0x294e <PM_CheckEndOfFuseLockData+0x36>
		  DF_CopyBufferToFlashPage(CurrPageAddress);    // Save the remaining buffer bytes
    2942:	80 91 6d 02 	lds	r24, 0x026D
    2946:	90 91 6e 02 	lds	r25, 0x026E
    294a:	0e 94 ca 0a 	call	0x1594 <DF_CopyBufferToFlashPage>

		uint32_t DataSize = ((CurrPageAddress * DF_INTERNALDF_BUFFBYTES) + CurrBuffByte);
    294e:	20 91 6d 02 	lds	r18, 0x026D
    2952:	30 91 6e 02 	lds	r19, 0x026E
    2956:	88 e0       	ldi	r24, 0x08	; 8
    2958:	91 e0       	ldi	r25, 0x01	; 1
    295a:	28 9f       	mul	r18, r24
    295c:	a0 01       	movw	r20, r0
    295e:	29 9f       	mul	r18, r25
    2960:	50 0d       	add	r21, r0
    2962:	38 9f       	mul	r19, r24
    2964:	50 0d       	add	r21, r0
    2966:	11 24       	eor	r1, r1
    2968:	ca 01       	movw	r24, r20
    296a:	20 91 66 02 	lds	r18, 0x0266
    296e:	30 91 67 02 	lds	r19, 0x0267
    2972:	82 0f       	add	r24, r18
    2974:	93 1f       	adc	r25, r19
    2976:	9c 01       	movw	r18, r24
    2978:	44 27       	eor	r20, r20
    297a:	55 27       	eor	r21, r21
    297c:	29 83       	std	Y+1, r18	; 0x01
    297e:	3a 83       	std	Y+2, r19	; 0x02
    2980:	4b 83       	std	Y+3, r20	; 0x03
    2982:	5c 83       	std	Y+4, r21	; 0x04

		if (MemoryType == TYPE_FLASH)
    2984:	80 91 61 02 	lds	r24, 0x0261
    2988:	fe 01       	movw	r30, r28
    298a:	31 96       	adiw	r30, 0x01	; 1
    298c:	81 30       	cpi	r24, 0x01	; 1
    298e:	19 f4       	brne	.+6      	; 0x2996 <PM_CheckEndOfFuseLockData+0x7e>
void 
eeprom_write_block (const void *pointer_ram,
                    void *pointer_eeprom,
                    size_t n)
{
    2990:	ab e1       	ldi	r26, 0x1B	; 27
    2992:	b0 e0       	ldi	r27, 0x00	; 0
    2994:	0a c0       	rjmp	.+20     	; 0x29aa <PM_CheckEndOfFuseLockData+0x92>
		{
			eeprom_write_block((const void*)&DataSize, (void*)&EEPROMVars.DataSize, sizeof(uint32_t));
		}
		else
		{
			DataSize -= PM_EEPROM_OFFSET;                // Remove DataFlash EEPROM start offset
    2996:	20 50       	subi	r18, 0x00	; 0
    2998:	34 40       	sbci	r19, 0x04	; 4
    299a:	44 40       	sbci	r20, 0x04	; 4
    299c:	50 40       	sbci	r21, 0x00	; 0
    299e:	29 83       	std	Y+1, r18	; 0x01
    29a0:	3a 83       	std	Y+2, r19	; 0x02
    29a2:	4b 83       	std	Y+3, r20	; 0x03
    29a4:	5c 83       	std	Y+4, r21	; 0x04
void 
eeprom_write_block (const void *pointer_ram,
                    void *pointer_eeprom,
                    size_t n)
{
    29a6:	af e1       	ldi	r26, 0x1F	; 31
    29a8:	b0 e0       	ldi	r27, 0x00	; 0
  if (!__builtin_constant_p (n)
      || n > 256)
    {
      /* make sure size is a 16 bit variable.  */
      uint16_t size = n; 

      asm volatile ( 
            ".%=_start:" CR_TAB
            "sbiw %2,1" CR_TAB
            "brlt .%=_finished" CR_TAB
            "ld __tmp_reg__,z+" CR_TAB
             XCALL " __eeprom_write_byte_" _REG_LOCATION_SUFFIX CR_TAB
            "rjmp .%=_start" CR_TAB
            ".%=_finished:" 
          : "=x" (pointer_eeprom),
            "=z" (pointer_ram),
            "+w" (size)
           : "x" (pointer_eeprom), 
             "z" (pointer_ram)
           : "memory");
    }
  else
    {
      /* Do nothing for compile time constant transfer size n == 0.  */
      if (n != 0)
        {
          if (n == 256)
            {
              asm volatile (
                 XCALL " __eeprom_write_block_" _REG_LOCATION_SUFFIX
               : "+x" (pointer_eeprom),
                 "=z" (pointer_ram)
               : "z"  (pointer_ram)
               : "memory" );
            }
          else
            {
              uint8_t len;
              len = (uint8_t) n;
    29aa:	84 e0       	ldi	r24, 0x04	; 4

              asm volatile (
    29ac:	18 2e       	mov	r1, r24
    29ae:	0e 94 75 1a 	call	0x34ea <__eeprom_write_block_1F2021>
    29b2:	10 c0       	rjmp	.+32     	; 0x29d4 <PM_CheckEndOfFuseLockData+0xbc>
			eeprom_write_block((const void*)&DataSize, (void*)&EEPROMVars.EEPROMSize, sizeof(uint32_t));
		}
	}
	else if (CurrentMode == PM_LOCKFUSEBITS_WRITE)
    29b4:	83 30       	cpi	r24, 0x03	; 3
    29b6:	71 f4       	brne	.+28     	; 0x29d4 <PM_CheckEndOfFuseLockData+0xbc>
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    29b8:	80 91 61 02 	lds	r24, 0x0261
    29bc:	82 30       	cpi	r24, 0x02	; 2
    29be:	19 f4       	brne	.+6      	; 0x29c6 <PM_CheckEndOfFuseLockData+0xae>
    29c0:	af e2       	ldi	r26, 0x2F	; 47
    29c2:	b0 e0       	ldi	r27, 0x00	; 0
    29c4:	02 c0       	rjmp	.+4      	; 0x29ca <PM_CheckEndOfFuseLockData+0xb2>
    29c6:	a0 e3       	ldi	r26, 0x30	; 48
    29c8:	b0 e0       	ldi	r27, 0x00	; 0
    29ca:	80 91 66 02 	lds	r24, 0x0266
  asm volatile (
    29ce:	08 2e       	mov	r0, r24
    29d0:	0e 94 64 1a 	call	0x34c8 <__eeprom_write_byte_1F2021>
    29d4:	24 96       	adiw	r28, 0x04	; 4
    29d6:	0f b6       	in	r0, 0x3f	; 63
    29d8:	f8 94       	cli
    29da:	de bf       	out	0x3e, r29	; 62
    29dc:	0f be       	out	0x3f, r0	; 63
    29de:	cd bf       	out	0x3d, r28	; 61
    29e0:	df 91       	pop	r29
    29e2:	cf 91       	pop	r28
    29e4:	08 95       	ret

000029e6 <PM_InterpretAVRISPPacket>:
    29e6:	cf 92       	push	r12
    29e8:	df 92       	push	r13
    29ea:	ef 92       	push	r14
    29ec:	ff 92       	push	r15
    29ee:	0f 93       	push	r16
    29f0:	1f 93       	push	r17
    29f2:	cf 93       	push	r28
    29f4:	df 93       	push	r29
    29f6:	40 91 4b 01 	lds	r20, 0x014B
    29fa:	84 2f       	mov	r24, r20
    29fc:	99 27       	eor	r25, r25
    29fe:	86 31       	cpi	r24, 0x16	; 22
    2a00:	91 05       	cpc	r25, r1
    2a02:	09 f4       	brne	.+2      	; 0x2a06 <PM_InterpretAVRISPPacket+0x20>
    2a04:	bc c1       	rjmp	.+888    	; 0x2d7e <PM_InterpretAVRISPPacket+0x398>
    2a06:	87 31       	cpi	r24, 0x17	; 23
    2a08:	91 05       	cpc	r25, r1
    2a0a:	94 f4       	brge	.+36     	; 0x2a30 <PM_InterpretAVRISPPacket+0x4a>
    2a0c:	82 31       	cpi	r24, 0x12	; 18
    2a0e:	91 05       	cpc	r25, r1
    2a10:	09 f4       	brne	.+2      	; 0x2a14 <PM_InterpretAVRISPPacket+0x2e>
    2a12:	66 c0       	rjmp	.+204    	; 0x2ae0 <PM_InterpretAVRISPPacket+0xfa>
    2a14:	83 31       	cpi	r24, 0x13	; 19
    2a16:	91 05       	cpc	r25, r1
    2a18:	3c f4       	brge	.+14     	; 0x2a28 <PM_InterpretAVRISPPacket+0x42>
    2a1a:	80 31       	cpi	r24, 0x10	; 16
    2a1c:	91 05       	cpc	r25, r1
    2a1e:	11 f1       	breq	.+68     	; 0x2a64 <PM_InterpretAVRISPPacket+0x7e>
    2a20:	41 97       	sbiw	r24, 0x11	; 17
    2a22:	09 f4       	brne	.+2      	; 0x2a26 <PM_InterpretAVRISPPacket+0x40>
    2a24:	3f c0       	rjmp	.+126    	; 0x2aa4 <PM_InterpretAVRISPPacket+0xbe>
    2a26:	19 c2       	rjmp	.+1074   	; 0x2e5a <PM_InterpretAVRISPPacket+0x474>
    2a28:	44 97       	sbiw	r24, 0x14	; 20
    2a2a:	09 f4       	brne	.+2      	; 0x2a2e <PM_InterpretAVRISPPacket+0x48>
    2a2c:	a8 c1       	rjmp	.+848    	; 0x2d7e <PM_InterpretAVRISPPacket+0x398>
    2a2e:	3c c1       	rjmp	.+632    	; 0x2ca8 <PM_InterpretAVRISPPacket+0x2c2>
    2a30:	89 31       	cpi	r24, 0x19	; 25
    2a32:	91 05       	cpc	r25, r1
    2a34:	09 f4       	brne	.+2      	; 0x2a38 <PM_InterpretAVRISPPacket+0x52>
    2a36:	e6 c0       	rjmp	.+460    	; 0x2c04 <PM_InterpretAVRISPPacket+0x21e>
    2a38:	8a 31       	cpi	r24, 0x1A	; 26
    2a3a:	91 05       	cpc	r25, r1
    2a3c:	44 f4       	brge	.+16     	; 0x2a4e <PM_InterpretAVRISPPacket+0x68>
    2a3e:	87 31       	cpi	r24, 0x17	; 23
    2a40:	91 05       	cpc	r25, r1
    2a42:	09 f4       	brne	.+2      	; 0x2a46 <PM_InterpretAVRISPPacket+0x60>
    2a44:	df c0       	rjmp	.+446    	; 0x2c04 <PM_InterpretAVRISPPacket+0x21e>
    2a46:	48 97       	sbiw	r24, 0x18	; 24
    2a48:	09 f4       	brne	.+2      	; 0x2a4c <PM_InterpretAVRISPPacket+0x66>
    2a4a:	89 c0       	rjmp	.+274    	; 0x2b5e <PM_InterpretAVRISPPacket+0x178>
    2a4c:	06 c2       	rjmp	.+1036   	; 0x2e5a <PM_InterpretAVRISPPacket+0x474>
    2a4e:	8b 31       	cpi	r24, 0x1B	; 27
    2a50:	91 05       	cpc	r25, r1
    2a52:	d1 f1       	breq	.+116    	; 0x2ac8 <PM_InterpretAVRISPPacket+0xe2>
    2a54:	8b 31       	cpi	r24, 0x1B	; 27
    2a56:	91 05       	cpc	r25, r1
    2a58:	0c f4       	brge	.+2      	; 0x2a5c <PM_InterpretAVRISPPacket+0x76>
    2a5a:	81 c0       	rjmp	.+258    	; 0x2b5e <PM_InterpretAVRISPPacket+0x178>
    2a5c:	4c 97       	sbiw	r24, 0x1c	; 28
    2a5e:	09 f4       	brne	.+2      	; 0x2a62 <PM_InterpretAVRISPPacket+0x7c>
    2a60:	71 c0       	rjmp	.+226    	; 0x2b44 <PM_InterpretAVRISPPacket+0x15e>
    2a62:	fb c1       	rjmp	.+1014   	; 0x2e5a <PM_InterpretAVRISPPacket+0x474>
    2a64:	82 e0       	ldi	r24, 0x02	; 2
    2a66:	90 e0       	ldi	r25, 0x00	; 0
    2a68:	90 93 48 01 	sts	0x0148, r25
    2a6c:	80 93 47 01 	sts	0x0147, r24
    2a70:	eb e4       	ldi	r30, 0x4B	; 75
    2a72:	f1 e0       	ldi	r31, 0x01	; 1
    2a74:	20 e0       	ldi	r18, 0x00	; 0
    2a76:	30 e0       	ldi	r19, 0x00	; 0
    2a78:	9b e0       	ldi	r25, 0x0B	; 11
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    2a7a:	d9 01       	movw	r26, r18
    2a7c:	ad 5d       	subi	r26, 0xDD	; 221
    2a7e:	bf 4f       	sbci	r27, 0xFF	; 255
    2a80:	81 91       	ld	r24, Z+
  asm volatile (
    2a82:	08 2e       	mov	r0, r24
    2a84:	0e 94 64 1a 	call	0x34c8 <__eeprom_write_byte_1F2021>
    2a88:	91 50       	subi	r25, 0x01	; 1
    2a8a:	2f 5f       	subi	r18, 0xFF	; 255
    2a8c:	3f 4f       	sbci	r19, 0xFF	; 255
    2a8e:	97 ff       	sbrs	r25, 7
    2a90:	f4 cf       	rjmp	.-24     	; 0x2a7a <PM_InterpretAVRISPPacket+0x94>
    2a92:	81 e0       	ldi	r24, 0x01	; 1
    2a94:	80 93 46 01 	sts	0x0146, r24
    2a98:	10 92 60 02 	sts	0x0260, r1
    2a9c:	81 b3       	in	r24, 0x11	; 17
    2a9e:	8f 7c       	andi	r24, 0xCF	; 207
    2aa0:	80 62       	ori	r24, 0x20	; 32
    2aa2:	10 c0       	rjmp	.+32     	; 0x2ac4 <PM_InterpretAVRISPPacket+0xde>
    2aa4:	82 e0       	ldi	r24, 0x02	; 2
    2aa6:	90 e0       	ldi	r25, 0x00	; 0
    2aa8:	90 93 48 01 	sts	0x0148, r25
    2aac:	80 93 47 01 	sts	0x0147, r24
    2ab0:	0e 94 8c 14 	call	0x2918 <PM_CheckEndOfFuseLockData>
    2ab4:	10 92 46 01 	sts	0x0146, r1
    2ab8:	80 e0       	ldi	r24, 0x00	; 0
    2aba:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    2abe:	81 b3       	in	r24, 0x11	; 17
    2ac0:	8f 7c       	andi	r24, 0xCF	; 207
    2ac2:	80 61       	ori	r24, 0x10	; 16
    2ac4:	81 bb       	out	0x11, r24	; 17
    2ac6:	58 c1       	rjmp	.+688    	; 0x2d78 <PM_InterpretAVRISPPacket+0x392>
    2ac8:	84 e0       	ldi	r24, 0x04	; 4
    2aca:	90 e0       	ldi	r25, 0x00	; 0
    2acc:	90 93 48 01 	sts	0x0148, r25
    2ad0:	80 93 47 01 	sts	0x0147, r24
    2ad4:	10 92 4c 01 	sts	0x014C, r1
    2ad8:	81 e0       	ldi	r24, 0x01	; 1
    2ada:	80 93 4d 01 	sts	0x014D, r24
    2ade:	3c c0       	rjmp	.+120    	; 0x2b58 <PM_InterpretAVRISPPacket+0x172>
    2ae0:	82 e0       	ldi	r24, 0x02	; 2
    2ae2:	90 e0       	ldi	r25, 0x00	; 0
    2ae4:	90 93 48 01 	sts	0x0148, r25
    2ae8:	80 93 47 01 	sts	0x0147, r24
    2aec:	ec e4       	ldi	r30, 0x4C	; 76
    2aee:	f1 e0       	ldi	r31, 0x01	; 1
    2af0:	21 e0       	ldi	r18, 0x01	; 1
    2af2:	30 e0       	ldi	r19, 0x00	; 0
    2af4:	95 e0       	ldi	r25, 0x05	; 5
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    2af6:	d9 01       	movw	r26, r18
    2af8:	ab 5e       	subi	r26, 0xEB	; 235
    2afa:	bf 4f       	sbci	r27, 0xFF	; 255
    2afc:	81 91       	ld	r24, Z+
  asm volatile (
    2afe:	08 2e       	mov	r0, r24
    2b00:	0e 94 64 1a 	call	0x34c8 <__eeprom_write_byte_1F2021>
    2b04:	91 50       	subi	r25, 0x01	; 1
    2b06:	2f 5f       	subi	r18, 0xFF	; 255
    2b08:	3f 4f       	sbci	r19, 0xFF	; 255
    2b0a:	97 ff       	sbrs	r25, 7
    2b0c:	f4 cf       	rjmp	.-24     	; 0x2af6 <PM_InterpretAVRISPPacket+0x110>
    2b0e:	20 e0       	ldi	r18, 0x00	; 0
    2b10:	80 e0       	ldi	r24, 0x00	; 0
    2b12:	90 e0       	ldi	r25, 0x00	; 0
    2b14:	37 e0       	ldi	r19, 0x07	; 7
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    2b16:	dc 01       	movw	r26, r24
    2b18:	a5 5e       	subi	r26, 0xE5	; 229
    2b1a:	bf 4f       	sbci	r27, 0xFF	; 255
  asm volatile (
    2b1c:	02 2e       	mov	r0, r18
    2b1e:	0e 94 64 1a 	call	0x34c8 <__eeprom_write_byte_1F2021>
    2b22:	dc 01       	movw	r26, r24
    2b24:	a1 5e       	subi	r26, 0xE1	; 225
    2b26:	bf 4f       	sbci	r27, 0xFF	; 255
    2b28:	02 2e       	mov	r0, r18
    2b2a:	0e 94 64 1a 	call	0x34c8 <__eeprom_write_byte_1F2021>
    2b2e:	31 50       	subi	r19, 0x01	; 1
    2b30:	01 96       	adiw	r24, 0x01	; 1
    2b32:	37 ff       	sbrs	r19, 7
    2b34:	f0 cf       	rjmp	.-32     	; 0x2b16 <PM_InterpretAVRISPPacket+0x130>
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    2b36:	a4 e1       	ldi	r26, 0x14	; 20
    2b38:	b0 e0       	ldi	r27, 0x00	; 0
    2b3a:	81 e0       	ldi	r24, 0x01	; 1
  asm volatile (
    2b3c:	08 2e       	mov	r0, r24
    2b3e:	0e 94 64 1a 	call	0x34c8 <__eeprom_write_byte_1F2021>
    2b42:	1a c1       	rjmp	.+564    	; 0x2d78 <PM_InterpretAVRISPPacket+0x392>
    2b44:	84 e0       	ldi	r24, 0x04	; 4
    2b46:	90 e0       	ldi	r25, 0x00	; 0
    2b48:	90 93 48 01 	sts	0x0148, r25
    2b4c:	80 93 47 01 	sts	0x0147, r24
    2b50:	10 92 4c 01 	sts	0x014C, r1
    2b54:	10 92 4d 01 	sts	0x014D, r1
    2b58:	10 92 4e 01 	sts	0x014E, r1
    2b5c:	87 c1       	rjmp	.+782    	; 0x2e6c <PM_InterpretAVRISPPacket+0x486>
    2b5e:	84 e0       	ldi	r24, 0x04	; 4
    2b60:	90 e0       	ldi	r25, 0x00	; 0
    2b62:	90 93 48 01 	sts	0x0148, r25
    2b66:	80 93 47 01 	sts	0x0147, r24
    2b6a:	80 91 60 02 	lds	r24, 0x0260
    2b6e:	84 30       	cpi	r24, 0x04	; 4
    2b70:	49 f0       	breq	.+18     	; 0x2b84 <PM_InterpretAVRISPPacket+0x19e>
    2b72:	0e 94 8c 14 	call	0x2918 <PM_CheckEndOfFuseLockData>
    2b76:	10 92 67 02 	sts	0x0267, r1
    2b7a:	10 92 66 02 	sts	0x0266, r1
    2b7e:	84 e0       	ldi	r24, 0x04	; 4
    2b80:	80 93 60 02 	sts	0x0260, r24
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2b84:	60 91 4b 01 	lds	r22, 0x014B
    2b88:	68 31       	cpi	r22, 0x18	; 24
    2b8a:	19 f4       	brne	.+6      	; 0x2b92 <PM_InterpretAVRISPPacket+0x1ac>
    2b8c:	af e2       	ldi	r26, 0x2F	; 47
    2b8e:	b0 e0       	ldi	r27, 0x00	; 0
    2b90:	02 c0       	rjmp	.+4      	; 0x2b96 <PM_InterpretAVRISPPacket+0x1b0>
    2b92:	a0 e3       	ldi	r26, 0x30	; 48
    2b94:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    2b96:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
    2b9a:	80 2d       	mov	r24, r0
    2b9c:	99 27       	eor	r25, r25
    2b9e:	40 91 66 02 	lds	r20, 0x0266
    2ba2:	50 91 67 02 	lds	r21, 0x0267
    2ba6:	84 17       	cp	r24, r20
    2ba8:	95 07       	cpc	r25, r21
    2baa:	10 f4       	brcc	.+4      	; 0x2bb0 <PM_InterpretAVRISPPacket+0x1ca>
    2bac:	8f ef       	ldi	r24, 0xFF	; 255
    2bae:	1d c0       	rjmp	.+58     	; 0x2bea <PM_InterpretAVRISPPacket+0x204>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2bb0:	80 ea       	ldi	r24, 0xA0	; 160
    2bb2:	90 e0       	ldi	r25, 0x00	; 0
    2bb4:	48 9f       	mul	r20, r24
    2bb6:	90 01       	movw	r18, r0
    2bb8:	49 9f       	mul	r20, r25
    2bba:	30 0d       	add	r19, r0
    2bbc:	58 9f       	mul	r21, r24
    2bbe:	30 0d       	add	r19, r0
    2bc0:	11 24       	eor	r1, r1
    2bc2:	90 91 4c 01 	lds	r25, 0x014C
    2bc6:	88 e2       	ldi	r24, 0x28	; 40
    2bc8:	98 9f       	mul	r25, r24
    2bca:	c0 01       	movw	r24, r0
    2bcc:	11 24       	eor	r1, r1
    2bce:	28 0f       	add	r18, r24
    2bd0:	39 1f       	adc	r19, r25
    2bd2:	68 31       	cpi	r22, 0x18	; 24
    2bd4:	21 f4       	brne	.+8      	; 0x2bde <PM_InterpretAVRISPPacket+0x1f8>
    2bd6:	d9 01       	movw	r26, r18
    2bd8:	a7 5f       	subi	r26, 0xF7	; 247
    2bda:	bf 4f       	sbci	r27, 0xFF	; 255
    2bdc:	03 c0       	rjmp	.+6      	; 0x2be4 <PM_InterpretAVRISPPacket+0x1fe>
    2bde:	d9 01       	movw	r26, r18
    2be0:	af 5c       	subi	r26, 0xCF	; 207
    2be2:	bf 4f       	sbci	r27, 0xFF	; 255
  uint8_t result;
  asm volatile
    2be4:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
    2be8:	80 2d       	mov	r24, r0
    2bea:	80 93 4d 01 	sts	0x014D, r24
    2bee:	10 92 4c 01 	sts	0x014C, r1
    2bf2:	10 92 4e 01 	sts	0x014E, r1
    2bf6:	4f 5f       	subi	r20, 0xFF	; 255
    2bf8:	5f 4f       	sbci	r21, 0xFF	; 255
    2bfa:	50 93 67 02 	sts	0x0267, r21
    2bfe:	40 93 66 02 	sts	0x0266, r20
    2c02:	34 c1       	rjmp	.+616    	; 0x2e6c <PM_InterpretAVRISPPacket+0x486>
    2c04:	83 e0       	ldi	r24, 0x03	; 3
    2c06:	90 e0       	ldi	r25, 0x00	; 0
    2c08:	90 93 48 01 	sts	0x0148, r25
    2c0c:	80 93 47 01 	sts	0x0147, r24
    2c10:	80 91 60 02 	lds	r24, 0x0260
    2c14:	83 30       	cpi	r24, 0x03	; 3
    2c16:	39 f0       	breq	.+14     	; 0x2c26 <PM_InterpretAVRISPPacket+0x240>
    2c18:	83 e0       	ldi	r24, 0x03	; 3
    2c1a:	80 93 60 02 	sts	0x0260, r24
    2c1e:	10 92 67 02 	sts	0x0267, r1
    2c22:	10 92 66 02 	sts	0x0266, r1
    2c26:	20 91 66 02 	lds	r18, 0x0266
    2c2a:	30 91 67 02 	lds	r19, 0x0267
    2c2e:	47 31       	cpi	r20, 0x17	; 23
    2c30:	69 f4       	brne	.+26     	; 0x2c4c <PM_InterpretAVRISPPacket+0x266>
    2c32:	80 ea       	ldi	r24, 0xA0	; 160
    2c34:	90 e0       	ldi	r25, 0x00	; 0
    2c36:	28 9f       	mul	r18, r24
    2c38:	e0 01       	movw	r28, r0
    2c3a:	29 9f       	mul	r18, r25
    2c3c:	d0 0d       	add	r29, r0
    2c3e:	38 9f       	mul	r19, r24
    2c40:	d0 0d       	add	r29, r0
    2c42:	11 24       	eor	r1, r1
    2c44:	cf 5c       	subi	r28, 0xCF	; 207
    2c46:	df 4f       	sbci	r29, 0xFF	; 255
    2c48:	82 e0       	ldi	r24, 0x02	; 2
    2c4a:	0c c0       	rjmp	.+24     	; 0x2c64 <PM_InterpretAVRISPPacket+0x27e>
    2c4c:	80 ea       	ldi	r24, 0xA0	; 160
    2c4e:	90 e0       	ldi	r25, 0x00	; 0
    2c50:	28 9f       	mul	r18, r24
    2c52:	e0 01       	movw	r28, r0
    2c54:	29 9f       	mul	r18, r25
    2c56:	d0 0d       	add	r29, r0
    2c58:	38 9f       	mul	r19, r24
    2c5a:	d0 0d       	add	r29, r0
    2c5c:	11 24       	eor	r1, r1
    2c5e:	c7 5a       	subi	r28, 0xA7	; 167
    2c60:	df 4f       	sbci	r29, 0xFF	; 255
    2c62:	83 e0       	ldi	r24, 0x03	; 3
    2c64:	80 93 61 02 	sts	0x0261, r24
    2c68:	80 91 66 02 	lds	r24, 0x0266
    2c6c:	90 91 67 02 	lds	r25, 0x0267
    2c70:	0a 97       	sbiw	r24, 0x0a	; 10
    2c72:	a8 f4       	brcc	.+42     	; 0x2c9e <PM_InterpretAVRISPPacket+0x2b8>
    2c74:	ec e4       	ldi	r30, 0x4C	; 76
    2c76:	f1 e0       	ldi	r31, 0x01	; 1
    2c78:	93 e0       	ldi	r25, 0x03	; 3
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    2c7a:	81 91       	ld	r24, Z+
  asm volatile (
    2c7c:	de 01       	movw	r26, r28
    2c7e:	08 2e       	mov	r0, r24
    2c80:	0e 94 64 1a 	call	0x34c8 <__eeprom_write_byte_1F2021>
    2c84:	21 96       	adiw	r28, 0x01	; 1
    2c86:	91 50       	subi	r25, 0x01	; 1
    2c88:	97 ff       	sbrs	r25, 7
    2c8a:	f7 cf       	rjmp	.-18     	; 0x2c7a <PM_InterpretAVRISPPacket+0x294>
    2c8c:	80 91 66 02 	lds	r24, 0x0266
    2c90:	90 91 67 02 	lds	r25, 0x0267
    2c94:	01 96       	adiw	r24, 0x01	; 1
    2c96:	90 93 67 02 	sts	0x0267, r25
    2c9a:	80 93 66 02 	sts	0x0266, r24
    2c9e:	10 92 4c 01 	sts	0x014C, r1
    2ca2:	10 92 4d 01 	sts	0x014D, r1
    2ca6:	e2 c0       	rjmp	.+452    	; 0x2e6c <PM_InterpretAVRISPPacket+0x486>
    2ca8:	82 e0       	ldi	r24, 0x02	; 2
    2caa:	90 e0       	ldi	r25, 0x00	; 0
    2cac:	90 93 48 01 	sts	0x0148, r25
    2cb0:	80 93 47 01 	sts	0x0147, r24
    2cb4:	80 91 60 02 	lds	r24, 0x0260
    2cb8:	81 30       	cpi	r24, 0x01	; 1
    2cba:	f9 f0       	breq	.+62     	; 0x2cfa <PM_InterpretAVRISPPacket+0x314>
    2cbc:	43 31       	cpi	r20, 0x13	; 19
    2cbe:	21 f4       	brne	.+8      	; 0x2cc8 <PM_InterpretAVRISPPacket+0x2e2>
    2cc0:	c2 e0       	ldi	r28, 0x02	; 2
    2cc2:	d0 e0       	ldi	r29, 0x00	; 0
    2cc4:	81 e0       	ldi	r24, 0x01	; 1
    2cc6:	03 c0       	rjmp	.+6      	; 0x2cce <PM_InterpretAVRISPPacket+0x2e8>
    2cc8:	cb e0       	ldi	r28, 0x0B	; 11
    2cca:	d0 e0       	ldi	r29, 0x00	; 0
    2ccc:	80 e0       	ldi	r24, 0x00	; 0
    2cce:	0e 94 15 14 	call	0x282a <PM_SetupDFAddressCounters>
    2cd2:	80 91 66 02 	lds	r24, 0x0266
    2cd6:	90 91 67 02 	lds	r25, 0x0267
    2cda:	0e 94 40 0a 	call	0x1480 <DF_BufferWriteEnable>
    2cde:	81 e0       	ldi	r24, 0x01	; 1
    2ce0:	80 93 60 02 	sts	0x0260, r24
    2ce4:	ec e4       	ldi	r30, 0x4C	; 76
    2ce6:	f1 e0       	ldi	r31, 0x01	; 1
    2ce8:	98 e0       	ldi	r25, 0x08	; 8
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    2cea:	81 91       	ld	r24, Z+
  asm volatile (
    2cec:	de 01       	movw	r26, r28
    2cee:	08 2e       	mov	r0, r24
    2cf0:	0e 94 64 1a 	call	0x34c8 <__eeprom_write_byte_1F2021>
    2cf4:	91 50       	subi	r25, 0x01	; 1
    2cf6:	97 ff       	sbrs	r25, 7
    2cf8:	f8 cf       	rjmp	.-16     	; 0x2cea <PM_InterpretAVRISPPacket+0x304>
    2cfa:	80 91 4c 01 	lds	r24, 0x014C
    2cfe:	99 27       	eor	r25, r25
    2d00:	d8 2f       	mov	r29, r24
    2d02:	cc 27       	eor	r28, r28
    2d04:	80 91 4d 01 	lds	r24, 0x014D
    2d08:	99 27       	eor	r25, r25
    2d0a:	c8 2b       	or	r28, r24
    2d0c:	d9 2b       	or	r29, r25
    2d0e:	00 e0       	ldi	r16, 0x00	; 0
    2d10:	10 e0       	ldi	r17, 0x00	; 0
    2d12:	0c 17       	cp	r16, r28
    2d14:	1d 07       	cpc	r17, r29
    2d16:	70 f4       	brcc	.+28     	; 0x2d34 <PM_InterpretAVRISPPacket+0x34e>
    2d18:	55 e5       	ldi	r21, 0x55	; 85
    2d1a:	e5 2e       	mov	r14, r21
    2d1c:	51 e0       	ldi	r21, 0x01	; 1
    2d1e:	f5 2e       	mov	r15, r21
    2d20:	f7 01       	movw	r30, r14
    2d22:	81 91       	ld	r24, Z+
    2d24:	7f 01       	movw	r14, r30
    2d26:	0e 94 57 14 	call	0x28ae <PM_StoreProgramByte>
    2d2a:	0f 5f       	subi	r16, 0xFF	; 255
    2d2c:	1f 4f       	sbci	r17, 0xFF	; 255
    2d2e:	0c 17       	cp	r16, r28
    2d30:	1d 07       	cpc	r17, r29
    2d32:	b0 f3       	brcs	.-20     	; 0x2d20 <PM_InterpretAVRISPPacket+0x33a>
    2d34:	20 91 5e 02 	lds	r18, 0x025E
    2d38:	30 91 5f 02 	lds	r19, 0x025F
    2d3c:	37 fd       	sbrc	r19, 7
    2d3e:	1c c0       	rjmp	.+56     	; 0x2d78 <PM_InterpretAVRISPPacket+0x392>
    2d40:	80 91 4e 01 	lds	r24, 0x014E
    2d44:	87 ff       	sbrs	r24, 7
    2d46:	18 c0       	rjmp	.+48     	; 0x2d78 <PM_InterpretAVRISPPacket+0x392>
    2d48:	21 15       	cp	r18, r1
    2d4a:	31 05       	cpc	r19, r1
    2d4c:	a9 f0       	breq	.+42     	; 0x2d78 <PM_InterpretAVRISPPacket+0x392>
    Write a word \c value to EEPROM address \c addr. */

void 
eeprom_write_word (uint16_t *addr,uint16_t value)
{
    2d4e:	80 91 61 02 	lds	r24, 0x0261
    2d52:	81 30       	cpi	r24, 0x01	; 1
    2d54:	19 f4       	brne	.+6      	; 0x2d5c <PM_InterpretAVRISPPacket+0x376>
    2d56:	a1 e8       	ldi	r26, 0x81	; 129
    2d58:	b0 e0       	ldi	r27, 0x00	; 0
    2d5a:	02 c0       	rjmp	.+4      	; 0x2d60 <PM_InterpretAVRISPPacket+0x37a>
    2d5c:	a3 e8       	ldi	r26, 0x83	; 131
    2d5e:	b0 e0       	ldi	r27, 0x00	; 0
  asm volatile (
    2d60:	09 01       	movw	r0, r18
    2d62:	0e 94 70 1a 	call	0x34e0 <__eeprom_write_word_1F2021>
    2d66:	80 91 5e 02 	lds	r24, 0x025E
    2d6a:	90 91 5f 02 	lds	r25, 0x025F
    2d6e:	90 68       	ori	r25, 0x80	; 128
    2d70:	90 93 5f 02 	sts	0x025F, r25
    2d74:	80 93 5e 02 	sts	0x025E, r24
    2d78:	10 92 4c 01 	sts	0x014C, r1
    2d7c:	77 c0       	rjmp	.+238    	; 0x2e6c <PM_InterpretAVRISPPacket+0x486>
    2d7e:	80 91 60 02 	lds	r24, 0x0260
    2d82:	82 30       	cpi	r24, 0x02	; 2
    2d84:	01 f1       	breq	.+64     	; 0x2dc6 <PM_InterpretAVRISPPacket+0x3e0>
    2d86:	0e 94 8c 14 	call	0x2918 <PM_CheckEndOfFuseLockData>
    2d8a:	90 e0       	ldi	r25, 0x00	; 0
    2d8c:	80 91 4b 01 	lds	r24, 0x014B
    2d90:	84 31       	cpi	r24, 0x14	; 20
    2d92:	09 f4       	brne	.+2      	; 0x2d96 <PM_InterpretAVRISPPacket+0x3b0>
    2d94:	91 e0       	ldi	r25, 0x01	; 1
    2d96:	89 2f       	mov	r24, r25
    2d98:	0e 94 15 14 	call	0x282a <PM_SetupDFAddressCounters>
    2d9c:	60 91 66 02 	lds	r22, 0x0266
    2da0:	70 91 67 02 	lds	r23, 0x0267
    2da4:	80 91 6d 02 	lds	r24, 0x026D
    2da8:	90 91 6e 02 	lds	r25, 0x026E
    2dac:	0e 94 04 0a 	call	0x1408 <DF_ContinuousReadEnable>
    2db0:	82 e0       	ldi	r24, 0x02	; 2
    2db2:	80 93 60 02 	sts	0x0260, r24
    2db6:	10 92 42 01 	sts	0x0142, r1
    2dba:	10 92 43 01 	sts	0x0143, r1
    2dbe:	10 92 44 01 	sts	0x0144, r1
    2dc2:	10 92 45 01 	sts	0x0145, r1
    2dc6:	80 91 4c 01 	lds	r24, 0x014C
    2dca:	99 27       	eor	r25, r25
    2dcc:	d8 2f       	mov	r29, r24
    2dce:	cc 27       	eor	r28, r28
    2dd0:	80 91 4d 01 	lds	r24, 0x014D
    2dd4:	99 27       	eor	r25, r25
    2dd6:	c8 2b       	or	r28, r24
    2dd8:	d9 2b       	or	r29, r25
    2dda:	90 e0       	ldi	r25, 0x00	; 0
    2ddc:	80 91 4b 01 	lds	r24, 0x014B
    2de0:	84 31       	cpi	r24, 0x14	; 20
    2de2:	09 f4       	brne	.+2      	; 0x2de6 <PM_InterpretAVRISPPacket+0x400>
    2de4:	91 e0       	ldi	r25, 0x01	; 1
    2de6:	89 2f       	mov	r24, r25
    2de8:	0e 94 de 13 	call	0x27bc <PM_GetStoredDataSize>
    2dec:	dc 01       	movw	r26, r24
    2dee:	cb 01       	movw	r24, r22
    2df0:	7c 01       	movw	r14, r24
    2df2:	00 e0       	ldi	r16, 0x00	; 0
    2df4:	10 e0       	ldi	r17, 0x00	; 0
    2df6:	0c 17       	cp	r16, r28
    2df8:	1d 07       	cpc	r17, r29
    2dfa:	18 f5       	brcc	.+70     	; 0x2e42 <PM_InterpretAVRISPPacket+0x45c>
    2dfc:	3d e4       	ldi	r19, 0x4D	; 77
    2dfe:	c3 2e       	mov	r12, r19
    2e00:	31 e0       	ldi	r19, 0x01	; 1
    2e02:	d3 2e       	mov	r13, r19
    2e04:	97 01       	movw	r18, r14
    2e06:	44 27       	eor	r20, r20
    2e08:	55 27       	eor	r21, r21
    2e0a:	80 91 42 01 	lds	r24, 0x0142
    2e0e:	90 91 43 01 	lds	r25, 0x0143
    2e12:	a0 91 44 01 	lds	r26, 0x0144
    2e16:	b0 91 45 01 	lds	r27, 0x0145
    2e1a:	82 17       	cp	r24, r18
    2e1c:	93 07       	cpc	r25, r19
    2e1e:	a4 07       	cpc	r26, r20
    2e20:	b5 07       	cpc	r27, r21
    2e22:	20 f4       	brcc	.+8      	; 0x2e2c <PM_InterpretAVRISPPacket+0x446>
    2e24:	80 e0       	ldi	r24, 0x00	; 0
    2e26:	0e 94 33 09 	call	0x1266 <SPI_SPITransmit>
    2e2a:	01 c0       	rjmp	.+2      	; 0x2e2e <PM_InterpretAVRISPPacket+0x448>
    2e2c:	8f ef       	ldi	r24, 0xFF	; 255
    2e2e:	f6 01       	movw	r30, r12
    2e30:	81 93       	st	Z+, r24
    2e32:	6f 01       	movw	r12, r30
    2e34:	0e 94 36 0f 	call	0x1e6c <V2P_IncrementCurrAddress>
    2e38:	0f 5f       	subi	r16, 0xFF	; 255
    2e3a:	1f 4f       	sbci	r17, 0xFF	; 255
    2e3c:	0c 17       	cp	r16, r28
    2e3e:	1d 07       	cpc	r17, r29
    2e40:	08 f3       	brcs	.-62     	; 0x2e04 <PM_InterpretAVRISPPacket+0x41e>
    2e42:	23 96       	adiw	r28, 0x03	; 3
    2e44:	d0 93 48 01 	sts	0x0148, r29
    2e48:	c0 93 47 01 	sts	0x0147, r28
    2e4c:	23 97       	sbiw	r28, 0x03	; 3
    2e4e:	10 92 4c 01 	sts	0x014C, r1
    2e52:	c5 5b       	subi	r28, 0xB5	; 181
    2e54:	de 4f       	sbci	r29, 0xFE	; 254
    2e56:	1a 82       	std	Y+2, r1	; 0x02
    2e58:	09 c0       	rjmp	.+18     	; 0x2e6c <PM_InterpretAVRISPPacket+0x486>
    2e5a:	81 e0       	ldi	r24, 0x01	; 1
    2e5c:	90 e0       	ldi	r25, 0x00	; 0
    2e5e:	90 93 48 01 	sts	0x0148, r25
    2e62:	80 93 47 01 	sts	0x0147, r24
    2e66:	89 ec       	ldi	r24, 0xC9	; 201
    2e68:	80 93 4c 01 	sts	0x014C, r24
    2e6c:	0e 94 55 0e 	call	0x1caa <V2P_SendPacket>
    2e70:	df 91       	pop	r29
    2e72:	cf 91       	pop	r28
    2e74:	1f 91       	pop	r17
    2e76:	0f 91       	pop	r16
    2e78:	ff 90       	pop	r15
    2e7a:	ef 90       	pop	r14
    2e7c:	df 90       	pop	r13
    2e7e:	cf 90       	pop	r12
    2e80:	08 95       	ret

00002e82 <PM_SendFuseLockBytes>:
	{
		// CurrBuffByte stores the total number of fuse/lock bytes written in this case:
		eeprom_write_byte(((MemoryType == TYPE_FUSE)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes), CurrBuffByte);
	}
}

void PM_SendFuseLockBytes(const uint8_t Type)
{
    2e82:	0f 93       	push	r16
    2e84:	1f 93       	push	r17
    2e86:	cf 93       	push	r28
    2e88:	df 93       	push	r29
	uint8_t* EEPROMAddress;
	uint8_t  TotalBytes;

	if (Type == TYPE_FUSE)
    2e8a:	82 30       	cpi	r24, 0x02	; 2
    2e8c:	49 f4       	brne	.+18     	; 0x2ea0 <PM_SendFuseLockBytes+0x1e>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2e8e:	af e2       	ldi	r26, 0x2F	; 47
    2e90:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    2e92:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
    2e96:	80 2d       	mov	r24, r0
    2e98:	18 2f       	mov	r17, r24
	{
		TotalBytes    = eeprom_read_byte(&EEPROMVars.TotalFuseBytes);
		EEPROMAddress = EEPROMVars.FuseBytes;
    2e9a:	c1 e3       	ldi	r28, 0x31	; 49
    2e9c:	d0 e0       	ldi	r29, 0x00	; 0
    2e9e:	08 c0       	rjmp	.+16     	; 0x2eb0 <PM_SendFuseLockBytes+0x2e>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2ea0:	a0 e3       	ldi	r26, 0x30	; 48
    2ea2:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    2ea4:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
    2ea8:	80 2d       	mov	r24, r0
    2eaa:	18 2f       	mov	r17, r24
	}
	else
	{
		TotalBytes    = eeprom_read_byte(&EEPROMVars.TotalLockBytes);
		EEPROMAddress = EEPROMVars.LockBytes;	
    2eac:	c9 e5       	ldi	r28, 0x59	; 89
    2eae:	d0 e0       	ldi	r29, 0x00	; 0
	}

	while (TotalBytes--)                              // Write each of the fuse/lock bytes stored in memory to the slave AVR
	{
		for (uint8_t CommandByte = 0; CommandByte < 4; CommandByte++)      // Write each individual command byte
		{
			USI_SPITransmit(eeprom_read_byte(EEPROMAddress));
			EEPROMAddress++;
		}
		
		// Add some delay before programming next byte, if there is one:
		if (TotalBytes)
		  MAIN_Delay10MS(5);
    2eb0:	11 50       	subi	r17, 0x01	; 1
    2eb2:	1f 3f       	cpi	r17, 0xFF	; 255
    2eb4:	91 f0       	breq	.+36     	; 0x2eda <PM_SendFuseLockBytes+0x58>
    2eb6:	03 e0       	ldi	r16, 0x03	; 3
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2eb8:	de 01       	movw	r26, r28
    2eba:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
    2ebe:	80 2d       	mov	r24, r0
    2ec0:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    2ec4:	21 96       	adiw	r28, 0x01	; 1
    2ec6:	01 50       	subi	r16, 0x01	; 1
    2ec8:	07 ff       	sbrs	r16, 7
    2eca:	f6 cf       	rjmp	.-20     	; 0x2eb8 <PM_SendFuseLockBytes+0x36>
    2ecc:	11 23       	and	r17, r17
    2ece:	19 f0       	breq	.+6      	; 0x2ed6 <PM_SendFuseLockBytes+0x54>
    2ed0:	85 e0       	ldi	r24, 0x05	; 5
    2ed2:	0e 94 2e 02 	call	0x45c <MAIN_Delay10MS>
    2ed6:	11 50       	subi	r17, 0x01	; 1
    2ed8:	70 f7       	brcc	.-36     	; 0x2eb6 <PM_SendFuseLockBytes+0x34>
    2eda:	df 91       	pop	r29
    2edc:	cf 91       	pop	r28
    2ede:	1f 91       	pop	r17
    2ee0:	0f 91       	pop	r16
    2ee2:	08 95       	ret

00002ee4 <PM_SendEraseCommand>:
	}
}

void PM_SendEraseCommand(void)
{			
    2ee4:	1f 93       	push	r17
    2ee6:	cf 93       	push	r28
    2ee8:	df 93       	push	r29
    2eea:	c2 e0       	ldi	r28, 0x02	; 2
    2eec:	d0 e0       	ldi	r29, 0x00	; 0
    2eee:	13 e0       	ldi	r17, 0x03	; 3
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2ef0:	de 01       	movw	r26, r28
    2ef2:	ab 5e       	subi	r26, 0xEB	; 235
    2ef4:	bf 4f       	sbci	r27, 0xFF	; 255
  uint8_t result;
  asm volatile
    2ef6:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
    2efa:	80 2d       	mov	r24, r0
    2efc:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
	for (uint8_t B = 2; B < 6 ; B++)                  // Read out the erase chip command bytes
    2f00:	11 50       	subi	r17, 0x01	; 1
    2f02:	21 96       	adiw	r28, 0x01	; 1
    2f04:	17 ff       	sbrs	r17, 7
    2f06:	f4 cf       	rjmp	.-24     	; 0x2ef0 <PM_SendEraseCommand+0xc>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2f08:	a6 e1       	ldi	r26, 0x16	; 22
    2f0a:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    2f0c:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
    2f10:	80 2d       	mov	r24, r0
    2f12:	88 23       	and	r24, r24
    2f14:	59 f0       	breq	.+22     	; 0x2f2c <PM_SendEraseCommand+0x48>
	  USI_SPITransmit(eeprom_read_byte(&EEPROMVars.EraseChip[B])); // Send the erase chip commands
			
	if (eeprom_read_byte(&EEPROMVars.EraseChip[1]))   // Value of 1 indicates a busy flag test
	{
		do
			USI_SPITransmitWord(0xF000);
    2f16:	80 e0       	ldi	r24, 0x00	; 0
    2f18:	90 ef       	ldi	r25, 0xF0	; 240
    2f1a:	0e 94 ab 09 	call	0x1356 <USI_SPITransmitWord>
    2f1e:	80 e0       	ldi	r24, 0x00	; 0
    2f20:	90 e0       	ldi	r25, 0x00	; 0
    2f22:	0e 94 ab 09 	call	0x1356 <USI_SPITransmitWord>
    2f26:	80 fd       	sbrc	r24, 0
    2f28:	f6 cf       	rjmp	.-20     	; 0x2f16 <PM_SendEraseCommand+0x32>
    2f2a:	07 c0       	rjmp	.+14     	; 0x2f3a <PM_SendEraseCommand+0x56>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2f2c:	a5 e1       	ldi	r26, 0x15	; 21
    2f2e:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    2f30:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
    2f34:	80 2d       	mov	r24, r0
    2f36:	0e 94 04 03 	call	0x608 <MAIN_Delay1MS>
    2f3a:	df 91       	pop	r29
    2f3c:	cf 91       	pop	r28
    2f3e:	1f 91       	pop	r17
    2f40:	08 95       	ret

00002f42 <PM_CreateProgrammingPackets>:
		while (USI_SPITransmitWord(0x0000) & 0x01);
	}
	else                                              // Cleared flag means use a predefined delay
	{		
		MAIN_Delay1MS(eeprom_read_byte(&EEPROMVars.EraseChip[0])); // Wait the erase delay
	}
}

void PM_CreateProgrammingPackets(const uint8_t Type)
{			
    2f42:	3f 92       	push	r3
    2f44:	4f 92       	push	r4
    2f46:	5f 92       	push	r5
    2f48:	6f 92       	push	r6
    2f4a:	7f 92       	push	r7
    2f4c:	8f 92       	push	r8
    2f4e:	9f 92       	push	r9
    2f50:	af 92       	push	r10
    2f52:	bf 92       	push	r11
    2f54:	cf 92       	push	r12
    2f56:	df 92       	push	r13
    2f58:	ef 92       	push	r14
    2f5a:	ff 92       	push	r15
    2f5c:	0f 93       	push	r16
    2f5e:	1f 93       	push	r17
    2f60:	cf 93       	push	r28
    2f62:	df 93       	push	r29
    2f64:	c8 2f       	mov	r28, r24
	uint32_t BytesRead       = 0;
    2f66:	aa 24       	eor	r10, r10
    2f68:	bb 24       	eor	r11, r11
    2f6a:	65 01       	movw	r12, r10
	uint32_t BytesToRead     = PM_GetStoredDataSize(Type);      // Get the byte size of the stored program
    2f6c:	0e 94 de 13 	call	0x27bc <PM_GetStoredDataSize>
    2f70:	2b 01       	movw	r4, r22
    2f72:	3c 01       	movw	r6, r24
	uint16_t BytesPerProgram;
	uint16_t PageLength;
	uint8_t* EEPROMAddress;
	uint8_t  ContinuedPage   = FALSE;
    2f74:	33 24       	eor	r3, r3
/** \ingroup avr_eeprom
    Read one 16-bit word (little endian) from EEPROM address \c addr. */
uint16_t
eeprom_read_word (const uint16_t *addr)
{
    2f76:	c1 30       	cpi	r28, 0x01	; 1
    2f78:	19 f4       	brne	.+6      	; 0x2f80 <PM_CreateProgrammingPackets+0x3e>
    2f7a:	a1 e8       	ldi	r26, 0x81	; 129
    2f7c:	b0 e0       	ldi	r27, 0x00	; 0
    2f7e:	02 c0       	rjmp	.+4      	; 0x2f84 <PM_CreateProgrammingPackets+0x42>
    2f80:	a3 e8       	ldi	r26, 0x83	; 131
    2f82:	b0 e0       	ldi	r27, 0x00	; 0
  uint16_t result;

  asm ( 
    2f84:	0e 94 5f 1a 	call	0x34be <__eeprom_read_word_1F2021>
    2f88:	4f 01       	movw	r8, r30

	PageLength  = eeprom_read_word((Type == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength);
	CurrAddress = 0;
    2f8a:	10 92 42 01 	sts	0x0142, r1
    2f8e:	10 92 43 01 	sts	0x0143, r1
    2f92:	10 92 44 01 	sts	0x0144, r1
    2f96:	10 92 45 01 	sts	0x0145, r1

	if (Type == TYPE_FLASH)
    2f9a:	c1 30       	cpi	r28, 0x01	; 1
    2f9c:	49 f4       	brne	.+18     	; 0x2fb0 <PM_CreateProgrammingPackets+0x6e>
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram;       // Set the EEPROM pointer to the write flash command bytes location
    2f9e:	c2 e0       	ldi	r28, 0x02	; 2
    2fa0:	d0 e0       	ldi	r29, 0x00	; 0
		DF_ContinuousReadEnable(0, 0);
    2fa2:	60 e0       	ldi	r22, 0x00	; 0
    2fa4:	70 e0       	ldi	r23, 0x00	; 0
    2fa6:	cb 01       	movw	r24, r22
    2fa8:	0e 94 04 0a 	call	0x1408 <DF_ContinuousReadEnable>
		PacketBytes[0] = CMD_PROGRAM_FLASH_ISP;
    2fac:	83 e1       	ldi	r24, 0x13	; 19
    2fae:	09 c0       	rjmp	.+18     	; 0x2fc2 <PM_CreateProgrammingPackets+0x80>
	}
	else
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;        // Set the EEPROM pointer to the write EEPROM command bytes location
    2fb0:	cb e0       	ldi	r28, 0x0B	; 11
    2fb2:	d0 e0       	ldi	r29, 0x00	; 0
		DF_ContinuousReadEnable(PM_EEPROM_OFFSET / DF_INTERNALDF_BUFFBYTES, PM_EEPROM_OFFSET % DF_INTERNALDF_BUFFBYTES); // Start read from the EEPROM offset location
    2fb4:	60 ee       	ldi	r22, 0xE0	; 224
    2fb6:	70 e0       	ldi	r23, 0x00	; 0
    2fb8:	84 ee       	ldi	r24, 0xE4	; 228
    2fba:	93 e0       	ldi	r25, 0x03	; 3
    2fbc:	0e 94 04 0a 	call	0x1408 <DF_ContinuousReadEnable>
		PacketBytes[0] = CMD_PROGRAM_EEPROM_ISP;
    2fc0:	85 e1       	ldi	r24, 0x15	; 21
    2fc2:	80 93 4b 01 	sts	0x014B, r24
    2fc6:	ec e4       	ldi	r30, 0x4C	; 76
    2fc8:	f1 e0       	ldi	r31, 0x01	; 1
    2fca:	98 e0       	ldi	r25, 0x08	; 8
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2fcc:	de 01       	movw	r26, r28
    2fce:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
    2fd2:	80 2d       	mov	r24, r0
    2fd4:	81 93       	st	Z+, r24
	}

	for (uint8_t B = 1; B <= 9 ; B++)                 // Load in the write data command bytes
	{
		PacketBytes[B] = eeprom_read_byte(EEPROMAddress); // Synthesise a write packet header
		EEPROMAddress++;                               // Increment the EEPROM location counter
    2fd6:	21 96       	adiw	r28, 0x01	; 1
    2fd8:	91 50       	subi	r25, 0x01	; 1
    2fda:	97 ff       	sbrs	r25, 7
    2fdc:	f7 cf       	rjmp	.-18     	; 0x2fcc <PM_CreateProgrammingPackets+0x8a>
	}
	
	BytesPerProgram = ((uint16_t)PacketBytes[1] << 8)
    2fde:	80 91 4c 01 	lds	r24, 0x014C
    2fe2:	99 27       	eor	r25, r25
    2fe4:	d8 2f       	mov	r29, r24
    2fe6:	cc 27       	eor	r28, r28
    2fe8:	80 91 4d 01 	lds	r24, 0x014D
    2fec:	99 27       	eor	r25, r25
    2fee:	c8 2b       	or	r28, r24
    2ff0:	d9 2b       	or	r29, r25
	                | PacketBytes[2];

	while (BytesRead < BytesToRead)
	{
		if (PacketBytes[3] & ISPCC_PROG_MODE_PAGE)
		{
			if (PageLength > 160) // Max 160 bytes at a time
			{
				if (!(ContinuedPage))                      // Start of a new page, program in the first 150 bytes
				{
					BytesPerProgram = 160;
					PacketBytes[3] &= ~ISPCC_PROG_MODE_PAGEDONE;		
					ContinuedPage = TRUE;
				}
				else                                       // Middle of a page, program in the remainder
				{
					BytesPerProgram = PageLength - 160;
					PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
					ContinuedPage = FALSE;
				}
				
				for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page				

				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);
				PacketBytes[2] = (uint8_t)(BytesPerProgram);

				BytesRead += BytesPerProgram;                         // Increment the counter
			}
			else
			{
				for (uint16_t LoadB = 0; LoadB < PageLength; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page
			
				PacketBytes[1]  = (uint8_t)(PageLength >> 8);
				PacketBytes[2]  = (uint8_t)(PageLength);
				PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;

				BytesRead += PageLength;                            // Increment the counter
			}
		}
		else
		{
			if ((BytesRead + BytesPerProgram) > BytesToRead)        // Less than a whole BytesPerProgram left of data to write
			{
				BytesPerProgram = BytesToRead - BytesRead;          // Next lot of bytes will be the remaining data length
				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);   // \. Save the new length
				PacketBytes[2] = (uint8_t)(BytesPerProgram);        // /  into the data packet
			}

			for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
				PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);    // Load in the page
			
			BytesRead += BytesPerProgram;                           // Increment the counter
		}
	
		if (!(BytesRead & 0xFFFF) && (BytesRead & 0x00FF0000))      // Extended address required
		{
			USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);            // Load extended address command
			USI_SPITransmit(0x00);
			USI_SPITransmit((BytesRead & 0x00FF0000) >> 16);        // The 3rd byte of the long holds the extended address
			USI_SPITransmit(0x00);
		}

		ISPCC_ProgramChip();                                        // Start the program cycle
    2ff2:	a4 14       	cp	r10, r4
    2ff4:	b5 04       	cpc	r11, r5
    2ff6:	c6 04       	cpc	r12, r6
    2ff8:	d7 04       	cpc	r13, r7
    2ffa:	08 f0       	brcs	.+2      	; 0x2ffe <PM_CreateProgrammingPackets+0xbc>
    2ffc:	b2 c0       	rjmp	.+356    	; 0x3162 <PM_CreateProgrammingPackets+0x220>
    2ffe:	20 91 4e 01 	lds	r18, 0x014E
    3002:	82 2f       	mov	r24, r18
    3004:	99 27       	eor	r25, r25
    3006:	ac 01       	movw	r20, r24
    3008:	41 70       	andi	r20, 0x01	; 1
    300a:	50 70       	andi	r21, 0x00	; 0
    300c:	80 ff       	sbrs	r24, 0
    300e:	53 c0       	rjmp	.+166    	; 0x30b6 <PM_CreateProgrammingPackets+0x174>
    3010:	f1 ea       	ldi	r31, 0xA1	; 161
    3012:	8f 16       	cp	r8, r31
    3014:	91 04       	cpc	r9, r1
    3016:	60 f1       	brcs	.+88     	; 0x3070 <PM_CreateProgrammingPackets+0x12e>
    3018:	33 20       	and	r3, r3
    301a:	41 f4       	brne	.+16     	; 0x302c <PM_CreateProgrammingPackets+0xea>
    301c:	c0 ea       	ldi	r28, 0xA0	; 160
    301e:	d0 e0       	ldi	r29, 0x00	; 0
    3020:	2f 77       	andi	r18, 0x7F	; 127
    3022:	20 93 4e 01 	sts	0x014E, r18
    3026:	31 e0       	ldi	r19, 0x01	; 1
    3028:	33 2e       	mov	r3, r19
    302a:	07 c0       	rjmp	.+14     	; 0x303a <PM_CreateProgrammingPackets+0xf8>
    302c:	e4 01       	movw	r28, r8
    302e:	c0 5a       	subi	r28, 0xA0	; 160
    3030:	d0 40       	sbci	r29, 0x00	; 0
    3032:	20 68       	ori	r18, 0x80	; 128
    3034:	20 93 4e 01 	sts	0x014E, r18
    3038:	33 24       	eor	r3, r3
    303a:	00 e0       	ldi	r16, 0x00	; 0
    303c:	10 e0       	ldi	r17, 0x00	; 0
    303e:	0c 17       	cp	r16, r28
    3040:	1d 07       	cpc	r17, r29
    3042:	78 f4       	brcc	.+30     	; 0x3062 <PM_CreateProgrammingPackets+0x120>
    3044:	25 e5       	ldi	r18, 0x55	; 85
    3046:	e2 2e       	mov	r14, r18
    3048:	21 e0       	ldi	r18, 0x01	; 1
    304a:	f2 2e       	mov	r15, r18
    304c:	80 e0       	ldi	r24, 0x00	; 0
    304e:	0e 94 33 09 	call	0x1266 <SPI_SPITransmit>
    3052:	f7 01       	movw	r30, r14
    3054:	81 93       	st	Z+, r24
    3056:	7f 01       	movw	r14, r30
    3058:	0f 5f       	subi	r16, 0xFF	; 255
    305a:	1f 4f       	sbci	r17, 0xFF	; 255
    305c:	0c 17       	cp	r16, r28
    305e:	1d 07       	cpc	r17, r29
    3060:	a8 f3       	brcs	.-22     	; 0x304c <PM_CreateProgrammingPackets+0x10a>
    3062:	8d 2f       	mov	r24, r29
    3064:	99 27       	eor	r25, r25
    3066:	80 93 4c 01 	sts	0x014C, r24
    306a:	c0 93 4d 01 	sts	0x014D, r28
    306e:	4b c0       	rjmp	.+150    	; 0x3106 <PM_CreateProgrammingPackets+0x1c4>
    3070:	00 e0       	ldi	r16, 0x00	; 0
    3072:	10 e0       	ldi	r17, 0x00	; 0
    3074:	08 15       	cp	r16, r8
    3076:	19 05       	cpc	r17, r9
    3078:	78 f4       	brcc	.+30     	; 0x3098 <PM_CreateProgrammingPackets+0x156>
    307a:	85 e5       	ldi	r24, 0x55	; 85
    307c:	e8 2e       	mov	r14, r24
    307e:	81 e0       	ldi	r24, 0x01	; 1
    3080:	f8 2e       	mov	r15, r24
    3082:	80 e0       	ldi	r24, 0x00	; 0
    3084:	0e 94 33 09 	call	0x1266 <SPI_SPITransmit>
    3088:	f7 01       	movw	r30, r14
    308a:	81 93       	st	Z+, r24
    308c:	7f 01       	movw	r14, r30
    308e:	0f 5f       	subi	r16, 0xFF	; 255
    3090:	1f 4f       	sbci	r17, 0xFF	; 255
    3092:	08 15       	cp	r16, r8
    3094:	19 05       	cpc	r17, r9
    3096:	a8 f3       	brcs	.-22     	; 0x3082 <PM_CreateProgrammingPackets+0x140>
    3098:	89 2d       	mov	r24, r9
    309a:	99 27       	eor	r25, r25
    309c:	80 93 4c 01 	sts	0x014C, r24
    30a0:	80 92 4d 01 	sts	0x014D, r8
    30a4:	80 91 4e 01 	lds	r24, 0x014E
    30a8:	80 68       	ori	r24, 0x80	; 128
    30aa:	80 93 4e 01 	sts	0x014E, r24
    30ae:	c4 01       	movw	r24, r8
    30b0:	aa 27       	eor	r26, r26
    30b2:	bb 27       	eor	r27, r27
    30b4:	2b c0       	rjmp	.+86     	; 0x310c <PM_CreateProgrammingPackets+0x1ca>
    30b6:	ce 01       	movw	r24, r28
    30b8:	aa 27       	eor	r26, r26
    30ba:	bb 27       	eor	r27, r27
    30bc:	8a 0d       	add	r24, r10
    30be:	9b 1d       	adc	r25, r11
    30c0:	ac 1d       	adc	r26, r12
    30c2:	bd 1d       	adc	r27, r13
    30c4:	48 16       	cp	r4, r24
    30c6:	59 06       	cpc	r5, r25
    30c8:	6a 06       	cpc	r6, r26
    30ca:	7b 06       	cpc	r7, r27
    30cc:	48 f4       	brcc	.+18     	; 0x30e0 <PM_CreateProgrammingPackets+0x19e>
    30ce:	e2 01       	movw	r28, r4
    30d0:	ca 19       	sub	r28, r10
    30d2:	db 09       	sbc	r29, r11
    30d4:	8d 2f       	mov	r24, r29
    30d6:	99 27       	eor	r25, r25
    30d8:	80 93 4c 01 	sts	0x014C, r24
    30dc:	c0 93 4d 01 	sts	0x014D, r28
    30e0:	8a 01       	movw	r16, r20
    30e2:	4c 17       	cp	r20, r28
    30e4:	5d 07       	cpc	r21, r29
    30e6:	78 f4       	brcc	.+30     	; 0x3106 <PM_CreateProgrammingPackets+0x1c4>
    30e8:	f5 e5       	ldi	r31, 0x55	; 85
    30ea:	ef 2e       	mov	r14, r31
    30ec:	f1 e0       	ldi	r31, 0x01	; 1
    30ee:	ff 2e       	mov	r15, r31
    30f0:	80 e0       	ldi	r24, 0x00	; 0
    30f2:	0e 94 33 09 	call	0x1266 <SPI_SPITransmit>
    30f6:	f7 01       	movw	r30, r14
    30f8:	81 93       	st	Z+, r24
    30fa:	7f 01       	movw	r14, r30
    30fc:	0f 5f       	subi	r16, 0xFF	; 255
    30fe:	1f 4f       	sbci	r17, 0xFF	; 255
    3100:	0c 17       	cp	r16, r28
    3102:	1d 07       	cpc	r17, r29
    3104:	a8 f3       	brcs	.-22     	; 0x30f0 <PM_CreateProgrammingPackets+0x1ae>
    3106:	ce 01       	movw	r24, r28
    3108:	aa 27       	eor	r26, r26
    310a:	bb 27       	eor	r27, r27
    310c:	a8 0e       	add	r10, r24
    310e:	b9 1e       	adc	r11, r25
    3110:	ca 1e       	adc	r12, r26
    3112:	db 1e       	adc	r13, r27
    3114:	a1 14       	cp	r10, r1
    3116:	b1 04       	cpc	r11, r1
    3118:	e1 f4       	brne	.+56     	; 0x3152 <PM_CreateProgrammingPackets+0x210>
    311a:	e1 2c       	mov	r14, r1
    311c:	f1 2c       	mov	r15, r1
    311e:	ef ef       	ldi	r30, 0xFF	; 255
    3120:	0e 2f       	mov	r16, r30
    3122:	11 2d       	mov	r17, r1
    3124:	ea 20       	and	r14, r10
    3126:	fb 20       	and	r15, r11
    3128:	0c 21       	and	r16, r12
    312a:	1d 21       	and	r17, r13
    312c:	e1 14       	cp	r14, r1
    312e:	f1 04       	cpc	r15, r1
    3130:	01 05       	cpc	r16, r1
    3132:	11 05       	cpc	r17, r1
    3134:	71 f0       	breq	.+28     	; 0x3152 <PM_CreateProgrammingPackets+0x210>
    3136:	8d e4       	ldi	r24, 0x4D	; 77
    3138:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    313c:	80 e0       	ldi	r24, 0x00	; 0
    313e:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    3142:	c8 01       	movw	r24, r16
    3144:	aa 27       	eor	r26, r26
    3146:	bb 27       	eor	r27, r27
    3148:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    314c:	80 e0       	ldi	r24, 0x00	; 0
    314e:	0e 94 98 09 	call	0x1330 <USI_SPITransmit>
    3152:	0e 94 86 11 	call	0x230c <ISPCC_ProgramChip>
    3156:	a4 14       	cp	r10, r4
    3158:	b5 04       	cpc	r11, r5
    315a:	c6 04       	cpc	r12, r6
    315c:	d7 04       	cpc	r13, r7
    315e:	08 f4       	brcc	.+2      	; 0x3162 <PM_CreateProgrammingPackets+0x220>
    3160:	4e cf       	rjmp	.-356    	; 0x2ffe <PM_CreateProgrammingPackets+0xbc>
    3162:	df 91       	pop	r29
    3164:	cf 91       	pop	r28
    3166:	1f 91       	pop	r17
    3168:	0f 91       	pop	r16
    316a:	ff 90       	pop	r15
    316c:	ef 90       	pop	r14
    316e:	df 90       	pop	r13
    3170:	cf 90       	pop	r12
    3172:	bf 90       	pop	r11
    3174:	af 90       	pop	r10
    3176:	9f 90       	pop	r9
    3178:	8f 90       	pop	r8
    317a:	7f 90       	pop	r7
    317c:	6f 90       	pop	r6
    317e:	5f 90       	pop	r5
    3180:	4f 90       	pop	r4
    3182:	3f 90       	pop	r3
    3184:	08 95       	ret

00003186 <PM_ShowStoredItemSizes>:
	}
}

void PM_ShowStoredItemSizes(void)
{
    3186:	1f 93       	push	r17
    3188:	cf 93       	push	r28
    318a:	df 93       	push	r29
    318c:	cd b7       	in	r28, 0x3d	; 61
    318e:	de b7       	in	r29, 0x3e	; 62
    3190:	2e 97       	sbiw	r28, 0x0e	; 14
    3192:	0f b6       	in	r0, 0x3f	; 63
    3194:	f8 94       	cli
    3196:	de bf       	out	0x3e, r29	; 62
    3198:	0f be       	out	0x3f, r0	; 63
    319a:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[14];
	uint8_t ItemInfoIndex = 0;
    319c:	10 e0       	ldi	r17, 0x00	; 0
	uint8_t TempB;
	
	JoyStatus = 1;
    319e:	81 e0       	ldi	r24, 0x01	; 1
    31a0:	8e bb       	out	0x1e, r24	; 30
	
	while (1)
	{
		if (JoyStatus)                           // Joystick is in the non-center position
    31a2:	8e b3       	in	r24, 0x1e	; 30
    31a4:	88 23       	and	r24, r24
    31a6:	e9 f3       	breq	.-6      	; 0x31a2 <PM_ShowStoredItemSizes+0x1c>
		{
			if (JoyStatus & JOY_UP)              // Previous item
    31a8:	f6 9b       	sbis	0x1e, 6	; 30
    31aa:	06 c0       	rjmp	.+12     	; 0x31b8 <PM_ShowStoredItemSizes+0x32>
				(ItemInfoIndex == 0)? ItemInfoIndex = 3 : ItemInfoIndex--;
    31ac:	11 23       	and	r17, r17
    31ae:	11 f4       	brne	.+4      	; 0x31b4 <PM_ShowStoredItemSizes+0x2e>
    31b0:	13 e0       	ldi	r17, 0x03	; 3
    31b2:	0c c0       	rjmp	.+24     	; 0x31cc <PM_ShowStoredItemSizes+0x46>
    31b4:	11 50       	subi	r17, 0x01	; 1
    31b6:	0a c0       	rjmp	.+20     	; 0x31cc <PM_ShowStoredItemSizes+0x46>
			else if (JoyStatus & JOY_DOWN)      // Next item
    31b8:	f7 9b       	sbis	0x1e, 7	; 30
    31ba:	06 c0       	rjmp	.+12     	; 0x31c8 <PM_ShowStoredItemSizes+0x42>
				(ItemInfoIndex == 3)? ItemInfoIndex = 0 : ItemInfoIndex++;
    31bc:	13 30       	cpi	r17, 0x03	; 3
    31be:	11 f4       	brne	.+4      	; 0x31c4 <PM_ShowStoredItemSizes+0x3e>
    31c0:	10 e0       	ldi	r17, 0x00	; 0
    31c2:	04 c0       	rjmp	.+8      	; 0x31cc <PM_ShowStoredItemSizes+0x46>
    31c4:	1f 5f       	subi	r17, 0xFF	; 255
    31c6:	02 c0       	rjmp	.+4      	; 0x31cc <PM_ShowStoredItemSizes+0x46>
			else if (JoyStatus & JOY_LEFT)
    31c8:	f2 99       	sbic	0x1e, 2	; 30
    31ca:	54 c0       	rjmp	.+168    	; 0x3274 <PM_ShowStoredItemSizes+0xee>
				return;
		
			switch (ItemInfoIndex)
    31cc:	81 2f       	mov	r24, r17
    31ce:	99 27       	eor	r25, r25
    31d0:	81 30       	cpi	r24, 0x01	; 1
    31d2:	91 05       	cpc	r25, r1
    31d4:	a1 f0       	breq	.+40     	; 0x31fe <PM_ShowStoredItemSizes+0x78>
    31d6:	82 30       	cpi	r24, 0x02	; 2
    31d8:	91 05       	cpc	r25, r1
    31da:	1c f4       	brge	.+6      	; 0x31e2 <PM_ShowStoredItemSizes+0x5c>
    31dc:	89 2b       	or	r24, r25
    31de:	39 f0       	breq	.+14     	; 0x31ee <PM_ShowStoredItemSizes+0x68>
    31e0:	42 c0       	rjmp	.+132    	; 0x3266 <PM_ShowStoredItemSizes+0xe0>
    31e2:	82 30       	cpi	r24, 0x02	; 2
    31e4:	91 05       	cpc	r25, r1
    31e6:	01 f1       	breq	.+64     	; 0x3228 <PM_ShowStoredItemSizes+0xa2>
    31e8:	03 97       	sbiw	r24, 0x03	; 3
    31ea:	39 f1       	breq	.+78     	; 0x323a <PM_ShowStoredItemSizes+0xb4>
    31ec:	3c c0       	rjmp	.+120    	; 0x3266 <PM_ShowStoredItemSizes+0xe0>
			{
				case 0:
					strcpy_P(Buffer, PSTR("DATA-"));
    31ee:	62 e0       	ldi	r22, 0x02	; 2
    31f0:	74 e0       	ldi	r23, 0x04	; 4
    31f2:	ce 01       	movw	r24, r28
    31f4:	01 96       	adiw	r24, 0x01	; 1
    31f6:	0e 94 16 1a 	call	0x342c <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_FLASH), &Buffer[5], 10);
    31fa:	81 e0       	ldi	r24, 0x01	; 1
    31fc:	07 c0       	rjmp	.+14     	; 0x320c <PM_ShowStoredItemSizes+0x86>
					break;
				case 1:
					strcpy_P(Buffer, PSTR("EPRM-"));
    31fe:	68 e0       	ldi	r22, 0x08	; 8
    3200:	74 e0       	ldi	r23, 0x04	; 4
    3202:	ce 01       	movw	r24, r28
    3204:	01 96       	adiw	r24, 0x01	; 1
    3206:	0e 94 16 1a 	call	0x342c <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_EEPROM), &Buffer[5], 10);
    320a:	80 e0       	ldi	r24, 0x00	; 0
    320c:	0e 94 de 13 	call	0x27bc <PM_GetStoredDataSize>
    3210:	dc 01       	movw	r26, r24
    3212:	cb 01       	movw	r24, r22
    3214:	2a e0       	ldi	r18, 0x0A	; 10
    3216:	30 e0       	ldi	r19, 0x00	; 0
    3218:	ae 01       	movw	r20, r28
    321a:	4a 5f       	subi	r20, 0xFA	; 250
    321c:	5f 4f       	sbci	r21, 0xFF	; 255
    321e:	bc 01       	movw	r22, r24
    3220:	cd 01       	movw	r24, r26
    3222:	0e 94 1d 1a 	call	0x343a <ultoa>
					break;
    3226:	1f c0       	rjmp	.+62     	; 0x3266 <PM_ShowStoredItemSizes+0xe0>
				case 2:
					strcpy_P(Buffer, PSTR("FUSE-"));
    3228:	6e e0       	ldi	r22, 0x0E	; 14
    322a:	74 e0       	ldi	r23, 0x04	; 4
    322c:	ce 01       	movw	r24, r28
    322e:	01 96       	adiw	r24, 0x01	; 1
    3230:	0e 94 16 1a 	call	0x342c <strcpy_P>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    3234:	af e2       	ldi	r26, 0x2F	; 47
    3236:	b0 e0       	ldi	r27, 0x00	; 0
    3238:	08 c0       	rjmp	.+16     	; 0x324a <PM_ShowStoredItemSizes+0xc4>
					TempB = eeprom_read_byte(&EEPROMVars.TotalFuseBytes);
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);
					break;
				case 3:
					strcpy_P(Buffer, PSTR("LOCK-"));
    323a:	64 e1       	ldi	r22, 0x14	; 20
    323c:	74 e0       	ldi	r23, 0x04	; 4
    323e:	ce 01       	movw	r24, r28
    3240:	01 96       	adiw	r24, 0x01	; 1
    3242:	0e 94 16 1a 	call	0x342c <strcpy_P>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    3246:	a0 e3       	ldi	r26, 0x30	; 48
    3248:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    324a:	0e 94 52 1a 	call	0x34a4 <__eeprom_read_byte_1F2021>
    324e:	80 2d       	mov	r24, r0
					TempB = eeprom_read_byte(&EEPROMVars.TotalLockBytes);
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);		
    3250:	8f 3f       	cpi	r24, 0xFF	; 255
    3252:	11 f0       	breq	.+4      	; 0x3258 <PM_ShowStoredItemSizes+0xd2>
    3254:	99 27       	eor	r25, r25
    3256:	02 c0       	rjmp	.+4      	; 0x325c <PM_ShowStoredItemSizes+0xd6>
    3258:	80 e0       	ldi	r24, 0x00	; 0
    325a:	90 e0       	ldi	r25, 0x00	; 0
    325c:	be 01       	movw	r22, r28
    325e:	6a 5f       	subi	r22, 0xFA	; 250
    3260:	7f 4f       	sbci	r23, 0xFF	; 255
    3262:	0e 94 32 03 	call	0x664 <MAIN_IntToStr>
			}
	
			LCD_puts(Buffer);
    3266:	ce 01       	movw	r24, r28
    3268:	01 96       	adiw	r24, 0x01	; 1
    326a:	0e 94 14 08 	call	0x1028 <LCD_puts>

			MAIN_WaitForJoyRelease();
    326e:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>
    3272:	97 cf       	rjmp	.-210    	; 0x31a2 <PM_ShowStoredItemSizes+0x1c>
    3274:	2e 96       	adiw	r28, 0x0e	; 14
    3276:	0f b6       	in	r0, 0x3f	; 63
    3278:	f8 94       	cli
    327a:	de bf       	out	0x3e, r29	; 62
    327c:	0f be       	out	0x3f, r0	; 63
    327e:	cd bf       	out	0x3d, r28	; 61
    3280:	df 91       	pop	r29
    3282:	cf 91       	pop	r28
    3284:	1f 91       	pop	r17
    3286:	08 95       	ret

00003288 <TM_FindNextTag>:
	DF_EnableDataflash(FALSE);
}

void TM_FindNextTag(void)
{
    3288:	af 92       	push	r10
    328a:	bf 92       	push	r11
    328c:	df 92       	push	r13
    328e:	ef 92       	push	r14
    3290:	ff 92       	push	r15
    3292:	0f 93       	push	r16
    3294:	1f 93       	push	r17
    3296:	cf 93       	push	r28
    3298:	df 93       	push	r29
    329a:	cd b7       	in	r28, 0x3d	; 61
    329c:	de b7       	in	r29, 0x3e	; 62
    329e:	69 97       	sbiw	r28, 0x19	; 25
    32a0:	0f b6       	in	r0, 0x3f	; 63
    32a2:	f8 94       	cli
    32a4:	de bf       	out	0x3e, r29	; 62
    32a6:	0f be       	out	0x3f, r0	; 63
    32a8:	cd bf       	out	0x3d, r28	; 61
	uint8_t  Buffer[21];
	uint8_t  HeadBuff[4]      = BT_TAGHEADER;
    32aa:	80 e4       	ldi	r24, 0x40	; 64
    32ac:	8e 8b       	std	Y+22, r24	; 0x16
    32ae:	86 e1       	ldi	r24, 0x16	; 22
    32b0:	a8 2e       	mov	r10, r24
    32b2:	b1 2c       	mov	r11, r1
    32b4:	ac 0e       	add	r10, r28
    32b6:	bd 1e       	adc	r11, r29
    32b8:	88 e2       	ldi	r24, 0x28	; 40
    32ba:	8f 8b       	std	Y+23, r24	; 0x17
    32bc:	83 e2       	ldi	r24, 0x23	; 35
    32be:	88 8f       	std	Y+24, r24	; 0x18
    32c0:	89 e2       	ldi	r24, 0x29	; 41
    32c2:	89 8f       	std	Y+25, r24	; 0x19
	uint32_t ProgDataSize     = PM_GetStoredDataSize(TYPE_FLASH);
    32c4:	81 e0       	ldi	r24, 0x01	; 1
    32c6:	0e 94 de 13 	call	0x27bc <PM_GetStoredDataSize>
    32ca:	7b 01       	movw	r14, r22
    32cc:	8c 01       	movw	r16, r24
	uint8_t  TotalOkHeadBytes = 0;
    32ce:	dd 24       	eor	r13, r13
	uint8_t  TagByte;
	uint8_t  BytesRead;
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);    // Orange = busy
    32d0:	81 b3       	in	r24, 0x11	; 17
    32d2:	80 63       	ori	r24, 0x30	; 48
    32d4:	81 bb       	out	0x11, r24	; 17

	while (DFPos < ProgDataSize)
	{
		BytesRead = 1;
		
		if (SPI_SPITransmit(0x00) == HeadBuff[TotalOkHeadBytes++])
		{
			if (TotalOkHeadBytes == 4)
			{
				uint8_t HB;
			
				for (HB = 0; HB < 20; HB++)
				{
					TagByte = SPI_SPITransmit(0x00);
					Buffer[HB] = TagByte;
					
					if (TagByte == 0x00)
					  break;
				}
				
				Buffer[20] = '\0';             // Make sure string is null-terminated

				TagExists = TRUE;
				BytesRead = (HB + 2);

				LCD_puts(Buffer);
				MAIN_SETSTATUSLED(MAIN_STATLED_GREEN); // Green = ready
				return;
			}
		}
		else
		{
			TotalOkHeadBytes = 0;
		}

		DFPos += BytesRead;
    32d6:	80 91 b4 02 	lds	r24, 0x02B4
    32da:	90 91 b5 02 	lds	r25, 0x02B5
    32de:	a0 91 b6 02 	lds	r26, 0x02B6
    32e2:	b0 91 b7 02 	lds	r27, 0x02B7
    32e6:	8e 15       	cp	r24, r14
    32e8:	9f 05       	cpc	r25, r15
    32ea:	a0 07       	cpc	r26, r16
    32ec:	b1 07       	cpc	r27, r17
    32ee:	08 f0       	brcs	.+2      	; 0x32f2 <TM_FindNextTag+0x6a>
    32f0:	43 c0       	rjmp	.+134    	; 0x3378 <TM_FindNextTag+0xf0>
    32f2:	80 e0       	ldi	r24, 0x00	; 0
    32f4:	0e 94 33 09 	call	0x1266 <SPI_SPITransmit>
    32f8:	f5 01       	movw	r30, r10
    32fa:	ed 0d       	add	r30, r13
    32fc:	f1 1d       	adc	r31, r1
    32fe:	d3 94       	inc	r13
    3300:	90 81       	ld	r25, Z
    3302:	89 17       	cp	r24, r25
    3304:	21 f5       	brne	.+72     	; 0x334e <TM_FindNextTag+0xc6>
    3306:	84 e0       	ldi	r24, 0x04	; 4
    3308:	d8 16       	cp	r13, r24
    330a:	11 f5       	brne	.+68     	; 0x3350 <TM_FindNextTag+0xc8>
    330c:	ff 24       	eor	r15, r15
    330e:	00 e0       	ldi	r16, 0x00	; 0
    3310:	10 e0       	ldi	r17, 0x00	; 0
    3312:	80 e0       	ldi	r24, 0x00	; 0
    3314:	0e 94 33 09 	call	0x1266 <SPI_SPITransmit>
    3318:	9e 01       	movw	r18, r28
    331a:	2f 5f       	subi	r18, 0xFF	; 255
    331c:	3f 4f       	sbci	r19, 0xFF	; 255
    331e:	f8 01       	movw	r30, r16
    3320:	e2 0f       	add	r30, r18
    3322:	f3 1f       	adc	r31, r19
    3324:	80 83       	st	Z, r24
    3326:	88 23       	and	r24, r24
    3328:	31 f0       	breq	.+12     	; 0x3336 <TM_FindNextTag+0xae>
    332a:	f3 94       	inc	r15
    332c:	0f 5f       	subi	r16, 0xFF	; 255
    332e:	1f 4f       	sbci	r17, 0xFF	; 255
    3330:	83 e1       	ldi	r24, 0x13	; 19
    3332:	8f 15       	cp	r24, r15
    3334:	70 f7       	brcc	.-36     	; 0x3312 <TM_FindNextTag+0x8a>
    3336:	1d 8a       	std	Y+21, r1	; 0x15
    3338:	81 e0       	ldi	r24, 0x01	; 1
    333a:	80 93 62 02 	sts	0x0262, r24
    333e:	c9 01       	movw	r24, r18
    3340:	0e 94 14 08 	call	0x1028 <LCD_puts>
    3344:	81 b3       	in	r24, 0x11	; 17
    3346:	8f 7c       	andi	r24, 0xCF	; 207
    3348:	80 61       	ori	r24, 0x10	; 16
    334a:	81 bb       	out	0x11, r24	; 17
    334c:	31 c0       	rjmp	.+98     	; 0x33b0 <TM_FindNextTag+0x128>
    334e:	dd 24       	eor	r13, r13
    3350:	80 91 b4 02 	lds	r24, 0x02B4
    3354:	90 91 b5 02 	lds	r25, 0x02B5
    3358:	a0 91 b6 02 	lds	r26, 0x02B6
    335c:	b0 91 b7 02 	lds	r27, 0x02B7
    3360:	01 96       	adiw	r24, 0x01	; 1
    3362:	a1 1d       	adc	r26, r1
    3364:	b1 1d       	adc	r27, r1
    3366:	80 93 b4 02 	sts	0x02B4, r24
    336a:	90 93 b5 02 	sts	0x02B5, r25
    336e:	a0 93 b6 02 	sts	0x02B6, r26
    3372:	b0 93 b7 02 	sts	0x02B7, r27
    3376:	b7 cf       	rjmp	.-146    	; 0x32e6 <TM_FindNextTag+0x5e>
	}
	
	DF_ContinuousReadEnable(0, 0);
    3378:	60 e0       	ldi	r22, 0x00	; 0
    337a:	70 e0       	ldi	r23, 0x00	; 0
    337c:	cb 01       	movw	r24, r22
    337e:	0e 94 04 0a 	call	0x1408 <DF_ContinuousReadEnable>
	DFPos = 0;
    3382:	10 92 b4 02 	sts	0x02B4, r1
    3386:	10 92 b5 02 	sts	0x02B5, r1
    338a:	10 92 b6 02 	sts	0x02B6, r1
    338e:	10 92 b7 02 	sts	0x02B7, r1
	
	if (TagExists == FALSE)
    3392:	80 91 62 02 	lds	r24, 0x0262
    3396:	88 23       	and	r24, r24
    3398:	49 f4       	brne	.+18     	; 0x33ac <TM_FindNextTag+0x124>
	{
		MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);  // Green = ready
    339a:	81 b3       	in	r24, 0x11	; 17
    339c:	8f 7c       	andi	r24, 0xCF	; 207
    339e:	80 61       	ori	r24, 0x10	; 16
    33a0:	81 bb       	out	0x11, r24	; 17
		MAIN_ShowError(PSTR("NO TAGS"));
    33a2:	8a e1       	ldi	r24, 0x1A	; 26
    33a4:	94 e0       	ldi	r25, 0x04	; 4
    33a6:	0e 94 6b 03 	call	0x6d6 <MAIN_ShowError>
    33aa:	02 c0       	rjmp	.+4      	; 0x33b0 <TM_FindNextTag+0x128>
	}
	else
	{
		/* The following line _is_ recursion, but the function will only ever call itself
		   a maximum of one time. The function will call itself upon skipping from the last
		   tag stored in the program data to the first; to guard against infinite recursion
		   if no tags are present, the system will error out if the TagExists flag is empty
		   after a full data read. Once a tag has been read and displayed onto the LCD, the
           function returns to the main tag handling routine.                               */
		TM_FindNextTag();
    33ac:	0e 94 44 19 	call	0x3288 <TM_FindNextTag>
    33b0:	69 96       	adiw	r28, 0x19	; 25
    33b2:	0f b6       	in	r0, 0x3f	; 63
    33b4:	f8 94       	cli
    33b6:	de bf       	out	0x3e, r29	; 62
    33b8:	0f be       	out	0x3f, r0	; 63
    33ba:	cd bf       	out	0x3d, r28	; 61
    33bc:	df 91       	pop	r29
    33be:	cf 91       	pop	r28
    33c0:	1f 91       	pop	r17
    33c2:	0f 91       	pop	r16
    33c4:	ff 90       	pop	r15
    33c6:	ef 90       	pop	r14
    33c8:	df 90       	pop	r13
    33ca:	bf 90       	pop	r11
    33cc:	af 90       	pop	r10
    33ce:	08 95       	ret

000033d0 <TM_ShowTags>:
    33d0:	60 e0       	ldi	r22, 0x00	; 0
    33d2:	70 e0       	ldi	r23, 0x00	; 0
    33d4:	cb 01       	movw	r24, r22
    33d6:	0e 94 04 0a 	call	0x1408 <DF_ContinuousReadEnable>
    33da:	10 92 62 02 	sts	0x0262, r1
    33de:	10 92 b4 02 	sts	0x02B4, r1
    33e2:	10 92 b5 02 	sts	0x02B5, r1
    33e6:	10 92 b6 02 	sts	0x02B6, r1
    33ea:	10 92 b7 02 	sts	0x02B7, r1
    33ee:	0e 94 44 19 	call	0x3288 <TM_FindNextTag>
    33f2:	80 91 62 02 	lds	r24, 0x0262
    33f6:	88 23       	and	r24, r24
    33f8:	71 f0       	breq	.+28     	; 0x3416 <TM_ShowTags+0x46>
    33fa:	8e b3       	in	r24, 0x1e	; 30
    33fc:	88 23       	and	r24, r24
    33fe:	e9 f3       	breq	.-6      	; 0x33fa <TM_ShowTags+0x2a>
    3400:	f7 9b       	sbis	0x1e, 7	; 30
    3402:	03 c0       	rjmp	.+6      	; 0x340a <TM_ShowTags+0x3a>
    3404:	0e 94 44 19 	call	0x3288 <TM_FindNextTag>
    3408:	02 c0       	rjmp	.+4      	; 0x340e <TM_ShowTags+0x3e>
    340a:	f2 99       	sbic	0x1e, 2	; 30
    340c:	03 c0       	rjmp	.+6      	; 0x3414 <TM_ShowTags+0x44>
    340e:	0e 94 40 02 	call	0x480 <MAIN_WaitForJoyRelease>
    3412:	f3 cf       	rjmp	.-26     	; 0x33fa <TM_ShowTags+0x2a>
    3414:	80 e0       	ldi	r24, 0x00	; 0
    3416:	0e 94 cd 09 	call	0x139a <DF_EnableDataflash>
    341a:	08 95       	ret

0000341c <__vector_2>:
.global PCINT0_vect             ; Pin change 0 (joystick)
.global PCINT1_vect             ; Pin change 1 (joystick)

PCINT0_vect:
  jmp PCINT1_vect
    341c:	0c 94 91 03 	jmp	0x722 <__vector_3>

00003420 <__vector_10>:

.global TIMER0_COMP_vect             ; Timer 0 compare

TIMER0_COMP_vect:
  push r24
    3420:	8f 93       	push	r24
  ldi r24, (USI_CONTROL_REG_FLAGS | (1<<USITC))
    3422:	8b e5       	ldi	r24, 0x5B	; 91
  sts _SFR_MEM_ADDR(USICR), r24
    3424:	80 93 b8 00 	sts	0x00B8, r24
  pop r24
    3428:	8f 91       	pop	r24
  reti
    342a:	18 95       	reti

0000342c <strcpy_P>:
    342c:	fb 01       	movw	r30, r22
    342e:	dc 01       	movw	r26, r24
    3430:	05 90       	lpm	r0, Z+
    3432:	0d 92       	st	X+, r0
    3434:	00 20       	and	r0, r0
    3436:	e1 f7       	brne	.-8      	; 0x3430 <strcpy_P+0x4>
    3438:	08 95       	ret

0000343a <ultoa>:
    343a:	fa 01       	movw	r30, r20
    343c:	cf 93       	push	r28
    343e:	ff 93       	push	r31
    3440:	ef 93       	push	r30
    3442:	22 30       	cpi	r18, 0x02	; 2
    3444:	cc f0       	brlt	.+50     	; 0x3478 <ultoa+0x3e>
    3446:	25 32       	cpi	r18, 0x25	; 37
    3448:	bc f4       	brge	.+46     	; 0x3478 <ultoa+0x3e>
    344a:	c2 2f       	mov	r28, r18
    344c:	2c 2f       	mov	r18, r28
    344e:	33 27       	eor	r19, r19
    3450:	44 27       	eor	r20, r20
    3452:	55 27       	eor	r21, r21
    3454:	ff 93       	push	r31
    3456:	ef 93       	push	r30
    3458:	0e 94 7a 1a 	call	0x34f4 <__udivmodsi4>
    345c:	ef 91       	pop	r30
    345e:	ff 91       	pop	r31
    3460:	60 5d       	subi	r22, 0xD0	; 208
    3462:	6a 33       	cpi	r22, 0x3A	; 58
    3464:	0c f0       	brlt	.+2      	; 0x3468 <ultoa+0x2e>
    3466:	69 5d       	subi	r22, 0xD9	; 217
    3468:	61 93       	st	Z+, r22
    346a:	b9 01       	movw	r22, r18
    346c:	ca 01       	movw	r24, r20
    346e:	60 50       	subi	r22, 0x00	; 0
    3470:	70 40       	sbci	r23, 0x00	; 0
    3472:	80 40       	sbci	r24, 0x00	; 0
    3474:	90 40       	sbci	r25, 0x00	; 0
    3476:	51 f7       	brne	.-44     	; 0x344c <ultoa+0x12>
    3478:	10 82       	st	Z, r1
    347a:	8f 91       	pop	r24
    347c:	9f 91       	pop	r25
    347e:	cf 91       	pop	r28
    3480:	0c 94 42 1a 	jmp	0x3484 <strrev>

00003484 <strrev>:
    3484:	dc 01       	movw	r26, r24
    3486:	fc 01       	movw	r30, r24
    3488:	01 90       	ld	r0, Z+
    348a:	00 20       	and	r0, r0
    348c:	e9 f7       	brne	.-6      	; 0x3488 <strrev+0x4>
    348e:	32 97       	sbiw	r30, 0x02	; 2
    3490:	ae 17       	cp	r26, r30
    3492:	bf 07       	cpc	r27, r31
    3494:	30 f4       	brcc	.+12     	; 0x34a2 <strrev+0x1e>
    3496:	7c 91       	ld	r23, X
    3498:	60 81       	ld	r22, Z
    349a:	70 83       	st	Z, r23
    349c:	31 97       	sbiw	r30, 0x01	; 1
    349e:	6d 93       	st	X+, r22
    34a0:	f7 cf       	rjmp	.-18     	; 0x3490 <strrev+0xc>
    34a2:	08 95       	ret

000034a4 <__eeprom_read_byte_1F2021>:
    34a4:	f9 99       	sbic	0x1f, 1	; 31
    34a6:	fe cf       	rjmp	.-4      	; 0x34a4 <__eeprom_read_byte_1F2021>
    34a8:	b2 bd       	out	0x22, r27	; 34
    34aa:	a1 bd       	out	0x21, r26	; 33
    34ac:	f8 9a       	sbi	0x1f, 0	; 31
    34ae:	11 96       	adiw	r26, 0x01	; 1
    34b0:	00 b4       	in	r0, 0x20	; 32
    34b2:	08 95       	ret

000034b4 <__eeprom_read_block_1F2021>:
    34b4:	f7 df       	rcall	.-18     	; 0x34a4 <__eeprom_read_byte_1F2021>
    34b6:	01 92       	st	Z+, r0
    34b8:	1a 94       	dec	r1
    34ba:	e1 f7       	brne	.-8      	; 0x34b4 <__eeprom_read_block_1F2021>
    34bc:	08 95       	ret

000034be <__eeprom_read_word_1F2021>:
    34be:	f2 df       	rcall	.-28     	; 0x34a4 <__eeprom_read_byte_1F2021>
    34c0:	e0 2d       	mov	r30, r0
    34c2:	f0 df       	rcall	.-32     	; 0x34a4 <__eeprom_read_byte_1F2021>
    34c4:	f0 2d       	mov	r31, r0
    34c6:	08 95       	ret

000034c8 <__eeprom_write_byte_1F2021>:
    34c8:	f9 99       	sbic	0x1f, 1	; 31
    34ca:	fe cf       	rjmp	.-4      	; 0x34c8 <__eeprom_write_byte_1F2021>
    34cc:	b2 bd       	out	0x22, r27	; 34
    34ce:	a1 bd       	out	0x21, r26	; 33
    34d0:	00 bc       	out	0x20, r0	; 32
    34d2:	11 96       	adiw	r26, 0x01	; 1
    34d4:	0f b6       	in	r0, 0x3f	; 63
    34d6:	f8 94       	cli
    34d8:	fa 9a       	sbi	0x1f, 2	; 31
    34da:	f9 9a       	sbi	0x1f, 1	; 31
    34dc:	0f be       	out	0x3f, r0	; 63
    34de:	08 95       	ret

000034e0 <__eeprom_write_word_1F2021>:
    34e0:	f3 df       	rcall	.-26     	; 0x34c8 <__eeprom_write_byte_1F2021>
    34e2:	01 2c       	mov	r0, r1
    34e4:	f1 df       	rcall	.-30     	; 0x34c8 <__eeprom_write_byte_1F2021>
    34e6:	11 24       	eor	r1, r1
    34e8:	08 95       	ret

000034ea <__eeprom_write_block_1F2021>:
    34ea:	01 90       	ld	r0, Z+
    34ec:	ed df       	rcall	.-38     	; 0x34c8 <__eeprom_write_byte_1F2021>
    34ee:	1a 94       	dec	r1
    34f0:	e1 f7       	brne	.-8      	; 0x34ea <__eeprom_write_block_1F2021>
    34f2:	08 95       	ret

000034f4 <__udivmodsi4>:
    34f4:	a1 e2       	ldi	r26, 0x21	; 33
    34f6:	1a 2e       	mov	r1, r26
    34f8:	aa 1b       	sub	r26, r26
    34fa:	bb 1b       	sub	r27, r27
    34fc:	fd 01       	movw	r30, r26
    34fe:	0d c0       	rjmp	.+26     	; 0x351a <__udivmodsi4_ep>

00003500 <__udivmodsi4_loop>:
    3500:	aa 1f       	adc	r26, r26
    3502:	bb 1f       	adc	r27, r27
    3504:	ee 1f       	adc	r30, r30
    3506:	ff 1f       	adc	r31, r31
    3508:	a2 17       	cp	r26, r18
    350a:	b3 07       	cpc	r27, r19
    350c:	e4 07       	cpc	r30, r20
    350e:	f5 07       	cpc	r31, r21
    3510:	20 f0       	brcs	.+8      	; 0x351a <__udivmodsi4_ep>
    3512:	a2 1b       	sub	r26, r18
    3514:	b3 0b       	sbc	r27, r19
    3516:	e4 0b       	sbc	r30, r20
    3518:	f5 0b       	sbc	r31, r21

0000351a <__udivmodsi4_ep>:
    351a:	66 1f       	adc	r22, r22
    351c:	77 1f       	adc	r23, r23
    351e:	88 1f       	adc	r24, r24
    3520:	99 1f       	adc	r25, r25
    3522:	1a 94       	dec	r1
    3524:	69 f7       	brne	.-38     	; 0x3500 <__udivmodsi4_loop>
    3526:	60 95       	com	r22
    3528:	70 95       	com	r23
    352a:	80 95       	com	r24
    352c:	90 95       	com	r25
    352e:	9b 01       	movw	r18, r22
    3530:	ac 01       	movw	r20, r24
    3532:	bd 01       	movw	r22, r26
    3534:	cf 01       	movw	r24, r30
    3536:	08 95       	ret
