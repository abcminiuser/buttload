
ButtLoad.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000026  00800100  000037ca  0000385e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000037ca  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b0  00800126  00800126  00003884  2**0
                  ALLOC
  3 .noinit       00000000  008002d6  008002d6  00003884  2**0
                  CONTENTS
  4 .eeprom       00000000  00810000  00810000  00003884  2**0
                  CONTENTS
  5 .stab         00000030  00000000  00000000  00003884  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      0000003f  00000000  00000000  000038b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000140  00000000  00000000  000038f3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000f75  00000000  00000000  00003a33  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000034e4  00000000  00000000  000049a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00000e54  00000000  00000000  00007e8c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000030c5  00000000  00000000  00008ce0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00001170  00000000  00000000  0000bda5  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 0a 02 	jmp	0x414 <__init>
       4:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
       8:	0c 94 66 1b 	jmp	0x36cc <__vector_2>
       c:	0c 94 90 03 	jmp	0x720 <__vector_3>
      10:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      14:	0c 94 86 07 	jmp	0xf0c <__vector_5>
      18:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      1c:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      20:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      24:	0c 94 1c 0c 	jmp	0x1838 <__vector_9>
      28:	0c 94 52 09 	jmp	0x12a4 <__vector_10>
      2c:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      30:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      34:	0c 94 0d 09 	jmp	0x121a <__vector_13>
      38:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      3c:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      40:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      44:	0c 94 63 09 	jmp	0x12c6 <__vector_17>
      48:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      4c:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      50:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      54:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      58:	0c 94 43 08 	jmp	0x1086 <__vector_22>

0000005c <SIFOOptionPtrs>:
      5c:	6f 00 60 00                                         o.`.

00000060 <SIFO_Tags>:
      60:	56 49 45 57 20 44 41 54 41 20 54 41 47 53 00        VIEW DATA TAGS.

0000006f <SIFO_Size>:
      6f:	53 54 4f 52 41 47 45 20 53 49 5a 45 53 00           STORAGE SIZES.

0000007d <USIPSNamePtrs>:
      7d:	a3 00 99 00 8f 00 85 00                             ........

00000085 <USI_Speed3>:
      85:	20 32 38 39 31 32 20 48 5a 00                        28912 HZ.

0000008f <USI_Speed2>:
      8f:	20 35 37 36 30 30 20 48 5a 00                        57600 HZ.

00000099 <USI_Speed1>:
      99:	20 38 36 37 33 38 20 48 5a 00                        86738 HZ.

000000a3 <USI_Speed0>:
      a3:	31 31 33 34 32 37 20 48 5a 00                       113427 HZ.

000000ad <ProgOptions>:
      ad:	16 01 0a 01 fa 00 ea 00 da 00 c6 00 bb 00           ..............

000000bb <PRG_C>:
      bb:	45 52 41 53 45 20 4f 4e 4c 59 00                    ERASE ONLY.

000000c6 <PRG_FL>:
      c6:	46 55 53 45 20 41 4e 44 20 4c 4f 43 4b 20 42 59     FUSE AND LOCK BY
      d6:	54 45 53 00                                         TES.

000000da <PRG_L>:
      da:	4c 4f 43 4b 20 42 59 54 45 53 20 4f 4e 4c 59 00     LOCK BYTES ONLY.

000000ea <PRG_F>:
      ea:	46 55 53 45 20 42 59 54 45 53 20 4f 4e 4c 59 00     FUSE BYTES ONLY.

000000fa <PRG_DE>:
      fa:	44 41 54 41 20 41 4e 44 20 45 45 50 52 4f 4d 00     DATA AND EEPROM.

0000010a <PRG_E>:
     10a:	45 45 50 52 4f 4d 20 4f 4e 4c 59 00                 EEPROM ONLY.

00000116 <PRG_D>:
     116:	44 41 54 41 20 4f 4e 4c 59 00                       DATA ONLY.

00000120 <SettingFunctionPtrs>:
     120:	33 06 7f 06 7d 05 d2 05 d9 05 27 07                 3...}.....'.

0000012c <SettingFunctionNames>:
     12c:	88 01 7a 01 6d 01 5e 01 4b 01 38 01                 ..z.m.^.K.8.

00000138 <SFunc_GOBOOTLOADER>:
     138:	4a 55 4d 50 20 54 4f 20 42 4f 4f 54 4c 4f 41 44     JUMP TO BOOTLOAD
     148:	45 52 00                                            ER.

0000014b <SFunc_MANCALIB>:
     14b:	4d 41 4e 55 41 4c 20 43 41 4c 49 42 52 41 54 49     MANUAL CALIBRATI
     15b:	4f 4e 00                                            ON.

0000015e <SFunc_AUTOCALIB>:
     15e:	41 55 54 4f 20 43 41 4c 49 42 52 41 54 45 00        AUTO CALIBRATE.

0000016d <SFunc_CLEARMEM>:
     16d:	43 4c 45 41 52 20 4d 45 4d 4f 52 59 00              CLEAR MEMORY.

0000017a <SFunc_SETSPISPEED>:
     17a:	53 45 54 20 53 50 49 20 53 50 45 45 44 00           SET SPI SPEED.

00000188 <SFunc_SETCONTRAST>:
     188:	53 45 54 20 43 4f 4e 54 52 41 53 54 00              SET CONTRAST.

00000195 <MainFunctionPtrs>:
     195:	e1 03 57 05 12 04 ee 03 ac 03 b4 06                 ..W.........

000001a1 <MainFunctionNames>:
     1a1:	ec 01 e1 01 d5 01 c1 01 b8 01 ad 01                 ............

000001ad <Func_SLEEP>:
     1ad:	53 4c 45 45 50 20 4d 4f 44 45 00                    SLEEP MODE.

000001b8 <Func_SETTINGS>:
     1b8:	53 45 54 54 49 4e 47 53 00                          SETTINGS.

000001c1 <Func_PRGMDATAFLASH>:
     1c1:	44 41 54 41 46 4c 41 53 48 20 50 52 47 4d 20 4d     DATAFLASH PRGM M
     1d1:	4f 44 45 00                                         ODE.

000001d5 <Func_PRGMAVR>:
     1d5:	50 52 4f 47 52 41 4d 20 41 56 52 00                 PROGRAM AVR.

000001e1 <Func_STOREPRGM>:
     1e1:	53 54 4f 52 45 20 50 52 47 4d 00                    STORE PRGM.

000001ec <Func_ISPPRGM>:
     1ec:	41 56 52 49 53 50 20 4d 4f 44 45 00                 AVRISP MODE.

000001f8 <AboutTextPtrs>:
     1f8:	23 02 1e 02 0f 02 00 02                             #.......

00000200 <CopyRight>:
     200:	3c 43 3e 20 32 30 30 36 20 2d 20 47 50 4c 00        <C> 2006 - GPL.

0000020f <AuthorName>:
     20f:	42 59 20 44 45 41 4e 20 43 41 4d 45 52 41 00        BY DEAN CAMERA.

0000021e <VersionInfo>:
     21e:	56 31 2d 33 00                                      V1-3.

00000223 <ProgrammerName>:
     223:	42 55 54 54 4c 4f 41 44 00                          BUTTLOAD.

0000022c <WaitText>:
     22c:	2a 57 41 49 54 2a 00                                *WAIT*.

00000233 <BUTTTAG_Author>:
     233:	40 28 23 29 42 59 20 44 45 41 4e 20 43 41 4d 45     @(#)BY DEAN CAME
     243:	52 41 00                                            RA.

00000246 <BUTTTAG_Name>:
     246:	40 28 23 29 42 55 54 54 4c 4f 41 44 20 41 56 52     @(#)BUTTLOAD AVR
     256:	49 53 50 00                                         ISP.

0000025a <__c.14>:
     25a:	50 52 47 3e 20 00                                   PRG> .

00000260 <__c.13>:
     260:	42 41 44 49 53 52 00                                BADISR.

00000267 <__c.6>:
     267:	4e 4f 20 45 52 41 53 45 20 43 4d 44 00              NO ERASE CMD.

00000274 <__c.7>:
     274:	4e 4f 20 44 41 54 41 00                             NO DATA.

0000027c <__c.8>:
     27c:	4e 4f 20 45 45 50 52 4f 4d 00                       NO EEPROM.

00000286 <__c.9>:
     286:	4e 4f 20 46 55 53 45 20 42 59 54 45 53 00           NO FUSE BYTES.

00000294 <__c.10>:
     294:	4e 4f 20 4c 4f 43 4b 20 42 59 54 45 53 00           NO LOCK BYTES.

000002a2 <__c.11>:
     2a2:	50 52 4f 47 52 41 4d 4d 49 4e 47 20 44 4f 4e 45     PROGRAMMING DONE
	...

000002b3 <__c.12>:
     2b3:	46 41 49 4c 45 44 00                                FAILED.

000002ba <__c.5>:
     2ba:	2a 53 54 4f 52 41 47 45 20 4d 4f 44 45 2a 00        *STORAGE MODE*.

000002c9 <__c.2>:
     2c9:	43 4f 4e 46 49 52 4d 00                             CONFIRM.

000002d1 <__c.3>:
     2d1:	3c 4e 20 59 3e 00                                   <N Y>.

000002d7 <__c.4>:
     2d7:	4d 45 4d 20 43 4c 45 41 52 45 44 00                 MEM CLEARED.

000002e3 <__c.1>:
     2e3:	4e 4f 20 53 54 4f 52 45 44 20 50 52 47 4d 00        NO STORED PRGM.

000002f2 <__c.0>:
     2f2:	2a 4a 54 41 47 20 4f 4e 2a 00                       *JTAG ON*.

000002fc <LCD_SegTable>:
     2fc:	a8 ea 80 2a 00 40 00 0a 51 0a 08 40 59 55 18 01     ...*.@..Q..@YU..
     30c:	11 1e 11 1b 50 0b 41 1b 41 1f 11 01 51 1f 51 1b     ....P.A.A...Q.Q.
     31c:	00 00 00 00 08 80 00 1a 20 40 00 00 00 00 51 0f     ........ @....Q.
     32c:	91 39 41 14 91 31 41 1e 41 0e 41 1d 50 0f 80 20     .9A..1A.A.A.P.. 
     33c:	10 15 48 86 40 14 78 05 70 85 51 15 51 0e 51 95     ..H.@.x.p.Q.Q.Q.
     34c:	51 8e 21 90 81 20 50 15 48 44 50 c5 28 c0 28 20     Q.!.. P.HDP.(.( 
     35c:	09 50 41 14 20 80 11 11 00 00 00 10                 .PA. .......

00000368 <USIPSValues>:
     368:	00 01 40 01 01 54 02 01 80 03 01 ff                 ..@..T......

00000374 <DataFlashError>:
     374:	44 41 54 41 46 4c 41 53 48 20 45 52 52 4f 52 00     DATAFLASH ERROR.

00000384 <DF_Pages>:
     384:	f9 00 f1 01 e1 03 10 3e 84 0f 84 0f 08 1f 08 1f     .......>........

00000394 <DF_PageSize>:
     394:	08 01 08 01 08 01 08 01 08 01 10 02 10 02 20 04     .............. .

000003a4 <DF_PageBits>:
     3a4:	09 09 09 09 09 0a 0a 0b                             ........

000003ac <__c.0>:
     3ac:	42 55 46 46 20 4f 56 45 52 46 4c 4f 57 00           BUFF OVERFLOW.

000003ba <DataFlashProgMode>:
     3ba:	2a 44 41 54 41 46 4c 41 53 48 20 4d 4f 44 45 2a     *DATAFLASH MODE*
	...

000003cb <SignonResponse>:
     3cb:	01 00 08 41 56 52 49 53 50 5f 32                    ...AVRISP_2

000003d6 <VersionData>:
     3d6:	02 02 04                                            ...

000003d9 <SyncErrorMessage>:
     3d9:	53 59 4e 43 20 45 52 52 4f 52 00                    SYNC ERROR.

000003e4 <AVRISPModeMessage>:
     3e4:	2a 41 54 41 56 52 49 53 50 20 4d 4f 44 45 2a 00     *ATAVRISP MODE*.

000003f4 <__c.0>:
     3f4:	44 41 54 41 2d 00                                   DATA-.

000003fa <__c.1>:
     3fa:	45 50 52 4d 2d 00                                   EPRM-.

00000400 <__c.2>:
     400:	46 55 53 45 2d 00                                   FUSE-.

00000406 <__c.3>:
     406:	4c 4f 43 4b 2d 00                                   LOCK-.

0000040c <__c.0>:
     40c:	4e 4f 20 54 41 47 53 00                             NO TAGS.

00000414 <__init>:
     414:	11 24       	eor	r1, r1
     416:	1f be       	out	0x3f, r1	; 63
     418:	cf ef       	ldi	r28, 0xFF	; 255
     41a:	d4 e0       	ldi	r29, 0x04	; 4
     41c:	de bf       	out	0x3e, r29	; 62
     41e:	cd bf       	out	0x3d, r28	; 61

00000420 <__do_copy_data>:
     420:	11 e0       	ldi	r17, 0x01	; 1
     422:	a0 e0       	ldi	r26, 0x00	; 0
     424:	b1 e0       	ldi	r27, 0x01	; 1
     426:	ea ec       	ldi	r30, 0xCA	; 202
     428:	f7 e3       	ldi	r31, 0x37	; 55
     42a:	02 c0       	rjmp	.+4      	; 0x430 <.do_copy_data_start>

0000042c <.do_copy_data_loop>:
     42c:	05 90       	lpm	r0, Z+
     42e:	0d 92       	st	X+, r0

00000430 <.do_copy_data_start>:
     430:	a6 32       	cpi	r26, 0x26	; 38
     432:	b1 07       	cpc	r27, r17
     434:	d9 f7       	brne	.-10     	; 0x42c <.do_copy_data_loop>

00000436 <__do_clear_bss>:
     436:	12 e0       	ldi	r17, 0x02	; 2
     438:	a6 e2       	ldi	r26, 0x26	; 38
     43a:	b1 e0       	ldi	r27, 0x01	; 1
     43c:	01 c0       	rjmp	.+2      	; 0x440 <.do_clear_bss_start>

0000043e <.do_clear_bss_loop>:
     43e:	1d 92       	st	X+, r1

00000440 <.do_clear_bss_start>:
     440:	a6 3d       	cpi	r26, 0xD6	; 214
     442:	b1 07       	cpc	r27, r17
     444:	e1 f7       	brne	.-8      	; 0x43e <.do_clear_bss_loop>
     446:	0c 94 6b 02 	jmp	0x4d6 <main>

0000044a <__bad_interrupt>:
     44a:	0c 94 a7 03 	jmp	0x74e <__vector_default>

0000044e <MAIN_Delay10MS>:

// ======================================================================================

void MAIN_Delay10MS(uint8_t loops)
{
     44e:	cf 93       	push	r28
     450:	df 93       	push	r29
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     452:	28 2f       	mov	r18, r24
     454:	21 50       	subi	r18, 0x01	; 1
     456:	2f 3f       	cpi	r18, 0xFF	; 255
     458:	49 f0       	breq	.+18     	; 0x46c <MAIN_Delay10MS+0x1e>
     45a:	a0 e0       	ldi	r26, 0x00	; 0
     45c:	b8 e4       	ldi	r27, 0x48	; 72
     45e:	c0 e0       	ldi	r28, 0x00	; 0
     460:	d0 e0       	ldi	r29, 0x00	; 0
     462:	cd 01       	movw	r24, r26
     464:	01 97       	sbiw	r24, 0x01	; 1
     466:	f1 f7       	brne	.-4      	; 0x464 <MAIN_Delay10MS+0x16>
     468:	21 50       	subi	r18, 0x01	; 1
     46a:	d8 f7       	brcc	.-10     	; 0x462 <MAIN_Delay10MS+0x14>
     46c:	df 91       	pop	r29
     46e:	cf 91       	pop	r28
     470:	08 95       	ret

00000472 <MAIN_WaitForJoyRelease>:
  /* Prevents the use of floating point libraries. Delaying in groups of
     10ms increases accuracy by reducing the time overhead for each loop
     interation of the while.                                            */

	while (loops--)
	  _delay_ms(10);
}

void MAIN_Delay1MS(uint8_t loops)
{
  /* Prevents the use of floating point libraries. Less accurate than the
     Delay10MS routine, but nessesary for many commands. The overhead required
     to call the routine is substantially less than the overhead required to
     calculate the float at compile time, so this actually saves execution time. */

	while (loops--)
	  _delay_ms(1);
}

void MAIN_ResetCSLine(uint8_t ActiveInactive)
{
  /* ActiveInactive controls the /Reset line to an AVR device or external dataflash
     /CS line. If the reset polarity parameter is a 0 then interfacing with AT89
	 devices which has an active high reset. Pins are tristated when inactive.      */
	
	switch (ActiveInactive)
	{
		case MAIN_RESETCS_ACTIVE:   // The target RESET line may be either active high or low.
			DDRF |= (1 << 6);
		
			if (!(eeprom_read_byte_169(&Param_ResetPolarity))) // Translate to correct logic level for target device type
			  PORTF |=  (1 << 6);
			else
			  PORTF &= ~(1 << 6);
		
			break;
		case MAIN_RESETCS_DFACTIVE: // Dataflashes are always active low.
			DDRF  |=  (1 << 6);
			PORTF &= ~(1 << 6);
			
			break;
		case MAIN_RESETCS_INACTIVE: // Both modes tristate the pins when inactive.
			DDRF  &= ~(1 << 6);
			PORTF &= ~(1 << 6);
	}
}

void MAIN_WaitForJoyRelease(void)
{
	while (1)
	{
		while (JoyStatus) {};                   // Wait until joystick released
     472:	8e b3       	in	r24, 0x1e	; 30
     474:	88 23       	and	r24, r24
     476:	e9 f7       	brne	.-6      	; 0x472 <MAIN_WaitForJoyRelease>

		MAIN_Delay10MS(1);
     478:	81 e0       	ldi	r24, 0x01	; 1
     47a:	0e 94 27 02 	call	0x44e <MAIN_Delay10MS>

		if (!(JoyStatus))                       // Joystick still released (not bouncing), return
     47e:	8e b3       	in	r24, 0x1e	; 30
     480:	88 23       	and	r24, r24
     482:	b9 f7       	brne	.-18     	; 0x472 <MAIN_WaitForJoyRelease>
     484:	08 95       	ret

00000486 <FUNCShowAbout>:
		  return;
	}
}

void MAIN_IntToStr(uint16_t IntV, uint8_t* Buff)
{
	// Shows leading zeros, unlike itoa.

	uint8_t Temp = 0;
	
	while (IntV >= 100)
	{
		Temp++;
		IntV -= 100;
	}

	*(Buff++) = '0' + Temp;
	
	Temp = 0;
	
	while (IntV >= 10)
	{
		Temp++;
		IntV -= 10;
	}
		
	*(Buff++) = '0' + Temp;
	*(Buff++) = '0' + IntV;
	*(Buff)   = '\0';
}

void MAIN_ShowProgType(uint8_t Letter)
{
	uint8_t ProgTypeBuffer[7];

	strcpy_P(ProgTypeBuffer, PSTR("PRG> "));
	ProgTypeBuffer[5] = Letter;
	ProgTypeBuffer[6] = '\0';
	
	LCD_puts(ProgTypeBuffer);
}

void MAIN_ShowError(const uint8_t *pFlashStr)
{
	uint8_t ErrorBuff[LCD_TEXTBUFFER_SIZE];       // New buffer, LCD text buffer size
	
	ErrorBuff[0] = 'E';
	ErrorBuff[1] = '>';

	strcpy_P(&ErrorBuff[2], pFlashStr);       // WARNING: If error text is larger than (TEXTBUFFER_SIZE - 2),
	                                          // this will overflow the buffer and probably crash the micro!
	LCD_puts(ErrorBuff);
	
	MAIN_WaitForJoyRelease();
	while (!(JoyStatus & JOY_PRESS)) {};
	MAIN_WaitForJoyRelease();
}

// ======================================================================================

ISR(PCINT1_vect, ISR_NOBLOCK)                 // Joystick routine; PCINT0_vect is bound to this also via JoystickInterrupt.S
{
	JoyStatus = (~PINB & JOY_BMASK)
	          | (~PINE & JOY_EMASK);
}

ISR(BADISR_vect, ISR_NAKED)                   // Bad ISR routine; should never be called, here for safety
{
	MAIN_ShowError(PSTR("BADISR"));
	while (1) {};
}

// ======================================================================================

void FUNCChangeSettings(void)
{
	uint8_t CurrSFunc = 0;
	
	JoyStatus = 1;

	while (1)
	{
		if (JoyStatus)                         // Joystick is in the non-center position
		{
			if (JoyStatus & JOY_UP)            // Previous function
			  (CurrSFunc == 0)? CurrSFunc = 5 : CurrSFunc--;
			else if (JoyStatus & JOY_DOWN)     // Next function
			  (CurrSFunc == 5)? CurrSFunc = 0 : CurrSFunc++;
			else if (JoyStatus & JOY_PRESS)    // Select current function
			  ((FuncPtr)pgm_read_word(&SettingFunctionPtrs[CurrSFunc]))(); // Run associated function
			else if (JoyStatus & JOY_LEFT)
			  return;
		
			// Show current function onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&SettingFunctionNames[CurrSFunc]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCShowAbout(void)
{
     486:	cf 93       	push	r28
	uint8_t InfoNum = 0;
     488:	c0 e0       	ldi	r28, 0x00	; 0
	
	JoyStatus = 1;
     48a:	81 e0       	ldi	r24, 0x01	; 1
     48c:	8e bb       	out	0x1e, r24	; 30
			
	while (1)
	{
		if (JoyStatus)
     48e:	8e b3       	in	r24, 0x1e	; 30
     490:	88 23       	and	r24, r24
     492:	e9 f3       	breq	.-6      	; 0x48e <FUNCShowAbout+0x8>
		{
			if (JoyStatus & JOY_UP)
     494:	f6 9b       	sbis	0x1e, 6	; 30
     496:	06 c0       	rjmp	.+12     	; 0x4a4 <FUNCShowAbout+0x1e>
			  (InfoNum == 0)? InfoNum = 3 : InfoNum--;
     498:	cc 23       	and	r28, r28
     49a:	11 f4       	brne	.+4      	; 0x4a0 <FUNCShowAbout+0x1a>
     49c:	c3 e0       	ldi	r28, 0x03	; 3
     49e:	0c c0       	rjmp	.+24     	; 0x4b8 <FUNCShowAbout+0x32>
     4a0:	c1 50       	subi	r28, 0x01	; 1
     4a2:	0a c0       	rjmp	.+20     	; 0x4b8 <FUNCShowAbout+0x32>
			else if (JoyStatus & JOY_DOWN)
     4a4:	f7 9b       	sbis	0x1e, 7	; 30
     4a6:	06 c0       	rjmp	.+12     	; 0x4b4 <FUNCShowAbout+0x2e>
			  (InfoNum == 3)? InfoNum = 0 : InfoNum++;
     4a8:	c3 30       	cpi	r28, 0x03	; 3
     4aa:	11 f4       	brne	.+4      	; 0x4b0 <FUNCShowAbout+0x2a>
     4ac:	c0 e0       	ldi	r28, 0x00	; 0
     4ae:	04 c0       	rjmp	.+8      	; 0x4b8 <FUNCShowAbout+0x32>
     4b0:	cf 5f       	subi	r28, 0xFF	; 255
     4b2:	02 c0       	rjmp	.+4      	; 0x4b8 <FUNCShowAbout+0x32>
			else if (JoyStatus & JOY_LEFT)
     4b4:	f2 99       	sbic	0x1e, 2	; 30
     4b6:	0d c0       	rjmp	.+26     	; 0x4d2 <FUNCShowAbout+0x4c>
			  return;

			LCD_puts_f((uint8_t*)pgm_read_word(&AboutTextPtrs[InfoNum]));
     4b8:	ec 2f       	mov	r30, r28
     4ba:	ff 27       	eor	r31, r31
     4bc:	ee 0f       	add	r30, r30
     4be:	ff 1f       	adc	r31, r31
     4c0:	e8 50       	subi	r30, 0x08	; 8
     4c2:	fe 4f       	sbci	r31, 0xFE	; 254
     4c4:	85 91       	lpm	r24, Z+
     4c6:	94 91       	lpm	r25, Z
     4c8:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     4cc:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     4d0:	de cf       	rjmp	.-68     	; 0x48e <FUNCShowAbout+0x8>
     4d2:	cf 91       	pop	r28
     4d4:	08 95       	ret

000004d6 <main>:
     4d6:	cd ef       	ldi	r28, 0xFD	; 253
     4d8:	d4 e0       	ldi	r29, 0x04	; 4
     4da:	de bf       	out	0x3e, r29	; 62
     4dc:	cd bf       	out	0x3d, r28	; 61
     4de:	10 e0       	ldi	r17, 0x00	; 0
     4e0:	80 e8       	ldi	r24, 0x80	; 128
     4e2:	85 bf       	out	0x35, r24	; 53
     4e4:	85 bf       	out	0x35, r24	; 53
     4e6:	80 bf       	out	0x30, r24	; 48
     4e8:	85 e0       	ldi	r24, 0x05	; 5
     4ea:	80 93 64 00 	sts	0x0064, r24
     4ee:	80 e3       	ldi	r24, 0x30	; 48
     4f0:	80 bb       	out	0x10, r24	; 16
     4f2:	87 e2       	ldi	r24, 0x27	; 39
     4f4:	84 b9       	out	0x04, r24	; 4
     4f6:	8f ed       	ldi	r24, 0xDF	; 223
     4f8:	85 b9       	out	0x05, r24	; 5
     4fa:	8c e0       	ldi	r24, 0x0C	; 12
     4fc:	8e b9       	out	0x0e, r24	; 14
     4fe:	80 93 6b 00 	sts	0x006B, r24
     502:	80 ed       	ldi	r24, 0xD0	; 208
     504:	80 93 6c 00 	sts	0x006C, r24
     508:	80 ec       	ldi	r24, 0xC0	; 192
     50a:	8d bb       	out	0x1d, r24	; 29
     50c:	8c bb       	out	0x1c, r24	; 28
     50e:	81 b3       	in	r24, 0x11	; 17
     510:	8f 7c       	andi	r24, 0xCF	; 207
     512:	80 62       	ori	r24, 0x20	; 32
     514:	81 bb       	out	0x11, r24	; 17
     516:	82 e0       	ldi	r24, 0x02	; 2
     518:	91 e0       	ldi	r25, 0x01	; 1
     51a:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
     51e:	8a 35       	cpi	r24, 0x5A	; 90
     520:	09 f1       	breq	.+66     	; 0x564 <__stack+0x65>
     522:	20 e0       	ldi	r18, 0x00	; 0
     524:	30 e0       	ldi	r19, 0x00	; 0
     526:	3a 83       	std	Y+2, r19	; 0x02
     528:	29 83       	std	Y+1, r18	; 0x01
     52a:	80 91 02 01 	lds	r24, 0x0102
     52e:	90 91 03 01 	lds	r25, 0x0103
     532:	28 17       	cp	r18, r24
     534:	39 07       	cpc	r19, r25
     536:	88 f4       	brcc	.+34     	; 0x55a <__stack+0x5b>
     538:	6f ef       	ldi	r22, 0xFF	; 255
     53a:	ce 01       	movw	r24, r28
     53c:	01 96       	adiw	r24, 0x01	; 1
     53e:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
     542:	89 81       	ldd	r24, Y+1	; 0x01
     544:	9a 81       	ldd	r25, Y+2	; 0x02
     546:	01 96       	adiw	r24, 0x01	; 1
     548:	9a 83       	std	Y+2, r25	; 0x02
     54a:	89 83       	std	Y+1, r24	; 0x01
     54c:	20 91 02 01 	lds	r18, 0x0102
     550:	30 91 03 01 	lds	r19, 0x0103
     554:	82 17       	cp	r24, r18
     556:	93 07       	cpc	r25, r19
     558:	78 f3       	brcs	.-34     	; 0x538 <__stack+0x39>
     55a:	6a e5       	ldi	r22, 0x5A	; 90
     55c:	82 e0       	ldi	r24, 0x02	; 2
     55e:	91 e0       	ldi	r25, 0x01	; 1
     560:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
     564:	0e 94 a7 07 	call	0xf4e <LCD_Init>
     568:	84 e0       	ldi	r24, 0x04	; 4
     56a:	91 e0       	ldi	r25, 0x01	; 1
     56c:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
     570:	8f 70       	andi	r24, 0x0F	; 15
     572:	80 93 e7 00 	sts	0x00E7, r24
     576:	78 94       	sei
     578:	8c e2       	ldi	r24, 0x2C	; 44
     57a:	92 e0       	ldi	r25, 0x02	; 2
     57c:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>
     580:	80 e0       	ldi	r24, 0x00	; 0
     582:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
     586:	81 b3       	in	r24, 0x11	; 17
     588:	80 63       	ori	r24, 0x30	; 48
     58a:	81 bb       	out	0x11, r24	; 17
     58c:	0e 94 35 07 	call	0xe6a <OSCCAL_Calibrate>
     590:	87 e0       	ldi	r24, 0x07	; 7
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	0e 94 d7 08 	call	0x11ae <USART_Init>
     598:	81 b3       	in	r24, 0x11	; 17
     59a:	8f 7c       	andi	r24, 0xCF	; 207
     59c:	80 61       	ori	r24, 0x10	; 16
     59e:	81 bb       	out	0x11, r24	; 17
     5a0:	81 e0       	ldi	r24, 0x01	; 1
     5a2:	8e bb       	out	0x1e, r24	; 30
     5a4:	8e b3       	in	r24, 0x1e	; 30
     5a6:	88 23       	and	r24, r24
     5a8:	e9 f3       	breq	.-6      	; 0x5a4 <__stack+0xa5>
     5aa:	f6 9b       	sbis	0x1e, 6	; 30
     5ac:	06 c0       	rjmp	.+12     	; 0x5ba <__stack+0xbb>
     5ae:	11 23       	and	r17, r17
     5b0:	11 f4       	brne	.+4      	; 0x5b6 <__stack+0xb7>
     5b2:	15 e0       	ldi	r17, 0x05	; 5
     5b4:	1b c0       	rjmp	.+54     	; 0x5ec <__stack+0xed>
     5b6:	11 50       	subi	r17, 0x01	; 1
     5b8:	19 c0       	rjmp	.+50     	; 0x5ec <__stack+0xed>
     5ba:	f7 9b       	sbis	0x1e, 7	; 30
     5bc:	06 c0       	rjmp	.+12     	; 0x5ca <__stack+0xcb>
     5be:	15 30       	cpi	r17, 0x05	; 5
     5c0:	11 f4       	brne	.+4      	; 0x5c6 <__stack+0xc7>
     5c2:	10 e0       	ldi	r17, 0x00	; 0
     5c4:	13 c0       	rjmp	.+38     	; 0x5ec <__stack+0xed>
     5c6:	1f 5f       	subi	r17, 0xFF	; 255
     5c8:	11 c0       	rjmp	.+34     	; 0x5ec <__stack+0xed>
     5ca:	f4 9b       	sbis	0x1e, 4	; 30
     5cc:	0b c0       	rjmp	.+22     	; 0x5e4 <__stack+0xe5>
     5ce:	e1 2f       	mov	r30, r17
     5d0:	ff 27       	eor	r31, r31
     5d2:	ee 0f       	add	r30, r30
     5d4:	ff 1f       	adc	r31, r31
     5d6:	eb 56       	subi	r30, 0x6B	; 107
     5d8:	fe 4f       	sbci	r31, 0xFE	; 254
     5da:	85 91       	lpm	r24, Z+
     5dc:	94 91       	lpm	r25, Z
     5de:	fc 01       	movw	r30, r24
     5e0:	09 95       	icall
     5e2:	04 c0       	rjmp	.+8      	; 0x5ec <__stack+0xed>
     5e4:	f3 9b       	sbis	0x1e, 3	; 30
     5e6:	02 c0       	rjmp	.+4      	; 0x5ec <__stack+0xed>
     5e8:	0e 94 43 02 	call	0x486 <FUNCShowAbout>
     5ec:	e1 2f       	mov	r30, r17
     5ee:	ff 27       	eor	r31, r31
     5f0:	ee 0f       	add	r30, r30
     5f2:	ff 1f       	adc	r31, r31
     5f4:	ef 55       	subi	r30, 0x5F	; 95
     5f6:	fe 4f       	sbci	r31, 0xFE	; 254
     5f8:	85 91       	lpm	r24, Z+
     5fa:	94 91       	lpm	r25, Z
     5fc:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>
     600:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     604:	cf cf       	rjmp	.-98     	; 0x5a4 <__stack+0xa5>

00000606 <MAIN_Delay1MS>:
     606:	cf 93       	push	r28
     608:	df 93       	push	r29
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     60a:	28 2f       	mov	r18, r24
     60c:	21 50       	subi	r18, 0x01	; 1
     60e:	2f 3f       	cpi	r18, 0xFF	; 255
     610:	49 f0       	breq	.+18     	; 0x624 <MAIN_Delay1MS+0x1e>
     612:	a3 e3       	ldi	r26, 0x33	; 51
     614:	b7 e0       	ldi	r27, 0x07	; 7
     616:	c0 e0       	ldi	r28, 0x00	; 0
     618:	d0 e0       	ldi	r29, 0x00	; 0
     61a:	cd 01       	movw	r24, r26
     61c:	01 97       	sbiw	r24, 0x01	; 1
     61e:	f1 f7       	brne	.-4      	; 0x61c <MAIN_Delay1MS+0x16>
     620:	21 50       	subi	r18, 0x01	; 1
     622:	d8 f7       	brcc	.-10     	; 0x61a <MAIN_Delay1MS+0x14>
     624:	df 91       	pop	r29
     626:	cf 91       	pop	r28
     628:	08 95       	ret

0000062a <MAIN_ResetCSLine>:
     62a:	99 27       	eor	r25, r25
     62c:	81 30       	cpi	r24, 0x01	; 1
     62e:	91 05       	cpc	r25, r1
     630:	a9 f0       	breq	.+42     	; 0x65c <MAIN_ResetCSLine+0x32>
     632:	82 30       	cpi	r24, 0x02	; 2
     634:	91 05       	cpc	r25, r1
     636:	1c f4       	brge	.+6      	; 0x63e <MAIN_ResetCSLine+0x14>
     638:	89 2b       	or	r24, r25
     63a:	21 f0       	breq	.+8      	; 0x644 <MAIN_ResetCSLine+0x1a>
     63c:	08 95       	ret
     63e:	02 97       	sbiw	r24, 0x02	; 2
     640:	51 f0       	breq	.+20     	; 0x656 <MAIN_ResetCSLine+0x2c>
     642:	08 95       	ret
     644:	86 9a       	sbi	0x10, 6	; 16
     646:	82 e2       	ldi	r24, 0x22	; 34
     648:	91 e0       	ldi	r25, 0x01	; 1
     64a:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
     64e:	88 23       	and	r24, r24
     650:	19 f4       	brne	.+6      	; 0x658 <MAIN_ResetCSLine+0x2e>
     652:	8e 9a       	sbi	0x11, 6	; 17
     654:	08 95       	ret
     656:	86 9a       	sbi	0x10, 6	; 16
     658:	8e 98       	cbi	0x11, 6	; 17
     65a:	08 95       	ret
     65c:	86 98       	cbi	0x10, 6	; 16
     65e:	fc cf       	rjmp	.-8      	; 0x658 <MAIN_ResetCSLine+0x2e>

00000660 <MAIN_IntToStr>:
     660:	fb 01       	movw	r30, r22
     662:	20 e0       	ldi	r18, 0x00	; 0
     664:	84 36       	cpi	r24, 0x64	; 100
     666:	91 05       	cpc	r25, r1
     668:	20 f0       	brcs	.+8      	; 0x672 <MAIN_IntToStr+0x12>
     66a:	2f 5f       	subi	r18, 0xFF	; 255
     66c:	84 56       	subi	r24, 0x64	; 100
     66e:	90 40       	sbci	r25, 0x00	; 0
     670:	f9 cf       	rjmp	.-14     	; 0x664 <MAIN_IntToStr+0x4>
     672:	20 5d       	subi	r18, 0xD0	; 208
     674:	21 93       	st	Z+, r18
     676:	20 e0       	ldi	r18, 0x00	; 0
     678:	8a 30       	cpi	r24, 0x0A	; 10
     67a:	91 05       	cpc	r25, r1
     67c:	18 f0       	brcs	.+6      	; 0x684 <MAIN_IntToStr+0x24>
     67e:	2f 5f       	subi	r18, 0xFF	; 255
     680:	0a 97       	sbiw	r24, 0x0a	; 10
     682:	fa cf       	rjmp	.-12     	; 0x678 <MAIN_IntToStr+0x18>
     684:	20 5d       	subi	r18, 0xD0	; 208
     686:	21 93       	st	Z+, r18
     688:	80 5d       	subi	r24, 0xD0	; 208
     68a:	81 93       	st	Z+, r24
     68c:	10 82       	st	Z, r1
     68e:	08 95       	ret

00000690 <MAIN_ShowProgType>:
     690:	1f 93       	push	r17
     692:	cf 93       	push	r28
     694:	df 93       	push	r29
     696:	cd b7       	in	r28, 0x3d	; 61
     698:	de b7       	in	r29, 0x3e	; 62
     69a:	27 97       	sbiw	r28, 0x07	; 7
     69c:	0f b6       	in	r0, 0x3f	; 63
     69e:	f8 94       	cli
     6a0:	de bf       	out	0x3e, r29	; 62
     6a2:	0f be       	out	0x3f, r0	; 63
     6a4:	cd bf       	out	0x3d, r28	; 61
     6a6:	18 2f       	mov	r17, r24
     6a8:	6a e5       	ldi	r22, 0x5A	; 90
     6aa:	72 e0       	ldi	r23, 0x02	; 2
     6ac:	ce 01       	movw	r24, r28
     6ae:	01 96       	adiw	r24, 0x01	; 1
     6b0:	0e 94 68 1b 	call	0x36d0 <strcpy_P>
     6b4:	1e 83       	std	Y+6, r17	; 0x06
     6b6:	1f 82       	std	Y+7, r1	; 0x07
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	0e 94 b9 07 	call	0xf72 <LCD_puts>
     6c0:	27 96       	adiw	r28, 0x07	; 7
     6c2:	0f b6       	in	r0, 0x3f	; 63
     6c4:	f8 94       	cli
     6c6:	de bf       	out	0x3e, r29	; 62
     6c8:	0f be       	out	0x3f, r0	; 63
     6ca:	cd bf       	out	0x3d, r28	; 61
     6cc:	df 91       	pop	r29
     6ce:	cf 91       	pop	r28
     6d0:	1f 91       	pop	r17
     6d2:	08 95       	ret

000006d4 <MAIN_ShowError>:
     6d4:	cf 93       	push	r28
     6d6:	df 93       	push	r29
     6d8:	cd b7       	in	r28, 0x3d	; 61
     6da:	de b7       	in	r29, 0x3e	; 62
     6dc:	64 97       	sbiw	r28, 0x14	; 20
     6de:	0f b6       	in	r0, 0x3f	; 63
     6e0:	f8 94       	cli
     6e2:	de bf       	out	0x3e, r29	; 62
     6e4:	0f be       	out	0x3f, r0	; 63
     6e6:	cd bf       	out	0x3d, r28	; 61
     6e8:	25 e4       	ldi	r18, 0x45	; 69
     6ea:	29 83       	std	Y+1, r18	; 0x01
     6ec:	2e e3       	ldi	r18, 0x3E	; 62
     6ee:	2a 83       	std	Y+2, r18	; 0x02
     6f0:	bc 01       	movw	r22, r24
     6f2:	ce 01       	movw	r24, r28
     6f4:	03 96       	adiw	r24, 0x03	; 3
     6f6:	0e 94 68 1b 	call	0x36d0 <strcpy_P>
     6fa:	ce 01       	movw	r24, r28
     6fc:	01 96       	adiw	r24, 0x01	; 1
     6fe:	0e 94 b9 07 	call	0xf72 <LCD_puts>
     702:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     706:	f4 9b       	sbis	0x1e, 4	; 30
     708:	fe cf       	rjmp	.-4      	; 0x706 <MAIN_ShowError+0x32>
     70a:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     70e:	64 96       	adiw	r28, 0x14	; 20
     710:	0f b6       	in	r0, 0x3f	; 63
     712:	f8 94       	cli
     714:	de bf       	out	0x3e, r29	; 62
     716:	0f be       	out	0x3f, r0	; 63
     718:	cd bf       	out	0x3d, r28	; 61
     71a:	df 91       	pop	r29
     71c:	cf 91       	pop	r28
     71e:	08 95       	ret

00000720 <__vector_3>:
     720:	78 94       	sei
     722:	1f 92       	push	r1
     724:	0f 92       	push	r0
     726:	0f b6       	in	r0, 0x3f	; 63
     728:	0f 92       	push	r0
     72a:	11 24       	eor	r1, r1
     72c:	8f 93       	push	r24
     72e:	9f 93       	push	r25
     730:	93 b1       	in	r25, 0x03	; 3
     732:	90 95       	com	r25
     734:	90 7d       	andi	r25, 0xD0	; 208
     736:	8c b1       	in	r24, 0x0c	; 12
     738:	80 95       	com	r24
     73a:	8c 70       	andi	r24, 0x0C	; 12
     73c:	98 2b       	or	r25, r24
     73e:	9e bb       	out	0x1e, r25	; 30
     740:	9f 91       	pop	r25
     742:	8f 91       	pop	r24
     744:	0f 90       	pop	r0
     746:	0f be       	out	0x3f, r0	; 63
     748:	0f 90       	pop	r0
     74a:	1f 90       	pop	r1
     74c:	18 95       	reti

0000074e <__vector_default>:
     74e:	80 e6       	ldi	r24, 0x60	; 96
     750:	92 e0       	ldi	r25, 0x02	; 2
     752:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
     756:	ff cf       	rjmp	.-2      	; 0x756 <__vector_default+0x8>

00000758 <FUNCChangeSettings>:
     758:	cf 93       	push	r28
     75a:	c0 e0       	ldi	r28, 0x00	; 0
     75c:	81 e0       	ldi	r24, 0x01	; 1
     75e:	8e bb       	out	0x1e, r24	; 30
     760:	8e b3       	in	r24, 0x1e	; 30
     762:	88 23       	and	r24, r24
     764:	e9 f3       	breq	.-6      	; 0x760 <FUNCChangeSettings+0x8>
     766:	f6 9b       	sbis	0x1e, 6	; 30
     768:	06 c0       	rjmp	.+12     	; 0x776 <FUNCChangeSettings+0x1e>
     76a:	cc 23       	and	r28, r28
     76c:	11 f4       	brne	.+4      	; 0x772 <FUNCChangeSettings+0x1a>
     76e:	c5 e0       	ldi	r28, 0x05	; 5
     770:	19 c0       	rjmp	.+50     	; 0x7a4 <FUNCChangeSettings+0x4c>
     772:	c1 50       	subi	r28, 0x01	; 1
     774:	17 c0       	rjmp	.+46     	; 0x7a4 <FUNCChangeSettings+0x4c>
     776:	f7 9b       	sbis	0x1e, 7	; 30
     778:	06 c0       	rjmp	.+12     	; 0x786 <FUNCChangeSettings+0x2e>
     77a:	c5 30       	cpi	r28, 0x05	; 5
     77c:	11 f4       	brne	.+4      	; 0x782 <FUNCChangeSettings+0x2a>
     77e:	c0 e0       	ldi	r28, 0x00	; 0
     780:	11 c0       	rjmp	.+34     	; 0x7a4 <FUNCChangeSettings+0x4c>
     782:	cf 5f       	subi	r28, 0xFF	; 255
     784:	0f c0       	rjmp	.+30     	; 0x7a4 <FUNCChangeSettings+0x4c>
     786:	f4 9b       	sbis	0x1e, 4	; 30
     788:	0b c0       	rjmp	.+22     	; 0x7a0 <FUNCChangeSettings+0x48>
     78a:	ec 2f       	mov	r30, r28
     78c:	ff 27       	eor	r31, r31
     78e:	ee 0f       	add	r30, r30
     790:	ff 1f       	adc	r31, r31
     792:	e0 5e       	subi	r30, 0xE0	; 224
     794:	fe 4f       	sbci	r31, 0xFE	; 254
     796:	85 91       	lpm	r24, Z+
     798:	94 91       	lpm	r25, Z
     79a:	fc 01       	movw	r30, r24
     79c:	09 95       	icall
     79e:	02 c0       	rjmp	.+4      	; 0x7a4 <FUNCChangeSettings+0x4c>
     7a0:	f2 99       	sbic	0x1e, 2	; 30
     7a2:	0d c0       	rjmp	.+26     	; 0x7be <FUNCChangeSettings+0x66>
     7a4:	ec 2f       	mov	r30, r28
     7a6:	ff 27       	eor	r31, r31
     7a8:	ee 0f       	add	r30, r30
     7aa:	ff 1f       	adc	r31, r31
     7ac:	e4 5d       	subi	r30, 0xD4	; 212
     7ae:	fe 4f       	sbci	r31, 0xFE	; 254
     7b0:	85 91       	lpm	r24, Z+
     7b2:	94 91       	lpm	r25, Z
     7b4:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>
     7b8:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     7bc:	d1 cf       	rjmp	.-94     	; 0x760 <FUNCChangeSettings+0x8>
     7be:	cf 91       	pop	r28
     7c0:	08 95       	ret

000007c2 <FUNCAVRISPMode>:
		}
	}
}

void FUNCAVRISPMode(void)
{
	LCD_puts_f(AVRISPModeMessage);
     7c2:	84 ee       	ldi	r24, 0xE4	; 228
     7c4:	93 e0       	ldi	r25, 0x03	; 3
     7c6:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>
	
	InterpretPacketRoutine = (FuncPtr)AICI_InterpretPacket;
     7ca:	86 e4       	ldi	r24, 0x46	; 70
     7cc:	92 e1       	ldi	r25, 0x12	; 18
     7ce:	90 93 25 01 	sts	0x0125, r25
     7d2:	80 93 24 01 	sts	0x0124, r24
	V2P_RunStateMachine();
     7d6:	0e 94 50 0f 	call	0x1ea0 <V2P_RunStateMachine>
     7da:	08 95       	ret

000007dc <FUNCProgramDataflash>:
}

void FUNCProgramDataflash(void)
{
	USI_SPIInitMaster(eeprom_read_byte_169(&Param_SCKDuration));
     7dc:	80 e2       	ldi	r24, 0x20	; 32
     7de:	91 e0       	ldi	r25, 0x01	; 1
     7e0:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
     7e4:	0e 94 a1 09 	call	0x1342 <USI_SPIInitMaster>
	UseExernalDF = TRUE;
     7e8:	81 e0       	ldi	r24, 0x01	; 1
     7ea:	80 93 83 02 	sts	0x0283, r24
	DFSPIRoutinePointer = USI_SPITransmit;
     7ee:	83 ec       	ldi	r24, 0xC3	; 195
     7f0:	99 e0       	ldi	r25, 0x09	; 9
     7f2:	90 93 01 01 	sts	0x0101, r25
     7f6:	80 93 00 01 	sts	0x0100, r24
	
	LCD_puts_f(DataFlashProgMode);
     7fa:	8a eb       	ldi	r24, 0xBA	; 186
     7fc:	93 e0       	ldi	r25, 0x03	; 3
     7fe:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>

	InterpretPacketRoutine = PD_InterpretAVRISPPacket;
     802:	84 ea       	ldi	r24, 0xA4	; 164
     804:	9c e0       	ldi	r25, 0x0C	; 12
     806:	90 93 25 01 	sts	0x0125, r25
     80a:	80 93 24 01 	sts	0x0124, r24
	V2P_RunStateMachine();
     80e:	0e 94 50 0f 	call	0x1ea0 <V2P_RunStateMachine>
	   
	DF_EnableDataflash(FALSE);
     812:	80 e0       	ldi	r24, 0x00	; 0
     814:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
	SPI_SPIOFF();
     818:	80 91 64 00 	lds	r24, 0x0064
     81c:	84 60       	ori	r24, 0x04	; 4
     81e:	80 93 64 00 	sts	0x0064, r24
     822:	08 95       	ret

00000824 <FUNCProgramAVR>:
}

void FUNCProgramAVR(void)
{
     824:	df 92       	push	r13
     826:	ef 92       	push	r14
     828:	ff 92       	push	r15
     82a:	0f 93       	push	r16
     82c:	1f 93       	push	r17
     82e:	cf 93       	push	r28
     830:	df 93       	push	r29
     832:	cd b7       	in	r28, 0x3d	; 61
     834:	de b7       	in	r29, 0x3e	; 62
     836:	65 97       	sbiw	r28, 0x15	; 21
     838:	0f b6       	in	r0, 0x3f	; 63
     83a:	f8 94       	cli
     83c:	de bf       	out	0x3e, r29	; 62
     83e:	0f be       	out	0x3f, r0	; 63
     840:	cd bf       	out	0x3d, r28	; 61
	uint8_t  DoneFailMessageBuff[19];
	uint16_t EEPROMAddress;
	uint8_t  Fault = ISPCC_NO_FAULT;
     842:	dd 24       	eor	r13, r13
	uint8_t  ProgMode = 0;
     844:	0d 2d       	mov	r16, r13

	SPI_SPIInit();
     846:	0e 94 33 09 	call	0x1266 <SPI_SPIInit>
	UseExernalDF = FALSE;
     84a:	d0 92 83 02 	sts	0x0283, r13
	DFSPIRoutinePointer = SPI_SPITransmit;
     84e:	8d e3       	ldi	r24, 0x3D	; 61
     850:	99 e0       	ldi	r25, 0x09	; 9
     852:	90 93 01 01 	sts	0x0101, r25
     856:	80 93 00 01 	sts	0x0100, r24
	
	if (!(DF_CheckCorrectOnboardChip()))
     85a:	0e 94 af 0b 	call	0x175e <DF_CheckCorrectOnboardChip>
     85e:	88 23       	and	r24, r24
     860:	09 f4       	brne	.+2      	; 0x864 <FUNCProgramAVR+0x40>
     862:	17 c1       	rjmp	.+558    	; 0xa92 <FUNCProgramAVR+0x26e>
	  return;

	MAIN_WaitForJoyRelease();
     864:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
	
	JoyStatus = 1;                            // Use an invalid joystick value to force the program to write the
     868:	81 e0       	ldi	r24, 0x01	; 1
     86a:	8e bb       	out	0x1e, r24	; 30
	                                          // name of the default command onto the LCD
	while (1)
	{
		if (JoyStatus)
     86c:	8e b3       	in	r24, 0x1e	; 30
     86e:	88 23       	and	r24, r24
     870:	e9 f3       	breq	.-6      	; 0x86c <FUNCProgramAVR+0x48>
		{
			if (JoyStatus & JOY_LEFT)
     872:	f2 99       	sbic	0x1e, 2	; 30
     874:	0e c1       	rjmp	.+540    	; 0xa92 <FUNCProgramAVR+0x26e>
			  return;
			else if (JoyStatus & JOY_PRESS)
     876:	f4 99       	sbic	0x1e, 4	; 30
     878:	1c c0       	rjmp	.+56     	; 0x8b2 <FUNCProgramAVR+0x8e>
			  break;
			else if (JoyStatus & JOY_UP)
     87a:	f6 9b       	sbis	0x1e, 6	; 30
     87c:	06 c0       	rjmp	.+12     	; 0x88a <FUNCProgramAVR+0x66>
			  (ProgMode == 0)? ProgMode = 6 : ProgMode--;
     87e:	00 23       	and	r16, r16
     880:	11 f4       	brne	.+4      	; 0x886 <FUNCProgramAVR+0x62>
     882:	06 e0       	ldi	r16, 0x06	; 6
     884:	09 c0       	rjmp	.+18     	; 0x898 <FUNCProgramAVR+0x74>
     886:	01 50       	subi	r16, 0x01	; 1
     888:	07 c0       	rjmp	.+14     	; 0x898 <FUNCProgramAVR+0x74>
			else if (JoyStatus & JOY_DOWN)
     88a:	f7 9b       	sbis	0x1e, 7	; 30
     88c:	05 c0       	rjmp	.+10     	; 0x898 <FUNCProgramAVR+0x74>
			  (ProgMode == 6)? ProgMode = 0 : ProgMode++;
     88e:	06 30       	cpi	r16, 0x06	; 6
     890:	11 f4       	brne	.+4      	; 0x896 <FUNCProgramAVR+0x72>
     892:	00 e0       	ldi	r16, 0x00	; 0
     894:	01 c0       	rjmp	.+2      	; 0x898 <FUNCProgramAVR+0x74>
     896:	0f 5f       	subi	r16, 0xFF	; 255

			LCD_puts_f((uint8_t*)pgm_read_word(&ProgOptions[ProgMode])); // Show current function onto the LCD
     898:	e0 2f       	mov	r30, r16
     89a:	ff 27       	eor	r31, r31
     89c:	ee 0f       	add	r30, r30
     89e:	ff 1f       	adc	r31, r31
     8a0:	e3 55       	subi	r30, 0x53	; 83
     8a2:	ff 4f       	sbci	r31, 0xFF	; 255
     8a4:	85 91       	lpm	r24, Z+
     8a6:	94 91       	lpm	r25, Z
     8a8:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     8ac:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     8b0:	dd cf       	rjmp	.-70     	; 0x86c <FUNCProgramAVR+0x48>
		}
	}

	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);                // Orange = busy
     8b2:	81 b3       	in	r24, 0x11	; 17
     8b4:	80 63       	ori	r24, 0x30	; 48
     8b6:	81 bb       	out	0x11, r24	; 17
	LCD_puts_f(WaitText);
     8b8:	8c e2       	ldi	r24, 0x2C	; 44
     8ba:	92 e0       	ldi	r25, 0x02	; 2
     8bc:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>

	USI_SPIInitMaster(eeprom_read_byte_169(&Param_SCKDuration));
     8c0:	80 e2       	ldi	r24, 0x20	; 32
     8c2:	91 e0       	ldi	r25, 0x01	; 1
     8c4:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
     8c8:	0e 94 a1 09 	call	0x1342 <USI_SPIInitMaster>
	MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE); // Capture the RESET line of the slave AVR
     8cc:	80 e0       	ldi	r24, 0x00	; 0
     8ce:	0e 94 15 03 	call	0x62a <MAIN_ResetCSLine>

	EEPROMAddress = Prog_EnterProgMode;
     8d2:	80 91 12 01 	lds	r24, 0x0112
     8d6:	90 91 13 01 	lds	r25, 0x0113
     8da:	9d 8b       	std	Y+21, r25	; 0x15
     8dc:	8c 8b       	std	Y+20, r24	; 0x14
     8de:	56 e3       	ldi	r21, 0x36	; 54
     8e0:	e5 2e       	mov	r14, r21
     8e2:	51 e0       	ldi	r21, 0x01	; 1
     8e4:	f5 2e       	mov	r15, r21
     8e6:	1b e0       	ldi	r17, 0x0B	; 11
			
	for (uint8_t PacketB = 0; PacketB <= 11; PacketB++) // Read the enter programming mode command bytes
	{
		PacketBytes[PacketB] = eeprom_read_byte_169(&EEPROMAddress);
     8e8:	ce 01       	movw	r24, r28
     8ea:	44 96       	adiw	r24, 0x14	; 20
     8ec:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
     8f0:	f7 01       	movw	r30, r14
     8f2:	81 93       	st	Z+, r24
     8f4:	7f 01       	movw	r14, r30
		EEPROMAddress++;
     8f6:	8c 89       	ldd	r24, Y+20	; 0x14
     8f8:	9d 89       	ldd	r25, Y+21	; 0x15
     8fa:	01 96       	adiw	r24, 0x01	; 1
     8fc:	9d 8b       	std	Y+21, r25	; 0x15
     8fe:	8c 8b       	std	Y+20, r24	; 0x14
     900:	11 50       	subi	r17, 0x01	; 1
     902:	17 ff       	sbrs	r17, 7
     904:	f1 cf       	rjmp	.-30     	; 0x8e8 <FUNCProgramAVR+0xc4>
	}
	
	ISPCC_EnterChipProgrammingMode();    // Try to sync with the slave AVR
     906:	0e 94 b0 10 	call	0x2160 <ISPCC_EnterChipProgrammingMode>

	CurrAddress = 0;
     90a:	10 92 2d 01 	sts	0x012D, r1
     90e:	10 92 2e 01 	sts	0x012E, r1
     912:	10 92 2f 01 	sts	0x012F, r1
     916:	10 92 30 01 	sts	0x0130, r1

	if (PacketBytes[1] == STATUS_CMD_OK) // ISPCC_EnterChipProgrammingMode alters the PacketBytes buffer rather than returning a value
     91a:	80 91 37 01 	lds	r24, 0x0137
     91e:	88 23       	and	r24, r24
     920:	09 f0       	breq	.+2      	; 0x924 <FUNCProgramAVR+0x100>
     922:	a2 c0       	rjmp	.+324    	; 0xa68 <FUNCProgramAVR+0x244>
	{						
		if ((ProgMode == 6) || (ProgMode == 0) || (ProgMode == 2)) // Erase chip, or program flash mode
     924:	06 30       	cpi	r16, 0x06	; 6
     926:	21 f0       	breq	.+8      	; 0x930 <FUNCProgramAVR+0x10c>
     928:	00 23       	and	r16, r16
     92a:	11 f0       	breq	.+4      	; 0x930 <FUNCProgramAVR+0x10c>
     92c:	02 30       	cpi	r16, 0x02	; 2
     92e:	91 f4       	brne	.+36     	; 0x954 <FUNCProgramAVR+0x130>
		{
			MAIN_ShowProgType('C');
     930:	83 e4       	ldi	r24, 0x43	; 67
     932:	0e 94 48 03 	call	0x690 <MAIN_ShowProgType>
			
			if (!(eeprom_read_byte_169(&Prog_EraseCmdStored) == TRUE))
     936:	8a e1       	ldi	r24, 0x1A	; 26
     938:	91 e0       	ldi	r25, 0x01	; 1
     93a:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
     93e:	81 30       	cpi	r24, 0x01	; 1
     940:	39 f0       	breq	.+14     	; 0x950 <FUNCProgramAVR+0x12c>
			{
				Fault = ISPCC_FAULT_NOERASE;
     942:	42 e0       	ldi	r20, 0x02	; 2
     944:	d4 2e       	mov	r13, r20
				MAIN_ShowError(PSTR("NO ERASE CMD"));
     946:	87 e6       	ldi	r24, 0x67	; 103
     948:	92 e0       	ldi	r25, 0x02	; 2
     94a:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
     94e:	02 c0       	rjmp	.+4      	; 0x954 <FUNCProgramAVR+0x130>
			}
			else
			{
				PM_SendEraseCommand();
     950:	0e 94 6f 18 	call	0x30de <PM_SendEraseCommand>
			}
		}

		if (((ProgMode == 0) || (ProgMode == 2)) && (Fault == ISPCC_NO_FAULT)) // Program flash
     954:	00 23       	and	r16, r16
     956:	11 f0       	breq	.+4      	; 0x95c <FUNCProgramAVR+0x138>
     958:	02 30       	cpi	r16, 0x02	; 2
     95a:	c1 f4       	brne	.+48     	; 0x98c <FUNCProgramAVR+0x168>
     95c:	dd 20       	and	r13, r13
     95e:	b1 f4       	brne	.+44     	; 0x98c <FUNCProgramAVR+0x168>
		{
			MAIN_ShowProgType('D');
     960:	84 e4       	ldi	r24, 0x44	; 68
     962:	0e 94 48 03 	call	0x690 <MAIN_ShowProgType>

			if (!(PM_GetStoredDataSize(TYPE_FLASH))) // Check to make sure a program is present in memory
     966:	81 e0       	ldi	r24, 0x01	; 1
     968:	0e 94 b5 13 	call	0x276a <PM_GetStoredDataSize>
     96c:	dc 01       	movw	r26, r24
     96e:	cb 01       	movw	r24, r22
     970:	00 97       	sbiw	r24, 0x00	; 0
     972:	a1 05       	cpc	r26, r1
     974:	b1 05       	cpc	r27, r1
     976:	39 f4       	brne	.+14     	; 0x986 <FUNCProgramAVR+0x162>
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
     978:	33 e0       	ldi	r19, 0x03	; 3
     97a:	d3 2e       	mov	r13, r19
				MAIN_ShowError(PSTR("NO DATA"));
     97c:	84 e7       	ldi	r24, 0x74	; 116
     97e:	92 e0       	ldi	r25, 0x02	; 2
     980:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
     984:	03 c0       	rjmp	.+6      	; 0x98c <FUNCProgramAVR+0x168>
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_FLASH);
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	0e 94 bf 18 	call	0x317e <PM_CreateProgrammingPackets>
			}
		}
	
		if ((ProgMode == 1) || (ProgMode == 2)) // Program EEPROM
     98c:	80 2f       	mov	r24, r16
     98e:	81 50       	subi	r24, 0x01	; 1
     990:	82 30       	cpi	r24, 0x02	; 2
     992:	b0 f4       	brcc	.+44     	; 0x9c0 <FUNCProgramAVR+0x19c>
		{
			MAIN_ShowProgType('E');
     994:	85 e4       	ldi	r24, 0x45	; 69
     996:	0e 94 48 03 	call	0x690 <MAIN_ShowProgType>
				
			if (!(PM_GetStoredDataSize(TYPE_EEPROM))) // Check to make sure EEPROM data is present in memory
     99a:	80 e0       	ldi	r24, 0x00	; 0
     99c:	0e 94 b5 13 	call	0x276a <PM_GetStoredDataSize>
     9a0:	dc 01       	movw	r26, r24
     9a2:	cb 01       	movw	r24, r22
     9a4:	00 97       	sbiw	r24, 0x00	; 0
     9a6:	a1 05       	cpc	r26, r1
     9a8:	b1 05       	cpc	r27, r1
     9aa:	39 f4       	brne	.+14     	; 0x9ba <FUNCProgramAVR+0x196>
			{
				Fault = ISPCC_FAULT_NODATATYPE;
     9ac:	23 e0       	ldi	r18, 0x03	; 3
     9ae:	d2 2e       	mov	r13, r18
				MAIN_ShowError(PSTR("NO EEPROM"));
     9b0:	8c e7       	ldi	r24, 0x7C	; 124
     9b2:	92 e0       	ldi	r25, 0x02	; 2
     9b4:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
     9b8:	03 c0       	rjmp	.+6      	; 0x9c0 <FUNCProgramAVR+0x19c>
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_EEPROM);
     9ba:	80 e0       	ldi	r24, 0x00	; 0
     9bc:	0e 94 bf 18 	call	0x317e <PM_CreateProgrammingPackets>
			}
		}

		if ((ProgMode == 3) || (ProgMode == 5)) // Program Fuse bytes
     9c0:	03 30       	cpi	r16, 0x03	; 3
     9c2:	11 f0       	breq	.+4      	; 0x9c8 <FUNCProgramAVR+0x1a4>
     9c4:	05 30       	cpi	r16, 0x05	; 5
     9c6:	99 f4       	brne	.+38     	; 0x9ee <FUNCProgramAVR+0x1ca>
		{
			MAIN_ShowProgType('F');
     9c8:	86 e4       	ldi	r24, 0x46	; 70
     9ca:	0e 94 48 03 	call	0x690 <MAIN_ShowProgType>
			
			if (!(eeprom_read_byte_169(&Prog_TotalFuseBytes)))
     9ce:	80 e1       	ldi	r24, 0x10	; 16
     9d0:	91 e0       	ldi	r25, 0x01	; 1
     9d2:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
     9d6:	88 23       	and	r24, r24
     9d8:	39 f4       	brne	.+14     	; 0x9e8 <FUNCProgramAVR+0x1c4>
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
     9da:	93 e0       	ldi	r25, 0x03	; 3
     9dc:	d9 2e       	mov	r13, r25
				MAIN_ShowError(PSTR("NO FUSE BYTES"));
     9de:	86 e8       	ldi	r24, 0x86	; 134
     9e0:	92 e0       	ldi	r25, 0x02	; 2
     9e2:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
     9e6:	03 c0       	rjmp	.+6      	; 0x9ee <FUNCProgramAVR+0x1ca>
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_FUSE);
     9e8:	82 e0       	ldi	r24, 0x02	; 2
     9ea:	0e 94 1f 18 	call	0x303e <PM_SendFuseLockBytes>
			}
		}

		if ((ProgMode == 4) || (ProgMode == 5)) // Program Lock bytes
     9ee:	80 2f       	mov	r24, r16
     9f0:	84 50       	subi	r24, 0x04	; 4
     9f2:	82 30       	cpi	r24, 0x02	; 2
     9f4:	00 f5       	brcc	.+64     	; 0xa36 <FUNCProgramAVR+0x212>
		{
			if (ProgMode == 5)                    // If fusebytes have already been written, we need to reenter programming mode to latch them
     9f6:	05 30       	cpi	r16, 0x05	; 5
     9f8:	59 f4       	brne	.+22     	; 0xa10 <FUNCProgramAVR+0x1ec>
			{
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line of the slave AVR
     9fa:	81 e0       	ldi	r24, 0x01	; 1
     9fc:	0e 94 15 03 	call	0x62a <MAIN_ResetCSLine>
				MAIN_Delay10MS(1);
     a00:	81 e0       	ldi	r24, 0x01	; 1
     a02:	0e 94 27 02 	call	0x44e <MAIN_Delay10MS>
				MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE); // Capture the RESET line of the slave AVR
     a06:	80 e0       	ldi	r24, 0x00	; 0
     a08:	0e 94 15 03 	call	0x62a <MAIN_ResetCSLine>
				ISPCC_EnterChipProgrammingMode(); // Try to sync with the slave AVR
     a0c:	0e 94 b0 10 	call	0x2160 <ISPCC_EnterChipProgrammingMode>
			}

			MAIN_ShowProgType('L');
     a10:	8c e4       	ldi	r24, 0x4C	; 76
     a12:	0e 94 48 03 	call	0x690 <MAIN_ShowProgType>
		
			if (!(eeprom_read_byte_169(&Prog_TotalLockBytes)))
     a16:	8e e0       	ldi	r24, 0x0E	; 14
     a18:	91 e0       	ldi	r25, 0x01	; 1
     a1a:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
     a1e:	88 23       	and	r24, r24
     a20:	39 f4       	brne	.+14     	; 0xa30 <FUNCProgramAVR+0x20c>
			{
				Fault = ISPCC_FAULT_NODATATYPE;
     a22:	83 e0       	ldi	r24, 0x03	; 3
     a24:	d8 2e       	mov	r13, r24
				MAIN_ShowError(PSTR("NO LOCK BYTES"));
     a26:	84 e9       	ldi	r24, 0x94	; 148
     a28:	92 e0       	ldi	r25, 0x02	; 2
     a2a:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
     a2e:	03 c0       	rjmp	.+6      	; 0xa36 <FUNCProgramAVR+0x212>
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_LOCK);
     a30:	83 e0       	ldi	r24, 0x03	; 3
     a32:	0e 94 1f 18 	call	0x303e <PM_SendFuseLockBytes>
			}
		}

		strcpy_P(DoneFailMessageBuff, PSTR("PROGRAMMING DONE"));
     a36:	62 ea       	ldi	r22, 0xA2	; 162
     a38:	72 e0       	ldi	r23, 0x02	; 2
     a3a:	ce 01       	movw	r24, r28
     a3c:	01 96       	adiw	r24, 0x01	; 1
     a3e:	0e 94 68 1b 	call	0x36d0 <strcpy_P>

		if (Fault != ISPCC_NO_FAULT)         // Takes less code to just overwrite part of the string on fail
     a42:	dd 20       	and	r13, r13
     a44:	31 f0       	breq	.+12     	; 0xa52 <FUNCProgramAVR+0x22e>
		  strcpy_P(&DoneFailMessageBuff[12], PSTR("FAILED"));
     a46:	63 eb       	ldi	r22, 0xB3	; 179
     a48:	72 e0       	ldi	r23, 0x02	; 2
     a4a:	ce 01       	movw	r24, r28
     a4c:	0d 96       	adiw	r24, 0x0d	; 13
     a4e:	0e 94 68 1b 	call	0x36d0 <strcpy_P>

		LCD_puts(DoneFailMessageBuff);
     a52:	ce 01       	movw	r24, r28
     a54:	01 96       	adiw	r24, 0x01	; 1
     a56:	0e 94 b9 07 	call	0xf72 <LCD_puts>

		MAIN_Delay10MS(255);
     a5a:	8f ef       	ldi	r24, 0xFF	; 255
     a5c:	0e 94 27 02 	call	0x44e <MAIN_Delay10MS>
		MAIN_Delay10MS(100);
     a60:	84 e6       	ldi	r24, 0x64	; 100
     a62:	0e 94 27 02 	call	0x44e <MAIN_Delay10MS>
     a66:	04 c0       	rjmp	.+8      	; 0xa70 <FUNCProgramAVR+0x24c>
	}
	else
	{
		MAIN_ShowError(SyncErrorMessage);
     a68:	89 ed       	ldi	r24, 0xD9	; 217
     a6a:	93 e0       	ldi	r25, 0x03	; 3
     a6c:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
	}
	
	MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run	
     a70:	81 e0       	ldi	r24, 0x01	; 1
     a72:	0e 94 15 03 	call	0x62a <MAIN_ResetCSLine>
	USI_SPIOff();
     a76:	0e 94 b9 09 	call	0x1372 <USI_SPIOff>
	DF_EnableDataflash(FALSE);
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
	SPI_SPIOFF();
     a80:	80 91 64 00 	lds	r24, 0x0064
     a84:	84 60       	ori	r24, 0x04	; 4
     a86:	80 93 64 00 	sts	0x0064, r24
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Green = ready
     a8a:	81 b3       	in	r24, 0x11	; 17
     a8c:	8f 7c       	andi	r24, 0xCF	; 207
     a8e:	80 61       	ori	r24, 0x10	; 16
     a90:	81 bb       	out	0x11, r24	; 17
     a92:	65 96       	adiw	r28, 0x15	; 21
     a94:	0f b6       	in	r0, 0x3f	; 63
     a96:	f8 94       	cli
     a98:	de bf       	out	0x3e, r29	; 62
     a9a:	0f be       	out	0x3f, r0	; 63
     a9c:	cd bf       	out	0x3d, r28	; 61
     a9e:	df 91       	pop	r29
     aa0:	cf 91       	pop	r28
     aa2:	1f 91       	pop	r17
     aa4:	0f 91       	pop	r16
     aa6:	ff 90       	pop	r15
     aa8:	ef 90       	pop	r14
     aaa:	df 90       	pop	r13
     aac:	08 95       	ret

00000aae <FUNCStoreProgram>:
}

void FUNCStoreProgram(void)
{
	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
     aae:	8d e3       	ldi	r24, 0x3D	; 61
     ab0:	99 e0       	ldi	r25, 0x09	; 9
     ab2:	90 93 01 01 	sts	0x0101, r25
     ab6:	80 93 00 01 	sts	0x0100, r24
	SPI_SPIInit();
     aba:	0e 94 33 09 	call	0x1266 <SPI_SPIInit>
	UseExernalDF = FALSE;
     abe:	10 92 83 02 	sts	0x0283, r1
	DF_EnableDataflash(TRUE);
     ac2:	81 e0       	ldi	r24, 0x01	; 1
     ac4:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>

	if (!(DF_CheckCorrectOnboardChip()))
     ac8:	0e 94 af 0b 	call	0x175e <DF_CheckCorrectOnboardChip>
     acc:	88 23       	and	r24, r24
     ace:	a1 f0       	breq	.+40     	; 0xaf8 <FUNCStoreProgram+0x4a>
	  return;
			
	LCD_puts_f(PSTR("*STORAGE MODE*"));
     ad0:	8a eb       	ldi	r24, 0xBA	; 186
     ad2:	92 e0       	ldi	r25, 0x02	; 2
     ad4:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>

	InterpretPacketRoutine = (FuncPtr)PM_InterpretAVRISPPacket;
     ad8:	8d e5       	ldi	r24, 0x5D	; 93
     ada:	95 e1       	ldi	r25, 0x15	; 21
     adc:	90 93 25 01 	sts	0x0125, r25
     ae0:	80 93 24 01 	sts	0x0124, r24
	V2P_RunStateMachine();
     ae4:	0e 94 50 0f 	call	0x1ea0 <V2P_RunStateMachine>
	DF_EnableDataflash(FALSE);
     ae8:	80 e0       	ldi	r24, 0x00	; 0
     aea:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
	SPI_SPIOFF();
     aee:	80 91 64 00 	lds	r24, 0x0064
     af2:	84 60       	ori	r24, 0x04	; 4
     af4:	80 93 64 00 	sts	0x0064, r24
     af8:	08 95       	ret

00000afa <FUNCClearMem>:
}

void FUNCClearMem(void)
{
     afa:	0f 93       	push	r16
     afc:	1f 93       	push	r17
     afe:	cf 93       	push	r28
     b00:	df 93       	push	r29
     b02:	cd b7       	in	r28, 0x3d	; 61
     b04:	de b7       	in	r29, 0x3e	; 62
     b06:	22 97       	sbiw	r28, 0x02	; 2
     b08:	0f b6       	in	r0, 0x3f	; 63
     b0a:	f8 94       	cli
     b0c:	de bf       	out	0x3e, r29	; 62
     b0e:	0f be       	out	0x3f, r0	; 63
     b10:	cd bf       	out	0x3d, r28	; 61
	LCD_puts_f(PSTR("CONFIRM"));
     b12:	89 ec       	ldi	r24, 0xC9	; 201
     b14:	92 e0       	ldi	r25, 0x02	; 2
     b16:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>
	MAIN_Delay10MS(180);
     b1a:	84 eb       	ldi	r24, 0xB4	; 180
     b1c:	0e 94 27 02 	call	0x44e <MAIN_Delay10MS>

	LCD_puts_f(PSTR("<N Y>"));
     b20:	81 ed       	ldi	r24, 0xD1	; 209
     b22:	92 e0       	ldi	r25, 0x02	; 2
     b24:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>

	while (1)
	{
		if (JoyStatus)
     b28:	8e b3       	in	r24, 0x1e	; 30
     b2a:	88 23       	and	r24, r24
     b2c:	e9 f3       	breq	.-6      	; 0xb28 <FUNCClearMem+0x2e>
		{
			if (JoyStatus & JOY_LEFT)
     b2e:	8e b3       	in	r24, 0x1e	; 30
     b30:	99 27       	eor	r25, r25
     b32:	8c 01       	movw	r16, r24
     b34:	04 70       	andi	r16, 0x04	; 4
     b36:	10 70       	andi	r17, 0x00	; 0
     b38:	82 fd       	sbrc	r24, 2
     b3a:	29 c0       	rjmp	.+82     	; 0xb8e <FUNCClearMem+0x94>
			  return;
			else if (JoyStatus & JOY_RIGHT)
     b3c:	f3 9b       	sbis	0x1e, 3	; 30
     b3e:	f4 cf       	rjmp	.-24     	; 0xb28 <FUNCClearMem+0x2e>
			  break;
		}
	}

	MAIN_WaitForJoyRelease();
     b40:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>

	LCD_puts_f(WaitText);
     b44:	8c e2       	ldi	r24, 0x2C	; 44
     b46:	92 e0       	ldi	r25, 0x02	; 2
     b48:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>

	for (uint16_t EAddr = 0; EAddr < Sys_MagicNumber; EAddr++)
     b4c:	1a 83       	std	Y+2, r17	; 0x02
     b4e:	09 83       	std	Y+1, r16	; 0x01
     b50:	80 91 02 01 	lds	r24, 0x0102
     b54:	90 91 03 01 	lds	r25, 0x0103
     b58:	08 17       	cp	r16, r24
     b5a:	19 07       	cpc	r17, r25
     b5c:	88 f4       	brcc	.+34     	; 0xb80 <FUNCClearMem+0x86>
	  eeprom_write_byte_169(&EAddr, 0xFF);
     b5e:	6f ef       	ldi	r22, 0xFF	; 255
     b60:	ce 01       	movw	r24, r28
     b62:	01 96       	adiw	r24, 0x01	; 1
     b64:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
     b68:	89 81       	ldd	r24, Y+1	; 0x01
     b6a:	9a 81       	ldd	r25, Y+2	; 0x02
     b6c:	01 96       	adiw	r24, 0x01	; 1
     b6e:	9a 83       	std	Y+2, r25	; 0x02
     b70:	89 83       	std	Y+1, r24	; 0x01
     b72:	20 91 02 01 	lds	r18, 0x0102
     b76:	30 91 03 01 	lds	r19, 0x0103
     b7a:	82 17       	cp	r24, r18
     b7c:	93 07       	cpc	r25, r19
     b7e:	78 f3       	brcs	.-34     	; 0xb5e <FUNCClearMem+0x64>

	LCD_puts_f(PSTR("MEM CLEARED"));
     b80:	87 ed       	ldi	r24, 0xD7	; 215
     b82:	92 e0       	ldi	r25, 0x02	; 2
     b84:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>
	MAIN_Delay10MS(255);
     b88:	8f ef       	ldi	r24, 0xFF	; 255
     b8a:	0e 94 27 02 	call	0x44e <MAIN_Delay10MS>
     b8e:	22 96       	adiw	r28, 0x02	; 2
     b90:	0f b6       	in	r0, 0x3f	; 63
     b92:	f8 94       	cli
     b94:	de bf       	out	0x3e, r29	; 62
     b96:	0f be       	out	0x3f, r0	; 63
     b98:	cd bf       	out	0x3d, r28	; 61
     b9a:	df 91       	pop	r29
     b9c:	cf 91       	pop	r28
     b9e:	1f 91       	pop	r17
     ba0:	0f 91       	pop	r16
     ba2:	08 95       	ret

00000ba4 <FUNCAutoCalib>:
}

void FUNCAutoCalib(void)
{
	LCD_puts_f(WaitText);
     ba4:	8c e2       	ldi	r24, 0x2C	; 44
     ba6:	92 e0       	ldi	r25, 0x02	; 2
     ba8:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>
	OSCCAL_Calibrate();
     bac:	0e 94 35 07 	call	0xe6a <OSCCAL_Calibrate>
     bb0:	08 95       	ret

00000bb2 <FUNCManCalib>:
}

void FUNCManCalib(void)
{
     bb2:	cf 93       	push	r28
     bb4:	df 93       	push	r29
     bb6:	cd b7       	in	r28, 0x3d	; 61
     bb8:	de b7       	in	r29, 0x3e	; 62
     bba:	29 97       	sbiw	r28, 0x09	; 9
     bbc:	0f b6       	in	r0, 0x3f	; 63
     bbe:	f8 94       	cli
     bc0:	de bf       	out	0x3e, r29	; 62
     bc2:	0f be       	out	0x3f, r0	; 63
     bc4:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[9];

	JoyStatus = 1;                           // Invalid value to force the LCD to update
     bc6:	81 e0       	ldi	r24, 0x01	; 1
     bc8:	8e bb       	out	0x1e, r24	; 30
	
	USART_ENABLE(USART_TX_ON, USART_RX_OFF);
     bca:	80 91 c1 00 	lds	r24, 0x00C1
     bce:	80 78       	andi	r24, 0x80	; 128
     bd0:	88 60       	ori	r24, 0x08	; 8
     bd2:	80 93 c1 00 	sts	0x00C1, r24

	while (1)
	{
		if (BuffElements)                    // Routine will also echo send chars (directly accesses the ringbuffer count var)
     bd6:	80 91 d1 02 	lds	r24, 0x02D1
     bda:	88 23       	and	r24, r24
     bdc:	21 f0       	breq	.+8      	; 0xbe6 <FUNCManCalib+0x34>
		   USART_Tx(BUFF_GetBuffByte());
     bde:	0e 94 fa 0b 	call	0x17f4 <BUFF_GetBuffByte>
     be2:	0e 94 ea 08 	call	0x11d4 <USART_Tx>
	
		if (JoyStatus)
     be6:	8e b3       	in	r24, 0x1e	; 30
     be8:	88 23       	and	r24, r24
     bea:	a9 f3       	breq	.-22     	; 0xbd6 <FUNCManCalib+0x24>
		{
			if (JoyStatus & JOY_UP)
     bec:	f6 9b       	sbis	0x1e, 6	; 30
     bee:	04 c0       	rjmp	.+8      	; 0xbf8 <FUNCManCalib+0x46>
			  OSCCAL++;
     bf0:	80 91 66 00 	lds	r24, 0x0066
     bf4:	8f 5f       	subi	r24, 0xFF	; 255
     bf6:	05 c0       	rjmp	.+10     	; 0xc02 <FUNCManCalib+0x50>
			else if (JoyStatus & JOY_DOWN)
     bf8:	f7 9b       	sbis	0x1e, 7	; 30
     bfa:	06 c0       	rjmp	.+12     	; 0xc08 <FUNCManCalib+0x56>
			  OSCCAL--;
     bfc:	80 91 66 00 	lds	r24, 0x0066
     c00:	81 50       	subi	r24, 0x01	; 1
     c02:	80 93 66 00 	sts	0x0066, r24
     c06:	02 c0       	rjmp	.+4      	; 0xc0c <FUNCManCalib+0x5a>
			else if (JoyStatus & JOY_LEFT)
     c08:	f2 99       	sbic	0x1e, 2	; 30
     c0a:	1f c0       	rjmp	.+62     	; 0xc4a <FUNCManCalib+0x98>
			  break;
					
			// Copy the programmer name out of memory and transmit it via the USART:
			strcpy_P(Buffer, ProgrammerName);
     c0c:	63 e2       	ldi	r22, 0x23	; 35
     c0e:	72 e0       	ldi	r23, 0x02	; 2
     c10:	ce 01       	movw	r24, r28
     c12:	01 96       	adiw	r24, 0x01	; 1
     c14:	0e 94 68 1b 	call	0x36d0 <strcpy_P>
			USART_TxString(Buffer);
     c18:	ce 01       	movw	r24, r28
     c1a:	01 96       	adiw	r24, 0x01	; 1
     c1c:	0e 94 f2 08 	call	0x11e4 <USART_TxString>

			Buffer[0] = 'C';
     c20:	83 e4       	ldi	r24, 0x43	; 67
     c22:	89 83       	std	Y+1, r24	; 0x01
			Buffer[1] = 'V';
     c24:	86 e5       	ldi	r24, 0x56	; 86
     c26:	8a 83       	std	Y+2, r24	; 0x02
			Buffer[2] = ' ';
     c28:	80 e2       	ldi	r24, 0x20	; 32
     c2a:	8b 83       	std	Y+3, r24	; 0x03

			MAIN_IntToStr(OSCCAL, &Buffer[3]);
     c2c:	80 91 66 00 	lds	r24, 0x0066
     c30:	be 01       	movw	r22, r28
     c32:	6c 5f       	subi	r22, 0xFC	; 252
     c34:	7f 4f       	sbci	r23, 0xFF	; 255
     c36:	99 27       	eor	r25, r25
     c38:	0e 94 30 03 	call	0x660 <MAIN_IntToStr>
			LCD_puts(Buffer);
     c3c:	ce 01       	movw	r24, r28
     c3e:	01 96       	adiw	r24, 0x01	; 1
     c40:	0e 94 b9 07 	call	0xf72 <LCD_puts>

			MAIN_WaitForJoyRelease();
     c44:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     c48:	c6 cf       	rjmp	.-116    	; 0xbd6 <FUNCManCalib+0x24>
		}
	}
	
	USART_ENABLE(USART_TX_OFF, USART_RX_OFF);
     c4a:	80 91 c1 00 	lds	r24, 0x00C1
     c4e:	80 78       	andi	r24, 0x80	; 128
     c50:	80 93 c1 00 	sts	0x00C1, r24
     c54:	29 96       	adiw	r28, 0x09	; 9
     c56:	0f b6       	in	r0, 0x3f	; 63
     c58:	f8 94       	cli
     c5a:	de bf       	out	0x3e, r29	; 62
     c5c:	0f be       	out	0x3f, r0	; 63
     c5e:	cd bf       	out	0x3d, r28	; 61
     c60:	df 91       	pop	r29
     c62:	cf 91       	pop	r28
     c64:	08 95       	ret

00000c66 <FUNCSetContrast>:
}

void FUNCSetContrast(void)
{
     c66:	1f 93       	push	r17
     c68:	cf 93       	push	r28
     c6a:	df 93       	push	r29
     c6c:	cd b7       	in	r28, 0x3d	; 61
     c6e:	de b7       	in	r29, 0x3e	; 62
     c70:	26 97       	sbiw	r28, 0x06	; 6
     c72:	0f b6       	in	r0, 0x3f	; 63
     c74:	f8 94       	cli
     c76:	de bf       	out	0x3e, r29	; 62
     c78:	0f be       	out	0x3f, r0	; 63
     c7a:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[6];
	uint8_t Contrast = (eeprom_read_byte_169(&Sys_LCDContrast) & 0x0F); // Ranges from 0-15 so mask retuns 15 on blank EEPROM (0xFF)
     c7c:	84 e0       	ldi	r24, 0x04	; 4
     c7e:	91 e0       	ldi	r25, 0x01	; 1
     c80:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
     c84:	18 2f       	mov	r17, r24
     c86:	1f 70       	andi	r17, 0x0F	; 15
	
	JoyStatus = 1;                          // Invalid value to force the LCD to update
     c88:	81 e0       	ldi	r24, 0x01	; 1
     c8a:	8e bb       	out	0x1e, r24	; 30
	
	while (1)
	{
		if (JoyStatus)
     c8c:	8e b3       	in	r24, 0x1e	; 30
     c8e:	88 23       	and	r24, r24
     c90:	e9 f3       	breq	.-6      	; 0xc8c <FUNCSetContrast+0x26>
		{
			if (JoyStatus & JOY_UP)
     c92:	f6 9b       	sbis	0x1e, 6	; 30
     c94:	04 c0       	rjmp	.+8      	; 0xc9e <FUNCSetContrast+0x38>
			{
				if (Contrast < 15)
     c96:	1f 30       	cpi	r17, 0x0F	; 15
     c98:	80 f4       	brcc	.+32     	; 0xcba <FUNCSetContrast+0x54>
				  Contrast++;
     c9a:	1f 5f       	subi	r17, 0xFF	; 255
     c9c:	0e c0       	rjmp	.+28     	; 0xcba <FUNCSetContrast+0x54>
			}
			else if (JoyStatus & JOY_DOWN)
     c9e:	f7 9b       	sbis	0x1e, 7	; 30
     ca0:	04 c0       	rjmp	.+8      	; 0xcaa <FUNCSetContrast+0x44>
			{
				if (Contrast > 1)          // Zero is non-visible, so 1 is the minimum
     ca2:	12 30       	cpi	r17, 0x02	; 2
     ca4:	50 f0       	brcs	.+20     	; 0xcba <FUNCSetContrast+0x54>
				  Contrast--;
     ca6:	11 50       	subi	r17, 0x01	; 1
     ca8:	08 c0       	rjmp	.+16     	; 0xcba <FUNCSetContrast+0x54>
			}
			else if (JoyStatus & JOY_LEFT)
     caa:	f2 9b       	sbis	0x1e, 2	; 30
     cac:	06 c0       	rjmp	.+12     	; 0xcba <FUNCSetContrast+0x54>
			{
				eeprom_write_byte_169(&Sys_LCDContrast, Contrast);
     cae:	61 2f       	mov	r22, r17
     cb0:	84 e0       	ldi	r24, 0x04	; 4
     cb2:	91 e0       	ldi	r25, 0x01	; 1
     cb4:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
				return;
     cb8:	18 c0       	rjmp	.+48     	; 0xcea <FUNCSetContrast+0x84>
			}
					
			Buffer[0] = 'C';
     cba:	83 e4       	ldi	r24, 0x43	; 67
     cbc:	89 83       	std	Y+1, r24	; 0x01
			Buffer[1] = 'T';
     cbe:	84 e5       	ldi	r24, 0x54	; 84
     cc0:	8a 83       	std	Y+2, r24	; 0x02
			Buffer[2] = ' ';
     cc2:	80 e2       	ldi	r24, 0x20	; 32
     cc4:	8b 83       	std	Y+3, r24	; 0x03

			MAIN_IntToStr((uint16_t)Contrast, &Buffer[3]);
     cc6:	be 01       	movw	r22, r28
     cc8:	6c 5f       	subi	r22, 0xFC	; 252
     cca:	7f 4f       	sbci	r23, 0xFF	; 255
     ccc:	81 2f       	mov	r24, r17
     cce:	99 27       	eor	r25, r25
     cd0:	0e 94 30 03 	call	0x660 <MAIN_IntToStr>
			LCD_puts(Buffer);
     cd4:	ce 01       	movw	r24, r28
     cd6:	01 96       	adiw	r24, 0x01	; 1
     cd8:	0e 94 b9 07 	call	0xf72 <LCD_puts>

			LCD_CONTRAST_LEVEL(Contrast);
     cdc:	81 2f       	mov	r24, r17
     cde:	8f 70       	andi	r24, 0x0F	; 15
     ce0:	80 93 e7 00 	sts	0x00E7, r24

			MAIN_WaitForJoyRelease();
     ce4:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     ce8:	d1 cf       	rjmp	.-94     	; 0xc8c <FUNCSetContrast+0x26>
     cea:	26 96       	adiw	r28, 0x06	; 6
     cec:	0f b6       	in	r0, 0x3f	; 63
     cee:	f8 94       	cli
     cf0:	de bf       	out	0x3e, r29	; 62
     cf2:	0f be       	out	0x3f, r0	; 63
     cf4:	cd bf       	out	0x3d, r28	; 61
     cf6:	df 91       	pop	r29
     cf8:	cf 91       	pop	r28
     cfa:	1f 91       	pop	r17
     cfc:	08 95       	ret

00000cfe <FUNCSetISPSpeed>:
		}
	}
}

void FUNCSetISPSpeed(void)
{
     cfe:	cf 93       	push	r28
	JoyStatus = 1;                         // Invalid value to force the LCD to update
     d00:	81 e0       	ldi	r24, 0x01	; 1
     d02:	8e bb       	out	0x1e, r24	; 30

	uint8_t CurrSpeed = eeprom_read_byte_169(&Param_SCKDuration);
     d04:	80 e2       	ldi	r24, 0x20	; 32
     d06:	91 e0       	ldi	r25, 0x01	; 1
     d08:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
     d0c:	c8 2f       	mov	r28, r24

	if (CurrSpeed > (USI_PRESET_SPEEDS - 1)) CurrSpeed = 0; // Protection against blank EEPROM
     d0e:	84 30       	cpi	r24, 0x04	; 4
     d10:	08 f0       	brcs	.+2      	; 0xd14 <FUNCSetISPSpeed+0x16>
     d12:	c0 e0       	ldi	r28, 0x00	; 0

	while (1)
	{
		if (JoyStatus)
     d14:	8e b3       	in	r24, 0x1e	; 30
     d16:	88 23       	and	r24, r24
     d18:	e9 f3       	breq	.-6      	; 0xd14 <FUNCSetISPSpeed+0x16>
		{
			if (JoyStatus & JOY_UP)
     d1a:	f6 9b       	sbis	0x1e, 6	; 30
     d1c:	06 c0       	rjmp	.+12     	; 0xd2a <FUNCSetISPSpeed+0x2c>
			{
				(CurrSpeed == 0)? CurrSpeed = (USI_PRESET_SPEEDS - 1) : CurrSpeed--;
     d1e:	cc 23       	and	r28, r28
     d20:	11 f4       	brne	.+4      	; 0xd26 <FUNCSetISPSpeed+0x28>
     d22:	c3 e0       	ldi	r28, 0x03	; 3
     d24:	12 c0       	rjmp	.+36     	; 0xd4a <FUNCSetISPSpeed+0x4c>
     d26:	c1 50       	subi	r28, 0x01	; 1
     d28:	10 c0       	rjmp	.+32     	; 0xd4a <FUNCSetISPSpeed+0x4c>
			}
			else if (JoyStatus & JOY_DOWN)
     d2a:	f7 9b       	sbis	0x1e, 7	; 30
     d2c:	06 c0       	rjmp	.+12     	; 0xd3a <FUNCSetISPSpeed+0x3c>
			{
				(CurrSpeed == (USI_PRESET_SPEEDS - 1))? CurrSpeed = 0 : CurrSpeed++;
     d2e:	c3 30       	cpi	r28, 0x03	; 3
     d30:	11 f4       	brne	.+4      	; 0xd36 <FUNCSetISPSpeed+0x38>
     d32:	c0 e0       	ldi	r28, 0x00	; 0
     d34:	0a c0       	rjmp	.+20     	; 0xd4a <FUNCSetISPSpeed+0x4c>
     d36:	cf 5f       	subi	r28, 0xFF	; 255
     d38:	08 c0       	rjmp	.+16     	; 0xd4a <FUNCSetISPSpeed+0x4c>
			}
			else if (JoyStatus & JOY_LEFT)
     d3a:	f2 9b       	sbis	0x1e, 2	; 30
     d3c:	06 c0       	rjmp	.+12     	; 0xd4a <FUNCSetISPSpeed+0x4c>
			{
				eeprom_write_byte_169(&Param_SCKDuration, CurrSpeed);
     d3e:	6c 2f       	mov	r22, r28
     d40:	80 e2       	ldi	r24, 0x20	; 32
     d42:	91 e0       	ldi	r25, 0x01	; 1
     d44:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
				return;
     d48:	0d c0       	rjmp	.+26     	; 0xd64 <FUNCSetISPSpeed+0x66>
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&USIPSNamePtrs[CurrSpeed]));
     d4a:	ec 2f       	mov	r30, r28
     d4c:	ff 27       	eor	r31, r31
     d4e:	ee 0f       	add	r30, r30
     d50:	ff 1f       	adc	r31, r31
     d52:	e3 58       	subi	r30, 0x83	; 131
     d54:	ff 4f       	sbci	r31, 0xFF	; 255
     d56:	85 91       	lpm	r24, Z+
     d58:	94 91       	lpm	r25, Z
     d5a:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     d5e:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     d62:	d8 cf       	rjmp	.-80     	; 0xd14 <FUNCSetISPSpeed+0x16>
     d64:	cf 91       	pop	r28
     d66:	08 95       	ret

00000d68 <FUNCSleepMode>:
		}
	}
}

void FUNCSleepMode(void)
{
	SMCR    = ((1 << SM1) | (1 << SE));   // Power down sleep mode
     d68:	85 e0       	ldi	r24, 0x05	; 5
     d6a:	83 bf       	out	0x33, r24	; 51
	LCDCRA &= ~(1 << LCDEN); 
     d6c:	80 91 e4 00 	lds	r24, 0x00E4
     d70:	8f 77       	andi	r24, 0x7F	; 127
     d72:	80 93 e4 00 	sts	0x00E4, r24
	
	while (!(JoyStatus & JOY_UP))        // Joystick interrupt wakes the micro
	  SLEEP();
     d76:	f6 99       	sbic	0x1e, 6	; 30
     d78:	03 c0       	rjmp	.+6      	; 0xd80 <FUNCSleepMode+0x18>
     d7a:	88 95       	sleep
     d7c:	f6 9b       	sbis	0x1e, 6	; 30
     d7e:	fd cf       	rjmp	.-6      	; 0xd7a <FUNCSleepMode+0x12>
	   
	LCDCRA |= (1 << LCDEN);
     d80:	80 91 e4 00 	lds	r24, 0x00E4
     d84:	80 68       	ori	r24, 0x80	; 128
     d86:	80 93 e4 00 	sts	0x00E4, r24

	LCD_puts_f(WaitText);
     d8a:	8c e2       	ldi	r24, 0x2C	; 44
     d8c:	92 e0       	ldi	r25, 0x02	; 2
     d8e:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>
	OSCCAL_Calibrate();	
     d92:	0e 94 35 07 	call	0xe6a <OSCCAL_Calibrate>
	
	MAIN_WaitForJoyRelease();
     d96:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     d9a:	08 95       	ret

00000d9c <FUNCStorageInfo>:
}

void FUNCStorageInfo(void)
{
     d9c:	1f 93       	push	r17
     d9e:	cf 93       	push	r28
	uint8_t SelectedItem = 0;
     da0:	10 e0       	ldi	r17, 0x00	; 0

	MAIN_WaitForJoyRelease();
     da2:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>

	JoyStatus = 1;                         // Invalid value to force the LCD to update
     da6:	81 e0       	ldi	r24, 0x01	; 1
     da8:	8e bb       	out	0x1e, r24	; 30

	while (1)
	{
		if (JoyStatus)
     daa:	8e b3       	in	r24, 0x1e	; 30
     dac:	88 23       	and	r24, r24
     dae:	e9 f3       	breq	.-6      	; 0xdaa <FUNCStorageInfo+0xe>
		{
			if ((JoyStatus & JOY_UP) || (JoyStatus & JOY_DOWN))
     db0:	f6 99       	sbic	0x1e, 6	; 30
     db2:	02 c0       	rjmp	.+4      	; 0xdb8 <FUNCStorageInfo+0x1c>
     db4:	f7 9b       	sbis	0x1e, 7	; 30
     db6:	03 c0       	rjmp	.+6      	; 0xdbe <FUNCStorageInfo+0x22>
			{
				SelectedItem ^= 1;
     db8:	81 e0       	ldi	r24, 0x01	; 1
     dba:	18 27       	eor	r17, r24
     dbc:	38 c0       	rjmp	.+112    	; 0xe2e <FUNCStorageInfo+0x92>
			}
			else if (JoyStatus & JOY_LEFT)
     dbe:	f2 99       	sbic	0x1e, 2	; 30
     dc0:	43 c0       	rjmp	.+134    	; 0xe48 <FUNCStorageInfo+0xac>
			{
				return;
			}
			else if (JoyStatus & JOY_PRESS)
     dc2:	f4 9b       	sbis	0x1e, 4	; 30
     dc4:	34 c0       	rjmp	.+104    	; 0xe2e <FUNCStorageInfo+0x92>
			{
				if (SelectedItem == 1)    // View storage tags
     dc6:	11 30       	cpi	r17, 0x01	; 1
     dc8:	81 f5       	brne	.+96     	; 0xe2a <FUNCStorageInfo+0x8e>
				{
					DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
     dca:	8d e3       	ldi	r24, 0x3D	; 61
     dcc:	99 e0       	ldi	r25, 0x09	; 9
     dce:	90 93 01 01 	sts	0x0101, r25
     dd2:	80 93 00 01 	sts	0x0100, r24
					SPI_SPIInit();
     dd6:	0e 94 33 09 	call	0x1266 <SPI_SPIInit>
					UseExernalDF = FALSE;
     dda:	10 92 83 02 	sts	0x0283, r1
					DF_EnableDataflash(TRUE);
     dde:	81 2f       	mov	r24, r17
     de0:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>

					if (DF_CheckCorrectOnboardChip())
     de4:	0e 94 af 0b 	call	0x175e <DF_CheckCorrectOnboardChip>
     de8:	c8 2f       	mov	r28, r24
     dea:	88 23       	and	r24, r24
     dec:	41 f0       	breq	.+16     	; 0xdfe <FUNCStorageInfo+0x62>
					{
						TM_ShowTags();
     dee:	0e 94 40 1b 	call	0x3680 <TM_ShowTags>
						SPI_SPIOFF();
     df2:	80 91 64 00 	lds	r24, 0x0064
     df6:	84 60       	ori	r24, 0x04	; 4
     df8:	80 93 64 00 	sts	0x0064, r24
     dfc:	18 c0       	rjmp	.+48     	; 0xe2e <FUNCStorageInfo+0x92>
					}
					else if (!(PM_GetStoredDataSize(TYPE_FLASH)))
     dfe:	81 2f       	mov	r24, r17
     e00:	0e 94 b5 13 	call	0x276a <PM_GetStoredDataSize>
     e04:	dc 01       	movw	r26, r24
     e06:	cb 01       	movw	r24, r22
     e08:	00 97       	sbiw	r24, 0x00	; 0
     e0a:	a1 05       	cpc	r26, r1
     e0c:	b1 05       	cpc	r27, r1
     e0e:	79 f4       	brne	.+30     	; 0xe2e <FUNCStorageInfo+0x92>
					{
						DF_EnableDataflash(FALSE);
     e10:	8c 2f       	mov	r24, r28
     e12:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
						SPI_SPIOFF();
     e16:	80 91 64 00 	lds	r24, 0x0064
     e1a:	84 60       	ori	r24, 0x04	; 4
     e1c:	80 93 64 00 	sts	0x0064, r24

						MAIN_ShowError(PSTR("NO STORED PRGM"));
     e20:	83 ee       	ldi	r24, 0xE3	; 227
     e22:	92 e0       	ldi	r25, 0x02	; 2
     e24:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
     e28:	02 c0       	rjmp	.+4      	; 0xe2e <FUNCStorageInfo+0x92>
					}	
				}
				else                  // View stored data sizes
				{
					PM_ShowStoredItemSizes();
     e2a:	0e 94 1c 1a 	call	0x3438 <PM_ShowStoredItemSizes>
				}
			}
			
			LCD_puts_f((uint8_t*)pgm_read_word(&SIFOOptionPtrs[SelectedItem]));
     e2e:	e1 2f       	mov	r30, r17
     e30:	ff 27       	eor	r31, r31
     e32:	ee 0f       	add	r30, r30
     e34:	ff 1f       	adc	r31, r31
     e36:	e4 5a       	subi	r30, 0xA4	; 164
     e38:	ff 4f       	sbci	r31, 0xFF	; 255
     e3a:	85 91       	lpm	r24, Z+
     e3c:	94 91       	lpm	r25, Z
     e3e:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     e42:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     e46:	b1 cf       	rjmp	.-158    	; 0xdaa <FUNCStorageInfo+0xe>
     e48:	cf 91       	pop	r28
     e4a:	1f 91       	pop	r17
     e4c:	08 95       	ret

00000e4e <FUNCGoBootloader>:
		}
	}
}

void FUNCGoBootloader(void)
{
	uint8_t MD = (MCUCR & ~(1 << JTD)); // Forces compiler to use two OUTs rather than two IN/AND/OUTs
     e4e:	85 b7       	in	r24, 0x35	; 53
     e50:	8f 77       	andi	r24, 0x7F	; 127
	MCUCR = MD;  // Turn on JTAG via code
     e52:	85 bf       	out	0x35, r24	; 53
	MCUCR = MD;  // Twice as specified in datasheet        
     e54:	85 bf       	out	0x35, r24	; 53
	
	LCD_puts_f(PSTR("*JTAG ON*"));
     e56:	82 ef       	ldi	r24, 0xF2	; 242
     e58:	92 e0       	ldi	r25, 0x02	; 2
     e5a:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>
	
	MAIN_WaitForJoyRelease();
     e5e:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
	
	WDTCR = ((1<<WDCE) | (1<<WDE)); // Enable Watchdog Timer to give reset after minimum timeout
     e62:	88 e1       	ldi	r24, 0x18	; 24
     e64:	80 93 60 00 	sts	0x0060, r24
	while (1) {};                  // Eternal loop - when watchdog resets the AVR it will enter the bootloader
     e68:	ff cf       	rjmp	.-2      	; 0xe68 <FUNCGoBootloader+0x1a>

00000e6a <OSCCAL_Calibrate>:
	unsigned char SREG_Backup;
	unsigned char LoopCount = 64; // Maximum range is 128, and starts from the middle, so 64 is the max number of iterations required
   
	// Make sure all clock division is turned off (8Mhz RC clock)
	CLKPR = (1 << CLKPCE);
     e6a:	80 e8       	ldi	r24, 0x80	; 128
     e6c:	80 93 61 00 	sts	0x0061, r24
	CLKPR = 0;
     e70:	10 92 61 00 	sts	0x0061, r1

	// Inital OSCCAL of half its maximum for speed
	OSCCAL = (0x7F / 2);
     e74:	8f e3       	ldi	r24, 0x3F	; 63
     e76:	80 93 66 00 	sts	0x0066, r24

	//Save the SREG
	SREG_Backup = SREG;
     e7a:	3f b7       	in	r19, 0x3f	; 63
    
	// Disable all timer 1 interrupts
	TIMSK1 = 0;
     e7c:	10 92 6f 00 	sts	0x006F, r1
        
	// Set timer 2 to asyncronous mode (32.768KHz crystal)
	ASSR  = (1 << AS2);
     e80:	88 e0       	ldi	r24, 0x08	; 8
     e82:	80 93 b6 00 	sts	0x00B6, r24
        
	// Timer 2 overflow interrupt enable
	TIMSK2 = (1 << TOIE2);
     e86:	81 e0       	ldi	r24, 0x01	; 1
     e88:	80 93 70 00 	sts	0x0070, r24

	//Enable interrupts
	sei();
     e8c:	78 94       	sei

	// Start both counters with no prescaling
	TCCR1B = (1 << CS10);
     e8e:	80 93 81 00 	sts	0x0081, r24
	TCCR2A = (1 << CS20);
     e92:	80 93 b0 00 	sts	0x00B0, r24
	 	 
	// Wait until timer 2's external 32.768KHz crystal is stable
	while (ASSR & ((1 << TCN2UB) | (1 << TCR2UB) | (1 << OCR2UB)));
     e96:	80 91 b6 00 	lds	r24, 0x00B6
     e9a:	99 27       	eor	r25, r25
     e9c:	87 70       	andi	r24, 0x07	; 7
     e9e:	90 70       	andi	r25, 0x00	; 0
     ea0:	00 97       	sbiw	r24, 0x00	; 0
     ea2:	c9 f7       	brne	.-14     	; 0xe96 <OSCCAL_Calibrate+0x2c>
    
	// Clear the timer values
	TCNT1 = 0;
     ea4:	90 93 85 00 	sts	0x0085, r25
     ea8:	80 93 84 00 	sts	0x0084, r24
	TCNT2 = 0;
     eac:	10 92 b2 00 	sts	0x00B2, r1
    
	while (LoopCount--)
	{
		// Let it take a few readings (60ms, approx 7 readings)
		_delay_ms(60);
        
		if (ActualCount > (TARGETCOUNT + 5))		    // Clock is running too fast
		{
			// Bit 7 selects low or high range - only low range is nessesary
			OSCCAL = ((OSCCAL - 1) & ~(1 << 7));
		}
		else if (ActualCount < (TARGETCOUNT - 5))		// Clock is running too slow
		{
			// Bit 7 selects low or high range - only low range is nessesary
			OSCCAL = ((OSCCAL + 1) & ~(1 << 7));
		}
		else		                                    // Clock is just right
		{
			break;
     eb0:	2f e3       	ldi	r18, 0x3F	; 63
     eb2:	fc 01       	movw	r30, r24
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     eb4:	cf 01       	movw	r24, r30
     eb6:	01 97       	sbiw	r24, 0x01	; 1
     eb8:	f1 f7       	brne	.-4      	; 0xeb6 <OSCCAL_Calibrate+0x4c>
     eba:	80 91 26 01 	lds	r24, 0x0126
     ebe:	90 91 27 01 	lds	r25, 0x0127
     ec2:	81 50       	subi	r24, 0x01	; 1
     ec4:	91 4e       	sbci	r25, 0xE1	; 225
     ec6:	20 f0       	brcs	.+8      	; 0xed0 <OSCCAL_Calibrate+0x66>
     ec8:	80 91 66 00 	lds	r24, 0x0066
     ecc:	81 50       	subi	r24, 0x01	; 1
     ece:	0a c0       	rjmp	.+20     	; 0xee4 <OSCCAL_Calibrate+0x7a>
     ed0:	80 91 26 01 	lds	r24, 0x0126
     ed4:	90 91 27 01 	lds	r25, 0x0127
     ed8:	86 5f       	subi	r24, 0xF6	; 246
     eda:	90 4e       	sbci	r25, 0xE0	; 224
     edc:	40 f4       	brcc	.+16     	; 0xeee <OSCCAL_Calibrate+0x84>
     ede:	80 91 66 00 	lds	r24, 0x0066
     ee2:	8f 5f       	subi	r24, 0xFF	; 255
     ee4:	8f 77       	andi	r24, 0x7F	; 127
     ee6:	80 93 66 00 	sts	0x0066, r24
     eea:	21 50       	subi	r18, 0x01	; 1
     eec:	18 f7       	brcc	.-58     	; 0xeb4 <OSCCAL_Calibrate+0x4a>
		}		
	}
            
	// Disable all timer interrupts
	TIMSK1 = 0;
     eee:	10 92 6f 00 	sts	0x006F, r1
	TIMSK2 = 0;
     ef2:	10 92 70 00 	sts	0x0070, r1
    
	// Stop the timers
	TCCR1B = 0x00;
     ef6:	10 92 81 00 	sts	0x0081, r1
	TCCR2A = 0x00;
     efa:	10 92 b0 00 	sts	0x00B0, r1

	// Turn off timer 2 asynchronous mode
	ASSR  &= ~(1 << AS2);
     efe:	80 91 b6 00 	lds	r24, 0x00B6
     f02:	87 7f       	andi	r24, 0xF7	; 247
     f04:	80 93 b6 00 	sts	0x00B6, r24

	// Restore SREG
	SREG = SREG_Backup;
     f08:	3f bf       	out	0x3f, r19	; 63
     f0a:	08 95       	ret

00000f0c <__vector_5>:
        
	return;
}

ISR(TIMER2_OVF_vect, ISR_BLOCK) // Occurs 32768/256 timers per second, or 128Hz
{
     f0c:	1f 92       	push	r1
     f0e:	0f 92       	push	r0
     f10:	0f b6       	in	r0, 0x3f	; 63
     f12:	0f 92       	push	r0
     f14:	11 24       	eor	r1, r1
     f16:	8f 93       	push	r24
     f18:	9f 93       	push	r25
	// Stop timer 1 so it can be read
	TCCR1B = 0x00;
     f1a:	10 92 81 00 	sts	0x0081, r1
    
	// Record timer 1's value
	ActualCount = TCNT1;
     f1e:	80 91 84 00 	lds	r24, 0x0084
     f22:	90 91 85 00 	lds	r25, 0x0085
     f26:	90 93 27 01 	sts	0x0127, r25
     f2a:	80 93 26 01 	sts	0x0126, r24
	     
	// Reset counters and restart timer 1
	TCNT1  = 0;
     f2e:	10 92 85 00 	sts	0x0085, r1
     f32:	10 92 84 00 	sts	0x0084, r1
	TCNT2  = 0;
     f36:	10 92 b2 00 	sts	0x00B2, r1
	TCCR1B = (1 << CS10);
     f3a:	81 e0       	ldi	r24, 0x01	; 1
     f3c:	80 93 81 00 	sts	0x0081, r24
     f40:	9f 91       	pop	r25
     f42:	8f 91       	pop	r24
     f44:	0f 90       	pop	r0
     f46:	0f be       	out	0x3f, r0	; 63
     f48:	0f 90       	pop	r0
     f4a:	1f 90       	pop	r1
     f4c:	18 95       	reti

00000f4e <LCD_Init>:
// ======================================================================================

void LCD_Init(void)
{
	LCDCCR = 0x0F;
     f4e:	8f e0       	ldi	r24, 0x0F	; 15
     f50:	80 93 e7 00 	sts	0x00E7, r24

    // Select asynchronous clock source, enable all COM pins and enable all segment pins.
    LCDCRB  = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
     f54:	87 eb       	ldi	r24, 0xB7	; 183
     f56:	80 93 e5 00 	sts	0x00E5, r24

    // Set LCD prescaler to give a framerate of 32,0 Hz
    LCDFRR  = (0<<LCDPS0) | (7<<LCDCD0);    
     f5a:	87 e0       	ldi	r24, 0x07	; 7
     f5c:	80 93 e6 00 	sts	0x00E6, r24

	// Enable LCD and set low power waveform
    LCDCRA  = (1<<LCDEN) | (1<<LCDAB); 
     f60:	80 ec       	ldi	r24, 0xC0	; 192
     f62:	80 93 e4 00 	sts	0x00E4, r24

    //Enable LCD start of frame interrupt
    LCDCRA |= (1<<LCDIE);
     f66:	80 91 e4 00 	lds	r24, 0x00E4
     f6a:	88 60       	ori	r24, 0x08	; 8
     f6c:	80 93 e4 00 	sts	0x00E4, r24
     f70:	08 95       	ret

00000f72 <LCD_puts>:
}

void LCD_puts_f(const uint8_t *FlashData)
{
	uint8_t StrBuff[LCD_TEXTBUFFER_SIZE];

	strcpy_P(StrBuff, FlashData);
	LCD_puts(StrBuff);
}

void LCD_puts(uint8_t *Data)
{
     f72:	cf 93       	push	r28
     f74:	df 93       	push	r29
     f76:	ec 01       	movw	r28, r24
	uint8_t LoadB;
	
	for (LoadB = 0; LoadB < 20; LoadB++)
     f78:	20 e0       	ldi	r18, 0x00	; 0
     f7a:	3f ef       	ldi	r19, 0xFF	; 255
     f7c:	e1 e5       	ldi	r30, 0x51	; 81
     f7e:	f2 e0       	ldi	r31, 0x02	; 2
     f80:	df 01       	movw	r26, r30
	{
		uint8_t CByte = *(Data++);
     f82:	89 91       	ld	r24, Y+
	
		if ((CByte >= '*') && (CByte <= 'z'))
     f84:	98 2f       	mov	r25, r24
     f86:	9a 52       	subi	r25, 0x2A	; 42
     f88:	91 35       	cpi	r25, 0x51	; 81
     f8a:	38 f4       	brcc	.+14     	; 0xf9a <LCD_puts+0x28>
		  TextBuffer[LoadB] = ((CByte == ' ')? 0xFF : (CByte - '*'));
     f8c:	80 32       	cpi	r24, 0x20	; 32
     f8e:	11 f0       	breq	.+4      	; 0xf94 <LCD_puts+0x22>
     f90:	89 2f       	mov	r24, r25
     f92:	01 c0       	rjmp	.+2      	; 0xf96 <LCD_puts+0x24>
     f94:	8f ef       	ldi	r24, 0xFF	; 255
     f96:	8c 93       	st	X, r24
     f98:	03 c0       	rjmp	.+6      	; 0xfa0 <LCD_puts+0x2e>
		else if (CByte == 0x00)
     f9a:	88 23       	and	r24, r24
     f9c:	31 f0       	breq	.+12     	; 0xfaa <LCD_puts+0x38>
		  break;
		else
		  TextBuffer[LoadB] = 0xFF;		
     f9e:	30 83       	st	Z, r19
     fa0:	2f 5f       	subi	r18, 0xFF	; 255
     fa2:	11 96       	adiw	r26, 0x01	; 1
     fa4:	31 96       	adiw	r30, 0x01	; 1
     fa6:	24 31       	cpi	r18, 0x14	; 20
     fa8:	60 f3       	brcs	.-40     	; 0xf82 <LCD_puts+0x10>
	}

	ScrollMode  = ((LoadB > 6)? TRUE : FALSE);
     faa:	80 e0       	ldi	r24, 0x00	; 0
     fac:	27 30       	cpi	r18, 0x07	; 7
     fae:	08 f0       	brcs	.+2      	; 0xfb2 <LCD_puts+0x40>
     fb0:	81 e0       	ldi	r24, 0x01	; 1
     fb2:	80 93 81 02 	sts	0x0281, r24
	ScrollCount = 0;
     fb6:	10 92 4f 02 	sts	0x024F, r1
     fba:	9f ef       	ldi	r25, 0xFF	; 255
     fbc:	86 e0       	ldi	r24, 0x06	; 6

	for (uint8_t Nulls = 0; Nulls < 7; Nulls++)
		TextBuffer[LoadB++] = 0xFF;
     fbe:	e2 2f       	mov	r30, r18
     fc0:	ff 27       	eor	r31, r31
     fc2:	ef 5a       	subi	r30, 0xAF	; 175
     fc4:	fd 4f       	sbci	r31, 0xFD	; 253
     fc6:	90 83       	st	Z, r25
     fc8:	2f 5f       	subi	r18, 0xFF	; 255
     fca:	81 50       	subi	r24, 0x01	; 1
     fcc:	87 ff       	sbrs	r24, 7
     fce:	f7 cf       	rjmp	.-18     	; 0xfbe <LCD_puts+0x4c>
	
	TextBuffer[LoadB] = 0x00;
     fd0:	e2 2f       	mov	r30, r18
     fd2:	ff 27       	eor	r31, r31
     fd4:	ef 5a       	subi	r30, 0xAF	; 175
     fd6:	fd 4f       	sbci	r31, 0xFD	; 253
     fd8:	10 82       	st	Z, r1
	StrStart   = 0;
     fda:	10 92 50 02 	sts	0x0250, r1
	StrEnd     = LoadB;	
     fde:	20 93 4e 02 	sts	0x024E, r18
	DelayCount = LCD_DELAYCOUNT_DEFAULT;
     fe2:	8a e0       	ldi	r24, 0x0A	; 10
     fe4:	80 93 82 02 	sts	0x0282, r24

	UpdateLCD  = TRUE;
     fe8:	81 e0       	ldi	r24, 0x01	; 1
     fea:	80 93 6c 02 	sts	0x026C, r24
     fee:	df 91       	pop	r29
     ff0:	cf 91       	pop	r28
     ff2:	08 95       	ret

00000ff4 <LCD_puts_f>:
     ff4:	cf 93       	push	r28
     ff6:	df 93       	push	r29
     ff8:	cd b7       	in	r28, 0x3d	; 61
     ffa:	de b7       	in	r29, 0x3e	; 62
     ffc:	64 97       	sbiw	r28, 0x14	; 20
     ffe:	0f b6       	in	r0, 0x3f	; 63
    1000:	f8 94       	cli
    1002:	de bf       	out	0x3e, r29	; 62
    1004:	0f be       	out	0x3f, r0	; 63
    1006:	cd bf       	out	0x3d, r28	; 61
    1008:	bc 01       	movw	r22, r24
    100a:	ce 01       	movw	r24, r28
    100c:	01 96       	adiw	r24, 0x01	; 1
    100e:	0e 94 68 1b 	call	0x36d0 <strcpy_P>
    1012:	ce 01       	movw	r24, r28
    1014:	01 96       	adiw	r24, 0x01	; 1
    1016:	0e 94 b9 07 	call	0xf72 <LCD_puts>
    101a:	64 96       	adiw	r28, 0x14	; 20
    101c:	0f b6       	in	r0, 0x3f	; 63
    101e:	f8 94       	cli
    1020:	de bf       	out	0x3e, r29	; 62
    1022:	0f be       	out	0x3f, r0	; 63
    1024:	cd bf       	out	0x3d, r28	; 61
    1026:	df 91       	pop	r29
    1028:	cf 91       	pop	r28
    102a:	08 95       	ret

0000102c <LCD_WriteChar>:
}

void LCD_WriteChar(uint8_t Byte, uint8_t Digit)
{
    102c:	e8 2f       	mov	r30, r24
	uint16_t SegData  = 0x00;
    102e:	20 e0       	ldi	r18, 0x00	; 0
    1030:	30 e0       	ldi	r19, 0x00	; 0
	uint8_t  *BuffPtr = (&SegBuffer[0] + (Digit >> 1));
    1032:	86 2f       	mov	r24, r22
    1034:	86 95       	lsr	r24
    1036:	a8 2f       	mov	r26, r24
    1038:	bb 27       	eor	r27, r27
    103a:	a3 59       	subi	r26, 0x93	; 147
    103c:	bd 4f       	sbci	r27, 0xFD	; 253

	if (Byte != 0xFF)
    103e:	ef 3f       	cpi	r30, 0xFF	; 255
    1040:	39 f0       	breq	.+14     	; 0x1050 <LCD_WriteChar+0x24>
	  SegData = pgm_read_word(&LCD_SegTable[Byte]);	
    1042:	ff 27       	eor	r31, r31
    1044:	ee 0f       	add	r30, r30
    1046:	ff 1f       	adc	r31, r31
    1048:	e4 50       	subi	r30, 0x04	; 4
    104a:	fd 4f       	sbci	r31, 0xFD	; 253
    104c:	25 91       	lpm	r18, Z+
    104e:	34 91       	lpm	r19, Z
    1050:	77 27       	eor	r23, r23
    1052:	61 70       	andi	r22, 0x01	; 1
    1054:	70 70       	andi	r23, 0x00	; 0
    1056:	43 e0       	ldi	r20, 0x03	; 3

	for (uint8_t BNib = 0; BNib < 4; BNib++)
	{
		uint8_t Mask          = 0xF0;
    1058:	50 ef       	ldi	r21, 0xF0	; 240
		uint8_t MaskedSegData = (SegData & 0x0000F);
    105a:	92 2f       	mov	r25, r18
    105c:	9f 70       	andi	r25, 0x0F	; 15
	
		if (Digit & 0x01)
    105e:	61 15       	cp	r22, r1
    1060:	71 05       	cpc	r23, r1
    1062:	19 f0       	breq	.+6      	; 0x106a <LCD_WriteChar+0x3e>
		{
			Mask = 0x0F;
    1064:	5f e0       	ldi	r21, 0x0F	; 15
			MaskedSegData <<= 4;
    1066:	92 95       	swap	r25
    1068:	90 7f       	andi	r25, 0xF0	; 240
		}
		
		*BuffPtr = ((*BuffPtr & Mask) | MaskedSegData);
    106a:	8c 91       	ld	r24, X
    106c:	85 23       	and	r24, r21
    106e:	89 2b       	or	r24, r25
    1070:	8c 93       	st	X, r24

		SegData >>= 4;
    1072:	84 e0       	ldi	r24, 0x04	; 4
    1074:	36 95       	lsr	r19
    1076:	27 95       	ror	r18
    1078:	8a 95       	dec	r24
    107a:	e1 f7       	brne	.-8      	; 0x1074 <LCD_WriteChar+0x48>
		BuffPtr  += 5;
    107c:	15 96       	adiw	r26, 0x05	; 5
    107e:	41 50       	subi	r20, 0x01	; 1
    1080:	47 ff       	sbrs	r20, 7
    1082:	ea cf       	rjmp	.-44     	; 0x1058 <LCD_WriteChar+0x2c>
    1084:	08 95       	ret

00001086 <__vector_22>:
	}
}

ISR(LCD_vect, ISR_NOBLOCK)
{
    1086:	78 94       	sei
    1088:	1f 92       	push	r1
    108a:	0f 92       	push	r0
    108c:	0f b6       	in	r0, 0x3f	; 63
    108e:	0f 92       	push	r0
    1090:	11 24       	eor	r1, r1
    1092:	2f 93       	push	r18
    1094:	3f 93       	push	r19
    1096:	4f 93       	push	r20
    1098:	5f 93       	push	r21
    109a:	6f 93       	push	r22
    109c:	7f 93       	push	r23
    109e:	8f 93       	push	r24
    10a0:	9f 93       	push	r25
    10a2:	af 93       	push	r26
    10a4:	bf 93       	push	r27
    10a6:	cf 93       	push	r28
    10a8:	ef 93       	push	r30
    10aa:	ff 93       	push	r31
	if (ScrollMode)
    10ac:	80 91 81 02 	lds	r24, 0x0281
    10b0:	88 23       	and	r24, r24
    10b2:	99 f0       	breq	.+38     	; 0x10da <__vector_22+0x54>
	{
		if (DelayCount)
    10b4:	80 91 82 02 	lds	r24, 0x0282
    10b8:	88 23       	and	r24, r24
    10ba:	21 f0       	breq	.+8      	; 0x10c4 <__vector_22+0x3e>
		{
			DelayCount--;
    10bc:	81 50       	subi	r24, 0x01	; 1
    10be:	80 93 82 02 	sts	0x0282, r24
    10c2:	0b c0       	rjmp	.+22     	; 0x10da <__vector_22+0x54>
		}
		else
		{
			if (!(ScrollCount))
    10c4:	80 91 4f 02 	lds	r24, 0x024F
    10c8:	88 23       	and	r24, r24
    10ca:	21 f4       	brne	.+8      	; 0x10d4 <__vector_22+0x4e>
			  UpdateLCD = TRUE;
    10cc:	81 e0       	ldi	r24, 0x01	; 1
    10ce:	80 93 6c 02 	sts	0x026C, r24
    10d2:	03 c0       	rjmp	.+6      	; 0x10da <__vector_22+0x54>
			else
			  ScrollCount--;
    10d4:	81 50       	subi	r24, 0x01	; 1
    10d6:	80 93 4f 02 	sts	0x024F, r24
		}
	}

	if (UpdateLCD)
    10da:	80 91 6c 02 	lds	r24, 0x026C
    10de:	88 23       	and	r24, r24
    10e0:	39 f1       	breq	.+78     	; 0x1130 <__vector_22+0xaa>
	{
		for (uint8_t Character = 0; Character < 6; Character++)
    10e2:	c0 e0       	ldi	r28, 0x00	; 0
		{
			uint8_t Byte = (StrStart + Character);
    10e4:	80 91 50 02 	lds	r24, 0x0250
    10e8:	8c 0f       	add	r24, r28

			if (Byte >= StrEnd)
    10ea:	90 91 4e 02 	lds	r25, 0x024E
    10ee:	e8 2f       	mov	r30, r24
    10f0:	ff 27       	eor	r31, r31
    10f2:	89 17       	cp	r24, r25
    10f4:	10 f0       	brcs	.+4      	; 0x10fa <__vector_22+0x74>
			  Byte = TextBuffer[Byte - StrEnd];
    10f6:	e9 1b       	sub	r30, r25
    10f8:	f1 09       	sbc	r31, r1
			else
			  Byte = TextBuffer[Byte];
    10fa:	ef 5a       	subi	r30, 0xAF	; 175
    10fc:	fd 4f       	sbci	r31, 0xFD	; 253
    10fe:	80 81       	ld	r24, Z
			
			LCD_WriteChar(Byte, Character);
    1100:	6c 2f       	mov	r22, r28
    1102:	0e 94 16 08 	call	0x102c <LCD_WriteChar>
    1106:	cf 5f       	subi	r28, 0xFF	; 255
    1108:	c6 30       	cpi	r28, 0x06	; 6
    110a:	60 f3       	brcs	.-40     	; 0x10e4 <__vector_22+0x5e>
		}
		
		if (StrStart++ == StrEnd)
    110c:	80 91 50 02 	lds	r24, 0x0250
    1110:	98 2f       	mov	r25, r24
    1112:	8f 5f       	subi	r24, 0xFF	; 255
    1114:	80 93 50 02 	sts	0x0250, r24
    1118:	80 91 4e 02 	lds	r24, 0x024E
    111c:	98 17       	cp	r25, r24
    111e:	19 f4       	brne	.+6      	; 0x1126 <__vector_22+0xa0>
		  StrStart = 1;
    1120:	81 e0       	ldi	r24, 0x01	; 1
    1122:	80 93 50 02 	sts	0x0250, r24
		
		ScrollCount = LCD_SCROLLCOUNT_DEFAULT;
    1126:	83 e0       	ldi	r24, 0x03	; 3
    1128:	80 93 4f 02 	sts	0x024F, r24
		UpdateLCD = FALSE;
    112c:	10 92 6c 02 	sts	0x026C, r1
    1130:	ac ee       	ldi	r26, 0xEC	; 236
    1132:	b0 e0       	ldi	r27, 0x00	; 0
    1134:	ed e6       	ldi	r30, 0x6D	; 109
    1136:	f2 e0       	ldi	r31, 0x02	; 2
    1138:	93 e1       	ldi	r25, 0x13	; 19
	}

	for (uint8_t LCDChar = 0; LCDChar < LCD_SEGBUFFER_SIZE; LCDChar++)
	  *(pLCDREG + LCDChar) = SegBuffer[LCDChar];
    113a:	81 91       	ld	r24, Z+
    113c:	8d 93       	st	X+, r24
    113e:	91 50       	subi	r25, 0x01	; 1
    1140:	97 ff       	sbrs	r25, 7
    1142:	fb cf       	rjmp	.-10     	; 0x113a <__vector_22+0xb4>
    1144:	ff 91       	pop	r31
    1146:	ef 91       	pop	r30
    1148:	cf 91       	pop	r28
    114a:	bf 91       	pop	r27
    114c:	af 91       	pop	r26
    114e:	9f 91       	pop	r25
    1150:	8f 91       	pop	r24
    1152:	7f 91       	pop	r23
    1154:	6f 91       	pop	r22
    1156:	5f 91       	pop	r21
    1158:	4f 91       	pop	r20
    115a:	3f 91       	pop	r19
    115c:	2f 91       	pop	r18
    115e:	0f 90       	pop	r0
    1160:	0f be       	out	0x3f, r0	; 63
    1162:	0f 90       	pop	r0
    1164:	1f 90       	pop	r1
    1166:	18 95       	reti

00001168 <eeprom_read_byte_169>:
#include <avr/interrupt.h>
#include "eeprom169.h"

uint8_t eeprom_read_byte_169(const uint16_t *addr)
{
    1168:	fc 01       	movw	r30, r24
	cli();
    116a:	f8 94       	cli
	/* Set up address register */
	EEAR = *addr;
    116c:	80 81       	ld	r24, Z
    116e:	91 81       	ldd	r25, Z+1	; 0x01
    1170:	92 bd       	out	0x22, r25	; 34
    1172:	81 bd       	out	0x21, r24	; 33
	/* Start eeprom read by writing EERE */
	EECR |= (1<<EERE);
    1174:	f8 9a       	sbi	0x1f, 0	; 31
	sei();
    1176:	78 94       	sei
	/* Return data from Data Register */
	return EEDR;
    1178:	80 b5       	in	r24, 0x20	; 32
}
    117a:	99 27       	eor	r25, r25
    117c:	08 95       	ret

0000117e <eeprom_write_byte_169>:

void eeprom_write_byte_169(const uint16_t *addr, uint8_t val) 
{
    117e:	1f 93       	push	r17
    1180:	cf 93       	push	r28
    1182:	df 93       	push	r29
    1184:	ec 01       	movw	r28, r24
    1186:	16 2f       	mov	r17, r22
	if(eeprom_read_byte_169(addr) == val) // Compare stored value with new value for match
    1188:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
    118c:	81 17       	cp	r24, r17
    118e:	59 f0       	breq	.+22     	; 0x11a6 <eeprom_write_byte_169+0x28>
		return; // Don't re-write the same value and waste EEPROM life

	cli();
    1190:	f8 94       	cli
	/* Set up address and Data Registers */
	EEAR = *addr;
    1192:	88 81       	ld	r24, Y
    1194:	99 81       	ldd	r25, Y+1	; 0x01
    1196:	92 bd       	out	0x22, r25	; 34
    1198:	81 bd       	out	0x21, r24	; 33
	EEDR = val;
    119a:	10 bd       	out	0x20, r17	; 32
	/* Write logical one to EEMWE */
	EECR |= (1<<EEMWE);
    119c:	fa 9a       	sbi	0x1f, 2	; 31
	/* Start eeprom write by setting EEWE */
	EECR |= (1<<EEWE);
    119e:	f9 9a       	sbi	0x1f, 1	; 31
	sei();
    11a0:	78 94       	sei
	/* Wait for completion */
	while(EECR & (1<<EEWE));
    11a2:	f9 99       	sbic	0x1f, 1	; 31
    11a4:	fe cf       	rjmp	.-4      	; 0x11a2 <eeprom_write_byte_169+0x24>
    11a6:	df 91       	pop	r29
    11a8:	cf 91       	pop	r28
    11aa:	1f 91       	pop	r17
    11ac:	08 95       	ret

000011ae <USART_Init>:
*   Purpose :       Initialize the USART
*
*****************************************************************************/
void USART_Init(unsigned int baudrate)
{
    11ae:	9c 01       	movw	r18, r24
    // Set baud rate
    UBRRH = (unsigned char)(baudrate>>8);
    11b0:	83 2f       	mov	r24, r19
    11b2:	99 27       	eor	r25, r25
    11b4:	80 93 c5 00 	sts	0x00C5, r24
    UBRRL = (unsigned char)(baudrate);
    11b8:	20 93 c4 00 	sts	0x00C4, r18

    // Double speed
	UCSRA = (USART_DOUBLESPEED << U2X);
    11bc:	82 e0       	ldi	r24, 0x02	; 2
    11be:	80 93 c0 00 	sts	0x00C0, r24

    // Enable recieve complete interrupt
	UCSRB = (1 << RXCIE);
    11c2:	80 e8       	ldi	r24, 0x80	; 128
    11c4:	80 93 c1 00 	sts	0x00C1, r24
	 
    // Async. mode, 8N1
    UCSRC = (3 << UCSZ0);
    11c8:	86 e0       	ldi	r24, 0x06	; 6
    11ca:	80 93 c2 00 	sts	0x00C2, r24
	 
	 // Initalise ringbuffer
	BUFF_InitialiseBuffer();
    11ce:	0e 94 c4 0b 	call	0x1788 <BUFF_InitialiseBuffer>
    11d2:	08 95       	ret

000011d4 <USART_Tx>:
}

/*****************************************************************************
*
*   Function name : Usart_Tx
*
*   Returns :       None
*
*   Parameters :    char data: byte to send
*
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_Tx(char data)
{
    11d4:	98 2f       	mov	r25, r24
    while (!(UCSRA & (1<<UDRE)));
    11d6:	80 91 c0 00 	lds	r24, 0x00C0
    11da:	85 ff       	sbrs	r24, 5
    11dc:	fc cf       	rjmp	.-8      	; 0x11d6 <USART_Tx+0x2>
    UDR = data;
    11de:	90 93 c6 00 	sts	0x00C6, r25
    11e2:	08 95       	ret

000011e4 <USART_TxString>:
}

/*****************************************************************************
*
*   Function name : Usart_Tx
*
*   Returns :       None
*
*   Parameters :    char data: byte to send
*
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_TxString(char *data)
{
    11e4:	cf 93       	push	r28
    11e6:	df 93       	push	r29
    11e8:	ec 01       	movw	r28, r24
	while (*data != '\0')
		USART_Tx(*data++);
    11ea:	88 81       	ld	r24, Y
    11ec:	88 23       	and	r24, r24
    11ee:	31 f0       	breq	.+12     	; 0x11fc <USART_TxString+0x18>
    11f0:	89 91       	ld	r24, Y+
    11f2:	0e 94 ea 08 	call	0x11d4 <USART_Tx>
    11f6:	88 81       	ld	r24, Y
    11f8:	88 23       	and	r24, r24
    11fa:	d1 f7       	brne	.-12     	; 0x11f0 <USART_TxString+0xc>
    11fc:	df 91       	pop	r29
    11fe:	cf 91       	pop	r28
    1200:	08 95       	ret

00001202 <USART_Rx>:
}

/*****************************************************************************
*
*   Function name : Usart_Rx
*
*   Returns :       char: byte received
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART
*
*****************************************************************************/
char USART_Rx(void)
{
    while (!(BuffElements) && !(TimeOut)) {};
    1202:	80 91 d1 02 	lds	r24, 0x02D1
    1206:	88 23       	and	r24, r24
    1208:	21 f4       	brne	.+8      	; 0x1212 <USART_Rx+0x10>
    120a:	80 91 2a 01 	lds	r24, 0x012A
    120e:	88 23       	and	r24, r24
    1210:	c1 f3       	breq	.-16     	; 0x1202 <USART_Rx>
    return BUFF_GetBuffByte();
    1212:	0e 94 fa 0b 	call	0x17f4 <BUFF_GetBuffByte>
}
    1216:	99 27       	eor	r25, r25
    1218:	08 95       	ret

0000121a <__vector_13>:

/*****************************************************************************
*
*   Function name : Usart_Rx Interrupt
*
*   Returns :       N/A
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART and stores it into the buffer
*
*****************************************************************************/

ISR(USART0_RX_vect, ISR_BLOCK)
{
    121a:	1f 92       	push	r1
    121c:	0f 92       	push	r0
    121e:	0f b6       	in	r0, 0x3f	; 63
    1220:	0f 92       	push	r0
    1222:	11 24       	eor	r1, r1
    1224:	2f 93       	push	r18
    1226:	3f 93       	push	r19
    1228:	4f 93       	push	r20
    122a:	5f 93       	push	r21
    122c:	6f 93       	push	r22
    122e:	7f 93       	push	r23
    1230:	8f 93       	push	r24
    1232:	9f 93       	push	r25
    1234:	af 93       	push	r26
    1236:	bf 93       	push	r27
    1238:	ef 93       	push	r30
    123a:	ff 93       	push	r31
	BUFF_StoreBuffByte(UDR);
    123c:	80 91 c6 00 	lds	r24, 0x00C6
    1240:	0e 94 d1 0b 	call	0x17a2 <BUFF_StoreBuffByte>
    1244:	ff 91       	pop	r31
    1246:	ef 91       	pop	r30
    1248:	bf 91       	pop	r27
    124a:	af 91       	pop	r26
    124c:	9f 91       	pop	r25
    124e:	8f 91       	pop	r24
    1250:	7f 91       	pop	r23
    1252:	6f 91       	pop	r22
    1254:	5f 91       	pop	r21
    1256:	4f 91       	pop	r20
    1258:	3f 91       	pop	r19
    125a:	2f 91       	pop	r18
    125c:	0f 90       	pop	r0
    125e:	0f be       	out	0x3f, r0	; 63
    1260:	0f 90       	pop	r0
    1262:	1f 90       	pop	r1
    1264:	18 95       	reti

00001266 <SPI_SPIInit>:
// ======================================================================================

void SPI_SPIInit(void)
{
	PRR &= ~(1 << PRSPI);              // Enable the SPI system by clearing the power save register SPI disable bit
    1266:	80 91 64 00 	lds	r24, 0x0064
    126a:	8b 7f       	andi	r24, 0xFB	; 251
    126c:	80 93 64 00 	sts	0x0064, r24

	// Master, Sample falling edge (setup rising), Fosc/32 speed (8Mhz/32 = 125Khz)
	SPSR = (1 << SPI2X);
    1270:	81 e0       	ldi	r24, 0x01	; 1
    1272:	8d bd       	out	0x2d, r24	; 45
	SPCR = ((1 << SPE) | (1 << MSTR) | (1 << CPHA) | (1 << CPOL) | (1 << SPR1));
    1274:	8e e5       	ldi	r24, 0x5E	; 94
    1276:	8c bd       	out	0x2c, r24	; 44
    1278:	08 95       	ret

0000127a <SPI_SPITransmit>:
}

uint8_t SPI_SPITransmit(uint8_t Data)
{
	SPDR = Data;                       // Loading a byte into the register starts the transmission
    127a:	8e bd       	out	0x2e, r24	; 46
	while (!(SPSR & (1 << SPIF)));    // Wait until transmission completed
    127c:	0d b4       	in	r0, 0x2d	; 45
    127e:	07 fe       	sbrs	r0, 7
    1280:	fd cf       	rjmp	.-6      	; 0x127c <SPI_SPITransmit+0x2>
	return SPDR;
    1282:	8e b5       	in	r24, 0x2e	; 46
}
    1284:	99 27       	eor	r25, r25
    1286:	08 95       	ret

00001288 <SPI_SPITransmitWord>:

uint8_t SPI_SPITransmitWord(uint16_t Data)
{
    1288:	0f 93       	push	r16
    128a:	1f 93       	push	r17
    128c:	8c 01       	movw	r16, r24
	SPI_SPITransmit((uint8_t)(Data >> 8));
    128e:	81 2f       	mov	r24, r17
    1290:	99 27       	eor	r25, r25
    1292:	0e 94 3d 09 	call	0x127a <SPI_SPITransmit>
	return SPI_SPITransmit((uint8_t)Data);
    1296:	80 2f       	mov	r24, r16
    1298:	0e 94 3d 09 	call	0x127a <SPI_SPITransmit>
}
    129c:	99 27       	eor	r25, r25
    129e:	1f 91       	pop	r17
    12a0:	0f 91       	pop	r16
    12a2:	08 95       	ret

000012a4 <__vector_10>:
 *  in master mode. It toggles the USI clock pin, i.e. two interrupts
 *  results in one clock period on the clock pin and for the USI counter.
 */
ISR(TIMER0_COMP_vect, ISR_BLOCK)
{
    12a4:	1f 92       	push	r1
    12a6:	0f 92       	push	r0
    12a8:	0f b6       	in	r0, 0x3f	; 63
    12aa:	0f 92       	push	r0
    12ac:	11 24       	eor	r1, r1
    12ae:	8f 93       	push	r24
	USICR |= (1<<USITC);	// Toggle clock output pin.
    12b0:	80 91 b8 00 	lds	r24, 0x00B8
    12b4:	81 60       	ori	r24, 0x01	; 1
    12b6:	80 93 b8 00 	sts	0x00B8, r24
    12ba:	8f 91       	pop	r24
    12bc:	0f 90       	pop	r0
    12be:	0f be       	out	0x3f, r0	; 63
    12c0:	0f 90       	pop	r0
    12c2:	1f 90       	pop	r1
    12c4:	18 95       	reti

000012c6 <__vector_17>:
}



/*! \brief  USI Timer Overflow Interrupt handler.
 *
 *  This handler disables the compare match interrupt if in master mode.
 *  When the USI counter overflows, a byte has been transferred, and we
 *  have to stop the timer tick.
 *  For all modes the USIDR contents are stored and flags are updated.
 */
ISR(USI_OVERFLOW_vect, ISR_BLOCK)
{
    12c6:	1f 92       	push	r1
    12c8:	0f 92       	push	r0
    12ca:	0f b6       	in	r0, 0x3f	; 63
    12cc:	0f 92       	push	r0
    12ce:	11 24       	eor	r1, r1
    12d0:	8f 93       	push	r24
	// Master must now disable the compare match interrupt
	// to prevent more USI counter clocks.
	TIMSK0 &= ~(1<<OCIE0A);
    12d2:	80 91 6e 00 	lds	r24, 0x006E
    12d6:	8d 7f       	andi	r24, 0xFD	; 253
    12d8:	80 93 6e 00 	sts	0x006E, r24
	
	// Update flags and clear USI counter
	USISR = (1<<USIOIF);
    12dc:	80 e4       	ldi	r24, 0x40	; 64
    12de:	80 93 b9 00 	sts	0x00B9, r24
	USI_status.transferComplete = 1;
    12e2:	80 91 29 01 	lds	r24, 0x0129
    12e6:	81 60       	ori	r24, 0x01	; 1
    12e8:	80 93 29 01 	sts	0x0129, r24

	// Copy USIDR to buffer to prevent overwrite on next transfer.
	storedUSIDR = USIDR;
    12ec:	80 91 ba 00 	lds	r24, 0x00BA
    12f0:	80 93 28 01 	sts	0x0128, r24
    12f4:	8f 91       	pop	r24
    12f6:	0f 90       	pop	r0
    12f8:	0f be       	out	0x3f, r0	; 63
    12fa:	0f 90       	pop	r0
    12fc:	1f 90       	pop	r1
    12fe:	18 95       	reti

00001300 <USI_SPISetSpeed>:
}



/*! \brief  Initialize USI as SPI master.
 *
 *  This function sets up all pin directions and module configurations.
 *  Use this function initially or when changing from slave to master mode.
 *  Note that the stored USIDR value is cleared.
 *
 *  \param spi_mode  Required SPI mode, must be 0 or 1.
 */
void USI_SPIInitMaster(char Freq)
{
	// Configure port directions.
 	USI_DIR_REG |= (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN);  // Outputs.
	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN);                       // Inputs.
	USI_OUT_REG |= (1<<USI_DATAIN_PIN);                        // Pull-ups.
	USI_OUT_REG &= ~(1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN); // Pull-ups.
	
	// Configure USI to 3-wire master mode with overflow interrupt.
	USICR = (1<<USIOIE) | (1<<USIWM0) |
	        (1<<USICS1) | (SPI_SAMPLE_LEADING<<USICS0) |
	        (1<<USICLK);

	// Set the compare and prescaler for the requested frequency:
	USI_SPISetSpeed(Freq);
	
	// Init driver status register.
	USI_status.transferComplete = 0;
	USI_status.writeCollision   = 0;
	
	storedUSIDR = 0;
}

void USI_SPIOff( void )
{
	USI_DIR_REG &= ~((1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN));                        // Inputs.
	USI_OUT_REG &= ~((1<<USI_DATAIN_PIN)  | (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN)); // Pull-ups.
	DDRF  &= ~(1 << 6);
	PORTF &= ~(1 << 6);
	
	USI_STOPUSITIMER();
}

/*! \brief  Put one byte on bus.
 *
 *  Use this function like you would write to the SPDR register in the native SPI module.
 *  Calling this function in master mode starts a transfer, while in slave mode, a
 *  byte will be prepared for the next transfer initiated by the master device.
 *  If a transfer is in progress, this function will set the write collision flag
 *  and return without altering the data registers.
 *
 *  \returns  0 if a write collision occurred, 1 otherwise.
 */
uint8_t USI_SPITransmit( unsigned char val )
{
	// Check if transmission in progress,
	// i.e. USI counter unequal to zero.
	if( (USISR & 0x0F) != 0 ) {
		// Indicate write collision and return.
		USI_status.writeCollision = 1;
		return 0;
	}
	
	// Reinit flags.
	USI_status.transferComplete = 0;
	USI_status.writeCollision = 0;

	// Put data in USI data register.
	USIDR = val;
	
	TIFR0  |= (1<<OCF0A);  // Clear compare match flag.
	TIMSK0 |= (1<<OCIE0A); // Enable compare match interrupt.

	// Clear the timer 0 value
	TCNT0 = 0;

	do {} while( USI_status.transferComplete == 0 );

	return storedUSIDR;
}

uint8_t USI_SPITransmitWord( unsigned int val )
{
	USI_SPITransmit((uint8_t)(val >> 8));
	return USI_SPITransmit((uint8_t)val);
}

void USI_SPIToggleClock(void)
{
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);	
}

void USI_SPISetSpeed(uint8_t Freq)
{
    1300:	98 2f       	mov	r25, r24
	if (Freq == 0xFF) // Blank EEPROM, default to fastest setting
    1302:	8f 3f       	cpi	r24, 0xFF	; 255
    1304:	09 f4       	brne	.+2      	; 0x1308 <USI_SPISetSpeed+0x8>
	   Freq = SPI_SPEED_921600Hz;
    1306:	90 e0       	ldi	r25, 0x00	; 0

	for (uint8_t MatchIndex = 0; MatchIndex < USI_PRESET_SPEEDS; MatchIndex++)
    1308:	40 e0       	ldi	r20, 0x00	; 0
    130a:	20 e0       	ldi	r18, 0x00	; 0
    130c:	30 e0       	ldi	r19, 0x00	; 0
	{
		if ((pgm_read_byte(&USIPSValues[MatchIndex][0]) == Freq) || (MatchIndex == (USI_PRESET_SPEEDS - 1)))
    130e:	f9 01       	movw	r30, r18
    1310:	e8 59       	subi	r30, 0x98	; 152
    1312:	fc 4f       	sbci	r31, 0xFC	; 252
    1314:	84 91       	lpm	r24, Z
    1316:	89 17       	cp	r24, r25
    1318:	11 f0       	breq	.+4      	; 0x131e <USI_SPISetSpeed+0x1e>
    131a:	43 30       	cpi	r20, 0x03	; 3
    131c:	61 f4       	brne	.+24     	; 0x1336 <USI_SPISetSpeed+0x36>
		{
			// Init Output Compare Register.
			OCR0A = pgm_read_byte(&USIPSValues[MatchIndex][2]);
    131e:	f9 01       	movw	r30, r18
    1320:	e6 59       	subi	r30, 0x96	; 150
    1322:	fc 4f       	sbci	r31, 0xFC	; 252
    1324:	84 91       	lpm	r24, Z
    1326:	87 bd       	out	0x27, r24	; 39

			// Enable 'Clear Timer on Compare match' and set prescaler, which starts the timer
			TCCR0A = ((1<<WGM01) | pgm_read_byte(&USIPSValues[MatchIndex][1]));
    1328:	27 59       	subi	r18, 0x97	; 151
    132a:	3c 4f       	sbci	r19, 0xFC	; 252
    132c:	f9 01       	movw	r30, r18
    132e:	84 91       	lpm	r24, Z
    1330:	88 60       	ori	r24, 0x08	; 8
    1332:	84 bd       	out	0x24, r24	; 36
				
			return;
    1334:	08 95       	ret
    1336:	4f 5f       	subi	r20, 0xFF	; 255
    1338:	2d 5f       	subi	r18, 0xFD	; 253
    133a:	3f 4f       	sbci	r19, 0xFF	; 255
    133c:	44 30       	cpi	r20, 0x04	; 4
    133e:	38 f3       	brcs	.-50     	; 0x130e <USI_SPISetSpeed+0xe>
    1340:	08 95       	ret

00001342 <USI_SPIInitMaster>:
    1342:	9d b1       	in	r25, 0x0d	; 13
    1344:	90 65       	ori	r25, 0x50	; 80
    1346:	9d b9       	out	0x0d, r25	; 13
    1348:	6d 98       	cbi	0x0d, 5	; 13
    134a:	75 9a       	sbi	0x0e, 5	; 14
    134c:	76 98       	cbi	0x0e, 6	; 14
    134e:	9a e5       	ldi	r25, 0x5A	; 90
    1350:	90 93 b8 00 	sts	0x00B8, r25
    1354:	0e 94 80 09 	call	0x1300 <USI_SPISetSpeed>
    1358:	80 91 29 01 	lds	r24, 0x0129
    135c:	8e 7f       	andi	r24, 0xFE	; 254
    135e:	80 93 29 01 	sts	0x0129, r24
    1362:	80 91 29 01 	lds	r24, 0x0129
    1366:	8d 7f       	andi	r24, 0xFD	; 253
    1368:	80 93 29 01 	sts	0x0129, r24
    136c:	10 92 28 01 	sts	0x0128, r1
    1370:	08 95       	ret

00001372 <USI_SPIOff>:
    1372:	8d b1       	in	r24, 0x0d	; 13
    1374:	8f 7a       	andi	r24, 0xAF	; 175
    1376:	8d b9       	out	0x0d, r24	; 13
    1378:	8e b1       	in	r24, 0x0e	; 14
    137a:	8f 78       	andi	r24, 0x8F	; 143
    137c:	8e b9       	out	0x0e, r24	; 14
    137e:	86 98       	cbi	0x10, 6	; 16
    1380:	8e 98       	cbi	0x11, 6	; 17
    1382:	14 bc       	out	0x24, r1	; 36
    1384:	08 95       	ret

00001386 <USI_SPITransmit>:
    1386:	28 2f       	mov	r18, r24
    1388:	80 91 b9 00 	lds	r24, 0x00B9
    138c:	99 27       	eor	r25, r25
    138e:	8f 70       	andi	r24, 0x0F	; 15
    1390:	90 70       	andi	r25, 0x00	; 0
    1392:	89 2b       	or	r24, r25
    1394:	41 f0       	breq	.+16     	; 0x13a6 <USI_SPITransmit+0x20>
    1396:	80 91 29 01 	lds	r24, 0x0129
    139a:	82 60       	ori	r24, 0x02	; 2
    139c:	80 93 29 01 	sts	0x0129, r24
    13a0:	80 e0       	ldi	r24, 0x00	; 0
    13a2:	90 e0       	ldi	r25, 0x00	; 0
    13a4:	08 95       	ret
    13a6:	80 91 29 01 	lds	r24, 0x0129
    13aa:	8e 7f       	andi	r24, 0xFE	; 254
    13ac:	80 93 29 01 	sts	0x0129, r24
    13b0:	80 91 29 01 	lds	r24, 0x0129
    13b4:	8d 7f       	andi	r24, 0xFD	; 253
    13b6:	80 93 29 01 	sts	0x0129, r24
    13ba:	20 93 ba 00 	sts	0x00BA, r18
    13be:	a9 9a       	sbi	0x15, 1	; 21
    13c0:	80 91 6e 00 	lds	r24, 0x006E
    13c4:	82 60       	ori	r24, 0x02	; 2
    13c6:	80 93 6e 00 	sts	0x006E, r24
    13ca:	16 bc       	out	0x26, r1	; 38
    13cc:	80 91 29 01 	lds	r24, 0x0129
    13d0:	80 ff       	sbrs	r24, 0
    13d2:	fc cf       	rjmp	.-8      	; 0x13cc <USI_SPITransmit+0x46>
    13d4:	80 91 28 01 	lds	r24, 0x0128
    13d8:	99 27       	eor	r25, r25
    13da:	08 95       	ret

000013dc <USI_SPITransmitWord>:
    13dc:	0f 93       	push	r16
    13de:	1f 93       	push	r17
    13e0:	8c 01       	movw	r16, r24
    13e2:	81 2f       	mov	r24, r17
    13e4:	99 27       	eor	r25, r25
    13e6:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    13ea:	80 2f       	mov	r24, r16
    13ec:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    13f0:	99 27       	eor	r25, r25
    13f2:	1f 91       	pop	r17
    13f4:	0f 91       	pop	r16
    13f6:	08 95       	ret

000013f8 <USI_SPIToggleClock>:
    13f8:	81 e0       	ldi	r24, 0x01	; 1
    13fa:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    13fe:	80 91 b8 00 	lds	r24, 0x00B8
    1402:	81 60       	ori	r24, 0x01	; 1
    1404:	80 93 b8 00 	sts	0x00B8, r24
    1408:	81 e0       	ldi	r24, 0x01	; 1
    140a:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    140e:	80 91 b8 00 	lds	r24, 0x00B8
    1412:	81 60       	ori	r24, 0x01	; 1
    1414:	80 93 b8 00 	sts	0x00B8, r24
    1418:	81 e0       	ldi	r24, 0x01	; 1
    141a:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    141e:	08 95       	ret

00001420 <DF_EnableDataflash>:
	while(DF_BUSY());
}

void DF_EnableDataflash(uint8_t Enabled)
{
    1420:	90 91 83 02 	lds	r25, 0x0283
	if (Enabled == TRUE)
    1424:	81 30       	cpi	r24, 0x01	; 1
    1426:	31 f4       	brne	.+12     	; 0x1434 <DF_EnableDataflash+0x14>
	{
		if (UseExernalDF == TRUE)
    1428:	91 30       	cpi	r25, 0x01	; 1
    142a:	11 f4       	brne	.+4      	; 0x1430 <DF_EnableDataflash+0x10>
		  MAIN_ResetCSLine(MAIN_RESETCS_DFACTIVE);
    142c:	82 e0       	ldi	r24, 0x02	; 2
    142e:	05 c0       	rjmp	.+10     	; 0x143a <DF_EnableDataflash+0x1a>
		else
		  PORTB &= ~(1 << 0);
    1430:	28 98       	cbi	0x05, 0	; 5
    1432:	08 95       	ret
	}
	else
	{
		if (UseExernalDF == TRUE)
    1434:	91 30       	cpi	r25, 0x01	; 1
    1436:	21 f4       	brne	.+8      	; 0x1440 <DF_EnableDataflash+0x20>
		  MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);
    1438:	89 2f       	mov	r24, r25
    143a:	0e 94 15 03 	call	0x62a <MAIN_ResetCSLine>
    143e:	08 95       	ret
		else
		  PORTB |= (1 << 0);
    1440:	28 9a       	sbi	0x05, 0	; 5
    1442:	08 95       	ret

00001444 <DF_ReadBufferByte>:
    1444:	0f 93       	push	r16
    1446:	1f 93       	push	r17
    1448:	8c 01       	movw	r16, r24
    144a:	80 e0       	ldi	r24, 0x00	; 0
    144c:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    1450:	00 00       	nop
    1452:	81 e0       	ldi	r24, 0x01	; 1
    1454:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    1458:	e0 91 00 01 	lds	r30, 0x0100
    145c:	f0 91 01 01 	lds	r31, 0x0101
    1460:	84 e5       	ldi	r24, 0x54	; 84
    1462:	09 95       	icall
    1464:	81 2f       	mov	r24, r17
    1466:	99 27       	eor	r25, r25
    1468:	e0 91 00 01 	lds	r30, 0x0100
    146c:	f0 91 01 01 	lds	r31, 0x0101
    1470:	09 95       	icall
    1472:	e0 91 00 01 	lds	r30, 0x0100
    1476:	f0 91 01 01 	lds	r31, 0x0101
    147a:	80 2f       	mov	r24, r16
    147c:	09 95       	icall
    147e:	e0 91 00 01 	lds	r30, 0x0100
    1482:	f0 91 01 01 	lds	r31, 0x0101
    1486:	80 e0       	ldi	r24, 0x00	; 0
    1488:	09 95       	icall
    148a:	e0 91 00 01 	lds	r30, 0x0100
    148e:	f0 91 01 01 	lds	r31, 0x0101
    1492:	80 e0       	ldi	r24, 0x00	; 0
    1494:	09 95       	icall
    1496:	99 27       	eor	r25, r25
    1498:	1f 91       	pop	r17
    149a:	0f 91       	pop	r16
    149c:	08 95       	ret

0000149e <DF_ContinuousReadEnable>:
    149e:	ef 92       	push	r14
    14a0:	ff 92       	push	r15
    14a2:	0f 93       	push	r16
    14a4:	1f 93       	push	r17
    14a6:	8c 01       	movw	r16, r24
    14a8:	7b 01       	movw	r14, r22
    14aa:	80 e0       	ldi	r24, 0x00	; 0
    14ac:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    14b0:	00 00       	nop
    14b2:	81 e0       	ldi	r24, 0x01	; 1
    14b4:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    14b8:	e0 91 00 01 	lds	r30, 0x0100
    14bc:	f0 91 01 01 	lds	r31, 0x0101
    14c0:	88 e6       	ldi	r24, 0x68	; 104
    14c2:	09 95       	icall
    14c4:	8a b5       	in	r24, 0x2a	; 42
    14c6:	98 01       	movw	r18, r16
    14c8:	02 c0       	rjmp	.+4      	; 0x14ce <DF_ContinuousReadEnable+0x30>
    14ca:	36 95       	lsr	r19
    14cc:	27 95       	ror	r18
    14ce:	8a 95       	dec	r24
    14d0:	e2 f7       	brpl	.-8      	; 0x14ca <DF_ContinuousReadEnable+0x2c>
    14d2:	c9 01       	movw	r24, r18
    14d4:	e0 91 00 01 	lds	r30, 0x0100
    14d8:	f0 91 01 01 	lds	r31, 0x0101
    14dc:	09 95       	icall
    14de:	8b b5       	in	r24, 0x2b	; 43
    14e0:	02 c0       	rjmp	.+4      	; 0x14e6 <DF_ContinuousReadEnable+0x48>
    14e2:	00 0f       	add	r16, r16
    14e4:	11 1f       	adc	r17, r17
    14e6:	8a 95       	dec	r24
    14e8:	e2 f7       	brpl	.-8      	; 0x14e2 <DF_ContinuousReadEnable+0x44>
    14ea:	8f 2d       	mov	r24, r15
    14ec:	99 27       	eor	r25, r25
    14ee:	e0 91 00 01 	lds	r30, 0x0100
    14f2:	f0 91 01 01 	lds	r31, 0x0101
    14f6:	80 0f       	add	r24, r16
    14f8:	09 95       	icall
    14fa:	e0 91 00 01 	lds	r30, 0x0100
    14fe:	f0 91 01 01 	lds	r31, 0x0101
    1502:	8e 2d       	mov	r24, r14
    1504:	09 95       	icall
    1506:	03 e0       	ldi	r16, 0x03	; 3
    1508:	e0 91 00 01 	lds	r30, 0x0100
    150c:	f0 91 01 01 	lds	r31, 0x0101
    1510:	80 e0       	ldi	r24, 0x00	; 0
    1512:	09 95       	icall
    1514:	01 50       	subi	r16, 0x01	; 1
    1516:	07 ff       	sbrs	r16, 7
    1518:	f7 cf       	rjmp	.-18     	; 0x1508 <DF_ContinuousReadEnable+0x6a>
    151a:	1f 91       	pop	r17
    151c:	0f 91       	pop	r16
    151e:	ff 90       	pop	r15
    1520:	ef 90       	pop	r14
    1522:	08 95       	ret

00001524 <DF_BufferWriteEnable>:
    1524:	0f 93       	push	r16
    1526:	1f 93       	push	r17
    1528:	8c 01       	movw	r16, r24
    152a:	80 e0       	ldi	r24, 0x00	; 0
    152c:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    1530:	00 00       	nop
    1532:	81 e0       	ldi	r24, 0x01	; 1
    1534:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    1538:	e0 91 00 01 	lds	r30, 0x0100
    153c:	f0 91 01 01 	lds	r31, 0x0101
    1540:	84 e8       	ldi	r24, 0x84	; 132
    1542:	09 95       	icall
    1544:	e0 91 00 01 	lds	r30, 0x0100
    1548:	f0 91 01 01 	lds	r31, 0x0101
    154c:	80 e0       	ldi	r24, 0x00	; 0
    154e:	09 95       	icall
    1550:	81 2f       	mov	r24, r17
    1552:	99 27       	eor	r25, r25
    1554:	e0 91 00 01 	lds	r30, 0x0100
    1558:	f0 91 01 01 	lds	r31, 0x0101
    155c:	09 95       	icall
    155e:	e0 91 00 01 	lds	r30, 0x0100
    1562:	f0 91 01 01 	lds	r31, 0x0101
    1566:	80 2f       	mov	r24, r16
    1568:	09 95       	icall
    156a:	1f 91       	pop	r17
    156c:	0f 91       	pop	r16
    156e:	08 95       	ret

00001570 <DF_GetChipCharacteristics>:
    1570:	80 e0       	ldi	r24, 0x00	; 0
    1572:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    1576:	00 00       	nop
    1578:	81 e0       	ldi	r24, 0x01	; 1
    157a:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    157e:	e0 91 00 01 	lds	r30, 0x0100
    1582:	f0 91 01 01 	lds	r31, 0x0101
    1586:	87 e5       	ldi	r24, 0x57	; 87
    1588:	09 95       	icall
    158a:	e0 91 00 01 	lds	r30, 0x0100
    158e:	f0 91 01 01 	lds	r31, 0x0101
    1592:	80 e0       	ldi	r24, 0x00	; 0
    1594:	09 95       	icall
    1596:	68 2f       	mov	r22, r24
    1598:	77 27       	eor	r23, r23
    159a:	cb 01       	movw	r24, r22
    159c:	88 73       	andi	r24, 0x38	; 56
    159e:	90 70       	andi	r25, 0x00	; 0
    15a0:	33 e0       	ldi	r19, 0x03	; 3
    15a2:	95 95       	asr	r25
    15a4:	87 95       	ror	r24
    15a6:	3a 95       	dec	r19
    15a8:	e1 f7       	brne	.-8      	; 0x15a2 <DF_GetChipCharacteristics+0x32>
    15aa:	99 27       	eor	r25, r25
    15ac:	fc 01       	movw	r30, r24
    15ae:	ec 55       	subi	r30, 0x5C	; 92
    15b0:	fc 4f       	sbci	r31, 0xFC	; 252
    15b2:	44 91       	lpm	r20, Z
    15b4:	40 93 86 02 	sts	0x0286, r20
    15b8:	9c 01       	movw	r18, r24
    15ba:	28 0f       	add	r18, r24
    15bc:	39 1f       	adc	r19, r25
    15be:	f9 01       	movw	r30, r18
    15c0:	ec 56       	subi	r30, 0x6C	; 108
    15c2:	fc 4f       	sbci	r31, 0xFC	; 252
    15c4:	85 91       	lpm	r24, Z+
    15c6:	94 91       	lpm	r25, Z
    15c8:	90 93 88 02 	sts	0x0288, r25
    15cc:	80 93 87 02 	sts	0x0287, r24
    15d0:	f9 01       	movw	r30, r18
    15d2:	ec 57       	subi	r30, 0x7C	; 124
    15d4:	fc 4f       	sbci	r31, 0xFC	; 252
    15d6:	85 91       	lpm	r24, Z+
    15d8:	94 91       	lpm	r25, Z
    15da:	90 93 8a 02 	sts	0x028A, r25
    15de:	80 93 89 02 	sts	0x0289, r24
    15e2:	80 e1       	ldi	r24, 0x10	; 16
    15e4:	84 1b       	sub	r24, r20
    15e6:	8a bd       	out	0x2a, r24	; 42
    15e8:	48 50       	subi	r20, 0x08	; 8
    15ea:	4b bd       	out	0x2b, r20	; 43
    15ec:	cb 01       	movw	r24, r22
    15ee:	08 95       	ret

000015f0 <DF_ErasePage>:
    15f0:	0f 93       	push	r16
    15f2:	1f 93       	push	r17
    15f4:	8c 01       	movw	r16, r24
    15f6:	80 e0       	ldi	r24, 0x00	; 0
    15f8:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    15fc:	00 00       	nop
    15fe:	81 e0       	ldi	r24, 0x01	; 1
    1600:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    1604:	e0 91 00 01 	lds	r30, 0x0100
    1608:	f0 91 01 01 	lds	r31, 0x0101
    160c:	81 e8       	ldi	r24, 0x81	; 129
    160e:	09 95       	icall
    1610:	8a b5       	in	r24, 0x2a	; 42
    1612:	98 01       	movw	r18, r16
    1614:	02 c0       	rjmp	.+4      	; 0x161a <DF_ErasePage+0x2a>
    1616:	36 95       	lsr	r19
    1618:	27 95       	ror	r18
    161a:	8a 95       	dec	r24
    161c:	e2 f7       	brpl	.-8      	; 0x1616 <DF_ErasePage+0x26>
    161e:	c9 01       	movw	r24, r18
    1620:	e0 91 00 01 	lds	r30, 0x0100
    1624:	f0 91 01 01 	lds	r31, 0x0101
    1628:	09 95       	icall
    162a:	8b b5       	in	r24, 0x2b	; 43
    162c:	02 c0       	rjmp	.+4      	; 0x1632 <DF_ErasePage+0x42>
    162e:	00 0f       	add	r16, r16
    1630:	11 1f       	adc	r17, r17
    1632:	8a 95       	dec	r24
    1634:	e2 f7       	brpl	.-8      	; 0x162e <DF_ErasePage+0x3e>
    1636:	e0 91 00 01 	lds	r30, 0x0100
    163a:	f0 91 01 01 	lds	r31, 0x0101
    163e:	80 2f       	mov	r24, r16
    1640:	09 95       	icall
    1642:	e0 91 00 01 	lds	r30, 0x0100
    1646:	f0 91 01 01 	lds	r31, 0x0101
    164a:	80 e0       	ldi	r24, 0x00	; 0
    164c:	09 95       	icall
    164e:	80 e0       	ldi	r24, 0x00	; 0
    1650:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    1654:	00 00       	nop
    1656:	81 e0       	ldi	r24, 0x01	; 1
    1658:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    165c:	0e 94 b8 0a 	call	0x1570 <DF_GetChipCharacteristics>
    1660:	88 23       	and	r24, r24
    1662:	e4 f7       	brge	.-8      	; 0x165c <DF_ErasePage+0x6c>
    1664:	1f 91       	pop	r17
    1666:	0f 91       	pop	r16
    1668:	08 95       	ret

0000166a <DF_CopyFlashPageToBuffer>:
    166a:	0f 93       	push	r16
    166c:	1f 93       	push	r17
    166e:	8c 01       	movw	r16, r24
    1670:	80 e0       	ldi	r24, 0x00	; 0
    1672:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    1676:	00 00       	nop
    1678:	81 e0       	ldi	r24, 0x01	; 1
    167a:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    167e:	e0 91 00 01 	lds	r30, 0x0100
    1682:	f0 91 01 01 	lds	r31, 0x0101
    1686:	83 e5       	ldi	r24, 0x53	; 83
    1688:	09 95       	icall
    168a:	8a b5       	in	r24, 0x2a	; 42
    168c:	98 01       	movw	r18, r16
    168e:	02 c0       	rjmp	.+4      	; 0x1694 <DF_CopyFlashPageToBuffer+0x2a>
    1690:	36 95       	lsr	r19
    1692:	27 95       	ror	r18
    1694:	8a 95       	dec	r24
    1696:	e2 f7       	brpl	.-8      	; 0x1690 <DF_CopyFlashPageToBuffer+0x26>
    1698:	c9 01       	movw	r24, r18
    169a:	e0 91 00 01 	lds	r30, 0x0100
    169e:	f0 91 01 01 	lds	r31, 0x0101
    16a2:	09 95       	icall
    16a4:	8b b5       	in	r24, 0x2b	; 43
    16a6:	02 c0       	rjmp	.+4      	; 0x16ac <DF_CopyFlashPageToBuffer+0x42>
    16a8:	00 0f       	add	r16, r16
    16aa:	11 1f       	adc	r17, r17
    16ac:	8a 95       	dec	r24
    16ae:	e2 f7       	brpl	.-8      	; 0x16a8 <DF_CopyFlashPageToBuffer+0x3e>
    16b0:	e0 91 00 01 	lds	r30, 0x0100
    16b4:	f0 91 01 01 	lds	r31, 0x0101
    16b8:	80 2f       	mov	r24, r16
    16ba:	09 95       	icall
    16bc:	e0 91 00 01 	lds	r30, 0x0100
    16c0:	f0 91 01 01 	lds	r31, 0x0101
    16c4:	80 e0       	ldi	r24, 0x00	; 0
    16c6:	09 95       	icall
    16c8:	80 e0       	ldi	r24, 0x00	; 0
    16ca:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    16ce:	00 00       	nop
    16d0:	81 e0       	ldi	r24, 0x01	; 1
    16d2:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    16d6:	0e 94 b8 0a 	call	0x1570 <DF_GetChipCharacteristics>
    16da:	88 23       	and	r24, r24
    16dc:	e4 f7       	brge	.-8      	; 0x16d6 <DF_CopyFlashPageToBuffer+0x6c>
    16de:	1f 91       	pop	r17
    16e0:	0f 91       	pop	r16
    16e2:	08 95       	ret

000016e4 <DF_CopyBufferToFlashPage>:
    16e4:	0f 93       	push	r16
    16e6:	1f 93       	push	r17
    16e8:	8c 01       	movw	r16, r24
    16ea:	80 e0       	ldi	r24, 0x00	; 0
    16ec:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    16f0:	00 00       	nop
    16f2:	81 e0       	ldi	r24, 0x01	; 1
    16f4:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    16f8:	e0 91 00 01 	lds	r30, 0x0100
    16fc:	f0 91 01 01 	lds	r31, 0x0101
    1700:	83 e8       	ldi	r24, 0x83	; 131
    1702:	09 95       	icall
    1704:	8a b5       	in	r24, 0x2a	; 42
    1706:	98 01       	movw	r18, r16
    1708:	02 c0       	rjmp	.+4      	; 0x170e <DF_CopyBufferToFlashPage+0x2a>
    170a:	36 95       	lsr	r19
    170c:	27 95       	ror	r18
    170e:	8a 95       	dec	r24
    1710:	e2 f7       	brpl	.-8      	; 0x170a <DF_CopyBufferToFlashPage+0x26>
    1712:	c9 01       	movw	r24, r18
    1714:	e0 91 00 01 	lds	r30, 0x0100
    1718:	f0 91 01 01 	lds	r31, 0x0101
    171c:	09 95       	icall
    171e:	8b b5       	in	r24, 0x2b	; 43
    1720:	02 c0       	rjmp	.+4      	; 0x1726 <DF_CopyBufferToFlashPage+0x42>
    1722:	00 0f       	add	r16, r16
    1724:	11 1f       	adc	r17, r17
    1726:	8a 95       	dec	r24
    1728:	e2 f7       	brpl	.-8      	; 0x1722 <DF_CopyBufferToFlashPage+0x3e>
    172a:	e0 91 00 01 	lds	r30, 0x0100
    172e:	f0 91 01 01 	lds	r31, 0x0101
    1732:	80 2f       	mov	r24, r16
    1734:	09 95       	icall
    1736:	e0 91 00 01 	lds	r30, 0x0100
    173a:	f0 91 01 01 	lds	r31, 0x0101
    173e:	80 e0       	ldi	r24, 0x00	; 0
    1740:	09 95       	icall
    1742:	80 e0       	ldi	r24, 0x00	; 0
    1744:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    1748:	00 00       	nop
    174a:	81 e0       	ldi	r24, 0x01	; 1
    174c:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    1750:	0e 94 b8 0a 	call	0x1570 <DF_GetChipCharacteristics>
    1754:	88 23       	and	r24, r24
    1756:	e4 f7       	brge	.-8      	; 0x1750 <DF_CopyBufferToFlashPage+0x6c>
    1758:	1f 91       	pop	r17
    175a:	0f 91       	pop	r16
    175c:	08 95       	ret

0000175e <DF_CheckCorrectOnboardChip>:
    175e:	0e 94 b8 0a 	call	0x1570 <DF_GetChipCharacteristics>
    1762:	80 91 86 02 	lds	r24, 0x0286
    1766:	89 30       	cpi	r24, 0x09	; 9
    1768:	61 f0       	breq	.+24     	; 0x1782 <DF_CheckCorrectOnboardChip+0x24>
    176a:	80 91 64 00 	lds	r24, 0x0064
    176e:	84 60       	ori	r24, 0x04	; 4
    1770:	80 93 64 00 	sts	0x0064, r24
    1774:	84 e7       	ldi	r24, 0x74	; 116
    1776:	93 e0       	ldi	r25, 0x03	; 3
    1778:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
    177c:	80 e0       	ldi	r24, 0x00	; 0
    177e:	90 e0       	ldi	r25, 0x00	; 0
    1780:	08 95       	ret
    1782:	81 e0       	ldi	r24, 0x01	; 1
    1784:	90 e0       	ldi	r25, 0x00	; 0
    1786:	08 95       	ret

00001788 <BUFF_InitialiseBuffer>:

// Routines:
void BUFF_InitialiseBuffer(void)
{
	StoreLoc    = (BuffType*)&RingBuffer[0]; // Set up the IN pointer to the start of the buffer
    1788:	8d e8       	ldi	r24, 0x8D	; 141
    178a:	92 e0       	ldi	r25, 0x02	; 2
    178c:	90 93 ce 02 	sts	0x02CE, r25
    1790:	80 93 cd 02 	sts	0x02CD, r24
	RetrieveLoc = (BuffType*)&RingBuffer[0]; // Set up the OUT pointer to the start of the buffer
    1794:	90 93 d0 02 	sts	0x02D0, r25
    1798:	80 93 cf 02 	sts	0x02CF, r24

	BuffElements = 0;                     // Reset the buffer elements counter
    179c:	10 92 d1 02 	sts	0x02D1, r1
    17a0:	08 95       	ret

000017a2 <BUFF_StoreBuffByte>:
}

void BUFF_StoreBuffByte(BuffType DataToStore)
{
    17a2:	98 2f       	mov	r25, r24
	if (BuffElements == BuffLen)          // Buffer full
    17a4:	80 91 d1 02 	lds	r24, 0x02D1
    17a8:	80 34       	cpi	r24, 0x40	; 64
    17aa:	29 f4       	brne	.+10     	; 0x17b6 <BUFF_StoreBuffByte+0x14>
	{
		MAIN_ShowError(PSTR("BUFF OVERFLOW"));
    17ac:	8c ea       	ldi	r24, 0xAC	; 172
    17ae:	93 e0       	ldi	r25, 0x03	; 3
    17b0:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
		return;
    17b4:	08 95       	ret
	}
		
	*StoreLoc = DataToStore;              // Store the data
    17b6:	e0 91 cd 02 	lds	r30, 0x02CD
    17ba:	f0 91 ce 02 	lds	r31, 0x02CE
    17be:	90 83       	st	Z, r25

	StoreLoc++;                           // Increment the IN pointer to the next element
    17c0:	40 91 cd 02 	lds	r20, 0x02CD
    17c4:	50 91 ce 02 	lds	r21, 0x02CE
    17c8:	9a 01       	movw	r18, r20
    17ca:	2f 5f       	subi	r18, 0xFF	; 255
    17cc:	3f 4f       	sbci	r19, 0xFF	; 255
    17ce:	30 93 ce 02 	sts	0x02CE, r19
    17d2:	20 93 cd 02 	sts	0x02CD, r18
	BuffElements++;                       // Increment the total elements variable
    17d6:	80 91 d1 02 	lds	r24, 0x02D1
    17da:	8f 5f       	subi	r24, 0xFF	; 255
    17dc:	80 93 d1 02 	sts	0x02D1, r24

	if (StoreLoc == (BuffType*)&RingBuffer[BuffLen])
    17e0:	2d 5c       	subi	r18, 0xCD	; 205
    17e2:	32 40       	sbci	r19, 0x02	; 2
    17e4:	31 f4       	brne	.+12     	; 0x17f2 <BUFF_StoreBuffByte+0x50>
		StoreLoc = (BuffType*)&RingBuffer[0]; // Wrap pointer if end of array reached
    17e6:	4f 53       	subi	r20, 0x3F	; 63
    17e8:	50 40       	sbci	r21, 0x00	; 0
    17ea:	50 93 ce 02 	sts	0x02CE, r21
    17ee:	40 93 cd 02 	sts	0x02CD, r20
    17f2:	08 95       	ret

000017f4 <BUFF_GetBuffByte>:
}	

BuffType BUFF_GetBuffByte(void)
{
	if (!(BuffElements))                  // No elements in the buffer
    17f4:	80 91 d1 02 	lds	r24, 0x02D1
    17f8:	88 23       	and	r24, r24
    17fa:	19 f4       	brne	.+6      	; 0x1802 <BUFF_GetBuffByte+0xe>
		return 0;
    17fc:	80 e0       	ldi	r24, 0x00	; 0
    17fe:	90 e0       	ldi	r25, 0x00	; 0
    1800:	08 95       	ret

	BuffType RetrievedData = *RetrieveLoc; // Grab the stored byte into a temp variable
    1802:	20 91 cf 02 	lds	r18, 0x02CF
    1806:	30 91 d0 02 	lds	r19, 0x02D0
    180a:	f9 01       	movw	r30, r18
    180c:	91 91       	ld	r25, Z+

	RetrieveLoc++;                         // Increment the OUT pointer to the next element if flag set
    180e:	f0 93 d0 02 	sts	0x02D0, r31
    1812:	e0 93 cf 02 	sts	0x02CF, r30
	BuffElements--;                        // Decrement the total elements variable
    1816:	80 91 d1 02 	lds	r24, 0x02D1
    181a:	81 50       	subi	r24, 0x01	; 1
    181c:	80 93 d1 02 	sts	0x02D1, r24
	
	if (RetrieveLoc == (BuffType*)&RingBuffer[BuffLen])
    1820:	ed 5c       	subi	r30, 0xCD	; 205
    1822:	f2 40       	sbci	r31, 0x02	; 2
    1824:	31 f4       	brne	.+12     	; 0x1832 <BUFF_GetBuffByte+0x3e>
		RetrieveLoc = (BuffType*)&RingBuffer[0]; // Wrap pointer if end of array reached
    1826:	2f 53       	subi	r18, 0x3F	; 63
    1828:	30 40       	sbci	r19, 0x00	; 0
    182a:	30 93 d0 02 	sts	0x02D0, r19
    182e:	20 93 cf 02 	sts	0x02CF, r18
		
	return RetrievedData;                 // Return the retrieved data
    1832:	89 2f       	mov	r24, r25
    1834:	99 27       	eor	r25, r25
}
    1836:	08 95       	ret

00001838 <__vector_9>:
// ======================================================================================

// Timeout = ((F_CPU / 64) / (65535 * TIMEOUT_TICKSBEFORETIMEOUT)) per second
ISR(TIMER1_OVF_vect, ISR_NOBLOCK)
{
    1838:	78 94       	sei
    183a:	1f 92       	push	r1
    183c:	0f 92       	push	r0
    183e:	0f b6       	in	r0, 0x3f	; 63
    1840:	0f 92       	push	r0
    1842:	11 24       	eor	r1, r1
    1844:	8f 93       	push	r24
	if (Ticks++ == TIMEOUT_TICKSBEFORETIMEOUT)
    1846:	80 91 2b 01 	lds	r24, 0x012B
    184a:	8f 5f       	subi	r24, 0xFF	; 255
    184c:	80 93 2b 01 	sts	0x012B, r24
    1850:	80 91 2b 01 	lds	r24, 0x012B
    1854:	87 30       	cpi	r24, 0x07	; 7
    1856:	29 f4       	brne	.+10     	; 0x1862 <__vector_9+0x2a>
	{
	   Ticks   = 0;
    1858:	10 92 2b 01 	sts	0x012B, r1
	   TimeOut = TRUE;
    185c:	81 e0       	ldi	r24, 0x01	; 1
    185e:	80 93 2a 01 	sts	0x012A, r24
    1862:	8f 91       	pop	r24
    1864:	0f 90       	pop	r0
    1866:	0f be       	out	0x3f, r0	; 63
    1868:	0f 90       	pop	r0
    186a:	1f 90       	pop	r1
    186c:	18 95       	reti

0000186e <TIMEOUT_SetupTimeoutTimer>:
	}
}

// ======================================================================================

void TIMEOUT_SetupTimeoutTimer(void)
{
	TCCR1A = 0;
    186e:	10 92 80 00 	sts	0x0080, r1
	TIMEOUT_TIMER_OFF();
    1872:	10 92 81 00 	sts	0x0081, r1
    1876:	10 92 2b 01 	sts	0x012B, r1
    187a:	10 92 85 00 	sts	0x0085, r1
    187e:	10 92 84 00 	sts	0x0084, r1
	TCCR1C = 0;
    1882:	10 92 82 00 	sts	0x0082, r1
	
	TIMSK1 = (1 << TOIE1); // Turn timer 1 overflow interrupt on
    1886:	81 e0       	ldi	r24, 0x01	; 1
    1888:	80 93 6f 00 	sts	0x006F, r24
    188c:	08 95       	ret

0000188e <PD_SetupDFAddressCounters>:
}

void PD_SetupDFAddressCounters(void)
{
	uint32_t StartAddress = CurrAddress;
    188e:	20 91 2d 01 	lds	r18, 0x012D
    1892:	30 91 2e 01 	lds	r19, 0x012E
    1896:	40 91 2f 01 	lds	r20, 0x012F
    189a:	50 91 30 01 	lds	r21, 0x0130

	CurrPageAddress = 0;
    189e:	10 92 8c 02 	sts	0x028C, r1
    18a2:	10 92 8b 02 	sts	0x028B, r1

	while (StartAddress > DataflashInfo.PageSize)      // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DataflashInfo.PageSize;         // Subtract one page's worth of bytes from the desired address
		CurrPageAddress++;
    18a6:	80 91 87 02 	lds	r24, 0x0287
    18aa:	90 91 88 02 	lds	r25, 0x0288
    18ae:	aa 27       	eor	r26, r26
    18b0:	bb 27       	eor	r27, r27
    18b2:	82 17       	cp	r24, r18
    18b4:	93 07       	cpc	r25, r19
    18b6:	a4 07       	cpc	r26, r20
    18b8:	b5 07       	cpc	r27, r21
    18ba:	88 f4       	brcc	.+34     	; 0x18de <PD_SetupDFAddressCounters+0x50>
    18bc:	60 e0       	ldi	r22, 0x00	; 0
    18be:	70 e0       	ldi	r23, 0x00	; 0
    18c0:	28 1b       	sub	r18, r24
    18c2:	39 0b       	sbc	r19, r25
    18c4:	4a 0b       	sbc	r20, r26
    18c6:	5b 0b       	sbc	r21, r27
    18c8:	6f 5f       	subi	r22, 0xFF	; 255
    18ca:	7f 4f       	sbci	r23, 0xFF	; 255
    18cc:	82 17       	cp	r24, r18
    18ce:	93 07       	cpc	r25, r19
    18d0:	a4 07       	cpc	r26, r20
    18d2:	b5 07       	cpc	r27, r21
    18d4:	a8 f3       	brcs	.-22     	; 0x18c0 <PD_SetupDFAddressCounters+0x32>
    18d6:	70 93 8c 02 	sts	0x028C, r23
    18da:	60 93 8b 02 	sts	0x028B, r22
	}
	
	CurrBuffByte = (uint16_t)StartAddress;              // The buffer byte is the remainder
    18de:	30 93 85 02 	sts	0x0285, r19
    18e2:	20 93 84 02 	sts	0x0284, r18
    18e6:	08 95       	ret

000018e8 <DF_StoreDataflashByte>:
}

void DF_StoreDataflashByte(uint8_t Data)
{
    18e8:	cf 93       	push	r28
    18ea:	c8 2f       	mov	r28, r24
	if (CurrBuffByte == DataflashInfo.PageSize)
    18ec:	20 91 84 02 	lds	r18, 0x0284
    18f0:	30 91 85 02 	lds	r19, 0x0285
    18f4:	80 91 87 02 	lds	r24, 0x0287
    18f8:	90 91 88 02 	lds	r25, 0x0288
    18fc:	28 17       	cp	r18, r24
    18fe:	39 07       	cpc	r19, r25
    1900:	a9 f4       	brne	.+42     	; 0x192c <DF_StoreDataflashByte+0x44>
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
    1902:	80 91 8b 02 	lds	r24, 0x028B
    1906:	90 91 8c 02 	lds	r25, 0x028C
    190a:	9c 01       	movw	r18, r24
    190c:	01 96       	adiw	r24, 0x01	; 1
    190e:	90 93 8c 02 	sts	0x028C, r25
    1912:	80 93 8b 02 	sts	0x028B, r24
    1916:	c9 01       	movw	r24, r18
    1918:	0e 94 72 0b 	call	0x16e4 <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    191c:	80 e0       	ldi	r24, 0x00	; 0
    191e:	90 e0       	ldi	r25, 0x00	; 0
    1920:	0e 94 92 0a 	call	0x1524 <DF_BufferWriteEnable>
		CurrBuffByte = 0;
    1924:	10 92 85 02 	sts	0x0285, r1
    1928:	10 92 84 02 	sts	0x0284, r1
	}
	
	USI_SPITransmit(Data);                                 // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    192c:	8c 2f       	mov	r24, r28
    192e:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
	CurrBuffByte++;
    1932:	80 91 84 02 	lds	r24, 0x0284
    1936:	90 91 85 02 	lds	r25, 0x0285
    193a:	01 96       	adiw	r24, 0x01	; 1
    193c:	90 93 85 02 	sts	0x0285, r25
    1940:	80 93 84 02 	sts	0x0284, r24
    1944:	cf 91       	pop	r28
    1946:	08 95       	ret

00001948 <PD_InterpretAVRISPPacket>:
    1948:	ef 92       	push	r14
    194a:	ff 92       	push	r15
    194c:	0f 93       	push	r16
    194e:	1f 93       	push	r17
    1950:	cf 93       	push	r28
    1952:	df 93       	push	r29
    1954:	80 91 36 01 	lds	r24, 0x0136
    1958:	99 27       	eor	r25, r25
    195a:	86 31       	cpi	r24, 0x16	; 22
    195c:	91 05       	cpc	r25, r1
    195e:	09 f4       	brne	.+2      	; 0x1962 <PD_InterpretAVRISPPacket+0x1a>
    1960:	04 c1       	rjmp	.+520    	; 0x1b6a <PD_InterpretAVRISPPacket+0x222>
    1962:	87 31       	cpi	r24, 0x17	; 23
    1964:	91 05       	cpc	r25, r1
    1966:	b4 f4       	brge	.+44     	; 0x1994 <PD_InterpretAVRISPPacket+0x4c>
    1968:	82 31       	cpi	r24, 0x12	; 18
    196a:	91 05       	cpc	r25, r1
    196c:	09 f4       	brne	.+2      	; 0x1970 <PD_InterpretAVRISPPacket+0x28>
    196e:	69 c0       	rjmp	.+210    	; 0x1a42 <PD_InterpretAVRISPPacket+0xfa>
    1970:	83 31       	cpi	r24, 0x13	; 19
    1972:	91 05       	cpc	r25, r1
    1974:	3c f4       	brge	.+14     	; 0x1984 <PD_InterpretAVRISPPacket+0x3c>
    1976:	80 31       	cpi	r24, 0x10	; 16
    1978:	91 05       	cpc	r25, r1
    197a:	31 f1       	breq	.+76     	; 0x19c8 <PD_InterpretAVRISPPacket+0x80>
    197c:	41 97       	sbiw	r24, 0x11	; 17
    197e:	09 f4       	brne	.+2      	; 0x1982 <PD_InterpretAVRISPPacket+0x3a>
    1980:	46 c0       	rjmp	.+140    	; 0x1a0e <PD_InterpretAVRISPPacket+0xc6>
    1982:	44 c1       	rjmp	.+648    	; 0x1c0c <PD_InterpretAVRISPPacket+0x2c4>
    1984:	84 31       	cpi	r24, 0x14	; 20
    1986:	91 05       	cpc	r25, r1
    1988:	09 f4       	brne	.+2      	; 0x198c <PD_InterpretAVRISPPacket+0x44>
    198a:	90 c0       	rjmp	.+288    	; 0x1aac <PD_InterpretAVRISPPacket+0x164>
    198c:	45 97       	sbiw	r24, 0x15	; 21
    198e:	0c f0       	brlt	.+2      	; 0x1992 <PD_InterpretAVRISPPacket+0x4a>
    1990:	b3 c0       	rjmp	.+358    	; 0x1af8 <PD_InterpretAVRISPPacket+0x1b0>
    1992:	85 c0       	rjmp	.+266    	; 0x1a9e <PD_InterpretAVRISPPacket+0x156>
    1994:	89 31       	cpi	r24, 0x19	; 25
    1996:	91 05       	cpc	r25, r1
    1998:	09 f4       	brne	.+2      	; 0x199c <PD_InterpretAVRISPPacket+0x54>
    199a:	76 c0       	rjmp	.+236    	; 0x1a88 <PD_InterpretAVRISPPacket+0x140>
    199c:	8a 31       	cpi	r24, 0x1A	; 26
    199e:	91 05       	cpc	r25, r1
    19a0:	44 f4       	brge	.+16     	; 0x19b2 <PD_InterpretAVRISPPacket+0x6a>
    19a2:	87 31       	cpi	r24, 0x17	; 23
    19a4:	91 05       	cpc	r25, r1
    19a6:	09 f4       	brne	.+2      	; 0x19aa <PD_InterpretAVRISPPacket+0x62>
    19a8:	6f c0       	rjmp	.+222    	; 0x1a88 <PD_InterpretAVRISPPacket+0x140>
    19aa:	48 97       	sbiw	r24, 0x18	; 24
    19ac:	09 f4       	brne	.+2      	; 0x19b0 <PD_InterpretAVRISPPacket+0x68>
    19ae:	5e c0       	rjmp	.+188    	; 0x1a6c <PD_InterpretAVRISPPacket+0x124>
    19b0:	2d c1       	rjmp	.+602    	; 0x1c0c <PD_InterpretAVRISPPacket+0x2c4>
    19b2:	8b 31       	cpi	r24, 0x1B	; 27
    19b4:	91 05       	cpc	r25, r1
    19b6:	d9 f1       	breq	.+118    	; 0x1a2e <PD_InterpretAVRISPPacket+0xe6>
    19b8:	8b 31       	cpi	r24, 0x1B	; 27
    19ba:	91 05       	cpc	r25, r1
    19bc:	0c f4       	brge	.+2      	; 0x19c0 <PD_InterpretAVRISPPacket+0x78>
    19be:	56 c0       	rjmp	.+172    	; 0x1a6c <PD_InterpretAVRISPPacket+0x124>
    19c0:	4c 97       	sbiw	r24, 0x1c	; 28
    19c2:	09 f4       	brne	.+2      	; 0x19c6 <PD_InterpretAVRISPPacket+0x7e>
    19c4:	53 c0       	rjmp	.+166    	; 0x1a6c <PD_InterpretAVRISPPacket+0x124>
    19c6:	22 c1       	rjmp	.+580    	; 0x1c0c <PD_InterpretAVRISPPacket+0x2c4>
    19c8:	82 e0       	ldi	r24, 0x02	; 2
    19ca:	90 e0       	ldi	r25, 0x00	; 0
    19cc:	90 93 33 01 	sts	0x0133, r25
    19d0:	80 93 32 01 	sts	0x0132, r24
    19d4:	81 e0       	ldi	r24, 0x01	; 1
    19d6:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    19da:	0e 94 b8 0a 	call	0x1570 <DF_GetChipCharacteristics>
    19de:	c0 91 86 02 	lds	r28, 0x0286
    19e2:	cc 23       	and	r28, r28
    19e4:	59 f0       	breq	.+22     	; 0x19fc <PD_InterpretAVRISPPacket+0xb4>
    19e6:	8a eb       	ldi	r24, 0xBA	; 186
    19e8:	93 e0       	ldi	r25, 0x03	; 3
    19ea:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>
    19ee:	81 e0       	ldi	r24, 0x01	; 1
    19f0:	80 93 31 01 	sts	0x0131, r24
    19f4:	81 b3       	in	r24, 0x11	; 17
    19f6:	8f 7c       	andi	r24, 0xCF	; 207
    19f8:	80 62       	ori	r24, 0x20	; 32
    19fa:	17 c0       	rjmp	.+46     	; 0x1a2a <PD_InterpretAVRISPPacket+0xe2>
    19fc:	84 e7       	ldi	r24, 0x74	; 116
    19fe:	93 e0       	ldi	r25, 0x03	; 3
    1a00:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>
    1a04:	8c 2f       	mov	r24, r28
    1a06:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    1a0a:	80 ec       	ldi	r24, 0xC0	; 192
    1a0c:	06 c1       	rjmp	.+524    	; 0x1c1a <PD_InterpretAVRISPPacket+0x2d2>
    1a0e:	82 e0       	ldi	r24, 0x02	; 2
    1a10:	90 e0       	ldi	r25, 0x00	; 0
    1a12:	90 93 33 01 	sts	0x0133, r25
    1a16:	80 93 32 01 	sts	0x0132, r24
    1a1a:	10 92 31 01 	sts	0x0131, r1
    1a1e:	80 e0       	ldi	r24, 0x00	; 0
    1a20:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    1a24:	81 b3       	in	r24, 0x11	; 17
    1a26:	8f 7c       	andi	r24, 0xCF	; 207
    1a28:	80 61       	ori	r24, 0x10	; 16
    1a2a:	81 bb       	out	0x11, r24	; 17
    1a2c:	9b c0       	rjmp	.+310    	; 0x1b64 <PD_InterpretAVRISPPacket+0x21c>
    1a2e:	84 e0       	ldi	r24, 0x04	; 4
    1a30:	90 e0       	ldi	r25, 0x00	; 0
    1a32:	90 93 33 01 	sts	0x0133, r25
    1a36:	80 93 32 01 	sts	0x0132, r24
    1a3a:	10 92 37 01 	sts	0x0137, r1
    1a3e:	82 e0       	ldi	r24, 0x02	; 2
    1a40:	1e c0       	rjmp	.+60     	; 0x1a7e <PD_InterpretAVRISPPacket+0x136>
    1a42:	82 e0       	ldi	r24, 0x02	; 2
    1a44:	90 e0       	ldi	r25, 0x00	; 0
    1a46:	90 93 33 01 	sts	0x0133, r25
    1a4a:	80 93 32 01 	sts	0x0132, r24
    1a4e:	c0 e0       	ldi	r28, 0x00	; 0
    1a50:	d0 e0       	ldi	r29, 0x00	; 0
    1a52:	80 91 89 02 	lds	r24, 0x0289
    1a56:	90 91 8a 02 	lds	r25, 0x028A
    1a5a:	c8 17       	cp	r28, r24
    1a5c:	d9 07       	cpc	r29, r25
    1a5e:	08 f0       	brcs	.+2      	; 0x1a62 <PD_InterpretAVRISPPacket+0x11a>
    1a60:	81 c0       	rjmp	.+258    	; 0x1b64 <PD_InterpretAVRISPPacket+0x21c>
    1a62:	ce 01       	movw	r24, r28
    1a64:	0e 94 f8 0a 	call	0x15f0 <DF_ErasePage>
    1a68:	21 96       	adiw	r28, 0x01	; 1
    1a6a:	f3 cf       	rjmp	.-26     	; 0x1a52 <PD_InterpretAVRISPPacket+0x10a>
    1a6c:	84 e0       	ldi	r24, 0x04	; 4
    1a6e:	90 e0       	ldi	r25, 0x00	; 0
    1a70:	90 93 33 01 	sts	0x0133, r25
    1a74:	80 93 32 01 	sts	0x0132, r24
    1a78:	10 92 37 01 	sts	0x0137, r1
    1a7c:	8f ef       	ldi	r24, 0xFF	; 255
    1a7e:	80 93 38 01 	sts	0x0138, r24
    1a82:	10 92 39 01 	sts	0x0139, r1
    1a86:	cb c0       	rjmp	.+406    	; 0x1c1e <PD_InterpretAVRISPPacket+0x2d6>
    1a88:	83 e0       	ldi	r24, 0x03	; 3
    1a8a:	90 e0       	ldi	r25, 0x00	; 0
    1a8c:	90 93 33 01 	sts	0x0133, r25
    1a90:	80 93 32 01 	sts	0x0132, r24
    1a94:	10 92 37 01 	sts	0x0137, r1
    1a98:	10 92 38 01 	sts	0x0138, r1
    1a9c:	c0 c0       	rjmp	.+384    	; 0x1c1e <PD_InterpretAVRISPPacket+0x2d6>
    1a9e:	82 e0       	ldi	r24, 0x02	; 2
    1aa0:	90 e0       	ldi	r25, 0x00	; 0
    1aa2:	90 93 33 01 	sts	0x0133, r25
    1aa6:	80 93 32 01 	sts	0x0132, r24
    1aaa:	5c c0       	rjmp	.+184    	; 0x1b64 <PD_InterpretAVRISPPacket+0x21c>
    1aac:	80 91 37 01 	lds	r24, 0x0137
    1ab0:	99 27       	eor	r25, r25
    1ab2:	38 2f       	mov	r19, r24
    1ab4:	22 27       	eor	r18, r18
    1ab6:	80 91 38 01 	lds	r24, 0x0138
    1aba:	99 27       	eor	r25, r25
    1abc:	28 2b       	or	r18, r24
    1abe:	39 2b       	or	r19, r25
    1ac0:	f9 01       	movw	r30, r18
    1ac2:	33 96       	adiw	r30, 0x03	; 3
    1ac4:	f0 93 33 01 	sts	0x0133, r31
    1ac8:	e0 93 32 01 	sts	0x0132, r30
    1acc:	10 92 37 01 	sts	0x0137, r1
    1ad0:	eb 5c       	subi	r30, 0xCB	; 203
    1ad2:	fe 4f       	sbci	r31, 0xFE	; 254
    1ad4:	10 82       	st	Z, r1
    1ad6:	81 e0       	ldi	r24, 0x01	; 1
    1ad8:	90 e0       	ldi	r25, 0x00	; 0
    1ada:	28 0f       	add	r18, r24
    1adc:	39 1f       	adc	r19, r25
    1ade:	82 17       	cp	r24, r18
    1ae0:	93 07       	cpc	r25, r19
    1ae2:	08 f0       	brcs	.+2      	; 0x1ae6 <PD_InterpretAVRISPPacket+0x19e>
    1ae4:	9c c0       	rjmp	.+312    	; 0x1c1e <PD_InterpretAVRISPPacket+0x2d6>
    1ae6:	4f ef       	ldi	r20, 0xFF	; 255
    1ae8:	e7 e3       	ldi	r30, 0x37	; 55
    1aea:	f1 e0       	ldi	r31, 0x01	; 1
    1aec:	41 93       	st	Z+, r20
    1aee:	01 96       	adiw	r24, 0x01	; 1
    1af0:	82 17       	cp	r24, r18
    1af2:	93 07       	cpc	r25, r19
    1af4:	d8 f3       	brcs	.-10     	; 0x1aec <PD_InterpretAVRISPPacket+0x1a4>
    1af6:	93 c0       	rjmp	.+294    	; 0x1c1e <PD_InterpretAVRISPPacket+0x2d6>
    1af8:	0e 94 47 0c 	call	0x188e <PD_SetupDFAddressCounters>
    1afc:	80 91 8b 02 	lds	r24, 0x028B
    1b00:	90 91 8c 02 	lds	r25, 0x028C
    1b04:	0e 94 35 0b 	call	0x166a <DF_CopyFlashPageToBuffer>
    1b08:	80 91 84 02 	lds	r24, 0x0284
    1b0c:	90 91 85 02 	lds	r25, 0x0285
    1b10:	0e 94 92 0a 	call	0x1524 <DF_BufferWriteEnable>
    1b14:	80 91 37 01 	lds	r24, 0x0137
    1b18:	99 27       	eor	r25, r25
    1b1a:	d8 2f       	mov	r29, r24
    1b1c:	cc 27       	eor	r28, r28
    1b1e:	80 91 38 01 	lds	r24, 0x0138
    1b22:	99 27       	eor	r25, r25
    1b24:	c8 2b       	or	r28, r24
    1b26:	d9 2b       	or	r29, r25
    1b28:	00 e0       	ldi	r16, 0x00	; 0
    1b2a:	10 e0       	ldi	r17, 0x00	; 0
    1b2c:	0c 17       	cp	r16, r28
    1b2e:	1d 07       	cpc	r17, r29
    1b30:	c8 f4       	brcc	.+50     	; 0x1b64 <PD_InterpretAVRISPPacket+0x21c>
    1b32:	30 e4       	ldi	r19, 0x40	; 64
    1b34:	e3 2e       	mov	r14, r19
    1b36:	31 e0       	ldi	r19, 0x01	; 1
    1b38:	f3 2e       	mov	r15, r19
    1b3a:	f7 01       	movw	r30, r14
    1b3c:	81 91       	ld	r24, Z+
    1b3e:	7f 01       	movw	r14, r30
    1b40:	0e 94 74 0c 	call	0x18e8 <DF_StoreDataflashByte>
    1b44:	80 91 84 02 	lds	r24, 0x0284
    1b48:	90 91 85 02 	lds	r25, 0x0285
    1b4c:	01 96       	adiw	r24, 0x01	; 1
    1b4e:	90 93 85 02 	sts	0x0285, r25
    1b52:	80 93 84 02 	sts	0x0284, r24
    1b56:	0e 94 13 0f 	call	0x1e26 <V2P_IncrementCurrAddress>
    1b5a:	0f 5f       	subi	r16, 0xFF	; 255
    1b5c:	1f 4f       	sbci	r17, 0xFF	; 255
    1b5e:	0c 17       	cp	r16, r28
    1b60:	1d 07       	cpc	r17, r29
    1b62:	58 f3       	brcs	.-42     	; 0x1b3a <PD_InterpretAVRISPPacket+0x1f2>
    1b64:	10 92 37 01 	sts	0x0137, r1
    1b68:	5a c0       	rjmp	.+180    	; 0x1c1e <PD_InterpretAVRISPPacket+0x2d6>
    1b6a:	0e 94 47 0c 	call	0x188e <PD_SetupDFAddressCounters>
    1b6e:	80 91 8b 02 	lds	r24, 0x028B
    1b72:	90 91 8c 02 	lds	r25, 0x028C
    1b76:	0e 94 35 0b 	call	0x166a <DF_CopyFlashPageToBuffer>
    1b7a:	80 91 37 01 	lds	r24, 0x0137
    1b7e:	99 27       	eor	r25, r25
    1b80:	d8 2f       	mov	r29, r24
    1b82:	cc 27       	eor	r28, r28
    1b84:	80 91 38 01 	lds	r24, 0x0138
    1b88:	99 27       	eor	r25, r25
    1b8a:	c8 2b       	or	r28, r24
    1b8c:	d9 2b       	or	r29, r25
    1b8e:	00 e0       	ldi	r16, 0x00	; 0
    1b90:	10 e0       	ldi	r17, 0x00	; 0
    1b92:	0c 17       	cp	r16, r28
    1b94:	1d 07       	cpc	r17, r29
    1b96:	70 f5       	brcc	.+92     	; 0x1bf4 <PD_InterpretAVRISPPacket+0x2ac>
    1b98:	88 e3       	ldi	r24, 0x38	; 56
    1b9a:	e8 2e       	mov	r14, r24
    1b9c:	81 e0       	ldi	r24, 0x01	; 1
    1b9e:	f8 2e       	mov	r15, r24
    1ba0:	20 91 84 02 	lds	r18, 0x0284
    1ba4:	30 91 85 02 	lds	r19, 0x0285
    1ba8:	80 91 87 02 	lds	r24, 0x0287
    1bac:	90 91 88 02 	lds	r25, 0x0288
    1bb0:	28 17       	cp	r18, r24
    1bb2:	39 07       	cpc	r19, r25
    1bb4:	41 f4       	brne	.+16     	; 0x1bc6 <PD_InterpretAVRISPPacket+0x27e>
    1bb6:	0e 94 47 0c 	call	0x188e <PD_SetupDFAddressCounters>
    1bba:	80 91 8b 02 	lds	r24, 0x028B
    1bbe:	90 91 8c 02 	lds	r25, 0x028C
    1bc2:	0e 94 35 0b 	call	0x166a <DF_CopyFlashPageToBuffer>
    1bc6:	80 91 84 02 	lds	r24, 0x0284
    1bca:	90 91 85 02 	lds	r25, 0x0285
    1bce:	9c 01       	movw	r18, r24
    1bd0:	01 96       	adiw	r24, 0x01	; 1
    1bd2:	90 93 85 02 	sts	0x0285, r25
    1bd6:	80 93 84 02 	sts	0x0284, r24
    1bda:	c9 01       	movw	r24, r18
    1bdc:	0e 94 22 0a 	call	0x1444 <DF_ReadBufferByte>
    1be0:	f7 01       	movw	r30, r14
    1be2:	81 93       	st	Z+, r24
    1be4:	7f 01       	movw	r14, r30
    1be6:	0e 94 13 0f 	call	0x1e26 <V2P_IncrementCurrAddress>
    1bea:	0f 5f       	subi	r16, 0xFF	; 255
    1bec:	1f 4f       	sbci	r17, 0xFF	; 255
    1bee:	0c 17       	cp	r16, r28
    1bf0:	1d 07       	cpc	r17, r29
    1bf2:	b0 f2       	brcs	.-84     	; 0x1ba0 <PD_InterpretAVRISPPacket+0x258>
    1bf4:	23 96       	adiw	r28, 0x03	; 3
    1bf6:	d0 93 33 01 	sts	0x0133, r29
    1bfa:	c0 93 32 01 	sts	0x0132, r28
    1bfe:	23 97       	sbiw	r28, 0x03	; 3
    1c00:	10 92 37 01 	sts	0x0137, r1
    1c04:	ca 5c       	subi	r28, 0xCA	; 202
    1c06:	de 4f       	sbci	r29, 0xFE	; 254
    1c08:	1a 82       	std	Y+2, r1	; 0x02
    1c0a:	09 c0       	rjmp	.+18     	; 0x1c1e <PD_InterpretAVRISPPacket+0x2d6>
    1c0c:	81 e0       	ldi	r24, 0x01	; 1
    1c0e:	90 e0       	ldi	r25, 0x00	; 0
    1c10:	90 93 33 01 	sts	0x0133, r25
    1c14:	80 93 32 01 	sts	0x0132, r24
    1c18:	89 ec       	ldi	r24, 0xC9	; 201
    1c1a:	80 93 37 01 	sts	0x0137, r24
    1c1e:	0e 94 39 0e 	call	0x1c72 <V2P_SendPacket>
    1c22:	df 91       	pop	r29
    1c24:	cf 91       	pop	r28
    1c26:	1f 91       	pop	r17
    1c28:	0f 91       	pop	r16
    1c2a:	ff 90       	pop	r15
    1c2c:	ef 90       	pop	r14
    1c2e:	08 95       	ret

00001c30 <V2P_GetChecksum>:
	
	/* Checksum for the V2 protocol is comprised of an XOR of all the packet 
      bytes, including the start, sequence number, size and token bytes.    */
	
	CheckSumByte  = MESSAGE_START;
    1c30:	6b e1       	ldi	r22, 0x1B	; 27
	CheckSumByte ^= SequenceNum;
    1c32:	80 91 34 01 	lds	r24, 0x0134
    1c36:	68 27       	eor	r22, r24
	CheckSumByte ^= (uint8_t)(MessageSize >> 8);
    1c38:	20 91 32 01 	lds	r18, 0x0132
    1c3c:	30 91 33 01 	lds	r19, 0x0133
    1c40:	83 2f       	mov	r24, r19
    1c42:	99 27       	eor	r25, r25
    1c44:	68 27       	eor	r22, r24
	CheckSumByte ^= (uint8_t)(MessageSize);
    1c46:	80 91 32 01 	lds	r24, 0x0132
    1c4a:	68 27       	eor	r22, r24
	CheckSumByte ^= TOKEN;
    1c4c:	8e e0       	ldi	r24, 0x0E	; 14
    1c4e:	68 27       	eor	r22, r24
	
	for(uint16_t CByteIndex = 0; CByteIndex < MessageSize; CByteIndex++)
    1c50:	40 e0       	ldi	r20, 0x00	; 0
    1c52:	50 e0       	ldi	r21, 0x00	; 0
    1c54:	42 17       	cp	r20, r18
    1c56:	53 07       	cpc	r21, r19
    1c58:	48 f4       	brcc	.+18     	; 0x1c6c <V2P_GetChecksum+0x3c>
    1c5a:	e6 e3       	ldi	r30, 0x36	; 54
    1c5c:	f1 e0       	ldi	r31, 0x01	; 1
		CheckSumByte ^= PacketBytes[CByteIndex];
    1c5e:	81 91       	ld	r24, Z+
    1c60:	68 27       	eor	r22, r24
    1c62:	4f 5f       	subi	r20, 0xFF	; 255
    1c64:	5f 4f       	sbci	r21, 0xFF	; 255
    1c66:	42 17       	cp	r20, r18
    1c68:	53 07       	cpc	r21, r19
    1c6a:	c8 f3       	brcs	.-14     	; 0x1c5e <V2P_GetChecksum+0x2e>

	return CheckSumByte;
}
    1c6c:	86 2f       	mov	r24, r22
    1c6e:	99 27       	eor	r25, r25
    1c70:	08 95       	ret

00001c72 <V2P_SendPacket>:
    1c72:	0f 93       	push	r16
    1c74:	1f 93       	push	r17
    1c76:	cf 93       	push	r28
    1c78:	df 93       	push	r29
    1c7a:	8b e1       	ldi	r24, 0x1B	; 27
    1c7c:	0e 94 ea 08 	call	0x11d4 <USART_Tx>
    1c80:	80 91 34 01 	lds	r24, 0x0134
    1c84:	0e 94 ea 08 	call	0x11d4 <USART_Tx>
    1c88:	80 91 33 01 	lds	r24, 0x0133
    1c8c:	0e 94 ea 08 	call	0x11d4 <USART_Tx>
    1c90:	80 91 32 01 	lds	r24, 0x0132
    1c94:	0e 94 ea 08 	call	0x11d4 <USART_Tx>
    1c98:	8e e0       	ldi	r24, 0x0E	; 14
    1c9a:	0e 94 ea 08 	call	0x11d4 <USART_Tx>
    1c9e:	c0 e0       	ldi	r28, 0x00	; 0
    1ca0:	d0 e0       	ldi	r29, 0x00	; 0
    1ca2:	80 91 32 01 	lds	r24, 0x0132
    1ca6:	90 91 33 01 	lds	r25, 0x0133
    1caa:	c8 17       	cp	r28, r24
    1cac:	d9 07       	cpc	r29, r25
    1cae:	78 f4       	brcc	.+30     	; 0x1cce <V2P_SendPacket+0x5c>
    1cb0:	06 e3       	ldi	r16, 0x36	; 54
    1cb2:	11 e0       	ldi	r17, 0x01	; 1
    1cb4:	f8 01       	movw	r30, r16
    1cb6:	81 91       	ld	r24, Z+
    1cb8:	8f 01       	movw	r16, r30
    1cba:	0e 94 ea 08 	call	0x11d4 <USART_Tx>
    1cbe:	21 96       	adiw	r28, 0x01	; 1
    1cc0:	80 91 32 01 	lds	r24, 0x0132
    1cc4:	90 91 33 01 	lds	r25, 0x0133
    1cc8:	c8 17       	cp	r28, r24
    1cca:	d9 07       	cpc	r29, r25
    1ccc:	98 f3       	brcs	.-26     	; 0x1cb4 <V2P_SendPacket+0x42>
    1cce:	0e 94 18 0e 	call	0x1c30 <V2P_GetChecksum>
    1cd2:	0e 94 ea 08 	call	0x11d4 <USART_Tx>
    1cd6:	80 91 34 01 	lds	r24, 0x0134
    1cda:	90 91 35 01 	lds	r25, 0x0135
    1cde:	01 96       	adiw	r24, 0x01	; 1
    1ce0:	90 93 35 01 	sts	0x0135, r25
    1ce4:	80 93 34 01 	sts	0x0134, r24
    1ce8:	df 91       	pop	r29
    1cea:	cf 91       	pop	r28
    1cec:	1f 91       	pop	r17
    1cee:	0f 91       	pop	r16
    1cf0:	08 95       	ret

00001cf2 <V2P_GetSetParamater>:

void V2P_GetSetParamater(void)
{
	uint8_t Param_Name = PacketBytes[1];    // Save the parameter number
    1cf2:	20 91 37 01 	lds	r18, 0x0137

	MessageSize = 3;                        // Set the default response message size to 3 bytes     
    1cf6:	83 e0       	ldi	r24, 0x03	; 3
    1cf8:	90 e0       	ldi	r25, 0x00	; 0
    1cfa:	90 93 33 01 	sts	0x0133, r25
    1cfe:	80 93 32 01 	sts	0x0132, r24
	PacketBytes[1] = STATUS_CMD_OK;         // Set the default response to OK
    1d02:	10 92 37 01 	sts	0x0137, r1

	switch (Param_Name)                    // Switch based on the recieved parameter byte
    1d06:	e2 2f       	mov	r30, r18
    1d08:	ff 27       	eor	r31, r31
    1d0a:	e8 39       	cpi	r30, 0x98	; 152
    1d0c:	f1 05       	cpc	r31, r1
    1d0e:	ac f4       	brge	.+42     	; 0x1d3a <V2P_GetSetParamater+0x48>
    1d10:	e6 39       	cpi	r30, 0x96	; 150
    1d12:	f1 05       	cpc	r31, r1
    1d14:	0c f0       	brlt	.+2      	; 0x1d18 <V2P_GetSetParamater+0x26>
    1d16:	6d c0       	rjmp	.+218    	; 0x1df2 <V2P_GetSetParamater+0x100>
    1d18:	e1 38       	cpi	r30, 0x81	; 129
    1d1a:	f1 05       	cpc	r31, r1
    1d1c:	f9 f0       	breq	.+62     	; 0x1d5c <V2P_GetSetParamater+0x6a>
    1d1e:	e2 38       	cpi	r30, 0x82	; 130
    1d20:	f1 05       	cpc	r31, r1
    1d22:	24 f4       	brge	.+8      	; 0x1d2c <V2P_GetSetParamater+0x3a>
    1d24:	e0 38       	cpi	r30, 0x80	; 128
    1d26:	f1 05       	cpc	r31, r1
    1d28:	b9 f0       	breq	.+46     	; 0x1d58 <V2P_GetSetParamater+0x66>
    1d2a:	71 c0       	rjmp	.+226    	; 0x1e0e <V2P_GetSetParamater+0x11c>
    1d2c:	cf 01       	movw	r24, r30
    1d2e:	80 59       	subi	r24, 0x90	; 144
    1d30:	90 40       	sbci	r25, 0x00	; 0
    1d32:	03 97       	sbiw	r24, 0x03	; 3
    1d34:	08 f0       	brcs	.+2      	; 0x1d38 <V2P_GetSetParamater+0x46>
    1d36:	6b c0       	rjmp	.+214    	; 0x1e0e <V2P_GetSetParamater+0x11c>
    1d38:	13 c0       	rjmp	.+38     	; 0x1d60 <V2P_GetSetParamater+0x6e>
    1d3a:	ee 39       	cpi	r30, 0x9E	; 158
    1d3c:	f1 05       	cpc	r31, r1
    1d3e:	09 f4       	brne	.+2      	; 0x1d42 <V2P_GetSetParamater+0x50>
    1d40:	3d c0       	rjmp	.+122    	; 0x1dbc <V2P_GetSetParamater+0xca>
    1d42:	ef 39       	cpi	r30, 0x9F	; 159
    1d44:	f1 05       	cpc	r31, r1
    1d46:	24 f4       	brge	.+8      	; 0x1d50 <V2P_GetSetParamater+0x5e>
    1d48:	e8 39       	cpi	r30, 0x98	; 152
    1d4a:	f1 05       	cpc	r31, r1
    1d4c:	f9 f0       	breq	.+62     	; 0x1d8c <V2P_GetSetParamater+0x9a>
    1d4e:	5f c0       	rjmp	.+190    	; 0x1e0e <V2P_GetSetParamater+0x11c>
    1d50:	ef 39       	cpi	r30, 0x9F	; 159
    1d52:	f1 05       	cpc	r31, r1
    1d54:	49 f0       	breq	.+18     	; 0x1d68 <V2P_GetSetParamater+0x76>
    1d56:	5b c0       	rjmp	.+182    	; 0x1e0e <V2P_GetSetParamater+0x11c>
	{
		case PARAM_BUILD_NUMBER_LOW:
			PacketBytes[2] = VERSION_MINOR;
    1d58:	83 e0       	ldi	r24, 0x03	; 3
    1d5a:	38 c0       	rjmp	.+112    	; 0x1dcc <V2P_GetSetParamater+0xda>

			break;
		case PARAM_BUILD_NUMBER_HIGH:
			PacketBytes[2] = VERSION_MAJOR;
    1d5c:	81 e0       	ldi	r24, 0x01	; 1
    1d5e:	36 c0       	rjmp	.+108    	; 0x1dcc <V2P_GetSetParamater+0xda>

			break;
		case PARAM_HARDWARE_VERSION:
		case PARAM_SW_MAJOR:
		case PARAM_SW_MINOR:
			PacketBytes[2] = pgm_read_byte(&VersionData[Param_Name - PARAM_HARDWARE_VERSION]);
    1d60:	ea 5b       	subi	r30, 0xBA	; 186
    1d62:	fc 4f       	sbci	r31, 0xFC	; 252
    1d64:	84 91       	lpm	r24, Z
    1d66:	32 c0       	rjmp	.+100    	; 0x1dcc <V2P_GetSetParamater+0xda>

			break;
		case PARAM_CONTROLLER_INIT:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1d68:	80 91 36 01 	lds	r24, 0x0136
    1d6c:	83 30       	cpi	r24, 0x03	; 3
    1d6e:	19 f4       	brne	.+6      	; 0x1d76 <V2P_GetSetParamater+0x84>
			{
				PacketBytes[2] = Param_ControllerInit;
    1d70:	80 91 2c 01 	lds	r24, 0x012C
    1d74:	2b c0       	rjmp	.+86     	; 0x1dcc <V2P_GetSetParamater+0xda>
			}
			else
			{
				MessageSize = 2;
    1d76:	82 e0       	ldi	r24, 0x02	; 2
    1d78:	90 e0       	ldi	r25, 0x00	; 0
    1d7a:	90 93 33 01 	sts	0x0133, r25
    1d7e:	80 93 32 01 	sts	0x0132, r24
				Param_ControllerInit = PacketBytes[2];
    1d82:	80 91 38 01 	lds	r24, 0x0138
    1d86:	80 93 2c 01 	sts	0x012C, r24
			}
			
			break;
    1d8a:	4a c0       	rjmp	.+148    	; 0x1e20 <V2P_GetSetParamater+0x12e>
		case PARAM_SCK_DURATION:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1d8c:	80 91 36 01 	lds	r24, 0x0136
    1d90:	83 30       	cpi	r24, 0x03	; 3
    1d92:	19 f4       	brne	.+6      	; 0x1d9a <V2P_GetSetParamater+0xa8>
			{
				PacketBytes[2] = eeprom_read_byte_169(&Param_SCKDuration);
    1d94:	80 e2       	ldi	r24, 0x20	; 32
    1d96:	91 e0       	ldi	r25, 0x01	; 1
    1d98:	17 c0       	rjmp	.+46     	; 0x1dc8 <V2P_GetSetParamater+0xd6>
			}
			else
			{
				MessageSize = 2;
    1d9a:	82 e0       	ldi	r24, 0x02	; 2
    1d9c:	90 e0       	ldi	r25, 0x00	; 0
    1d9e:	90 93 33 01 	sts	0x0133, r25
    1da2:	80 93 32 01 	sts	0x0132, r24
				eeprom_write_byte_169(&Param_SCKDuration, PacketBytes[2]);
    1da6:	60 91 38 01 	lds	r22, 0x0138
    1daa:	80 e2       	ldi	r24, 0x20	; 32
    1dac:	91 e0       	ldi	r25, 0x01	; 1
    1dae:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
				USI_SPISetSpeed(PacketBytes[2]); // Re-Initialise the USI system with the new frequency
    1db2:	80 91 38 01 	lds	r24, 0x0138
    1db6:	0e 94 80 09 	call	0x1300 <USI_SPISetSpeed>
			}
					
			break;
    1dba:	32 c0       	rjmp	.+100    	; 0x1e20 <V2P_GetSetParamater+0x12e>
		case PARAM_RESET_POLARITY:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1dbc:	80 91 36 01 	lds	r24, 0x0136
    1dc0:	83 30       	cpi	r24, 0x03	; 3
    1dc2:	39 f4       	brne	.+14     	; 0x1dd2 <V2P_GetSetParamater+0xe0>
			{
				PacketBytes[2] = eeprom_read_byte_169(&Param_ResetPolarity);		
    1dc4:	82 e2       	ldi	r24, 0x22	; 34
    1dc6:	91 e0       	ldi	r25, 0x01	; 1
    1dc8:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
    1dcc:	80 93 38 01 	sts	0x0138, r24
    1dd0:	27 c0       	rjmp	.+78     	; 0x1e20 <V2P_GetSetParamater+0x12e>
			}
			else
			{
				MessageSize = 2;
    1dd2:	82 e0       	ldi	r24, 0x02	; 2
    1dd4:	90 e0       	ldi	r25, 0x00	; 0
    1dd6:	90 93 33 01 	sts	0x0133, r25
    1dda:	80 93 32 01 	sts	0x0132, r24
				eeprom_write_byte_169(&Param_ResetPolarity, PacketBytes[2]);
    1dde:	60 91 38 01 	lds	r22, 0x0138
    1de2:	82 e2       	ldi	r24, 0x22	; 34
    1de4:	91 e0       	ldi	r25, 0x01	; 1
    1de6:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Change takes effect immediatly
    1dea:	81 e0       	ldi	r24, 0x01	; 1
    1dec:	0e 94 15 03 	call	0x62a <MAIN_ResetCSLine>
			}
			
			break;
    1df0:	17 c0       	rjmp	.+46     	; 0x1e20 <V2P_GetSetParamater+0x12e>
		case PARAM_OSC_PSCALE:
		case PARAM_OSC_CMATCH:
			/* Despite not supporting these parameters (STK500 only), the AVR Studio programmer
			   sends them along with the SCK duration. A OK must be returned or the sequence will fail
			   and the SCK duration byte will not be sent.                                             */
		
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1df2:	80 91 36 01 	lds	r24, 0x0136
    1df6:	83 30       	cpi	r24, 0x03	; 3
    1df8:	19 f4       	brne	.+6      	; 0x1e00 <V2P_GetSetParamater+0x10e>
			{
			   PacketBytes[2] = 0;            // If the command is a read, return a 0 for both parameters
    1dfa:	10 92 38 01 	sts	0x0138, r1
    1dfe:	10 c0       	rjmp	.+32     	; 0x1e20 <V2P_GetSetParamater+0x12e>
			}
			else
			{
				MessageSize = 2;              // Otherwise just send back an OK if the command is a set		
    1e00:	82 e0       	ldi	r24, 0x02	; 2
    1e02:	90 e0       	ldi	r25, 0x00	; 0
    1e04:	90 93 33 01 	sts	0x0133, r25
    1e08:	80 93 32 01 	sts	0x0132, r24
			}
			
			break;
    1e0c:	09 c0       	rjmp	.+18     	; 0x1e20 <V2P_GetSetParamater+0x12e>
		default:                             // Unrecognised parameter
			MessageSize = 2;
    1e0e:	82 e0       	ldi	r24, 0x02	; 2
    1e10:	90 e0       	ldi	r25, 0x00	; 0
    1e12:	90 93 33 01 	sts	0x0133, r25
    1e16:	80 93 32 01 	sts	0x0132, r24
			PacketBytes[1] = STATUS_CMD_FAILED;			
    1e1a:	80 ec       	ldi	r24, 0xC0	; 192
    1e1c:	80 93 37 01 	sts	0x0137, r24
	}
	
	V2P_SendPacket();
    1e20:	0e 94 39 0e 	call	0x1c72 <V2P_SendPacket>
    1e24:	08 95       	ret

00001e26 <V2P_IncrementCurrAddress>:
}

void V2P_IncrementCurrAddress(void)
{
	// Incrementing a 32-bit unsigned variable takes a lot of code. Because much of the code is
	// not very time critical (much of it is waiting for the hardware), i've chosen to waste
	// a few extra cycles per increment and save a good 60 bytes or so of code space by putting
	// the incrmement inside a function.

	CurrAddress++;
    1e26:	80 91 2d 01 	lds	r24, 0x012D
    1e2a:	90 91 2e 01 	lds	r25, 0x012E
    1e2e:	a0 91 2f 01 	lds	r26, 0x012F
    1e32:	b0 91 30 01 	lds	r27, 0x0130
    1e36:	01 96       	adiw	r24, 0x01	; 1
    1e38:	a1 1d       	adc	r26, r1
    1e3a:	b1 1d       	adc	r27, r1
    1e3c:	80 93 2d 01 	sts	0x012D, r24
    1e40:	90 93 2e 01 	sts	0x012E, r25
    1e44:	a0 93 2f 01 	sts	0x012F, r26
    1e48:	b0 93 30 01 	sts	0x0130, r27
    1e4c:	08 95       	ret

00001e4e <V2P_CheckForExtendedAddress>:
}

void V2P_CheckForExtendedAddress(void)
{
	if (CurrAddress & (1UL << 31))                     // MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
    1e4e:	80 91 2d 01 	lds	r24, 0x012D
    1e52:	90 91 2e 01 	lds	r25, 0x012E
    1e56:	a0 91 2f 01 	lds	r26, 0x012F
    1e5a:	b0 91 30 01 	lds	r27, 0x0130
    1e5e:	b7 ff       	sbrs	r27, 7
    1e60:	1e c0       	rjmp	.+60     	; 0x1e9e <V2P_CheckForExtendedAddress+0x50>
	{
		USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);   // Load extended address command
    1e62:	8d e4       	ldi	r24, 0x4D	; 77
    1e64:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1e68:	80 e0       	ldi	r24, 0x00	; 0
    1e6a:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
		USI_SPITransmit((CurrAddress & 0x00FF0000) >> 16); // The 3rd byte of the long holds the extended address
    1e6e:	80 91 2f 01 	lds	r24, 0x012F
    1e72:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1e76:	80 e0       	ldi	r24, 0x00	; 0
    1e78:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
		
		CurrAddress &= ~(1UL << 31);                   // Clear the flag
    1e7c:	80 91 2d 01 	lds	r24, 0x012D
    1e80:	90 91 2e 01 	lds	r25, 0x012E
    1e84:	a0 91 2f 01 	lds	r26, 0x012F
    1e88:	b0 91 30 01 	lds	r27, 0x0130
    1e8c:	bf 77       	andi	r27, 0x7F	; 127
    1e8e:	80 93 2d 01 	sts	0x012D, r24
    1e92:	90 93 2e 01 	sts	0x012E, r25
    1e96:	a0 93 2f 01 	sts	0x012F, r26
    1e9a:	b0 93 30 01 	sts	0x0130, r27
    1e9e:	08 95       	ret

00001ea0 <V2P_RunStateMachine>:
    1ea0:	ef 92       	push	r14
    1ea2:	ff 92       	push	r15
    1ea4:	0f 93       	push	r16
    1ea6:	1f 93       	push	r17
    1ea8:	cf 93       	push	r28
    1eaa:	c0 e0       	ldi	r28, 0x00	; 0
    1eac:	ee 24       	eor	r14, r14
    1eae:	ff 24       	eor	r15, r15
    1eb0:	80 91 c1 00 	lds	r24, 0x00C1
    1eb4:	80 78       	andi	r24, 0x80	; 128
    1eb6:	88 61       	ori	r24, 0x18	; 24
    1eb8:	80 93 c1 00 	sts	0x00C1, r24
    1ebc:	0e 94 c4 0b 	call	0x1788 <BUFF_InitialiseBuffer>
    1ec0:	0e 94 37 0c 	call	0x186e <TIMEOUT_SetupTimeoutTimer>
    1ec4:	c0 93 31 01 	sts	0x0131, r28
    1ec8:	81 e0       	ldi	r24, 0x01	; 1
    1eca:	90 e0       	ldi	r25, 0x00	; 0
    1ecc:	90 93 35 01 	sts	0x0135, r25
    1ed0:	80 93 34 01 	sts	0x0134, r24
    1ed4:	10 92 2d 01 	sts	0x012D, r1
    1ed8:	10 92 2e 01 	sts	0x012E, r1
    1edc:	10 92 2f 01 	sts	0x012F, r1
    1ee0:	10 92 30 01 	sts	0x0130, r1
    1ee4:	80 91 2a 01 	lds	r24, 0x012A
    1ee8:	81 30       	cpi	r24, 0x01	; 1
    1eea:	11 f4       	brne	.+4      	; 0x1ef0 <V2P_RunStateMachine+0x50>
    1eec:	c9 e0       	ldi	r28, 0x09	; 9
    1eee:	05 c0       	rjmp	.+10     	; 0x1efa <V2P_RunStateMachine+0x5a>
    1ef0:	cc 23       	and	r28, r28
    1ef2:	19 f0       	breq	.+6      	; 0x1efa <V2P_RunStateMachine+0x5a>
    1ef4:	83 e0       	ldi	r24, 0x03	; 3
    1ef6:	80 93 81 00 	sts	0x0081, r24
    1efa:	8c 2f       	mov	r24, r28
    1efc:	99 27       	eor	r25, r25
    1efe:	84 30       	cpi	r24, 0x04	; 4
    1f00:	91 05       	cpc	r25, r1
    1f02:	09 f4       	brne	.+2      	; 0x1f06 <V2P_RunStateMachine+0x66>
    1f04:	6d c0       	rjmp	.+218    	; 0x1fe0 <V2P_RunStateMachine+0x140>
    1f06:	85 30       	cpi	r24, 0x05	; 5
    1f08:	91 05       	cpc	r25, r1
    1f0a:	94 f4       	brge	.+36     	; 0x1f30 <V2P_RunStateMachine+0x90>
    1f0c:	81 30       	cpi	r24, 0x01	; 1
    1f0e:	91 05       	cpc	r25, r1
    1f10:	09 f4       	brne	.+2      	; 0x1f14 <V2P_RunStateMachine+0x74>
    1f12:	4c c0       	rjmp	.+152    	; 0x1fac <V2P_RunStateMachine+0x10c>
    1f14:	82 30       	cpi	r24, 0x02	; 2
    1f16:	91 05       	cpc	r25, r1
    1f18:	1c f4       	brge	.+6      	; 0x1f20 <V2P_RunStateMachine+0x80>
    1f1a:	89 2b       	or	r24, r25
    1f1c:	b1 f1       	breq	.+108    	; 0x1f8a <V2P_RunStateMachine+0xea>
    1f1e:	e2 cf       	rjmp	.-60     	; 0x1ee4 <V2P_RunStateMachine+0x44>
    1f20:	82 30       	cpi	r24, 0x02	; 2
    1f22:	91 05       	cpc	r25, r1
    1f24:	09 f4       	brne	.+2      	; 0x1f28 <V2P_RunStateMachine+0x88>
    1f26:	48 c0       	rjmp	.+144    	; 0x1fb8 <V2P_RunStateMachine+0x118>
    1f28:	03 97       	sbiw	r24, 0x03	; 3
    1f2a:	09 f4       	brne	.+2      	; 0x1f2e <V2P_RunStateMachine+0x8e>
    1f2c:	4e c0       	rjmp	.+156    	; 0x1fca <V2P_RunStateMachine+0x12a>
    1f2e:	da cf       	rjmp	.-76     	; 0x1ee4 <V2P_RunStateMachine+0x44>
    1f30:	87 30       	cpi	r24, 0x07	; 7
    1f32:	91 05       	cpc	r25, r1
    1f34:	09 f4       	brne	.+2      	; 0x1f38 <V2P_RunStateMachine+0x98>
    1f36:	85 c0       	rjmp	.+266    	; 0x2042 <V2P_RunStateMachine+0x1a2>
    1f38:	88 30       	cpi	r24, 0x08	; 8
    1f3a:	91 05       	cpc	r25, r1
    1f3c:	44 f4       	brge	.+16     	; 0x1f4e <V2P_RunStateMachine+0xae>
    1f3e:	85 30       	cpi	r24, 0x05	; 5
    1f40:	91 05       	cpc	r25, r1
    1f42:	09 f4       	brne	.+2      	; 0x1f46 <V2P_RunStateMachine+0xa6>
    1f44:	62 c0       	rjmp	.+196    	; 0x200a <V2P_RunStateMachine+0x16a>
    1f46:	06 97       	sbiw	r24, 0x06	; 6
    1f48:	09 f4       	brne	.+2      	; 0x1f4c <V2P_RunStateMachine+0xac>
    1f4a:	67 c0       	rjmp	.+206    	; 0x201a <V2P_RunStateMachine+0x17a>
    1f4c:	cb cf       	rjmp	.-106    	; 0x1ee4 <V2P_RunStateMachine+0x44>
    1f4e:	88 30       	cpi	r24, 0x08	; 8
    1f50:	91 05       	cpc	r25, r1
    1f52:	79 f0       	breq	.+30     	; 0x1f72 <V2P_RunStateMachine+0xd2>
    1f54:	09 97       	sbiw	r24, 0x09	; 9
    1f56:	31 f6       	brne	.-116    	; 0x1ee4 <V2P_RunStateMachine+0x44>
    1f58:	82 e0       	ldi	r24, 0x02	; 2
    1f5a:	90 e0       	ldi	r25, 0x00	; 0
    1f5c:	90 93 33 01 	sts	0x0133, r25
    1f60:	80 93 32 01 	sts	0x0132, r24
    1f64:	80 ec       	ldi	r24, 0xC0	; 192
    1f66:	80 93 37 01 	sts	0x0137, r24
    1f6a:	10 92 2a 01 	sts	0x012A, r1
    1f6e:	0e 94 39 0e 	call	0x1c72 <V2P_SendPacket>
    1f72:	0e 94 c4 0b 	call	0x1788 <BUFF_InitialiseBuffer>
    1f76:	10 92 81 00 	sts	0x0081, r1
    1f7a:	10 92 2b 01 	sts	0x012B, r1
    1f7e:	10 92 85 00 	sts	0x0085, r1
    1f82:	10 92 84 00 	sts	0x0084, r1
    1f86:	c0 e0       	ldi	r28, 0x00	; 0
    1f88:	ad cf       	rjmp	.-166    	; 0x1ee4 <V2P_RunStateMachine+0x44>
    1f8a:	80 91 d1 02 	lds	r24, 0x02D1
    1f8e:	81 11       	cpse	r24, r1
    1f90:	c1 e0       	ldi	r28, 0x01	; 1
    1f92:	f2 9b       	sbis	0x1e, 2	; 30
    1f94:	a7 cf       	rjmp	.-178    	; 0x1ee4 <V2P_RunStateMachine+0x44>
    1f96:	80 91 31 01 	lds	r24, 0x0131
    1f9a:	88 23       	and	r24, r24
    1f9c:	09 f0       	breq	.+2      	; 0x1fa0 <V2P_RunStateMachine+0x100>
    1f9e:	a2 cf       	rjmp	.-188    	; 0x1ee4 <V2P_RunStateMachine+0x44>
    1fa0:	80 91 c1 00 	lds	r24, 0x00C1
    1fa4:	80 78       	andi	r24, 0x80	; 128
    1fa6:	80 93 c1 00 	sts	0x00C1, r24
    1faa:	d4 c0       	rjmp	.+424    	; 0x2154 <V2P_RunStateMachine+0x2b4>
    1fac:	0e 94 01 09 	call	0x1202 <USART_Rx>
    1fb0:	8b 31       	cpi	r24, 0x1B	; 27
    1fb2:	89 f5       	brne	.+98     	; 0x2016 <V2P_RunStateMachine+0x176>
    1fb4:	c2 e0       	ldi	r28, 0x02	; 2
    1fb6:	96 cf       	rjmp	.-212    	; 0x1ee4 <V2P_RunStateMachine+0x44>
    1fb8:	0e 94 01 09 	call	0x1202 <USART_Rx>
    1fbc:	99 27       	eor	r25, r25
    1fbe:	90 93 35 01 	sts	0x0135, r25
    1fc2:	80 93 34 01 	sts	0x0134, r24
    1fc6:	c3 e0       	ldi	r28, 0x03	; 3
    1fc8:	8d cf       	rjmp	.-230    	; 0x1ee4 <V2P_RunStateMachine+0x44>
    1fca:	0e 94 01 09 	call	0x1202 <USART_Rx>
    1fce:	99 27       	eor	r25, r25
    1fd0:	98 2f       	mov	r25, r24
    1fd2:	88 27       	eor	r24, r24
    1fd4:	90 93 33 01 	sts	0x0133, r25
    1fd8:	80 93 32 01 	sts	0x0132, r24
    1fdc:	c4 e0       	ldi	r28, 0x04	; 4
    1fde:	82 cf       	rjmp	.-252    	; 0x1ee4 <V2P_RunStateMachine+0x44>
    1fe0:	0e 94 01 09 	call	0x1202 <USART_Rx>
    1fe4:	28 2f       	mov	r18, r24
    1fe6:	33 27       	eor	r19, r19
    1fe8:	80 91 32 01 	lds	r24, 0x0132
    1fec:	90 91 33 01 	lds	r25, 0x0133
    1ff0:	82 2b       	or	r24, r18
    1ff2:	93 2b       	or	r25, r19
    1ff4:	90 93 33 01 	sts	0x0133, r25
    1ff8:	80 93 32 01 	sts	0x0132, r24
    1ffc:	83 51       	subi	r24, 0x13	; 19
    1ffe:	91 40       	sbci	r25, 0x01	; 1
    2000:	50 f4       	brcc	.+20     	; 0x2016 <V2P_RunStateMachine+0x176>
    2002:	c5 e0       	ldi	r28, 0x05	; 5
    2004:	ee 24       	eor	r14, r14
    2006:	ff 24       	eor	r15, r15
    2008:	6d cf       	rjmp	.-294    	; 0x1ee4 <V2P_RunStateMachine+0x44>
    200a:	0e 94 01 09 	call	0x1202 <USART_Rx>
    200e:	8e 30       	cpi	r24, 0x0E	; 14
    2010:	11 f4       	brne	.+4      	; 0x2016 <V2P_RunStateMachine+0x176>
    2012:	c6 e0       	ldi	r28, 0x06	; 6
    2014:	67 cf       	rjmp	.-306    	; 0x1ee4 <V2P_RunStateMachine+0x44>
    2016:	c9 e0       	ldi	r28, 0x09	; 9
    2018:	65 cf       	rjmp	.-310    	; 0x1ee4 <V2P_RunStateMachine+0x44>
    201a:	80 91 32 01 	lds	r24, 0x0132
    201e:	90 91 33 01 	lds	r25, 0x0133
    2022:	e8 16       	cp	r14, r24
    2024:	f9 06       	cpc	r15, r25
    2026:	11 f4       	brne	.+4      	; 0x202c <V2P_RunStateMachine+0x18c>
    2028:	c7 e0       	ldi	r28, 0x07	; 7
    202a:	5c cf       	rjmp	.-328    	; 0x1ee4 <V2P_RunStateMachine+0x44>
    202c:	87 01       	movw	r16, r14
    202e:	0a 5c       	subi	r16, 0xCA	; 202
    2030:	1e 4f       	sbci	r17, 0xFE	; 254
    2032:	08 94       	sec
    2034:	e1 1c       	adc	r14, r1
    2036:	f1 1c       	adc	r15, r1
    2038:	0e 94 01 09 	call	0x1202 <USART_Rx>
    203c:	f8 01       	movw	r30, r16
    203e:	80 83       	st	Z, r24
    2040:	51 cf       	rjmp	.-350    	; 0x1ee4 <V2P_RunStateMachine+0x44>
    2042:	0e 94 18 0e 	call	0x1c30 <V2P_GetChecksum>
    2046:	18 2f       	mov	r17, r24
    2048:	0e 94 01 09 	call	0x1202 <USART_Rx>
    204c:	18 17       	cp	r17, r24
    204e:	09 f0       	breq	.+2      	; 0x2052 <V2P_RunStateMachine+0x1b2>
    2050:	74 c0       	rjmp	.+232    	; 0x213a <V2P_RunStateMachine+0x29a>
    2052:	80 91 36 01 	lds	r24, 0x0136
    2056:	99 27       	eor	r25, r25
    2058:	84 30       	cpi	r24, 0x04	; 4
    205a:	91 05       	cpc	r25, r1
    205c:	3c f4       	brge	.+14     	; 0x206c <V2P_RunStateMachine+0x1cc>
    205e:	82 30       	cpi	r24, 0x02	; 2
    2060:	91 05       	cpc	r25, r1
    2062:	0c f0       	brlt	.+2      	; 0x2066 <V2P_RunStateMachine+0x1c6>
    2064:	61 c0       	rjmp	.+194    	; 0x2128 <V2P_RunStateMachine+0x288>
    2066:	01 97       	sbiw	r24, 0x01	; 1
    2068:	39 f0       	breq	.+14     	; 0x2078 <V2P_RunStateMachine+0x1d8>
    206a:	61 c0       	rjmp	.+194    	; 0x212e <V2P_RunStateMachine+0x28e>
    206c:	86 30       	cpi	r24, 0x06	; 6
    206e:	91 05       	cpc	r25, r1
    2070:	e9 f0       	breq	.+58     	; 0x20ac <V2P_RunStateMachine+0x20c>
    2072:	07 97       	sbiw	r24, 0x07	; 7
    2074:	99 f0       	breq	.+38     	; 0x209c <V2P_RunStateMachine+0x1fc>
    2076:	5b c0       	rjmp	.+182    	; 0x212e <V2P_RunStateMachine+0x28e>
    2078:	8b e0       	ldi	r24, 0x0B	; 11
    207a:	90 e0       	ldi	r25, 0x00	; 0
    207c:	90 93 33 01 	sts	0x0133, r25
    2080:	80 93 32 01 	sts	0x0132, r24
    2084:	a6 e3       	ldi	r26, 0x36	; 54
    2086:	b1 e0       	ldi	r27, 0x01	; 1
    2088:	eb ec       	ldi	r30, 0xCB	; 203
    208a:	f3 e0       	ldi	r31, 0x03	; 3
    208c:	9a e0       	ldi	r25, 0x0A	; 10
    208e:	84 91       	lpm	r24, Z
    2090:	8d 93       	st	X+, r24
    2092:	91 50       	subi	r25, 0x01	; 1
    2094:	31 96       	adiw	r30, 0x01	; 1
    2096:	97 ff       	sbrs	r25, 7
    2098:	fa cf       	rjmp	.-12     	; 0x208e <V2P_RunStateMachine+0x1ee>
    209a:	58 c0       	rjmp	.+176    	; 0x214c <V2P_RunStateMachine+0x2ac>
    209c:	82 e0       	ldi	r24, 0x02	; 2
    209e:	90 e0       	ldi	r25, 0x00	; 0
    20a0:	90 93 33 01 	sts	0x0133, r25
    20a4:	80 93 32 01 	sts	0x0132, r24
    20a8:	80 ec       	ldi	r24, 0xC0	; 192
    20aa:	4e c0       	rjmp	.+156    	; 0x2148 <V2P_RunStateMachine+0x2a8>
    20ac:	82 e0       	ldi	r24, 0x02	; 2
    20ae:	90 e0       	ldi	r25, 0x00	; 0
    20b0:	90 93 33 01 	sts	0x0133, r25
    20b4:	80 93 32 01 	sts	0x0132, r24
    20b8:	0e 94 27 0f 	call	0x1e4e <V2P_CheckForExtendedAddress>
    20bc:	80 91 37 01 	lds	r24, 0x0137
    20c0:	99 27       	eor	r25, r25
    20c2:	aa 27       	eor	r26, r26
    20c4:	bb 27       	eor	r27, r27
    20c6:	b8 2f       	mov	r27, r24
    20c8:	aa 27       	eor	r26, r26
    20ca:	99 27       	eor	r25, r25
    20cc:	88 27       	eor	r24, r24
    20ce:	20 91 38 01 	lds	r18, 0x0138
    20d2:	33 27       	eor	r19, r19
    20d4:	44 27       	eor	r20, r20
    20d6:	55 27       	eor	r21, r21
    20d8:	a9 01       	movw	r20, r18
    20da:	33 27       	eor	r19, r19
    20dc:	22 27       	eor	r18, r18
    20de:	82 2b       	or	r24, r18
    20e0:	93 2b       	or	r25, r19
    20e2:	a4 2b       	or	r26, r20
    20e4:	b5 2b       	or	r27, r21
    20e6:	20 91 39 01 	lds	r18, 0x0139
    20ea:	33 27       	eor	r19, r19
    20ec:	44 27       	eor	r20, r20
    20ee:	55 27       	eor	r21, r21
    20f0:	54 2f       	mov	r21, r20
    20f2:	43 2f       	mov	r20, r19
    20f4:	32 2f       	mov	r19, r18
    20f6:	22 27       	eor	r18, r18
    20f8:	82 2b       	or	r24, r18
    20fa:	93 2b       	or	r25, r19
    20fc:	a4 2b       	or	r26, r20
    20fe:	b5 2b       	or	r27, r21
    2100:	20 91 3a 01 	lds	r18, 0x013A
    2104:	33 27       	eor	r19, r19
    2106:	44 27       	eor	r20, r20
    2108:	55 27       	eor	r21, r21
    210a:	82 2b       	or	r24, r18
    210c:	93 2b       	or	r25, r19
    210e:	a4 2b       	or	r26, r20
    2110:	b5 2b       	or	r27, r21
    2112:	80 93 2d 01 	sts	0x012D, r24
    2116:	90 93 2e 01 	sts	0x012E, r25
    211a:	a0 93 2f 01 	sts	0x012F, r26
    211e:	b0 93 30 01 	sts	0x0130, r27
    2122:	10 92 37 01 	sts	0x0137, r1
    2126:	12 c0       	rjmp	.+36     	; 0x214c <V2P_RunStateMachine+0x2ac>
    2128:	0e 94 79 0e 	call	0x1cf2 <V2P_GetSetParamater>
    212c:	11 c0       	rjmp	.+34     	; 0x2150 <V2P_RunStateMachine+0x2b0>
    212e:	e0 91 24 01 	lds	r30, 0x0124
    2132:	f0 91 25 01 	lds	r31, 0x0125
    2136:	09 95       	icall
    2138:	0b c0       	rjmp	.+22     	; 0x2150 <V2P_RunStateMachine+0x2b0>
    213a:	82 e0       	ldi	r24, 0x02	; 2
    213c:	90 e0       	ldi	r25, 0x00	; 0
    213e:	90 93 33 01 	sts	0x0133, r25
    2142:	80 93 32 01 	sts	0x0132, r24
    2146:	81 ec       	ldi	r24, 0xC1	; 193
    2148:	80 93 37 01 	sts	0x0137, r24
    214c:	0e 94 39 0e 	call	0x1c72 <V2P_SendPacket>
    2150:	c8 e0       	ldi	r28, 0x08	; 8
    2152:	c8 ce       	rjmp	.-624    	; 0x1ee4 <V2P_RunStateMachine+0x44>
    2154:	cf 91       	pop	r28
    2156:	1f 91       	pop	r17
    2158:	0f 91       	pop	r16
    215a:	ff 90       	pop	r15
    215c:	ef 90       	pop	r14
    215e:	08 95       	ret

00002160 <ISPCC_EnterChipProgrammingMode>:

// ======================================================================================

void ISPCC_EnterChipProgrammingMode(void)
{
    2160:	0f 93       	push	r16
    2162:	1f 93       	push	r17
    2164:	cf 93       	push	r28
	uint8_t ByteDelay = PacketBytes[5];
    2166:	10 91 3b 01 	lds	r17, 0x013B
	uint8_t Attempts  = PacketBytes[4];
    216a:	c0 91 3a 01 	lds	r28, 0x013A
	uint8_t Response;

	MAIN_Delay1MS(PacketBytes[2]);         // Wait before continuing, amount specified in the packet
    216e:	80 91 38 01 	lds	r24, 0x0138
    2172:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>

	if ((!(Attempts)) || (Attempts > 100)) // Safety - if no attempts or too high a value is specified, a fixed number is chosen
    2176:	8c 2f       	mov	r24, r28
    2178:	81 50       	subi	r24, 0x01	; 1
    217a:	84 36       	cpi	r24, 0x64	; 100
    217c:	08 f0       	brcs	.+2      	; 0x2180 <ISPCC_EnterChipProgrammingMode+0x20>
	   Attempts = 24;
    217e:	c8 e1       	ldi	r28, 0x18	; 24
		
	while (Attempts--)
	{
		USI_SPITransmit(PacketBytes[8]);
		MAIN_Delay1MS(ByteDelay);
		USI_SPITransmit(PacketBytes[9]);
		MAIN_Delay1MS(ByteDelay);
			
		Response = USI_SPITransmit(PacketBytes[10]);
		MAIN_Delay1MS(ByteDelay);

		if(PacketBytes[7] == ISPCC_POLL_MODE_AVR)
		  USI_SPITransmit(PacketBytes[11]);
		else
		  Response = USI_SPITransmit(PacketBytes[11]);
				
		if(!(PacketBytes[7]) || (Response == PacketBytes[6])) // Polling disabled, or returned value matches expected poll value
		{
			MAIN_Delay1MS(ByteDelay);

			InProgrammingMode = TRUE;
			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = STATUS_CMD_OK;
			return;
		}
		
		MAIN_Delay1MS(ByteDelay);
		USI_SPIToggleClock();            // Out of sync, shift in one bit and try again
    2180:	c1 50       	subi	r28, 0x01	; 1
    2182:	cf 3f       	cpi	r28, 0xFF	; 255
    2184:	09 f4       	brne	.+2      	; 0x2188 <ISPCC_EnterChipProgrammingMode+0x28>
    2186:	3f c0       	rjmp	.+126    	; 0x2206 <ISPCC_EnterChipProgrammingMode+0xa6>
    2188:	80 91 3e 01 	lds	r24, 0x013E
    218c:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    2190:	81 2f       	mov	r24, r17
    2192:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    2196:	80 91 3f 01 	lds	r24, 0x013F
    219a:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    219e:	81 2f       	mov	r24, r17
    21a0:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    21a4:	80 91 40 01 	lds	r24, 0x0140
    21a8:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    21ac:	08 2f       	mov	r16, r24
    21ae:	81 2f       	mov	r24, r17
    21b0:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    21b4:	80 91 3d 01 	lds	r24, 0x013D
    21b8:	83 30       	cpi	r24, 0x03	; 3
    21ba:	29 f4       	brne	.+10     	; 0x21c6 <ISPCC_EnterChipProgrammingMode+0x66>
    21bc:	80 91 41 01 	lds	r24, 0x0141
    21c0:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    21c4:	05 c0       	rjmp	.+10     	; 0x21d0 <ISPCC_EnterChipProgrammingMode+0x70>
    21c6:	80 91 41 01 	lds	r24, 0x0141
    21ca:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    21ce:	08 2f       	mov	r16, r24
    21d0:	80 91 3d 01 	lds	r24, 0x013D
    21d4:	88 23       	and	r24, r24
    21d6:	21 f0       	breq	.+8      	; 0x21e0 <ISPCC_EnterChipProgrammingMode+0x80>
    21d8:	80 91 3c 01 	lds	r24, 0x013C
    21dc:	08 17       	cp	r16, r24
    21de:	69 f4       	brne	.+26     	; 0x21fa <ISPCC_EnterChipProgrammingMode+0x9a>
    21e0:	81 2f       	mov	r24, r17
    21e2:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    21e6:	81 e0       	ldi	r24, 0x01	; 1
    21e8:	80 93 31 01 	sts	0x0131, r24
    21ec:	81 b3       	in	r24, 0x11	; 17
    21ee:	8f 7c       	andi	r24, 0xCF	; 207
    21f0:	80 62       	ori	r24, 0x20	; 32
    21f2:	81 bb       	out	0x11, r24	; 17
    21f4:	10 92 37 01 	sts	0x0137, r1
    21f8:	0d c0       	rjmp	.+26     	; 0x2214 <ISPCC_EnterChipProgrammingMode+0xb4>
    21fa:	81 2f       	mov	r24, r17
    21fc:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    2200:	0e 94 fc 09 	call	0x13f8 <USI_SPIToggleClock>
    2204:	bd cf       	rjmp	.-134    	; 0x2180 <ISPCC_EnterChipProgrammingMode+0x20>
	}

	// If function hasn't returned by now, all the attempts have failed. Show this by
	// resetting the status leds to green (ready) and send a fail message.

	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
    2206:	81 b3       	in	r24, 0x11	; 17
    2208:	8f 7c       	andi	r24, 0xCF	; 207
    220a:	80 61       	ori	r24, 0x10	; 16
    220c:	81 bb       	out	0x11, r24	; 17
	PacketBytes[1] = STATUS_CMD_FAILED;
    220e:	80 ec       	ldi	r24, 0xC0	; 192
    2210:	80 93 37 01 	sts	0x0137, r24
    2214:	cf 91       	pop	r28
    2216:	1f 91       	pop	r17
    2218:	0f 91       	pop	r16
    221a:	08 95       	ret

0000221c <ISPCC_PollForProgComplete>:
}

void ISPCC_ProgramChip(void)
{
	uint16_t PollAddress  = 0;
	uint8_t  ProgMode     = PacketBytes[3];
	uint8_t  WriteCommand = PacketBytes[5];
	uint16_t StartAddress = (uint16_t)CurrAddress;
	uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
	                      | PacketBytes[2];
	uint8_t  PollType;
			
	if (ProgMode & ISPCC_PROG_MODE_PAGE)                 // Page writing mode
	{
		for (uint16_t WriteByte = 0; WriteByte < BytesToWrite; WriteByte++) // Transmit the page bytes
		{
			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) // Flash write mode - word addresses so MSB/LSB masking 
			   USI_SPITransmit(WriteCommand | ((WriteByte & 0x01)? ISPCC_HIGH_BYTE_WRITE : ISPCC_LOW_BYTE_WRITE));
			else                                         // EEPROM write mode - byte addresses so no masking 
			   USI_SPITransmit(WriteCommand);

			USI_SPITransmitWord(CurrAddress & 0xFFFF);    // Only the LSW of the address should be sent
			USI_SPITransmit(PacketBytes[10 + WriteByte]); // Send one of the new bytes to be written

			if (!(PollAddress))
			{
				if ((PacketBytes[8] != PacketBytes[10 + WriteByte]) // Can do polling
				   && ((PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) || ((PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP) && (PacketBytes[9] != PacketBytes[10 + BytesToWrite]))))
				{
					PollAddress = (CurrAddress & 0xFFFF);    // Save the current address
				
					if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
					   PollAddress = ((PollAddress << 1) + (WriteByte & 0x01));
				}
			}

			// Flash addresses are in words; only increment address on odd byte, OR if it's the EEPROM being programmed (byte addresses)
			if ((WriteByte & 0x01) || (PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP))
			   V2P_IncrementCurrAddress();
		}

		PollType = ProgMode;

		if (ProgMode & ISPCC_PROG_MODE_PAGEDONE)         // If this packet is the end of a page, we need to send the program page command
		{
			USI_SPITransmit(PacketBytes[6]);             // Send the write program memory page command
			USI_SPITransmitWord(StartAddress);           // Send the page address word
			USI_SPITransmit(0x00);

			if (!(PollAddress))                          // No polling address
			   PollType = ((ProgMode & ~ISPCC_PAGE_POLLTYPE_MASK) | ISPCC_PAGE_POLLTYPE_WAIT);

			ISPCC_PollForProgComplete(PollType, PollAddress);
		}
	}
	else                                                 // Flash Word writing mode or EEPROM byte writing mode
	{
		for (uint16_t WriteByte = 0; WriteByte < BytesToWrite; WriteByte++)
		{
			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
			   USI_SPITransmit(WriteCommand | ((WriteByte & 0x01)? ISPCC_HIGH_BYTE_WRITE : ISPCC_LOW_BYTE_WRITE));
			else
			   USI_SPITransmit(WriteCommand);					
					
			USI_SPITransmitWord(CurrAddress & 0xFFFF);    // Transmit the current address to the slave AVR
			USI_SPITransmit(PacketBytes[10 + WriteByte]); // Send one of the new bytes to be written

			PollType = ProgMode;

			if ((PacketBytes[8] != PacketBytes[10 + WriteByte]) // Can do polling
			   && ((PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) || ((PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP) && (PacketBytes[9] != PacketBytes[10 + WriteByte]))))
			{
				PollAddress = (CurrAddress & 0xFFFF);     // Save the current address;

				if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
				   PollAddress = ((PollAddress << 1) + (WriteByte & 0x01));
			}
			else
			{
				PollType = ((ProgMode & ~ISPCC_WORD_POLLTYPE_MASK) | ISPCC_WORD_POLLTYPE_WAIT);
			}					

			// Flash addresses are in words; only increment address on the odd byte, OR if it's the EEPROM being programmed (byte addresses)
			if ((WriteByte & 0x01) || (PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP))
			   V2P_IncrementCurrAddress();

			ISPCC_PollForProgComplete(PollType, PollAddress);
		}
	}
}

void ISPCC_PollForProgComplete(uint8_t PollData, uint16_t PollAddr)
{
    221c:	1f 93       	push	r17
    221e:	cf 93       	push	r28
    2220:	df 93       	push	r29
    2222:	eb 01       	movw	r28, r22
	uint8_t PollType;
	uint8_t ProgCommand;

	if (PollData & ISPCC_PROG_MODE_PAGE)
    2224:	99 27       	eor	r25, r25
    2226:	80 ff       	sbrs	r24, 0
    2228:	08 c0       	rjmp	.+16     	; 0x223a <ISPCC_PollForProgComplete+0x1e>
	   PollType = ((PollData & ISPCC_PAGE_POLLTYPE_MASK) >> ISPCC_PAGE_POLLTYPE_MASKSHIFT);
    222a:	80 77       	andi	r24, 0x70	; 112
    222c:	90 70       	andi	r25, 0x00	; 0
    222e:	34 e0       	ldi	r19, 0x04	; 4
    2230:	95 95       	asr	r25
    2232:	87 95       	ror	r24
    2234:	3a 95       	dec	r19
    2236:	e1 f7       	brne	.-8      	; 0x2230 <ISPCC_PollForProgComplete+0x14>
    2238:	04 c0       	rjmp	.+8      	; 0x2242 <ISPCC_PollForProgComplete+0x26>
	else
	   PollType = ((PollData & ISPCC_WORD_POLLTYPE_MASK) >> ISPCC_WORD_POLLTYPE_MASKSHIFT);	
    223a:	8e 70       	andi	r24, 0x0E	; 14
    223c:	90 70       	andi	r25, 0x00	; 0
    223e:	95 95       	asr	r25
    2240:	87 95       	ror	r24

	switch (PollType & ISPCC_POLLTYPE_MASK)
    2242:	99 27       	eor	r25, r25
    2244:	87 70       	andi	r24, 0x07	; 7
    2246:	90 70       	andi	r25, 0x00	; 0
    2248:	82 30       	cpi	r24, 0x02	; 2
    224a:	91 05       	cpc	r25, r1
    224c:	19 f0       	breq	.+6      	; 0x2254 <ISPCC_PollForProgComplete+0x38>
    224e:	04 97       	sbiw	r24, 0x04	; 4
    2250:	e1 f0       	breq	.+56     	; 0x228a <ISPCC_PollForProgComplete+0x6e>
    2252:	26 c0       	rjmp	.+76     	; 0x22a0 <ISPCC_PollForProgComplete+0x84>
	{
		case ISPCC_POLLTYPE_DATA:
			ProgCommand = PacketBytes[7];
    2254:	10 91 3d 01 	lds	r17, 0x013D
			
			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) // Flash uses word addresses
    2258:	80 91 36 01 	lds	r24, 0x0136
    225c:	83 31       	cpi	r24, 0x13	; 19
    225e:	39 f4       	brne	.+14     	; 0x226e <ISPCC_PollForProgComplete+0x52>
			{
				ProgCommand  |= ((PollAddr & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ);
    2260:	81 2f       	mov	r24, r17
    2262:	99 27       	eor	r25, r25
    2264:	c0 fd       	sbrc	r28, 0
    2266:	88 60       	ori	r24, 0x08	; 8
    2268:	18 2f       	mov	r17, r24
				PollAddr    >>= 1;
    226a:	d6 95       	lsr	r29
    226c:	c7 95       	ror	r28
			}

			do
			{
				USI_SPITransmit(ProgCommand);
    226e:	81 2f       	mov	r24, r17
    2270:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
				USI_SPITransmitWord(PollAddr);
    2274:	ce 01       	movw	r24, r28
    2276:	0e 94 ee 09 	call	0x13dc <USI_SPITransmitWord>
			}
    227a:	80 e0       	ldi	r24, 0x00	; 0
    227c:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    2280:	90 91 3e 01 	lds	r25, 0x013E
    2284:	89 17       	cp	r24, r25
    2286:	99 f3       	breq	.-26     	; 0x226e <ISPCC_PollForProgComplete+0x52>
			while (USI_SPITransmit(0x00) == PacketBytes[8]);
						
			break;
    2288:	0f c0       	rjmp	.+30     	; 0x22a8 <ISPCC_PollForProgComplete+0x8c>
		case ISPCC_POLLTYPE_READY:
			do
			   USI_SPITransmitWord(0xF000);
    228a:	80 e0       	ldi	r24, 0x00	; 0
    228c:	90 ef       	ldi	r25, 0xF0	; 240
    228e:	0e 94 ee 09 	call	0x13dc <USI_SPITransmitWord>
    2292:	80 e0       	ldi	r24, 0x00	; 0
    2294:	90 e0       	ldi	r25, 0x00	; 0
    2296:	0e 94 ee 09 	call	0x13dc <USI_SPITransmitWord>
    229a:	80 fd       	sbrc	r24, 0
    229c:	f6 cf       	rjmp	.-20     	; 0x228a <ISPCC_PollForProgComplete+0x6e>
			while (USI_SPITransmitWord(0x0000) & ISPCC_POLL_BUSYFLAG);

			break;
    229e:	04 c0       	rjmp	.+8      	; 0x22a8 <ISPCC_PollForProgComplete+0x8c>
		default:                                      // Default is Wait polling
			MAIN_Delay1MS(PacketBytes[4]);	
    22a0:	80 91 3a 01 	lds	r24, 0x013A
    22a4:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    22a8:	df 91       	pop	r29
    22aa:	cf 91       	pop	r28
    22ac:	1f 91       	pop	r17
    22ae:	08 95       	ret

000022b0 <ISPCC_ProgramChip>:
    22b0:	8f 92       	push	r8
    22b2:	9f 92       	push	r9
    22b4:	af 92       	push	r10
    22b6:	bf 92       	push	r11
    22b8:	cf 92       	push	r12
    22ba:	df 92       	push	r13
    22bc:	ef 92       	push	r14
    22be:	ff 92       	push	r15
    22c0:	0f 93       	push	r16
    22c2:	1f 93       	push	r17
    22c4:	cf 93       	push	r28
    22c6:	df 93       	push	r29
    22c8:	00 e0       	ldi	r16, 0x00	; 0
    22ca:	10 e0       	ldi	r17, 0x00	; 0
    22cc:	80 90 39 01 	lds	r8, 0x0139
    22d0:	90 90 3b 01 	lds	r9, 0x013B
    22d4:	a0 90 2d 01 	lds	r10, 0x012D
    22d8:	b0 90 2e 01 	lds	r11, 0x012E
    22dc:	80 91 37 01 	lds	r24, 0x0137
    22e0:	99 27       	eor	r25, r25
    22e2:	d8 2e       	mov	r13, r24
    22e4:	cc 24       	eor	r12, r12
    22e6:	80 91 38 01 	lds	r24, 0x0138
    22ea:	99 27       	eor	r25, r25
    22ec:	c8 2a       	or	r12, r24
    22ee:	d9 2a       	or	r13, r25
    22f0:	80 fe       	sbrs	r8, 0
    22f2:	67 c0       	rjmp	.+206    	; 0x23c2 <ISPCC_ProgramChip+0x112>
    22f4:	78 01       	movw	r14, r16
    22f6:	0c 15       	cp	r16, r12
    22f8:	1d 05       	cpc	r17, r13
    22fa:	08 f0       	brcs	.+2      	; 0x22fe <ISPCC_ProgramChip+0x4e>
    22fc:	4b c0       	rjmp	.+150    	; 0x2394 <ISPCC_ProgramChip+0xe4>
    22fe:	c6 e3       	ldi	r28, 0x36	; 54
    2300:	d1 e0       	ldi	r29, 0x01	; 1
    2302:	80 91 36 01 	lds	r24, 0x0136
    2306:	83 31       	cpi	r24, 0x13	; 19
    2308:	31 f4       	brne	.+12     	; 0x2316 <ISPCC_ProgramChip+0x66>
    230a:	89 2d       	mov	r24, r9
    230c:	99 27       	eor	r25, r25
    230e:	e0 fe       	sbrs	r14, 0
    2310:	03 c0       	rjmp	.+6      	; 0x2318 <ISPCC_ProgramChip+0x68>
    2312:	88 60       	ori	r24, 0x08	; 8
    2314:	01 c0       	rjmp	.+2      	; 0x2318 <ISPCC_ProgramChip+0x68>
    2316:	89 2d       	mov	r24, r9
    2318:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    231c:	80 91 2d 01 	lds	r24, 0x012D
    2320:	90 91 2e 01 	lds	r25, 0x012E
    2324:	0e 94 ee 09 	call	0x13dc <USI_SPITransmitWord>
    2328:	8a 85       	ldd	r24, Y+10	; 0x0a
    232a:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    232e:	01 15       	cp	r16, r1
    2330:	11 05       	cpc	r17, r1
    2332:	01 f5       	brne	.+64     	; 0x2374 <ISPCC_ProgramChip+0xc4>
    2334:	90 91 3e 01 	lds	r25, 0x013E
    2338:	8a 85       	ldd	r24, Y+10	; 0x0a
    233a:	98 17       	cp	r25, r24
    233c:	d9 f0       	breq	.+54     	; 0x2374 <ISPCC_ProgramChip+0xc4>
    233e:	20 91 36 01 	lds	r18, 0x0136
    2342:	23 31       	cpi	r18, 0x13	; 19
    2344:	51 f0       	breq	.+20     	; 0x235a <ISPCC_ProgramChip+0xaa>
    2346:	25 31       	cpi	r18, 0x15	; 21
    2348:	a9 f4       	brne	.+42     	; 0x2374 <ISPCC_ProgramChip+0xc4>
    234a:	f6 01       	movw	r30, r12
    234c:	ea 5c       	subi	r30, 0xCA	; 202
    234e:	fe 4f       	sbci	r31, 0xFE	; 254
    2350:	90 91 3f 01 	lds	r25, 0x013F
    2354:	82 85       	ldd	r24, Z+10	; 0x0a
    2356:	98 17       	cp	r25, r24
    2358:	69 f0       	breq	.+26     	; 0x2374 <ISPCC_ProgramChip+0xc4>
    235a:	00 91 2d 01 	lds	r16, 0x012D
    235e:	10 91 2e 01 	lds	r17, 0x012E
    2362:	23 31       	cpi	r18, 0x13	; 19
    2364:	39 f4       	brne	.+14     	; 0x2374 <ISPCC_ProgramChip+0xc4>
    2366:	00 0f       	add	r16, r16
    2368:	11 1f       	adc	r17, r17
    236a:	c7 01       	movw	r24, r14
    236c:	81 70       	andi	r24, 0x01	; 1
    236e:	90 70       	andi	r25, 0x00	; 0
    2370:	08 0f       	add	r16, r24
    2372:	19 1f       	adc	r17, r25
    2374:	e0 fc       	sbrc	r14, 0
    2376:	04 c0       	rjmp	.+8      	; 0x2380 <ISPCC_ProgramChip+0xd0>
    2378:	80 91 36 01 	lds	r24, 0x0136
    237c:	85 31       	cpi	r24, 0x15	; 21
    237e:	11 f4       	brne	.+4      	; 0x2384 <ISPCC_ProgramChip+0xd4>
    2380:	0e 94 13 0f 	call	0x1e26 <V2P_IncrementCurrAddress>
    2384:	08 94       	sec
    2386:	e1 1c       	adc	r14, r1
    2388:	f1 1c       	adc	r15, r1
    238a:	21 96       	adiw	r28, 0x01	; 1
    238c:	ec 14       	cp	r14, r12
    238e:	fd 04       	cpc	r15, r13
    2390:	08 f4       	brcc	.+2      	; 0x2394 <ISPCC_ProgramChip+0xe4>
    2392:	b7 cf       	rjmp	.-146    	; 0x2302 <ISPCC_ProgramChip+0x52>
    2394:	c8 2d       	mov	r28, r8
    2396:	87 fe       	sbrs	r8, 7
    2398:	6c c0       	rjmp	.+216    	; 0x2472 <ISPCC_ProgramChip+0x1c2>
    239a:	80 91 3c 01 	lds	r24, 0x013C
    239e:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    23a2:	c5 01       	movw	r24, r10
    23a4:	0e 94 ee 09 	call	0x13dc <USI_SPITransmitWord>
    23a8:	80 e0       	ldi	r24, 0x00	; 0
    23aa:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    23ae:	01 15       	cp	r16, r1
    23b0:	11 05       	cpc	r17, r1
    23b2:	11 f4       	brne	.+4      	; 0x23b8 <ISPCC_ProgramChip+0x108>
    23b4:	cf 78       	andi	r28, 0x8F	; 143
    23b6:	c0 61       	ori	r28, 0x10	; 16
    23b8:	b8 01       	movw	r22, r16
    23ba:	8c 2f       	mov	r24, r28
    23bc:	0e 94 0e 11 	call	0x221c <ISPCC_PollForProgComplete>
    23c0:	58 c0       	rjmp	.+176    	; 0x2472 <ISPCC_ProgramChip+0x1c2>
    23c2:	78 01       	movw	r14, r16
    23c4:	0c 15       	cp	r16, r12
    23c6:	1d 05       	cpc	r17, r13
    23c8:	08 f0       	brcs	.+2      	; 0x23cc <ISPCC_ProgramChip+0x11c>
    23ca:	53 c0       	rjmp	.+166    	; 0x2472 <ISPCC_ProgramChip+0x1c2>
    23cc:	56 e3       	ldi	r21, 0x36	; 54
    23ce:	a5 2e       	mov	r10, r21
    23d0:	51 e0       	ldi	r21, 0x01	; 1
    23d2:	b5 2e       	mov	r11, r21
    23d4:	80 91 36 01 	lds	r24, 0x0136
    23d8:	83 31       	cpi	r24, 0x13	; 19
    23da:	31 f4       	brne	.+12     	; 0x23e8 <ISPCC_ProgramChip+0x138>
    23dc:	89 2d       	mov	r24, r9
    23de:	99 27       	eor	r25, r25
    23e0:	e0 fe       	sbrs	r14, 0
    23e2:	03 c0       	rjmp	.+6      	; 0x23ea <ISPCC_ProgramChip+0x13a>
    23e4:	88 60       	ori	r24, 0x08	; 8
    23e6:	01 c0       	rjmp	.+2      	; 0x23ea <ISPCC_ProgramChip+0x13a>
    23e8:	89 2d       	mov	r24, r9
    23ea:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    23ee:	80 91 2d 01 	lds	r24, 0x012D
    23f2:	90 91 2e 01 	lds	r25, 0x012E
    23f6:	0e 94 ee 09 	call	0x13dc <USI_SPITransmitWord>
    23fa:	f5 01       	movw	r30, r10
    23fc:	82 85       	ldd	r24, Z+10	; 0x0a
    23fe:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    2402:	c8 2d       	mov	r28, r8
    2404:	80 91 3e 01 	lds	r24, 0x013E
    2408:	f5 01       	movw	r30, r10
    240a:	22 85       	ldd	r18, Z+10	; 0x0a
    240c:	82 17       	cp	r24, r18
    240e:	c1 f0       	breq	.+48     	; 0x2440 <ISPCC_ProgramChip+0x190>
    2410:	90 91 36 01 	lds	r25, 0x0136
    2414:	93 31       	cpi	r25, 0x13	; 19
    2416:	31 f0       	breq	.+12     	; 0x2424 <ISPCC_ProgramChip+0x174>
    2418:	95 31       	cpi	r25, 0x15	; 21
    241a:	91 f4       	brne	.+36     	; 0x2440 <ISPCC_ProgramChip+0x190>
    241c:	80 91 3f 01 	lds	r24, 0x013F
    2420:	82 17       	cp	r24, r18
    2422:	71 f0       	breq	.+28     	; 0x2440 <ISPCC_ProgramChip+0x190>
    2424:	00 91 2d 01 	lds	r16, 0x012D
    2428:	10 91 2e 01 	lds	r17, 0x012E
    242c:	93 31       	cpi	r25, 0x13	; 19
    242e:	59 f4       	brne	.+22     	; 0x2446 <ISPCC_ProgramChip+0x196>
    2430:	00 0f       	add	r16, r16
    2432:	11 1f       	adc	r17, r17
    2434:	c7 01       	movw	r24, r14
    2436:	81 70       	andi	r24, 0x01	; 1
    2438:	90 70       	andi	r25, 0x00	; 0
    243a:	08 0f       	add	r16, r24
    243c:	19 1f       	adc	r17, r25
    243e:	03 c0       	rjmp	.+6      	; 0x2446 <ISPCC_ProgramChip+0x196>
    2440:	c8 2d       	mov	r28, r8
    2442:	c1 7f       	andi	r28, 0xF1	; 241
    2444:	c2 60       	ori	r28, 0x02	; 2
    2446:	e0 fc       	sbrc	r14, 0
    2448:	04 c0       	rjmp	.+8      	; 0x2452 <ISPCC_ProgramChip+0x1a2>
    244a:	80 91 36 01 	lds	r24, 0x0136
    244e:	85 31       	cpi	r24, 0x15	; 21
    2450:	11 f4       	brne	.+4      	; 0x2456 <ISPCC_ProgramChip+0x1a6>
    2452:	0e 94 13 0f 	call	0x1e26 <V2P_IncrementCurrAddress>
    2456:	b8 01       	movw	r22, r16
    2458:	8c 2f       	mov	r24, r28
    245a:	0e 94 0e 11 	call	0x221c <ISPCC_PollForProgComplete>
    245e:	08 94       	sec
    2460:	e1 1c       	adc	r14, r1
    2462:	f1 1c       	adc	r15, r1
    2464:	08 94       	sec
    2466:	a1 1c       	adc	r10, r1
    2468:	b1 1c       	adc	r11, r1
    246a:	ec 14       	cp	r14, r12
    246c:	fd 04       	cpc	r15, r13
    246e:	08 f4       	brcc	.+2      	; 0x2472 <ISPCC_ProgramChip+0x1c2>
    2470:	b1 cf       	rjmp	.-158    	; 0x23d4 <ISPCC_ProgramChip+0x124>
    2472:	df 91       	pop	r29
    2474:	cf 91       	pop	r28
    2476:	1f 91       	pop	r17
    2478:	0f 91       	pop	r16
    247a:	ff 90       	pop	r15
    247c:	ef 90       	pop	r14
    247e:	df 90       	pop	r13
    2480:	cf 90       	pop	r12
    2482:	bf 90       	pop	r11
    2484:	af 90       	pop	r10
    2486:	9f 90       	pop	r9
    2488:	8f 90       	pop	r8
    248a:	08 95       	ret

0000248c <AICI_InterpretPacket>:

// ======================================================================================

void AICI_InterpretPacket(void)
{
    248c:	df 92       	push	r13
    248e:	ef 92       	push	r14
    2490:	ff 92       	push	r15
    2492:	0f 93       	push	r16
    2494:	1f 93       	push	r17
    2496:	cf 93       	push	r28
    2498:	df 93       	push	r29
	switch (PacketBytes[0])
    249a:	80 91 36 01 	lds	r24, 0x0136
    249e:	99 27       	eor	r25, r25
    24a0:	86 31       	cpi	r24, 0x16	; 22
    24a2:	91 05       	cpc	r25, r1
    24a4:	09 f4       	brne	.+2      	; 0x24a8 <AICI_InterpretPacket+0x1c>
    24a6:	fa c0       	rjmp	.+500    	; 0x269c <AICI_InterpretPacket+0x210>
    24a8:	87 31       	cpi	r24, 0x17	; 23
    24aa:	91 05       	cpc	r25, r1
    24ac:	94 f4       	brge	.+36     	; 0x24d2 <AICI_InterpretPacket+0x46>
    24ae:	82 31       	cpi	r24, 0x12	; 18
    24b0:	91 05       	cpc	r25, r1
    24b2:	09 f4       	brne	.+2      	; 0x24b6 <AICI_InterpretPacket+0x2a>
    24b4:	5f c0       	rjmp	.+190    	; 0x2574 <AICI_InterpretPacket+0xe8>
    24b6:	83 31       	cpi	r24, 0x13	; 19
    24b8:	91 05       	cpc	r25, r1
    24ba:	3c f4       	brge	.+14     	; 0x24ca <AICI_InterpretPacket+0x3e>
    24bc:	80 31       	cpi	r24, 0x10	; 16
    24be:	91 05       	cpc	r25, r1
    24c0:	f9 f0       	breq	.+62     	; 0x2500 <AICI_InterpretPacket+0x74>
    24c2:	41 97       	sbiw	r24, 0x11	; 17
    24c4:	09 f4       	brne	.+2      	; 0x24c8 <AICI_InterpretPacket+0x3c>
    24c6:	3c c0       	rjmp	.+120    	; 0x2540 <AICI_InterpretPacket+0xb4>
    24c8:	3d c1       	rjmp	.+634    	; 0x2744 <AICI_InterpretPacket+0x2b8>
    24ca:	44 97       	sbiw	r24, 0x14	; 20
    24cc:	09 f4       	brne	.+2      	; 0x24d0 <AICI_InterpretPacket+0x44>
    24ce:	e6 c0       	rjmp	.+460    	; 0x269c <AICI_InterpretPacket+0x210>
    24d0:	2e c1       	rjmp	.+604    	; 0x272e <AICI_InterpretPacket+0x2a2>
    24d2:	89 31       	cpi	r24, 0x19	; 25
    24d4:	91 05       	cpc	r25, r1
    24d6:	09 f4       	brne	.+2      	; 0x24da <AICI_InterpretPacket+0x4e>
    24d8:	cb c0       	rjmp	.+406    	; 0x2670 <AICI_InterpretPacket+0x1e4>
    24da:	8a 31       	cpi	r24, 0x1A	; 26
    24dc:	91 05       	cpc	r25, r1
    24de:	44 f4       	brge	.+16     	; 0x24f0 <AICI_InterpretPacket+0x64>
    24e0:	87 31       	cpi	r24, 0x17	; 23
    24e2:	91 05       	cpc	r25, r1
    24e4:	09 f4       	brne	.+2      	; 0x24e8 <AICI_InterpretPacket+0x5c>
    24e6:	c4 c0       	rjmp	.+392    	; 0x2670 <AICI_InterpretPacket+0x1e4>
    24e8:	48 97       	sbiw	r24, 0x18	; 24
    24ea:	09 f4       	brne	.+2      	; 0x24ee <AICI_InterpretPacket+0x62>
    24ec:	a4 c0       	rjmp	.+328    	; 0x2636 <AICI_InterpretPacket+0x1aa>
    24ee:	2a c1       	rjmp	.+596    	; 0x2744 <AICI_InterpretPacket+0x2b8>
    24f0:	8d 31       	cpi	r24, 0x1D	; 29
    24f2:	91 05       	cpc	r25, r1
    24f4:	0c f4       	brge	.+2      	; 0x24f8 <AICI_InterpretPacket+0x6c>
    24f6:	9f c0       	rjmp	.+318    	; 0x2636 <AICI_InterpretPacket+0x1aa>
    24f8:	4d 97       	sbiw	r24, 0x1d	; 29
    24fa:	09 f4       	brne	.+2      	; 0x24fe <AICI_InterpretPacket+0x72>
    24fc:	60 c0       	rjmp	.+192    	; 0x25be <AICI_InterpretPacket+0x132>
    24fe:	22 c1       	rjmp	.+580    	; 0x2744 <AICI_InterpretPacket+0x2b8>
	{
		case CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
    2500:	82 e0       	ldi	r24, 0x02	; 2
    2502:	90 e0       	ldi	r25, 0x00	; 0
    2504:	90 93 33 01 	sts	0x0133, r25
    2508:	80 93 32 01 	sts	0x0132, r24
			
			USI_SPIInitMaster(eeprom_read_byte_169(&Param_SCKDuration));
    250c:	80 e2       	ldi	r24, 0x20	; 32
    250e:	91 e0       	ldi	r25, 0x01	; 1
    2510:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
    2514:	0e 94 a1 09 	call	0x1342 <USI_SPIInitMaster>

			MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);  // Pull the slave AVR's RESET line to active
    2518:	80 e0       	ldi	r24, 0x00	; 0
    251a:	0e 94 15 03 	call	0x62a <MAIN_ResetCSLine>
			MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE); // Orange = Busy
    251e:	81 b3       	in	r24, 0x11	; 17
    2520:	80 63       	ori	r24, 0x30	; 48
    2522:	81 bb       	out	0x11, r24	; 17
			ISPCC_EnterChipProgrammingMode();       // Run the Enter Programming Mode routine
    2524:	0e 94 b0 10 	call	0x2160 <ISPCC_EnterChipProgrammingMode>

			if (InProgrammingMode)
    2528:	80 91 31 01 	lds	r24, 0x0131
    252c:	88 23       	and	r24, r24
    252e:	19 f0       	breq	.+6      	; 0x2536 <AICI_InterpretPacket+0xaa>
			   LCD_puts_f(AVRISPModeMessage);
    2530:	84 ee       	ldi	r24, 0xE4	; 228
    2532:	93 e0       	ldi	r25, 0x03	; 3
    2534:	02 c0       	rjmp	.+4      	; 0x253a <AICI_InterpretPacket+0xae>
			else
			   LCD_puts_f(SyncErrorMessage);
    2536:	89 ed       	ldi	r24, 0xD9	; 217
    2538:	93 e0       	ldi	r25, 0x03	; 3
    253a:	0e 94 fa 07 	call	0xff4 <LCD_puts_f>
			
			break;
    253e:	0b c1       	rjmp	.+534    	; 0x2756 <AICI_InterpretPacket+0x2ca>
		case CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;
    2540:	82 e0       	ldi	r24, 0x02	; 2
    2542:	90 e0       	ldi	r25, 0x00	; 0
    2544:	90 93 33 01 	sts	0x0133, r25
    2548:	80 93 32 01 	sts	0x0132, r24

			MAIN_Delay1MS(PacketBytes[1]);           // Wait for the "PreDelay" amount specified in the packet
    254c:	80 91 37 01 	lds	r24, 0x0137
    2550:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Non programming mode = green status led
    2554:	81 b3       	in	r24, 0x11	; 17
    2556:	8f 7c       	andi	r24, 0xCF	; 207
    2558:	80 61       	ori	r24, 0x10	; 16
    255a:	81 bb       	out	0x11, r24	; 17
			InProgrammingMode = FALSE;
    255c:	10 92 31 01 	sts	0x0131, r1
			MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run
    2560:	81 e0       	ldi	r24, 0x01	; 1
    2562:	0e 94 15 03 	call	0x62a <MAIN_ResetCSLine>
			MAIN_Delay1MS(PacketBytes[2]);           // Wait for the "PostDelay" amount specified in the packet
    2566:	80 91 38 01 	lds	r24, 0x0138
    256a:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
			
			USI_SPIOff();
    256e:	0e 94 b9 09 	call	0x1372 <USI_SPIOff>
    2572:	e5 c0       	rjmp	.+458    	; 0x273e <AICI_InterpretPacket+0x2b2>

			PacketBytes[1] = STATUS_CMD_OK;      // Return OK

			break;
		case CMD_CHIP_ERASE_ISP:
			MessageSize = 2;
    2574:	82 e0       	ldi	r24, 0x02	; 2
    2576:	90 e0       	ldi	r25, 0x00	; 0
    2578:	90 93 33 01 	sts	0x0133, r25
    257c:	80 93 32 01 	sts	0x0132, r24
			
			for (uint8_t PacketB = 3; PacketB <= 6; PacketB++) // Send the erase commands to the slave AVR
    2580:	c3 e0       	ldi	r28, 0x03	; 3
    2582:	09 e3       	ldi	r16, 0x39	; 57
    2584:	11 e0       	ldi	r17, 0x01	; 1
				USI_SPITransmit(PacketBytes[PacketB]);
    2586:	f8 01       	movw	r30, r16
    2588:	81 91       	ld	r24, Z+
    258a:	8f 01       	movw	r16, r30
    258c:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    2590:	c1 50       	subi	r28, 0x01	; 1
    2592:	c7 ff       	sbrs	r28, 7
    2594:	f8 cf       	rjmp	.-16     	; 0x2586 <AICI_InterpretPacket+0xfa>

			if (PacketBytes[2])                  // Poll mode, value of 1 indicates a busy flag wait
    2596:	80 91 38 01 	lds	r24, 0x0138
    259a:	88 23       	and	r24, r24
    259c:	59 f0       	breq	.+22     	; 0x25b4 <AICI_InterpretPacket+0x128>
			{
				do
					USI_SPITransmitWord(0xF000);
    259e:	80 e0       	ldi	r24, 0x00	; 0
    25a0:	90 ef       	ldi	r25, 0xF0	; 240
    25a2:	0e 94 ee 09 	call	0x13dc <USI_SPITransmitWord>
    25a6:	80 e0       	ldi	r24, 0x00	; 0
    25a8:	90 e0       	ldi	r25, 0x00	; 0
    25aa:	0e 94 ee 09 	call	0x13dc <USI_SPITransmitWord>
    25ae:	80 fd       	sbrc	r24, 0
    25b0:	f6 cf       	rjmp	.-20     	; 0x259e <AICI_InterpretPacket+0x112>
    25b2:	c5 c0       	rjmp	.+394    	; 0x273e <AICI_InterpretPacket+0x2b2>
				while (USI_SPITransmitWord(0x0000) & 0x01);
			}
			else                                // Poll mode flag of 0 indicates a predefined delay
			{
				MAIN_Delay1MS(PacketBytes[1]);   // Wait the specified interval to ensure erase complete
    25b4:	80 91 37 01 	lds	r24, 0x0137
    25b8:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    25bc:	c0 c0       	rjmp	.+384    	; 0x273e <AICI_InterpretPacket+0x2b2>
			}
			
			PacketBytes[1] = STATUS_CMD_OK;      // Always return OK
			
			break;
		case CMD_SPI_MULTI:
				MessageSize = (3 + PacketBytes[2]);    // Number of recieved bytes, plus two OKs and the command byte
    25be:	e0 90 38 01 	lds	r14, 0x0138
    25c2:	8e 2d       	mov	r24, r14
    25c4:	99 27       	eor	r25, r25
    25c6:	03 96       	adiw	r24, 0x03	; 3
    25c8:	90 93 33 01 	sts	0x0133, r25
    25cc:	80 93 32 01 	sts	0x0132, r24
		
				uint8_t TxBytes      = PacketBytes[1]; // \. The packet data is overwritten during the transfer. Because
    25d0:	00 91 37 01 	lds	r16, 0x0137
				uint8_t RxStartByte  = PacketBytes[2]; // |  of this each data byte must be stored into temp variables
				uint8_t RxBytes      = PacketBytes[3]; // /  so that their contents are not lost.
    25d4:	f0 90 39 01 	lds	r15, 0x0139
				uint8_t RxByteNum    = 1;
    25d8:	c1 e0       	ldi	r28, 0x01	; 1
				uint8_t TxByteNum    = 1;
				uint8_t RecievedByte = 0;

				while (TxByteNum++ < TxBytes)          // Still bytes to transfer
				{
					RecievedByte = USI_SPITransmit(PacketBytes[3 + TxByteNum]); // Transmit the byte, store the answer

					if ((TxByteNum >= RxStartByte) && (RxByteNum < RxBytes))
					   PacketBytes[2 + RxByteNum++] = RecievedByte;
    25da:	12 e0       	ldi	r17, 0x02	; 2
    25dc:	c0 17       	cp	r28, r16
    25de:	a8 f4       	brcc	.+42     	; 0x260a <AICI_InterpretPacket+0x17e>
    25e0:	e1 2f       	mov	r30, r17
    25e2:	ff 27       	eor	r31, r31
    25e4:	ea 5c       	subi	r30, 0xCA	; 202
    25e6:	fe 4f       	sbci	r31, 0xFE	; 254
    25e8:	83 81       	ldd	r24, Z+3	; 0x03
    25ea:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    25ee:	1e 15       	cp	r17, r14
    25f0:	40 f0       	brcs	.+16     	; 0x2602 <AICI_InterpretPacket+0x176>
    25f2:	cf 15       	cp	r28, r15
    25f4:	30 f4       	brcc	.+12     	; 0x2602 <AICI_InterpretPacket+0x176>
    25f6:	ec 2f       	mov	r30, r28
    25f8:	ff 27       	eor	r31, r31
    25fa:	ea 5c       	subi	r30, 0xCA	; 202
    25fc:	fe 4f       	sbci	r31, 0xFE	; 254
    25fe:	82 83       	std	Z+2, r24	; 0x02
    2600:	cf 5f       	subi	r28, 0xFF	; 255
    2602:	81 2f       	mov	r24, r17
    2604:	1f 5f       	subi	r17, 0xFF	; 255
    2606:	80 17       	cp	r24, r16
    2608:	58 f3       	brcs	.-42     	; 0x25e0 <AICI_InterpretPacket+0x154>
				}

				while (RxByteNum++ < RxBytes)                         // Still more bytes to recieve
				   PacketBytes[2 + RxByteNum] = USI_SPITransmit(0x00); // its answer to be recorded (or more bytes than sent need responses), send dummy bytes to fetch the response(s)
    260a:	8c 2f       	mov	r24, r28
    260c:	cf 5f       	subi	r28, 0xFF	; 255
    260e:	8f 15       	cp	r24, r15
    2610:	50 f4       	brcc	.+20     	; 0x2626 <AICI_InterpretPacket+0x19a>
    2612:	0c 2f       	mov	r16, r28
    2614:	11 27       	eor	r17, r17
    2616:	0a 5c       	subi	r16, 0xCA	; 202
    2618:	1e 4f       	sbci	r17, 0xFE	; 254
    261a:	80 e0       	ldi	r24, 0x00	; 0
    261c:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    2620:	f8 01       	movw	r30, r16
    2622:	82 83       	std	Z+2, r24	; 0x02
    2624:	f2 cf       	rjmp	.-28     	; 0x260a <AICI_InterpretPacket+0x17e>

				PacketBytes[1]             = STATUS_CMD_OK; // Data should be encompassed
    2626:	10 92 37 01 	sts	0x0137, r1
				PacketBytes[3 + RxByteNum] = STATUS_CMD_OK; //  by STATS_CMD_OKs
    262a:	ec 2f       	mov	r30, r28
    262c:	ff 27       	eor	r31, r31
    262e:	ea 5c       	subi	r30, 0xCA	; 202
    2630:	fe 4f       	sbci	r31, 0xFE	; 254
    2632:	13 82       	std	Z+3, r1	; 0x03

				break;
    2634:	90 c0       	rjmp	.+288    	; 0x2756 <AICI_InterpretPacket+0x2ca>
		case CMD_READ_SIGNATURE_ISP:
		case CMD_READ_FUSE_ISP:
		case CMD_READ_LOCK_ISP:
		case CMD_READ_OSCCAL_ISP:
			MessageSize = 4;
    2636:	84 e0       	ldi	r24, 0x04	; 4
    2638:	90 e0       	ldi	r25, 0x00	; 0
    263a:	90 93 33 01 	sts	0x0133, r25
    263e:	80 93 32 01 	sts	0x0132, r24
	
			for(uint8_t ByteNum = 1; ByteNum <= 4; ByteNum++)
    2642:	c1 e0       	ldi	r28, 0x01	; 1
    2644:	08 e3       	ldi	r16, 0x38	; 56
    2646:	11 e0       	ldi	r17, 0x01	; 1
			{
				uint8_t Response = USI_SPITransmit(PacketBytes[1 + ByteNum]); // Transmit the four signature request bytes
    2648:	f8 01       	movw	r30, r16
    264a:	81 91       	ld	r24, Z+
    264c:	8f 01       	movw	r16, r30
    264e:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    2652:	98 2f       	mov	r25, r24

				if (ByteNum == PacketBytes[1])         // If the current byte is the requested signature byte, save the reponse in the packet
    2654:	80 91 37 01 	lds	r24, 0x0137
    2658:	c8 17       	cp	r28, r24
    265a:	11 f4       	brne	.+4      	; 0x2660 <AICI_InterpretPacket+0x1d4>
					PacketBytes[2] = Response;
    265c:	90 93 38 01 	sts	0x0138, r25
    2660:	cf 5f       	subi	r28, 0xFF	; 255
    2662:	c5 30       	cpi	r28, 0x05	; 5
    2664:	88 f3       	brcs	.-30     	; 0x2648 <AICI_InterpretPacket+0x1bc>
			}

			PacketBytes[1] = STATUS_CMD_OK;            // Data byte is encased in CMD_OKs
    2666:	10 92 37 01 	sts	0x0137, r1
			PacketBytes[3] = STATUS_CMD_OK;            // Data byte is encased in CMD_OKs
    266a:	10 92 39 01 	sts	0x0139, r1

			break;
    266e:	73 c0       	rjmp	.+230    	; 0x2756 <AICI_InterpretPacket+0x2ca>
		case CMD_PROGRAM_FUSE_ISP:
		case CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;
    2670:	83 e0       	ldi	r24, 0x03	; 3
    2672:	90 e0       	ldi	r25, 0x00	; 0
    2674:	90 93 33 01 	sts	0x0133, r25
    2678:	80 93 32 01 	sts	0x0132, r24
    267c:	07 e3       	ldi	r16, 0x37	; 55
    267e:	11 e0       	ldi	r17, 0x01	; 1
    2680:	c3 e0       	ldi	r28, 0x03	; 3
			
			for (uint8_t PacketB = 1; PacketB <= 4; PacketB++) // Send the lock-byte values to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    2682:	f8 01       	movw	r30, r16
    2684:	81 91       	ld	r24, Z+
    2686:	8f 01       	movw	r16, r30
    2688:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    268c:	c1 50       	subi	r28, 0x01	; 1
    268e:	c7 ff       	sbrs	r28, 7
    2690:	f8 cf       	rjmp	.-16     	; 0x2682 <AICI_InterpretPacket+0x1f6>

			PacketBytes[1] = STATUS_CMD_OK;            // Two CMD_OKs are always returned
    2692:	10 92 37 01 	sts	0x0137, r1
			PacketBytes[2] = STATUS_CMD_OK;            // Two CMD_OKs are always returned
    2696:	10 92 38 01 	sts	0x0138, r1

			break;
    269a:	5d c0       	rjmp	.+186    	; 0x2756 <AICI_InterpretPacket+0x2ca>
		case CMD_READ_FLASH_ISP:
		case CMD_READ_EEPROM_ISP:
			MessageSize = 0;                           // Here to prevent compiler from complaining if a var dec appears straight after a case

			uint8_t  ReadCommand = PacketBytes[3];
    269c:	d0 90 39 01 	lds	r13, 0x0139
			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8) // Load in the number of bytes that is to
    26a0:	80 91 37 01 	lds	r24, 0x0137
    26a4:	99 27       	eor	r25, r25
    26a6:	d8 2f       	mov	r29, r24
    26a8:	cc 27       	eor	r28, r28
    26aa:	80 91 38 01 	lds	r24, 0x0138
    26ae:	99 27       	eor	r25, r25
    26b0:	c8 2b       	or	r28, r24
    26b2:	d9 2b       	or	r29, r25
			                     | PacketBytes[2];                 // be read into a temp variable (MSB first)

			MessageSize = BytesToRead + 3;
    26b4:	23 96       	adiw	r28, 0x03	; 3
    26b6:	d0 93 33 01 	sts	0x0133, r29
    26ba:	c0 93 32 01 	sts	0x0132, r28
    26be:	23 97       	sbiw	r28, 0x03	; 3

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
    26c0:	00 e0       	ldi	r16, 0x00	; 0
    26c2:	10 e0       	ldi	r17, 0x00	; 0
    26c4:	0c 17       	cp	r16, r28
    26c6:	1d 07       	cpc	r17, r29
    26c8:	60 f5       	brcc	.+88     	; 0x2722 <AICI_InterpretPacket+0x296>
    26ca:	88 e3       	ldi	r24, 0x38	; 56
    26cc:	e8 2e       	mov	r14, r24
    26ce:	81 e0       	ldi	r24, 0x01	; 1
    26d0:	f8 2e       	mov	r15, r24
			{
				if (PacketBytes[0] == CMD_READ_FLASH_ISP)  // Flash read mode - word addresses so MSB/LSB masking nessesary
    26d2:	80 91 36 01 	lds	r24, 0x0136
    26d6:	84 31       	cpi	r24, 0x14	; 20
    26d8:	31 f4       	brne	.+12     	; 0x26e6 <AICI_InterpretPacket+0x25a>
				{
					USI_SPITransmit(ReadCommand | ((ReadByte & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ));
    26da:	8d 2d       	mov	r24, r13
    26dc:	99 27       	eor	r25, r25
    26de:	00 ff       	sbrs	r16, 0
    26e0:	03 c0       	rjmp	.+6      	; 0x26e8 <AICI_InterpretPacket+0x25c>
    26e2:	88 60       	ori	r24, 0x08	; 8
    26e4:	01 c0       	rjmp	.+2      	; 0x26e8 <AICI_InterpretPacket+0x25c>
				}
				else                                       // EEPROM read mode, address is in bytes and so no masking nessesary
				{
					USI_SPITransmit(ReadCommand);
    26e6:	8d 2d       	mov	r24, r13
    26e8:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
				}
				
				USI_SPITransmitWord(CurrAddress);          // Transmit the current address to the slave AVR
    26ec:	80 91 2d 01 	lds	r24, 0x012D
    26f0:	90 91 2e 01 	lds	r25, 0x012E
    26f4:	0e 94 ee 09 	call	0x13dc <USI_SPITransmitWord>

				PacketBytes[2 + ReadByte] = USI_SPITransmit(0x00); // Read in the byte stored at the requested location
    26f8:	80 e0       	ldi	r24, 0x00	; 0
    26fa:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    26fe:	f7 01       	movw	r30, r14
    2700:	80 83       	st	Z, r24

				if ((ReadByte & 0x01) || (PacketBytes[0] == CMD_READ_EEPROM_ISP)) // Flash addresses are given in words; only increment on the odd byte if reading the flash.
    2702:	00 fd       	sbrc	r16, 0
    2704:	04 c0       	rjmp	.+8      	; 0x270e <AICI_InterpretPacket+0x282>
    2706:	80 91 36 01 	lds	r24, 0x0136
    270a:	86 31       	cpi	r24, 0x16	; 22
    270c:	11 f4       	brne	.+4      	; 0x2712 <AICI_InterpretPacket+0x286>
				{
					V2P_IncrementCurrAddress();             // Increment the address counter
    270e:	0e 94 13 0f 	call	0x1e26 <V2P_IncrementCurrAddress>
    2712:	0f 5f       	subi	r16, 0xFF	; 255
    2714:	1f 4f       	sbci	r17, 0xFF	; 255
    2716:	08 94       	sec
    2718:	e1 1c       	adc	r14, r1
    271a:	f1 1c       	adc	r15, r1
    271c:	0c 17       	cp	r16, r28
    271e:	1d 07       	cpc	r17, r29
    2720:	c0 f2       	brcs	.-80     	; 0x26d2 <AICI_InterpretPacket+0x246>
				}
				else
				{
					if ((CurrAddress & 0x00FF0000) & !(CurrAddress & 0x0000FFFF))
					{
						CurrAddress |= (1UL << 31);        // Set MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
						V2P_CheckForExtendedAddress();
					}
				}
			}
			
			PacketBytes[1]               = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    2722:	10 92 37 01 	sts	0x0137, r1
			PacketBytes[2 + BytesToRead] = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    2726:	ca 5c       	subi	r28, 0xCA	; 202
    2728:	de 4f       	sbci	r29, 0xFE	; 254
    272a:	1a 82       	std	Y+2, r1	; 0x02

			break;
    272c:	14 c0       	rjmp	.+40     	; 0x2756 <AICI_InterpretPacket+0x2ca>
		case CMD_PROGRAM_FLASH_ISP:
		case CMD_PROGRAM_EEPROM_ISP:
			ISPCC_ProgramChip();                          // Program the bytes into the chip
    272e:	0e 94 58 11 	call	0x22b0 <ISPCC_ProgramChip>
			
			MessageSize = 2;
    2732:	82 e0       	ldi	r24, 0x02	; 2
    2734:	90 e0       	ldi	r25, 0x00	; 0
    2736:	90 93 33 01 	sts	0x0133, r25
    273a:	80 93 32 01 	sts	0x0132, r24

			PacketBytes[1] = STATUS_CMD_OK;
    273e:	10 92 37 01 	sts	0x0137, r1
			
			break;
    2742:	09 c0       	rjmp	.+18     	; 0x2756 <AICI_InterpretPacket+0x2ca>
		default:                                        // Unknown command, return error
			MessageSize = 1;
    2744:	81 e0       	ldi	r24, 0x01	; 1
    2746:	90 e0       	ldi	r25, 0x00	; 0
    2748:	90 93 33 01 	sts	0x0133, r25
    274c:	80 93 32 01 	sts	0x0132, r24
			
			PacketBytes[1] = STATUS_CMD_UNKNOWN;
    2750:	89 ec       	ldi	r24, 0xC9	; 201
    2752:	80 93 37 01 	sts	0x0137, r24
	}

	V2P_SendPacket();                                   // Send the response packet
    2756:	0e 94 39 0e 	call	0x1c72 <V2P_SendPacket>
    275a:	df 91       	pop	r29
    275c:	cf 91       	pop	r28
    275e:	1f 91       	pop	r17
    2760:	0f 91       	pop	r16
    2762:	ff 90       	pop	r15
    2764:	ef 90       	pop	r14
    2766:	df 90       	pop	r13
    2768:	08 95       	ret

0000276a <PM_GetStoredDataSize>:

// ======================================================================================

uint32_t PM_GetStoredDataSize(uint8_t Type)
{
    276a:	ef 92       	push	r14
    276c:	ff 92       	push	r15
    276e:	0f 93       	push	r16
    2770:	1f 93       	push	r17
    2772:	cf 93       	push	r28
    2774:	df 93       	push	r29
    2776:	cd b7       	in	r28, 0x3d	; 61
    2778:	de b7       	in	r29, 0x3e	; 62
    277a:	22 97       	sbiw	r28, 0x02	; 2
    277c:	0f b6       	in	r0, 0x3f	; 63
    277e:	f8 94       	cli
    2780:	de bf       	out	0x3e, r29	; 62
    2782:	0f be       	out	0x3f, r0	; 63
    2784:	cd bf       	out	0x3d, r28	; 61
	/* This take a **LOT** of code (202 bytes), and is accessed several times throughout
	   the program, so I've put it into a seperate function to save on flash.            */

	uint32_t ProgDataSize  = 0;
	uint16_t EEPROMAddress;

	EEPROMAddress = ((Type == TYPE_FLASH)? Prog_DataSize : Prog_EEPROMSize);
    2786:	81 30       	cpi	r24, 0x01	; 1
    2788:	29 f4       	brne	.+10     	; 0x2794 <PM_GetStoredDataSize+0x2a>
    278a:	80 91 16 01 	lds	r24, 0x0116
    278e:	90 91 17 01 	lds	r25, 0x0117
    2792:	04 c0       	rjmp	.+8      	; 0x279c <PM_GetStoredDataSize+0x32>
    2794:	80 91 14 01 	lds	r24, 0x0114
    2798:	90 91 15 01 	lds	r25, 0x0115
    279c:	9a 83       	std	Y+2, r25	; 0x02
    279e:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize  = ((uint32_t)eeprom_read_byte_169(&EEPROMAddress) << 24);
    27a0:	ce 01       	movw	r24, r28
    27a2:	01 96       	adiw	r24, 0x01	; 1
    27a4:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
    27a8:	99 27       	eor	r25, r25
    27aa:	aa 27       	eor	r26, r26
    27ac:	bb 27       	eor	r27, r27
    27ae:	18 2f       	mov	r17, r24
    27b0:	00 27       	eor	r16, r16
    27b2:	ff 24       	eor	r15, r15
    27b4:	ee 24       	eor	r14, r14
	EEPROMAddress++;
    27b6:	89 81       	ldd	r24, Y+1	; 0x01
    27b8:	9a 81       	ldd	r25, Y+2	; 0x02
    27ba:	01 96       	adiw	r24, 0x01	; 1
    27bc:	9a 83       	std	Y+2, r25	; 0x02
    27be:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize |= ((uint32_t)eeprom_read_byte_169(&EEPROMAddress) << 16);
    27c0:	ce 01       	movw	r24, r28
    27c2:	01 96       	adiw	r24, 0x01	; 1
    27c4:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
    27c8:	99 27       	eor	r25, r25
    27ca:	aa 27       	eor	r26, r26
    27cc:	bb 27       	eor	r27, r27
    27ce:	dc 01       	movw	r26, r24
    27d0:	99 27       	eor	r25, r25
    27d2:	88 27       	eor	r24, r24
    27d4:	e8 2a       	or	r14, r24
    27d6:	f9 2a       	or	r15, r25
    27d8:	0a 2b       	or	r16, r26
    27da:	1b 2b       	or	r17, r27
	EEPROMAddress++;
    27dc:	89 81       	ldd	r24, Y+1	; 0x01
    27de:	9a 81       	ldd	r25, Y+2	; 0x02
    27e0:	01 96       	adiw	r24, 0x01	; 1
    27e2:	9a 83       	std	Y+2, r25	; 0x02
    27e4:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize |= ((uint32_t)eeprom_read_byte_169(&EEPROMAddress) << 8);
    27e6:	ce 01       	movw	r24, r28
    27e8:	01 96       	adiw	r24, 0x01	; 1
    27ea:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
    27ee:	99 27       	eor	r25, r25
    27f0:	aa 27       	eor	r26, r26
    27f2:	bb 27       	eor	r27, r27
    27f4:	ba 2f       	mov	r27, r26
    27f6:	a9 2f       	mov	r26, r25
    27f8:	98 2f       	mov	r25, r24
    27fa:	88 27       	eor	r24, r24
    27fc:	e8 2a       	or	r14, r24
    27fe:	f9 2a       	or	r15, r25
    2800:	0a 2b       	or	r16, r26
    2802:	1b 2b       	or	r17, r27
	EEPROMAddress++;
    2804:	89 81       	ldd	r24, Y+1	; 0x01
    2806:	9a 81       	ldd	r25, Y+2	; 0x02
    2808:	01 96       	adiw	r24, 0x01	; 1
    280a:	9a 83       	std	Y+2, r25	; 0x02
    280c:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize |= eeprom_read_byte_169(&EEPROMAddress);
    280e:	ce 01       	movw	r24, r28
    2810:	01 96       	adiw	r24, 0x01	; 1
    2812:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
    2816:	99 27       	eor	r25, r25
    2818:	aa 27       	eor	r26, r26
    281a:	bb 27       	eor	r27, r27
    281c:	e8 2a       	or	r14, r24
    281e:	f9 2a       	or	r15, r25
    2820:	0a 2b       	or	r16, r26
    2822:	1b 2b       	or	r17, r27

	if (ProgDataSize == 0xFFFFFFFF)                                      // Blank EEPROM, return a size  of 0 bytes
    2824:	8f ef       	ldi	r24, 0xFF	; 255
    2826:	e8 16       	cp	r14, r24
    2828:	8f ef       	ldi	r24, 0xFF	; 255
    282a:	f8 06       	cpc	r15, r24
    282c:	8f ef       	ldi	r24, 0xFF	; 255
    282e:	08 07       	cpc	r16, r24
    2830:	8f ef       	ldi	r24, 0xFF	; 255
    2832:	18 07       	cpc	r17, r24
    2834:	19 f4       	brne	.+6      	; 0x283c <PM_GetStoredDataSize+0xd2>
	   ProgDataSize = 0x00;
    2836:	ee 24       	eor	r14, r14
    2838:	ff 24       	eor	r15, r15
    283a:	87 01       	movw	r16, r14

	return ProgDataSize;
}
    283c:	c8 01       	movw	r24, r16
    283e:	b7 01       	movw	r22, r14
    2840:	22 96       	adiw	r28, 0x02	; 2
    2842:	0f b6       	in	r0, 0x3f	; 63
    2844:	f8 94       	cli
    2846:	de bf       	out	0x3e, r29	; 62
    2848:	0f be       	out	0x3f, r0	; 63
    284a:	cd bf       	out	0x3d, r28	; 61
    284c:	df 91       	pop	r29
    284e:	cf 91       	pop	r28
    2850:	1f 91       	pop	r17
    2852:	0f 91       	pop	r16
    2854:	ff 90       	pop	r15
    2856:	ef 90       	pop	r14
    2858:	08 95       	ret

0000285a <PM_SetupDFAddressCounters>:

void PM_SetupDFAddressCounters(uint8_t Type)
{
	uint32_t StartAddress;

	MemoryType   = Type;
    285a:	80 93 4c 02 	sts	0x024C, r24
	PageLength   = 0;
    285e:	10 92 4a 02 	sts	0x024A, r1
    2862:	10 92 49 02 	sts	0x0249, r1
    2866:	20 91 2d 01 	lds	r18, 0x012D
    286a:	30 91 2e 01 	lds	r19, 0x012E
    286e:	40 91 2f 01 	lds	r20, 0x012F
    2872:	50 91 30 01 	lds	r21, 0x0130

	if (Type == TYPE_FLASH)                                              // Type 1 = Flash
    2876:	81 30       	cpi	r24, 0x01	; 1
    2878:	39 f4       	brne	.+14     	; 0x2888 <PM_SetupDFAddressCounters+0x2e>
		StartAddress = (CurrAddress << 1);                               // Convert flash word address to byte address
    287a:	da 01       	movw	r26, r20
    287c:	c9 01       	movw	r24, r18
    287e:	88 0f       	add	r24, r24
    2880:	99 1f       	adc	r25, r25
    2882:	aa 1f       	adc	r26, r26
    2884:	bb 1f       	adc	r27, r27
    2886:	06 c0       	rjmp	.+12     	; 0x2894 <PM_SetupDFAddressCounters+0x3a>
	else
		StartAddress = CurrAddress + PM_EEPROM_OFFSET;                   // EEPROM uses byte addresses, and starts at the 257th kilobyte in Dataflash
    2888:	da 01       	movw	r26, r20
    288a:	c9 01       	movw	r24, r18
    288c:	80 50       	subi	r24, 0x00	; 0
    288e:	9c 4f       	sbci	r25, 0xFC	; 252
    2890:	ab 4f       	sbci	r26, 0xFB	; 251
    2892:	bf 4f       	sbci	r27, 0xFF	; 255
	
	CurrPageAddress = 0;
    2894:	10 92 8c 02 	sts	0x028C, r1
    2898:	10 92 8b 02 	sts	0x028B, r1

	while (StartAddress > DF_INTERNALDF_BUFFBYTES)                      // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DF_INTERNALDF_BUFFBYTES;                         // Subtract one page's worth of bytes from the desired address
		CurrPageAddress++;
    289c:	89 30       	cpi	r24, 0x09	; 9
    289e:	21 e0       	ldi	r18, 0x01	; 1
    28a0:	92 07       	cpc	r25, r18
    28a2:	20 e0       	ldi	r18, 0x00	; 0
    28a4:	a2 07       	cpc	r26, r18
    28a6:	20 e0       	ldi	r18, 0x00	; 0
    28a8:	b2 07       	cpc	r27, r18
    28aa:	a0 f0       	brcs	.+40     	; 0x28d4 <PM_SetupDFAddressCounters+0x7a>
    28ac:	20 e0       	ldi	r18, 0x00	; 0
    28ae:	30 e0       	ldi	r19, 0x00	; 0
    28b0:	88 50       	subi	r24, 0x08	; 8
    28b2:	91 40       	sbci	r25, 0x01	; 1
    28b4:	a0 40       	sbci	r26, 0x00	; 0
    28b6:	b0 40       	sbci	r27, 0x00	; 0
    28b8:	2f 5f       	subi	r18, 0xFF	; 255
    28ba:	3f 4f       	sbci	r19, 0xFF	; 255
    28bc:	89 30       	cpi	r24, 0x09	; 9
    28be:	41 e0       	ldi	r20, 0x01	; 1
    28c0:	94 07       	cpc	r25, r20
    28c2:	40 e0       	ldi	r20, 0x00	; 0
    28c4:	a4 07       	cpc	r26, r20
    28c6:	40 e0       	ldi	r20, 0x00	; 0
    28c8:	b4 07       	cpc	r27, r20
    28ca:	90 f7       	brcc	.-28     	; 0x28b0 <PM_SetupDFAddressCounters+0x56>
    28cc:	30 93 8c 02 	sts	0x028C, r19
    28d0:	20 93 8b 02 	sts	0x028B, r18
	}
	
	CurrBuffByte = (uint16_t)StartAddress;                               // The buffer byte is the remainder
    28d4:	90 93 85 02 	sts	0x0285, r25
    28d8:	80 93 84 02 	sts	0x0284, r24
    28dc:	08 95       	ret

000028de <PM_StoreProgramByte>:
}

void PM_StoreProgramByte(uint8_t Data)
{
    28de:	cf 93       	push	r28
    28e0:	c8 2f       	mov	r28, r24
	if (CurrBuffByte == DF_INTERNALDF_BUFFBYTES)
    28e2:	80 91 84 02 	lds	r24, 0x0284
    28e6:	90 91 85 02 	lds	r25, 0x0285
    28ea:	88 50       	subi	r24, 0x08	; 8
    28ec:	91 40       	sbci	r25, 0x01	; 1
    28ee:	a9 f4       	brne	.+42     	; 0x291a <PM_StoreProgramByte+0x3c>
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
    28f0:	80 91 8b 02 	lds	r24, 0x028B
    28f4:	90 91 8c 02 	lds	r25, 0x028C
    28f8:	9c 01       	movw	r18, r24
    28fa:	01 96       	adiw	r24, 0x01	; 1
    28fc:	90 93 8c 02 	sts	0x028C, r25
    2900:	80 93 8b 02 	sts	0x028B, r24
    2904:	c9 01       	movw	r24, r18
    2906:	0e 94 72 0b 	call	0x16e4 <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    290a:	80 e0       	ldi	r24, 0x00	; 0
    290c:	90 e0       	ldi	r25, 0x00	; 0
    290e:	0e 94 92 0a 	call	0x1524 <DF_BufferWriteEnable>
		CurrBuffByte = 0;
    2912:	10 92 85 02 	sts	0x0285, r1
    2916:	10 92 84 02 	sts	0x0284, r1
	}
	
	SPI_SPITransmit(Data);                                               // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    291a:	8c 2f       	mov	r24, r28
    291c:	0e 94 3d 09 	call	0x127a <SPI_SPITransmit>
	CurrBuffByte++;
    2920:	80 91 84 02 	lds	r24, 0x0284
    2924:	90 91 85 02 	lds	r25, 0x0285
    2928:	01 96       	adiw	r24, 0x01	; 1
    292a:	90 93 85 02 	sts	0x0285, r25
    292e:	80 93 84 02 	sts	0x0284, r24
	PageLength++;
    2932:	80 91 49 02 	lds	r24, 0x0249
    2936:	90 91 4a 02 	lds	r25, 0x024A
    293a:	01 96       	adiw	r24, 0x01	; 1
    293c:	90 93 4a 02 	sts	0x024A, r25
    2940:	80 93 49 02 	sts	0x0249, r24
    2944:	cf 91       	pop	r28
    2946:	08 95       	ret

00002948 <PM_CheckEndOfProgramming>:
}

void PM_InterpretAVRISPPacket(void)
{
	uint16_t EEPROMAddress;

	switch (PacketBytes[0])
	{
		case CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
			
			EEPROMAddress = Prog_EnterProgMode;
			
			for (uint8_t PacketB = 0; PacketB <= 11; PacketB++)          // Save the enter programming mode command bytes
			{
				eeprom_write_byte_169(&EEPROMAddress, PacketBytes[PacketB]);
				EEPROMAddress++;
			}
			
			InProgrammingMode = TRUE;                                    // Set the flag, prevent the user from exiting the V2P state machine			
			CurrentMode = PM_NO_SETUP;                                   // Clear the current mode variable

			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = STATUS_CMD_OK;

			break;			
		case CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;

			PM_CheckEndOfProgramming();                                  // Check if the last command was a program - if so store the program length
			PM_CheckEndOfFuseLockStore();                                // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
			
			InProgrammingMode = FALSE;                                   // Clear the flag, allow the user to exit the V2P state machine

			DF_EnableDataflash(FALSE);

			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
			PacketBytes[1] = STATUS_CMD_OK;

			break;
		case CMD_READ_SIGNATURE_ISP:
			MessageSize = 4;

			PacketBytes[1] = STATUS_CMD_OK;                              // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x01;                                       // Signature bytes all return "01" in storage mode
			PacketBytes[3] = STATUS_CMD_OK;                              // Data byte is encased in CMD_OKs

			break;
		case CMD_CHIP_ERASE_ISP:
			MessageSize = 2;

			EEPROMAddress = Prog_EraseChip;                              // Program erase chip command start address
			
			for (uint8_t PacketB = 1; PacketB <= 6; PacketB++)          // Save the erase chip command bytes to EEPROM
			{
				eeprom_write_byte_169(&EEPROMAddress, PacketBytes[PacketB]);
				EEPROMAddress++;
			}

			EEPROMAddress = Prog_DataSize;
										
			for (uint8_t Byte = 0; Byte < 8; Byte++)                    // Clear the program and EEPROM size counters
			{
				if (Byte == 4)
				   EEPROMAddress = Prog_EEPROMSize;

				eeprom_write_byte_169(&EEPROMAddress, 0x00);
				EEPROMAddress++;						
			}
			
			eeprom_write_byte_169(&Prog_EraseCmdStored, TRUE);
			
			PacketBytes[1] = STATUS_CMD_OK;
			
			break;
		case CMD_READ_OSCCAL_ISP:
			MessageSize = 4;

			PacketBytes[1] = STATUS_CMD_OK;                             // Data byte is encased in CMD_OKs
			PacketBytes[1] = 0x00;                                      // Return 0x00 for the OSCCAL byte
			PacketBytes[3] = STATUS_CMD_OK;                             // Data byte is encased in CMD_OKs

			break;
		case CMD_READ_FUSE_ISP:
		case CMD_READ_LOCK_ISP:
			MessageSize = 4;
	
			if (CurrentMode != PM_LOCKFUSEBITS_READ)                    // First lock or fuse byte being read, set the EEPROM pointer
			{
				PM_CheckEndOfProgramming();                             // Check if the last command was a program - if so store the program length
				PM_CheckEndOfFuseLockStore();                           // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
				
				CurrBuffByte = 0;
				CurrentMode  = PM_LOCKFUSEBITS_READ;
			}
			
			EEPROMAddress = ((PacketBytes[0] == CMD_READ_FUSE_ISP)? Prog_TotalFuseBytes : Prog_TotalLockBytes);

			if (CurrBuffByte > eeprom_read_byte_169(&EEPROMAddress))    // Trying to read more fuse/lock bytes than are stored in memory
			{
				PacketBytes[2] = 0xFF;                                  // Return 0xFF for the fuse/lock byte
			}
			else
			{
				EEPROMAddress  = ((PacketBytes[0] == CMD_READ_FUSE_ISP)? Prog_FuseBytes : Prog_LockBytes) // Starting location
									+ (CurrBuffByte << 2) + (PacketBytes[1] - 1); // The start position of the actual fuse/lock byte to read (4 bytes each)

				PacketBytes[2] = eeprom_read_byte_169(&EEPROMAddress); // Return the fuse/lock byte
			}

			PacketBytes[1] = STATUS_CMD_OK;                            // Data byte is encased in CMD_OKs
			PacketBytes[3] = STATUS_CMD_OK;                            // Data byte is encased in CMD_OKs

			CurrBuffByte++;

			break;
		case CMD_PROGRAM_FUSE_ISP:
		case CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;

			if (CurrentMode != PM_LOCKFUSEBITS_WRITE)                  // First lock or fuse byte being written, set the EEPROM pointer
			{
				CurrentMode   = PM_LOCKFUSEBITS_WRITE;
				CurrBuffByte  = 0;                                     // CurrBuffByte is used to store the total fuse/lock bytes written
			}

			if (PacketBytes[0] == CMD_PROGRAM_FUSE_ISP)
			{
				EEPROMAddress = Prog_FuseBytes + (CurrBuffByte << 2);
				MemoryType    = TYPE_FUSE;
			}
			else
			{
				EEPROMAddress = Prog_LockBytes + (CurrBuffByte << 2);
				MemoryType    = TYPE_LOCK;
			}				
			
			if (CurrBuffByte < PM_MAX_FUSELOCKBITS)
			{
				for (uint8_t FLByte = 1; FLByte <= 4; FLByte++)
				{
					eeprom_write_byte_169(&EEPROMAddress, PacketBytes[FLByte]);
					EEPROMAddress++;
				}

				CurrBuffByte++;                                        // Increment the total fuse/lock bytes written counter
			}
			
			PacketBytes[1] = STATUS_CMD_OK;                            // Two CMD_OKs are always returned
			PacketBytes[2] = STATUS_CMD_OK;                            // Two CMD_OKs are always returned

			break;
		case CMD_PROGRAM_FLASH_ISP:
		case CMD_PROGRAM_EEPROM_ISP:
			MessageSize = 2;

			if (CurrentMode != PM_DATAFLASH_WRITE)                     // First programming packet
			{
				if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)           // Flash programming mode
				{
					EEPROMAddress = Prog_WriteProgram;                 // Set the eeprom address to the Program command bytes location
					PM_SetupDFAddressCounters(TYPE_FLASH);
				}
				else                                                  // EEPROM programming mode
				{
					EEPROMAddress = Prog_WriteEEPROM;                  // Set the eeprom address to the EEPROM command bytes location
					PM_SetupDFAddressCounters(TYPE_EEPROM);
				}
				
				DF_BufferWriteEnable(CurrBuffByte);
				CurrentMode = PM_DATAFLASH_WRITE;
				
				for (uint8_t B = 1; B <= 9; B++)                       // Save the command bytes
				{
					eeprom_write_byte_169(&EEPROMAddress, PacketBytes[B]);
					EEPROMAddress++;				
				}
			}

			uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
			                      | PacketBytes[2];

			for (uint16_t CurrByte = 0; CurrByte < BytesToWrite; CurrByte++)
				PM_StoreProgramByte(PacketBytes[10 + CurrByte]);
						
			if ((PacketBytes[3] & ISPCC_PROG_MODE_PAGEDONE) && !(PageLength & PM_PAGELENGTH_FOUNDBIT) && PageLength)
			{
				EEPROMAddress = ((MemoryType == TYPE_FLASH)? Prog_PageLength : Prog_EPageLength);
	
				eeprom_write_byte_169(&EEPROMAddress, (uint8_t)(PageLength >> 8));
				EEPROMAddress++;
				eeprom_write_byte_169(&EEPROMAddress, (uint8_t)PageLength);		
		
				PageLength |= PM_PAGELENGTH_FOUNDBIT;                 // Bit 15 is used to indicate if the length has been found
			}

			PacketBytes[1] = STATUS_CMD_OK;
		
			break;
		case CMD_READ_FLASH_ISP:
		case CMD_READ_EEPROM_ISP:	
			if (CurrentMode != PM_DATAFLASH_READ)
			{
				PM_CheckEndOfProgramming();                           // Check if the last command was a program - if so store the program length
				PM_CheckEndOfFuseLockStore();                         // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
				
				PM_SetupDFAddressCounters((PacketBytes[0] == CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);
				DF_ContinuousReadEnable(CurrPageAddress, CurrBuffByte);
				
				CurrentMode = PM_DATAFLASH_READ;
				CurrAddress = 0;
			}

			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8)    // \. Load in the number of bytes that is to
			                     | PacketBytes[2];                    // /  be read into a temp variable (MSB first)
						
			uint16_t BytesInMem  = PM_GetStoredDataSize((PacketBytes[0] == CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
			   PacketBytes[2 + ReadByte] = ((CurrAddress < BytesInMem)? SPI_SPITransmit(0x00) : 0xFF); // Read in the next dataflash byte if present
			   V2P_IncrementCurrAddress();
			}
			
			MessageSize = BytesToRead + 3;

			PacketBytes[1]               = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
			PacketBytes[2 + BytesToRead] = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
		
			break;
		default:
			MessageSize = 1;
			
			PacketBytes[1] = STATUS_CMD_UNKNOWN;
	}

	V2P_SendPacket();                                   // Send the response packet
}

void PM_CheckEndOfProgramming(void)
{
    2948:	ef 92       	push	r14
    294a:	ff 92       	push	r15
    294c:	0f 93       	push	r16
    294e:	1f 93       	push	r17
    2950:	cf 93       	push	r28
    2952:	df 93       	push	r29
    2954:	cd b7       	in	r28, 0x3d	; 61
    2956:	de b7       	in	r29, 0x3e	; 62
    2958:	22 97       	sbiw	r28, 0x02	; 2
    295a:	0f b6       	in	r0, 0x3f	; 63
    295c:	f8 94       	cli
    295e:	de bf       	out	0x3e, r29	; 62
    2960:	0f be       	out	0x3f, r0	; 63
    2962:	cd bf       	out	0x3d, r28	; 61
   uint16_t EEPROMAddress;

   if (CurrentMode == PM_DATAFLASH_WRITE)
    2964:	80 91 4b 02 	lds	r24, 0x024B
    2968:	81 30       	cpi	r24, 0x01	; 1
    296a:	09 f0       	breq	.+2      	; 0x296e <PM_CheckEndOfProgramming+0x26>
    296c:	6d c0       	rjmp	.+218    	; 0x2a48 <PM_CheckEndOfProgramming+0x100>
   {
      if (CurrBuffByte)                               // Data in the dataflash buffer, pending to be written
    296e:	80 91 84 02 	lds	r24, 0x0284
    2972:	90 91 85 02 	lds	r25, 0x0285
    2976:	89 2b       	or	r24, r25
    2978:	31 f0       	breq	.+12     	; 0x2986 <PM_CheckEndOfProgramming+0x3e>
         DF_CopyBufferToFlashPage(CurrPageAddress);   // Save the buffer
    297a:	80 91 8b 02 	lds	r24, 0x028B
    297e:	90 91 8c 02 	lds	r25, 0x028C
    2982:	0e 94 72 0b 	call	0x16e4 <DF_CopyBufferToFlashPage>

      uint32_t DataSize = ((uint32_t)CurrPageAddress * DF_INTERNALDF_BUFFBYTES) + CurrBuffByte;
    2986:	80 91 8b 02 	lds	r24, 0x028B
    298a:	90 91 8c 02 	lds	r25, 0x028C
    298e:	aa 27       	eor	r26, r26
    2990:	bb 27       	eor	r27, r27
    2992:	bc 01       	movw	r22, r24
    2994:	cd 01       	movw	r24, r26
    2996:	28 e0       	ldi	r18, 0x08	; 8
    2998:	31 e0       	ldi	r19, 0x01	; 1
    299a:	40 e0       	ldi	r20, 0x00	; 0
    299c:	50 e0       	ldi	r21, 0x00	; 0
    299e:	0e 94 a4 1b 	call	0x3748 <__mulsi3>
    29a2:	7b 01       	movw	r14, r22
    29a4:	8c 01       	movw	r16, r24
    29a6:	80 91 84 02 	lds	r24, 0x0284
    29aa:	90 91 85 02 	lds	r25, 0x0285
    29ae:	aa 27       	eor	r26, r26
    29b0:	bb 27       	eor	r27, r27
    29b2:	e8 0e       	add	r14, r24
    29b4:	f9 1e       	adc	r15, r25
    29b6:	0a 1f       	adc	r16, r26
    29b8:	1b 1f       	adc	r17, r27

      if (MemoryType == TYPE_FLASH)
    29ba:	80 91 4c 02 	lds	r24, 0x024C
    29be:	81 30       	cpi	r24, 0x01	; 1
    29c0:	39 f4       	brne	.+14     	; 0x29d0 <PM_CheckEndOfProgramming+0x88>
      {
         EEPROMAddress = Prog_DataSize;       
    29c2:	80 91 16 01 	lds	r24, 0x0116
    29c6:	90 91 17 01 	lds	r25, 0x0117
    29ca:	9a 83       	std	Y+2, r25	; 0x02
    29cc:	89 83       	std	Y+1, r24	; 0x01
    29ce:	0e c0       	rjmp	.+28     	; 0x29ec <PM_CheckEndOfProgramming+0xa4>
      }
      else
      {
         EEPROMAddress = Prog_EEPROMSize;
    29d0:	80 91 14 01 	lds	r24, 0x0114
    29d4:	90 91 15 01 	lds	r25, 0x0115
    29d8:	9a 83       	std	Y+2, r25	; 0x02
    29da:	89 83       	std	Y+1, r24	; 0x01
         DataSize -= PM_EEPROM_OFFSET;                // Remove DataFlash starting offset
    29dc:	80 e0       	ldi	r24, 0x00	; 0
    29de:	9c ef       	ldi	r25, 0xFC	; 252
    29e0:	ab ef       	ldi	r26, 0xFB	; 251
    29e2:	bf ef       	ldi	r27, 0xFF	; 255
    29e4:	e8 0e       	add	r14, r24
    29e6:	f9 1e       	adc	r15, r25
    29e8:	0a 1f       	adc	r16, r26
    29ea:	1b 1f       	adc	r17, r27
      }

      eeprom_write_byte_169(&EEPROMAddress, (DataSize >> 24));
    29ec:	81 2f       	mov	r24, r17
    29ee:	99 27       	eor	r25, r25
    29f0:	aa 27       	eor	r26, r26
    29f2:	bb 27       	eor	r27, r27
    29f4:	68 2f       	mov	r22, r24
    29f6:	ce 01       	movw	r24, r28
    29f8:	01 96       	adiw	r24, 0x01	; 1
    29fa:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
      EEPROMAddress++;
    29fe:	89 81       	ldd	r24, Y+1	; 0x01
    2a00:	9a 81       	ldd	r25, Y+2	; 0x02
    2a02:	01 96       	adiw	r24, 0x01	; 1
    2a04:	9a 83       	std	Y+2, r25	; 0x02
    2a06:	89 83       	std	Y+1, r24	; 0x01
      eeprom_write_byte_169(&EEPROMAddress, (DataSize >> 16));             
    2a08:	c8 01       	movw	r24, r16
    2a0a:	aa 27       	eor	r26, r26
    2a0c:	bb 27       	eor	r27, r27
    2a0e:	68 2f       	mov	r22, r24
    2a10:	ce 01       	movw	r24, r28
    2a12:	01 96       	adiw	r24, 0x01	; 1
    2a14:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
      EEPROMAddress++;
    2a18:	89 81       	ldd	r24, Y+1	; 0x01
    2a1a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a1c:	01 96       	adiw	r24, 0x01	; 1
    2a1e:	9a 83       	std	Y+2, r25	; 0x02
    2a20:	89 83       	std	Y+1, r24	; 0x01
      eeprom_write_byte_169(&EEPROMAddress, (DataSize >> 8));
    2a22:	bb 27       	eor	r27, r27
    2a24:	a1 2f       	mov	r26, r17
    2a26:	90 2f       	mov	r25, r16
    2a28:	8f 2d       	mov	r24, r15
    2a2a:	68 2f       	mov	r22, r24
    2a2c:	ce 01       	movw	r24, r28
    2a2e:	01 96       	adiw	r24, 0x01	; 1
    2a30:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
      EEPROMAddress++;
    2a34:	89 81       	ldd	r24, Y+1	; 0x01
    2a36:	9a 81       	ldd	r25, Y+2	; 0x02
    2a38:	01 96       	adiw	r24, 0x01	; 1
    2a3a:	9a 83       	std	Y+2, r25	; 0x02
    2a3c:	89 83       	std	Y+1, r24	; 0x01
      eeprom_write_byte_169(&EEPROMAddress, DataSize);
    2a3e:	6e 2d       	mov	r22, r14
    2a40:	ce 01       	movw	r24, r28
    2a42:	01 96       	adiw	r24, 0x01	; 1
    2a44:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
    2a48:	22 96       	adiw	r28, 0x02	; 2
    2a4a:	0f b6       	in	r0, 0x3f	; 63
    2a4c:	f8 94       	cli
    2a4e:	de bf       	out	0x3e, r29	; 62
    2a50:	0f be       	out	0x3f, r0	; 63
    2a52:	cd bf       	out	0x3d, r28	; 61
    2a54:	df 91       	pop	r29
    2a56:	cf 91       	pop	r28
    2a58:	1f 91       	pop	r17
    2a5a:	0f 91       	pop	r16
    2a5c:	ff 90       	pop	r15
    2a5e:	ef 90       	pop	r14
    2a60:	08 95       	ret

00002a62 <PM_CheckEndOfFuseLockStore>:
   }
}

void PM_CheckEndOfFuseLockStore(void)
{
    2a62:	cf 93       	push	r28
    2a64:	df 93       	push	r29
    2a66:	cd b7       	in	r28, 0x3d	; 61
    2a68:	de b7       	in	r29, 0x3e	; 62
    2a6a:	22 97       	sbiw	r28, 0x02	; 2
    2a6c:	0f b6       	in	r0, 0x3f	; 63
    2a6e:	f8 94       	cli
    2a70:	de bf       	out	0x3e, r29	; 62
    2a72:	0f be       	out	0x3f, r0	; 63
    2a74:	cd bf       	out	0x3d, r28	; 61
	uint16_t EEPROMAddress;

	if (CurrentMode == PM_LOCKFUSEBITS_WRITE)
    2a76:	80 91 4b 02 	lds	r24, 0x024B
    2a7a:	83 30       	cpi	r24, 0x03	; 3
    2a7c:	a9 f4       	brne	.+42     	; 0x2aa8 <PM_CheckEndOfFuseLockStore+0x46>
	{
		EEPROMAddress = ((MemoryType == TYPE_FUSE)? Prog_TotalFuseBytes : Prog_TotalLockBytes);
    2a7e:	80 91 4c 02 	lds	r24, 0x024C
    2a82:	82 30       	cpi	r24, 0x02	; 2
    2a84:	29 f4       	brne	.+10     	; 0x2a90 <PM_CheckEndOfFuseLockStore+0x2e>
    2a86:	80 91 10 01 	lds	r24, 0x0110
    2a8a:	90 91 11 01 	lds	r25, 0x0111
    2a8e:	04 c0       	rjmp	.+8      	; 0x2a98 <PM_CheckEndOfFuseLockStore+0x36>
    2a90:	80 91 0e 01 	lds	r24, 0x010E
    2a94:	90 91 0f 01 	lds	r25, 0x010F
    2a98:	9a 83       	std	Y+2, r25	; 0x02
    2a9a:	89 83       	std	Y+1, r24	; 0x01
		
		eeprom_write_byte_169(&EEPROMAddress, CurrBuffByte); // CurrBuffByte stores the total number of fuse/lock bytes written in this case
    2a9c:	60 91 84 02 	lds	r22, 0x0284
    2aa0:	ce 01       	movw	r24, r28
    2aa2:	01 96       	adiw	r24, 0x01	; 1
    2aa4:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
    2aa8:	22 96       	adiw	r28, 0x02	; 2
    2aaa:	0f b6       	in	r0, 0x3f	; 63
    2aac:	f8 94       	cli
    2aae:	de bf       	out	0x3e, r29	; 62
    2ab0:	0f be       	out	0x3f, r0	; 63
    2ab2:	cd bf       	out	0x3d, r28	; 61
    2ab4:	df 91       	pop	r29
    2ab6:	cf 91       	pop	r28
    2ab8:	08 95       	ret

00002aba <PM_InterpretAVRISPPacket>:
    2aba:	af 92       	push	r10
    2abc:	bf 92       	push	r11
    2abe:	cf 92       	push	r12
    2ac0:	df 92       	push	r13
    2ac2:	ef 92       	push	r14
    2ac4:	ff 92       	push	r15
    2ac6:	0f 93       	push	r16
    2ac8:	1f 93       	push	r17
    2aca:	cf 93       	push	r28
    2acc:	df 93       	push	r29
    2ace:	cd b7       	in	r28, 0x3d	; 61
    2ad0:	de b7       	in	r29, 0x3e	; 62
    2ad2:	22 97       	sbiw	r28, 0x02	; 2
    2ad4:	0f b6       	in	r0, 0x3f	; 63
    2ad6:	f8 94       	cli
    2ad8:	de bf       	out	0x3e, r29	; 62
    2ada:	0f be       	out	0x3f, r0	; 63
    2adc:	cd bf       	out	0x3d, r28	; 61
    2ade:	40 91 36 01 	lds	r20, 0x0136
    2ae2:	84 2f       	mov	r24, r20
    2ae4:	99 27       	eor	r25, r25
    2ae6:	86 31       	cpi	r24, 0x16	; 22
    2ae8:	91 05       	cpc	r25, r1
    2aea:	09 f4       	brne	.+2      	; 0x2aee <PM_InterpretAVRISPPacket+0x34>
    2aec:	18 c2       	rjmp	.+1072   	; 0x2f1e <PM_InterpretAVRISPPacket+0x464>
    2aee:	87 31       	cpi	r24, 0x17	; 23
    2af0:	91 05       	cpc	r25, r1
    2af2:	94 f4       	brge	.+36     	; 0x2b18 <PM_InterpretAVRISPPacket+0x5e>
    2af4:	82 31       	cpi	r24, 0x12	; 18
    2af6:	91 05       	cpc	r25, r1
    2af8:	09 f4       	brne	.+2      	; 0x2afc <PM_InterpretAVRISPPacket+0x42>
    2afa:	72 c0       	rjmp	.+228    	; 0x2be0 <PM_InterpretAVRISPPacket+0x126>
    2afc:	83 31       	cpi	r24, 0x13	; 19
    2afe:	91 05       	cpc	r25, r1
    2b00:	3c f4       	brge	.+14     	; 0x2b10 <PM_InterpretAVRISPPacket+0x56>
    2b02:	80 31       	cpi	r24, 0x10	; 16
    2b04:	91 05       	cpc	r25, r1
    2b06:	19 f1       	breq	.+70     	; 0x2b4e <PM_InterpretAVRISPPacket+0x94>
    2b08:	41 97       	sbiw	r24, 0x11	; 17
    2b0a:	09 f4       	brne	.+2      	; 0x2b0e <PM_InterpretAVRISPPacket+0x54>
    2b0c:	49 c0       	rjmp	.+146    	; 0x2ba0 <PM_InterpretAVRISPPacket+0xe6>
    2b0e:	7b c2       	rjmp	.+1270   	; 0x3006 <PM_InterpretAVRISPPacket+0x54c>
    2b10:	44 97       	sbiw	r24, 0x14	; 20
    2b12:	09 f4       	brne	.+2      	; 0x2b16 <PM_InterpretAVRISPPacket+0x5c>
    2b14:	04 c2       	rjmp	.+1032   	; 0x2f1e <PM_InterpretAVRISPPacket+0x464>
    2b16:	71 c1       	rjmp	.+738    	; 0x2dfa <PM_InterpretAVRISPPacket+0x340>
    2b18:	89 31       	cpi	r24, 0x19	; 25
    2b1a:	91 05       	cpc	r25, r1
    2b1c:	09 f4       	brne	.+2      	; 0x2b20 <PM_InterpretAVRISPPacket+0x66>
    2b1e:	11 c1       	rjmp	.+546    	; 0x2d42 <PM_InterpretAVRISPPacket+0x288>
    2b20:	8a 31       	cpi	r24, 0x1A	; 26
    2b22:	91 05       	cpc	r25, r1
    2b24:	44 f4       	brge	.+16     	; 0x2b36 <PM_InterpretAVRISPPacket+0x7c>
    2b26:	87 31       	cpi	r24, 0x17	; 23
    2b28:	91 05       	cpc	r25, r1
    2b2a:	09 f4       	brne	.+2      	; 0x2b2e <PM_InterpretAVRISPPacket+0x74>
    2b2c:	0a c1       	rjmp	.+532    	; 0x2d42 <PM_InterpretAVRISPPacket+0x288>
    2b2e:	48 97       	sbiw	r24, 0x18	; 24
    2b30:	09 f4       	brne	.+2      	; 0x2b34 <PM_InterpretAVRISPPacket+0x7a>
    2b32:	a3 c0       	rjmp	.+326    	; 0x2c7a <PM_InterpretAVRISPPacket+0x1c0>
    2b34:	68 c2       	rjmp	.+1232   	; 0x3006 <PM_InterpretAVRISPPacket+0x54c>
    2b36:	8b 31       	cpi	r24, 0x1B	; 27
    2b38:	91 05       	cpc	r25, r1
    2b3a:	09 f4       	brne	.+2      	; 0x2b3e <PM_InterpretAVRISPPacket+0x84>
    2b3c:	45 c0       	rjmp	.+138    	; 0x2bc8 <PM_InterpretAVRISPPacket+0x10e>
    2b3e:	8b 31       	cpi	r24, 0x1B	; 27
    2b40:	91 05       	cpc	r25, r1
    2b42:	0c f4       	brge	.+2      	; 0x2b46 <PM_InterpretAVRISPPacket+0x8c>
    2b44:	9a c0       	rjmp	.+308    	; 0x2c7a <PM_InterpretAVRISPPacket+0x1c0>
    2b46:	4c 97       	sbiw	r24, 0x1c	; 28
    2b48:	09 f4       	brne	.+2      	; 0x2b4c <PM_InterpretAVRISPPacket+0x92>
    2b4a:	8c c0       	rjmp	.+280    	; 0x2c64 <PM_InterpretAVRISPPacket+0x1aa>
    2b4c:	5c c2       	rjmp	.+1208   	; 0x3006 <PM_InterpretAVRISPPacket+0x54c>
    2b4e:	82 e0       	ldi	r24, 0x02	; 2
    2b50:	90 e0       	ldi	r25, 0x00	; 0
    2b52:	90 93 33 01 	sts	0x0133, r25
    2b56:	80 93 32 01 	sts	0x0132, r24
    2b5a:	80 91 12 01 	lds	r24, 0x0112
    2b5e:	90 91 13 01 	lds	r25, 0x0113
    2b62:	9a 83       	std	Y+2, r25	; 0x02
    2b64:	89 83       	std	Y+1, r24	; 0x01
    2b66:	f6 e3       	ldi	r31, 0x36	; 54
    2b68:	ef 2e       	mov	r14, r31
    2b6a:	f1 e0       	ldi	r31, 0x01	; 1
    2b6c:	ff 2e       	mov	r15, r31
    2b6e:	1b e0       	ldi	r17, 0x0B	; 11
    2b70:	f7 01       	movw	r30, r14
    2b72:	61 91       	ld	r22, Z+
    2b74:	7f 01       	movw	r14, r30
    2b76:	ce 01       	movw	r24, r28
    2b78:	01 96       	adiw	r24, 0x01	; 1
    2b7a:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
    2b7e:	89 81       	ldd	r24, Y+1	; 0x01
    2b80:	9a 81       	ldd	r25, Y+2	; 0x02
    2b82:	01 96       	adiw	r24, 0x01	; 1
    2b84:	9a 83       	std	Y+2, r25	; 0x02
    2b86:	89 83       	std	Y+1, r24	; 0x01
    2b88:	11 50       	subi	r17, 0x01	; 1
    2b8a:	17 ff       	sbrs	r17, 7
    2b8c:	f1 cf       	rjmp	.-30     	; 0x2b70 <PM_InterpretAVRISPPacket+0xb6>
    2b8e:	81 e0       	ldi	r24, 0x01	; 1
    2b90:	80 93 31 01 	sts	0x0131, r24
    2b94:	10 92 4b 02 	sts	0x024B, r1
    2b98:	81 b3       	in	r24, 0x11	; 17
    2b9a:	8f 7c       	andi	r24, 0xCF	; 207
    2b9c:	80 62       	ori	r24, 0x20	; 32
    2b9e:	12 c0       	rjmp	.+36     	; 0x2bc4 <PM_InterpretAVRISPPacket+0x10a>
    2ba0:	82 e0       	ldi	r24, 0x02	; 2
    2ba2:	90 e0       	ldi	r25, 0x00	; 0
    2ba4:	90 93 33 01 	sts	0x0133, r25
    2ba8:	80 93 32 01 	sts	0x0132, r24
    2bac:	0e 94 a4 14 	call	0x2948 <PM_CheckEndOfProgramming>
    2bb0:	0e 94 31 15 	call	0x2a62 <PM_CheckEndOfFuseLockStore>
    2bb4:	10 92 31 01 	sts	0x0131, r1
    2bb8:	80 e0       	ldi	r24, 0x00	; 0
    2bba:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    2bbe:	81 b3       	in	r24, 0x11	; 17
    2bc0:	8f 7c       	andi	r24, 0xCF	; 207
    2bc2:	80 61       	ori	r24, 0x10	; 16
    2bc4:	81 bb       	out	0x11, r24	; 17
    2bc6:	a8 c1       	rjmp	.+848    	; 0x2f18 <PM_InterpretAVRISPPacket+0x45e>
    2bc8:	84 e0       	ldi	r24, 0x04	; 4
    2bca:	90 e0       	ldi	r25, 0x00	; 0
    2bcc:	90 93 33 01 	sts	0x0133, r25
    2bd0:	80 93 32 01 	sts	0x0132, r24
    2bd4:	10 92 37 01 	sts	0x0137, r1
    2bd8:	81 e0       	ldi	r24, 0x01	; 1
    2bda:	80 93 38 01 	sts	0x0138, r24
    2bde:	4a c0       	rjmp	.+148    	; 0x2c74 <PM_InterpretAVRISPPacket+0x1ba>
    2be0:	82 e0       	ldi	r24, 0x02	; 2
    2be2:	90 e0       	ldi	r25, 0x00	; 0
    2be4:	90 93 33 01 	sts	0x0133, r25
    2be8:	80 93 32 01 	sts	0x0132, r24
    2bec:	80 91 18 01 	lds	r24, 0x0118
    2bf0:	90 91 19 01 	lds	r25, 0x0119
    2bf4:	9a 83       	std	Y+2, r25	; 0x02
    2bf6:	89 83       	std	Y+1, r24	; 0x01
    2bf8:	e7 e3       	ldi	r30, 0x37	; 55
    2bfa:	ee 2e       	mov	r14, r30
    2bfc:	e1 e0       	ldi	r30, 0x01	; 1
    2bfe:	fe 2e       	mov	r15, r30
    2c00:	15 e0       	ldi	r17, 0x05	; 5
    2c02:	f7 01       	movw	r30, r14
    2c04:	61 91       	ld	r22, Z+
    2c06:	7f 01       	movw	r14, r30
    2c08:	ce 01       	movw	r24, r28
    2c0a:	01 96       	adiw	r24, 0x01	; 1
    2c0c:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
    2c10:	89 81       	ldd	r24, Y+1	; 0x01
    2c12:	9a 81       	ldd	r25, Y+2	; 0x02
    2c14:	01 96       	adiw	r24, 0x01	; 1
    2c16:	9a 83       	std	Y+2, r25	; 0x02
    2c18:	89 83       	std	Y+1, r24	; 0x01
    2c1a:	11 50       	subi	r17, 0x01	; 1
    2c1c:	17 ff       	sbrs	r17, 7
    2c1e:	f1 cf       	rjmp	.-30     	; 0x2c02 <PM_InterpretAVRISPPacket+0x148>
    2c20:	80 91 16 01 	lds	r24, 0x0116
    2c24:	90 91 17 01 	lds	r25, 0x0117
    2c28:	9a 83       	std	Y+2, r25	; 0x02
    2c2a:	89 83       	std	Y+1, r24	; 0x01
    2c2c:	10 e0       	ldi	r17, 0x00	; 0
    2c2e:	14 30       	cpi	r17, 0x04	; 4
    2c30:	31 f4       	brne	.+12     	; 0x2c3e <PM_InterpretAVRISPPacket+0x184>
    2c32:	80 91 14 01 	lds	r24, 0x0114
    2c36:	90 91 15 01 	lds	r25, 0x0115
    2c3a:	9a 83       	std	Y+2, r25	; 0x02
    2c3c:	89 83       	std	Y+1, r24	; 0x01
    2c3e:	60 e0       	ldi	r22, 0x00	; 0
    2c40:	ce 01       	movw	r24, r28
    2c42:	01 96       	adiw	r24, 0x01	; 1
    2c44:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
    2c48:	89 81       	ldd	r24, Y+1	; 0x01
    2c4a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c4c:	01 96       	adiw	r24, 0x01	; 1
    2c4e:	9a 83       	std	Y+2, r25	; 0x02
    2c50:	89 83       	std	Y+1, r24	; 0x01
    2c52:	1f 5f       	subi	r17, 0xFF	; 255
    2c54:	18 30       	cpi	r17, 0x08	; 8
    2c56:	58 f3       	brcs	.-42     	; 0x2c2e <PM_InterpretAVRISPPacket+0x174>
    2c58:	61 e0       	ldi	r22, 0x01	; 1
    2c5a:	8a e1       	ldi	r24, 0x1A	; 26
    2c5c:	91 e0       	ldi	r25, 0x01	; 1
    2c5e:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
    2c62:	5a c1       	rjmp	.+692    	; 0x2f18 <PM_InterpretAVRISPPacket+0x45e>
    2c64:	84 e0       	ldi	r24, 0x04	; 4
    2c66:	90 e0       	ldi	r25, 0x00	; 0
    2c68:	90 93 33 01 	sts	0x0133, r25
    2c6c:	80 93 32 01 	sts	0x0132, r24
    2c70:	10 92 37 01 	sts	0x0137, r1
    2c74:	10 92 39 01 	sts	0x0139, r1
    2c78:	cf c1       	rjmp	.+926    	; 0x3018 <PM_InterpretAVRISPPacket+0x55e>
    2c7a:	84 e0       	ldi	r24, 0x04	; 4
    2c7c:	90 e0       	ldi	r25, 0x00	; 0
    2c7e:	90 93 33 01 	sts	0x0133, r25
    2c82:	80 93 32 01 	sts	0x0132, r24
    2c86:	80 91 4b 02 	lds	r24, 0x024B
    2c8a:	84 30       	cpi	r24, 0x04	; 4
    2c8c:	59 f0       	breq	.+22     	; 0x2ca4 <PM_InterpretAVRISPPacket+0x1ea>
    2c8e:	0e 94 a4 14 	call	0x2948 <PM_CheckEndOfProgramming>
    2c92:	0e 94 31 15 	call	0x2a62 <PM_CheckEndOfFuseLockStore>
    2c96:	10 92 85 02 	sts	0x0285, r1
    2c9a:	10 92 84 02 	sts	0x0284, r1
    2c9e:	84 e0       	ldi	r24, 0x04	; 4
    2ca0:	80 93 4b 02 	sts	0x024B, r24
    2ca4:	80 91 36 01 	lds	r24, 0x0136
    2ca8:	88 31       	cpi	r24, 0x18	; 24
    2caa:	29 f4       	brne	.+10     	; 0x2cb6 <PM_InterpretAVRISPPacket+0x1fc>
    2cac:	80 91 10 01 	lds	r24, 0x0110
    2cb0:	90 91 11 01 	lds	r25, 0x0111
    2cb4:	04 c0       	rjmp	.+8      	; 0x2cbe <PM_InterpretAVRISPPacket+0x204>
    2cb6:	80 91 0e 01 	lds	r24, 0x010E
    2cba:	90 91 0f 01 	lds	r25, 0x010F
    2cbe:	9a 83       	std	Y+2, r25	; 0x02
    2cc0:	89 83       	std	Y+1, r24	; 0x01
    2cc2:	ce 01       	movw	r24, r28
    2cc4:	01 96       	adiw	r24, 0x01	; 1
    2cc6:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
    2cca:	99 27       	eor	r25, r25
    2ccc:	20 91 84 02 	lds	r18, 0x0284
    2cd0:	30 91 85 02 	lds	r19, 0x0285
    2cd4:	82 17       	cp	r24, r18
    2cd6:	93 07       	cpc	r25, r19
    2cd8:	10 f4       	brcc	.+4      	; 0x2cde <PM_InterpretAVRISPPacket+0x224>
    2cda:	8f ef       	ldi	r24, 0xFF	; 255
    2cdc:	22 c0       	rjmp	.+68     	; 0x2d22 <PM_InterpretAVRISPPacket+0x268>
    2cde:	a9 01       	movw	r20, r18
    2ce0:	44 0f       	add	r20, r20
    2ce2:	55 1f       	adc	r21, r21
    2ce4:	44 0f       	add	r20, r20
    2ce6:	55 1f       	adc	r21, r21
    2ce8:	80 91 37 01 	lds	r24, 0x0137
    2cec:	28 2f       	mov	r18, r24
    2cee:	33 27       	eor	r19, r19
    2cf0:	21 50       	subi	r18, 0x01	; 1
    2cf2:	30 40       	sbci	r19, 0x00	; 0
    2cf4:	80 91 36 01 	lds	r24, 0x0136
    2cf8:	88 31       	cpi	r24, 0x18	; 24
    2cfa:	29 f4       	brne	.+10     	; 0x2d06 <PM_InterpretAVRISPPacket+0x24c>
    2cfc:	80 91 0c 01 	lds	r24, 0x010C
    2d00:	90 91 0d 01 	lds	r25, 0x010D
    2d04:	04 c0       	rjmp	.+8      	; 0x2d0e <PM_InterpretAVRISPPacket+0x254>
    2d06:	80 91 0a 01 	lds	r24, 0x010A
    2d0a:	90 91 0b 01 	lds	r25, 0x010B
    2d0e:	84 0f       	add	r24, r20
    2d10:	95 1f       	adc	r25, r21
    2d12:	82 0f       	add	r24, r18
    2d14:	93 1f       	adc	r25, r19
    2d16:	9a 83       	std	Y+2, r25	; 0x02
    2d18:	89 83       	std	Y+1, r24	; 0x01
    2d1a:	ce 01       	movw	r24, r28
    2d1c:	01 96       	adiw	r24, 0x01	; 1
    2d1e:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
    2d22:	80 93 38 01 	sts	0x0138, r24
    2d26:	10 92 37 01 	sts	0x0137, r1
    2d2a:	10 92 39 01 	sts	0x0139, r1
    2d2e:	80 91 84 02 	lds	r24, 0x0284
    2d32:	90 91 85 02 	lds	r25, 0x0285
    2d36:	01 96       	adiw	r24, 0x01	; 1
    2d38:	90 93 85 02 	sts	0x0285, r25
    2d3c:	80 93 84 02 	sts	0x0284, r24
    2d40:	6b c1       	rjmp	.+726    	; 0x3018 <PM_InterpretAVRISPPacket+0x55e>
    2d42:	83 e0       	ldi	r24, 0x03	; 3
    2d44:	90 e0       	ldi	r25, 0x00	; 0
    2d46:	90 93 33 01 	sts	0x0133, r25
    2d4a:	80 93 32 01 	sts	0x0132, r24
    2d4e:	80 91 4b 02 	lds	r24, 0x024B
    2d52:	83 30       	cpi	r24, 0x03	; 3
    2d54:	39 f0       	breq	.+14     	; 0x2d64 <PM_InterpretAVRISPPacket+0x2aa>
    2d56:	83 e0       	ldi	r24, 0x03	; 3
    2d58:	80 93 4b 02 	sts	0x024B, r24
    2d5c:	10 92 85 02 	sts	0x0285, r1
    2d60:	10 92 84 02 	sts	0x0284, r1
    2d64:	20 91 84 02 	lds	r18, 0x0284
    2d68:	30 91 85 02 	lds	r19, 0x0285
    2d6c:	47 31       	cpi	r20, 0x17	; 23
    2d6e:	71 f4       	brne	.+28     	; 0x2d8c <PM_InterpretAVRISPPacket+0x2d2>
    2d70:	22 0f       	add	r18, r18
    2d72:	33 1f       	adc	r19, r19
    2d74:	22 0f       	add	r18, r18
    2d76:	33 1f       	adc	r19, r19
    2d78:	80 91 0c 01 	lds	r24, 0x010C
    2d7c:	90 91 0d 01 	lds	r25, 0x010D
    2d80:	82 0f       	add	r24, r18
    2d82:	93 1f       	adc	r25, r19
    2d84:	9a 83       	std	Y+2, r25	; 0x02
    2d86:	89 83       	std	Y+1, r24	; 0x01
    2d88:	82 e0       	ldi	r24, 0x02	; 2
    2d8a:	0d c0       	rjmp	.+26     	; 0x2da6 <PM_InterpretAVRISPPacket+0x2ec>
    2d8c:	22 0f       	add	r18, r18
    2d8e:	33 1f       	adc	r19, r19
    2d90:	22 0f       	add	r18, r18
    2d92:	33 1f       	adc	r19, r19
    2d94:	80 91 0a 01 	lds	r24, 0x010A
    2d98:	90 91 0b 01 	lds	r25, 0x010B
    2d9c:	82 0f       	add	r24, r18
    2d9e:	93 1f       	adc	r25, r19
    2da0:	9a 83       	std	Y+2, r25	; 0x02
    2da2:	89 83       	std	Y+1, r24	; 0x01
    2da4:	83 e0       	ldi	r24, 0x03	; 3
    2da6:	80 93 4c 02 	sts	0x024C, r24
    2daa:	80 91 84 02 	lds	r24, 0x0284
    2dae:	90 91 85 02 	lds	r25, 0x0285
    2db2:	0a 97       	sbiw	r24, 0x0a	; 10
    2db4:	e8 f4       	brcc	.+58     	; 0x2df0 <PM_InterpretAVRISPPacket+0x336>
    2db6:	47 e3       	ldi	r20, 0x37	; 55
    2db8:	e4 2e       	mov	r14, r20
    2dba:	41 e0       	ldi	r20, 0x01	; 1
    2dbc:	f4 2e       	mov	r15, r20
    2dbe:	13 e0       	ldi	r17, 0x03	; 3
    2dc0:	f7 01       	movw	r30, r14
    2dc2:	61 91       	ld	r22, Z+
    2dc4:	7f 01       	movw	r14, r30
    2dc6:	ce 01       	movw	r24, r28
    2dc8:	01 96       	adiw	r24, 0x01	; 1
    2dca:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
    2dce:	89 81       	ldd	r24, Y+1	; 0x01
    2dd0:	9a 81       	ldd	r25, Y+2	; 0x02
    2dd2:	01 96       	adiw	r24, 0x01	; 1
    2dd4:	9a 83       	std	Y+2, r25	; 0x02
    2dd6:	89 83       	std	Y+1, r24	; 0x01
    2dd8:	11 50       	subi	r17, 0x01	; 1
    2dda:	17 ff       	sbrs	r17, 7
    2ddc:	f1 cf       	rjmp	.-30     	; 0x2dc0 <PM_InterpretAVRISPPacket+0x306>
    2dde:	80 91 84 02 	lds	r24, 0x0284
    2de2:	90 91 85 02 	lds	r25, 0x0285
    2de6:	01 96       	adiw	r24, 0x01	; 1
    2de8:	90 93 85 02 	sts	0x0285, r25
    2dec:	80 93 84 02 	sts	0x0284, r24
    2df0:	10 92 37 01 	sts	0x0137, r1
    2df4:	10 92 38 01 	sts	0x0138, r1
    2df8:	0f c1       	rjmp	.+542    	; 0x3018 <PM_InterpretAVRISPPacket+0x55e>
    2dfa:	82 e0       	ldi	r24, 0x02	; 2
    2dfc:	90 e0       	ldi	r25, 0x00	; 0
    2dfe:	90 93 33 01 	sts	0x0133, r25
    2e02:	80 93 32 01 	sts	0x0132, r24
    2e06:	80 91 4b 02 	lds	r24, 0x024B
    2e0a:	81 30       	cpi	r24, 0x01	; 1
    2e0c:	81 f1       	breq	.+96     	; 0x2e6e <PM_InterpretAVRISPPacket+0x3b4>
    2e0e:	43 31       	cpi	r20, 0x13	; 19
    2e10:	41 f4       	brne	.+16     	; 0x2e22 <PM_InterpretAVRISPPacket+0x368>
    2e12:	80 91 1e 01 	lds	r24, 0x011E
    2e16:	90 91 1f 01 	lds	r25, 0x011F
    2e1a:	9a 83       	std	Y+2, r25	; 0x02
    2e1c:	89 83       	std	Y+1, r24	; 0x01
    2e1e:	81 e0       	ldi	r24, 0x01	; 1
    2e20:	07 c0       	rjmp	.+14     	; 0x2e30 <PM_InterpretAVRISPPacket+0x376>
    2e22:	80 91 1c 01 	lds	r24, 0x011C
    2e26:	90 91 1d 01 	lds	r25, 0x011D
    2e2a:	9a 83       	std	Y+2, r25	; 0x02
    2e2c:	89 83       	std	Y+1, r24	; 0x01
    2e2e:	80 e0       	ldi	r24, 0x00	; 0
    2e30:	0e 94 2d 14 	call	0x285a <PM_SetupDFAddressCounters>
    2e34:	80 91 84 02 	lds	r24, 0x0284
    2e38:	90 91 85 02 	lds	r25, 0x0285
    2e3c:	0e 94 92 0a 	call	0x1524 <DF_BufferWriteEnable>
    2e40:	81 e0       	ldi	r24, 0x01	; 1
    2e42:	80 93 4b 02 	sts	0x024B, r24
    2e46:	37 e3       	ldi	r19, 0x37	; 55
    2e48:	e3 2e       	mov	r14, r19
    2e4a:	31 e0       	ldi	r19, 0x01	; 1
    2e4c:	f3 2e       	mov	r15, r19
    2e4e:	18 e0       	ldi	r17, 0x08	; 8
    2e50:	f7 01       	movw	r30, r14
    2e52:	61 91       	ld	r22, Z+
    2e54:	7f 01       	movw	r14, r30
    2e56:	ce 01       	movw	r24, r28
    2e58:	01 96       	adiw	r24, 0x01	; 1
    2e5a:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
    2e5e:	89 81       	ldd	r24, Y+1	; 0x01
    2e60:	9a 81       	ldd	r25, Y+2	; 0x02
    2e62:	01 96       	adiw	r24, 0x01	; 1
    2e64:	9a 83       	std	Y+2, r25	; 0x02
    2e66:	89 83       	std	Y+1, r24	; 0x01
    2e68:	11 50       	subi	r17, 0x01	; 1
    2e6a:	17 ff       	sbrs	r17, 7
    2e6c:	f1 cf       	rjmp	.-30     	; 0x2e50 <PM_InterpretAVRISPPacket+0x396>
    2e6e:	80 91 37 01 	lds	r24, 0x0137
    2e72:	99 27       	eor	r25, r25
    2e74:	18 2f       	mov	r17, r24
    2e76:	00 27       	eor	r16, r16
    2e78:	80 91 38 01 	lds	r24, 0x0138
    2e7c:	99 27       	eor	r25, r25
    2e7e:	08 2b       	or	r16, r24
    2e80:	19 2b       	or	r17, r25
    2e82:	ee 24       	eor	r14, r14
    2e84:	ff 24       	eor	r15, r15
    2e86:	e0 16       	cp	r14, r16
    2e88:	f1 06       	cpc	r15, r17
    2e8a:	78 f4       	brcc	.+30     	; 0x2eaa <PM_InterpretAVRISPPacket+0x3f0>
    2e8c:	80 e4       	ldi	r24, 0x40	; 64
    2e8e:	c8 2e       	mov	r12, r24
    2e90:	81 e0       	ldi	r24, 0x01	; 1
    2e92:	d8 2e       	mov	r13, r24
    2e94:	f6 01       	movw	r30, r12
    2e96:	81 91       	ld	r24, Z+
    2e98:	6f 01       	movw	r12, r30
    2e9a:	0e 94 6f 14 	call	0x28de <PM_StoreProgramByte>
    2e9e:	08 94       	sec
    2ea0:	e1 1c       	adc	r14, r1
    2ea2:	f1 1c       	adc	r15, r1
    2ea4:	e0 16       	cp	r14, r16
    2ea6:	f1 06       	cpc	r15, r17
    2ea8:	a8 f3       	brcs	.-22     	; 0x2e94 <PM_InterpretAVRISPPacket+0x3da>
    2eaa:	80 91 39 01 	lds	r24, 0x0139
    2eae:	87 ff       	sbrs	r24, 7
    2eb0:	33 c0       	rjmp	.+102    	; 0x2f18 <PM_InterpretAVRISPPacket+0x45e>
    2eb2:	40 91 49 02 	lds	r20, 0x0249
    2eb6:	50 91 4a 02 	lds	r21, 0x024A
    2eba:	57 fd       	sbrc	r21, 7
    2ebc:	2d c0       	rjmp	.+90     	; 0x2f18 <PM_InterpretAVRISPPacket+0x45e>
    2ebe:	41 15       	cp	r20, r1
    2ec0:	51 05       	cpc	r21, r1
    2ec2:	51 f1       	breq	.+84     	; 0x2f18 <PM_InterpretAVRISPPacket+0x45e>
    2ec4:	80 91 4c 02 	lds	r24, 0x024C
    2ec8:	81 30       	cpi	r24, 0x01	; 1
    2eca:	29 f4       	brne	.+10     	; 0x2ed6 <PM_InterpretAVRISPPacket+0x41c>
    2ecc:	20 91 08 01 	lds	r18, 0x0108
    2ed0:	30 91 09 01 	lds	r19, 0x0109
    2ed4:	04 c0       	rjmp	.+8      	; 0x2ede <PM_InterpretAVRISPPacket+0x424>
    2ed6:	20 91 06 01 	lds	r18, 0x0106
    2eda:	30 91 07 01 	lds	r19, 0x0107
    2ede:	3a 83       	std	Y+2, r19	; 0x02
    2ee0:	29 83       	std	Y+1, r18	; 0x01
    2ee2:	85 2f       	mov	r24, r21
    2ee4:	99 27       	eor	r25, r25
    2ee6:	68 2f       	mov	r22, r24
    2ee8:	ce 01       	movw	r24, r28
    2eea:	01 96       	adiw	r24, 0x01	; 1
    2eec:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
    2ef0:	89 81       	ldd	r24, Y+1	; 0x01
    2ef2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ef4:	01 96       	adiw	r24, 0x01	; 1
    2ef6:	9a 83       	std	Y+2, r25	; 0x02
    2ef8:	89 83       	std	Y+1, r24	; 0x01
    2efa:	60 91 49 02 	lds	r22, 0x0249
    2efe:	ce 01       	movw	r24, r28
    2f00:	01 96       	adiw	r24, 0x01	; 1
    2f02:	0e 94 bf 08 	call	0x117e <eeprom_write_byte_169>
    2f06:	80 91 49 02 	lds	r24, 0x0249
    2f0a:	90 91 4a 02 	lds	r25, 0x024A
    2f0e:	90 68       	ori	r25, 0x80	; 128
    2f10:	90 93 4a 02 	sts	0x024A, r25
    2f14:	80 93 49 02 	sts	0x0249, r24
    2f18:	10 92 37 01 	sts	0x0137, r1
    2f1c:	7d c0       	rjmp	.+250    	; 0x3018 <PM_InterpretAVRISPPacket+0x55e>
    2f1e:	80 91 4b 02 	lds	r24, 0x024B
    2f22:	82 30       	cpi	r24, 0x02	; 2
    2f24:	11 f1       	breq	.+68     	; 0x2f6a <PM_InterpretAVRISPPacket+0x4b0>
    2f26:	0e 94 a4 14 	call	0x2948 <PM_CheckEndOfProgramming>
    2f2a:	0e 94 31 15 	call	0x2a62 <PM_CheckEndOfFuseLockStore>
    2f2e:	90 e0       	ldi	r25, 0x00	; 0
    2f30:	80 91 36 01 	lds	r24, 0x0136
    2f34:	84 31       	cpi	r24, 0x14	; 20
    2f36:	09 f4       	brne	.+2      	; 0x2f3a <PM_InterpretAVRISPPacket+0x480>
    2f38:	91 e0       	ldi	r25, 0x01	; 1
    2f3a:	89 2f       	mov	r24, r25
    2f3c:	0e 94 2d 14 	call	0x285a <PM_SetupDFAddressCounters>
    2f40:	60 91 84 02 	lds	r22, 0x0284
    2f44:	70 91 85 02 	lds	r23, 0x0285
    2f48:	80 91 8b 02 	lds	r24, 0x028B
    2f4c:	90 91 8c 02 	lds	r25, 0x028C
    2f50:	0e 94 4f 0a 	call	0x149e <DF_ContinuousReadEnable>
    2f54:	82 e0       	ldi	r24, 0x02	; 2
    2f56:	80 93 4b 02 	sts	0x024B, r24
    2f5a:	10 92 2d 01 	sts	0x012D, r1
    2f5e:	10 92 2e 01 	sts	0x012E, r1
    2f62:	10 92 2f 01 	sts	0x012F, r1
    2f66:	10 92 30 01 	sts	0x0130, r1
    2f6a:	80 91 37 01 	lds	r24, 0x0137
    2f6e:	99 27       	eor	r25, r25
    2f70:	18 2f       	mov	r17, r24
    2f72:	00 27       	eor	r16, r16
    2f74:	80 91 38 01 	lds	r24, 0x0138
    2f78:	99 27       	eor	r25, r25
    2f7a:	08 2b       	or	r16, r24
    2f7c:	19 2b       	or	r17, r25
    2f7e:	90 e0       	ldi	r25, 0x00	; 0
    2f80:	80 91 36 01 	lds	r24, 0x0136
    2f84:	84 31       	cpi	r24, 0x14	; 20
    2f86:	09 f4       	brne	.+2      	; 0x2f8a <PM_InterpretAVRISPPacket+0x4d0>
    2f88:	91 e0       	ldi	r25, 0x01	; 1
    2f8a:	89 2f       	mov	r24, r25
    2f8c:	0e 94 b5 13 	call	0x276a <PM_GetStoredDataSize>
    2f90:	dc 01       	movw	r26, r24
    2f92:	cb 01       	movw	r24, r22
    2f94:	6c 01       	movw	r12, r24
    2f96:	ee 24       	eor	r14, r14
    2f98:	ff 24       	eor	r15, r15
    2f9a:	e0 16       	cp	r14, r16
    2f9c:	f1 06       	cpc	r15, r17
    2f9e:	20 f5       	brcc	.+72     	; 0x2fe8 <PM_InterpretAVRISPPacket+0x52e>
    2fa0:	f8 e3       	ldi	r31, 0x38	; 56
    2fa2:	af 2e       	mov	r10, r31
    2fa4:	f1 e0       	ldi	r31, 0x01	; 1
    2fa6:	bf 2e       	mov	r11, r31
    2fa8:	96 01       	movw	r18, r12
    2faa:	44 27       	eor	r20, r20
    2fac:	55 27       	eor	r21, r21
    2fae:	80 91 2d 01 	lds	r24, 0x012D
    2fb2:	90 91 2e 01 	lds	r25, 0x012E
    2fb6:	a0 91 2f 01 	lds	r26, 0x012F
    2fba:	b0 91 30 01 	lds	r27, 0x0130
    2fbe:	82 17       	cp	r24, r18
    2fc0:	93 07       	cpc	r25, r19
    2fc2:	a4 07       	cpc	r26, r20
    2fc4:	b5 07       	cpc	r27, r21
    2fc6:	20 f4       	brcc	.+8      	; 0x2fd0 <PM_InterpretAVRISPPacket+0x516>
    2fc8:	80 e0       	ldi	r24, 0x00	; 0
    2fca:	0e 94 3d 09 	call	0x127a <SPI_SPITransmit>
    2fce:	01 c0       	rjmp	.+2      	; 0x2fd2 <PM_InterpretAVRISPPacket+0x518>
    2fd0:	8f ef       	ldi	r24, 0xFF	; 255
    2fd2:	f5 01       	movw	r30, r10
    2fd4:	81 93       	st	Z+, r24
    2fd6:	5f 01       	movw	r10, r30
    2fd8:	0e 94 13 0f 	call	0x1e26 <V2P_IncrementCurrAddress>
    2fdc:	08 94       	sec
    2fde:	e1 1c       	adc	r14, r1
    2fe0:	f1 1c       	adc	r15, r1
    2fe2:	e0 16       	cp	r14, r16
    2fe4:	f1 06       	cpc	r15, r17
    2fe6:	00 f3       	brcs	.-64     	; 0x2fa8 <PM_InterpretAVRISPPacket+0x4ee>
    2fe8:	0d 5f       	subi	r16, 0xFD	; 253
    2fea:	1f 4f       	sbci	r17, 0xFF	; 255
    2fec:	10 93 33 01 	sts	0x0133, r17
    2ff0:	00 93 32 01 	sts	0x0132, r16
    2ff4:	03 50       	subi	r16, 0x03	; 3
    2ff6:	10 40       	sbci	r17, 0x00	; 0
    2ff8:	10 92 37 01 	sts	0x0137, r1
    2ffc:	0a 5c       	subi	r16, 0xCA	; 202
    2ffe:	1e 4f       	sbci	r17, 0xFE	; 254
    3000:	f8 01       	movw	r30, r16
    3002:	12 82       	std	Z+2, r1	; 0x02
    3004:	09 c0       	rjmp	.+18     	; 0x3018 <PM_InterpretAVRISPPacket+0x55e>
    3006:	81 e0       	ldi	r24, 0x01	; 1
    3008:	90 e0       	ldi	r25, 0x00	; 0
    300a:	90 93 33 01 	sts	0x0133, r25
    300e:	80 93 32 01 	sts	0x0132, r24
    3012:	89 ec       	ldi	r24, 0xC9	; 201
    3014:	80 93 37 01 	sts	0x0137, r24
    3018:	0e 94 39 0e 	call	0x1c72 <V2P_SendPacket>
    301c:	22 96       	adiw	r28, 0x02	; 2
    301e:	0f b6       	in	r0, 0x3f	; 63
    3020:	f8 94       	cli
    3022:	de bf       	out	0x3e, r29	; 62
    3024:	0f be       	out	0x3f, r0	; 63
    3026:	cd bf       	out	0x3d, r28	; 61
    3028:	df 91       	pop	r29
    302a:	cf 91       	pop	r28
    302c:	1f 91       	pop	r17
    302e:	0f 91       	pop	r16
    3030:	ff 90       	pop	r15
    3032:	ef 90       	pop	r14
    3034:	df 90       	pop	r13
    3036:	cf 90       	pop	r12
    3038:	bf 90       	pop	r11
    303a:	af 90       	pop	r10
    303c:	08 95       	ret

0000303e <PM_SendFuseLockBytes>:
	}
}

void PM_SendFuseLockBytes(uint8_t Type)
{
    303e:	0f 93       	push	r16
    3040:	1f 93       	push	r17
    3042:	cf 93       	push	r28
    3044:	df 93       	push	r29
    3046:	cd b7       	in	r28, 0x3d	; 61
    3048:	de b7       	in	r29, 0x3e	; 62
    304a:	22 97       	sbiw	r28, 0x02	; 2
    304c:	0f b6       	in	r0, 0x3f	; 63
    304e:	f8 94       	cli
    3050:	de bf       	out	0x3e, r29	; 62
    3052:	0f be       	out	0x3f, r0	; 63
    3054:	cd bf       	out	0x3d, r28	; 61
    3056:	08 2f       	mov	r16, r24
	uint16_t EEPROMAddress;
	uint8_t  TotalBytes;
	
	EEPROMAddress = ((Type == TYPE_FUSE)? Prog_TotalFuseBytes : Prog_TotalLockBytes);
    3058:	82 30       	cpi	r24, 0x02	; 2
    305a:	29 f4       	brne	.+10     	; 0x3066 <PM_SendFuseLockBytes+0x28>
    305c:	80 91 10 01 	lds	r24, 0x0110
    3060:	90 91 11 01 	lds	r25, 0x0111
    3064:	04 c0       	rjmp	.+8      	; 0x306e <PM_SendFuseLockBytes+0x30>
    3066:	80 91 0e 01 	lds	r24, 0x010E
    306a:	90 91 0f 01 	lds	r25, 0x010F
    306e:	9a 83       	std	Y+2, r25	; 0x02
    3070:	89 83       	std	Y+1, r24	; 0x01

	TotalBytes = eeprom_read_byte_169(&EEPROMAddress); // Get the total number of stored fuse/lock bytes
    3072:	ce 01       	movw	r24, r28
    3074:	01 96       	adiw	r24, 0x01	; 1
    3076:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
    307a:	18 2f       	mov	r17, r24
			
	EEPROMAddress = ((Type == TYPE_FUSE)? Prog_FuseBytes : Prog_LockBytes); // Set the EEPROM pointer to the fuse/lock bytes start (each fuse or lock byte takes four bytes in EEPROM)
    307c:	02 30       	cpi	r16, 0x02	; 2
    307e:	29 f4       	brne	.+10     	; 0x308a <PM_SendFuseLockBytes+0x4c>
    3080:	80 91 0c 01 	lds	r24, 0x010C
    3084:	90 91 0d 01 	lds	r25, 0x010D
    3088:	04 c0       	rjmp	.+8      	; 0x3092 <PM_SendFuseLockBytes+0x54>
    308a:	80 91 0a 01 	lds	r24, 0x010A
    308e:	90 91 0b 01 	lds	r25, 0x010B
    3092:	9a 83       	std	Y+2, r25	; 0x02
    3094:	89 83       	std	Y+1, r24	; 0x01

	while (TotalBytes--)                              // Write each of the fuse/lock bytes stored in memory to the slave AVR
	{
		for (uint8_t CommandByte = 0; CommandByte < 4; CommandByte++)      // Write each individual command byte
		{
			USI_SPITransmit(eeprom_read_byte_169(&EEPROMAddress));
			EEPROMAddress++;
		}
		
		// Add some delay before programming next byte, if there is one:
		if (TotalBytes)
		   MAIN_Delay10MS(5);
    3096:	11 50       	subi	r17, 0x01	; 1
    3098:	1f 3f       	cpi	r17, 0xFF	; 255
    309a:	b1 f0       	breq	.+44     	; 0x30c8 <PM_SendFuseLockBytes+0x8a>
    309c:	03 e0       	ldi	r16, 0x03	; 3
    309e:	ce 01       	movw	r24, r28
    30a0:	01 96       	adiw	r24, 0x01	; 1
    30a2:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
    30a6:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    30aa:	89 81       	ldd	r24, Y+1	; 0x01
    30ac:	9a 81       	ldd	r25, Y+2	; 0x02
    30ae:	01 96       	adiw	r24, 0x01	; 1
    30b0:	9a 83       	std	Y+2, r25	; 0x02
    30b2:	89 83       	std	Y+1, r24	; 0x01
    30b4:	01 50       	subi	r16, 0x01	; 1
    30b6:	07 ff       	sbrs	r16, 7
    30b8:	f2 cf       	rjmp	.-28     	; 0x309e <PM_SendFuseLockBytes+0x60>
    30ba:	11 23       	and	r17, r17
    30bc:	19 f0       	breq	.+6      	; 0x30c4 <PM_SendFuseLockBytes+0x86>
    30be:	85 e0       	ldi	r24, 0x05	; 5
    30c0:	0e 94 27 02 	call	0x44e <MAIN_Delay10MS>
    30c4:	11 50       	subi	r17, 0x01	; 1
    30c6:	50 f7       	brcc	.-44     	; 0x309c <PM_SendFuseLockBytes+0x5e>
    30c8:	22 96       	adiw	r28, 0x02	; 2
    30ca:	0f b6       	in	r0, 0x3f	; 63
    30cc:	f8 94       	cli
    30ce:	de bf       	out	0x3e, r29	; 62
    30d0:	0f be       	out	0x3f, r0	; 63
    30d2:	cd bf       	out	0x3d, r28	; 61
    30d4:	df 91       	pop	r29
    30d6:	cf 91       	pop	r28
    30d8:	1f 91       	pop	r17
    30da:	0f 91       	pop	r16
    30dc:	08 95       	ret

000030de <PM_SendEraseCommand>:
	}
}

void PM_SendEraseCommand(void)
{
    30de:	0f 93       	push	r16
    30e0:	1f 93       	push	r17
    30e2:	cf 93       	push	r28
    30e4:	df 93       	push	r29
    30e6:	cd b7       	in	r28, 0x3d	; 61
    30e8:	de b7       	in	r29, 0x3e	; 62
    30ea:	22 97       	sbiw	r28, 0x02	; 2
    30ec:	0f b6       	in	r0, 0x3f	; 63
    30ee:	f8 94       	cli
    30f0:	de bf       	out	0x3e, r29	; 62
    30f2:	0f be       	out	0x3f, r0	; 63
    30f4:	cd bf       	out	0x3d, r28	; 61
	uint16_t EEPROMAddress;

	EEPROMAddress = Prog_EraseChip + 2;               // Start of the erase commands
    30f6:	80 91 18 01 	lds	r24, 0x0118
    30fa:	90 91 19 01 	lds	r25, 0x0119
    30fe:	02 96       	adiw	r24, 0x02	; 2
    3100:	9a 83       	std	Y+2, r25	; 0x02
    3102:	89 83       	std	Y+1, r24	; 0x01
    3104:	13 e0       	ldi	r17, 0x03	; 3
			
	for (uint8_t B = 0; B < 4 ; B++)                  // Read out the erase chip command bytes
	{
		USI_SPITransmit(eeprom_read_byte_169(&EEPROMAddress)); // Send the erase chip commands
    3106:	ce 01       	movw	r24, r28
    3108:	01 96       	adiw	r24, 0x01	; 1
    310a:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
    310e:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
		EEPROMAddress++;
    3112:	89 81       	ldd	r24, Y+1	; 0x01
    3114:	9a 81       	ldd	r25, Y+2	; 0x02
    3116:	01 96       	adiw	r24, 0x01	; 1
    3118:	9a 83       	std	Y+2, r25	; 0x02
    311a:	89 83       	std	Y+1, r24	; 0x01
    311c:	11 50       	subi	r17, 0x01	; 1
    311e:	17 ff       	sbrs	r17, 7
    3120:	f2 cf       	rjmp	.-28     	; 0x3106 <PM_SendEraseCommand+0x28>
	}
			
	EEPROMAddress = Prog_EraseChip + 1;                // Poll mode flag address
    3122:	00 91 18 01 	lds	r16, 0x0118
    3126:	10 91 19 01 	lds	r17, 0x0119
    312a:	0f 5f       	subi	r16, 0xFF	; 255
    312c:	1f 4f       	sbci	r17, 0xFF	; 255
    312e:	1a 83       	std	Y+2, r17	; 0x02
    3130:	09 83       	std	Y+1, r16	; 0x01
    3132:	01 50       	subi	r16, 0x01	; 1
    3134:	10 40       	sbci	r17, 0x00	; 0
	if (eeprom_read_byte_169(&EEPROMAddress))          // Value of 1 indicates a busy flag test
    3136:	ce 01       	movw	r24, r28
    3138:	01 96       	adiw	r24, 0x01	; 1
    313a:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
    313e:	88 23       	and	r24, r24
    3140:	59 f0       	breq	.+22     	; 0x3158 <PM_SendEraseCommand+0x7a>
	{
		do
			USI_SPITransmitWord(0xF000);
    3142:	80 e0       	ldi	r24, 0x00	; 0
    3144:	90 ef       	ldi	r25, 0xF0	; 240
    3146:	0e 94 ee 09 	call	0x13dc <USI_SPITransmitWord>
    314a:	80 e0       	ldi	r24, 0x00	; 0
    314c:	90 e0       	ldi	r25, 0x00	; 0
    314e:	0e 94 ee 09 	call	0x13dc <USI_SPITransmitWord>
    3152:	80 fd       	sbrc	r24, 0
    3154:	f6 cf       	rjmp	.-20     	; 0x3142 <PM_SendEraseCommand+0x64>
    3156:	08 c0       	rjmp	.+16     	; 0x3168 <PM_SendEraseCommand+0x8a>
		while (USI_SPITransmitWord(0x0000) & 0x01);
	}
	else                                               // Cleared flag means use a predefined delay
	{
		EEPROMAddress = Prog_EraseChip;                 // Delay value address			
    3158:	1a 83       	std	Y+2, r17	; 0x02
    315a:	09 83       	std	Y+1, r16	; 0x01
		MAIN_Delay1MS(eeprom_read_byte_169(&EEPROMAddress)); // Wait the erase delay
    315c:	ce 01       	movw	r24, r28
    315e:	01 96       	adiw	r24, 0x01	; 1
    3160:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
    3164:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    3168:	22 96       	adiw	r28, 0x02	; 2
    316a:	0f b6       	in	r0, 0x3f	; 63
    316c:	f8 94       	cli
    316e:	de bf       	out	0x3e, r29	; 62
    3170:	0f be       	out	0x3f, r0	; 63
    3172:	cd bf       	out	0x3d, r28	; 61
    3174:	df 91       	pop	r29
    3176:	cf 91       	pop	r28
    3178:	1f 91       	pop	r17
    317a:	0f 91       	pop	r16
    317c:	08 95       	ret

0000317e <PM_CreateProgrammingPackets>:
	}
}

void PM_CreateProgrammingPackets(uint8_t Type)
{			
    317e:	2f 92       	push	r2
    3180:	3f 92       	push	r3
    3182:	4f 92       	push	r4
    3184:	5f 92       	push	r5
    3186:	6f 92       	push	r6
    3188:	7f 92       	push	r7
    318a:	8f 92       	push	r8
    318c:	9f 92       	push	r9
    318e:	af 92       	push	r10
    3190:	bf 92       	push	r11
    3192:	cf 92       	push	r12
    3194:	df 92       	push	r13
    3196:	ef 92       	push	r14
    3198:	ff 92       	push	r15
    319a:	0f 93       	push	r16
    319c:	1f 93       	push	r17
    319e:	cf 93       	push	r28
    31a0:	df 93       	push	r29
    31a2:	cd b7       	in	r28, 0x3d	; 61
    31a4:	de b7       	in	r29, 0x3e	; 62
    31a6:	23 97       	sbiw	r28, 0x03	; 3
    31a8:	0f b6       	in	r0, 0x3f	; 63
    31aa:	f8 94       	cli
    31ac:	de bf       	out	0x3e, r29	; 62
    31ae:	0f be       	out	0x3f, r0	; 63
    31b0:	cd bf       	out	0x3d, r28	; 61
    31b2:	18 2f       	mov	r17, r24
	uint32_t BytesRead       = 0;
    31b4:	88 24       	eor	r8, r8
    31b6:	99 24       	eor	r9, r9
    31b8:	54 01       	movw	r10, r8
	uint32_t BytesToRead     = PM_GetStoredDataSize(Type);      // Get the byte size of the stored program
    31ba:	0e 94 b5 13 	call	0x276a <PM_GetStoredDataSize>
    31be:	1b 01       	movw	r2, r22
    31c0:	2c 01       	movw	r4, r24
	uint16_t BytesPerProgram;
	uint16_t EEPROMAddress;
	uint16_t PageLength;
	uint8_t  ContinuedPage   = FALSE;
    31c2:	1b 82       	std	Y+3, r1	; 0x03

	EEPROMAddress = ((Type == TYPE_FLASH)? Prog_PageLength : Prog_EPageLength);
    31c4:	11 30       	cpi	r17, 0x01	; 1
    31c6:	29 f4       	brne	.+10     	; 0x31d2 <PM_CreateProgrammingPackets+0x54>
    31c8:	80 91 08 01 	lds	r24, 0x0108
    31cc:	90 91 09 01 	lds	r25, 0x0109
    31d0:	04 c0       	rjmp	.+8      	; 0x31da <PM_CreateProgrammingPackets+0x5c>
    31d2:	80 91 06 01 	lds	r24, 0x0106
    31d6:	90 91 07 01 	lds	r25, 0x0107
    31da:	9a 83       	std	Y+2, r25	; 0x02
    31dc:	89 83       	std	Y+1, r24	; 0x01
	PageLength    = ((uint16_t)eeprom_read_byte_169(&EEPROMAddress) << 8);
    31de:	ce 01       	movw	r24, r28
    31e0:	01 96       	adiw	r24, 0x01	; 1
    31e2:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
    31e6:	99 27       	eor	r25, r25
    31e8:	78 2e       	mov	r7, r24
    31ea:	66 24       	eor	r6, r6
	EEPROMAddress++;
    31ec:	89 81       	ldd	r24, Y+1	; 0x01
    31ee:	9a 81       	ldd	r25, Y+2	; 0x02
    31f0:	01 96       	adiw	r24, 0x01	; 1
    31f2:	9a 83       	std	Y+2, r25	; 0x02
    31f4:	89 83       	std	Y+1, r24	; 0x01
	PageLength   |= (eeprom_read_byte_169(&EEPROMAddress));
    31f6:	ce 01       	movw	r24, r28
    31f8:	01 96       	adiw	r24, 0x01	; 1
    31fa:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
    31fe:	99 27       	eor	r25, r25
    3200:	68 2a       	or	r6, r24
    3202:	79 2a       	or	r7, r25
	
	CurrAddress = 0;
    3204:	10 92 2d 01 	sts	0x012D, r1
    3208:	10 92 2e 01 	sts	0x012E, r1
    320c:	10 92 2f 01 	sts	0x012F, r1
    3210:	10 92 30 01 	sts	0x0130, r1

	if (Type == TYPE_FLASH)
    3214:	11 30       	cpi	r17, 0x01	; 1
    3216:	69 f4       	brne	.+26     	; 0x3232 <PM_CreateProgrammingPackets+0xb4>
	{
		EEPROMAddress = Prog_WriteProgram;             // Set the EEPROM pointer to the write flash command bytes location
    3218:	80 91 1e 01 	lds	r24, 0x011E
    321c:	90 91 1f 01 	lds	r25, 0x011F
    3220:	9a 83       	std	Y+2, r25	; 0x02
    3222:	89 83       	std	Y+1, r24	; 0x01
		DF_ContinuousReadEnable(0, 0);
    3224:	60 e0       	ldi	r22, 0x00	; 0
    3226:	70 e0       	ldi	r23, 0x00	; 0
    3228:	cb 01       	movw	r24, r22
    322a:	0e 94 4f 0a 	call	0x149e <DF_ContinuousReadEnable>
		PacketBytes[0] = CMD_PROGRAM_FLASH_ISP;
    322e:	83 e1       	ldi	r24, 0x13	; 19
    3230:	0d c0       	rjmp	.+26     	; 0x324c <PM_CreateProgrammingPackets+0xce>
	}
	else
	{
		EEPROMAddress = Prog_WriteEEPROM;              // Set the EEPROM pointer to the write EEPROM command bytes location
    3232:	80 91 1c 01 	lds	r24, 0x011C
    3236:	90 91 1d 01 	lds	r25, 0x011D
    323a:	9a 83       	std	Y+2, r25	; 0x02
    323c:	89 83       	std	Y+1, r24	; 0x01
		DF_ContinuousReadEnable(PM_EEPROM_OFFSET / DF_INTERNALDF_BUFFBYTES, PM_EEPROM_OFFSET % DF_INTERNALDF_BUFFBYTES); // Start read from the EEPROM offset location
    323e:	60 ee       	ldi	r22, 0xE0	; 224
    3240:	70 e0       	ldi	r23, 0x00	; 0
    3242:	84 ee       	ldi	r24, 0xE4	; 228
    3244:	93 e0       	ldi	r25, 0x03	; 3
    3246:	0e 94 4f 0a 	call	0x149e <DF_ContinuousReadEnable>
		PacketBytes[0] = CMD_PROGRAM_EEPROM_ISP;
    324a:	85 e1       	ldi	r24, 0x15	; 21
    324c:	80 93 36 01 	sts	0x0136, r24
    3250:	f7 e3       	ldi	r31, 0x37	; 55
    3252:	ef 2e       	mov	r14, r31
    3254:	f1 e0       	ldi	r31, 0x01	; 1
    3256:	ff 2e       	mov	r15, r31
    3258:	18 e0       	ldi	r17, 0x08	; 8
	}

	for (uint8_t B = 1; B <= 9 ; B++)                 // Load in the write data command bytes
	{
		PacketBytes[B] = eeprom_read_byte_169(&EEPROMAddress); // Synthesise a write packet header
    325a:	ce 01       	movw	r24, r28
    325c:	01 96       	adiw	r24, 0x01	; 1
    325e:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
    3262:	f7 01       	movw	r30, r14
    3264:	81 93       	st	Z+, r24
    3266:	7f 01       	movw	r14, r30
		EEPROMAddress++;                               // Increment the EEPROM location counter
    3268:	89 81       	ldd	r24, Y+1	; 0x01
    326a:	9a 81       	ldd	r25, Y+2	; 0x02
    326c:	01 96       	adiw	r24, 0x01	; 1
    326e:	9a 83       	std	Y+2, r25	; 0x02
    3270:	89 83       	std	Y+1, r24	; 0x01
    3272:	11 50       	subi	r17, 0x01	; 1
    3274:	17 ff       	sbrs	r17, 7
    3276:	f1 cf       	rjmp	.-30     	; 0x325a <PM_CreateProgrammingPackets+0xdc>
	}
	
	BytesPerProgram = ((uint16_t)PacketBytes[1] << 8)
    3278:	80 91 37 01 	lds	r24, 0x0137
    327c:	99 27       	eor	r25, r25
    327e:	d8 2e       	mov	r13, r24
    3280:	cc 24       	eor	r12, r12
    3282:	80 91 38 01 	lds	r24, 0x0138
    3286:	99 27       	eor	r25, r25
    3288:	c8 2a       	or	r12, r24
    328a:	d9 2a       	or	r13, r25
	                | PacketBytes[2];

	while (BytesRead < BytesToRead)
	{
		if (PacketBytes[3] & ISPCC_PROG_MODE_PAGE)
		{
			if (PageLength > 160) // Max 160 bytes at a time
			{
				if (!(ContinuedPage))                      // Start of a new page, program in the first 150 bytes
				{
					BytesPerProgram = 160;
					PacketBytes[3] &= ~ISPCC_PROG_MODE_PAGEDONE;		
					ContinuedPage = TRUE;
				}
				else                                       // Middle of a page, program in the remainder
				{
					BytesPerProgram = PageLength - 160;
					PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
					ContinuedPage = FALSE;
				}
				
				for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page				

				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);
				PacketBytes[2] = (uint8_t)(BytesPerProgram);

				BytesRead += BytesPerProgram;                         // Increment the counter
			}
			else
			{
				for (uint16_t LoadB = 0; LoadB < PageLength; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page
			
				PacketBytes[1]  = (uint8_t)(PageLength >> 8);
				PacketBytes[2]  = (uint8_t)(PageLength);
				PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;

				BytesRead     += PageLength;                          // Increment the counter
			}
		}
		else
		{
			if ((BytesRead + BytesPerProgram) > BytesToRead)        // Less than a whole BytesPerProgram left of data to write
			{
				BytesPerProgram = BytesToRead - BytesRead;          // Next lot of bytes will be the remaining data length
				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);   // \. Save the new length
				PacketBytes[2] = (uint8_t)(BytesPerProgram);        // /  into the data packet
			}

			for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
				PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);    // Load in the page
			
			BytesRead += BytesPerProgram;                           // Increment the counter
		}
	
		if (!(BytesRead & 0xFFFF) && (BytesRead & 0x00FF0000))      // Extended address required
		{
			USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);            // Load extended address command
			USI_SPITransmit(0x00);
			USI_SPITransmit((BytesRead & 0x00FF0000) >> 16);        // The 3rd byte of the long holds the extended address
			USI_SPITransmit(0x00);
		}

		ISPCC_ProgramChip();                                        // Start the program cycle
    328c:	82 14       	cp	r8, r2
    328e:	93 04       	cpc	r9, r3
    3290:	a4 04       	cpc	r10, r4
    3292:	b5 04       	cpc	r11, r5
    3294:	08 f0       	brcs	.+2      	; 0x3298 <PM_CreateProgrammingPackets+0x11a>
    3296:	b7 c0       	rjmp	.+366    	; 0x3406 <PM_CreateProgrammingPackets+0x288>
    3298:	20 91 39 01 	lds	r18, 0x0139
    329c:	82 2f       	mov	r24, r18
    329e:	99 27       	eor	r25, r25
    32a0:	ac 01       	movw	r20, r24
    32a2:	41 70       	andi	r20, 0x01	; 1
    32a4:	50 70       	andi	r21, 0x00	; 0
    32a6:	80 ff       	sbrs	r24, 0
    32a8:	58 c0       	rjmp	.+176    	; 0x335a <PM_CreateProgrammingPackets+0x1dc>
    32aa:	f1 ea       	ldi	r31, 0xA1	; 161
    32ac:	6f 16       	cp	r6, r31
    32ae:	71 04       	cpc	r7, r1
    32b0:	88 f1       	brcs	.+98     	; 0x3314 <PM_CreateProgrammingPackets+0x196>
    32b2:	8b 81       	ldd	r24, Y+3	; 0x03
    32b4:	88 23       	and	r24, r24
    32b6:	49 f4       	brne	.+18     	; 0x32ca <PM_CreateProgrammingPackets+0x14c>
    32b8:	70 ea       	ldi	r23, 0xA0	; 160
    32ba:	c7 2e       	mov	r12, r23
    32bc:	d1 2c       	mov	r13, r1
    32be:	2f 77       	andi	r18, 0x7F	; 127
    32c0:	20 93 39 01 	sts	0x0139, r18
    32c4:	e1 e0       	ldi	r30, 0x01	; 1
    32c6:	eb 83       	std	Y+3, r30	; 0x03
    32c8:	0a c0       	rjmp	.+20     	; 0x32de <PM_CreateProgrammingPackets+0x160>
    32ca:	60 e6       	ldi	r22, 0x60	; 96
    32cc:	c6 2e       	mov	r12, r22
    32ce:	6f ef       	ldi	r22, 0xFF	; 255
    32d0:	d6 2e       	mov	r13, r22
    32d2:	c6 0c       	add	r12, r6
    32d4:	d7 1c       	adc	r13, r7
    32d6:	20 68       	ori	r18, 0x80	; 128
    32d8:	20 93 39 01 	sts	0x0139, r18
    32dc:	1b 82       	std	Y+3, r1	; 0x03
    32de:	00 e0       	ldi	r16, 0x00	; 0
    32e0:	10 e0       	ldi	r17, 0x00	; 0
    32e2:	0c 15       	cp	r16, r12
    32e4:	1d 05       	cpc	r17, r13
    32e6:	78 f4       	brcc	.+30     	; 0x3306 <PM_CreateProgrammingPackets+0x188>
    32e8:	50 e4       	ldi	r21, 0x40	; 64
    32ea:	e5 2e       	mov	r14, r21
    32ec:	51 e0       	ldi	r21, 0x01	; 1
    32ee:	f5 2e       	mov	r15, r21
    32f0:	80 e0       	ldi	r24, 0x00	; 0
    32f2:	0e 94 3d 09 	call	0x127a <SPI_SPITransmit>
    32f6:	f7 01       	movw	r30, r14
    32f8:	81 93       	st	Z+, r24
    32fa:	7f 01       	movw	r14, r30
    32fc:	0f 5f       	subi	r16, 0xFF	; 255
    32fe:	1f 4f       	sbci	r17, 0xFF	; 255
    3300:	0c 15       	cp	r16, r12
    3302:	1d 05       	cpc	r17, r13
    3304:	a8 f3       	brcs	.-22     	; 0x32f0 <PM_CreateProgrammingPackets+0x172>
    3306:	8d 2d       	mov	r24, r13
    3308:	99 27       	eor	r25, r25
    330a:	80 93 37 01 	sts	0x0137, r24
    330e:	c0 92 38 01 	sts	0x0138, r12
    3312:	4b c0       	rjmp	.+150    	; 0x33aa <PM_CreateProgrammingPackets+0x22c>
    3314:	00 e0       	ldi	r16, 0x00	; 0
    3316:	10 e0       	ldi	r17, 0x00	; 0
    3318:	06 15       	cp	r16, r6
    331a:	17 05       	cpc	r17, r7
    331c:	78 f4       	brcc	.+30     	; 0x333c <PM_CreateProgrammingPackets+0x1be>
    331e:	30 e4       	ldi	r19, 0x40	; 64
    3320:	e3 2e       	mov	r14, r19
    3322:	31 e0       	ldi	r19, 0x01	; 1
    3324:	f3 2e       	mov	r15, r19
    3326:	80 e0       	ldi	r24, 0x00	; 0
    3328:	0e 94 3d 09 	call	0x127a <SPI_SPITransmit>
    332c:	f7 01       	movw	r30, r14
    332e:	81 93       	st	Z+, r24
    3330:	7f 01       	movw	r14, r30
    3332:	0f 5f       	subi	r16, 0xFF	; 255
    3334:	1f 4f       	sbci	r17, 0xFF	; 255
    3336:	06 15       	cp	r16, r6
    3338:	17 05       	cpc	r17, r7
    333a:	a8 f3       	brcs	.-22     	; 0x3326 <PM_CreateProgrammingPackets+0x1a8>
    333c:	87 2d       	mov	r24, r7
    333e:	99 27       	eor	r25, r25
    3340:	80 93 37 01 	sts	0x0137, r24
    3344:	60 92 38 01 	sts	0x0138, r6
    3348:	80 91 39 01 	lds	r24, 0x0139
    334c:	80 68       	ori	r24, 0x80	; 128
    334e:	80 93 39 01 	sts	0x0139, r24
    3352:	c3 01       	movw	r24, r6
    3354:	aa 27       	eor	r26, r26
    3356:	bb 27       	eor	r27, r27
    3358:	2b c0       	rjmp	.+86     	; 0x33b0 <PM_CreateProgrammingPackets+0x232>
    335a:	c6 01       	movw	r24, r12
    335c:	aa 27       	eor	r26, r26
    335e:	bb 27       	eor	r27, r27
    3360:	88 0d       	add	r24, r8
    3362:	99 1d       	adc	r25, r9
    3364:	aa 1d       	adc	r26, r10
    3366:	bb 1d       	adc	r27, r11
    3368:	28 16       	cp	r2, r24
    336a:	39 06       	cpc	r3, r25
    336c:	4a 06       	cpc	r4, r26
    336e:	5b 06       	cpc	r5, r27
    3370:	48 f4       	brcc	.+18     	; 0x3384 <PM_CreateProgrammingPackets+0x206>
    3372:	61 01       	movw	r12, r2
    3374:	c8 18       	sub	r12, r8
    3376:	d9 08       	sbc	r13, r9
    3378:	8d 2d       	mov	r24, r13
    337a:	99 27       	eor	r25, r25
    337c:	80 93 37 01 	sts	0x0137, r24
    3380:	c0 92 38 01 	sts	0x0138, r12
    3384:	8a 01       	movw	r16, r20
    3386:	4c 15       	cp	r20, r12
    3388:	5d 05       	cpc	r21, r13
    338a:	78 f4       	brcc	.+30     	; 0x33aa <PM_CreateProgrammingPackets+0x22c>
    338c:	80 e4       	ldi	r24, 0x40	; 64
    338e:	e8 2e       	mov	r14, r24
    3390:	81 e0       	ldi	r24, 0x01	; 1
    3392:	f8 2e       	mov	r15, r24
    3394:	80 e0       	ldi	r24, 0x00	; 0
    3396:	0e 94 3d 09 	call	0x127a <SPI_SPITransmit>
    339a:	f7 01       	movw	r30, r14
    339c:	81 93       	st	Z+, r24
    339e:	7f 01       	movw	r14, r30
    33a0:	0f 5f       	subi	r16, 0xFF	; 255
    33a2:	1f 4f       	sbci	r17, 0xFF	; 255
    33a4:	0c 15       	cp	r16, r12
    33a6:	1d 05       	cpc	r17, r13
    33a8:	a8 f3       	brcs	.-22     	; 0x3394 <PM_CreateProgrammingPackets+0x216>
    33aa:	c6 01       	movw	r24, r12
    33ac:	aa 27       	eor	r26, r26
    33ae:	bb 27       	eor	r27, r27
    33b0:	88 0e       	add	r8, r24
    33b2:	99 1e       	adc	r9, r25
    33b4:	aa 1e       	adc	r10, r26
    33b6:	bb 1e       	adc	r11, r27
    33b8:	81 14       	cp	r8, r1
    33ba:	91 04       	cpc	r9, r1
    33bc:	e1 f4       	brne	.+56     	; 0x33f6 <PM_CreateProgrammingPackets+0x278>
    33be:	e1 2c       	mov	r14, r1
    33c0:	f1 2c       	mov	r15, r1
    33c2:	bf ef       	ldi	r27, 0xFF	; 255
    33c4:	0b 2f       	mov	r16, r27
    33c6:	11 2d       	mov	r17, r1
    33c8:	e8 20       	and	r14, r8
    33ca:	f9 20       	and	r15, r9
    33cc:	0a 21       	and	r16, r10
    33ce:	1b 21       	and	r17, r11
    33d0:	e1 14       	cp	r14, r1
    33d2:	f1 04       	cpc	r15, r1
    33d4:	01 05       	cpc	r16, r1
    33d6:	11 05       	cpc	r17, r1
    33d8:	71 f0       	breq	.+28     	; 0x33f6 <PM_CreateProgrammingPackets+0x278>
    33da:	8d e4       	ldi	r24, 0x4D	; 77
    33dc:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    33e0:	80 e0       	ldi	r24, 0x00	; 0
    33e2:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    33e6:	c8 01       	movw	r24, r16
    33e8:	aa 27       	eor	r26, r26
    33ea:	bb 27       	eor	r27, r27
    33ec:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    33f0:	80 e0       	ldi	r24, 0x00	; 0
    33f2:	0e 94 c3 09 	call	0x1386 <USI_SPITransmit>
    33f6:	0e 94 58 11 	call	0x22b0 <ISPCC_ProgramChip>
    33fa:	82 14       	cp	r8, r2
    33fc:	93 04       	cpc	r9, r3
    33fe:	a4 04       	cpc	r10, r4
    3400:	b5 04       	cpc	r11, r5
    3402:	08 f4       	brcc	.+2      	; 0x3406 <PM_CreateProgrammingPackets+0x288>
    3404:	49 cf       	rjmp	.-366    	; 0x3298 <PM_CreateProgrammingPackets+0x11a>
    3406:	23 96       	adiw	r28, 0x03	; 3
    3408:	0f b6       	in	r0, 0x3f	; 63
    340a:	f8 94       	cli
    340c:	de bf       	out	0x3e, r29	; 62
    340e:	0f be       	out	0x3f, r0	; 63
    3410:	cd bf       	out	0x3d, r28	; 61
    3412:	df 91       	pop	r29
    3414:	cf 91       	pop	r28
    3416:	1f 91       	pop	r17
    3418:	0f 91       	pop	r16
    341a:	ff 90       	pop	r15
    341c:	ef 90       	pop	r14
    341e:	df 90       	pop	r13
    3420:	cf 90       	pop	r12
    3422:	bf 90       	pop	r11
    3424:	af 90       	pop	r10
    3426:	9f 90       	pop	r9
    3428:	8f 90       	pop	r8
    342a:	7f 90       	pop	r7
    342c:	6f 90       	pop	r6
    342e:	5f 90       	pop	r5
    3430:	4f 90       	pop	r4
    3432:	3f 90       	pop	r3
    3434:	2f 90       	pop	r2
    3436:	08 95       	ret

00003438 <PM_ShowStoredItemSizes>:
	}
}

void PM_ShowStoredItemSizes(void)
{
    3438:	1f 93       	push	r17
    343a:	cf 93       	push	r28
    343c:	df 93       	push	r29
    343e:	cd b7       	in	r28, 0x3d	; 61
    3440:	de b7       	in	r29, 0x3e	; 62
    3442:	2e 97       	sbiw	r28, 0x0e	; 14
    3444:	0f b6       	in	r0, 0x3f	; 63
    3446:	f8 94       	cli
    3448:	de bf       	out	0x3e, r29	; 62
    344a:	0f be       	out	0x3f, r0	; 63
    344c:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[14];
	uint8_t ItemInfoIndex = 0;
    344e:	10 e0       	ldi	r17, 0x00	; 0
	uint8_t TempB;
	
	JoyStatus = 1;
    3450:	81 e0       	ldi	r24, 0x01	; 1
    3452:	8e bb       	out	0x1e, r24	; 30
	
	while (1)
	{
		if (JoyStatus)                           // Joystick is in the non-center position
    3454:	8e b3       	in	r24, 0x1e	; 30
    3456:	88 23       	and	r24, r24
    3458:	e9 f3       	breq	.-6      	; 0x3454 <PM_ShowStoredItemSizes+0x1c>
		{
			if (JoyStatus & JOY_UP)              // Previous item
    345a:	f6 9b       	sbis	0x1e, 6	; 30
    345c:	06 c0       	rjmp	.+12     	; 0x346a <PM_ShowStoredItemSizes+0x32>
				(ItemInfoIndex == 0)? ItemInfoIndex = 3 : ItemInfoIndex--;
    345e:	11 23       	and	r17, r17
    3460:	11 f4       	brne	.+4      	; 0x3466 <PM_ShowStoredItemSizes+0x2e>
    3462:	13 e0       	ldi	r17, 0x03	; 3
    3464:	0c c0       	rjmp	.+24     	; 0x347e <PM_ShowStoredItemSizes+0x46>
    3466:	11 50       	subi	r17, 0x01	; 1
    3468:	0a c0       	rjmp	.+20     	; 0x347e <PM_ShowStoredItemSizes+0x46>
			else if (JoyStatus & JOY_DOWN)      // Next item
    346a:	f7 9b       	sbis	0x1e, 7	; 30
    346c:	06 c0       	rjmp	.+12     	; 0x347a <PM_ShowStoredItemSizes+0x42>
				(ItemInfoIndex == 3)? ItemInfoIndex = 0 : ItemInfoIndex++;
    346e:	13 30       	cpi	r17, 0x03	; 3
    3470:	11 f4       	brne	.+4      	; 0x3476 <PM_ShowStoredItemSizes+0x3e>
    3472:	10 e0       	ldi	r17, 0x00	; 0
    3474:	04 c0       	rjmp	.+8      	; 0x347e <PM_ShowStoredItemSizes+0x46>
    3476:	1f 5f       	subi	r17, 0xFF	; 255
    3478:	02 c0       	rjmp	.+4      	; 0x347e <PM_ShowStoredItemSizes+0x46>
			else if (JoyStatus & JOY_LEFT)
    347a:	f2 99       	sbic	0x1e, 2	; 30
    347c:	53 c0       	rjmp	.+166    	; 0x3524 <PM_ShowStoredItemSizes+0xec>
				return;
		
			switch (ItemInfoIndex)
    347e:	81 2f       	mov	r24, r17
    3480:	99 27       	eor	r25, r25
    3482:	81 30       	cpi	r24, 0x01	; 1
    3484:	91 05       	cpc	r25, r1
    3486:	a1 f0       	breq	.+40     	; 0x34b0 <PM_ShowStoredItemSizes+0x78>
    3488:	82 30       	cpi	r24, 0x02	; 2
    348a:	91 05       	cpc	r25, r1
    348c:	1c f4       	brge	.+6      	; 0x3494 <PM_ShowStoredItemSizes+0x5c>
    348e:	89 2b       	or	r24, r25
    3490:	39 f0       	breq	.+14     	; 0x34a0 <PM_ShowStoredItemSizes+0x68>
    3492:	41 c0       	rjmp	.+130    	; 0x3516 <PM_ShowStoredItemSizes+0xde>
    3494:	82 30       	cpi	r24, 0x02	; 2
    3496:	91 05       	cpc	r25, r1
    3498:	01 f1       	breq	.+64     	; 0x34da <PM_ShowStoredItemSizes+0xa2>
    349a:	03 97       	sbiw	r24, 0x03	; 3
    349c:	39 f1       	breq	.+78     	; 0x34ec <PM_ShowStoredItemSizes+0xb4>
    349e:	3b c0       	rjmp	.+118    	; 0x3516 <PM_ShowStoredItemSizes+0xde>
			{
				case 0:
					strcpy_P(Buffer, PSTR("DATA-"));
    34a0:	64 ef       	ldi	r22, 0xF4	; 244
    34a2:	73 e0       	ldi	r23, 0x03	; 3
    34a4:	ce 01       	movw	r24, r28
    34a6:	01 96       	adiw	r24, 0x01	; 1
    34a8:	0e 94 68 1b 	call	0x36d0 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_FLASH), &Buffer[5], 10);
    34ac:	81 e0       	ldi	r24, 0x01	; 1
    34ae:	07 c0       	rjmp	.+14     	; 0x34be <PM_ShowStoredItemSizes+0x86>
					break;
				case 1:
					strcpy_P(Buffer, PSTR("EPRM-"));
    34b0:	6a ef       	ldi	r22, 0xFA	; 250
    34b2:	73 e0       	ldi	r23, 0x03	; 3
    34b4:	ce 01       	movw	r24, r28
    34b6:	01 96       	adiw	r24, 0x01	; 1
    34b8:	0e 94 68 1b 	call	0x36d0 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_EEPROM), &Buffer[5], 10);
    34bc:	80 e0       	ldi	r24, 0x00	; 0
    34be:	0e 94 b5 13 	call	0x276a <PM_GetStoredDataSize>
    34c2:	dc 01       	movw	r26, r24
    34c4:	cb 01       	movw	r24, r22
    34c6:	2a e0       	ldi	r18, 0x0A	; 10
    34c8:	30 e0       	ldi	r19, 0x00	; 0
    34ca:	ae 01       	movw	r20, r28
    34cc:	4a 5f       	subi	r20, 0xFA	; 250
    34ce:	5f 4f       	sbci	r21, 0xFF	; 255
    34d0:	bc 01       	movw	r22, r24
    34d2:	cd 01       	movw	r24, r26
    34d4:	0e 94 6f 1b 	call	0x36de <ultoa>
					break;
    34d8:	1e c0       	rjmp	.+60     	; 0x3516 <PM_ShowStoredItemSizes+0xde>
				case 2:
					strcpy_P(Buffer, PSTR("FUSE-"));
    34da:	60 e0       	ldi	r22, 0x00	; 0
    34dc:	74 e0       	ldi	r23, 0x04	; 4
    34de:	ce 01       	movw	r24, r28
    34e0:	01 96       	adiw	r24, 0x01	; 1
    34e2:	0e 94 68 1b 	call	0x36d0 <strcpy_P>
					TempB = eeprom_read_byte_169(&Prog_TotalFuseBytes);
    34e6:	80 e1       	ldi	r24, 0x10	; 16
    34e8:	91 e0       	ldi	r25, 0x01	; 1
    34ea:	08 c0       	rjmp	.+16     	; 0x34fc <PM_ShowStoredItemSizes+0xc4>
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);
					break;
				case 3:
					strcpy_P(Buffer, PSTR("LOCK-"));
    34ec:	66 e0       	ldi	r22, 0x06	; 6
    34ee:	74 e0       	ldi	r23, 0x04	; 4
    34f0:	ce 01       	movw	r24, r28
    34f2:	01 96       	adiw	r24, 0x01	; 1
    34f4:	0e 94 68 1b 	call	0x36d0 <strcpy_P>
					TempB = eeprom_read_byte_169(&Prog_TotalLockBytes);
    34f8:	8e e0       	ldi	r24, 0x0E	; 14
    34fa:	91 e0       	ldi	r25, 0x01	; 1
    34fc:	0e 94 b4 08 	call	0x1168 <eeprom_read_byte_169>
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);		
    3500:	8f 3f       	cpi	r24, 0xFF	; 255
    3502:	11 f0       	breq	.+4      	; 0x3508 <PM_ShowStoredItemSizes+0xd0>
    3504:	99 27       	eor	r25, r25
    3506:	02 c0       	rjmp	.+4      	; 0x350c <PM_ShowStoredItemSizes+0xd4>
    3508:	80 e0       	ldi	r24, 0x00	; 0
    350a:	90 e0       	ldi	r25, 0x00	; 0
    350c:	be 01       	movw	r22, r28
    350e:	6a 5f       	subi	r22, 0xFA	; 250
    3510:	7f 4f       	sbci	r23, 0xFF	; 255
    3512:	0e 94 30 03 	call	0x660 <MAIN_IntToStr>
			}
	
			LCD_puts(Buffer);
    3516:	ce 01       	movw	r24, r28
    3518:	01 96       	adiw	r24, 0x01	; 1
    351a:	0e 94 b9 07 	call	0xf72 <LCD_puts>

			MAIN_WaitForJoyRelease();
    351e:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
    3522:	98 cf       	rjmp	.-208    	; 0x3454 <PM_ShowStoredItemSizes+0x1c>
    3524:	2e 96       	adiw	r28, 0x0e	; 14
    3526:	0f b6       	in	r0, 0x3f	; 63
    3528:	f8 94       	cli
    352a:	de bf       	out	0x3e, r29	; 62
    352c:	0f be       	out	0x3f, r0	; 63
    352e:	cd bf       	out	0x3d, r28	; 61
    3530:	df 91       	pop	r29
    3532:	cf 91       	pop	r28
    3534:	1f 91       	pop	r17
    3536:	08 95       	ret

00003538 <TM_FindNextTag>:
	DF_EnableDataflash(FALSE);
}

void TM_FindNextTag(void)
{
    3538:	af 92       	push	r10
    353a:	bf 92       	push	r11
    353c:	df 92       	push	r13
    353e:	ef 92       	push	r14
    3540:	ff 92       	push	r15
    3542:	0f 93       	push	r16
    3544:	1f 93       	push	r17
    3546:	cf 93       	push	r28
    3548:	df 93       	push	r29
    354a:	cd b7       	in	r28, 0x3d	; 61
    354c:	de b7       	in	r29, 0x3e	; 62
    354e:	69 97       	sbiw	r28, 0x19	; 25
    3550:	0f b6       	in	r0, 0x3f	; 63
    3552:	f8 94       	cli
    3554:	de bf       	out	0x3e, r29	; 62
    3556:	0f be       	out	0x3f, r0	; 63
    3558:	cd bf       	out	0x3d, r28	; 61
	uint8_t  Buffer[21];
	uint8_t  HeadBuff[4]      = BT_TAGHEADER;
    355a:	80 e4       	ldi	r24, 0x40	; 64
    355c:	8e 8b       	std	Y+22, r24	; 0x16
    355e:	86 e1       	ldi	r24, 0x16	; 22
    3560:	a8 2e       	mov	r10, r24
    3562:	b1 2c       	mov	r11, r1
    3564:	ac 0e       	add	r10, r28
    3566:	bd 1e       	adc	r11, r29
    3568:	88 e2       	ldi	r24, 0x28	; 40
    356a:	8f 8b       	std	Y+23, r24	; 0x17
    356c:	83 e2       	ldi	r24, 0x23	; 35
    356e:	88 8f       	std	Y+24, r24	; 0x18
    3570:	89 e2       	ldi	r24, 0x29	; 41
    3572:	89 8f       	std	Y+25, r24	; 0x19
	uint32_t ProgDataSize     = PM_GetStoredDataSize(TYPE_FLASH);
    3574:	81 e0       	ldi	r24, 0x01	; 1
    3576:	0e 94 b5 13 	call	0x276a <PM_GetStoredDataSize>
    357a:	7b 01       	movw	r14, r22
    357c:	8c 01       	movw	r16, r24
	uint8_t  TotalOkHeadBytes = 0;
    357e:	dd 24       	eor	r13, r13
	uint8_t  TagByte;
	uint8_t  BytesRead;
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);    // Orange = busy
    3580:	81 b3       	in	r24, 0x11	; 17
    3582:	80 63       	ori	r24, 0x30	; 48
    3584:	81 bb       	out	0x11, r24	; 17

	while (DFPos < ProgDataSize)
	{
		BytesRead = 1;
		
		if (SPI_SPITransmit(0x00) == HeadBuff[TotalOkHeadBytes++])
		{
			if (TotalOkHeadBytes == 4)
			{
				uint8_t HB;
			
				for (HB = 0; HB < 20; HB++)
				{
					TagByte = SPI_SPITransmit(0x00);
					Buffer[HB] = TagByte;
					
					if (TagByte == 0x00)
					  break;
				}
				
				Buffer[20] = '\0';             // Make sure string is null-terminated

				TagExists = TRUE;
				BytesRead = (HB + 2);

				LCD_puts(Buffer);
				MAIN_SETSTATUSLED(MAIN_STATLED_GREEN); // Green = ready
				return;
			}
		}
		else
		{
			TotalOkHeadBytes = 0;
		}

		DFPos += BytesRead;
    3586:	80 91 d2 02 	lds	r24, 0x02D2
    358a:	90 91 d3 02 	lds	r25, 0x02D3
    358e:	a0 91 d4 02 	lds	r26, 0x02D4
    3592:	b0 91 d5 02 	lds	r27, 0x02D5
    3596:	8e 15       	cp	r24, r14
    3598:	9f 05       	cpc	r25, r15
    359a:	a0 07       	cpc	r26, r16
    359c:	b1 07       	cpc	r27, r17
    359e:	08 f0       	brcs	.+2      	; 0x35a2 <TM_FindNextTag+0x6a>
    35a0:	43 c0       	rjmp	.+134    	; 0x3628 <TM_FindNextTag+0xf0>
    35a2:	80 e0       	ldi	r24, 0x00	; 0
    35a4:	0e 94 3d 09 	call	0x127a <SPI_SPITransmit>
    35a8:	f5 01       	movw	r30, r10
    35aa:	ed 0d       	add	r30, r13
    35ac:	f1 1d       	adc	r31, r1
    35ae:	d3 94       	inc	r13
    35b0:	90 81       	ld	r25, Z
    35b2:	89 17       	cp	r24, r25
    35b4:	21 f5       	brne	.+72     	; 0x35fe <TM_FindNextTag+0xc6>
    35b6:	84 e0       	ldi	r24, 0x04	; 4
    35b8:	d8 16       	cp	r13, r24
    35ba:	11 f5       	brne	.+68     	; 0x3600 <TM_FindNextTag+0xc8>
    35bc:	ff 24       	eor	r15, r15
    35be:	00 e0       	ldi	r16, 0x00	; 0
    35c0:	10 e0       	ldi	r17, 0x00	; 0
    35c2:	80 e0       	ldi	r24, 0x00	; 0
    35c4:	0e 94 3d 09 	call	0x127a <SPI_SPITransmit>
    35c8:	9e 01       	movw	r18, r28
    35ca:	2f 5f       	subi	r18, 0xFF	; 255
    35cc:	3f 4f       	sbci	r19, 0xFF	; 255
    35ce:	f8 01       	movw	r30, r16
    35d0:	e2 0f       	add	r30, r18
    35d2:	f3 1f       	adc	r31, r19
    35d4:	80 83       	st	Z, r24
    35d6:	88 23       	and	r24, r24
    35d8:	31 f0       	breq	.+12     	; 0x35e6 <TM_FindNextTag+0xae>
    35da:	f3 94       	inc	r15
    35dc:	0f 5f       	subi	r16, 0xFF	; 255
    35de:	1f 4f       	sbci	r17, 0xFF	; 255
    35e0:	83 e1       	ldi	r24, 0x13	; 19
    35e2:	8f 15       	cp	r24, r15
    35e4:	70 f7       	brcc	.-36     	; 0x35c2 <TM_FindNextTag+0x8a>
    35e6:	1d 8a       	std	Y+21, r1	; 0x15
    35e8:	81 e0       	ldi	r24, 0x01	; 1
    35ea:	80 93 4d 02 	sts	0x024D, r24
    35ee:	c9 01       	movw	r24, r18
    35f0:	0e 94 b9 07 	call	0xf72 <LCD_puts>
    35f4:	81 b3       	in	r24, 0x11	; 17
    35f6:	8f 7c       	andi	r24, 0xCF	; 207
    35f8:	80 61       	ori	r24, 0x10	; 16
    35fa:	81 bb       	out	0x11, r24	; 17
    35fc:	31 c0       	rjmp	.+98     	; 0x3660 <TM_FindNextTag+0x128>
    35fe:	dd 24       	eor	r13, r13
    3600:	80 91 d2 02 	lds	r24, 0x02D2
    3604:	90 91 d3 02 	lds	r25, 0x02D3
    3608:	a0 91 d4 02 	lds	r26, 0x02D4
    360c:	b0 91 d5 02 	lds	r27, 0x02D5
    3610:	01 96       	adiw	r24, 0x01	; 1
    3612:	a1 1d       	adc	r26, r1
    3614:	b1 1d       	adc	r27, r1
    3616:	80 93 d2 02 	sts	0x02D2, r24
    361a:	90 93 d3 02 	sts	0x02D3, r25
    361e:	a0 93 d4 02 	sts	0x02D4, r26
    3622:	b0 93 d5 02 	sts	0x02D5, r27
    3626:	b7 cf       	rjmp	.-146    	; 0x3596 <TM_FindNextTag+0x5e>
	}
	
	DF_ContinuousReadEnable(0, 0);
    3628:	60 e0       	ldi	r22, 0x00	; 0
    362a:	70 e0       	ldi	r23, 0x00	; 0
    362c:	cb 01       	movw	r24, r22
    362e:	0e 94 4f 0a 	call	0x149e <DF_ContinuousReadEnable>
	DFPos = 0;
    3632:	10 92 d2 02 	sts	0x02D2, r1
    3636:	10 92 d3 02 	sts	0x02D3, r1
    363a:	10 92 d4 02 	sts	0x02D4, r1
    363e:	10 92 d5 02 	sts	0x02D5, r1
	
	if (TagExists == FALSE)
    3642:	80 91 4d 02 	lds	r24, 0x024D
    3646:	88 23       	and	r24, r24
    3648:	49 f4       	brne	.+18     	; 0x365c <TM_FindNextTag+0x124>
	{
		MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);  // Green = ready
    364a:	81 b3       	in	r24, 0x11	; 17
    364c:	8f 7c       	andi	r24, 0xCF	; 207
    364e:	80 61       	ori	r24, 0x10	; 16
    3650:	81 bb       	out	0x11, r24	; 17
		MAIN_ShowError(PSTR("NO TAGS"));
    3652:	8c e0       	ldi	r24, 0x0C	; 12
    3654:	94 e0       	ldi	r25, 0x04	; 4
    3656:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
    365a:	02 c0       	rjmp	.+4      	; 0x3660 <TM_FindNextTag+0x128>
	}
	else
	{
		/* The following line _is_ recursion, but the function will only ever call itself
		   a maximum of one time. The function will call itself upon skipping from the last
		   tag stored in the program data to the first; to guard against infinite recursion
		   if no tags are present, the system will error out if the TagExists flag is empty
		   after a full data read. Once a tag has been read and displayed onto the LCD, the
           function returns to the main tag handling routine.                               */
		TM_FindNextTag();
    365c:	0e 94 9c 1a 	call	0x3538 <TM_FindNextTag>
    3660:	69 96       	adiw	r28, 0x19	; 25
    3662:	0f b6       	in	r0, 0x3f	; 63
    3664:	f8 94       	cli
    3666:	de bf       	out	0x3e, r29	; 62
    3668:	0f be       	out	0x3f, r0	; 63
    366a:	cd bf       	out	0x3d, r28	; 61
    366c:	df 91       	pop	r29
    366e:	cf 91       	pop	r28
    3670:	1f 91       	pop	r17
    3672:	0f 91       	pop	r16
    3674:	ff 90       	pop	r15
    3676:	ef 90       	pop	r14
    3678:	df 90       	pop	r13
    367a:	bf 90       	pop	r11
    367c:	af 90       	pop	r10
    367e:	08 95       	ret

00003680 <TM_ShowTags>:
    3680:	60 e0       	ldi	r22, 0x00	; 0
    3682:	70 e0       	ldi	r23, 0x00	; 0
    3684:	cb 01       	movw	r24, r22
    3686:	0e 94 4f 0a 	call	0x149e <DF_ContinuousReadEnable>
    368a:	10 92 4d 02 	sts	0x024D, r1
    368e:	10 92 d2 02 	sts	0x02D2, r1
    3692:	10 92 d3 02 	sts	0x02D3, r1
    3696:	10 92 d4 02 	sts	0x02D4, r1
    369a:	10 92 d5 02 	sts	0x02D5, r1
    369e:	0e 94 9c 1a 	call	0x3538 <TM_FindNextTag>
    36a2:	80 91 4d 02 	lds	r24, 0x024D
    36a6:	88 23       	and	r24, r24
    36a8:	71 f0       	breq	.+28     	; 0x36c6 <TM_ShowTags+0x46>
    36aa:	8e b3       	in	r24, 0x1e	; 30
    36ac:	88 23       	and	r24, r24
    36ae:	e9 f3       	breq	.-6      	; 0x36aa <TM_ShowTags+0x2a>
    36b0:	f7 9b       	sbis	0x1e, 7	; 30
    36b2:	03 c0       	rjmp	.+6      	; 0x36ba <TM_ShowTags+0x3a>
    36b4:	0e 94 9c 1a 	call	0x3538 <TM_FindNextTag>
    36b8:	02 c0       	rjmp	.+4      	; 0x36be <TM_ShowTags+0x3e>
    36ba:	f2 99       	sbic	0x1e, 2	; 30
    36bc:	03 c0       	rjmp	.+6      	; 0x36c4 <TM_ShowTags+0x44>
    36be:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
    36c2:	f3 cf       	rjmp	.-26     	; 0x36aa <TM_ShowTags+0x2a>
    36c4:	80 e0       	ldi	r24, 0x00	; 0
    36c6:	0e 94 10 0a 	call	0x1420 <DF_EnableDataflash>
    36ca:	08 95       	ret

000036cc <__vector_2>:
.global PCINT0_vect             ; Pin change 0 (joystick)
.global PCINT1_vect             ; Pin change 1 (joystick)

PCINT0_vect:
  jmp PCINT1_vect
    36cc:	0c 94 90 03 	jmp	0x720 <__vector_3>

000036d0 <strcpy_P>:
    36d0:	fb 01       	movw	r30, r22
    36d2:	dc 01       	movw	r26, r24
    36d4:	05 90       	lpm	r0, Z+
    36d6:	0d 92       	st	X+, r0
    36d8:	00 20       	and	r0, r0
    36da:	e1 f7       	brne	.-8      	; 0x36d4 <strcpy_P+0x4>
    36dc:	08 95       	ret

000036de <ultoa>:
    36de:	fa 01       	movw	r30, r20
    36e0:	cf 93       	push	r28
    36e2:	ff 93       	push	r31
    36e4:	ef 93       	push	r30
    36e6:	22 30       	cpi	r18, 0x02	; 2
    36e8:	cc f0       	brlt	.+50     	; 0x371c <ultoa+0x3e>
    36ea:	25 32       	cpi	r18, 0x25	; 37
    36ec:	bc f4       	brge	.+46     	; 0x371c <ultoa+0x3e>
    36ee:	c2 2f       	mov	r28, r18
    36f0:	2c 2f       	mov	r18, r28
    36f2:	33 27       	eor	r19, r19
    36f4:	44 27       	eor	r20, r20
    36f6:	55 27       	eor	r21, r21
    36f8:	ff 93       	push	r31
    36fa:	ef 93       	push	r30
    36fc:	0e 94 c3 1b 	call	0x3786 <__udivmodsi4>
    3700:	ef 91       	pop	r30
    3702:	ff 91       	pop	r31
    3704:	60 5d       	subi	r22, 0xD0	; 208
    3706:	6a 33       	cpi	r22, 0x3A	; 58
    3708:	0c f0       	brlt	.+2      	; 0x370c <ultoa+0x2e>
    370a:	69 5d       	subi	r22, 0xD9	; 217
    370c:	61 93       	st	Z+, r22
    370e:	b9 01       	movw	r22, r18
    3710:	ca 01       	movw	r24, r20
    3712:	60 50       	subi	r22, 0x00	; 0
    3714:	70 40       	sbci	r23, 0x00	; 0
    3716:	80 40       	sbci	r24, 0x00	; 0
    3718:	90 40       	sbci	r25, 0x00	; 0
    371a:	51 f7       	brne	.-44     	; 0x36f0 <ultoa+0x12>
    371c:	10 82       	st	Z, r1
    371e:	8f 91       	pop	r24
    3720:	9f 91       	pop	r25
    3722:	cf 91       	pop	r28
    3724:	0c 94 94 1b 	jmp	0x3728 <strrev>

00003728 <strrev>:
    3728:	dc 01       	movw	r26, r24
    372a:	fc 01       	movw	r30, r24
    372c:	01 90       	ld	r0, Z+
    372e:	00 20       	and	r0, r0
    3730:	e9 f7       	brne	.-6      	; 0x372c <strrev+0x4>
    3732:	32 97       	sbiw	r30, 0x02	; 2
    3734:	ae 17       	cp	r26, r30
    3736:	bf 07       	cpc	r27, r31
    3738:	30 f4       	brcc	.+12     	; 0x3746 <strrev+0x1e>
    373a:	7c 91       	ld	r23, X
    373c:	60 81       	ld	r22, Z
    373e:	70 83       	st	Z, r23
    3740:	31 97       	sbiw	r30, 0x01	; 1
    3742:	6d 93       	st	X+, r22
    3744:	f7 cf       	rjmp	.-18     	; 0x3734 <strrev+0xc>
    3746:	08 95       	ret

00003748 <__mulsi3>:
    3748:	62 9f       	mul	r22, r18
    374a:	d0 01       	movw	r26, r0
    374c:	73 9f       	mul	r23, r19
    374e:	f0 01       	movw	r30, r0
    3750:	82 9f       	mul	r24, r18
    3752:	e0 0d       	add	r30, r0
    3754:	f1 1d       	adc	r31, r1
    3756:	64 9f       	mul	r22, r20
    3758:	e0 0d       	add	r30, r0
    375a:	f1 1d       	adc	r31, r1
    375c:	92 9f       	mul	r25, r18
    375e:	f0 0d       	add	r31, r0
    3760:	83 9f       	mul	r24, r19
    3762:	f0 0d       	add	r31, r0
    3764:	74 9f       	mul	r23, r20
    3766:	f0 0d       	add	r31, r0
    3768:	65 9f       	mul	r22, r21
    376a:	f0 0d       	add	r31, r0
    376c:	99 27       	eor	r25, r25
    376e:	72 9f       	mul	r23, r18
    3770:	b0 0d       	add	r27, r0
    3772:	e1 1d       	adc	r30, r1
    3774:	f9 1f       	adc	r31, r25
    3776:	63 9f       	mul	r22, r19
    3778:	b0 0d       	add	r27, r0
    377a:	e1 1d       	adc	r30, r1
    377c:	f9 1f       	adc	r31, r25
    377e:	bd 01       	movw	r22, r26
    3780:	cf 01       	movw	r24, r30
    3782:	11 24       	eor	r1, r1
    3784:	08 95       	ret

00003786 <__udivmodsi4>:
    3786:	a1 e2       	ldi	r26, 0x21	; 33
    3788:	1a 2e       	mov	r1, r26
    378a:	aa 1b       	sub	r26, r26
    378c:	bb 1b       	sub	r27, r27
    378e:	fd 01       	movw	r30, r26
    3790:	0d c0       	rjmp	.+26     	; 0x37ac <__udivmodsi4_ep>

00003792 <__udivmodsi4_loop>:
    3792:	aa 1f       	adc	r26, r26
    3794:	bb 1f       	adc	r27, r27
    3796:	ee 1f       	adc	r30, r30
    3798:	ff 1f       	adc	r31, r31
    379a:	a2 17       	cp	r26, r18
    379c:	b3 07       	cpc	r27, r19
    379e:	e4 07       	cpc	r30, r20
    37a0:	f5 07       	cpc	r31, r21
    37a2:	20 f0       	brcs	.+8      	; 0x37ac <__udivmodsi4_ep>
    37a4:	a2 1b       	sub	r26, r18
    37a6:	b3 0b       	sbc	r27, r19
    37a8:	e4 0b       	sbc	r30, r20
    37aa:	f5 0b       	sbc	r31, r21

000037ac <__udivmodsi4_ep>:
    37ac:	66 1f       	adc	r22, r22
    37ae:	77 1f       	adc	r23, r23
    37b0:	88 1f       	adc	r24, r24
    37b2:	99 1f       	adc	r25, r25
    37b4:	1a 94       	dec	r1
    37b6:	69 f7       	brne	.-38     	; 0x3792 <__udivmodsi4_loop>
    37b8:	60 95       	com	r22
    37ba:	70 95       	com	r23
    37bc:	80 95       	com	r24
    37be:	90 95       	com	r25
    37c0:	9b 01       	movw	r18, r22
    37c2:	ac 01       	movw	r20, r24
    37c4:	bd 01       	movw	r22, r26
    37c6:	cf 01       	movw	r24, r30
    37c8:	08 95       	ret
