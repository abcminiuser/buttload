
ButtLoad.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  00003580  00003634  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003580  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b2  00800104  00800104  00003638  2**0
                  ALLOC
  3 .eeprom       0000008e  00810000  00810000  00003638  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00000084  00000000  00000000  000036c8  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00000078  00000000  00000000  0000374c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 0000012c  00000000  00000000  000037c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 00000d48  00000000  00000000  000038f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00004552  00000000  00000000  00004638  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000012e2  00000000  00000000  00008b8a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00003357  00000000  00000000  00009e6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000004ec  00000000  00000000  0000d1c3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000011c7  00000000  00000000  0000d6af  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00001206  00000000  00000000  0000e876  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000070  00000000  00000000  0000fa7c  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 33 02 	jmp	0x466	; 0x466 <__ctors_end>
       4:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
       8:	0c 94 31 1a 	jmp	0x3462	; 0x3462 <__vector_2>
       c:	0c 94 bb 02 	jmp	0x576	; 0x576 <__vector_3>
      10:	0c 94 aa 0c 	jmp	0x1954	; 0x1954 <__vector_4>
      14:	0c 94 48 08 	jmp	0x1090	; 0x1090 <__vector_5>
      18:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      1c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      20:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      24:	0c 94 70 0c 	jmp	0x18e0	; 0x18e0 <__vector_9>
      28:	0c 94 33 1a 	jmp	0x3466	; 0x3466 <__vector_10>
      2c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      30:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      34:	0c 94 fe 0b 	jmp	0x17fc	; 0x17fc <__vector_13>
      38:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      3c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      40:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      44:	0c 94 c5 09 	jmp	0x138a	; 0x138a <__vector_17>
      48:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      4c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      50:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      54:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      58:	0c 94 bb 08 	jmp	0x1176	; 0x1176 <__vector_22>

0000005c <BUTTTAG_Title>:
      5c:	40 28 23 29 42 55 54 54 4c 4f 41 44 20 41 56 52     @(#)BUTTLOAD AVR
      6c:	49 53 50 00                                         ISP.

00000070 <BUTTTAG_Version>:
      70:	40 28 23 29 56 31 2d 34 00                          @(#)V1-4.

00000079 <BUTTTAG_Author>:
      79:	40 28 23 29 42 59 20 44 45 41 4e 20 43 41 4d 45     @(#)BY DEAN CAME
      89:	52 41 00                                            RA.

0000008c <BUTTTAG_Copyright>:
      8c:	40 28 23 29 3c 43 3e 20 32 30 30 36 20 2d 20 47     @(#)<C> 2006 - G
      9c:	50 4c 00                                            PL.

0000009f <AboutTextPtrs>:
      9f:	60 00 74 00 7d 00 90 00                             `.t.}...

000000a7 <WaitText>:
      a7:	2a 57 41 49 54 2a 00                                *WAIT*.

000000ae <Func_ISPPRGM>:
      ae:	41 56 52 49 53 50 20 4d 4f 44 45 00                 AVRISP MODE.

000000ba <Func_STOREPRGM>:
      ba:	53 54 4f 52 45 20 50 52 47 4d 00                    STORE PRGM.

000000c5 <Func_PRGMAVR>:
      c5:	50 52 4f 47 52 41 4d 20 41 56 52 00                 PROGRAM AVR.

000000d1 <Func_PRGMDATAFLASH>:
      d1:	44 41 54 41 46 4c 41 53 48 20 50 52 47 4d 00        DATAFLASH PRGM.

000000e0 <Func_PRGMSTOREINFO>:
      e0:	44 41 54 41 53 54 4f 52 45 20 49 4e 46 4f 00        DATASTORE INFO.

000000ef <Func_SETTINGS>:
      ef:	53 45 54 54 49 4e 47 53 00                          SETTINGS.

000000f8 <Func_SLEEP>:
      f8:	53 4c 45 45 50 20 4d 4f 44 45 00                    SLEEP MODE.

00000103 <MainFunctionNames>:
     103:	ae 00 ba 00 c5 00 d1 00 e0 00 ef 00 f8 00           ..............

00000111 <MainFunctionPtrs>:
     111:	8a 04 5c 04 ef 04 9f 04 e9 03 2c 03 da 02           ..\.......,...

0000011f <SFunc_SETCONTRAST>:
     11f:	53 45 54 20 43 4f 4e 54 52 41 53 54 00              SET CONTRAST.

0000012c <SFunc_SETSPISPEED>:
     12c:	53 45 54 20 49 53 50 20 53 50 45 45 44 00           SET ISP SPEED.

0000013a <SFunc_SETRESETMODE>:
     13a:	53 45 54 20 52 45 53 45 54 20 4d 4f 44 45 00        SET RESET MODE.

00000149 <SFunc_SETFIRMMINOR>:
     149:	53 45 54 20 46 49 52 4d 20 56 45 52 53 49 4f 4e     SET FIRM VERSION
	...

0000015a <SFunc_SETAUTOSLEEPTO>:
     15a:	53 45 54 20 53 4c 45 45 50 20 54 49 4d 45 4f 55     SET SLEEP TIMEOU
     16a:	54 00                                               T.

0000016c <SFunc_CLEARMEM>:
     16c:	43 4c 45 41 52 20 4d 45 4d 4f 52 59 00              CLEAR MEMORY.

00000179 <SFunc_GOBOOTLOADER>:
     179:	4a 55 4d 50 20 54 4f 20 42 4f 4f 54 4c 4f 41 44     JUMP TO BOOTLOAD
     189:	45 52 00                                            ER.

0000018c <SettingFunctionNames>:
     18c:	1f 01 2c 01 3a 01 49 01 5a 01 6c 01 79 01           ..,.:.I.Z.l.y.

0000019a <SettingFunctionPtrs>:
     19a:	f5 06 41 07 74 07 9c 07 61 03 c2 06 f4 02           ..A.t...a.....

000001a8 <PRG_A>:
     1a8:	50 52 47 4d 20 41 4c 4c 00                          PRGM ALL.

000001b1 <PRG_D>:
     1b1:	44 41 54 41 20 4f 4e 4c 59 00                       DATA ONLY.

000001bb <PRG_E>:
     1bb:	45 45 50 52 4f 4d 20 4f 4e 4c 59 00                 EEPROM ONLY.

000001c7 <PRG_DE>:
     1c7:	44 41 54 41 20 41 4e 44 20 45 45 50 52 4f 4d 00     DATA AND EEPROM.

000001d7 <PRG_F>:
     1d7:	46 55 53 45 20 42 59 54 45 53 20 4f 4e 4c 59 00     FUSE BYTES ONLY.

000001e7 <PRG_L>:
     1e7:	4c 4f 43 4b 20 42 59 54 45 53 20 4f 4e 4c 59 00     LOCK BYTES ONLY.

000001f7 <PRG_FL>:
     1f7:	46 55 53 45 20 41 4e 44 20 4c 4f 43 4b 20 42 59     FUSE AND LOCK BY
     207:	54 45 53 00                                         TES.

0000020b <PRG_C>:
     20b:	45 52 41 53 45 20 4f 4e 4c 59 00                    ERASE ONLY.

00000216 <ProgOptions>:
     216:	a8 01 b1 01 bb 01 c7 01 d7 01 e7 01 f7 01 0b 02     ................

00000226 <USISpeeds>:
     226:	20 35 37 31 35 33 20 48 5a 00 20 38 36 37 33 38      57153 HZ. 86738
     236:	20 48 5a 00 31 31 33 34 32 37 20 48 5a 00 32 31      HZ.113427 HZ.21
     246:	30 36 35 31 20 48 5a 00                             0651 HZ.

0000024e <SPIResetModes>:
     24e:	4c 4f 47 49 43 00 46 4c 4f 41 54 00                 LOGIC.FLOAT.

0000025a <SIFONames>:
     25a:	53 54 4f 52 41 47 45 20 53 49 5a 45 53 00 00 56     STORAGE SIZES..V
     26a:	49 45 57 20 44 41 54 41 20 54 41 47 53 00           IEW DATA TAGS.

00000278 <__c.2508>:
     278:	2a 4a 54 41 47 20 4f 4e 2a 00                       *JTAG ON*.

00000282 <__c.2479>:
     282:	4e 4f 20 53 54 4f 52 45 44 20 50 52 47 4d 00        NO STORED PRGM.

00000291 <__c.2425>:
     291:	4f 46 46 00                                         OFF.

00000295 <__c.2423>:
     295:	20 20 20 20 53 45 43 00                                 SEC.

0000029d <__c.2402>:
     29d:	56 32 2d 20 00                                      V2- .

000002a2 <__c.2304>:
     2a2:	4d 45 4d 20 43 4c 45 41 52 45 44 00                 MEM CLEARED.

000002ae <__c.2296>:
     2ae:	3c 4e 20 59 3e 00                                   <N Y>.

000002b4 <__c.2294>:
     2b4:	43 4f 4e 46 49 52 4d 00                             CONFIRM.

000002bc <__c.2277>:
     2bc:	2a 53 54 4f 52 41 47 45 20 4d 4f 44 45 2a 00        *STORAGE MODE*.

000002cb <__c.2210>:
     2cb:	46 41 49 4c 45 44 00                                FAILED.

000002d2 <__c.2208>:
     2d2:	50 52 4f 47 52 41 4d 4d 49 4e 47 20 44 4f 4e 45     PROGRAMMING DONE
	...

000002e3 <__c.2206>:
     2e3:	4e 4f 20 4c 4f 43 4b 20 42 59 54 45 53 00           NO LOCK BYTES.

000002f1 <__c.2204>:
     2f1:	4e 4f 20 46 55 53 45 20 42 59 54 45 53 00           NO FUSE BYTES.

000002ff <__c.2202>:
     2ff:	4e 4f 20 45 45 50 52 4f 4d 00                       NO EEPROM.

00000309 <__c.2200>:
     309:	4e 4f 20 44 41 54 41 00                             NO DATA.

00000311 <__c.2198>:
     311:	4e 4f 20 45 52 41 53 45 20 43 4d 44 00              NO ERASE CMD.

0000031e <__c.2095>:
     31e:	42 41 44 49 53 52 00                                BADISR.

00000325 <__c.2032>:
     325:	50 52 47 3e 20 20 00                                PRG>  .

0000032c <LCD_SegTable>:
     32c:	a8 ea 80 2a 00 40 00 0a 51 0a 08 40 59 55 18 01     ...*.@..Q..@YU..
     33c:	11 1e 11 1b 50 0b 41 1b 41 1f 11 01 51 1f 51 1b     ....P.A.A...Q.Q.
     34c:	00 00 00 00 08 80 00 1a 20 40 00 00 00 00 51 0f     ........ @....Q.
     35c:	91 39 41 14 91 31 41 1e 41 0e 41 1d 50 0f 80 20     .9A..1A.A.A.P.. 
     36c:	10 15 48 86 40 14 78 05 70 85 51 15 51 0e 51 95     ..H.@.x.p.Q.Q.Q.
     37c:	51 8e 21 90 81 20 50 15 48 44 50 c5 28 c0 28 20     Q.!.. P.HDP.(.( 
     38c:	09 50 41 14 20 80 11 11 00 00 00 10                 .PA. .......

00000398 <USIPSValues>:
     398:	03 80 02 54 01 40 00 22                             ...T.@."

000003a0 <DF_PageBits>:
     3a0:	09 09 09 09 09 0a 0a 0b                             ........

000003a8 <DF_PageSize>:
     3a8:	08 01 08 01 08 01 08 01 08 01 10 02 10 02 20 04     .............. .

000003b8 <DF_Pages>:
     3b8:	00 01 00 02 00 04 00 08 00 10 00 10 00 20 00 20     ............. . 

000003c8 <DataFlashError>:
     3c8:	44 41 54 41 46 4c 41 53 48 20 45 52 52 4f 52 00     DATAFLASH ERROR.

000003d8 <__c.1862>:
     3d8:	42 55 46 46 20 4f 56 46 00                          BUFF OVF.

000003e1 <AutoSleepTOValues>:
     3e1:	00 0f 1e 3c 78                                      ...<x

000003e6 <__c.1865>:
     3e6:	46 52 41 4d 45 20 45 52 52 00                       FRAME ERR.

000003f0 <__c.1863>:
     3f0:	44 41 54 41 20 4f 56 52 00                          DATA OVR.

000003f9 <DataFlashProgMode>:
     3f9:	2a 44 41 54 41 46 4c 41 53 48 20 4d 4f 44 45 2a     *DATAFLASH MODE*
	...

0000040a <SignonResponse>:
     40a:	01 00 08 41 56 52 49 53 50 5f 32 00                 ...AVRISP_2.

00000416 <ButtLoadData>:
     416:	40 28 23 29 2a 53 43 52 45 57 20 52 45 54 52 4f     @(#)*SCREW RETRO
     426:	44 41 4e 00 2a                                      DAN.*

0000042b <SyncErrorMessage>:
     42b:	53 59 4e 43 20 45 52 52 4f 52 00                    SYNC ERROR.

00000436 <AVRISPModeMessage>:
     436:	2a 41 54 41 56 52 49 53 50 20 4d 4f 44 45 2a 00     *ATAVRISP MODE*.

00000446 <__c.2144>:
     446:	4c 4f 43 4b 2d 00                                   LOCK-.

0000044c <__c.2141>:
     44c:	46 55 53 45 2d 00                                   FUSE-.

00000452 <__c.2138>:
     452:	45 50 52 4d 2d 00                                   EPRM-.

00000458 <__c.2134>:
     458:	44 41 54 41 2d 00                                   DATA-.

0000045e <__c.1884>:
     45e:	4e 4f 20 54 41 47 53 00                             NO TAGS.

00000466 <__ctors_end>:
     466:	11 24       	eor	r1, r1
     468:	1f be       	out	0x3f, r1	; 63
     46a:	cf ef       	ldi	r28, 0xFF	; 255
     46c:	d4 e0       	ldi	r29, 0x04	; 4
     46e:	de bf       	out	0x3e, r29	; 62
     470:	cd bf       	out	0x3d, r28	; 61

00000472 <__do_copy_data>:
     472:	11 e0       	ldi	r17, 0x01	; 1
     474:	a0 e0       	ldi	r26, 0x00	; 0
     476:	b1 e0       	ldi	r27, 0x01	; 1
     478:	e0 e8       	ldi	r30, 0x80	; 128
     47a:	f5 e3       	ldi	r31, 0x35	; 53
     47c:	02 c0       	rjmp	.+4      	; 0x482 <.do_copy_data_start>

0000047e <.do_copy_data_loop>:
     47e:	05 90       	lpm	r0, Z+
     480:	0d 92       	st	X+, r0

00000482 <.do_copy_data_start>:
     482:	a4 30       	cpi	r26, 0x04	; 4
     484:	b1 07       	cpc	r27, r17
     486:	d9 f7       	brne	.-10     	; 0x47e <.do_copy_data_loop>

00000488 <__do_clear_bss>:
     488:	12 e0       	ldi	r17, 0x02	; 2
     48a:	a4 e0       	ldi	r26, 0x04	; 4
     48c:	b1 e0       	ldi	r27, 0x01	; 1
     48e:	01 c0       	rjmp	.+2      	; 0x492 <.do_clear_bss_start>

00000490 <.do_clear_bss_loop>:
     490:	1d 92       	st	X+, r1

00000492 <.do_clear_bss_start>:
     492:	a6 3b       	cpi	r26, 0xB6	; 182
     494:	b1 07       	cpc	r27, r17
     496:	e1 f7       	brne	.-8      	; 0x490 <.do_clear_bss_loop>
     498:	0e 94 32 06 	call	0xc64	; 0xc64 <main>
     49c:	0c 94 bf 1a 	jmp	0x357e	; 0x357e <_exit>

000004a0 <__bad_interrupt>:
     4a0:	0c 94 eb 04 	jmp	0x9d6	; 0x9d6 <__vector_default>

000004a4 <MAIN_Delay10MS>:

// ======================================================================================

void MAIN_Delay10MS(uint8_t loops)
{
     4a4:	28 2f       	mov	r18, r24
     4a6:	e0 e0       	ldi	r30, 0x00	; 0
     4a8:	f8 e4       	ldi	r31, 0x48	; 72
     4aa:	03 c0       	rjmp	.+6      	; 0x4b2 <MAIN_Delay10MS+0xe>
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     4ac:	cf 01       	movw	r24, r30
     4ae:	01 97       	sbiw	r24, 0x01	; 1
     4b0:	f1 f7       	brne	.-4      	; 0x4ae <MAIN_Delay10MS+0xa>
  /* Prevents the use of floating point libraries. Delaying in groups of
     10ms increases accuracy by reducing the time overhead for each loop
     interation of the while.                                            */

	while (loops--)
     4b2:	21 50       	subi	r18, 0x01	; 1
     4b4:	d8 f7       	brcc	.-10     	; 0x4ac <MAIN_Delay10MS+0x8>
     4b6:	08 95       	ret

000004b8 <MAIN_Delay1MS>:
	  _delay_ms(10);
}

void MAIN_Delay1MS(uint8_t loops)
{
     4b8:	28 2f       	mov	r18, r24
     4ba:	e3 e3       	ldi	r30, 0x33	; 51
     4bc:	f7 e0       	ldi	r31, 0x07	; 7
     4be:	03 c0       	rjmp	.+6      	; 0x4c6 <MAIN_Delay1MS+0xe>
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     4c0:	cf 01       	movw	r24, r30
     4c2:	01 97       	sbiw	r24, 0x01	; 1
     4c4:	f1 f7       	brne	.-4      	; 0x4c2 <MAIN_Delay1MS+0xa>
  /* Prevents the use of floating point libraries. Less accurate than the
     Delay10MS routine, but nessesary for many commands. The overhead required
     to call the routine is substantially less than the overhead required to
     calculate the float at compile time, so this actually saves execution time. */

	while (loops--)
     4c6:	21 50       	subi	r18, 0x01	; 1
     4c8:	d8 f7       	brcc	.-10     	; 0x4c0 <MAIN_Delay1MS+0x8>
     4ca:	08 95       	ret

000004cc <MAIN_ResetCSLine>:
	  _delay_ms(1);
}

void MAIN_ResetCSLine(const uint8_t ActiveInactive)
{
     4cc:	81 30       	cpi	r24, 0x01	; 1
     4ce:	81 f0       	breq	.+32     	; 0x4f0 <MAIN_ResetCSLine+0x24>
	/* ActiveInactive controls the /Reset line to an AVR device or external dataflash
	/CS line. If the reset polarity parameter is a 0 then interfacing with AT89
	devices which has an active high reset. Pins are tristated when inactive.         */
	
	switch (ActiveInactive)
     4d0:	81 30       	cpi	r24, 0x01	; 1
     4d2:	18 f0       	brcs	.+6      	; 0x4da <MAIN_ResetCSLine+0xe>
     4d4:	82 30       	cpi	r24, 0x02	; 2
     4d6:	01 f5       	brne	.+64     	; 0x518 <__stack+0x19>
     4d8:	09 c0       	rjmp	.+18     	; 0x4ec <MAIN_ResetCSLine+0x20>
	{
		case MAIN_RESETCS_ACTIVE:                // The target RESET line may be either active high or low.
			DDRF |= (1 << 6);
     4da:	86 9a       	sbi	0x10, 6	; 16
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     4dc:	a1 e0       	ldi	r26, 0x01	; 1
     4de:	b0 e0       	ldi	r27, 0x00	; 0
     4e0:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
     4e4:	80 2d       	mov	r24, r0
		
			if (eeprom_read_byte(&EEPROMVars.ResetPolarity)) // Translate to correct active logic level for target device type
     4e6:	88 23       	and	r24, r24
     4e8:	59 f4       	brne	.+22     	; 0x500 <__stack+0x1>
     4ea:	13 c0       	rjmp	.+38     	; 0x512 <__stack+0x13>
			  PORTF &= ~(1 << 6);
			else
			  PORTF |= (1 << 6);
		
			break;
		case MAIN_RESETCS_EXTDFACTIVE:           // Dataflashes are always active low.
			DDRF  |=  (1 << 6);
     4ec:	86 9a       	sbi	0x10, 6	; 16
     4ee:	08 c0       	rjmp	.+16     	; 0x500 <__stack+0x1>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     4f0:	ac e8       	ldi	r26, 0x8C	; 140
     4f2:	b0 e0       	ldi	r27, 0x00	; 0
     4f4:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
     4f8:	80 2d       	mov	r24, r0
			PORTF &= ~(1 << 6);
			
			break;
		case MAIN_RESETCS_INACTIVE:              // Must determine what to do for inactive RESET.
			if (eeprom_read_byte(&EEPROMVars.SPIResetMode)) // FLOAT mode reset
     4fa:	88 23       	and	r24, r24
     4fc:	19 f0       	breq	.+6      	; 0x504 <__stack+0x5>
			{
				DDRF  &= ~(1 << 6);
     4fe:	86 98       	cbi	0x10, 6	; 16
				PORTF &= ~(1 << 6);
     500:	8e 98       	cbi	0x11, 6	; 17
     502:	08 95       	ret
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     504:	a1 e0       	ldi	r26, 0x01	; 1
     506:	b0 e0       	ldi	r27, 0x00	; 0
     508:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
     50c:	80 2d       	mov	r24, r0
			}
			else                                 // ACTIVE mode reset
			{
				if (eeprom_read_byte(&EEPROMVars.ResetPolarity)) // Translate to correct inactive logic level for target device type
     50e:	88 23       	and	r24, r24
     510:	11 f0       	breq	.+4      	; 0x516 <__stack+0x17>
				  PORTF |= (1 << 6);
     512:	8e 9a       	sbi	0x11, 6	; 17
     514:	08 95       	ret
				else
				  PORTF &= ~(1 << 6);			
     516:	8e 98       	cbi	0x11, 6	; 17
     518:	08 95       	ret

0000051a <MAIN_WaitForJoyRelease>:
			}
	}
}

void MAIN_WaitForJoyRelease(void)
{
     51a:	8e b3       	in	r24, 0x1e	; 30
     51c:	81 30       	cpi	r24, 0x01	; 1
     51e:	11 f4       	brne	.+4      	; 0x524 <MAIN_WaitForJoyRelease+0xa>
	if (JoyStatus == JOY_INVALID)                // If invalid value used to force menu drawing, reset value and exit
	{
		JoyStatus = 0;
     520:	1e ba       	out	0x1e, r1	; 30
     522:	08 95       	ret
		return;
	}

	for (;;)
	{
		while (JoyStatus) {};                    // Wait until joystick released
     524:	8e b3       	in	r24, 0x1e	; 30
     526:	88 23       	and	r24, r24
     528:	e9 f7       	brne	.-6      	; 0x524 <MAIN_WaitForJoyRelease+0xa>

		MAIN_Delay10MS(2);
     52a:	82 e0       	ldi	r24, 0x02	; 2
     52c:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>

		if (!(JoyStatus))                        // Joystick still released (not bouncing), return
     530:	8e b3       	in	r24, 0x1e	; 30
     532:	88 23       	and	r24, r24
     534:	b9 f7       	brne	.-18     	; 0x524 <MAIN_WaitForJoyRelease+0xa>
     536:	08 95       	ret

00000538 <MAIN_IntToStr>:
		  return;
	}
}

void MAIN_IntToStr(uint16_t IntV, uint8_t* Buff)
{
     538:	cf 93       	push	r28
     53a:	df 93       	push	r29
     53c:	fb 01       	movw	r30, r22
     53e:	20 e0       	ldi	r18, 0x00	; 0
     540:	03 c0       	rjmp	.+6      	; 0x548 <MAIN_IntToStr+0x10>
	// Shows leading zeros, unlike itoa.

	uint8_t Temp = 0;
	
	while (IntV >= 100)
	{
		Temp++;
     542:	2f 5f       	subi	r18, 0xFF	; 255
		IntV -= 100;
     544:	84 56       	subi	r24, 0x64	; 100
     546:	90 40       	sbci	r25, 0x00	; 0
     548:	84 36       	cpi	r24, 0x64	; 100
     54a:	91 05       	cpc	r25, r1
     54c:	d0 f7       	brcc	.-12     	; 0x542 <MAIN_IntToStr+0xa>
	}

	*(Buff++) = '0' + Temp;
     54e:	20 5d       	subi	r18, 0xD0	; 208
     550:	21 93       	st	Z+, r18
     552:	df 01       	movw	r26, r30
     554:	20 e0       	ldi	r18, 0x00	; 0
     556:	02 c0       	rjmp	.+4      	; 0x55c <MAIN_IntToStr+0x24>
	
	Temp = 0;
	
	while (IntV >= 10)
	{
		Temp++;
     558:	2f 5f       	subi	r18, 0xFF	; 255
		IntV -= 10;
     55a:	0a 97       	sbiw	r24, 0x0a	; 10
     55c:	8a 30       	cpi	r24, 0x0A	; 10
     55e:	91 05       	cpc	r25, r1
     560:	d8 f7       	brcc	.-10     	; 0x558 <MAIN_IntToStr+0x20>
	}
		
	*(Buff++) = '0' + Temp;
     562:	20 5d       	subi	r18, 0xD0	; 208
     564:	fd 01       	movw	r30, r26
     566:	21 93       	st	Z+, r18
	*(Buff++) = '0' + IntV;
     568:	80 5d       	subi	r24, 0xD0	; 208
     56a:	ed 01       	movw	r28, r26
     56c:	89 83       	std	Y+1, r24	; 0x01
	*(Buff)   = '\0';
     56e:	11 82       	std	Z+1, r1	; 0x01
     570:	df 91       	pop	r29
     572:	cf 91       	pop	r28
     574:	08 95       	ret

00000576 <__vector_3>:
}

void MAIN_ShowProgType(const uint8_t Letter)
{
	uint8_t ProgTypeBuffer[7];

	strcpy_P(ProgTypeBuffer, PSTR("PRG>  "));
	ProgTypeBuffer[5] = Letter;
	
	LCD_puts(ProgTypeBuffer);
}

void MAIN_ShowError(const uint8_t *pFlashStr)
{
	uint8_t ErrorBuff[LCD_TEXTBUFFER_SIZE];      // New buffer, LCD text buffer size
	
	ErrorBuff[0] = 'E';
	ErrorBuff[1] = '>';

	strcpy_P(&ErrorBuff[2], pFlashStr);          // WARNING: If flash error text is larger than (TEXTBUFFER_SIZE - 1),
	                                             // this will overflow the buffer and crash the program!
	LCD_puts(ErrorBuff);
	
	MAIN_WaitForJoyRelease();
	while (!(JoyStatus & JOY_PRESS)) {};
	MAIN_WaitForJoyRelease();
}

void MAIN_CrashProgram(const uint8_t *ErrTxtPtr)
{
	SPI_SPIOFF();
	USI_SPIOff();
	TIMEOUT_PACKET_TIMER_OFF();
	TIMEOUT_SLEEP_TIMER_OFF();
	USART_ENABLE(USART_TX_OFF, USART_RX_OFF);

	LCD_puts_f(ErrTxtPtr);
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);	

	for (;;)
	{
		MAIN_Delay10MS(50);
		PORTF ^= MAIN_STATLED_GREEN;               // Loop forever, blinking the status LED from orange to red and back
	}
}

// ======================================================================================

ISR(PCINT1_vect, ISR_NOBLOCK)                    // Joystick routine; PCINT0_vect is bound to this also via JoystickInterrupt.S
{
     576:	78 94       	sei
     578:	1f 92       	push	r1
     57a:	0f 92       	push	r0
     57c:	0f b6       	in	r0, 0x3f	; 63
     57e:	0f 92       	push	r0
     580:	11 24       	eor	r1, r1
     582:	8f 93       	push	r24
     584:	9f 93       	push	r25
	JoyStatus = (~PINB & JOY_BMASK)
     586:	83 b1       	in	r24, 0x03	; 3
     588:	9c b1       	in	r25, 0x0c	; 12
     58a:	80 95       	com	r24
     58c:	80 7d       	andi	r24, 0xD0	; 208
     58e:	90 95       	com	r25
     590:	9c 70       	andi	r25, 0x0C	; 12
     592:	89 2b       	or	r24, r25
     594:	8e bb       	out	0x1e, r24	; 30
	          | (~PINE & JOY_EMASK);
			  
	TIMEOUT_SLEEP_TIMEOUT_RESET();
     596:	10 92 8e 01 	sts	0x018E, r1
     59a:	10 92 8d 01 	sts	0x018D, r1
     59e:	10 92 85 00 	sts	0x0085, r1
     5a2:	10 92 84 00 	sts	0x0084, r1
     5a6:	9f 91       	pop	r25
     5a8:	8f 91       	pop	r24
     5aa:	0f 90       	pop	r0
     5ac:	0f be       	out	0x3f, r0	; 63
     5ae:	0f 90       	pop	r0
     5b0:	1f 90       	pop	r1
     5b2:	18 95       	reti

000005b4 <FUNCSleepMode>:
}

ISR(BADISR_vect, ISR_NAKED)                      // Bad ISR routine; should never be called, here for safety
{
	MAIN_CrashProgram(PSTR("BADISR"));
}

// ======================================================================================

void FUNCChangeSettings(void)
{
	uint8_t CurrSFunc = 0;
	
	JoyStatus = JOY_INVALID;

	for (;;)
	{
		if (JoyStatus)                           // Joystick is in the non-center position
		{
			if (JoyStatus & JOY_UP)              // Previous function
			  (CurrSFunc == 0)? CurrSFunc = ARRAY_UPPERBOUND(SettingFunctionPtrs) : CurrSFunc--;
			else if (JoyStatus & JOY_DOWN)       // Next function
			  (CurrSFunc == ARRAY_UPPERBOUND(SettingFunctionPtrs))? CurrSFunc = 0 : CurrSFunc++;
			else if (JoyStatus & JOY_PRESS)      // Select current function
			  ((FuncPtr)pgm_read_word(&SettingFunctionPtrs[CurrSFunc]))(); // Run associated function
			else if (JoyStatus & JOY_LEFT)
			  return;
		
			// Show current function onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&SettingFunctionNames[CurrSFunc]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCShowAbout(void)
{
	uint8_t InfoNum = 0;
	
	JoyStatus = JOY_INVALID;                     // Use an invalid joystick value to force the program to write the
	                                             // name of the default command onto the LCD			
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			  (InfoNum == 0)? InfoNum = ARRAY_UPPERBOUND(AboutTextPtrs) : InfoNum--;
			else if (JoyStatus & JOY_DOWN)
			  (InfoNum == ARRAY_UPPERBOUND(AboutTextPtrs))? InfoNum = 0 : InfoNum++;
			else if (JoyStatus & JOY_LEFT)
			  return;

			LCD_puts_f((uint8_t*)pgm_read_word(&AboutTextPtrs[InfoNum]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCAVRISPMode(void)
{
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(AVRISPModeMessage);
	
	V2P_RunStateMachine(AICI_InterpretPacket);
}

void FUNCProgramDataflash(void)
{
	USI_SPIInitMaster();
	DataflashInfo.UseExernalDF = TRUE;
	DFSPIRoutinePointer = USI_SPITransmit;
	
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(DataFlashProgMode);

	V2P_RunStateMachine(PD_InterpretAVRISPPacket);
	   
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
}

void FUNCProgramAVR(void)
{
	uint8_t  DoneFailMessageBuff[19];
	uint8_t  Fault    = ISPCC_NO_FAULT;
	uint8_t  ProgMode = 0;

	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
	SPI_SPIInit();
	DataflashInfo.UseExernalDF = FALSE;
	
	if (!(DF_CheckCorrectOnboardChip()))
	  return;

	MAIN_WaitForJoyRelease();
	
	JoyStatus = JOY_INVALID;                     // Use an invalid joystick value to force the program to write the
	                                             // name of the default command onto the LCD
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_LEFT)
			  return;
			else if (JoyStatus & JOY_PRESS)
			  break;
			else if (JoyStatus & JOY_UP)
			  (ProgMode == 0)? ProgMode = ARRAY_UPPERBOUND(ProgOptions) : ProgMode--;
			else if (JoyStatus & JOY_DOWN)
			  (ProgMode == ARRAY_UPPERBOUND(ProgOptions))? ProgMode = 0 : ProgMode++;

			LCD_puts_f((uint8_t*)pgm_read_word(&ProgOptions[ProgMode])); // Show current function onto the LCD

			MAIN_WaitForJoyRelease();
		}
	}

	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_BASECLOCKSPEED_8MHZ);
	LCD_puts_f(WaitText);

	TIMEOUT_SLEEP_TIMER_OFF();

	USI_SPIInitMaster();
	MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);       // Capture the RESET line of the slave AVR
			
	for (uint8_t PacketB = 0; PacketB < 12; PacketB++) // Read the enter programming mode command bytes
	  PacketBytes[PacketB] = eeprom_read_byte(&EEPROMVars.EnterProgMode[PacketB]);
	
	ISPCC_EnterChipProgrammingMode();            // Try to sync with the slave AVR

	CurrAddress = 0;

	if (PacketBytes[1] == AICB_STATUS_CMD_OK)    // ISPCC_EnterChipProgrammingMode alters the PacketBytes buffer rather than returning a value
	{						
		if (!(ProgMode) || (ProgMode == 7) || (ProgMode == 1) || (ProgMode == 3)) // All, erase chip, flash and eeprom, or program flash mode
		{
			MAIN_ShowProgType('C');
			
			if (!(eeprom_read_byte(&EEPROMVars.EraseCmdStored) == TRUE))
			{
				Fault = ISPCC_FAULT_NOERASE;
				MAIN_ShowError(PSTR("NO ERASE CMD"));
			}
			else
			{
				PM_SendEraseCommand();
			}
		}

		if ((!(ProgMode) || (ProgMode == 1) || (ProgMode == 3)) && (Fault == ISPCC_NO_FAULT)) // All, flash and EEPROM, or program flash mode
		{
			MAIN_ShowProgType('D');

			if (!(PM_GetStoredDataSize(TYPE_FLASH))) // Check to make sure a program is present in memory
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
				MAIN_ShowError(PSTR("NO DATA"));
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_FLASH);
			}
		}
	
		if (!(ProgMode) || (ProgMode == 2) || (ProgMode == 3)) // All, flash and EEPROM, or program EEPROM mode
		{
			MAIN_ShowProgType('E');
				
			if (!(PM_GetStoredDataSize(TYPE_EEPROM))) // Check to make sure EEPROM data is present in memory
			{
				Fault = ISPCC_FAULT_NODATATYPE;
				MAIN_ShowError(PSTR("NO EEPROM"));
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_EEPROM);
			}
		}

		if (!(ProgMode) || (ProgMode == 4) || (ProgMode == 6)) // All, fuse and lock bytes, or program fuse bytes mode
		{
			MAIN_ShowProgType('F');
			
			if (!(eeprom_read_byte(&EEPROMVars.TotalFuseBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
				MAIN_ShowError(PSTR("NO FUSE BYTES"));
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_FUSE);
			}
		}

		if (!(ProgMode) || (ProgMode == 5) || (ProgMode == 6)) // All, fuse and lock bytes, or program lock bytes mode
		{
			if (ProgMode == 6)                           // If fusebytes have already been written, we need to reenter programming mode to latch them
			{
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line of the slave AVR
				MAIN_Delay10MS(1);
				MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);   // Capture the RESET line of the slave AVR
				ISPCC_EnterChipProgrammingMode();        // Try to sync with the slave AVR
			}

			MAIN_ShowProgType('L');
		
			if (!(eeprom_read_byte(&EEPROMVars.TotalLockBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;
				MAIN_ShowError(PSTR("NO LOCK BYTES"));
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_LOCK);
			}
		}

		strcpy_P(DoneFailMessageBuff, PSTR("PROGRAMMING DONE"));

		if (Fault != ISPCC_NO_FAULT)             // Takes less code to just overwrite part of the string on fail
		  strcpy_P(&DoneFailMessageBuff[12], PSTR("FAILED"));

		LCD_puts(DoneFailMessageBuff);

		MAIN_Delay10MS(250);
		MAIN_Delay10MS(200);
	}
	else
	{
		MAIN_ShowError(SyncErrorMessage);
	}
	
	TOUT_SetupSleepTimer();
	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_BASECLOCKSPEED_1MHZ);
	MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);     // Release the RESET line and allow the slave AVR to run	
	USI_SPIOff();
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);       // Set status LEDs to green (ready)
}

void FUNCStoreProgram(void)
{
	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
	SPI_SPIInit();
	DataflashInfo.UseExernalDF = FALSE;
	DF_EnableDataflash(TRUE);

	if (!(DF_CheckCorrectOnboardChip()))
	  return;
			
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(PSTR("*STORAGE MODE*"));

	V2P_RunStateMachine(PM_InterpretAVRISPPacket);
	
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
}

void FUNCClearMem(void)
{
	LCD_puts_f(PSTR("CONFIRM"));
	MAIN_Delay10MS(180);

	LCD_puts_f(PSTR("<N Y>"));

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_LEFT)
			  return;
			else if (JoyStatus & JOY_RIGHT)
			  break;
		}
	}

	MAIN_WaitForJoyRelease();

	LCD_puts_f(WaitText);
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);      // Set status LEDs to orange (busy)

	for (uint16_t EAddr = 0; EAddr < sizeof(EEPROMVars); EAddr++)
	  eeprom_write_byte((uint8_t*)EAddr, 0xFF);

	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);       // Set status LEDs to green (ready)
	LCD_puts_f(PSTR("MEM CLEARED"));
	MAIN_Delay10MS(250);
}

void FUNCSetContrast(void)
{
	uint8_t Buffer[6];
	uint8_t Contrast = (eeprom_read_byte(&EEPROMVars.LCDContrast) & 0x0F); // Ranges from 0-15 so mask retuns 15 on blank EEPROM (0xFF)
	
	JoyStatus = JOY_INVALID;                     // Use an invalid joystick value to force the program to write the
	                                             // name of the default command onto the LCD
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				if (Contrast < 15)
				  Contrast++;
			}
			else if (JoyStatus & JOY_DOWN)
			{
				if (Contrast > 1)                // Zero is non-visible, so 1 is the minimum
				  Contrast--;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.LCDContrast, Contrast);
				return;
			}
					
			Buffer[0] = 'C';
			Buffer[1] = 'T';
			Buffer[2] = ' ';

			MAIN_IntToStr((uint16_t)Contrast, &Buffer[3]);
			LCD_puts(Buffer);

			LCD_CONTRAST_LEVEL(Contrast);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCSetISPSpeed(void)
{
	uint8_t CurrSpeed = eeprom_read_byte(&EEPROMVars.SCKDuration);

	if (CurrSpeed > ARRAY_UPPERBOUND(USISpeeds))
	  CurrSpeed = ARRAY_UPPERBOUND(USISpeeds);   // Protection against blank EEPROM

	JoyStatus = JOY_INVALID;                     // Use an invalid joystick value to force the program to write the
	                                             // name of the default command onto the LCD
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				(CurrSpeed == 0)? CurrSpeed = ARRAY_UPPERBOUND(USISpeeds) : CurrSpeed--;
			}
			else if (JoyStatus & JOY_DOWN)
			{
				(CurrSpeed == ARRAY_UPPERBOUND(USISpeeds))? CurrSpeed = 0 : CurrSpeed++;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.SCKDuration, CurrSpeed);
				return;
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f(USISpeeds[CurrSpeed]);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCSetResetMode(void)
{
	uint8_t CurrMode = (eeprom_read_byte(&EEPROMVars.SPIResetMode) & 0x01);

	JoyStatus = JOY_INVALID;                     // Use an invalid joystick value to force the program to write the
	                                             // name of the default command onto the LCD
	for (;;)
	{
		if (JoyStatus)
		{
			if ((JoyStatus & JOY_UP) || (JoyStatus & JOY_DOWN))
			{
				CurrMode ^= 1;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.SPIResetMode, CurrMode);
				return;
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f(SPIResetModes[CurrMode]);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCSetFirmMinorVer(void)
{
	uint8_t VerBuffer[5];
	uint8_t VerMinor = eeprom_read_byte(&EEPROMVars.FirmVerMinor);

	if (VerMinor > 9)
	  VerMinor = V2P_SW_VERSION_MINOR_DEFAULT;
	
	strcpy_P(VerBuffer, PSTR("V2- "));

	JoyStatus = JOY_INVALID;                     // Use an invalid joystick value to force the program to write the
	                                             // name of the default command onto the LCD
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				if (VerMinor < 9)
				  VerMinor++;
			}
			if (JoyStatus & JOY_DOWN)
			{
				if (VerMinor)
				  VerMinor--;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.FirmVerMinor, VerMinor);
				return;
			}
			
			VerBuffer[3] = ('0' + VerMinor);
			LCD_puts(VerBuffer);

			MAIN_WaitForJoyRelease();
		}
	}	
}

void FUNCSetAutoSleepTimeOut(void)
{
	uint8_t SleepTxtBuffer[8];
	uint8_t SleepVal = eeprom_read_byte(&EEPROMVars.AutoSleepValIndex);

	if (SleepVal > ARRAY_UPPERBOUND(AutoSleepTOValues))
	  SleepVal = ARRAY_UPPERBOUND(AutoSleepTOValues);

	strcpy_P(SleepTxtBuffer, PSTR("    SEC"));
	
	JoyStatus = JOY_INVALID;                     // Use an invalid joystick value to force the program to write the
	                                             // name of the default command onto the LCD
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				(SleepVal == 0)? SleepVal = ARRAY_UPPERBOUND(AutoSleepTOValues) : SleepVal--;
			}
			if (JoyStatus & JOY_DOWN)
			{
				(SleepVal == ARRAY_UPPERBOUND(AutoSleepTOValues))? SleepVal = 0 : SleepVal++;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.AutoSleepValIndex, SleepVal);
				TOUT_SetupSleepTimer();
				return;
			}

			if (!(SleepVal))
			{
				LCD_puts_f(PSTR("OFF"));
			}
			else
			{
				MAIN_IntToStr(pgm_read_byte(&AutoSleepTOValues[SleepVal]), &SleepTxtBuffer[0]);
				SleepTxtBuffer[3] = ' ';         // Remove the auto-string termination from the buffer
				LCD_puts(SleepTxtBuffer);
			}

			MAIN_WaitForJoyRelease();
		}
	}	
}

void FUNCSleepMode(void)
{
     5b4:	85 e0       	ldi	r24, 0x05	; 5
     5b6:	83 bf       	out	0x33, r24	; 51
	SMCR    = ((1 << SM1) | (1 << SE));          // Power down sleep mode
	LCDCRA &= ~(1 << LCDEN); 
     5b8:	80 91 e4 00 	lds	r24, 0x00E4
     5bc:	8f 77       	andi	r24, 0x7F	; 127
     5be:	80 93 e4 00 	sts	0x00E4, r24
	
	MAIN_SETSTATUSLED(MAIN_STATLED_OFF);         // Save battery power - turn off status LED
     5c2:	81 b3       	in	r24, 0x11	; 17
     5c4:	8f 7c       	andi	r24, 0xCF	; 207
     5c6:	81 bb       	out	0x11, r24	; 17
     5c8:	01 c0       	rjmp	.+2      	; 0x5cc <FUNCSleepMode+0x18>

	while (!(JoyStatus & JOY_UP))                // Joystick interrupt wakes the micro
	  SLEEP();
     5ca:	88 95       	sleep
     5cc:	f6 9b       	sbis	0x1e, 6	; 30
     5ce:	fd cf       	rjmp	.-6      	; 0x5ca <FUNCSleepMode+0x16>
	   
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);       // Turn status LED back on
     5d0:	81 b3       	in	r24, 0x11	; 17
     5d2:	8f 7c       	andi	r24, 0xCF	; 207
     5d4:	80 61       	ori	r24, 0x10	; 16
     5d6:	81 bb       	out	0x11, r24	; 17

	LCDCRA |= (1 << LCDEN);
     5d8:	80 91 e4 00 	lds	r24, 0x00E4
     5dc:	80 68       	ori	r24, 0x80	; 128
     5de:	80 93 e4 00 	sts	0x00E4, r24
	
	MAIN_WaitForJoyRelease();
     5e2:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     5e6:	08 95       	ret

000005e8 <FUNCGoBootloader>:
}

void FUNCStorageInfo(void)
{
	uint8_t SelectedItem = 0;

	MAIN_WaitForJoyRelease();

	JoyStatus = JOY_INVALID;                     // Use an invalid joystick value to force the program to write the
	                                             // name of the default command onto the LCD
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & (JOY_UP | JOY_DOWN))
			{
				SelectedItem ^= 1;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				return;
			}
			else if (JoyStatus & JOY_PRESS)
			{
				if (SelectedItem == 1)           // View storage tags
				{
					DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
					SPI_SPIInit();
					DataflashInfo.UseExernalDF = FALSE;
					DF_EnableDataflash(TRUE);

					if (!(PM_GetStoredDataSize(TYPE_FLASH)))
					  MAIN_ShowError(PSTR("NO STORED PRGM"));
					else if (DF_CheckCorrectOnboardChip())
					  TM_ShowTags();

					DF_EnableDataflash(FALSE);
					SPI_SPIOFF();
				}
				else                             // View stored data sizes
				{
					PM_ShowStoredItemSizes();
				}
			}
			
			LCD_puts_f(SIFONames[SelectedItem]);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCGoBootloader(void)
{
     5e8:	85 b7       	in	r24, 0x35	; 53
     5ea:	8f 77       	andi	r24, 0x7F	; 127
	uint8_t MD = (MCUCR & ~(1 << JTD));         // Forces compiler to use IN, AND plus two OUTs rather than two lots of IN/AND/OUTs
	MCUCR = MD;                                 // Turn on JTAG via code
     5ec:	85 bf       	out	0x35, r24	; 53
	MCUCR = MD;                                 // Set bit twice as specified in datasheet        
     5ee:	85 bf       	out	0x35, r24	; 53

	TIMEOUT_SLEEP_TIMER_OFF();
     5f0:	10 92 81 00 	sts	0x0081, r1
	
	LCD_puts_f(PSTR("*JTAG ON*"));
     5f4:	88 e7       	ldi	r24, 0x78	; 120
     5f6:	92 e0       	ldi	r25, 0x02	; 2
     5f8:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
	
	MAIN_WaitForJoyRelease();
     5fc:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
	
	WDTCR = ((1<<WDCE) | (1<<WDE));             // Enable Watchdog Timer to give reset after minimum timeout
     600:	88 e1       	ldi	r24, 0x18	; 24
     602:	80 93 60 00 	sts	0x0060, r24
     606:	ff cf       	rjmp	.-2      	; 0x606 <FUNCGoBootloader+0x1e>

00000608 <FUNCShowAbout>:
     608:	1f 93       	push	r17
     60a:	81 e0       	ldi	r24, 0x01	; 1
     60c:	8e bb       	out	0x1e, r24	; 30
     60e:	10 e0       	ldi	r17, 0x00	; 0
     610:	8e b3       	in	r24, 0x1e	; 30
     612:	88 23       	and	r24, r24
     614:	e9 f3       	breq	.-6      	; 0x610 <FUNCShowAbout+0x8>
     616:	f6 9b       	sbis	0x1e, 6	; 30
     618:	06 c0       	rjmp	.+12     	; 0x626 <FUNCShowAbout+0x1e>
     61a:	11 23       	and	r17, r17
     61c:	11 f4       	brne	.+4      	; 0x622 <FUNCShowAbout+0x1a>
     61e:	13 e0       	ldi	r17, 0x03	; 3
     620:	0c c0       	rjmp	.+24     	; 0x63a <FUNCShowAbout+0x32>
     622:	11 50       	subi	r17, 0x01	; 1
     624:	0a c0       	rjmp	.+20     	; 0x63a <FUNCShowAbout+0x32>
     626:	f7 9b       	sbis	0x1e, 7	; 30
     628:	06 c0       	rjmp	.+12     	; 0x636 <FUNCShowAbout+0x2e>
     62a:	13 30       	cpi	r17, 0x03	; 3
     62c:	11 f4       	brne	.+4      	; 0x632 <FUNCShowAbout+0x2a>
     62e:	10 e0       	ldi	r17, 0x00	; 0
     630:	04 c0       	rjmp	.+8      	; 0x63a <FUNCShowAbout+0x32>
     632:	1f 5f       	subi	r17, 0xFF	; 255
     634:	02 c0       	rjmp	.+4      	; 0x63a <FUNCShowAbout+0x32>
     636:	f2 99       	sbic	0x1e, 2	; 30
     638:	0d c0       	rjmp	.+26     	; 0x654 <FUNCShowAbout+0x4c>
     63a:	e1 2f       	mov	r30, r17
     63c:	ff 27       	eor	r31, r31
     63e:	ee 0f       	add	r30, r30
     640:	ff 1f       	adc	r31, r31
     642:	e1 56       	subi	r30, 0x61	; 97
     644:	ff 4f       	sbci	r31, 0xFF	; 255
     646:	85 91       	lpm	r24, Z+
     648:	94 91       	lpm	r25, Z
     64a:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     64e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     652:	de cf       	rjmp	.-68     	; 0x610 <FUNCShowAbout+0x8>
     654:	1f 91       	pop	r17
     656:	08 95       	ret

00000658 <FUNCChangeSettings>:
     658:	1f 93       	push	r17
     65a:	81 e0       	ldi	r24, 0x01	; 1
     65c:	8e bb       	out	0x1e, r24	; 30
     65e:	10 e0       	ldi	r17, 0x00	; 0
     660:	8e b3       	in	r24, 0x1e	; 30
     662:	88 23       	and	r24, r24
     664:	e9 f3       	breq	.-6      	; 0x660 <FUNCChangeSettings+0x8>
     666:	f6 9b       	sbis	0x1e, 6	; 30
     668:	06 c0       	rjmp	.+12     	; 0x676 <FUNCChangeSettings+0x1e>
     66a:	11 23       	and	r17, r17
     66c:	11 f4       	brne	.+4      	; 0x672 <FUNCChangeSettings+0x1a>
     66e:	16 e0       	ldi	r17, 0x06	; 6
     670:	19 c0       	rjmp	.+50     	; 0x6a4 <FUNCChangeSettings+0x4c>
     672:	11 50       	subi	r17, 0x01	; 1
     674:	17 c0       	rjmp	.+46     	; 0x6a4 <FUNCChangeSettings+0x4c>
     676:	f7 9b       	sbis	0x1e, 7	; 30
     678:	06 c0       	rjmp	.+12     	; 0x686 <FUNCChangeSettings+0x2e>
     67a:	16 30       	cpi	r17, 0x06	; 6
     67c:	11 f4       	brne	.+4      	; 0x682 <FUNCChangeSettings+0x2a>
     67e:	10 e0       	ldi	r17, 0x00	; 0
     680:	11 c0       	rjmp	.+34     	; 0x6a4 <FUNCChangeSettings+0x4c>
     682:	1f 5f       	subi	r17, 0xFF	; 255
     684:	0f c0       	rjmp	.+30     	; 0x6a4 <FUNCChangeSettings+0x4c>
     686:	f4 9b       	sbis	0x1e, 4	; 30
     688:	0b c0       	rjmp	.+22     	; 0x6a0 <FUNCChangeSettings+0x48>
     68a:	e1 2f       	mov	r30, r17
     68c:	ff 27       	eor	r31, r31
     68e:	ee 0f       	add	r30, r30
     690:	ff 1f       	adc	r31, r31
     692:	e6 56       	subi	r30, 0x66	; 102
     694:	fe 4f       	sbci	r31, 0xFE	; 254
     696:	85 91       	lpm	r24, Z+
     698:	94 91       	lpm	r25, Z
     69a:	fc 01       	movw	r30, r24
     69c:	09 95       	icall
     69e:	02 c0       	rjmp	.+4      	; 0x6a4 <FUNCChangeSettings+0x4c>
     6a0:	f2 99       	sbic	0x1e, 2	; 30
     6a2:	0d c0       	rjmp	.+26     	; 0x6be <FUNCChangeSettings+0x66>
     6a4:	e1 2f       	mov	r30, r17
     6a6:	ff 27       	eor	r31, r31
     6a8:	ee 0f       	add	r30, r30
     6aa:	ff 1f       	adc	r31, r31
     6ac:	e4 57       	subi	r30, 0x74	; 116
     6ae:	fe 4f       	sbci	r31, 0xFE	; 254
     6b0:	85 91       	lpm	r24, Z+
     6b2:	94 91       	lpm	r25, Z
     6b4:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     6b8:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     6bc:	d1 cf       	rjmp	.-94     	; 0x660 <FUNCChangeSettings+0x8>
     6be:	1f 91       	pop	r17
     6c0:	08 95       	ret

000006c2 <FUNCSetAutoSleepTimeOut>:
     6c2:	ef 92       	push	r14
     6c4:	ff 92       	push	r15
     6c6:	0f 93       	push	r16
     6c8:	cf 93       	push	r28
     6ca:	df 93       	push	r29
     6cc:	cd b7       	in	r28, 0x3d	; 61
     6ce:	de b7       	in	r29, 0x3e	; 62
     6d0:	28 97       	sbiw	r28, 0x08	; 8
     6d2:	0f b6       	in	r0, 0x3f	; 63
     6d4:	f8 94       	cli
     6d6:	de bf       	out	0x3e, r29	; 62
     6d8:	0f be       	out	0x3f, r0	; 63
     6da:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     6dc:	ab e8       	ldi	r26, 0x8B	; 139
     6de:	b0 e0       	ldi	r27, 0x00	; 0
     6e0:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
     6e4:	80 2d       	mov	r24, r0
     6e6:	08 2f       	mov	r16, r24
     6e8:	85 30       	cpi	r24, 0x05	; 5
     6ea:	08 f0       	brcs	.+2      	; 0x6ee <FUNCSetAutoSleepTimeOut+0x2c>
     6ec:	04 e0       	ldi	r16, 0x04	; 4
     6ee:	65 e9       	ldi	r22, 0x95	; 149
     6f0:	72 e0       	ldi	r23, 0x02	; 2
     6f2:	ce 01       	movw	r24, r28
     6f4:	01 96       	adiw	r24, 0x01	; 1
     6f6:	0e 94 39 1a 	call	0x3472	; 0x3472 <strcpy_P>
     6fa:	81 e0       	ldi	r24, 0x01	; 1
     6fc:	8e bb       	out	0x1e, r24	; 30
     6fe:	8e b3       	in	r24, 0x1e	; 30
     700:	88 23       	and	r24, r24
     702:	e9 f3       	breq	.-6      	; 0x6fe <FUNCSetAutoSleepTimeOut+0x3c>
     704:	f6 9b       	sbis	0x1e, 6	; 30
     706:	05 c0       	rjmp	.+10     	; 0x712 <FUNCSetAutoSleepTimeOut+0x50>
     708:	00 23       	and	r16, r16
     70a:	11 f4       	brne	.+4      	; 0x710 <FUNCSetAutoSleepTimeOut+0x4e>
     70c:	04 e0       	ldi	r16, 0x04	; 4
     70e:	01 c0       	rjmp	.+2      	; 0x712 <FUNCSetAutoSleepTimeOut+0x50>
     710:	01 50       	subi	r16, 0x01	; 1
     712:	f7 9b       	sbis	0x1e, 7	; 30
     714:	06 c0       	rjmp	.+12     	; 0x722 <FUNCSetAutoSleepTimeOut+0x60>
     716:	04 30       	cpi	r16, 0x04	; 4
     718:	11 f4       	brne	.+4      	; 0x71e <FUNCSetAutoSleepTimeOut+0x5c>
     71a:	00 e0       	ldi	r16, 0x00	; 0
     71c:	06 c0       	rjmp	.+12     	; 0x72a <FUNCSetAutoSleepTimeOut+0x68>
     71e:	0f 5f       	subi	r16, 0xFF	; 255
     720:	02 c0       	rjmp	.+4      	; 0x726 <FUNCSetAutoSleepTimeOut+0x64>
     722:	f2 99       	sbic	0x1e, 2	; 30
     724:	1d c0       	rjmp	.+58     	; 0x760 <FUNCSetAutoSleepTimeOut+0x9e>
     726:	00 23       	and	r16, r16
     728:	29 f4       	brne	.+10     	; 0x734 <FUNCSetAutoSleepTimeOut+0x72>
     72a:	81 e9       	ldi	r24, 0x91	; 145
     72c:	92 e0       	ldi	r25, 0x02	; 2
     72e:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     732:	13 c0       	rjmp	.+38     	; 0x75a <FUNCSetAutoSleepTimeOut+0x98>
     734:	e0 2f       	mov	r30, r16
     736:	ff 27       	eor	r31, r31
     738:	ef 51       	subi	r30, 0x1F	; 31
     73a:	fc 4f       	sbci	r31, 0xFC	; 252
     73c:	e4 91       	lpm	r30, Z
     73e:	7e 01       	movw	r14, r28
     740:	08 94       	sec
     742:	e1 1c       	adc	r14, r1
     744:	f1 1c       	adc	r15, r1
     746:	b7 01       	movw	r22, r14
     748:	8e 2f       	mov	r24, r30
     74a:	99 27       	eor	r25, r25
     74c:	0e 94 9c 02 	call	0x538	; 0x538 <MAIN_IntToStr>
     750:	80 e2       	ldi	r24, 0x20	; 32
     752:	8c 83       	std	Y+4, r24	; 0x04
     754:	c7 01       	movw	r24, r14
     756:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <LCD_puts>
     75a:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     75e:	cf cf       	rjmp	.-98     	; 0x6fe <FUNCSetAutoSleepTimeOut+0x3c>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     760:	ab e8       	ldi	r26, 0x8B	; 139
     762:	b0 e0       	ldi	r27, 0x00	; 0
     764:	00 2e       	mov	r0, r16
     766:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
     76a:	0e 94 3f 0c 	call	0x187e	; 0x187e <TOUT_SetupSleepTimer>
     76e:	28 96       	adiw	r28, 0x08	; 8
     770:	0f b6       	in	r0, 0x3f	; 63
     772:	f8 94       	cli
     774:	de bf       	out	0x3e, r29	; 62
     776:	0f be       	out	0x3f, r0	; 63
     778:	cd bf       	out	0x3d, r28	; 61
     77a:	df 91       	pop	r29
     77c:	cf 91       	pop	r28
     77e:	0f 91       	pop	r16
     780:	ff 90       	pop	r15
     782:	ef 90       	pop	r14
     784:	08 95       	ret

00000786 <MAIN_ShowError>:
     786:	cf 93       	push	r28
     788:	df 93       	push	r29
     78a:	cd b7       	in	r28, 0x3d	; 61
     78c:	de b7       	in	r29, 0x3e	; 62
     78e:	64 97       	sbiw	r28, 0x14	; 20
     790:	0f b6       	in	r0, 0x3f	; 63
     792:	f8 94       	cli
     794:	de bf       	out	0x3e, r29	; 62
     796:	0f be       	out	0x3f, r0	; 63
     798:	cd bf       	out	0x3d, r28	; 61
     79a:	25 e4       	ldi	r18, 0x45	; 69
     79c:	29 83       	std	Y+1, r18	; 0x01
     79e:	2e e3       	ldi	r18, 0x3E	; 62
     7a0:	2a 83       	std	Y+2, r18	; 0x02
     7a2:	bc 01       	movw	r22, r24
     7a4:	ce 01       	movw	r24, r28
     7a6:	03 96       	adiw	r24, 0x03	; 3
     7a8:	0e 94 39 1a 	call	0x3472	; 0x3472 <strcpy_P>
     7ac:	ce 01       	movw	r24, r28
     7ae:	01 96       	adiw	r24, 0x01	; 1
     7b0:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <LCD_puts>
     7b4:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     7b8:	f4 9b       	sbis	0x1e, 4	; 30
     7ba:	fe cf       	rjmp	.-4      	; 0x7b8 <MAIN_ShowError+0x32>
     7bc:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     7c0:	64 96       	adiw	r28, 0x14	; 20
     7c2:	0f b6       	in	r0, 0x3f	; 63
     7c4:	f8 94       	cli
     7c6:	de bf       	out	0x3e, r29	; 62
     7c8:	0f be       	out	0x3f, r0	; 63
     7ca:	cd bf       	out	0x3d, r28	; 61
     7cc:	df 91       	pop	r29
     7ce:	cf 91       	pop	r28
     7d0:	08 95       	ret

000007d2 <FUNCStorageInfo>:
     7d2:	1f 93       	push	r17
     7d4:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     7d8:	81 e0       	ldi	r24, 0x01	; 1
     7da:	8e bb       	out	0x1e, r24	; 30
     7dc:	10 e0       	ldi	r17, 0x00	; 0
     7de:	8e b3       	in	r24, 0x1e	; 30
     7e0:	88 23       	and	r24, r24
     7e2:	e9 f3       	breq	.-6      	; 0x7de <FUNCStorageInfo+0xc>
     7e4:	8e b3       	in	r24, 0x1e	; 30
     7e6:	80 7c       	andi	r24, 0xC0	; 192
     7e8:	19 f0       	breq	.+6      	; 0x7f0 <FUNCStorageInfo+0x1e>
     7ea:	81 e0       	ldi	r24, 0x01	; 1
     7ec:	18 27       	eor	r17, r24
     7ee:	31 c0       	rjmp	.+98     	; 0x852 <FUNCStorageInfo+0x80>
     7f0:	f2 99       	sbic	0x1e, 2	; 30
     7f2:	3a c0       	rjmp	.+116    	; 0x868 <FUNCStorageInfo+0x96>
     7f4:	f4 9b       	sbis	0x1e, 4	; 30
     7f6:	2d c0       	rjmp	.+90     	; 0x852 <FUNCStorageInfo+0x80>
     7f8:	11 30       	cpi	r17, 0x01	; 1
     7fa:	49 f5       	brne	.+82     	; 0x84e <FUNCStorageInfo+0x7c>
     7fc:	8f ea       	ldi	r24, 0xAF	; 175
     7fe:	99 e0       	ldi	r25, 0x09	; 9
     800:	90 93 01 01 	sts	0x0101, r25
     804:	80 93 00 01 	sts	0x0100, r24
     808:	0e 94 a7 09 	call	0x134e	; 0x134e <SPI_SPIInit>
     80c:	10 92 47 01 	sts	0x0147, r1
     810:	81 e0       	ldi	r24, 0x01	; 1
     812:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
     816:	81 e0       	ldi	r24, 0x01	; 1
     818:	0e 94 e4 14 	call	0x29c8	; 0x29c8 <PM_GetStoredDataSize>
     81c:	61 15       	cp	r22, r1
     81e:	71 05       	cpc	r23, r1
     820:	81 05       	cpc	r24, r1
     822:	91 05       	cpc	r25, r1
     824:	29 f4       	brne	.+10     	; 0x830 <FUNCStorageInfo+0x5e>
     826:	82 e8       	ldi	r24, 0x82	; 130
     828:	92 e0       	ldi	r25, 0x02	; 2
     82a:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     82e:	06 c0       	rjmp	.+12     	; 0x83c <FUNCStorageInfo+0x6a>
     830:	0e 94 c0 0b 	call	0x1780	; 0x1780 <DF_CheckCorrectOnboardChip>
     834:	88 23       	and	r24, r24
     836:	11 f0       	breq	.+4      	; 0x83c <FUNCStorageInfo+0x6a>
     838:	0e 94 0a 1a 	call	0x3414	; 0x3414 <TM_ShowTags>
     83c:	80 e0       	ldi	r24, 0x00	; 0
     83e:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
     842:	80 91 64 00 	lds	r24, 0x0064
     846:	84 60       	ori	r24, 0x04	; 4
     848:	80 93 64 00 	sts	0x0064, r24
     84c:	02 c0       	rjmp	.+4      	; 0x852 <FUNCStorageInfo+0x80>
     84e:	0e 94 cd 16 	call	0x2d9a	; 0x2d9a <PM_ShowStoredItemSizes>
     852:	8f e0       	ldi	r24, 0x0F	; 15
     854:	18 9f       	mul	r17, r24
     856:	c0 01       	movw	r24, r0
     858:	11 24       	eor	r1, r1
     85a:	86 5a       	subi	r24, 0xA6	; 166
     85c:	9d 4f       	sbci	r25, 0xFD	; 253
     85e:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     862:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     866:	bb cf       	rjmp	.-138    	; 0x7de <FUNCStorageInfo+0xc>
     868:	1f 91       	pop	r17
     86a:	08 95       	ret

0000086c <MAIN_ShowProgType>:
     86c:	ff 92       	push	r15
     86e:	0f 93       	push	r16
     870:	1f 93       	push	r17
     872:	cf 93       	push	r28
     874:	df 93       	push	r29
     876:	cd b7       	in	r28, 0x3d	; 61
     878:	de b7       	in	r29, 0x3e	; 62
     87a:	27 97       	sbiw	r28, 0x07	; 7
     87c:	0f b6       	in	r0, 0x3f	; 63
     87e:	f8 94       	cli
     880:	de bf       	out	0x3e, r29	; 62
     882:	0f be       	out	0x3f, r0	; 63
     884:	cd bf       	out	0x3d, r28	; 61
     886:	f8 2e       	mov	r15, r24
     888:	8e 01       	movw	r16, r28
     88a:	0f 5f       	subi	r16, 0xFF	; 255
     88c:	1f 4f       	sbci	r17, 0xFF	; 255
     88e:	65 e2       	ldi	r22, 0x25	; 37
     890:	73 e0       	ldi	r23, 0x03	; 3
     892:	c8 01       	movw	r24, r16
     894:	0e 94 39 1a 	call	0x3472	; 0x3472 <strcpy_P>
     898:	fe 82       	std	Y+6, r15	; 0x06
     89a:	c8 01       	movw	r24, r16
     89c:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <LCD_puts>
     8a0:	27 96       	adiw	r28, 0x07	; 7
     8a2:	0f b6       	in	r0, 0x3f	; 63
     8a4:	f8 94       	cli
     8a6:	de bf       	out	0x3e, r29	; 62
     8a8:	0f be       	out	0x3f, r0	; 63
     8aa:	cd bf       	out	0x3d, r28	; 61
     8ac:	df 91       	pop	r29
     8ae:	cf 91       	pop	r28
     8b0:	1f 91       	pop	r17
     8b2:	0f 91       	pop	r16
     8b4:	ff 90       	pop	r15
     8b6:	08 95       	ret

000008b8 <FUNCStoreProgram>:
     8b8:	8f ea       	ldi	r24, 0xAF	; 175
     8ba:	99 e0       	ldi	r25, 0x09	; 9
     8bc:	90 93 01 01 	sts	0x0101, r25
     8c0:	80 93 00 01 	sts	0x0100, r24
     8c4:	0e 94 a7 09 	call	0x134e	; 0x134e <SPI_SPIInit>
     8c8:	10 92 47 01 	sts	0x0147, r1
     8cc:	81 e0       	ldi	r24, 0x01	; 1
     8ce:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
     8d2:	0e 94 c0 0b 	call	0x1780	; 0x1780 <DF_CheckCorrectOnboardChip>
     8d6:	88 23       	and	r24, r24
     8d8:	e1 f0       	breq	.+56     	; 0x912 <FUNCStoreProgram+0x5a>
     8da:	87 ea       	ldi	r24, 0xA7	; 167
     8dc:	90 e0       	ldi	r25, 0x00	; 0
     8de:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     8e2:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <OSCCAL_Calibrate>
     8e6:	80 91 c1 00 	lds	r24, 0x00C1
     8ea:	80 78       	andi	r24, 0x80	; 128
     8ec:	88 61       	ori	r24, 0x18	; 24
     8ee:	80 93 c1 00 	sts	0x00C1, r24
     8f2:	8c eb       	ldi	r24, 0xBC	; 188
     8f4:	92 e0       	ldi	r25, 0x02	; 2
     8f6:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     8fa:	81 e4       	ldi	r24, 0x41	; 65
     8fc:	97 e1       	ldi	r25, 0x17	; 23
     8fe:	0e 94 e3 0f 	call	0x1fc6	; 0x1fc6 <V2P_RunStateMachine>
     902:	80 e0       	ldi	r24, 0x00	; 0
     904:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
     908:	80 91 64 00 	lds	r24, 0x0064
     90c:	84 60       	ori	r24, 0x04	; 4
     90e:	80 93 64 00 	sts	0x0064, r24
     912:	08 95       	ret

00000914 <FUNCAVRISPMode>:
     914:	87 ea       	ldi	r24, 0xA7	; 167
     916:	90 e0       	ldi	r25, 0x00	; 0
     918:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     91c:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <OSCCAL_Calibrate>
     920:	e1 ec       	ldi	r30, 0xC1	; 193
     922:	f0 e0       	ldi	r31, 0x00	; 0
     924:	80 81       	ld	r24, Z
     926:	80 78       	andi	r24, 0x80	; 128
     928:	88 61       	ori	r24, 0x18	; 24
     92a:	80 83       	st	Z, r24
     92c:	86 e3       	ldi	r24, 0x36	; 54
     92e:	94 e0       	ldi	r25, 0x04	; 4
     930:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     934:	88 ee       	ldi	r24, 0xE8	; 232
     936:	92 e1       	ldi	r25, 0x12	; 18
     938:	0e 94 e3 0f 	call	0x1fc6	; 0x1fc6 <V2P_RunStateMachine>
     93c:	08 95       	ret

0000093e <FUNCProgramDataflash>:
     93e:	0e 94 2d 0a 	call	0x145a	; 0x145a <USI_SPIInitMaster>
     942:	81 e0       	ldi	r24, 0x01	; 1
     944:	80 93 47 01 	sts	0x0147, r24
     948:	8e ee       	ldi	r24, 0xEE	; 238
     94a:	99 e0       	ldi	r25, 0x09	; 9
     94c:	90 93 01 01 	sts	0x0101, r25
     950:	80 93 00 01 	sts	0x0100, r24
     954:	87 ea       	ldi	r24, 0xA7	; 167
     956:	90 e0       	ldi	r25, 0x00	; 0
     958:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     95c:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <OSCCAL_Calibrate>
     960:	e1 ec       	ldi	r30, 0xC1	; 193
     962:	f0 e0       	ldi	r31, 0x00	; 0
     964:	80 81       	ld	r24, Z
     966:	80 78       	andi	r24, 0x80	; 128
     968:	88 61       	ori	r24, 0x18	; 24
     96a:	80 83       	st	Z, r24
     96c:	89 ef       	ldi	r24, 0xF9	; 249
     96e:	93 e0       	ldi	r25, 0x03	; 3
     970:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     974:	81 e5       	ldi	r24, 0x51	; 81
     976:	9d e0       	ldi	r25, 0x0D	; 13
     978:	0e 94 e3 0f 	call	0x1fc6	; 0x1fc6 <V2P_RunStateMachine>
     97c:	80 e0       	ldi	r24, 0x00	; 0
     97e:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
     982:	e4 e6       	ldi	r30, 0x64	; 100
     984:	f0 e0       	ldi	r31, 0x00	; 0
     986:	80 81       	ld	r24, Z
     988:	84 60       	ori	r24, 0x04	; 4
     98a:	80 83       	st	Z, r24
     98c:	08 95       	ret

0000098e <MAIN_CrashProgram>:
     98e:	8c 01       	movw	r16, r24
     990:	80 91 64 00 	lds	r24, 0x0064
     994:	84 60       	ori	r24, 0x04	; 4
     996:	80 93 64 00 	sts	0x0064, r24
     99a:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <USI_SPIOff>
     99e:	10 92 b0 00 	sts	0x00B0, r1
     9a2:	10 92 70 00 	sts	0x0070, r1
     9a6:	10 92 81 00 	sts	0x0081, r1
     9aa:	80 e8       	ldi	r24, 0x80	; 128
     9ac:	80 93 61 00 	sts	0x0061, r24
     9b0:	83 e0       	ldi	r24, 0x03	; 3
     9b2:	80 93 61 00 	sts	0x0061, r24
     9b6:	10 92 c1 00 	sts	0x00C1, r1
     9ba:	c8 01       	movw	r24, r16
     9bc:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     9c0:	81 b3       	in	r24, 0x11	; 17
     9c2:	8f 7c       	andi	r24, 0xCF	; 207
     9c4:	80 63       	ori	r24, 0x30	; 48
     9c6:	81 bb       	out	0x11, r24	; 17
     9c8:	82 e3       	ldi	r24, 0x32	; 50
     9ca:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     9ce:	81 b3       	in	r24, 0x11	; 17
     9d0:	90 e1       	ldi	r25, 0x10	; 16
     9d2:	89 27       	eor	r24, r25
     9d4:	f8 cf       	rjmp	.-16     	; 0x9c6 <MAIN_CrashProgram+0x38>

000009d6 <__vector_default>:
     9d6:	8e e1       	ldi	r24, 0x1E	; 30
     9d8:	93 e0       	ldi	r25, 0x03	; 3
     9da:	0e 94 c7 04 	call	0x98e	; 0x98e <MAIN_CrashProgram>

000009de <FUNCProgramAVR>:
     9de:	0f 93       	push	r16
     9e0:	1f 93       	push	r17
     9e2:	cf 93       	push	r28
     9e4:	df 93       	push	r29
     9e6:	cd b7       	in	r28, 0x3d	; 61
     9e8:	de b7       	in	r29, 0x3e	; 62
     9ea:	63 97       	sbiw	r28, 0x13	; 19
     9ec:	0f b6       	in	r0, 0x3f	; 63
     9ee:	f8 94       	cli
     9f0:	de bf       	out	0x3e, r29	; 62
     9f2:	0f be       	out	0x3f, r0	; 63
     9f4:	cd bf       	out	0x3d, r28	; 61
     9f6:	8f ea       	ldi	r24, 0xAF	; 175
     9f8:	99 e0       	ldi	r25, 0x09	; 9
     9fa:	90 93 01 01 	sts	0x0101, r25
     9fe:	80 93 00 01 	sts	0x0100, r24
     a02:	0e 94 a7 09 	call	0x134e	; 0x134e <SPI_SPIInit>
     a06:	10 92 47 01 	sts	0x0147, r1
     a0a:	0e 94 c0 0b 	call	0x1780	; 0x1780 <DF_CheckCorrectOnboardChip>
     a0e:	88 23       	and	r24, r24
     a10:	09 f4       	brne	.+2      	; 0xa14 <FUNCProgramAVR+0x36>
     a12:	1d c1       	rjmp	.+570    	; 0xc4e <FUNCProgramAVR+0x270>
     a14:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     a18:	81 e0       	ldi	r24, 0x01	; 1
     a1a:	8e bb       	out	0x1e, r24	; 30
     a1c:	10 e0       	ldi	r17, 0x00	; 0
     a1e:	8e b3       	in	r24, 0x1e	; 30
     a20:	88 23       	and	r24, r24
     a22:	e9 f3       	breq	.-6      	; 0xa1e <FUNCProgramAVR+0x40>
     a24:	f2 99       	sbic	0x1e, 2	; 30
     a26:	13 c1       	rjmp	.+550    	; 0xc4e <FUNCProgramAVR+0x270>
     a28:	f4 99       	sbic	0x1e, 4	; 30
     a2a:	1c c0       	rjmp	.+56     	; 0xa64 <FUNCProgramAVR+0x86>
     a2c:	f6 9b       	sbis	0x1e, 6	; 30
     a2e:	06 c0       	rjmp	.+12     	; 0xa3c <FUNCProgramAVR+0x5e>
     a30:	11 23       	and	r17, r17
     a32:	11 f4       	brne	.+4      	; 0xa38 <FUNCProgramAVR+0x5a>
     a34:	17 e0       	ldi	r17, 0x07	; 7
     a36:	09 c0       	rjmp	.+18     	; 0xa4a <FUNCProgramAVR+0x6c>
     a38:	11 50       	subi	r17, 0x01	; 1
     a3a:	07 c0       	rjmp	.+14     	; 0xa4a <FUNCProgramAVR+0x6c>
     a3c:	f7 9b       	sbis	0x1e, 7	; 30
     a3e:	05 c0       	rjmp	.+10     	; 0xa4a <FUNCProgramAVR+0x6c>
     a40:	17 30       	cpi	r17, 0x07	; 7
     a42:	11 f4       	brne	.+4      	; 0xa48 <FUNCProgramAVR+0x6a>
     a44:	10 e0       	ldi	r17, 0x00	; 0
     a46:	01 c0       	rjmp	.+2      	; 0xa4a <FUNCProgramAVR+0x6c>
     a48:	1f 5f       	subi	r17, 0xFF	; 255
     a4a:	e1 2f       	mov	r30, r17
     a4c:	ff 27       	eor	r31, r31
     a4e:	ee 0f       	add	r30, r30
     a50:	ff 1f       	adc	r31, r31
     a52:	ea 5e       	subi	r30, 0xEA	; 234
     a54:	fd 4f       	sbci	r31, 0xFD	; 253
     a56:	85 91       	lpm	r24, Z+
     a58:	94 91       	lpm	r25, Z
     a5a:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     a5e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     a62:	dd cf       	rjmp	.-70     	; 0xa1e <FUNCProgramAVR+0x40>
     a64:	80 e8       	ldi	r24, 0x80	; 128
     a66:	80 93 61 00 	sts	0x0061, r24
     a6a:	10 92 61 00 	sts	0x0061, r1
     a6e:	87 ea       	ldi	r24, 0xA7	; 167
     a70:	90 e0       	ldi	r25, 0x00	; 0
     a72:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     a76:	10 92 81 00 	sts	0x0081, r1
     a7a:	0e 94 2d 0a 	call	0x145a	; 0x145a <USI_SPIInitMaster>
     a7e:	80 e0       	ldi	r24, 0x00	; 0
     a80:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     a84:	27 e2       	ldi	r18, 0x27	; 39
     a86:	30 e0       	ldi	r19, 0x00	; 0
     a88:	e1 e9       	ldi	r30, 0x91	; 145
     a8a:	f1 e0       	ldi	r31, 0x01	; 1
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     a8c:	d9 01       	movw	r26, r18
     a8e:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
     a92:	80 2d       	mov	r24, r0
     a94:	81 93       	st	Z+, r24
     a96:	2f 5f       	subi	r18, 0xFF	; 255
     a98:	3f 4f       	sbci	r19, 0xFF	; 255
     a9a:	80 e0       	ldi	r24, 0x00	; 0
     a9c:	23 33       	cpi	r18, 0x33	; 51
     a9e:	38 07       	cpc	r19, r24
     aa0:	a9 f7       	brne	.-22     	; 0xa8c <FUNCProgramAVR+0xae>
     aa2:	0e 94 87 12 	call	0x250e	; 0x250e <ISPCC_EnterChipProgrammingMode>
     aa6:	10 92 a9 02 	sts	0x02A9, r1
     aaa:	10 92 aa 02 	sts	0x02AA, r1
     aae:	10 92 ab 02 	sts	0x02AB, r1
     ab2:	10 92 ac 02 	sts	0x02AC, r1
     ab6:	80 91 92 01 	lds	r24, 0x0192
     aba:	88 23       	and	r24, r24
     abc:	09 f0       	breq	.+2      	; 0xac0 <FUNCProgramAVR+0xe2>
     abe:	aa c0       	rjmp	.+340    	; 0xc14 <FUNCProgramAVR+0x236>
     ac0:	11 23       	and	r17, r17
     ac2:	31 f0       	breq	.+12     	; 0xad0 <FUNCProgramAVR+0xf2>
     ac4:	17 30       	cpi	r17, 0x07	; 7
     ac6:	21 f0       	breq	.+8      	; 0xad0 <FUNCProgramAVR+0xf2>
     ac8:	11 30       	cpi	r17, 0x01	; 1
     aca:	11 f0       	breq	.+4      	; 0xad0 <FUNCProgramAVR+0xf2>
     acc:	13 30       	cpi	r17, 0x03	; 3
     ace:	91 f4       	brne	.+36     	; 0xaf4 <FUNCProgramAVR+0x116>
     ad0:	83 e4       	ldi	r24, 0x43	; 67
     ad2:	0e 94 36 04 	call	0x86c	; 0x86c <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     ad6:	a7 e1       	ldi	r26, 0x17	; 23
     ad8:	b0 e0       	ldi	r27, 0x00	; 0
     ada:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
     ade:	80 2d       	mov	r24, r0
     ae0:	81 30       	cpi	r24, 0x01	; 1
     ae2:	31 f0       	breq	.+12     	; 0xaf0 <FUNCProgramAVR+0x112>
     ae4:	81 e1       	ldi	r24, 0x11	; 17
     ae6:	93 e0       	ldi	r25, 0x03	; 3
     ae8:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     aec:	02 e0       	ldi	r16, 0x02	; 2
     aee:	03 c0       	rjmp	.+6      	; 0xaf6 <FUNCProgramAVR+0x118>
     af0:	0e 94 86 15 	call	0x2b0c	; 0x2b0c <PM_SendEraseCommand>
     af4:	00 e0       	ldi	r16, 0x00	; 0
     af6:	12 30       	cpi	r17, 0x02	; 2
     af8:	10 f0       	brcs	.+4      	; 0xafe <FUNCProgramAVR+0x120>
     afa:	13 30       	cpi	r17, 0x03	; 3
     afc:	c1 f4       	brne	.+48     	; 0xb2e <FUNCProgramAVR+0x150>
     afe:	00 23       	and	r16, r16
     b00:	a1 f4       	brne	.+40     	; 0xb2a <FUNCProgramAVR+0x14c>
     b02:	84 e4       	ldi	r24, 0x44	; 68
     b04:	0e 94 36 04 	call	0x86c	; 0x86c <MAIN_ShowProgType>
     b08:	81 e0       	ldi	r24, 0x01	; 1
     b0a:	0e 94 e4 14 	call	0x29c8	; 0x29c8 <PM_GetStoredDataSize>
     b0e:	61 15       	cp	r22, r1
     b10:	71 05       	cpc	r23, r1
     b12:	81 05       	cpc	r24, r1
     b14:	91 05       	cpc	r25, r1
     b16:	31 f4       	brne	.+12     	; 0xb24 <FUNCProgramAVR+0x146>
     b18:	89 e0       	ldi	r24, 0x09	; 9
     b1a:	93 e0       	ldi	r25, 0x03	; 3
     b1c:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     b20:	03 e0       	ldi	r16, 0x03	; 3
     b22:	03 c0       	rjmp	.+6      	; 0xb2a <FUNCProgramAVR+0x14c>
     b24:	81 e0       	ldi	r24, 0x01	; 1
     b26:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <PM_CreateProgrammingPackets>
     b2a:	11 23       	and	r17, r17
     b2c:	21 f0       	breq	.+8      	; 0xb36 <FUNCProgramAVR+0x158>
     b2e:	12 30       	cpi	r17, 0x02	; 2
     b30:	11 f0       	breq	.+4      	; 0xb36 <FUNCProgramAVR+0x158>
     b32:	13 30       	cpi	r17, 0x03	; 3
     b34:	b1 f4       	brne	.+44     	; 0xb62 <FUNCProgramAVR+0x184>
     b36:	85 e4       	ldi	r24, 0x45	; 69
     b38:	0e 94 36 04 	call	0x86c	; 0x86c <MAIN_ShowProgType>
     b3c:	80 e0       	ldi	r24, 0x00	; 0
     b3e:	0e 94 e4 14 	call	0x29c8	; 0x29c8 <PM_GetStoredDataSize>
     b42:	61 15       	cp	r22, r1
     b44:	71 05       	cpc	r23, r1
     b46:	81 05       	cpc	r24, r1
     b48:	91 05       	cpc	r25, r1
     b4a:	31 f4       	brne	.+12     	; 0xb58 <FUNCProgramAVR+0x17a>
     b4c:	8f ef       	ldi	r24, 0xFF	; 255
     b4e:	92 e0       	ldi	r25, 0x02	; 2
     b50:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     b54:	03 e0       	ldi	r16, 0x03	; 3
     b56:	03 c0       	rjmp	.+6      	; 0xb5e <FUNCProgramAVR+0x180>
     b58:	80 e0       	ldi	r24, 0x00	; 0
     b5a:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <PM_CreateProgrammingPackets>
     b5e:	11 23       	and	r17, r17
     b60:	21 f0       	breq	.+8      	; 0xb6a <FUNCProgramAVR+0x18c>
     b62:	14 30       	cpi	r17, 0x04	; 4
     b64:	11 f0       	breq	.+4      	; 0xb6a <FUNCProgramAVR+0x18c>
     b66:	16 30       	cpi	r17, 0x06	; 6
     b68:	a9 f4       	brne	.+42     	; 0xb94 <FUNCProgramAVR+0x1b6>
     b6a:	86 e4       	ldi	r24, 0x46	; 70
     b6c:	0e 94 36 04 	call	0x86c	; 0x86c <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     b70:	a3 e3       	ldi	r26, 0x33	; 51
     b72:	b0 e0       	ldi	r27, 0x00	; 0
     b74:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
     b78:	80 2d       	mov	r24, r0
     b7a:	88 23       	and	r24, r24
     b7c:	31 f4       	brne	.+12     	; 0xb8a <FUNCProgramAVR+0x1ac>
     b7e:	81 ef       	ldi	r24, 0xF1	; 241
     b80:	92 e0       	ldi	r25, 0x02	; 2
     b82:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     b86:	03 e0       	ldi	r16, 0x03	; 3
     b88:	03 c0       	rjmp	.+6      	; 0xb90 <FUNCProgramAVR+0x1b2>
     b8a:	82 e0       	ldi	r24, 0x02	; 2
     b8c:	0e 94 48 15 	call	0x2a90	; 0x2a90 <PM_SendFuseLockBytes>
     b90:	11 23       	and	r17, r17
     b92:	79 f0       	breq	.+30     	; 0xbb2 <FUNCProgramAVR+0x1d4>
     b94:	15 30       	cpi	r17, 0x05	; 5
     b96:	69 f0       	breq	.+26     	; 0xbb2 <FUNCProgramAVR+0x1d4>
     b98:	16 30       	cpi	r17, 0x06	; 6
     b9a:	19 f5       	brne	.+70     	; 0xbe2 <FUNCProgramAVR+0x204>
     b9c:	81 e0       	ldi	r24, 0x01	; 1
     b9e:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     ba2:	81 e0       	ldi	r24, 0x01	; 1
     ba4:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     ba8:	80 e0       	ldi	r24, 0x00	; 0
     baa:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     bae:	0e 94 87 12 	call	0x250e	; 0x250e <ISPCC_EnterChipProgrammingMode>
     bb2:	8c e4       	ldi	r24, 0x4C	; 76
     bb4:	0e 94 36 04 	call	0x86c	; 0x86c <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     bb8:	a4 e3       	ldi	r26, 0x34	; 52
     bba:	b0 e0       	ldi	r27, 0x00	; 0
     bbc:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
     bc0:	80 2d       	mov	r24, r0
     bc2:	88 23       	and	r24, r24
     bc4:	59 f4       	brne	.+22     	; 0xbdc <FUNCProgramAVR+0x1fe>
     bc6:	83 ee       	ldi	r24, 0xE3	; 227
     bc8:	92 e0       	ldi	r25, 0x02	; 2
     bca:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     bce:	62 ed       	ldi	r22, 0xD2	; 210
     bd0:	72 e0       	ldi	r23, 0x02	; 2
     bd2:	ce 01       	movw	r24, r28
     bd4:	01 96       	adiw	r24, 0x01	; 1
     bd6:	0e 94 39 1a 	call	0x3472	; 0x3472 <strcpy_P>
     bda:	0b c0       	rjmp	.+22     	; 0xbf2 <FUNCProgramAVR+0x214>
     bdc:	83 e0       	ldi	r24, 0x03	; 3
     bde:	0e 94 48 15 	call	0x2a90	; 0x2a90 <PM_SendFuseLockBytes>
     be2:	62 ed       	ldi	r22, 0xD2	; 210
     be4:	72 e0       	ldi	r23, 0x02	; 2
     be6:	ce 01       	movw	r24, r28
     be8:	01 96       	adiw	r24, 0x01	; 1
     bea:	0e 94 39 1a 	call	0x3472	; 0x3472 <strcpy_P>
     bee:	00 23       	and	r16, r16
     bf0:	31 f0       	breq	.+12     	; 0xbfe <FUNCProgramAVR+0x220>
     bf2:	6b ec       	ldi	r22, 0xCB	; 203
     bf4:	72 e0       	ldi	r23, 0x02	; 2
     bf6:	ce 01       	movw	r24, r28
     bf8:	0d 96       	adiw	r24, 0x0d	; 13
     bfa:	0e 94 39 1a 	call	0x3472	; 0x3472 <strcpy_P>
     bfe:	ce 01       	movw	r24, r28
     c00:	01 96       	adiw	r24, 0x01	; 1
     c02:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <LCD_puts>
     c06:	8a ef       	ldi	r24, 0xFA	; 250
     c08:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     c0c:	88 ec       	ldi	r24, 0xC8	; 200
     c0e:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     c12:	04 c0       	rjmp	.+8      	; 0xc1c <FUNCProgramAVR+0x23e>
     c14:	8b e2       	ldi	r24, 0x2B	; 43
     c16:	94 e0       	ldi	r25, 0x04	; 4
     c18:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     c1c:	0e 94 3f 0c 	call	0x187e	; 0x187e <TOUT_SetupSleepTimer>
     c20:	80 e8       	ldi	r24, 0x80	; 128
     c22:	80 93 61 00 	sts	0x0061, r24
     c26:	83 e0       	ldi	r24, 0x03	; 3
     c28:	80 93 61 00 	sts	0x0061, r24
     c2c:	81 e0       	ldi	r24, 0x01	; 1
     c2e:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     c32:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <USI_SPIOff>
     c36:	80 e0       	ldi	r24, 0x00	; 0
     c38:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
     c3c:	80 91 64 00 	lds	r24, 0x0064
     c40:	84 60       	ori	r24, 0x04	; 4
     c42:	80 93 64 00 	sts	0x0064, r24
     c46:	81 b3       	in	r24, 0x11	; 17
     c48:	8f 7c       	andi	r24, 0xCF	; 207
     c4a:	80 61       	ori	r24, 0x10	; 16
     c4c:	81 bb       	out	0x11, r24	; 17
     c4e:	63 96       	adiw	r28, 0x13	; 19
     c50:	0f b6       	in	r0, 0x3f	; 63
     c52:	f8 94       	cli
     c54:	de bf       	out	0x3e, r29	; 62
     c56:	0f be       	out	0x3f, r0	; 63
     c58:	cd bf       	out	0x3d, r28	; 61
     c5a:	df 91       	pop	r29
     c5c:	cf 91       	pop	r28
     c5e:	1f 91       	pop	r17
     c60:	0f 91       	pop	r16
     c62:	08 95       	ret

00000c64 <main>:
     c64:	1f 93       	push	r17
     c66:	80 e8       	ldi	r24, 0x80	; 128
     c68:	85 bf       	out	0x35, r24	; 53
     c6a:	85 bf       	out	0x35, r24	; 53
     c6c:	80 bf       	out	0x30, r24	; 48
     c6e:	85 e0       	ldi	r24, 0x05	; 5
     c70:	80 93 64 00 	sts	0x0064, r24
     c74:	80 e3       	ldi	r24, 0x30	; 48
     c76:	80 bb       	out	0x10, r24	; 16
     c78:	87 e2       	ldi	r24, 0x27	; 39
     c7a:	84 b9       	out	0x04, r24	; 4
     c7c:	8f ed       	ldi	r24, 0xDF	; 223
     c7e:	85 b9       	out	0x05, r24	; 5
     c80:	8c e0       	ldi	r24, 0x0C	; 12
     c82:	8e b9       	out	0x0e, r24	; 14
     c84:	80 93 6b 00 	sts	0x006B, r24
     c88:	80 ed       	ldi	r24, 0xD0	; 208
     c8a:	80 93 6c 00 	sts	0x006C, r24
     c8e:	80 ec       	ldi	r24, 0xC0	; 192
     c90:	8d bb       	out	0x1d, r24	; 29
     c92:	8c bb       	out	0x1c, r24	; 28
     c94:	81 b3       	in	r24, 0x11	; 17
     c96:	8f 7c       	andi	r24, 0xCF	; 207
     c98:	80 63       	ori	r24, 0x30	; 48
     c9a:	81 bb       	out	0x11, r24	; 17
     c9c:	81 e0       	ldi	r24, 0x01	; 1
     c9e:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     ca2:	0e 94 6f 08 	call	0x10de	; 0x10de <LCD_Init>
     ca6:	8f e0       	ldi	r24, 0x0F	; 15
     ca8:	80 93 e7 00 	sts	0x00E7, r24
     cac:	87 ea       	ldi	r24, 0xA7	; 167
     cae:	90 e0       	ldi	r25, 0x00	; 0
     cb0:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     cb4:	78 94       	sei
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     cb6:	ad e8       	ldi	r26, 0x8D	; 141
     cb8:	b0 e0       	ldi	r27, 0x00	; 0
     cba:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
     cbe:	80 2d       	mov	r24, r0
     cc0:	8a 37       	cpi	r24, 0x7A	; 122
     cc2:	89 f0       	breq	.+34     	; 0xce6 <main+0x82>
     cc4:	80 e0       	ldi	r24, 0x00	; 0
     cc6:	90 e0       	ldi	r25, 0x00	; 0
     cc8:	2f ef       	ldi	r18, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     cca:	dc 01       	movw	r26, r24
     ccc:	02 2e       	mov	r0, r18
     cce:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
     cd2:	01 96       	adiw	r24, 0x01	; 1
     cd4:	8e 38       	cpi	r24, 0x8E	; 142
     cd6:	91 05       	cpc	r25, r1
     cd8:	c1 f7       	brne	.-16     	; 0xcca <main+0x66>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     cda:	8a e7       	ldi	r24, 0x7A	; 122
     cdc:	ad e8       	ldi	r26, 0x8D	; 141
     cde:	b0 e0       	ldi	r27, 0x00	; 0
     ce0:	08 2e       	mov	r0, r24
     ce2:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
     ce6:	a9 e8       	ldi	r26, 0x89	; 137
     ce8:	b0 e0       	ldi	r27, 0x00	; 0
     cea:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
     cee:	80 2d       	mov	r24, r0
     cf0:	8f 70       	andi	r24, 0x0F	; 15
     cf2:	80 93 e7 00 	sts	0x00E7, r24
     cf6:	80 e0       	ldi	r24, 0x00	; 0
     cf8:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
     cfc:	0e 94 96 09 	call	0x132c	; 0x132c <USART_Init>
     d00:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <OSCCAL_Calibrate>
     d04:	0e 94 3f 0c 	call	0x187e	; 0x187e <TOUT_SetupSleepTimer>
     d08:	81 b3       	in	r24, 0x11	; 17
     d0a:	8f 7c       	andi	r24, 0xCF	; 207
     d0c:	80 61       	ori	r24, 0x10	; 16
     d0e:	81 bb       	out	0x11, r24	; 17
     d10:	80 e8       	ldi	r24, 0x80	; 128
     d12:	80 93 61 00 	sts	0x0061, r24
     d16:	83 e0       	ldi	r24, 0x03	; 3
     d18:	80 93 61 00 	sts	0x0061, r24
     d1c:	81 e0       	ldi	r24, 0x01	; 1
     d1e:	8e bb       	out	0x1e, r24	; 30
     d20:	10 e0       	ldi	r17, 0x00	; 0
     d22:	8e b3       	in	r24, 0x1e	; 30
     d24:	88 23       	and	r24, r24
     d26:	e9 f3       	breq	.-6      	; 0xd22 <main+0xbe>
     d28:	f6 9b       	sbis	0x1e, 6	; 30
     d2a:	06 c0       	rjmp	.+12     	; 0xd38 <main+0xd4>
     d2c:	11 23       	and	r17, r17
     d2e:	11 f4       	brne	.+4      	; 0xd34 <main+0xd0>
     d30:	16 e0       	ldi	r17, 0x06	; 6
     d32:	1b c0       	rjmp	.+54     	; 0xd6a <main+0x106>
     d34:	11 50       	subi	r17, 0x01	; 1
     d36:	19 c0       	rjmp	.+50     	; 0xd6a <main+0x106>
     d38:	f7 9b       	sbis	0x1e, 7	; 30
     d3a:	06 c0       	rjmp	.+12     	; 0xd48 <main+0xe4>
     d3c:	16 30       	cpi	r17, 0x06	; 6
     d3e:	11 f4       	brne	.+4      	; 0xd44 <main+0xe0>
     d40:	10 e0       	ldi	r17, 0x00	; 0
     d42:	13 c0       	rjmp	.+38     	; 0xd6a <main+0x106>
     d44:	1f 5f       	subi	r17, 0xFF	; 255
     d46:	11 c0       	rjmp	.+34     	; 0xd6a <main+0x106>
     d48:	f4 9b       	sbis	0x1e, 4	; 30
     d4a:	0b c0       	rjmp	.+22     	; 0xd62 <main+0xfe>
     d4c:	e1 2f       	mov	r30, r17
     d4e:	ff 27       	eor	r31, r31
     d50:	ee 0f       	add	r30, r30
     d52:	ff 1f       	adc	r31, r31
     d54:	ef 5e       	subi	r30, 0xEF	; 239
     d56:	fe 4f       	sbci	r31, 0xFE	; 254
     d58:	85 91       	lpm	r24, Z+
     d5a:	94 91       	lpm	r25, Z
     d5c:	fc 01       	movw	r30, r24
     d5e:	09 95       	icall
     d60:	04 c0       	rjmp	.+8      	; 0xd6a <main+0x106>
     d62:	f3 9b       	sbis	0x1e, 3	; 30
     d64:	02 c0       	rjmp	.+4      	; 0xd6a <main+0x106>
     d66:	0e 94 04 03 	call	0x608	; 0x608 <FUNCShowAbout>
     d6a:	e1 2f       	mov	r30, r17
     d6c:	ff 27       	eor	r31, r31
     d6e:	ee 0f       	add	r30, r30
     d70:	ff 1f       	adc	r31, r31
     d72:	ed 5f       	subi	r30, 0xFD	; 253
     d74:	fe 4f       	sbci	r31, 0xFE	; 254
     d76:	85 91       	lpm	r24, Z+
     d78:	94 91       	lpm	r25, Z
     d7a:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     d7e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     d82:	cf cf       	rjmp	.-98     	; 0xd22 <main+0xbe>

00000d84 <FUNCClearMem>:
     d84:	84 eb       	ldi	r24, 0xB4	; 180
     d86:	92 e0       	ldi	r25, 0x02	; 2
     d88:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     d8c:	84 eb       	ldi	r24, 0xB4	; 180
     d8e:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     d92:	8e ea       	ldi	r24, 0xAE	; 174
     d94:	92 e0       	ldi	r25, 0x02	; 2
     d96:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     d9a:	8e b3       	in	r24, 0x1e	; 30
     d9c:	88 23       	and	r24, r24
     d9e:	e9 f3       	breq	.-6      	; 0xd9a <FUNCClearMem+0x16>
     da0:	f2 99       	sbic	0x1e, 2	; 30
     da2:	22 c0       	rjmp	.+68     	; 0xde8 <FUNCClearMem+0x64>
     da4:	f3 9b       	sbis	0x1e, 3	; 30
     da6:	f9 cf       	rjmp	.-14     	; 0xd9a <FUNCClearMem+0x16>
     da8:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     dac:	87 ea       	ldi	r24, 0xA7	; 167
     dae:	90 e0       	ldi	r25, 0x00	; 0
     db0:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     db4:	81 b3       	in	r24, 0x11	; 17
     db6:	8f 7c       	andi	r24, 0xCF	; 207
     db8:	80 63       	ori	r24, 0x30	; 48
     dba:	81 bb       	out	0x11, r24	; 17
     dbc:	80 e0       	ldi	r24, 0x00	; 0
     dbe:	90 e0       	ldi	r25, 0x00	; 0
     dc0:	2f ef       	ldi	r18, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     dc2:	dc 01       	movw	r26, r24
     dc4:	02 2e       	mov	r0, r18
     dc6:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
     dca:	01 96       	adiw	r24, 0x01	; 1
     dcc:	8e 38       	cpi	r24, 0x8E	; 142
     dce:	91 05       	cpc	r25, r1
     dd0:	c1 f7       	brne	.-16     	; 0xdc2 <FUNCClearMem+0x3e>
     dd2:	81 b3       	in	r24, 0x11	; 17
     dd4:	8f 7c       	andi	r24, 0xCF	; 207
     dd6:	80 61       	ori	r24, 0x10	; 16
     dd8:	81 bb       	out	0x11, r24	; 17
     dda:	82 ea       	ldi	r24, 0xA2	; 162
     ddc:	92 e0       	ldi	r25, 0x02	; 2
     dde:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     de2:	8a ef       	ldi	r24, 0xFA	; 250
     de4:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     de8:	08 95       	ret

00000dea <FUNCSetContrast>:
     dea:	1f 93       	push	r17
     dec:	cf 93       	push	r28
     dee:	df 93       	push	r29
     df0:	cd b7       	in	r28, 0x3d	; 61
     df2:	de b7       	in	r29, 0x3e	; 62
     df4:	26 97       	sbiw	r28, 0x06	; 6
     df6:	0f b6       	in	r0, 0x3f	; 63
     df8:	f8 94       	cli
     dfa:	de bf       	out	0x3e, r29	; 62
     dfc:	0f be       	out	0x3f, r0	; 63
     dfe:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     e00:	a9 e8       	ldi	r26, 0x89	; 137
     e02:	b0 e0       	ldi	r27, 0x00	; 0
     e04:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
     e08:	80 2d       	mov	r24, r0
     e0a:	18 2f       	mov	r17, r24
     e0c:	1f 70       	andi	r17, 0x0F	; 15
     e0e:	81 e0       	ldi	r24, 0x01	; 1
     e10:	8e bb       	out	0x1e, r24	; 30
     e12:	8e b3       	in	r24, 0x1e	; 30
     e14:	88 23       	and	r24, r24
     e16:	e9 f3       	breq	.-6      	; 0xe12 <FUNCSetContrast+0x28>
     e18:	f6 9b       	sbis	0x1e, 6	; 30
     e1a:	04 c0       	rjmp	.+8      	; 0xe24 <FUNCSetContrast+0x3a>
     e1c:	1f 30       	cpi	r17, 0x0F	; 15
     e1e:	50 f4       	brcc	.+20     	; 0xe34 <FUNCSetContrast+0x4a>
     e20:	1f 5f       	subi	r17, 0xFF	; 255
     e22:	08 c0       	rjmp	.+16     	; 0xe34 <FUNCSetContrast+0x4a>
     e24:	f7 9b       	sbis	0x1e, 7	; 30
     e26:	04 c0       	rjmp	.+8      	; 0xe30 <FUNCSetContrast+0x46>
     e28:	12 30       	cpi	r17, 0x02	; 2
     e2a:	20 f0       	brcs	.+8      	; 0xe34 <FUNCSetContrast+0x4a>
     e2c:	11 50       	subi	r17, 0x01	; 1
     e2e:	02 c0       	rjmp	.+4      	; 0xe34 <FUNCSetContrast+0x4a>
     e30:	f2 99       	sbic	0x1e, 2	; 30
     e32:	18 c0       	rjmp	.+48     	; 0xe64 <FUNCSetContrast+0x7a>
     e34:	83 e4       	ldi	r24, 0x43	; 67
     e36:	89 83       	std	Y+1, r24	; 0x01
     e38:	84 e5       	ldi	r24, 0x54	; 84
     e3a:	8a 83       	std	Y+2, r24	; 0x02
     e3c:	80 e2       	ldi	r24, 0x20	; 32
     e3e:	8b 83       	std	Y+3, r24	; 0x03
     e40:	be 01       	movw	r22, r28
     e42:	6c 5f       	subi	r22, 0xFC	; 252
     e44:	7f 4f       	sbci	r23, 0xFF	; 255
     e46:	81 2f       	mov	r24, r17
     e48:	99 27       	eor	r25, r25
     e4a:	0e 94 9c 02 	call	0x538	; 0x538 <MAIN_IntToStr>
     e4e:	ce 01       	movw	r24, r28
     e50:	01 96       	adiw	r24, 0x01	; 1
     e52:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <LCD_puts>
     e56:	81 2f       	mov	r24, r17
     e58:	8f 70       	andi	r24, 0x0F	; 15
     e5a:	80 93 e7 00 	sts	0x00E7, r24
     e5e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     e62:	d7 cf       	rjmp	.-82     	; 0xe12 <FUNCSetContrast+0x28>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     e64:	a9 e8       	ldi	r26, 0x89	; 137
     e66:	b0 e0       	ldi	r27, 0x00	; 0
     e68:	01 2e       	mov	r0, r17
     e6a:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
     e6e:	26 96       	adiw	r28, 0x06	; 6
     e70:	0f b6       	in	r0, 0x3f	; 63
     e72:	f8 94       	cli
     e74:	de bf       	out	0x3e, r29	; 62
     e76:	0f be       	out	0x3f, r0	; 63
     e78:	cd bf       	out	0x3d, r28	; 61
     e7a:	df 91       	pop	r29
     e7c:	cf 91       	pop	r28
     e7e:	1f 91       	pop	r17
     e80:	08 95       	ret

00000e82 <FUNCSetISPSpeed>:
     e82:	1f 93       	push	r17
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     e84:	a2 e0       	ldi	r26, 0x02	; 2
     e86:	b0 e0       	ldi	r27, 0x00	; 0
     e88:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
     e8c:	80 2d       	mov	r24, r0
     e8e:	18 2f       	mov	r17, r24
     e90:	84 30       	cpi	r24, 0x04	; 4
     e92:	08 f0       	brcs	.+2      	; 0xe96 <FUNCSetISPSpeed+0x14>
     e94:	13 e0       	ldi	r17, 0x03	; 3
     e96:	81 e0       	ldi	r24, 0x01	; 1
     e98:	8e bb       	out	0x1e, r24	; 30
     e9a:	8e b3       	in	r24, 0x1e	; 30
     e9c:	88 23       	and	r24, r24
     e9e:	e9 f3       	breq	.-6      	; 0xe9a <FUNCSetISPSpeed+0x18>
     ea0:	f6 9b       	sbis	0x1e, 6	; 30
     ea2:	06 c0       	rjmp	.+12     	; 0xeb0 <FUNCSetISPSpeed+0x2e>
     ea4:	11 23       	and	r17, r17
     ea6:	11 f4       	brne	.+4      	; 0xeac <FUNCSetISPSpeed+0x2a>
     ea8:	13 e0       	ldi	r17, 0x03	; 3
     eaa:	0c c0       	rjmp	.+24     	; 0xec4 <FUNCSetISPSpeed+0x42>
     eac:	11 50       	subi	r17, 0x01	; 1
     eae:	0a c0       	rjmp	.+20     	; 0xec4 <FUNCSetISPSpeed+0x42>
     eb0:	f7 9b       	sbis	0x1e, 7	; 30
     eb2:	04 c0       	rjmp	.+8      	; 0xebc <FUNCSetISPSpeed+0x3a>
     eb4:	13 30       	cpi	r17, 0x03	; 3
     eb6:	29 f0       	breq	.+10     	; 0xec2 <FUNCSetISPSpeed+0x40>
     eb8:	1f 5f       	subi	r17, 0xFF	; 255
     eba:	04 c0       	rjmp	.+8      	; 0xec4 <FUNCSetISPSpeed+0x42>
     ebc:	f2 9b       	sbis	0x1e, 2	; 30
     ebe:	02 c0       	rjmp	.+4      	; 0xec4 <FUNCSetISPSpeed+0x42>
     ec0:	0c c0       	rjmp	.+24     	; 0xeda <FUNCSetISPSpeed+0x58>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     ec2:	10 e0       	ldi	r17, 0x00	; 0
     ec4:	8a e0       	ldi	r24, 0x0A	; 10
     ec6:	18 9f       	mul	r17, r24
     ec8:	c0 01       	movw	r24, r0
     eca:	11 24       	eor	r1, r1
     ecc:	8a 5d       	subi	r24, 0xDA	; 218
     ece:	9d 4f       	sbci	r25, 0xFD	; 253
     ed0:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     ed4:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     ed8:	e0 cf       	rjmp	.-64     	; 0xe9a <FUNCSetISPSpeed+0x18>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     eda:	a2 e0       	ldi	r26, 0x02	; 2
     edc:	b0 e0       	ldi	r27, 0x00	; 0
     ede:	01 2e       	mov	r0, r17
     ee0:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
     ee4:	1f 91       	pop	r17
     ee6:	08 95       	ret

00000ee8 <FUNCSetResetMode>:
     ee8:	1f 93       	push	r17
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     eea:	ac e8       	ldi	r26, 0x8C	; 140
     eec:	b0 e0       	ldi	r27, 0x00	; 0
     eee:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
     ef2:	80 2d       	mov	r24, r0
     ef4:	18 2f       	mov	r17, r24
     ef6:	11 70       	andi	r17, 0x01	; 1
     ef8:	81 e0       	ldi	r24, 0x01	; 1
     efa:	8e bb       	out	0x1e, r24	; 30
     efc:	8e b3       	in	r24, 0x1e	; 30
     efe:	88 23       	and	r24, r24
     f00:	e9 f3       	breq	.-6      	; 0xefc <FUNCSetResetMode+0x14>
     f02:	f6 99       	sbic	0x1e, 6	; 30
     f04:	02 c0       	rjmp	.+4      	; 0xf0a <FUNCSetResetMode+0x22>
     f06:	f7 9b       	sbis	0x1e, 7	; 30
     f08:	03 c0       	rjmp	.+6      	; 0xf10 <FUNCSetResetMode+0x28>
     f0a:	81 e0       	ldi	r24, 0x01	; 1
     f0c:	18 27       	eor	r17, r24
     f0e:	02 c0       	rjmp	.+4      	; 0xf14 <FUNCSetResetMode+0x2c>
     f10:	f2 99       	sbic	0x1e, 2	; 30
     f12:	0b c0       	rjmp	.+22     	; 0xf2a <FUNCSetResetMode+0x42>
     f14:	86 e0       	ldi	r24, 0x06	; 6
     f16:	18 9f       	mul	r17, r24
     f18:	c0 01       	movw	r24, r0
     f1a:	11 24       	eor	r1, r1
     f1c:	82 5b       	subi	r24, 0xB2	; 178
     f1e:	9d 4f       	sbci	r25, 0xFD	; 253
     f20:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     f24:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     f28:	e9 cf       	rjmp	.-46     	; 0xefc <FUNCSetResetMode+0x14>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     f2a:	ac e8       	ldi	r26, 0x8C	; 140
     f2c:	b0 e0       	ldi	r27, 0x00	; 0
     f2e:	01 2e       	mov	r0, r17
     f30:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
     f34:	1f 91       	pop	r17
     f36:	08 95       	ret

00000f38 <FUNCSetFirmMinorVer>:
     f38:	1f 93       	push	r17
     f3a:	cf 93       	push	r28
     f3c:	df 93       	push	r29
     f3e:	cd b7       	in	r28, 0x3d	; 61
     f40:	de b7       	in	r29, 0x3e	; 62
     f42:	25 97       	sbiw	r28, 0x05	; 5
     f44:	0f b6       	in	r0, 0x3f	; 63
     f46:	f8 94       	cli
     f48:	de bf       	out	0x3e, r29	; 62
     f4a:	0f be       	out	0x3f, r0	; 63
     f4c:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     f4e:	aa e8       	ldi	r26, 0x8A	; 138
     f50:	b0 e0       	ldi	r27, 0x00	; 0
     f52:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
     f56:	80 2d       	mov	r24, r0
     f58:	18 2f       	mov	r17, r24
     f5a:	8a 30       	cpi	r24, 0x0A	; 10
     f5c:	08 f0       	brcs	.+2      	; 0xf60 <FUNCSetFirmMinorVer+0x28>
     f5e:	14 e0       	ldi	r17, 0x04	; 4
     f60:	6d e9       	ldi	r22, 0x9D	; 157
     f62:	72 e0       	ldi	r23, 0x02	; 2
     f64:	ce 01       	movw	r24, r28
     f66:	01 96       	adiw	r24, 0x01	; 1
     f68:	0e 94 39 1a 	call	0x3472	; 0x3472 <strcpy_P>
     f6c:	81 e0       	ldi	r24, 0x01	; 1
     f6e:	8e bb       	out	0x1e, r24	; 30
     f70:	8e b3       	in	r24, 0x1e	; 30
     f72:	88 23       	and	r24, r24
     f74:	e9 f3       	breq	.-6      	; 0xf70 <FUNCSetFirmMinorVer+0x38>
     f76:	f6 9b       	sbis	0x1e, 6	; 30
     f78:	03 c0       	rjmp	.+6      	; 0xf80 <FUNCSetFirmMinorVer+0x48>
     f7a:	19 30       	cpi	r17, 0x09	; 9
     f7c:	08 f4       	brcc	.+2      	; 0xf80 <FUNCSetFirmMinorVer+0x48>
     f7e:	1f 5f       	subi	r17, 0xFF	; 255
     f80:	f7 9b       	sbis	0x1e, 7	; 30
     f82:	04 c0       	rjmp	.+8      	; 0xf8c <FUNCSetFirmMinorVer+0x54>
     f84:	11 23       	and	r17, r17
     f86:	21 f0       	breq	.+8      	; 0xf90 <FUNCSetFirmMinorVer+0x58>
     f88:	11 50       	subi	r17, 0x01	; 1
     f8a:	02 c0       	rjmp	.+4      	; 0xf90 <FUNCSetFirmMinorVer+0x58>
     f8c:	f2 99       	sbic	0x1e, 2	; 30
     f8e:	0a c0       	rjmp	.+20     	; 0xfa4 <FUNCSetFirmMinorVer+0x6c>
     f90:	10 5d       	subi	r17, 0xD0	; 208
     f92:	1c 83       	std	Y+4, r17	; 0x04
     f94:	10 53       	subi	r17, 0x30	; 48
     f96:	ce 01       	movw	r24, r28
     f98:	01 96       	adiw	r24, 0x01	; 1
     f9a:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <LCD_puts>
     f9e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     fa2:	e6 cf       	rjmp	.-52     	; 0xf70 <FUNCSetFirmMinorVer+0x38>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     fa4:	aa e8       	ldi	r26, 0x8A	; 138
     fa6:	b0 e0       	ldi	r27, 0x00	; 0
     fa8:	01 2e       	mov	r0, r17
     faa:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
     fae:	25 96       	adiw	r28, 0x05	; 5
     fb0:	0f b6       	in	r0, 0x3f	; 63
     fb2:	f8 94       	cli
     fb4:	de bf       	out	0x3e, r29	; 62
     fb6:	0f be       	out	0x3f, r0	; 63
     fb8:	cd bf       	out	0x3d, r28	; 61
     fba:	df 91       	pop	r29
     fbc:	cf 91       	pop	r28
     fbe:	1f 91       	pop	r17
     fc0:	08 95       	ret

00000fc2 <OSCCAL_Calibrate>:

volatile uint16_t ActualCount = 0;

void OSCCAL_Calibrate(void)
{
     fc2:	10 92 05 01 	sts	0x0105, r1
     fc6:	10 92 04 01 	sts	0x0104, r1
	uint8_t SREG_Backup;
	uint8_t LoopCount = (0x7F / 2); // Maximum range is 128, and starts from the middle, so 64 is the max number of iterations required
	uint8_t PrevOSCALValues[4] = {0,0,0,0};
   
	// Reset ActualCount
	ActualCount = 0;
   
	// Make sure all clock division is turned off (8Mhz RC clock)
	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_BASECLOCKSPEED_8MHZ);
     fca:	80 e8       	ldi	r24, 0x80	; 128
     fcc:	80 93 61 00 	sts	0x0061, r24
     fd0:	10 92 61 00 	sts	0x0061, r1

	// Inital OSCCAL of half its maximum
	OSCCAL = (0x7F / 2);
     fd4:	8f e3       	ldi	r24, 0x3F	; 63
     fd6:	80 93 66 00 	sts	0x0066, r24

	// Save the SREG
	SREG_Backup = SREG;
     fda:	7f b7       	in	r23, 0x3f	; 63
    
	// Disable all timer 1 interrupts
	TIMSK1 = 0;
     fdc:	10 92 6f 00 	sts	0x006F, r1
        
	// Set timer 2 to asyncronous mode (32.768KHz crystal)
	ASSR   = (1 << AS2);
     fe0:	88 e0       	ldi	r24, 0x08	; 8
     fe2:	80 93 b6 00 	sts	0x00B6, r24
        
	// Timer 2 overflow interrupt enable
	TIMSK2 = (1 << TOIE2);
     fe6:	81 e0       	ldi	r24, 0x01	; 1
     fe8:	80 93 70 00 	sts	0x0070, r24

	// Enable interrupts
	sei();
     fec:	78 94       	sei

	// Start both counters with no prescaling
	TCCR1B = (1 << CS10);
     fee:	80 93 81 00 	sts	0x0081, r24
	TCCR2A = (1 << CS20);
     ff2:	80 93 b0 00 	sts	0x00B0, r24
	 	 
	// Previous OSCCAL value of 0
	PrevOSCALValues[0] = 0;

	// Wait until timer 2's external 32.768KHz crystal is stable
	while (ASSR & ((1 << TCN2UB) | (1 << TCR2UB) | (1 << OCR2UB)));
     ff6:	80 91 b6 00 	lds	r24, 0x00B6
     ffa:	99 27       	eor	r25, r25
     ffc:	87 70       	andi	r24, 0x07	; 7
     ffe:	90 70       	andi	r25, 0x00	; 0
    1000:	89 2b       	or	r24, r25
    1002:	c9 f7       	brne	.-14     	; 0xff6 <OSCCAL_Calibrate+0x34>
    
	// Clear the timer values
	TCNT1  = 0;
    1004:	10 92 85 00 	sts	0x0085, r1
    1008:	10 92 84 00 	sts	0x0084, r1
	TCNT2  = 0;
    100c:	10 92 b2 00 	sts	0x00B2, r1
    1010:	3e e3       	ldi	r19, 0x3E	; 62
    1012:	60 e0       	ldi	r22, 0x00	; 0
    1014:	50 e0       	ldi	r21, 0x00	; 0
    1016:	20 e0       	ldi	r18, 0x00	; 0
    1018:	e9 e9       	ldi	r30, 0x99	; 153
    101a:	f9 ec       	ldi	r31, 0xC9	; 201
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    101c:	cf 01       	movw	r24, r30
    101e:	01 97       	sbiw	r24, 0x01	; 1
    1020:	f1 f7       	brne	.-4      	; 0x101e <OSCCAL_Calibrate+0x5c>
    
	while (LoopCount--)
	{
		// Let it take a few readings (28ms, approx 4 readings)
		_delay_ms(28);

		PrevOSCALValues[3] = PrevOSCALValues[2];
		PrevOSCALValues[2] = PrevOSCALValues[1];
		PrevOSCALValues[1] = PrevOSCALValues[0];
		PrevOSCALValues[0] = OSCCAL;
    1022:	40 91 66 00 	lds	r20, 0x0066
        
		if (ActualCount > OSCCAL_TARGETCOUNT)       // Clock is running too fast
    1026:	80 91 04 01 	lds	r24, 0x0104
    102a:	90 91 05 01 	lds	r25, 0x0105
    102e:	81 50       	subi	r24, 0x01	; 1
    1030:	91 4e       	sbci	r25, 0xE1	; 225
    1032:	20 f0       	brcs	.+8      	; 0x103c <OSCCAL_Calibrate+0x7a>
			OSCCAL--;
    1034:	80 91 66 00 	lds	r24, 0x0066
    1038:	81 50       	subi	r24, 0x01	; 1
    103a:	0a c0       	rjmp	.+20     	; 0x1050 <OSCCAL_Calibrate+0x8e>
		else if (ActualCount < OSCCAL_TARGETCOUNT) // Clock is running too slow
    103c:	80 91 04 01 	lds	r24, 0x0104
    1040:	90 91 05 01 	lds	r25, 0x0105
    1044:	80 50       	subi	r24, 0x00	; 0
    1046:	91 4e       	sbci	r25, 0xE1	; 225
    1048:	28 f4       	brcc	.+10     	; 0x1054 <OSCCAL_Calibrate+0x92>
			OSCCAL++;
    104a:	80 91 66 00 	lds	r24, 0x0066
    104e:	8f 5f       	subi	r24, 0xFF	; 255
    1050:	80 93 66 00 	sts	0x0066, r24
		
		// When the routine finds the closest value for the given target count,
		// it will cause the OSCCAL to hover around the closest two values.
		// If the current value is the same as several loops previous, exit the
		// routine as the best value has been found.
		if ((OSCCAL == PrevOSCALValues[1]) && (OSCCAL == PrevOSCALValues[3]))
    1054:	80 91 66 00 	lds	r24, 0x0066
    1058:	82 17       	cp	r24, r18
    105a:	21 f4       	brne	.+8      	; 0x1064 <OSCCAL_Calibrate+0xa2>
    105c:	80 91 66 00 	lds	r24, 0x0066
    1060:	85 17       	cp	r24, r21
    1062:	39 f0       	breq	.+14     	; 0x1072 <OSCCAL_Calibrate+0xb0>
    1064:	31 50       	subi	r19, 0x01	; 1
    1066:	56 2f       	mov	r21, r22
    1068:	62 2f       	mov	r22, r18
    106a:	3f 3f       	cpi	r19, 0xFF	; 255
    106c:	11 f0       	breq	.+4      	; 0x1072 <OSCCAL_Calibrate+0xb0>
    106e:	24 2f       	mov	r18, r20
    1070:	d5 cf       	rjmp	.-86     	; 0x101c <OSCCAL_Calibrate+0x5a>
		  break;
	}

	// Disable all timer interrupts
	TIMSK1 = 0;
    1072:	10 92 6f 00 	sts	0x006F, r1
	TIMSK2 = 0;
    1076:	10 92 70 00 	sts	0x0070, r1
    
	// Stop the timers
	TCCR1B = 0x00;
    107a:	10 92 81 00 	sts	0x0081, r1
	TCCR2A = 0x00;
    107e:	10 92 b0 00 	sts	0x00B0, r1

	// Turn off timer 2 asynchronous mode
	ASSR  &= ~(1 << AS2);
    1082:	80 91 b6 00 	lds	r24, 0x00B6
    1086:	87 7f       	andi	r24, 0xF7	; 247
    1088:	80 93 b6 00 	sts	0x00B6, r24

	// Restore SREG
	SREG = SREG_Backup;
    108c:	7f bf       	out	0x3f, r23	; 63
    108e:	08 95       	ret

00001090 <__vector_5>:
        
	return;
}

ISR(TIMER2_OVF_vect, ISR_BLOCK) // Occurs 32768/256 timers per second, or 128Hz
{
    1090:	1f 92       	push	r1
    1092:	0f 92       	push	r0
    1094:	0f b6       	in	r0, 0x3f	; 63
    1096:	0f 92       	push	r0
    1098:	11 24       	eor	r1, r1
    109a:	8f 93       	push	r24
    109c:	9f 93       	push	r25
    109e:	af 93       	push	r26
    10a0:	bf 93       	push	r27
    10a2:	ef 93       	push	r30
    10a4:	ff 93       	push	r31
	// Stop timer 1 so it can be read
	TCCR1B = 0x00;
    10a6:	a1 e8       	ldi	r26, 0x81	; 129
    10a8:	b0 e0       	ldi	r27, 0x00	; 0
    10aa:	1c 92       	st	X, r1
    
	// Record timer 1's value
	ActualCount = TCNT1;
    10ac:	e4 e8       	ldi	r30, 0x84	; 132
    10ae:	f0 e0       	ldi	r31, 0x00	; 0
    10b0:	80 81       	ld	r24, Z
    10b2:	91 81       	ldd	r25, Z+1	; 0x01
    10b4:	90 93 05 01 	sts	0x0105, r25
    10b8:	80 93 04 01 	sts	0x0104, r24
	     
	// Reset counters and restart timer 1
	TCNT1  = 0;
    10bc:	11 82       	std	Z+1, r1	; 0x01
    10be:	10 82       	st	Z, r1
	TCNT2  = 0;
    10c0:	10 92 b2 00 	sts	0x00B2, r1
	TCCR1B = (1 << CS10);
    10c4:	81 e0       	ldi	r24, 0x01	; 1
    10c6:	8c 93       	st	X, r24
    10c8:	ff 91       	pop	r31
    10ca:	ef 91       	pop	r30
    10cc:	bf 91       	pop	r27
    10ce:	af 91       	pop	r26
    10d0:	9f 91       	pop	r25
    10d2:	8f 91       	pop	r24
    10d4:	0f 90       	pop	r0
    10d6:	0f be       	out	0x3f, r0	; 63
    10d8:	0f 90       	pop	r0
    10da:	1f 90       	pop	r1
    10dc:	18 95       	reti

000010de <LCD_Init>:

// ======================================================================================

void LCD_Init(void)
{
    10de:	8f e0       	ldi	r24, 0x0F	; 15
    10e0:	80 93 e7 00 	sts	0x00E7, r24
	// Set the initial contrast level to maximum:
	LCDCCR = 0x0F;

    // Select asynchronous clock source, enable all COM pins and enable all segment pins:
    LCDCRB  = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
    10e4:	87 eb       	ldi	r24, 0xB7	; 183
    10e6:	80 93 e5 00 	sts	0x00E5, r24

    // Set LCD prescaler to give a framerate of 32Hz:
    LCDFRR  = (7<<LCDCD0);    
    10ea:	87 e0       	ldi	r24, 0x07	; 7
    10ec:	80 93 e6 00 	sts	0x00E6, r24

	// Enable LCD and set low power waveform, enable start of frame interrupt:
    LCDCRA  = (1<<LCDEN) | (1<<LCDAB) | (1<<LCDIE);
    10f0:	88 ec       	ldi	r24, 0xC8	; 200
    10f2:	80 93 e4 00 	sts	0x00E4, r24
    10f6:	08 95       	ret

000010f8 <LCD_puts>:
}

void LCD_puts_f(const uint8_t *FlashData)
{
	uint8_t StrBuff[LCD_TEXTBUFFER_SIZE];

	strcpy_P(StrBuff, FlashData);
	LCD_puts(StrBuff);
}

void LCD_puts(const uint8_t *Data)
{
    10f8:	fc 01       	movw	r30, r24
    10fa:	ac e0       	ldi	r26, 0x0C	; 12
    10fc:	b1 e0       	ldi	r27, 0x01	; 1
    10fe:	38 2f       	mov	r19, r24
    1100:	4f ef       	ldi	r20, 0xFF	; 255
    1102:	2e 2f       	mov	r18, r30
    1104:	23 1b       	sub	r18, r19
	uint8_t LoadB;
	
	for (LoadB = 0; LoadB < 20; LoadB++)
	{
		uint8_t CByte = *(Data++);
    1106:	91 91       	ld	r25, Z+
	
		if ((CByte >= '*') && (CByte <= 'z') && (CByte != ' '))
    1108:	89 2f       	mov	r24, r25
    110a:	8a 52       	subi	r24, 0x2A	; 42
    110c:	81 35       	cpi	r24, 0x51	; 81
    110e:	10 f4       	brcc	.+4      	; 0x1114 <LCD_puts+0x1c>
		  TextBuffer[LoadB] = (CByte - '*');
    1110:	8c 93       	st	X, r24
    1112:	03 c0       	rjmp	.+6      	; 0x111a <LCD_puts+0x22>
		else if (CByte == 0x00)
    1114:	99 23       	and	r25, r25
    1116:	41 f0       	breq	.+16     	; 0x1128 <LCD_puts+0x30>
		  break;
		else
		  TextBuffer[LoadB] = 0xFF;		
    1118:	4c 93       	st	X, r20
    111a:	2e 2f       	mov	r18, r30
    111c:	23 1b       	sub	r18, r19
    111e:	11 96       	adiw	r26, 0x01	; 1
    1120:	81 e0       	ldi	r24, 0x01	; 1
    1122:	a0 32       	cpi	r26, 0x20	; 32
    1124:	b8 07       	cpc	r27, r24
    1126:	69 f7       	brne	.-38     	; 0x1102 <LCD_puts+0xa>
	}

	ScrollMode  = ((LoadB > 6)? TRUE : FALSE);
    1128:	10 92 06 01 	sts	0x0106, r1
    112c:	27 30       	cpi	r18, 0x07	; 7
    112e:	18 f0       	brcs	.+6      	; 0x1136 <LCD_puts+0x3e>
    1130:	81 e0       	ldi	r24, 0x01	; 1
    1132:	80 93 06 01 	sts	0x0106, r24
	ScrollCount = 0;
    1136:	10 92 08 01 	sts	0x0108, r1
    113a:	82 2f       	mov	r24, r18
    113c:	90 e0       	ldi	r25, 0x00	; 0
    113e:	3f ef       	ldi	r19, 0xFF	; 255

	for (uint8_t Nulls = 0; Nulls < 7; Nulls++)
		TextBuffer[LoadB++] = 0xFF;
    1140:	e8 2f       	mov	r30, r24
    1142:	ff 27       	eor	r31, r31
    1144:	e4 5f       	subi	r30, 0xF4	; 244
    1146:	fe 4f       	sbci	r31, 0xFE	; 254
    1148:	30 83       	st	Z, r19
    114a:	8f 5f       	subi	r24, 0xFF	; 255
    114c:	9f 5f       	subi	r25, 0xFF	; 255
    114e:	97 30       	cpi	r25, 0x07	; 7
    1150:	b9 f7       	brne	.-18     	; 0x1140 <LCD_puts+0x48>
    1152:	82 2f       	mov	r24, r18
    1154:	89 5f       	subi	r24, 0xF9	; 249
	
	TextBuffer[LoadB] = 0x00;
    1156:	e8 2f       	mov	r30, r24
    1158:	ff 27       	eor	r31, r31
    115a:	e4 5f       	subi	r30, 0xF4	; 244
    115c:	fe 4f       	sbci	r31, 0xFE	; 254
    115e:	10 82       	st	Z, r1
	StrStart   = 0;
    1160:	10 92 0a 01 	sts	0x010A, r1
	StrEnd     = LoadB;	
    1164:	80 93 0b 01 	sts	0x010B, r24
	DelayCount = LCD_DELAYCOUNT_DEFAULT;
    1168:	8a e0       	ldi	r24, 0x0A	; 10
    116a:	80 93 07 01 	sts	0x0107, r24

	UpdateLCD  = TRUE;
    116e:	81 e0       	ldi	r24, 0x01	; 1
    1170:	80 93 09 01 	sts	0x0109, r24
    1174:	08 95       	ret

00001176 <__vector_22>:
}

static inline void LCD_WriteChar(const uint8_t Byte, const uint8_t Digit)
{
	uint16_t SegData  = 0x00;
	uint8_t  *BuffPtr = (&SegBuffer[0] + (Digit >> 1));

	if (Byte != 0xFF)
	  SegData = pgm_read_word(&LCD_SegTable[Byte]);	

	for (uint8_t BNib = 0; BNib < 4; BNib++)
	{
		uint8_t Mask          = 0xF0;
		uint8_t MaskedSegData = (SegData & 0x0000F);
	
		if (Digit & 0x01)
		{
			Mask = 0x0F;
			MaskedSegData <<= 4;
		}
		
		*BuffPtr = ((*BuffPtr & Mask) | MaskedSegData);

		SegData >>= 4;
		BuffPtr  += 5;
	}
}

ISR(LCD_vect, ISR_NOBLOCK)
{
    1176:	78 94       	sei
    1178:	1f 92       	push	r1
    117a:	0f 92       	push	r0
    117c:	0f b6       	in	r0, 0x3f	; 63
    117e:	0f 92       	push	r0
    1180:	11 24       	eor	r1, r1
    1182:	ef 92       	push	r14
    1184:	ff 92       	push	r15
    1186:	0f 93       	push	r16
    1188:	1f 93       	push	r17
    118a:	2f 93       	push	r18
    118c:	3f 93       	push	r19
    118e:	4f 93       	push	r20
    1190:	5f 93       	push	r21
    1192:	6f 93       	push	r22
    1194:	7f 93       	push	r23
    1196:	8f 93       	push	r24
    1198:	9f 93       	push	r25
    119a:	af 93       	push	r26
    119c:	bf 93       	push	r27
    119e:	ef 93       	push	r30
    11a0:	ff 93       	push	r31
	if (ScrollMode)
    11a2:	80 91 06 01 	lds	r24, 0x0106
    11a6:	88 23       	and	r24, r24
    11a8:	99 f0       	breq	.+38     	; 0x11d0 <__vector_22+0x5a>
	{
		if (DelayCount)
    11aa:	80 91 07 01 	lds	r24, 0x0107
    11ae:	88 23       	and	r24, r24
    11b0:	21 f0       	breq	.+8      	; 0x11ba <__vector_22+0x44>
		{
			DelayCount--;
    11b2:	81 50       	subi	r24, 0x01	; 1
    11b4:	80 93 07 01 	sts	0x0107, r24
    11b8:	0b c0       	rjmp	.+22     	; 0x11d0 <__vector_22+0x5a>
		}
		else
		{
			if (!(ScrollCount--))
    11ba:	80 91 08 01 	lds	r24, 0x0108
    11be:	81 50       	subi	r24, 0x01	; 1
    11c0:	80 93 08 01 	sts	0x0108, r24
    11c4:	8f 3f       	cpi	r24, 0xFF	; 255
    11c6:	21 f4       	brne	.+8      	; 0x11d0 <__vector_22+0x5a>
			  UpdateLCD = TRUE;
    11c8:	81 e0       	ldi	r24, 0x01	; 1
    11ca:	80 93 09 01 	sts	0x0109, r24
    11ce:	05 c0       	rjmp	.+10     	; 0x11da <__vector_22+0x64>
		}
	}

	if (UpdateLCD)
    11d0:	80 91 09 01 	lds	r24, 0x0109
    11d4:	88 23       	and	r24, r24
    11d6:	09 f4       	brne	.+2      	; 0x11da <__vector_22+0x64>
    11d8:	55 c0       	rjmp	.+170    	; 0x1284 <__vector_22+0x10e>
	{
		for (uint8_t Character = 0; Character < 6; Character++)
		{
			uint8_t Byte = (StrStart + Character);
    11da:	30 91 0a 01 	lds	r19, 0x010A

			if (Byte >= StrEnd)
    11de:	e0 90 0b 01 	lds	r14, 0x010B
    11e2:	f3 2e       	mov	r15, r19
    11e4:	fe 18       	sub	r15, r14
    11e6:	13 2f       	mov	r17, r19
    11e8:	60 e0       	ldi	r22, 0x00	; 0
    11ea:	70 e0       	ldi	r23, 0x00	; 0
    11ec:	86 2f       	mov	r24, r22
    11ee:	1e 15       	cp	r17, r14
    11f0:	10 f4       	brcc	.+4      	; 0x11f6 <__vector_22+0x80>
    11f2:	e1 2f       	mov	r30, r17
    11f4:	01 c0       	rjmp	.+2      	; 0x11f8 <__vector_22+0x82>
    11f6:	ef 2d       	mov	r30, r15
			  Byte -= StrEnd;
			
			LCD_WriteChar(TextBuffer[Byte], Character);
    11f8:	ff 27       	eor	r31, r31
    11fa:	e4 5f       	subi	r30, 0xF4	; 244
    11fc:	fe 4f       	sbci	r31, 0xFE	; 254
    11fe:	e0 81       	ld	r30, Z
    1200:	ef 3f       	cpi	r30, 0xFF	; 255
    1202:	19 f4       	brne	.+6      	; 0x120a <__vector_22+0x94>
    1204:	40 e0       	ldi	r20, 0x00	; 0
    1206:	50 e0       	ldi	r21, 0x00	; 0
    1208:	07 c0       	rjmp	.+14     	; 0x1218 <__vector_22+0xa2>
    120a:	ff 27       	eor	r31, r31
    120c:	ee 0f       	add	r30, r30
    120e:	ff 1f       	adc	r31, r31
    1210:	e4 5d       	subi	r30, 0xD4	; 212
    1212:	fc 4f       	sbci	r31, 0xFC	; 252
    1214:	45 91       	lpm	r20, Z+
    1216:	54 91       	lpm	r21, Z
    1218:	86 95       	lsr	r24
    121a:	e8 2f       	mov	r30, r24
    121c:	ff 27       	eor	r31, r31
    121e:	e9 5d       	subi	r30, 0xD9	; 217
    1220:	fe 4f       	sbci	r31, 0xFE	; 254
    1222:	00 e0       	ldi	r16, 0x00	; 0
    1224:	db 01       	movw	r26, r22
    1226:	a1 70       	andi	r26, 0x01	; 1
    1228:	b0 70       	andi	r27, 0x00	; 0
    122a:	24 2f       	mov	r18, r20
    122c:	2f 70       	andi	r18, 0x0F	; 15
    122e:	10 97       	sbiw	r26, 0x00	; 0
    1230:	11 f4       	brne	.+4      	; 0x1236 <__vector_22+0xc0>
    1232:	90 ef       	ldi	r25, 0xF0	; 240
    1234:	03 c0       	rjmp	.+6      	; 0x123c <__vector_22+0xc6>
    1236:	22 95       	swap	r18
    1238:	20 7f       	andi	r18, 0xF0	; 240
    123a:	9f e0       	ldi	r25, 0x0F	; 15
    123c:	80 81       	ld	r24, Z
    123e:	98 23       	and	r25, r24
    1240:	92 2b       	or	r25, r18
    1242:	90 83       	st	Z, r25
    1244:	0f 5f       	subi	r16, 0xFF	; 255
    1246:	04 30       	cpi	r16, 0x04	; 4
    1248:	39 f0       	breq	.+14     	; 0x1258 <__vector_22+0xe2>
    124a:	84 e0       	ldi	r24, 0x04	; 4
    124c:	56 95       	lsr	r21
    124e:	47 95       	ror	r20
    1250:	8a 95       	dec	r24
    1252:	e1 f7       	brne	.-8      	; 0x124c <__vector_22+0xd6>
    1254:	35 96       	adiw	r30, 0x05	; 5
    1256:	e9 cf       	rjmp	.-46     	; 0x122a <__vector_22+0xb4>
    1258:	6f 5f       	subi	r22, 0xFF	; 255
    125a:	7f 4f       	sbci	r23, 0xFF	; 255
    125c:	1f 5f       	subi	r17, 0xFF	; 255
    125e:	f3 94       	inc	r15
    1260:	66 30       	cpi	r22, 0x06	; 6
    1262:	71 05       	cpc	r23, r1
    1264:	09 f0       	breq	.+2      	; 0x1268 <__vector_22+0xf2>
    1266:	c2 cf       	rjmp	.-124    	; 0x11ec <__vector_22+0x76>
		}
		
		if (StrStart++ == StrEnd)
    1268:	3f 5f       	subi	r19, 0xFF	; 255
    126a:	30 93 0a 01 	sts	0x010A, r19
    126e:	31 50       	subi	r19, 0x01	; 1
    1270:	3e 15       	cp	r19, r14
    1272:	19 f4       	brne	.+6      	; 0x127a <__vector_22+0x104>
		  StrStart = 1;
    1274:	81 e0       	ldi	r24, 0x01	; 1
    1276:	80 93 0a 01 	sts	0x010A, r24
		
		ScrollCount = LCD_SCROLLCOUNT_DEFAULT;
    127a:	83 e0       	ldi	r24, 0x03	; 3
    127c:	80 93 08 01 	sts	0x0108, r24
		UpdateLCD = FALSE;
    1280:	10 92 09 01 	sts	0x0109, r1
    1284:	a7 e2       	ldi	r26, 0x27	; 39
    1286:	b1 e0       	ldi	r27, 0x01	; 1
    1288:	ec ee       	ldi	r30, 0xEC	; 236
    128a:	f0 e0       	ldi	r31, 0x00	; 0
	}

	for (uint8_t LCDChar = 0; LCDChar < LCD_SEGBUFFER_SIZE; LCDChar++)
	  *(pLCDREG + LCDChar) = SegBuffer[LCDChar];
    128c:	8d 91       	ld	r24, X+
    128e:	81 93       	st	Z+, r24
    1290:	81 e0       	ldi	r24, 0x01	; 1
    1292:	e0 30       	cpi	r30, 0x00	; 0
    1294:	f8 07       	cpc	r31, r24
    1296:	d1 f7       	brne	.-12     	; 0x128c <__vector_22+0x116>
    1298:	ff 91       	pop	r31
    129a:	ef 91       	pop	r30
    129c:	bf 91       	pop	r27
    129e:	af 91       	pop	r26
    12a0:	9f 91       	pop	r25
    12a2:	8f 91       	pop	r24
    12a4:	7f 91       	pop	r23
    12a6:	6f 91       	pop	r22
    12a8:	5f 91       	pop	r21
    12aa:	4f 91       	pop	r20
    12ac:	3f 91       	pop	r19
    12ae:	2f 91       	pop	r18
    12b0:	1f 91       	pop	r17
    12b2:	0f 91       	pop	r16
    12b4:	ff 90       	pop	r15
    12b6:	ef 90       	pop	r14
    12b8:	0f 90       	pop	r0
    12ba:	0f be       	out	0x3f, r0	; 63
    12bc:	0f 90       	pop	r0
    12be:	1f 90       	pop	r1
    12c0:	18 95       	reti

000012c2 <LCD_puts_f>:
    12c2:	0f 93       	push	r16
    12c4:	1f 93       	push	r17
    12c6:	cf 93       	push	r28
    12c8:	df 93       	push	r29
    12ca:	cd b7       	in	r28, 0x3d	; 61
    12cc:	de b7       	in	r29, 0x3e	; 62
    12ce:	64 97       	sbiw	r28, 0x14	; 20
    12d0:	0f b6       	in	r0, 0x3f	; 63
    12d2:	f8 94       	cli
    12d4:	de bf       	out	0x3e, r29	; 62
    12d6:	0f be       	out	0x3f, r0	; 63
    12d8:	cd bf       	out	0x3d, r28	; 61
    12da:	8e 01       	movw	r16, r28
    12dc:	0f 5f       	subi	r16, 0xFF	; 255
    12de:	1f 4f       	sbci	r17, 0xFF	; 255
    12e0:	bc 01       	movw	r22, r24
    12e2:	c8 01       	movw	r24, r16
    12e4:	0e 94 39 1a 	call	0x3472	; 0x3472 <strcpy_P>
    12e8:	c8 01       	movw	r24, r16
    12ea:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <LCD_puts>
    12ee:	64 96       	adiw	r28, 0x14	; 20
    12f0:	0f b6       	in	r0, 0x3f	; 63
    12f2:	f8 94       	cli
    12f4:	de bf       	out	0x3e, r29	; 62
    12f6:	0f be       	out	0x3f, r0	; 63
    12f8:	cd bf       	out	0x3d, r28	; 61
    12fa:	df 91       	pop	r29
    12fc:	cf 91       	pop	r28
    12fe:	1f 91       	pop	r17
    1300:	0f 91       	pop	r16
    1302:	08 95       	ret

00001304 <USART_Tx>:
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_Tx(const char data)
{
    1304:	98 2f       	mov	r25, r24
    while (!(UCSRA & (1 << UDRE)));
    1306:	80 91 c0 00 	lds	r24, 0x00C0
    130a:	85 ff       	sbrs	r24, 5
    130c:	fc cf       	rjmp	.-8      	; 0x1306 <USART_Tx+0x2>
    UDR = data;
    130e:	90 93 c6 00 	sts	0x00C6, r25
    1312:	08 95       	ret

00001314 <USART_Rx>:
}

/*****************************************************************************
*
*   Function name : Usart_Rx
*
*   Returns :       char: byte received
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART
*
*****************************************************************************/
char USART_Rx(void)
{
    1314:	80 91 88 01 	lds	r24, 0x0188
    1318:	88 23       	and	r24, r24
    131a:	21 f4       	brne	.+8      	; 0x1324 <USART_Rx+0x10>
    while (!(BuffElements) && !(PacketTimeOut)) {};
    131c:	80 91 8c 01 	lds	r24, 0x018C
    1320:	88 23       	and	r24, r24
    1322:	c1 f3       	breq	.-16     	; 0x1314 <USART_Rx>
    return BUFF_GetBuffByte();
    1324:	0e 94 df 0b 	call	0x17be	; 0x17be <BUFF_GetBuffByte>
}
    1328:	99 27       	eor	r25, r25
    132a:	08 95       	ret

0000132c <USART_Init>:
    132c:	10 92 c5 00 	sts	0x00C5, r1
    1330:	87 e0       	ldi	r24, 0x07	; 7
    1332:	80 93 c4 00 	sts	0x00C4, r24
    1336:	82 e0       	ldi	r24, 0x02	; 2
    1338:	80 93 c0 00 	sts	0x00C0, r24
    133c:	80 e8       	ldi	r24, 0x80	; 128
    133e:	80 93 c1 00 	sts	0x00C1, r24
    1342:	86 e0       	ldi	r24, 0x06	; 6
    1344:	80 93 c2 00 	sts	0x00C2, r24
    1348:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <BUFF_InitialiseBuffer>
    134c:	08 95       	ret

0000134e <SPI_SPIInit>:

// ======================================================================================

void SPI_SPIInit(void)
{
    134e:	e4 e6       	ldi	r30, 0x64	; 100
    1350:	f0 e0       	ldi	r31, 0x00	; 0
    1352:	80 81       	ld	r24, Z
    1354:	8b 7f       	andi	r24, 0xFB	; 251
    1356:	80 83       	st	Z, r24
	PRR &= ~(1 << PRSPI);              // Enable the SPI system by clearing the power save register SPI disable bit

	// Master, Sample falling edge (setup rising), Fosc/16 speed (7.3MHz/16 = 467KHz)
	SPCR = ((1 << SPE) | (1 << MSTR) | (1 << CPHA) | (1 << CPOL) | (1 << SPR0));
    1358:	8d e5       	ldi	r24, 0x5D	; 93
    135a:	8c bd       	out	0x2c, r24	; 44
    135c:	08 95       	ret

0000135e <SPI_SPITransmit>:
}

uint8_t SPI_SPITransmit(const uint8_t Data)
{
    135e:	8e bd       	out	0x2e, r24	; 46
	SPDR = Data;                       // Loading a byte into the register starts the transmission
	while (!(SPSR & (1 << SPIF)));    // Wait until transmission completed
    1360:	0d b4       	in	r0, 0x2d	; 45
    1362:	07 fe       	sbrs	r0, 7
    1364:	fd cf       	rjmp	.-6      	; 0x1360 <SPI_SPITransmit+0x2>
	return SPDR;
    1366:	8e b5       	in	r24, 0x2e	; 46
}
    1368:	99 27       	eor	r25, r25
    136a:	08 95       	ret

0000136c <SPI_SPITransmitWord>:

uint8_t SPI_SPITransmitWord(const uint16_t Data)
{
    136c:	9c 01       	movw	r18, r24
	SPI_SPITransmit((uint8_t)(Data >> 8));
    136e:	83 2f       	mov	r24, r19
    1370:	99 27       	eor	r25, r25
    1372:	8e bd       	out	0x2e, r24	; 46
    1374:	0d b4       	in	r0, 0x2d	; 45
    1376:	07 fe       	sbrs	r0, 7
    1378:	fd cf       	rjmp	.-6      	; 0x1374 <SPI_SPITransmitWord+0x8>
    137a:	8e b5       	in	r24, 0x2e	; 46
    137c:	2e bd       	out	0x2e, r18	; 46
    137e:	0d b4       	in	r0, 0x2d	; 45
    1380:	07 fe       	sbrs	r0, 7
    1382:	fd cf       	rjmp	.-6      	; 0x137e <SPI_SPITransmitWord+0x12>
    1384:	8e b5       	in	r24, 0x2e	; 46
	return SPI_SPITransmit((uint8_t)Data);
}
    1386:	99 27       	eor	r25, r25
    1388:	08 95       	ret

0000138a <__vector_17>:
 *  have to stop the timer tick.
 *  For all modes the USIDR contents are stored and flags are updated.
 */
ISR(USI_OVERFLOW_vect, ISR_BLOCK)
{
    138a:	1f 92       	push	r1
    138c:	0f 92       	push	r0
    138e:	0f b6       	in	r0, 0x3f	; 63
    1390:	0f 92       	push	r0
    1392:	11 24       	eor	r1, r1
    1394:	8f 93       	push	r24
    1396:	ef 93       	push	r30
    1398:	ff 93       	push	r31
	// Master must now disable the compare match interrupt
	// to prevent more USI counter clocks.
	TIMSK0 &= ~(1<<OCIE0A);
    139a:	ee e6       	ldi	r30, 0x6E	; 110
    139c:	f0 e0       	ldi	r31, 0x00	; 0
    139e:	80 81       	ld	r24, Z
    13a0:	8d 7f       	andi	r24, 0xFD	; 253
    13a2:	80 83       	st	Z, r24
	
	// Update flags and clear USI counter
	USISR = (1<<USIOIF);
    13a4:	80 e4       	ldi	r24, 0x40	; 64
    13a6:	80 93 b9 00 	sts	0x00B9, r24
	TransferComplete = 1;
    13aa:	81 e0       	ldi	r24, 0x01	; 1
    13ac:	80 93 3c 01 	sts	0x013C, r24

	// Copy USIDR to buffer to prevent overwrite on next transfer.
	StoredUSIDR = USIDR;
    13b0:	80 91 ba 00 	lds	r24, 0x00BA
    13b4:	80 93 3b 01 	sts	0x013B, r24
    13b8:	ff 91       	pop	r31
    13ba:	ef 91       	pop	r30
    13bc:	8f 91       	pop	r24
    13be:	0f 90       	pop	r0
    13c0:	0f be       	out	0x3f, r0	; 63
    13c2:	0f 90       	pop	r0
    13c4:	1f 90       	pop	r1
    13c6:	18 95       	reti

000013c8 <USI_SPIOff>:
}

/*! \brief  Initialize USI as SPI master.
 *
 *  This function sets up all pin directions and module configurations.
 *  Use this function initially or when changing from slave to master mode.
 *  Note that the stored USIDR value is cleared.
 *
 */
void USI_SPIInitMaster()
{
	// Configure port directions.
 	USI_DIR_REG |= (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN);  // Outputs.
	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN);                       // Inputs.
	USI_OUT_REG |= (1<<USI_DATAIN_PIN);                        // Pull-ups.
	USI_OUT_REG &= ~(1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN); // Pull-ups.
	
	// Configure USI to 3-wire master mode with overflow interrupt.
	USICR = USI_CONTROL_REG_FLAGS;

	// Set the compare and prescaler for the requested frequency:
	USI_SPISetSpeed();
	
	// Init driver status register.
	TransferComplete = 0;
	
	StoredUSIDR = 0;
}

void USI_SPIOff(void)
{
    13c8:	8d b1       	in	r24, 0x0d	; 13
    13ca:	8f 7a       	andi	r24, 0xAF	; 175
    13cc:	8d b9       	out	0x0d, r24	; 13
	USI_DIR_REG &= ~((1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN));                        // Inputs.
	USI_OUT_REG &= ~((1<<USI_DATAIN_PIN)  | (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN)); // Pull-ups.
    13ce:	8e b1       	in	r24, 0x0e	; 14
    13d0:	8f 78       	andi	r24, 0x8F	; 143
    13d2:	8e b9       	out	0x0e, r24	; 14
	DDRF  &= ~(1 << 6);
    13d4:	86 98       	cbi	0x10, 6	; 16
	PORTF &= ~(1 << 6);
    13d6:	8e 98       	cbi	0x11, 6	; 17
	
	USI_STOPUSITIMER();
    13d8:	14 bc       	out	0x24, r1	; 36
    13da:	08 95       	ret

000013dc <USI_SPITransmit>:
}

/*! \brief  Put one byte on bus.
 *
 *  Use this function like you would write to the SPDR register in the native SPI module.
 *  Calling this function in master mode starts a transfer, while in slave mode, a
 *  byte will be prepared for the next transfer initiated by the master device.
 *  If a transfer is in progress, this function will set the write collision flag
 *  and return without altering the data registers.
 *
 *  \returns  Value returned by slave.
 */
uint8_t USI_SPITransmit(uint8_t val)
{
    13dc:	10 92 3c 01 	sts	0x013C, r1
	// Reinit flags.
	TransferComplete = 0;

	// Put data in USI data register.
	USIDR = val;
    13e0:	80 93 ba 00 	sts	0x00BA, r24
	
	TIFR0  |= (1<<OCF0A);  // Clear compare match flag.
    13e4:	a9 9a       	sbi	0x15, 1	; 21
	TIMSK0 |= (1<<OCIE0A); // Enable compare match interrupt.
    13e6:	80 91 6e 00 	lds	r24, 0x006E
    13ea:	82 60       	ori	r24, 0x02	; 2
    13ec:	80 93 6e 00 	sts	0x006E, r24

	// Clear the timer 0 value
	TCNT0 = 0;
    13f0:	16 bc       	out	0x26, r1	; 38

	while (!(TransferComplete));
    13f2:	80 91 3c 01 	lds	r24, 0x013C
    13f6:	88 23       	and	r24, r24
    13f8:	e1 f3       	breq	.-8      	; 0x13f2 <USI_SPITransmit+0x16>

	return StoredUSIDR;
    13fa:	80 91 3b 01 	lds	r24, 0x013B
}
    13fe:	99 27       	eor	r25, r25
    1400:	08 95       	ret

00001402 <USI_SPITransmitWord>:

uint8_t USI_SPITransmitWord(const uint16_t val )
{
    1402:	0f 93       	push	r16
    1404:	1f 93       	push	r17
    1406:	8c 01       	movw	r16, r24
	USI_SPITransmit((uint8_t)(val >> 8));
    1408:	81 2f       	mov	r24, r17
    140a:	99 27       	eor	r25, r25
    140c:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
	return USI_SPITransmit((uint8_t)val);
    1410:	80 2f       	mov	r24, r16
    1412:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
}
    1416:	99 27       	eor	r25, r25
    1418:	1f 91       	pop	r17
    141a:	0f 91       	pop	r16
    141c:	08 95       	ret

0000141e <USI_SPISetSpeed>:

void USI_SPIToggleClock(void)
{
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);	
}

void USI_SPISetSpeed()
{
    141e:	a2 e0       	ldi	r26, 0x02	; 2
    1420:	b0 e0       	ldi	r27, 0x00	; 0
    1422:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
    1426:	80 2d       	mov	r24, r0
	uint8_t StoredIndex = eeprom_read_byte(&EEPROMVars.SCKDuration);
    1428:	98 2f       	mov	r25, r24

	if (StoredIndex == 0xFF) // Blank EEPROM protection
    142a:	8f 3f       	cpi	r24, 0xFF	; 255
    142c:	09 f4       	brne	.+2      	; 0x1430 <USI_SPISetSpeed+0x12>
    142e:	93 e0       	ldi	r25, 0x03	; 3
    1430:	29 e9       	ldi	r18, 0x99	; 153
    1432:	33 e0       	ldi	r19, 0x03	; 3
    1434:	f9 01       	movw	r30, r18
    1436:	31 97       	sbiw	r30, 0x01	; 1
	  StoredIndex = (USI_PRESET_SPEEDS - 1);

	for (uint8_t MatchIndex = 0; MatchIndex < USI_PRESET_SPEEDS; MatchIndex++)
	{
		if ((pgm_read_byte(&USIPSValues[MatchIndex][0]) == StoredIndex))
    1438:	84 91       	lpm	r24, Z
    143a:	89 17       	cp	r24, r25
    143c:	31 f4       	brne	.+12     	; 0x144a <USI_SPISetSpeed+0x2c>
		{
			// Init Output Compare Register.
			OCR0A = pgm_read_byte(&USIPSValues[MatchIndex][1]);
    143e:	f9 01       	movw	r30, r18
    1440:	84 91       	lpm	r24, Z
    1442:	87 bd       	out	0x27, r24	; 39

			// Enable 'Clear Timer on Compare match' and set prescaler, which starts the timer
			TCCR0A = ((1<<WGM01) | TC0_PS_1);
    1444:	89 e0       	ldi	r24, 0x09	; 9
    1446:	84 bd       	out	0x24, r24	; 36
    1448:	08 95       	ret
    144a:	32 96       	adiw	r30, 0x02	; 2
    144c:	2e 5f       	subi	r18, 0xFE	; 254
    144e:	3f 4f       	sbci	r19, 0xFF	; 255
    1450:	83 e0       	ldi	r24, 0x03	; 3
    1452:	e0 3a       	cpi	r30, 0xA0	; 160
    1454:	f8 07       	cpc	r31, r24
    1456:	81 f7       	brne	.-32     	; 0x1438 <USI_SPISetSpeed+0x1a>
    1458:	08 95       	ret

0000145a <USI_SPIInitMaster>:
    145a:	8d b1       	in	r24, 0x0d	; 13
    145c:	80 65       	ori	r24, 0x50	; 80
    145e:	8d b9       	out	0x0d, r24	; 13
    1460:	6d 98       	cbi	0x0d, 5	; 13
    1462:	75 9a       	sbi	0x0e, 5	; 14
    1464:	76 98       	cbi	0x0e, 6	; 14
    1466:	8a e5       	ldi	r24, 0x5A	; 90
    1468:	80 93 b8 00 	sts	0x00B8, r24
    146c:	0e 94 0f 0a 	call	0x141e	; 0x141e <USI_SPISetSpeed>
    1470:	10 92 3c 01 	sts	0x013C, r1
    1474:	10 92 3b 01 	sts	0x013B, r1
    1478:	08 95       	ret

0000147a <USI_SPIToggleClock>:
    147a:	0f 93       	push	r16
    147c:	1f 93       	push	r17
    147e:	81 e0       	ldi	r24, 0x01	; 1
    1480:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    1484:	08 eb       	ldi	r16, 0xB8	; 184
    1486:	10 e0       	ldi	r17, 0x00	; 0
    1488:	f8 01       	movw	r30, r16
    148a:	80 81       	ld	r24, Z
    148c:	81 60       	ori	r24, 0x01	; 1
    148e:	80 83       	st	Z, r24
    1490:	81 e0       	ldi	r24, 0x01	; 1
    1492:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    1496:	f8 01       	movw	r30, r16
    1498:	80 81       	ld	r24, Z
    149a:	81 60       	ori	r24, 0x01	; 1
    149c:	80 83       	st	Z, r24
    149e:	81 e0       	ldi	r24, 0x01	; 1
    14a0:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    14a4:	1f 91       	pop	r17
    14a6:	0f 91       	pop	r16
    14a8:	08 95       	ret

000014aa <DF_EnableDataflash>:
	DF_WaitWhileBusy();
}

void DF_EnableDataflash(const uint8_t Enabled)
{
    14aa:	90 91 47 01 	lds	r25, 0x0147
	if (Enabled == TRUE)
    14ae:	81 30       	cpi	r24, 0x01	; 1
    14b0:	31 f4       	brne	.+12     	; 0x14be <DF_EnableDataflash+0x14>
	{
		if (DataflashInfo.UseExernalDF == TRUE)
    14b2:	91 30       	cpi	r25, 0x01	; 1
    14b4:	11 f4       	brne	.+4      	; 0x14ba <DF_EnableDataflash+0x10>
		  MAIN_ResetCSLine(MAIN_RESETCS_EXTDFACTIVE);
    14b6:	82 e0       	ldi	r24, 0x02	; 2
    14b8:	05 c0       	rjmp	.+10     	; 0x14c4 <DF_EnableDataflash+0x1a>
		else
		  PORTB &= ~(1 << 0);
    14ba:	28 98       	cbi	0x05, 0	; 5
    14bc:	08 95       	ret
	}
	else
	{
		if (DataflashInfo.UseExernalDF == TRUE)
    14be:	91 30       	cpi	r25, 0x01	; 1
    14c0:	21 f4       	brne	.+8      	; 0x14ca <DF_EnableDataflash+0x20>
		  MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);
    14c2:	81 e0       	ldi	r24, 0x01	; 1
    14c4:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
    14c8:	08 95       	ret
		else
		  PORTB |= (1 << 0);
    14ca:	28 9a       	sbi	0x05, 0	; 5
    14cc:	08 95       	ret

000014ce <DF_ReadBufferByte>:
    14ce:	ef 92       	push	r14
    14d0:	ff 92       	push	r15
    14d2:	0f 93       	push	r16
    14d4:	1f 93       	push	r17
    14d6:	7c 01       	movw	r14, r24
    14d8:	00 91 00 01 	lds	r16, 0x0100
    14dc:	10 91 01 01 	lds	r17, 0x0101
    14e0:	80 e0       	ldi	r24, 0x00	; 0
    14e2:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    14e6:	81 e0       	ldi	r24, 0x01	; 1
    14e8:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    14ec:	84 e5       	ldi	r24, 0x54	; 84
    14ee:	f8 01       	movw	r30, r16
    14f0:	09 95       	icall
    14f2:	8f 2d       	mov	r24, r15
    14f4:	99 27       	eor	r25, r25
    14f6:	f8 01       	movw	r30, r16
    14f8:	09 95       	icall
    14fa:	8e 2d       	mov	r24, r14
    14fc:	f8 01       	movw	r30, r16
    14fe:	09 95       	icall
    1500:	80 e0       	ldi	r24, 0x00	; 0
    1502:	f8 01       	movw	r30, r16
    1504:	09 95       	icall
    1506:	80 e0       	ldi	r24, 0x00	; 0
    1508:	f8 01       	movw	r30, r16
    150a:	09 95       	icall
    150c:	99 27       	eor	r25, r25
    150e:	1f 91       	pop	r17
    1510:	0f 91       	pop	r16
    1512:	ff 90       	pop	r15
    1514:	ef 90       	pop	r14
    1516:	08 95       	ret

00001518 <DF_ContinuousReadEnable>:
    1518:	ef 92       	push	r14
    151a:	ff 92       	push	r15
    151c:	0f 93       	push	r16
    151e:	1f 93       	push	r17
    1520:	cf 93       	push	r28
    1522:	df 93       	push	r29
    1524:	8c 01       	movw	r16, r24
    1526:	7b 01       	movw	r14, r22
    1528:	c0 91 00 01 	lds	r28, 0x0100
    152c:	d0 91 01 01 	lds	r29, 0x0101
    1530:	80 e0       	ldi	r24, 0x00	; 0
    1532:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    1536:	81 e0       	ldi	r24, 0x01	; 1
    1538:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    153c:	88 e6       	ldi	r24, 0x68	; 104
    153e:	fe 01       	movw	r30, r28
    1540:	09 95       	icall
    1542:	8a b5       	in	r24, 0x2a	; 42
    1544:	98 01       	movw	r18, r16
    1546:	02 c0       	rjmp	.+4      	; 0x154c <DF_ContinuousReadEnable+0x34>
    1548:	36 95       	lsr	r19
    154a:	27 95       	ror	r18
    154c:	8a 95       	dec	r24
    154e:	e2 f7       	brpl	.-8      	; 0x1548 <DF_ContinuousReadEnable+0x30>
    1550:	c9 01       	movw	r24, r18
    1552:	fe 01       	movw	r30, r28
    1554:	09 95       	icall
    1556:	8b b5       	in	r24, 0x2b	; 43
    1558:	02 c0       	rjmp	.+4      	; 0x155e <DF_ContinuousReadEnable+0x46>
    155a:	00 0f       	add	r16, r16
    155c:	11 1f       	adc	r17, r17
    155e:	8a 95       	dec	r24
    1560:	e2 f7       	brpl	.-8      	; 0x155a <DF_ContinuousReadEnable+0x42>
    1562:	8f 2d       	mov	r24, r15
    1564:	99 27       	eor	r25, r25
    1566:	80 0f       	add	r24, r16
    1568:	fe 01       	movw	r30, r28
    156a:	09 95       	icall
    156c:	8e 2d       	mov	r24, r14
    156e:	fe 01       	movw	r30, r28
    1570:	09 95       	icall
    1572:	00 e0       	ldi	r16, 0x00	; 0
    1574:	80 e0       	ldi	r24, 0x00	; 0
    1576:	fe 01       	movw	r30, r28
    1578:	09 95       	icall
    157a:	0f 5f       	subi	r16, 0xFF	; 255
    157c:	04 30       	cpi	r16, 0x04	; 4
    157e:	d1 f7       	brne	.-12     	; 0x1574 <DF_ContinuousReadEnable+0x5c>
    1580:	df 91       	pop	r29
    1582:	cf 91       	pop	r28
    1584:	1f 91       	pop	r17
    1586:	0f 91       	pop	r16
    1588:	ff 90       	pop	r15
    158a:	ef 90       	pop	r14
    158c:	08 95       	ret

0000158e <DF_BufferWriteEnable>:
    158e:	ef 92       	push	r14
    1590:	ff 92       	push	r15
    1592:	0f 93       	push	r16
    1594:	1f 93       	push	r17
    1596:	7c 01       	movw	r14, r24
    1598:	00 91 00 01 	lds	r16, 0x0100
    159c:	10 91 01 01 	lds	r17, 0x0101
    15a0:	80 e0       	ldi	r24, 0x00	; 0
    15a2:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    15a6:	81 e0       	ldi	r24, 0x01	; 1
    15a8:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    15ac:	84 e8       	ldi	r24, 0x84	; 132
    15ae:	f8 01       	movw	r30, r16
    15b0:	09 95       	icall
    15b2:	80 e0       	ldi	r24, 0x00	; 0
    15b4:	f8 01       	movw	r30, r16
    15b6:	09 95       	icall
    15b8:	8f 2d       	mov	r24, r15
    15ba:	99 27       	eor	r25, r25
    15bc:	f8 01       	movw	r30, r16
    15be:	09 95       	icall
    15c0:	8e 2d       	mov	r24, r14
    15c2:	f8 01       	movw	r30, r16
    15c4:	09 95       	icall
    15c6:	1f 91       	pop	r17
    15c8:	0f 91       	pop	r16
    15ca:	ff 90       	pop	r15
    15cc:	ef 90       	pop	r14
    15ce:	08 95       	ret

000015d0 <DF_WaitWhileBusy>:
    15d0:	cf 93       	push	r28
    15d2:	df 93       	push	r29
    15d4:	c0 91 00 01 	lds	r28, 0x0100
    15d8:	d0 91 01 01 	lds	r29, 0x0101
    15dc:	80 e0       	ldi	r24, 0x00	; 0
    15de:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    15e2:	81 e0       	ldi	r24, 0x01	; 1
    15e4:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    15e8:	87 e5       	ldi	r24, 0x57	; 87
    15ea:	fe 01       	movw	r30, r28
    15ec:	09 95       	icall
    15ee:	80 e0       	ldi	r24, 0x00	; 0
    15f0:	fe 01       	movw	r30, r28
    15f2:	09 95       	icall
    15f4:	87 ff       	sbrs	r24, 7
    15f6:	fb cf       	rjmp	.-10     	; 0x15ee <DF_WaitWhileBusy+0x1e>
    15f8:	df 91       	pop	r29
    15fa:	cf 91       	pop	r28
    15fc:	08 95       	ret

000015fe <DF_EraseBlock>:
    15fe:	ef 92       	push	r14
    1600:	ff 92       	push	r15
    1602:	0f 93       	push	r16
    1604:	1f 93       	push	r17
    1606:	7c 01       	movw	r14, r24
    1608:	00 91 00 01 	lds	r16, 0x0100
    160c:	10 91 01 01 	lds	r17, 0x0101
    1610:	80 e0       	ldi	r24, 0x00	; 0
    1612:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    1616:	81 e0       	ldi	r24, 0x01	; 1
    1618:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    161c:	80 e5       	ldi	r24, 0x50	; 80
    161e:	f8 01       	movw	r30, r16
    1620:	09 95       	icall
    1622:	8f 2d       	mov	r24, r15
    1624:	99 27       	eor	r25, r25
    1626:	f8 01       	movw	r30, r16
    1628:	09 95       	icall
    162a:	8e 2d       	mov	r24, r14
    162c:	f8 01       	movw	r30, r16
    162e:	09 95       	icall
    1630:	80 e0       	ldi	r24, 0x00	; 0
    1632:	f8 01       	movw	r30, r16
    1634:	09 95       	icall
    1636:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <DF_WaitWhileBusy>
    163a:	1f 91       	pop	r17
    163c:	0f 91       	pop	r16
    163e:	ff 90       	pop	r15
    1640:	ef 90       	pop	r14
    1642:	08 95       	ret

00001644 <DF_CopyFlashPageToBuffer>:
    1644:	ef 92       	push	r14
    1646:	ff 92       	push	r15
    1648:	0f 93       	push	r16
    164a:	1f 93       	push	r17
    164c:	8c 01       	movw	r16, r24
    164e:	e0 90 00 01 	lds	r14, 0x0100
    1652:	f0 90 01 01 	lds	r15, 0x0101
    1656:	80 e0       	ldi	r24, 0x00	; 0
    1658:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    165c:	81 e0       	ldi	r24, 0x01	; 1
    165e:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    1662:	83 e5       	ldi	r24, 0x53	; 83
    1664:	f7 01       	movw	r30, r14
    1666:	09 95       	icall
    1668:	8a b5       	in	r24, 0x2a	; 42
    166a:	98 01       	movw	r18, r16
    166c:	02 c0       	rjmp	.+4      	; 0x1672 <DF_CopyFlashPageToBuffer+0x2e>
    166e:	36 95       	lsr	r19
    1670:	27 95       	ror	r18
    1672:	8a 95       	dec	r24
    1674:	e2 f7       	brpl	.-8      	; 0x166e <DF_CopyFlashPageToBuffer+0x2a>
    1676:	c9 01       	movw	r24, r18
    1678:	f7 01       	movw	r30, r14
    167a:	09 95       	icall
    167c:	8b b5       	in	r24, 0x2b	; 43
    167e:	02 c0       	rjmp	.+4      	; 0x1684 <DF_CopyFlashPageToBuffer+0x40>
    1680:	00 0f       	add	r16, r16
    1682:	11 1f       	adc	r17, r17
    1684:	8a 95       	dec	r24
    1686:	e2 f7       	brpl	.-8      	; 0x1680 <DF_CopyFlashPageToBuffer+0x3c>
    1688:	80 2f       	mov	r24, r16
    168a:	f7 01       	movw	r30, r14
    168c:	09 95       	icall
    168e:	80 e0       	ldi	r24, 0x00	; 0
    1690:	f7 01       	movw	r30, r14
    1692:	09 95       	icall
    1694:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <DF_WaitWhileBusy>
    1698:	1f 91       	pop	r17
    169a:	0f 91       	pop	r16
    169c:	ff 90       	pop	r15
    169e:	ef 90       	pop	r14
    16a0:	08 95       	ret

000016a2 <DF_CopyBufferToFlashPage>:
    16a2:	ef 92       	push	r14
    16a4:	ff 92       	push	r15
    16a6:	0f 93       	push	r16
    16a8:	1f 93       	push	r17
    16aa:	8c 01       	movw	r16, r24
    16ac:	e0 90 00 01 	lds	r14, 0x0100
    16b0:	f0 90 01 01 	lds	r15, 0x0101
    16b4:	80 e0       	ldi	r24, 0x00	; 0
    16b6:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    16ba:	81 e0       	ldi	r24, 0x01	; 1
    16bc:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    16c0:	83 e8       	ldi	r24, 0x83	; 131
    16c2:	f7 01       	movw	r30, r14
    16c4:	09 95       	icall
    16c6:	8a b5       	in	r24, 0x2a	; 42
    16c8:	98 01       	movw	r18, r16
    16ca:	02 c0       	rjmp	.+4      	; 0x16d0 <DF_CopyBufferToFlashPage+0x2e>
    16cc:	36 95       	lsr	r19
    16ce:	27 95       	ror	r18
    16d0:	8a 95       	dec	r24
    16d2:	e2 f7       	brpl	.-8      	; 0x16cc <DF_CopyBufferToFlashPage+0x2a>
    16d4:	c9 01       	movw	r24, r18
    16d6:	f7 01       	movw	r30, r14
    16d8:	09 95       	icall
    16da:	8b b5       	in	r24, 0x2b	; 43
    16dc:	02 c0       	rjmp	.+4      	; 0x16e2 <DF_CopyBufferToFlashPage+0x40>
    16de:	00 0f       	add	r16, r16
    16e0:	11 1f       	adc	r17, r17
    16e2:	8a 95       	dec	r24
    16e4:	e2 f7       	brpl	.-8      	; 0x16de <DF_CopyBufferToFlashPage+0x3c>
    16e6:	80 2f       	mov	r24, r16
    16e8:	f7 01       	movw	r30, r14
    16ea:	09 95       	icall
    16ec:	80 e0       	ldi	r24, 0x00	; 0
    16ee:	f7 01       	movw	r30, r14
    16f0:	09 95       	icall
    16f2:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <DF_WaitWhileBusy>
    16f6:	1f 91       	pop	r17
    16f8:	0f 91       	pop	r16
    16fa:	ff 90       	pop	r15
    16fc:	ef 90       	pop	r14
    16fe:	08 95       	ret

00001700 <DF_GetChipCharacteristics>:
    1700:	0f 93       	push	r16
    1702:	1f 93       	push	r17
    1704:	00 91 00 01 	lds	r16, 0x0100
    1708:	10 91 01 01 	lds	r17, 0x0101
    170c:	80 e0       	ldi	r24, 0x00	; 0
    170e:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    1712:	81 e0       	ldi	r24, 0x01	; 1
    1714:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    1718:	87 e5       	ldi	r24, 0x57	; 87
    171a:	f8 01       	movw	r30, r16
    171c:	09 95       	icall
    171e:	80 e0       	ldi	r24, 0x00	; 0
    1720:	f8 01       	movw	r30, r16
    1722:	09 95       	icall
    1724:	99 27       	eor	r25, r25
    1726:	88 73       	andi	r24, 0x38	; 56
    1728:	90 70       	andi	r25, 0x00	; 0
    172a:	63 e0       	ldi	r22, 0x03	; 3
    172c:	96 95       	lsr	r25
    172e:	87 95       	ror	r24
    1730:	6a 95       	dec	r22
    1732:	e1 f7       	brne	.-8      	; 0x172c <DF_GetChipCharacteristics+0x2c>
    1734:	fc 01       	movw	r30, r24
    1736:	e0 56       	subi	r30, 0x60	; 96
    1738:	fc 4f       	sbci	r31, 0xFC	; 252
    173a:	e4 91       	lpm	r30, Z
    173c:	4e 2f       	mov	r20, r30
    173e:	55 27       	eor	r21, r21
    1740:	50 93 3e 01 	sts	0x013E, r21
    1744:	40 93 3d 01 	sts	0x013D, r20
    1748:	88 0f       	add	r24, r24
    174a:	99 1f       	adc	r25, r25
    174c:	fc 01       	movw	r30, r24
    174e:	e8 55       	subi	r30, 0x58	; 88
    1750:	fc 4f       	sbci	r31, 0xFC	; 252
    1752:	25 91       	lpm	r18, Z+
    1754:	34 91       	lpm	r19, Z
    1756:	30 93 40 01 	sts	0x0140, r19
    175a:	20 93 3f 01 	sts	0x013F, r18
    175e:	88 54       	subi	r24, 0x48	; 72
    1760:	9c 4f       	sbci	r25, 0xFC	; 252
    1762:	fc 01       	movw	r30, r24
    1764:	25 91       	lpm	r18, Z+
    1766:	34 91       	lpm	r19, Z
    1768:	30 93 42 01 	sts	0x0142, r19
    176c:	20 93 41 01 	sts	0x0141, r18
    1770:	80 e1       	ldi	r24, 0x10	; 16
    1772:	84 1b       	sub	r24, r20
    1774:	8a bd       	out	0x2a, r24	; 42
    1776:	48 50       	subi	r20, 0x08	; 8
    1778:	4b bd       	out	0x2b, r20	; 43
    177a:	1f 91       	pop	r17
    177c:	0f 91       	pop	r16
    177e:	08 95       	ret

00001780 <DF_CheckCorrectOnboardChip>:
    1780:	0e 94 80 0b 	call	0x1700	; 0x1700 <DF_GetChipCharacteristics>
    1784:	80 91 41 01 	lds	r24, 0x0141
    1788:	90 91 42 01 	lds	r25, 0x0142
    178c:	80 50       	subi	r24, 0x00	; 0
    178e:	98 40       	sbci	r25, 0x08	; 8
    1790:	19 f4       	brne	.+6      	; 0x1798 <DF_CheckCorrectOnboardChip+0x18>
    1792:	81 e0       	ldi	r24, 0x01	; 1
    1794:	90 e0       	ldi	r25, 0x00	; 0
    1796:	08 95       	ret
    1798:	80 91 64 00 	lds	r24, 0x0064
    179c:	84 60       	ori	r24, 0x04	; 4
    179e:	80 93 64 00 	sts	0x0064, r24
    17a2:	88 ec       	ldi	r24, 0xC8	; 200
    17a4:	93 e0       	ldi	r25, 0x03	; 3
    17a6:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
    17aa:	80 e0       	ldi	r24, 0x00	; 0
    17ac:	90 e0       	ldi	r25, 0x00	; 0
    17ae:	08 95       	ret

000017b0 <BUFF_InitialiseBuffer>:

// ======================================================================================

void BUFF_InitialiseBuffer(void)
{
    17b0:	10 92 89 01 	sts	0x0189, r1
	InPos  = 0;                            // Set up the IN counter to the start of the buffer
	OutPos = 0;                            // Set up the OUT counter to the start of the buffer
    17b4:	10 92 8a 01 	sts	0x018A, r1

	BuffElements = 0;                      // Reset the buffer elements counter
    17b8:	10 92 88 01 	sts	0x0188, r1
    17bc:	08 95       	ret

000017be <BUFF_GetBuffByte>:
}

uint8_t BUFF_GetBuffByte(void)
{
    17be:	80 91 88 01 	lds	r24, 0x0188
    17c2:	88 23       	and	r24, r24
    17c4:	19 f4       	brne	.+6      	; 0x17cc <BUFF_GetBuffByte+0xe>
	if (!(BuffElements))                   // No elements in the buffer
    17c6:	80 e0       	ldi	r24, 0x00	; 0
    17c8:	90 e0       	ldi	r25, 0x00	; 0
    17ca:	08 95       	ret
	  return 0;

	uint8_t RetrievedData = RingBuffer[OutPos++]; // Grab the stored byte into a temp variable
    17cc:	80 91 8a 01 	lds	r24, 0x018A
    17d0:	e8 2f       	mov	r30, r24
    17d2:	ff 27       	eor	r31, r31
    17d4:	e8 5b       	subi	r30, 0xB8	; 184
    17d6:	fe 4f       	sbci	r31, 0xFE	; 254
    17d8:	e0 81       	ld	r30, Z
    17da:	8f 5f       	subi	r24, 0xFF	; 255
    17dc:	80 93 8a 01 	sts	0x018A, r24
	BuffElements--;                        // Decrement the total elements variable
    17e0:	80 91 88 01 	lds	r24, 0x0188
    17e4:	81 50       	subi	r24, 0x01	; 1
    17e6:	80 93 88 01 	sts	0x0188, r24
	
	if (OutPos == BUFF_BUFFLEN)
    17ea:	80 91 8a 01 	lds	r24, 0x018A
    17ee:	80 34       	cpi	r24, 0x40	; 64
    17f0:	11 f4       	brne	.+4      	; 0x17f6 <BUFF_GetBuffByte+0x38>
	  OutPos = 0;                        // Wrap pointer if end of array reached
    17f2:	10 92 8a 01 	sts	0x018A, r1
		
	return RetrievedData;                 // Return the retrieved data
    17f6:	8e 2f       	mov	r24, r30
    17f8:	99 27       	eor	r25, r25
}
    17fa:	08 95       	ret

000017fc <__vector_13>:
    17fc:	1f 92       	push	r1
    17fe:	0f 92       	push	r0
    1800:	0f b6       	in	r0, 0x3f	; 63
    1802:	0f 92       	push	r0
    1804:	11 24       	eor	r1, r1
    1806:	2f 93       	push	r18
    1808:	3f 93       	push	r19
    180a:	4f 93       	push	r20
    180c:	5f 93       	push	r21
    180e:	6f 93       	push	r22
    1810:	7f 93       	push	r23
    1812:	8f 93       	push	r24
    1814:	9f 93       	push	r25
    1816:	af 93       	push	r26
    1818:	bf 93       	push	r27
    181a:	ef 93       	push	r30
    181c:	ff 93       	push	r31
    181e:	80 91 88 01 	lds	r24, 0x0188
    1822:	80 34       	cpi	r24, 0x40	; 64
    1824:	21 f4       	brne	.+8      	; 0x182e <__vector_13+0x32>
    1826:	88 ed       	ldi	r24, 0xD8	; 216
    1828:	93 e0       	ldi	r25, 0x03	; 3
    182a:	0e 94 c7 04 	call	0x98e	; 0x98e <MAIN_CrashProgram>
    182e:	80 91 89 01 	lds	r24, 0x0189
    1832:	e8 2f       	mov	r30, r24
    1834:	ff 27       	eor	r31, r31
    1836:	90 91 c6 00 	lds	r25, 0x00C6
    183a:	e8 5b       	subi	r30, 0xB8	; 184
    183c:	fe 4f       	sbci	r31, 0xFE	; 254
    183e:	90 83       	st	Z, r25
    1840:	8f 5f       	subi	r24, 0xFF	; 255
    1842:	80 93 89 01 	sts	0x0189, r24
    1846:	80 91 88 01 	lds	r24, 0x0188
    184a:	8f 5f       	subi	r24, 0xFF	; 255
    184c:	80 93 88 01 	sts	0x0188, r24
    1850:	80 91 89 01 	lds	r24, 0x0189
    1854:	80 34       	cpi	r24, 0x40	; 64
    1856:	11 f4       	brne	.+4      	; 0x185c <__vector_13+0x60>
    1858:	10 92 89 01 	sts	0x0189, r1
    185c:	ff 91       	pop	r31
    185e:	ef 91       	pop	r30
    1860:	bf 91       	pop	r27
    1862:	af 91       	pop	r26
    1864:	9f 91       	pop	r25
    1866:	8f 91       	pop	r24
    1868:	7f 91       	pop	r23
    186a:	6f 91       	pop	r22
    186c:	5f 91       	pop	r21
    186e:	4f 91       	pop	r20
    1870:	3f 91       	pop	r19
    1872:	2f 91       	pop	r18
    1874:	0f 90       	pop	r0
    1876:	0f be       	out	0x3f, r0	; 63
    1878:	0f 90       	pop	r0
    187a:	1f 90       	pop	r1
    187c:	18 95       	reti

0000187e <TOUT_SetupSleepTimer>:

// ======================================================================================

void TOUT_SetupSleepTimer(void)
{
    187e:	ab e8       	ldi	r26, 0x8B	; 139
    1880:	b0 e0       	ldi	r27, 0x00	; 0
    1882:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
    1886:	80 2d       	mov	r24, r0
	uint8_t NewTicksIndex = eeprom_read_byte(&EEPROMVars.AutoSleepValIndex);
    1888:	48 2f       	mov	r20, r24

	if (NewTicksIndex == 0xFF) // Blank EEPROM protection
    188a:	8f 3f       	cpi	r24, 0xFF	; 255
    188c:	09 f4       	brne	.+2      	; 0x1890 <TOUT_SetupSleepTimer+0x12>
    188e:	44 e0       	ldi	r20, 0x04	; 4
	  NewTicksIndex = 4;

	TIMSK1 = (1 << TOIE1);
    1890:	51 e0       	ldi	r21, 0x01	; 1
    1892:	50 93 6f 00 	sts	0x006F, r21
	TicksBeforeAutoSleep = ((pgm_read_byte(&AutoSleepTOValues[NewTicksIndex]) << 1) * 5); // ((x << 1) * 5) == (x * 10)
    1896:	e4 2f       	mov	r30, r20
    1898:	ff 27       	eor	r31, r31
    189a:	ef 51       	subi	r30, 0x1F	; 31
    189c:	fc 4f       	sbci	r31, 0xFC	; 252
    189e:	e4 91       	lpm	r30, Z
    18a0:	8e 2f       	mov	r24, r30
    18a2:	99 27       	eor	r25, r25
    18a4:	9c 01       	movw	r18, r24
    18a6:	73 e0       	ldi	r23, 0x03	; 3
    18a8:	22 0f       	add	r18, r18
    18aa:	33 1f       	adc	r19, r19
    18ac:	7a 95       	dec	r23
    18ae:	e1 f7       	brne	.-8      	; 0x18a8 <TOUT_SetupSleepTimer+0x2a>
    18b0:	88 0f       	add	r24, r24
    18b2:	99 1f       	adc	r25, r25
    18b4:	28 0f       	add	r18, r24
    18b6:	39 1f       	adc	r19, r25
    18b8:	30 93 90 01 	sts	0x0190, r19
    18bc:	20 93 8f 01 	sts	0x018F, r18

	TIMEOUT_SLEEP_TIMEOUT_RESET();
    18c0:	10 92 8e 01 	sts	0x018E, r1
    18c4:	10 92 8d 01 	sts	0x018D, r1
    18c8:	10 92 85 00 	sts	0x0085, r1
    18cc:	10 92 84 00 	sts	0x0084, r1
	
	if (NewTicksIndex)
    18d0:	44 23       	and	r20, r20
    18d2:	19 f0       	breq	.+6      	; 0x18da <TOUT_SetupSleepTimer+0x5c>
	  TIMEOUT_SLEEP_TIMER_ON();
    18d4:	50 93 81 00 	sts	0x0081, r21
    18d8:	08 95       	ret
	else
	  TIMEOUT_SLEEP_TIMER_OFF();
    18da:	10 92 81 00 	sts	0x0081, r1
    18de:	08 95       	ret

000018e0 <__vector_9>:
    18e0:	78 94       	sei
    18e2:	1f 92       	push	r1
    18e4:	0f 92       	push	r0
    18e6:	0f b6       	in	r0, 0x3f	; 63
    18e8:	0f 92       	push	r0
    18ea:	11 24       	eor	r1, r1
    18ec:	2f 93       	push	r18
    18ee:	3f 93       	push	r19
    18f0:	4f 93       	push	r20
    18f2:	5f 93       	push	r21
    18f4:	6f 93       	push	r22
    18f6:	7f 93       	push	r23
    18f8:	8f 93       	push	r24
    18fa:	9f 93       	push	r25
    18fc:	af 93       	push	r26
    18fe:	bf 93       	push	r27
    1900:	ef 93       	push	r30
    1902:	ff 93       	push	r31
    1904:	80 91 8d 01 	lds	r24, 0x018D
    1908:	90 91 8e 01 	lds	r25, 0x018E
    190c:	20 91 8f 01 	lds	r18, 0x018F
    1910:	30 91 90 01 	lds	r19, 0x0190
    1914:	01 96       	adiw	r24, 0x01	; 1
    1916:	90 93 8e 01 	sts	0x018E, r25
    191a:	80 93 8d 01 	sts	0x018D, r24
    191e:	01 97       	sbiw	r24, 0x01	; 1
    1920:	82 17       	cp	r24, r18
    1922:	93 07       	cpc	r25, r19
    1924:	31 f4       	brne	.+12     	; 0x1932 <__vector_9+0x52>
    1926:	10 92 81 00 	sts	0x0081, r1
    192a:	0e 94 da 02 	call	0x5b4	; 0x5b4 <FUNCSleepMode>
    192e:	0e 94 3f 0c 	call	0x187e	; 0x187e <TOUT_SetupSleepTimer>
    1932:	ff 91       	pop	r31
    1934:	ef 91       	pop	r30
    1936:	bf 91       	pop	r27
    1938:	af 91       	pop	r26
    193a:	9f 91       	pop	r25
    193c:	8f 91       	pop	r24
    193e:	7f 91       	pop	r23
    1940:	6f 91       	pop	r22
    1942:	5f 91       	pop	r21
    1944:	4f 91       	pop	r20
    1946:	3f 91       	pop	r19
    1948:	2f 91       	pop	r18
    194a:	0f 90       	pop	r0
    194c:	0f be       	out	0x3f, r0	; 63
    194e:	0f 90       	pop	r0
    1950:	1f 90       	pop	r1
    1952:	18 95       	reti

00001954 <__vector_4>:
    1954:	78 94       	sei
    1956:	1f 92       	push	r1
    1958:	0f 92       	push	r0
    195a:	0f b6       	in	r0, 0x3f	; 63
    195c:	0f 92       	push	r0
    195e:	11 24       	eor	r1, r1
    1960:	2f 93       	push	r18
    1962:	3f 93       	push	r19
    1964:	4f 93       	push	r20
    1966:	5f 93       	push	r21
    1968:	6f 93       	push	r22
    196a:	7f 93       	push	r23
    196c:	8f 93       	push	r24
    196e:	9f 93       	push	r25
    1970:	af 93       	push	r26
    1972:	bf 93       	push	r27
    1974:	ef 93       	push	r30
    1976:	ff 93       	push	r31
    1978:	80 91 8b 01 	lds	r24, 0x018B
    197c:	8f 5f       	subi	r24, 0xFF	; 255
    197e:	80 93 8b 01 	sts	0x018B, r24
    1982:	80 91 8b 01 	lds	r24, 0x018B
    1986:	87 39       	cpi	r24, 0x97	; 151
    1988:	29 f4       	brne	.+10     	; 0x1994 <__vector_4+0x40>
    198a:	10 92 8b 01 	sts	0x018B, r1
    198e:	81 e0       	ldi	r24, 0x01	; 1
    1990:	80 93 8c 01 	sts	0x018C, r24
    1994:	80 91 c0 00 	lds	r24, 0x00C0
    1998:	83 ff       	sbrs	r24, 3
    199a:	03 c0       	rjmp	.+6      	; 0x19a2 <__vector_4+0x4e>
    199c:	80 ef       	ldi	r24, 0xF0	; 240
    199e:	93 e0       	ldi	r25, 0x03	; 3
    19a0:	06 c0       	rjmp	.+12     	; 0x19ae <__vector_4+0x5a>
    19a2:	80 91 c0 00 	lds	r24, 0x00C0
    19a6:	84 ff       	sbrs	r24, 4
    19a8:	04 c0       	rjmp	.+8      	; 0x19b2 <__vector_4+0x5e>
    19aa:	86 ee       	ldi	r24, 0xE6	; 230
    19ac:	93 e0       	ldi	r25, 0x03	; 3
    19ae:	0e 94 c7 04 	call	0x98e	; 0x98e <MAIN_CrashProgram>
    19b2:	ff 91       	pop	r31
    19b4:	ef 91       	pop	r30
    19b6:	bf 91       	pop	r27
    19b8:	af 91       	pop	r26
    19ba:	9f 91       	pop	r25
    19bc:	8f 91       	pop	r24
    19be:	7f 91       	pop	r23
    19c0:	6f 91       	pop	r22
    19c2:	5f 91       	pop	r21
    19c4:	4f 91       	pop	r20
    19c6:	3f 91       	pop	r19
    19c8:	2f 91       	pop	r18
    19ca:	0f 90       	pop	r0
    19cc:	0f be       	out	0x3f, r0	; 63
    19ce:	0f 90       	pop	r0
    19d0:	1f 90       	pop	r1
    19d2:	18 95       	reti

000019d4 <PD_SetupDFAddressCounters>:
	}
}

void PD_SetupDFAddressCounters(void)
{
    19d4:	ef 92       	push	r14
    19d6:	ff 92       	push	r15
    19d8:	0f 93       	push	r16
    19da:	1f 93       	push	r17
	uint32_t StartAddress = CurrAddress;
    19dc:	20 91 a9 02 	lds	r18, 0x02A9
    19e0:	30 91 aa 02 	lds	r19, 0x02AA
    19e4:	40 91 ab 02 	lds	r20, 0x02AB
    19e8:	50 91 ac 02 	lds	r21, 0x02AC

	DataflashInfo.CurrPageAddress = 0;
    19ec:	10 92 44 01 	sts	0x0144, r1
    19f0:	10 92 43 01 	sts	0x0143, r1

	while (StartAddress > DataflashInfo.PageSize)      // This loop is the equivalent of a DIV and a MOD
    19f4:	80 91 3f 01 	lds	r24, 0x013F
    19f8:	90 91 40 01 	lds	r25, 0x0140
    19fc:	aa 27       	eor	r26, r26
    19fe:	bb 27       	eor	r27, r27
    1a00:	60 e0       	ldi	r22, 0x00	; 0
    1a02:	70 e0       	ldi	r23, 0x00	; 0
    1a04:	ee 24       	eor	r14, r14
    1a06:	ff 24       	eor	r15, r15
    1a08:	87 01       	movw	r16, r14
    1a0a:	e8 1a       	sub	r14, r24
    1a0c:	f9 0a       	sbc	r15, r25
    1a0e:	0a 0b       	sbc	r16, r26
    1a10:	1b 0b       	sbc	r17, r27
    1a12:	06 c0       	rjmp	.+12     	; 0x1a20 <PD_SetupDFAddressCounters+0x4c>
    1a14:	2e 0d       	add	r18, r14
    1a16:	3f 1d       	adc	r19, r15
    1a18:	40 1f       	adc	r20, r16
    1a1a:	51 1f       	adc	r21, r17
    1a1c:	6f 5f       	subi	r22, 0xFF	; 255
    1a1e:	7f 4f       	sbci	r23, 0xFF	; 255
    1a20:	82 17       	cp	r24, r18
    1a22:	93 07       	cpc	r25, r19
    1a24:	a4 07       	cpc	r26, r20
    1a26:	b5 07       	cpc	r27, r21
    1a28:	a8 f3       	brcs	.-22     	; 0x1a14 <PD_SetupDFAddressCounters+0x40>
    1a2a:	70 93 44 01 	sts	0x0144, r23
    1a2e:	60 93 43 01 	sts	0x0143, r22
	{
		StartAddress -= DataflashInfo.PageSize;         // Subtract one page's worth of bytes from the desired address
		DataflashInfo.CurrPageAddress++;
	}
	
	DataflashInfo.CurrBuffByte = (uint16_t)StartAddress; // The buffer byte is the remainder
    1a32:	30 93 46 01 	sts	0x0146, r19
    1a36:	20 93 45 01 	sts	0x0145, r18
    1a3a:	1f 91       	pop	r17
    1a3c:	0f 91       	pop	r16
    1a3e:	ff 90       	pop	r15
    1a40:	ef 90       	pop	r14
    1a42:	08 95       	ret

00001a44 <PD_StoreDataflashByte>:
}

void PD_StoreDataflashByte(const uint8_t Data)
{
    1a44:	1f 93       	push	r17
    1a46:	18 2f       	mov	r17, r24
	if (DataflashInfo.CurrBuffByte == DataflashInfo.PageSize)
    1a48:	20 91 45 01 	lds	r18, 0x0145
    1a4c:	30 91 46 01 	lds	r19, 0x0146
    1a50:	80 91 3f 01 	lds	r24, 0x013F
    1a54:	90 91 40 01 	lds	r25, 0x0140
    1a58:	28 17       	cp	r18, r24
    1a5a:	39 07       	cpc	r19, r25
    1a5c:	a1 f4       	brne	.+40     	; 0x1a86 <PD_StoreDataflashByte+0x42>
	{
		DF_CopyBufferToFlashPage(DataflashInfo.CurrPageAddress++);
    1a5e:	80 91 43 01 	lds	r24, 0x0143
    1a62:	90 91 44 01 	lds	r25, 0x0144
    1a66:	01 96       	adiw	r24, 0x01	; 1
    1a68:	90 93 44 01 	sts	0x0144, r25
    1a6c:	80 93 43 01 	sts	0x0143, r24
    1a70:	01 97       	sbiw	r24, 0x01	; 1
    1a72:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    1a76:	80 e0       	ldi	r24, 0x00	; 0
    1a78:	90 e0       	ldi	r25, 0x00	; 0
    1a7a:	0e 94 c7 0a 	call	0x158e	; 0x158e <DF_BufferWriteEnable>
		DataflashInfo.CurrBuffByte = 0;
    1a7e:	10 92 46 01 	sts	0x0146, r1
    1a82:	10 92 45 01 	sts	0x0145, r1
	}
	
	USI_SPITransmit(Data);                                 // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    1a86:	81 2f       	mov	r24, r17
    1a88:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
	DataflashInfo.CurrBuffByte++;
    1a8c:	80 91 45 01 	lds	r24, 0x0145
    1a90:	90 91 46 01 	lds	r25, 0x0146
    1a94:	01 96       	adiw	r24, 0x01	; 1
    1a96:	90 93 46 01 	sts	0x0146, r25
    1a9a:	80 93 45 01 	sts	0x0145, r24
    1a9e:	1f 91       	pop	r17
    1aa0:	08 95       	ret

00001aa2 <PD_InterpretAVRISPPacket>:
    1aa2:	0f 93       	push	r16
    1aa4:	1f 93       	push	r17
    1aa6:	cf 93       	push	r28
    1aa8:	df 93       	push	r29
    1aaa:	80 91 91 01 	lds	r24, 0x0191
    1aae:	86 31       	cpi	r24, 0x16	; 22
    1ab0:	09 f4       	brne	.+2      	; 0x1ab4 <PD_InterpretAVRISPPacket+0x12>
    1ab2:	f1 c0       	rjmp	.+482    	; 0x1c96 <PD_InterpretAVRISPPacket+0x1f4>
    1ab4:	87 31       	cpi	r24, 0x17	; 23
    1ab6:	90 f4       	brcc	.+36     	; 0x1adc <PD_InterpretAVRISPPacket+0x3a>
    1ab8:	82 31       	cpi	r24, 0x12	; 18
    1aba:	09 f4       	brne	.+2      	; 0x1abe <PD_InterpretAVRISPPacket+0x1c>
    1abc:	65 c0       	rjmp	.+202    	; 0x1b88 <PD_InterpretAVRISPPacket+0xe6>
    1abe:	83 31       	cpi	r24, 0x13	; 19
    1ac0:	30 f4       	brcc	.+12     	; 0x1ace <PD_InterpretAVRISPPacket+0x2c>
    1ac2:	80 31       	cpi	r24, 0x10	; 16
    1ac4:	01 f1       	breq	.+64     	; 0x1b06 <PD_InterpretAVRISPPacket+0x64>
    1ac6:	81 31       	cpi	r24, 0x11	; 17
    1ac8:	09 f0       	breq	.+2      	; 0x1acc <PD_InterpretAVRISPPacket+0x2a>
    1aca:	2f c1       	rjmp	.+606    	; 0x1d2a <PD_InterpretAVRISPPacket+0x288>
    1acc:	41 c0       	rjmp	.+130    	; 0x1b50 <PD_InterpretAVRISPPacket+0xae>
    1ace:	84 31       	cpi	r24, 0x14	; 20
    1ad0:	09 f4       	brne	.+2      	; 0x1ad4 <PD_InterpretAVRISPPacket+0x32>
    1ad2:	8b c0       	rjmp	.+278    	; 0x1bea <PD_InterpretAVRISPPacket+0x148>
    1ad4:	85 31       	cpi	r24, 0x15	; 21
    1ad6:	08 f0       	brcs	.+2      	; 0x1ada <PD_InterpretAVRISPPacket+0x38>
    1ad8:	ab c0       	rjmp	.+342    	; 0x1c30 <PD_InterpretAVRISPPacket+0x18e>
    1ada:	80 c0       	rjmp	.+256    	; 0x1bdc <PD_InterpretAVRISPPacket+0x13a>
    1adc:	89 31       	cpi	r24, 0x19	; 25
    1ade:	09 f4       	brne	.+2      	; 0x1ae2 <PD_InterpretAVRISPPacket+0x40>
    1ae0:	72 c0       	rjmp	.+228    	; 0x1bc6 <PD_InterpretAVRISPPacket+0x124>
    1ae2:	8a 31       	cpi	r24, 0x1A	; 26
    1ae4:	38 f4       	brcc	.+14     	; 0x1af4 <PD_InterpretAVRISPPacket+0x52>
    1ae6:	87 31       	cpi	r24, 0x17	; 23
    1ae8:	09 f4       	brne	.+2      	; 0x1aec <PD_InterpretAVRISPPacket+0x4a>
    1aea:	6d c0       	rjmp	.+218    	; 0x1bc6 <PD_InterpretAVRISPPacket+0x124>
    1aec:	88 31       	cpi	r24, 0x18	; 24
    1aee:	09 f0       	breq	.+2      	; 0x1af2 <PD_InterpretAVRISPPacket+0x50>
    1af0:	1c c1       	rjmp	.+568    	; 0x1d2a <PD_InterpretAVRISPPacket+0x288>
    1af2:	5b c0       	rjmp	.+182    	; 0x1baa <PD_InterpretAVRISPPacket+0x108>
    1af4:	8b 31       	cpi	r24, 0x1B	; 27
    1af6:	f1 f1       	breq	.+124    	; 0x1b74 <PD_InterpretAVRISPPacket+0xd2>
    1af8:	8b 31       	cpi	r24, 0x1B	; 27
    1afa:	08 f4       	brcc	.+2      	; 0x1afe <PD_InterpretAVRISPPacket+0x5c>
    1afc:	56 c0       	rjmp	.+172    	; 0x1baa <PD_InterpretAVRISPPacket+0x108>
    1afe:	8c 31       	cpi	r24, 0x1C	; 28
    1b00:	09 f0       	breq	.+2      	; 0x1b04 <PD_InterpretAVRISPPacket+0x62>
    1b02:	13 c1       	rjmp	.+550    	; 0x1d2a <PD_InterpretAVRISPPacket+0x288>
    1b04:	52 c0       	rjmp	.+164    	; 0x1baa <PD_InterpretAVRISPPacket+0x108>
    1b06:	82 e0       	ldi	r24, 0x02	; 2
    1b08:	90 e0       	ldi	r25, 0x00	; 0
    1b0a:	90 93 a7 02 	sts	0x02A7, r25
    1b0e:	80 93 a6 02 	sts	0x02A6, r24
    1b12:	81 e0       	ldi	r24, 0x01	; 1
    1b14:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    1b18:	0e 94 80 0b 	call	0x1700	; 0x1700 <DF_GetChipCharacteristics>
    1b1c:	80 91 3d 01 	lds	r24, 0x013D
    1b20:	90 91 3e 01 	lds	r25, 0x013E
    1b24:	89 2b       	or	r24, r25
    1b26:	59 f0       	breq	.+22     	; 0x1b3e <PD_InterpretAVRISPPacket+0x9c>
    1b28:	89 ef       	ldi	r24, 0xF9	; 249
    1b2a:	93 e0       	ldi	r25, 0x03	; 3
    1b2c:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
    1b30:	81 e0       	ldi	r24, 0x01	; 1
    1b32:	80 93 a8 02 	sts	0x02A8, r24
    1b36:	81 b3       	in	r24, 0x11	; 17
    1b38:	8f 7c       	andi	r24, 0xCF	; 207
    1b3a:	80 62       	ori	r24, 0x20	; 32
    1b3c:	17 c0       	rjmp	.+46     	; 0x1b6c <PD_InterpretAVRISPPacket+0xca>
    1b3e:	88 ec       	ldi	r24, 0xC8	; 200
    1b40:	93 e0       	ldi	r25, 0x03	; 3
    1b42:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
    1b46:	80 e0       	ldi	r24, 0x00	; 0
    1b48:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    1b4c:	80 ec       	ldi	r24, 0xC0	; 192
    1b4e:	f4 c0       	rjmp	.+488    	; 0x1d38 <PD_InterpretAVRISPPacket+0x296>
    1b50:	82 e0       	ldi	r24, 0x02	; 2
    1b52:	90 e0       	ldi	r25, 0x00	; 0
    1b54:	90 93 a7 02 	sts	0x02A7, r25
    1b58:	80 93 a6 02 	sts	0x02A6, r24
    1b5c:	10 92 a8 02 	sts	0x02A8, r1
    1b60:	80 e0       	ldi	r24, 0x00	; 0
    1b62:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    1b66:	81 b3       	in	r24, 0x11	; 17
    1b68:	8f 7c       	andi	r24, 0xCF	; 207
    1b6a:	80 61       	ori	r24, 0x10	; 16
    1b6c:	81 bb       	out	0x11, r24	; 17
    1b6e:	10 92 92 01 	sts	0x0192, r1
    1b72:	e4 c0       	rjmp	.+456    	; 0x1d3c <PD_InterpretAVRISPPacket+0x29a>
    1b74:	84 e0       	ldi	r24, 0x04	; 4
    1b76:	90 e0       	ldi	r25, 0x00	; 0
    1b78:	90 93 a7 02 	sts	0x02A7, r25
    1b7c:	80 93 a6 02 	sts	0x02A6, r24
    1b80:	10 92 92 01 	sts	0x0192, r1
    1b84:	82 e0       	ldi	r24, 0x02	; 2
    1b86:	1a c0       	rjmp	.+52     	; 0x1bbc <PD_InterpretAVRISPPacket+0x11a>
    1b88:	82 e0       	ldi	r24, 0x02	; 2
    1b8a:	90 e0       	ldi	r25, 0x00	; 0
    1b8c:	90 93 a7 02 	sts	0x02A7, r25
    1b90:	80 93 a6 02 	sts	0x02A6, r24
    1b94:	10 92 92 01 	sts	0x0192, r1
    1b98:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <V2P_SendPacket>
    1b9c:	87 ea       	ldi	r24, 0xA7	; 167
    1b9e:	90 e0       	ldi	r25, 0x00	; 0
    1ba0:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
    1ba4:	c0 e0       	ldi	r28, 0x00	; 0
    1ba6:	d0 e0       	ldi	r29, 0x00	; 0
    1ba8:	d0 c0       	rjmp	.+416    	; 0x1d4a <PD_InterpretAVRISPPacket+0x2a8>
    1baa:	84 e0       	ldi	r24, 0x04	; 4
    1bac:	90 e0       	ldi	r25, 0x00	; 0
    1bae:	90 93 a7 02 	sts	0x02A7, r25
    1bb2:	80 93 a6 02 	sts	0x02A6, r24
    1bb6:	10 92 92 01 	sts	0x0192, r1
    1bba:	8f ef       	ldi	r24, 0xFF	; 255
    1bbc:	80 93 93 01 	sts	0x0193, r24
    1bc0:	10 92 94 01 	sts	0x0194, r1
    1bc4:	bb c0       	rjmp	.+374    	; 0x1d3c <PD_InterpretAVRISPPacket+0x29a>
    1bc6:	83 e0       	ldi	r24, 0x03	; 3
    1bc8:	90 e0       	ldi	r25, 0x00	; 0
    1bca:	90 93 a7 02 	sts	0x02A7, r25
    1bce:	80 93 a6 02 	sts	0x02A6, r24
    1bd2:	10 92 92 01 	sts	0x0192, r1
    1bd6:	10 92 93 01 	sts	0x0193, r1
    1bda:	b0 c0       	rjmp	.+352    	; 0x1d3c <PD_InterpretAVRISPPacket+0x29a>
    1bdc:	82 e0       	ldi	r24, 0x02	; 2
    1bde:	90 e0       	ldi	r25, 0x00	; 0
    1be0:	90 93 a7 02 	sts	0x02A7, r25
    1be4:	80 93 a6 02 	sts	0x02A6, r24
    1be8:	c2 cf       	rjmp	.-124    	; 0x1b6e <PD_InterpretAVRISPPacket+0xcc>
    1bea:	20 91 92 01 	lds	r18, 0x0192
    1bee:	33 27       	eor	r19, r19
    1bf0:	32 2f       	mov	r19, r18
    1bf2:	22 27       	eor	r18, r18
    1bf4:	80 91 93 01 	lds	r24, 0x0193
    1bf8:	99 27       	eor	r25, r25
    1bfa:	28 2b       	or	r18, r24
    1bfc:	39 2b       	or	r19, r25
    1bfe:	f9 01       	movw	r30, r18
    1c00:	33 96       	adiw	r30, 0x03	; 3
    1c02:	f0 93 a7 02 	sts	0x02A7, r31
    1c06:	e0 93 a6 02 	sts	0x02A6, r30
    1c0a:	81 e0       	ldi	r24, 0x01	; 1
    1c0c:	90 e0       	ldi	r25, 0x00	; 0
    1c0e:	a2 e9       	ldi	r26, 0x92	; 146
    1c10:	b1 e0       	ldi	r27, 0x01	; 1
    1c12:	2f 5f       	subi	r18, 0xFF	; 255
    1c14:	3f 4f       	sbci	r19, 0xFF	; 255
    1c16:	4f ef       	ldi	r20, 0xFF	; 255
    1c18:	02 c0       	rjmp	.+4      	; 0x1c1e <PD_InterpretAVRISPPacket+0x17c>
    1c1a:	4d 93       	st	X+, r20
    1c1c:	01 96       	adiw	r24, 0x01	; 1
    1c1e:	82 17       	cp	r24, r18
    1c20:	93 07       	cpc	r25, r19
    1c22:	d8 f3       	brcs	.-10     	; 0x1c1a <PD_InterpretAVRISPPacket+0x178>
    1c24:	10 92 92 01 	sts	0x0192, r1
    1c28:	e0 57       	subi	r30, 0x70	; 112
    1c2a:	fe 4f       	sbci	r31, 0xFE	; 254
    1c2c:	10 82       	st	Z, r1
    1c2e:	86 c0       	rjmp	.+268    	; 0x1d3c <PD_InterpretAVRISPPacket+0x29a>
    1c30:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <PD_SetupDFAddressCounters>
    1c34:	80 91 43 01 	lds	r24, 0x0143
    1c38:	90 91 44 01 	lds	r25, 0x0144
    1c3c:	0e 94 22 0b 	call	0x1644	; 0x1644 <DF_CopyFlashPageToBuffer>
    1c40:	80 91 45 01 	lds	r24, 0x0145
    1c44:	90 91 46 01 	lds	r25, 0x0146
    1c48:	0e 94 c7 0a 	call	0x158e	; 0x158e <DF_BufferWriteEnable>
    1c4c:	80 91 92 01 	lds	r24, 0x0192
    1c50:	99 27       	eor	r25, r25
    1c52:	d8 2f       	mov	r29, r24
    1c54:	cc 27       	eor	r28, r28
    1c56:	80 91 93 01 	lds	r24, 0x0193
    1c5a:	99 27       	eor	r25, r25
    1c5c:	c8 2b       	or	r28, r24
    1c5e:	d9 2b       	or	r29, r25
    1c60:	01 e9       	ldi	r16, 0x91	; 145
    1c62:	11 e0       	ldi	r17, 0x01	; 1
    1c64:	11 c0       	rjmp	.+34     	; 0x1c88 <PD_InterpretAVRISPPacket+0x1e6>
    1c66:	f8 01       	movw	r30, r16
    1c68:	82 85       	ldd	r24, Z+10	; 0x0a
    1c6a:	0e 94 22 0d 	call	0x1a44	; 0x1a44 <PD_StoreDataflashByte>
    1c6e:	80 91 45 01 	lds	r24, 0x0145
    1c72:	90 91 46 01 	lds	r25, 0x0146
    1c76:	01 96       	adiw	r24, 0x01	; 1
    1c78:	90 93 46 01 	sts	0x0146, r25
    1c7c:	80 93 45 01 	sts	0x0145, r24
    1c80:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <V2P_IncrementCurrAddress>
    1c84:	0f 5f       	subi	r16, 0xFF	; 255
    1c86:	1f 4f       	sbci	r17, 0xFF	; 255
    1c88:	ce 01       	movw	r24, r28
    1c8a:	8f 56       	subi	r24, 0x6F	; 111
    1c8c:	9e 4f       	sbci	r25, 0xFE	; 254
    1c8e:	08 17       	cp	r16, r24
    1c90:	19 07       	cpc	r17, r25
    1c92:	49 f7       	brne	.-46     	; 0x1c66 <PD_InterpretAVRISPPacket+0x1c4>
    1c94:	6c cf       	rjmp	.-296    	; 0x1b6e <PD_InterpretAVRISPPacket+0xcc>
    1c96:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <PD_SetupDFAddressCounters>
    1c9a:	80 91 43 01 	lds	r24, 0x0143
    1c9e:	90 91 44 01 	lds	r25, 0x0144
    1ca2:	0e 94 22 0b 	call	0x1644	; 0x1644 <DF_CopyFlashPageToBuffer>
    1ca6:	80 91 92 01 	lds	r24, 0x0192
    1caa:	99 27       	eor	r25, r25
    1cac:	d8 2f       	mov	r29, r24
    1cae:	cc 27       	eor	r28, r28
    1cb0:	80 91 93 01 	lds	r24, 0x0193
    1cb4:	99 27       	eor	r25, r25
    1cb6:	c8 2b       	or	r28, r24
    1cb8:	d9 2b       	or	r29, r25
    1cba:	01 e9       	ldi	r16, 0x91	; 145
    1cbc:	11 e0       	ldi	r17, 0x01	; 1
    1cbe:	25 c0       	rjmp	.+74     	; 0x1d0a <PD_InterpretAVRISPPacket+0x268>
    1cc0:	20 91 45 01 	lds	r18, 0x0145
    1cc4:	30 91 46 01 	lds	r19, 0x0146
    1cc8:	80 91 3f 01 	lds	r24, 0x013F
    1ccc:	90 91 40 01 	lds	r25, 0x0140
    1cd0:	28 17       	cp	r18, r24
    1cd2:	39 07       	cpc	r19, r25
    1cd4:	41 f4       	brne	.+16     	; 0x1ce6 <PD_InterpretAVRISPPacket+0x244>
    1cd6:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <PD_SetupDFAddressCounters>
    1cda:	80 91 43 01 	lds	r24, 0x0143
    1cde:	90 91 44 01 	lds	r25, 0x0144
    1ce2:	0e 94 22 0b 	call	0x1644	; 0x1644 <DF_CopyFlashPageToBuffer>
    1ce6:	80 91 45 01 	lds	r24, 0x0145
    1cea:	90 91 46 01 	lds	r25, 0x0146
    1cee:	01 96       	adiw	r24, 0x01	; 1
    1cf0:	90 93 46 01 	sts	0x0146, r25
    1cf4:	80 93 45 01 	sts	0x0145, r24
    1cf8:	01 97       	sbiw	r24, 0x01	; 1
    1cfa:	0e 94 67 0a 	call	0x14ce	; 0x14ce <DF_ReadBufferByte>
    1cfe:	f8 01       	movw	r30, r16
    1d00:	82 83       	std	Z+2, r24	; 0x02
    1d02:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <V2P_IncrementCurrAddress>
    1d06:	0f 5f       	subi	r16, 0xFF	; 255
    1d08:	1f 4f       	sbci	r17, 0xFF	; 255
    1d0a:	ce 01       	movw	r24, r28
    1d0c:	8f 56       	subi	r24, 0x6F	; 111
    1d0e:	9e 4f       	sbci	r25, 0xFE	; 254
    1d10:	08 17       	cp	r16, r24
    1d12:	19 07       	cpc	r17, r25
    1d14:	a9 f6       	brne	.-86     	; 0x1cc0 <PD_InterpretAVRISPPacket+0x21e>
    1d16:	23 96       	adiw	r28, 0x03	; 3
    1d18:	d0 93 a7 02 	sts	0x02A7, r29
    1d1c:	c0 93 a6 02 	sts	0x02A6, r28
    1d20:	10 92 92 01 	sts	0x0192, r1
    1d24:	f8 01       	movw	r30, r16
    1d26:	12 82       	std	Z+2, r1	; 0x02
    1d28:	09 c0       	rjmp	.+18     	; 0x1d3c <PD_InterpretAVRISPPacket+0x29a>
    1d2a:	81 e0       	ldi	r24, 0x01	; 1
    1d2c:	90 e0       	ldi	r25, 0x00	; 0
    1d2e:	90 93 a7 02 	sts	0x02A7, r25
    1d32:	80 93 a6 02 	sts	0x02A6, r24
    1d36:	89 ec       	ldi	r24, 0xC9	; 201
    1d38:	80 93 92 01 	sts	0x0192, r24
    1d3c:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <V2P_SendPacket>
    1d40:	14 c0       	rjmp	.+40     	; 0x1d6a <PD_InterpretAVRISPPacket+0x2c8>
    1d42:	ce 01       	movw	r24, r28
    1d44:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <DF_EraseBlock>
    1d48:	21 96       	adiw	r28, 0x01	; 1
    1d4a:	80 91 41 01 	lds	r24, 0x0141
    1d4e:	90 91 42 01 	lds	r25, 0x0142
    1d52:	23 e0       	ldi	r18, 0x03	; 3
    1d54:	96 95       	lsr	r25
    1d56:	87 95       	ror	r24
    1d58:	2a 95       	dec	r18
    1d5a:	e1 f7       	brne	.-8      	; 0x1d54 <PD_InterpretAVRISPPacket+0x2b2>
    1d5c:	c8 17       	cp	r28, r24
    1d5e:	d9 07       	cpc	r29, r25
    1d60:	80 f3       	brcs	.-32     	; 0x1d42 <PD_InterpretAVRISPPacket+0x2a0>
    1d62:	89 ef       	ldi	r24, 0xF9	; 249
    1d64:	93 e0       	ldi	r25, 0x03	; 3
    1d66:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
    1d6a:	df 91       	pop	r29
    1d6c:	cf 91       	pop	r28
    1d6e:	1f 91       	pop	r17
    1d70:	0f 91       	pop	r16
    1d72:	08 95       	ret

00001d74 <V2P_GetChecksum>:
	SequenceNum++;
}

uint8_t V2P_GetChecksum()
{
    1d74:	90 91 a4 02 	lds	r25, 0x02A4
    1d78:	8b e1       	ldi	r24, 0x1B	; 27
    1d7a:	98 27       	eor	r25, r24
	uint8_t CheckSumByte;
	
	/* Checksum for the V2 protocol is comprised of an XOR of all the packet 
      bytes, including the start, sequence number, size and token bytes.    */
	
	CheckSumByte  = AICB_MESSAGE_START;
	CheckSumByte ^= SequenceNum;
	CheckSumByte ^= (uint8_t)(MessageSize >> 8);
    1d7c:	40 91 a6 02 	lds	r20, 0x02A6
    1d80:	50 91 a7 02 	lds	r21, 0x02A7
    1d84:	94 27       	eor	r25, r20
	CheckSumByte ^= (uint8_t)(MessageSize & 0xFF);
    1d86:	25 2f       	mov	r18, r21
    1d88:	33 27       	eor	r19, r19
    1d8a:	8e e0       	ldi	r24, 0x0E	; 14
    1d8c:	82 27       	eor	r24, r18
	CheckSumByte ^= AICB_TOKEN;
    1d8e:	98 27       	eor	r25, r24
    1d90:	20 e0       	ldi	r18, 0x00	; 0
    1d92:	30 e0       	ldi	r19, 0x00	; 0
    1d94:	e1 e9       	ldi	r30, 0x91	; 145
    1d96:	f1 e0       	ldi	r31, 0x01	; 1
    1d98:	04 c0       	rjmp	.+8      	; 0x1da2 <V2P_GetChecksum+0x2e>
	
	for (uint16_t CByteIndex = 0; CByteIndex < MessageSize; CByteIndex++)
	   CheckSumByte ^= PacketBytes[CByteIndex];
    1d9a:	81 91       	ld	r24, Z+
    1d9c:	98 27       	eor	r25, r24
    1d9e:	2f 5f       	subi	r18, 0xFF	; 255
    1da0:	3f 4f       	sbci	r19, 0xFF	; 255
    1da2:	24 17       	cp	r18, r20
    1da4:	35 07       	cpc	r19, r21
    1da6:	c9 f7       	brne	.-14     	; 0x1d9a <V2P_GetChecksum+0x26>

	return CheckSumByte;
}
    1da8:	89 2f       	mov	r24, r25
    1daa:	99 27       	eor	r25, r25
    1dac:	08 95       	ret

00001dae <V2P_IncrementCurrAddress>:

void V2P_GetSetParamater(void)
{
	uint8_t Param_Name = PacketBytes[1];    // Save the parameter number

	MessageSize = 3;                        // Set the default response message size to 3 bytes     
	PacketBytes[1] = AICB_STATUS_CMD_OK;    // Set the default response to OK

	switch (Param_Name)                     // Switch based on the recieved parameter byte
	{
		case AICB_PARAM_BUILD_NUMBER_LOW:
			PacketBytes[2] = VERSION_MINOR;

			break;
		case AICB_PARAM_BUILD_NUMBER_HIGH:
			PacketBytes[2] = VERSION_MAJOR;

			break;
		case AICB_PARAM_HARDWARE_VERSION:
			PacketBytes[2] = V2P_HW_VERSION;

			break;
		case AICB_PARAM_SW_MAJOR:
			PacketBytes[2] = V2P_SW_VERSION_MAJOR;

			break;
		case AICB_PARAM_SW_MINOR:
			PacketBytes[2] = ((eeprom_read_byte(&EEPROMVars.FirmVerMinor) == 0xFF)? V2P_SW_VERSION_MINOR_DEFAULT : eeprom_read_byte(&EEPROMVars.FirmVerMinor));

			break;
		case AICB_PARAM_CONTROLLER_INIT:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = Param_ControllerInit;
			}
			else
			{
				MessageSize = 2;
				Param_ControllerInit = PacketBytes[2];
			}
			
			break;
		case AICB_PARAM_SCK_DURATION:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.SCKDuration);
			}
			else
			{
				MessageSize = 2;
				eeprom_write_byte(&EEPROMVars.SCKDuration, PacketBytes[2]);
				USI_SPISetSpeed();          // Re-Initialise the USI system with the new frequency
			}
					
			break;
		case AICB_PARAM_RESET_POLARITY:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.ResetPolarity);		
			}
			else
			{
				MessageSize = 2;
				eeprom_write_byte(&EEPROMVars.ResetPolarity, PacketBytes[2]);
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Change takes effect immediatly
			}
			
			break;
		case AICB_PARAM_OSC_PSCALE:
		case AICB_PARAM_OSC_CMATCH:
			/* Despite not supporting these parameters (STK500 only), the AVR Studio programmer
			   sends them occasionally. A OK must be returned or the sequence will fail.        */
		
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			  PacketBytes[2] = 0;             // If the command is a read, return a 0 for both parameters
			else
			  MessageSize = 2;                // Otherwise just send back an OK if the command is a set		
			
			break;
		default:                             // Unrecognised parameter
			MessageSize = 2;
			PacketBytes[1] = AICB_STATUS_CMD_FAILED;			
	}
	
	V2P_SendPacket();
}

void V2P_IncrementCurrAddress(void)
{
    1dae:	80 91 a9 02 	lds	r24, 0x02A9
    1db2:	90 91 aa 02 	lds	r25, 0x02AA
    1db6:	a0 91 ab 02 	lds	r26, 0x02AB
    1dba:	b0 91 ac 02 	lds	r27, 0x02AC
    1dbe:	01 96       	adiw	r24, 0x01	; 1
    1dc0:	a1 1d       	adc	r26, r1
    1dc2:	b1 1d       	adc	r27, r1
    1dc4:	80 93 a9 02 	sts	0x02A9, r24
    1dc8:	90 93 aa 02 	sts	0x02AA, r25
    1dcc:	a0 93 ab 02 	sts	0x02AB, r26
    1dd0:	b0 93 ac 02 	sts	0x02AC, r27
    1dd4:	08 95       	ret

00001dd6 <V2P_CheckForExtendedAddress>:
	// Incrementing a 32-bit unsigned variable takes a lot of code. Because much of the code is
	// not very time critical (much of it is waiting for the hardware), I've chosen to waste
	// a few extra cycles per increment and save a good 60 bytes or so of code space by putting
	// the increment inside a function.

	CurrAddress++;
}

void V2P_CheckForExtendedAddress(void)
{
    1dd6:	80 91 a9 02 	lds	r24, 0x02A9
    1dda:	90 91 aa 02 	lds	r25, 0x02AA
    1dde:	a0 91 ab 02 	lds	r26, 0x02AB
    1de2:	b0 91 ac 02 	lds	r27, 0x02AC
    1de6:	b7 ff       	sbrs	r27, 7
    1de8:	1e c0       	rjmp	.+60     	; 0x1e26 <V2P_CheckForExtendedAddress+0x50>
	if (CurrAddress & V2P_LOAD_EXTENDED_ADDR_FLAG)     // MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
	{
		USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);   // Load extended address command
    1dea:	8d e4       	ldi	r24, 0x4D	; 77
    1dec:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1df0:	80 e0       	ldi	r24, 0x00	; 0
    1df2:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
		USI_SPITransmit((CurrAddress & V2P_LOAD_EXTENDED_ADDR_MASK) >> V2P_LOAD_EXTENDED_ADDR_SHIFT);
    1df6:	80 91 ab 02 	lds	r24, 0x02AB
    1dfa:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1dfe:	80 e0       	ldi	r24, 0x00	; 0
    1e00:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
		
		CurrAddress &= ~(V2P_LOAD_EXTENDED_ADDR_FLAG); // Clear the flag
    1e04:	80 91 a9 02 	lds	r24, 0x02A9
    1e08:	90 91 aa 02 	lds	r25, 0x02AA
    1e0c:	a0 91 ab 02 	lds	r26, 0x02AB
    1e10:	b0 91 ac 02 	lds	r27, 0x02AC
    1e14:	bf 77       	andi	r27, 0x7F	; 127
    1e16:	80 93 a9 02 	sts	0x02A9, r24
    1e1a:	90 93 aa 02 	sts	0x02AA, r25
    1e1e:	a0 93 ab 02 	sts	0x02AB, r26
    1e22:	b0 93 ac 02 	sts	0x02AC, r27
    1e26:	08 95       	ret

00001e28 <V2P_SendPacket>:
    1e28:	0f 93       	push	r16
    1e2a:	1f 93       	push	r17
    1e2c:	cf 93       	push	r28
    1e2e:	df 93       	push	r29
    1e30:	8b e1       	ldi	r24, 0x1B	; 27
    1e32:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e36:	80 91 a4 02 	lds	r24, 0x02A4
    1e3a:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e3e:	80 91 a7 02 	lds	r24, 0x02A7
    1e42:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e46:	80 91 a6 02 	lds	r24, 0x02A6
    1e4a:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e4e:	8e e0       	ldi	r24, 0x0E	; 14
    1e50:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e54:	c0 e0       	ldi	r28, 0x00	; 0
    1e56:	d0 e0       	ldi	r29, 0x00	; 0
    1e58:	01 e9       	ldi	r16, 0x91	; 145
    1e5a:	11 e0       	ldi	r17, 0x01	; 1
    1e5c:	06 c0       	rjmp	.+12     	; 0x1e6a <V2P_SendPacket+0x42>
    1e5e:	f8 01       	movw	r30, r16
    1e60:	81 91       	ld	r24, Z+
    1e62:	8f 01       	movw	r16, r30
    1e64:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e68:	21 96       	adiw	r28, 0x01	; 1
    1e6a:	80 91 a6 02 	lds	r24, 0x02A6
    1e6e:	90 91 a7 02 	lds	r25, 0x02A7
    1e72:	c8 17       	cp	r28, r24
    1e74:	d9 07       	cpc	r29, r25
    1e76:	98 f3       	brcs	.-26     	; 0x1e5e <V2P_SendPacket+0x36>
    1e78:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <V2P_GetChecksum>
    1e7c:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e80:	80 91 a4 02 	lds	r24, 0x02A4
    1e84:	90 91 a5 02 	lds	r25, 0x02A5
    1e88:	01 96       	adiw	r24, 0x01	; 1
    1e8a:	90 93 a5 02 	sts	0x02A5, r25
    1e8e:	80 93 a4 02 	sts	0x02A4, r24
    1e92:	df 91       	pop	r29
    1e94:	cf 91       	pop	r28
    1e96:	1f 91       	pop	r17
    1e98:	0f 91       	pop	r16
    1e9a:	08 95       	ret

00001e9c <V2P_GetSetParamater>:
    1e9c:	20 91 92 01 	lds	r18, 0x0192
    1ea0:	83 e0       	ldi	r24, 0x03	; 3
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	90 93 a7 02 	sts	0x02A7, r25
    1ea8:	80 93 a6 02 	sts	0x02A6, r24
    1eac:	10 92 92 01 	sts	0x0192, r1
    1eb0:	22 39       	cpi	r18, 0x92	; 146
    1eb2:	21 f1       	breq	.+72     	; 0x1efc <V2P_GetSetParamater+0x60>
    1eb4:	23 39       	cpi	r18, 0x93	; 147
    1eb6:	70 f4       	brcc	.+28     	; 0x1ed4 <V2P_GetSetParamater+0x38>
    1eb8:	21 38       	cpi	r18, 0x81	; 129
    1eba:	d1 f0       	breq	.+52     	; 0x1ef0 <V2P_GetSetParamater+0x54>
    1ebc:	22 38       	cpi	r18, 0x82	; 130
    1ebe:	20 f4       	brcc	.+8      	; 0x1ec8 <V2P_GetSetParamater+0x2c>
    1ec0:	20 38       	cpi	r18, 0x80	; 128
    1ec2:	09 f0       	breq	.+2      	; 0x1ec6 <V2P_GetSetParamater+0x2a>
    1ec4:	74 c0       	rjmp	.+232    	; 0x1fae <V2P_GetSetParamater+0x112>
    1ec6:	22 c0       	rjmp	.+68     	; 0x1f0c <V2P_GetSetParamater+0x70>
    1ec8:	20 39       	cpi	r18, 0x90	; 144
    1eca:	b1 f0       	breq	.+44     	; 0x1ef8 <V2P_GetSetParamater+0x5c>
    1ecc:	21 39       	cpi	r18, 0x91	; 145
    1ece:	09 f0       	breq	.+2      	; 0x1ed2 <V2P_GetSetParamater+0x36>
    1ed0:	6e c0       	rjmp	.+220    	; 0x1fae <V2P_GetSetParamater+0x112>
    1ed2:	12 c0       	rjmp	.+36     	; 0x1ef8 <V2P_GetSetParamater+0x5c>
    1ed4:	28 39       	cpi	r18, 0x98	; 152
    1ed6:	81 f1       	breq	.+96     	; 0x1f38 <V2P_GetSetParamater+0x9c>
    1ed8:	29 39       	cpi	r18, 0x99	; 153
    1eda:	20 f4       	brcc	.+8      	; 0x1ee4 <V2P_GetSetParamater+0x48>
    1edc:	26 39       	cpi	r18, 0x96	; 150
    1ede:	08 f4       	brcc	.+2      	; 0x1ee2 <V2P_GetSetParamater+0x46>
    1ee0:	66 c0       	rjmp	.+204    	; 0x1fae <V2P_GetSetParamater+0x112>
    1ee2:	57 c0       	rjmp	.+174    	; 0x1f92 <V2P_GetSetParamater+0xf6>
    1ee4:	2e 39       	cpi	r18, 0x9E	; 158
    1ee6:	e1 f1       	breq	.+120    	; 0x1f60 <V2P_GetSetParamater+0xc4>
    1ee8:	2f 39       	cpi	r18, 0x9F	; 159
    1eea:	09 f0       	breq	.+2      	; 0x1eee <V2P_GetSetParamater+0x52>
    1eec:	60 c0       	rjmp	.+192    	; 0x1fae <V2P_GetSetParamater+0x112>
    1eee:	12 c0       	rjmp	.+36     	; 0x1f14 <V2P_GetSetParamater+0x78>
    1ef0:	81 e0       	ldi	r24, 0x01	; 1
    1ef2:	80 93 93 01 	sts	0x0193, r24
    1ef6:	64 c0       	rjmp	.+200    	; 0x1fc0 <V2P_GetSetParamater+0x124>
    1ef8:	82 e0       	ldi	r24, 0x02	; 2
    1efa:	fb cf       	rjmp	.-10     	; 0x1ef2 <V2P_GetSetParamater+0x56>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1efc:	2a e8       	ldi	r18, 0x8A	; 138
    1efe:	30 e0       	ldi	r19, 0x00	; 0
    1f00:	d9 01       	movw	r26, r18
    1f02:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
    1f06:	80 2d       	mov	r24, r0
    1f08:	8f 3f       	cpi	r24, 0xFF	; 255
    1f0a:	11 f4       	brne	.+4      	; 0x1f10 <V2P_GetSetParamater+0x74>
    1f0c:	84 e0       	ldi	r24, 0x04	; 4
    1f0e:	f1 cf       	rjmp	.-30     	; 0x1ef2 <V2P_GetSetParamater+0x56>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1f10:	d9 01       	movw	r26, r18
    1f12:	2c c0       	rjmp	.+88     	; 0x1f6c <V2P_GetSetParamater+0xd0>
    1f14:	80 91 91 01 	lds	r24, 0x0191
    1f18:	83 30       	cpi	r24, 0x03	; 3
    1f1a:	19 f4       	brne	.+6      	; 0x1f22 <V2P_GetSetParamater+0x86>
    1f1c:	80 91 ad 02 	lds	r24, 0x02AD
    1f20:	e8 cf       	rjmp	.-48     	; 0x1ef2 <V2P_GetSetParamater+0x56>
    1f22:	82 e0       	ldi	r24, 0x02	; 2
    1f24:	90 e0       	ldi	r25, 0x00	; 0
    1f26:	90 93 a7 02 	sts	0x02A7, r25
    1f2a:	80 93 a6 02 	sts	0x02A6, r24
    1f2e:	80 91 93 01 	lds	r24, 0x0193
    1f32:	80 93 ad 02 	sts	0x02AD, r24
    1f36:	44 c0       	rjmp	.+136    	; 0x1fc0 <V2P_GetSetParamater+0x124>
    1f38:	80 91 91 01 	lds	r24, 0x0191
    1f3c:	a2 e0       	ldi	r26, 0x02	; 2
    1f3e:	b0 e0       	ldi	r27, 0x00	; 0
    1f40:	83 30       	cpi	r24, 0x03	; 3
    1f42:	a1 f0       	breq	.+40     	; 0x1f6c <V2P_GetSetParamater+0xd0>
    1f44:	82 e0       	ldi	r24, 0x02	; 2
    1f46:	90 e0       	ldi	r25, 0x00	; 0
    1f48:	90 93 a7 02 	sts	0x02A7, r25
    1f4c:	80 93 a6 02 	sts	0x02A6, r24

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    1f50:	80 91 93 01 	lds	r24, 0x0193
    1f54:	08 2e       	mov	r0, r24
    1f56:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
    1f5a:	0e 94 0f 0a 	call	0x141e	; 0x141e <USI_SPISetSpeed>
    1f5e:	30 c0       	rjmp	.+96     	; 0x1fc0 <V2P_GetSetParamater+0x124>
    1f60:	80 91 91 01 	lds	r24, 0x0191
    1f64:	a1 e0       	ldi	r26, 0x01	; 1
    1f66:	b0 e0       	ldi	r27, 0x00	; 0
    1f68:	83 30       	cpi	r24, 0x03	; 3
    1f6a:	21 f4       	brne	.+8      	; 0x1f74 <V2P_GetSetParamater+0xd8>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1f6c:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
    1f70:	80 2d       	mov	r24, r0
    1f72:	bf cf       	rjmp	.-130    	; 0x1ef2 <V2P_GetSetParamater+0x56>
    1f74:	82 e0       	ldi	r24, 0x02	; 2
    1f76:	90 e0       	ldi	r25, 0x00	; 0
    1f78:	90 93 a7 02 	sts	0x02A7, r25
    1f7c:	80 93 a6 02 	sts	0x02A6, r24

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    1f80:	80 91 93 01 	lds	r24, 0x0193
    1f84:	08 2e       	mov	r0, r24
    1f86:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
    1f8a:	81 e0       	ldi	r24, 0x01	; 1
    1f8c:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
    1f90:	17 c0       	rjmp	.+46     	; 0x1fc0 <V2P_GetSetParamater+0x124>
    1f92:	80 91 91 01 	lds	r24, 0x0191
    1f96:	83 30       	cpi	r24, 0x03	; 3
    1f98:	19 f4       	brne	.+6      	; 0x1fa0 <V2P_GetSetParamater+0x104>
    1f9a:	10 92 93 01 	sts	0x0193, r1
    1f9e:	10 c0       	rjmp	.+32     	; 0x1fc0 <V2P_GetSetParamater+0x124>
    1fa0:	82 e0       	ldi	r24, 0x02	; 2
    1fa2:	90 e0       	ldi	r25, 0x00	; 0
    1fa4:	90 93 a7 02 	sts	0x02A7, r25
    1fa8:	80 93 a6 02 	sts	0x02A6, r24
    1fac:	09 c0       	rjmp	.+18     	; 0x1fc0 <V2P_GetSetParamater+0x124>
    1fae:	82 e0       	ldi	r24, 0x02	; 2
    1fb0:	90 e0       	ldi	r25, 0x00	; 0
    1fb2:	90 93 a7 02 	sts	0x02A7, r25
    1fb6:	80 93 a6 02 	sts	0x02A6, r24
    1fba:	80 ec       	ldi	r24, 0xC0	; 192
    1fbc:	80 93 92 01 	sts	0x0192, r24
    1fc0:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <V2P_SendPacket>
    1fc4:	08 95       	ret

00001fc6 <V2P_RunStateMachine>:
    1fc6:	cf 92       	push	r12
    1fc8:	df 92       	push	r13
    1fca:	ef 92       	push	r14
    1fcc:	ff 92       	push	r15
    1fce:	0f 93       	push	r16
    1fd0:	1f 93       	push	r17
    1fd2:	cf 93       	push	r28
    1fd4:	df 93       	push	r29
    1fd6:	6c 01       	movw	r12, r24
    1fd8:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <BUFF_InitialiseBuffer>
    1fdc:	10 92 81 00 	sts	0x0081, r1
    1fe0:	10 92 a8 02 	sts	0x02A8, r1
    1fe4:	10 92 a9 02 	sts	0x02A9, r1
    1fe8:	10 92 aa 02 	sts	0x02AA, r1
    1fec:	10 92 ab 02 	sts	0x02AB, r1
    1ff0:	10 92 ac 02 	sts	0x02AC, r1
    1ff4:	10 e0       	ldi	r17, 0x00	; 0
    1ff6:	73 c0       	rjmp	.+230    	; 0x20de <V2P_RunStateMachine+0x118>
    1ff8:	12 e0       	ldi	r17, 0x02	; 2
    1ffa:	01 c0       	rjmp	.+2      	; 0x1ffe <V2P_RunStateMachine+0x38>
    1ffc:	19 e0       	ldi	r17, 0x09	; 9
    1ffe:	80 91 8c 01 	lds	r24, 0x018C
    2002:	81 30       	cpi	r24, 0x01	; 1
    2004:	09 f4       	brne	.+2      	; 0x2008 <V2P_RunStateMachine+0x42>
    2006:	0e c1       	rjmp	.+540    	; 0x2224 <V2P_RunStateMachine+0x25e>
    2008:	11 23       	and	r17, r17
    200a:	81 f1       	breq	.+96     	; 0x206c <V2P_RunStateMachine+0xa6>
    200c:	10 92 8c 01 	sts	0x018C, r1
    2010:	10 92 8b 01 	sts	0x018B, r1
    2014:	10 92 b2 00 	sts	0x00B2, r1
    2018:	80 ef       	ldi	r24, 0xF0	; 240
    201a:	80 93 b3 00 	sts	0x00B3, r24
    201e:	82 e0       	ldi	r24, 0x02	; 2
    2020:	80 93 70 00 	sts	0x0070, r24
    2024:	8f e0       	ldi	r24, 0x0F	; 15
    2026:	80 93 b0 00 	sts	0x00B0, r24
    202a:	15 30       	cpi	r17, 0x05	; 5
    202c:	09 f4       	brne	.+2      	; 0x2030 <V2P_RunStateMachine+0x6a>
    202e:	5a c0       	rjmp	.+180    	; 0x20e4 <V2P_RunStateMachine+0x11e>
    2030:	16 30       	cpi	r17, 0x06	; 6
    2032:	70 f4       	brcc	.+28     	; 0x2050 <V2P_RunStateMachine+0x8a>
    2034:	12 30       	cpi	r17, 0x02	; 2
    2036:	69 f1       	breq	.+90     	; 0x2092 <V2P_RunStateMachine+0xcc>
    2038:	13 30       	cpi	r17, 0x03	; 3
    203a:	28 f4       	brcc	.+10     	; 0x2046 <V2P_RunStateMachine+0x80>
    203c:	11 23       	and	r17, r17
    203e:	b1 f0       	breq	.+44     	; 0x206c <V2P_RunStateMachine+0xa6>
    2040:	11 30       	cpi	r17, 0x01	; 1
    2042:	e9 f6       	brne	.-70     	; 0x1ffe <V2P_RunStateMachine+0x38>
    2044:	20 c0       	rjmp	.+64     	; 0x2086 <V2P_RunStateMachine+0xc0>
    2046:	13 30       	cpi	r17, 0x03	; 3
    2048:	69 f1       	breq	.+90     	; 0x20a4 <V2P_RunStateMachine+0xde>
    204a:	14 30       	cpi	r17, 0x04	; 4
    204c:	c1 f6       	brne	.-80     	; 0x1ffe <V2P_RunStateMachine+0x38>
    204e:	35 c0       	rjmp	.+106    	; 0x20ba <V2P_RunStateMachine+0xf4>
    2050:	18 30       	cpi	r17, 0x08	; 8
    2052:	09 f4       	brne	.+2      	; 0x2056 <V2P_RunStateMachine+0x90>
    2054:	f4 c0       	rjmp	.+488    	; 0x223e <V2P_RunStateMachine+0x278>
    2056:	19 30       	cpi	r17, 0x09	; 9
    2058:	30 f4       	brcc	.+12     	; 0x2066 <V2P_RunStateMachine+0xa0>
    205a:	16 30       	cpi	r17, 0x06	; 6
    205c:	09 f4       	brne	.+2      	; 0x2060 <V2P_RunStateMachine+0x9a>
    205e:	49 c0       	rjmp	.+146    	; 0x20f2 <V2P_RunStateMachine+0x12c>
    2060:	17 30       	cpi	r17, 0x07	; 7
    2062:	69 f6       	brne	.-102    	; 0x1ffe <V2P_RunStateMachine+0x38>
    2064:	57 c0       	rjmp	.+174    	; 0x2114 <V2P_RunStateMachine+0x14e>
    2066:	1c 30       	cpi	r17, 0x0C	; 12
    2068:	50 f6       	brcc	.-108    	; 0x1ffe <V2P_RunStateMachine+0x38>
    206a:	d6 c0       	rjmp	.+428    	; 0x2218 <V2P_RunStateMachine+0x252>
    206c:	80 91 88 01 	lds	r24, 0x0188
    2070:	81 11       	cpse	r24, r1
    2072:	81 e0       	ldi	r24, 0x01	; 1
    2074:	18 2f       	mov	r17, r24
    2076:	f2 9b       	sbis	0x1e, 2	; 30
    2078:	c2 cf       	rjmp	.-124    	; 0x1ffe <V2P_RunStateMachine+0x38>
    207a:	80 91 a8 02 	lds	r24, 0x02A8
    207e:	88 23       	and	r24, r24
    2080:	09 f0       	breq	.+2      	; 0x2084 <V2P_RunStateMachine+0xbe>
    2082:	bd cf       	rjmp	.-134    	; 0x1ffe <V2P_RunStateMachine+0x38>
    2084:	e6 c0       	rjmp	.+460    	; 0x2252 <V2P_RunStateMachine+0x28c>
    2086:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    208a:	8b 31       	cpi	r24, 0x1B	; 27
    208c:	09 f0       	breq	.+2      	; 0x2090 <V2P_RunStateMachine+0xca>
    208e:	b6 cf       	rjmp	.-148    	; 0x1ffc <V2P_RunStateMachine+0x36>
    2090:	b3 cf       	rjmp	.-154    	; 0x1ff8 <V2P_RunStateMachine+0x32>
    2092:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    2096:	99 27       	eor	r25, r25
    2098:	90 93 a5 02 	sts	0x02A5, r25
    209c:	80 93 a4 02 	sts	0x02A4, r24
    20a0:	13 e0       	ldi	r17, 0x03	; 3
    20a2:	ad cf       	rjmp	.-166    	; 0x1ffe <V2P_RunStateMachine+0x38>
    20a4:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    20a8:	99 27       	eor	r25, r25
    20aa:	98 2f       	mov	r25, r24
    20ac:	88 27       	eor	r24, r24
    20ae:	90 93 a7 02 	sts	0x02A7, r25
    20b2:	80 93 a6 02 	sts	0x02A6, r24
    20b6:	14 e0       	ldi	r17, 0x04	; 4
    20b8:	a2 cf       	rjmp	.-188    	; 0x1ffe <V2P_RunStateMachine+0x38>
    20ba:	00 91 a6 02 	lds	r16, 0x02A6
    20be:	10 91 a7 02 	lds	r17, 0x02A7
    20c2:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    20c6:	99 27       	eor	r25, r25
    20c8:	80 2b       	or	r24, r16
    20ca:	91 2b       	or	r25, r17
    20cc:	90 93 a7 02 	sts	0x02A7, r25
    20d0:	80 93 a6 02 	sts	0x02A6, r24
    20d4:	83 51       	subi	r24, 0x13	; 19
    20d6:	91 40       	sbci	r25, 0x01	; 1
    20d8:	08 f0       	brcs	.+2      	; 0x20dc <V2P_RunStateMachine+0x116>
    20da:	90 cf       	rjmp	.-224    	; 0x1ffc <V2P_RunStateMachine+0x36>
    20dc:	15 e0       	ldi	r17, 0x05	; 5
    20de:	c0 e0       	ldi	r28, 0x00	; 0
    20e0:	d0 e0       	ldi	r29, 0x00	; 0
    20e2:	8d cf       	rjmp	.-230    	; 0x1ffe <V2P_RunStateMachine+0x38>
    20e4:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    20e8:	8e 30       	cpi	r24, 0x0E	; 14
    20ea:	09 f0       	breq	.+2      	; 0x20ee <V2P_RunStateMachine+0x128>
    20ec:	87 cf       	rjmp	.-242    	; 0x1ffc <V2P_RunStateMachine+0x36>
    20ee:	16 e0       	ldi	r17, 0x06	; 6
    20f0:	86 cf       	rjmp	.-244    	; 0x1ffe <V2P_RunStateMachine+0x38>
    20f2:	80 91 a6 02 	lds	r24, 0x02A6
    20f6:	90 91 a7 02 	lds	r25, 0x02A7
    20fa:	c8 17       	cp	r28, r24
    20fc:	d9 07       	cpc	r29, r25
    20fe:	11 f4       	brne	.+4      	; 0x2104 <V2P_RunStateMachine+0x13e>
    2100:	17 e0       	ldi	r17, 0x07	; 7
    2102:	7d cf       	rjmp	.-262    	; 0x1ffe <V2P_RunStateMachine+0x38>
    2104:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    2108:	fe 01       	movw	r30, r28
    210a:	ef 56       	subi	r30, 0x6F	; 111
    210c:	fe 4f       	sbci	r31, 0xFE	; 254
    210e:	80 83       	st	Z, r24
    2110:	21 96       	adiw	r28, 0x01	; 1
    2112:	75 cf       	rjmp	.-278    	; 0x1ffe <V2P_RunStateMachine+0x38>
    2114:	80 91 8c 01 	lds	r24, 0x018C
    2118:	88 23       	and	r24, r24
    211a:	09 f0       	breq	.+2      	; 0x211e <V2P_RunStateMachine+0x158>
    211c:	70 cf       	rjmp	.-288    	; 0x1ffe <V2P_RunStateMachine+0x38>
    211e:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <V2P_GetChecksum>
    2122:	18 2f       	mov	r17, r24
    2124:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    2128:	18 17       	cp	r17, r24
    212a:	11 f0       	breq	.+4      	; 0x2130 <V2P_RunStateMachine+0x16a>
    212c:	1b e0       	ldi	r17, 0x0B	; 11
    212e:	67 cf       	rjmp	.-306    	; 0x1ffe <V2P_RunStateMachine+0x38>
    2130:	80 91 91 01 	lds	r24, 0x0191
    2134:	84 30       	cpi	r24, 0x04	; 4
    2136:	38 f4       	brcc	.+14     	; 0x2146 <V2P_RunStateMachine+0x180>
    2138:	82 30       	cpi	r24, 0x02	; 2
    213a:	08 f0       	brcs	.+2      	; 0x213e <V2P_RunStateMachine+0x178>
    213c:	66 c0       	rjmp	.+204    	; 0x220a <V2P_RunStateMachine+0x244>
    213e:	81 30       	cpi	r24, 0x01	; 1
    2140:	09 f0       	breq	.+2      	; 0x2144 <V2P_RunStateMachine+0x17e>
    2142:	66 c0       	rjmp	.+204    	; 0x2210 <V2P_RunStateMachine+0x24a>
    2144:	06 c0       	rjmp	.+12     	; 0x2152 <V2P_RunStateMachine+0x18c>
    2146:	86 30       	cpi	r24, 0x06	; 6
    2148:	01 f1       	breq	.+64     	; 0x218a <V2P_RunStateMachine+0x1c4>
    214a:	87 30       	cpi	r24, 0x07	; 7
    214c:	09 f0       	breq	.+2      	; 0x2150 <V2P_RunStateMachine+0x18a>
    214e:	60 c0       	rjmp	.+192    	; 0x2210 <V2P_RunStateMachine+0x24a>
    2150:	12 c0       	rjmp	.+36     	; 0x2176 <V2P_RunStateMachine+0x1b0>
    2152:	8b e0       	ldi	r24, 0x0B	; 11
    2154:	90 e0       	ldi	r25, 0x00	; 0
    2156:	90 93 a7 02 	sts	0x02A7, r25
    215a:	80 93 a6 02 	sts	0x02A6, r24
    215e:	ea e0       	ldi	r30, 0x0A	; 10
    2160:	f4 e0       	ldi	r31, 0x04	; 4
    2162:	a1 e9       	ldi	r26, 0x91	; 145
    2164:	b1 e0       	ldi	r27, 0x01	; 1
    2166:	84 91       	lpm	r24, Z
    2168:	8d 93       	st	X+, r24
    216a:	31 96       	adiw	r30, 0x01	; 1
    216c:	81 e0       	ldi	r24, 0x01	; 1
    216e:	ac 39       	cpi	r26, 0x9C	; 156
    2170:	b8 07       	cpc	r27, r24
    2172:	c9 f7       	brne	.-14     	; 0x2166 <V2P_RunStateMachine+0x1a0>
    2174:	47 c0       	rjmp	.+142    	; 0x2204 <V2P_RunStateMachine+0x23e>
    2176:	82 e0       	ldi	r24, 0x02	; 2
    2178:	90 e0       	ldi	r25, 0x00	; 0
    217a:	90 93 a7 02 	sts	0x02A7, r25
    217e:	80 93 a6 02 	sts	0x02A6, r24
    2182:	80 ec       	ldi	r24, 0xC0	; 192
    2184:	80 93 92 01 	sts	0x0192, r24
    2188:	3d c0       	rjmp	.+122    	; 0x2204 <V2P_RunStateMachine+0x23e>
    218a:	82 e0       	ldi	r24, 0x02	; 2
    218c:	90 e0       	ldi	r25, 0x00	; 0
    218e:	90 93 a7 02 	sts	0x02A7, r25
    2192:	80 93 a6 02 	sts	0x02A6, r24
    2196:	0e 94 eb 0e 	call	0x1dd6	; 0x1dd6 <V2P_CheckForExtendedAddress>
    219a:	e0 90 94 01 	lds	r14, 0x0194
    219e:	ff 24       	eor	r15, r15
    21a0:	00 27       	eor	r16, r16
    21a2:	11 27       	eor	r17, r17
    21a4:	10 2f       	mov	r17, r16
    21a6:	0f 2d       	mov	r16, r15
    21a8:	fe 2c       	mov	r15, r14
    21aa:	ee 24       	eor	r14, r14
    21ac:	20 91 92 01 	lds	r18, 0x0192
    21b0:	33 27       	eor	r19, r19
    21b2:	44 27       	eor	r20, r20
    21b4:	55 27       	eor	r21, r21
    21b6:	52 2f       	mov	r21, r18
    21b8:	44 27       	eor	r20, r20
    21ba:	33 27       	eor	r19, r19
    21bc:	22 27       	eor	r18, r18
    21be:	80 91 93 01 	lds	r24, 0x0193
    21c2:	99 27       	eor	r25, r25
    21c4:	aa 27       	eor	r26, r26
    21c6:	bb 27       	eor	r27, r27
    21c8:	dc 01       	movw	r26, r24
    21ca:	99 27       	eor	r25, r25
    21cc:	88 27       	eor	r24, r24
    21ce:	28 2b       	or	r18, r24
    21d0:	39 2b       	or	r19, r25
    21d2:	4a 2b       	or	r20, r26
    21d4:	5b 2b       	or	r21, r27
    21d6:	80 91 95 01 	lds	r24, 0x0195
    21da:	99 27       	eor	r25, r25
    21dc:	aa 27       	eor	r26, r26
    21de:	bb 27       	eor	r27, r27
    21e0:	28 2b       	or	r18, r24
    21e2:	39 2b       	or	r19, r25
    21e4:	4a 2b       	or	r20, r26
    21e6:	5b 2b       	or	r21, r27
    21e8:	e2 2a       	or	r14, r18
    21ea:	f3 2a       	or	r15, r19
    21ec:	04 2b       	or	r16, r20
    21ee:	15 2b       	or	r17, r21
    21f0:	e0 92 a9 02 	sts	0x02A9, r14
    21f4:	f0 92 aa 02 	sts	0x02AA, r15
    21f8:	00 93 ab 02 	sts	0x02AB, r16
    21fc:	10 93 ac 02 	sts	0x02AC, r17
    2200:	10 92 92 01 	sts	0x0192, r1
    2204:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <V2P_SendPacket>
    2208:	05 c0       	rjmp	.+10     	; 0x2214 <V2P_RunStateMachine+0x24e>
    220a:	0e 94 4e 0f 	call	0x1e9c	; 0x1e9c <V2P_GetSetParamater>
    220e:	02 c0       	rjmp	.+4      	; 0x2214 <V2P_RunStateMachine+0x24e>
    2210:	f6 01       	movw	r30, r12
    2212:	09 95       	icall
    2214:	18 e0       	ldi	r17, 0x08	; 8
    2216:	f3 ce       	rjmp	.-538    	; 0x1ffe <V2P_RunStateMachine+0x38>
    2218:	1b 30       	cpi	r17, 0x0B	; 11
    221a:	11 f4       	brne	.+4      	; 0x2220 <V2P_RunStateMachine+0x25a>
    221c:	81 ec       	ldi	r24, 0xC1	; 193
    221e:	05 c0       	rjmp	.+10     	; 0x222a <V2P_RunStateMachine+0x264>
    2220:	1a 30       	cpi	r17, 0x0A	; 10
    2222:	11 f4       	brne	.+4      	; 0x2228 <V2P_RunStateMachine+0x262>
    2224:	80 e8       	ldi	r24, 0x80	; 128
    2226:	01 c0       	rjmp	.+2      	; 0x222a <V2P_RunStateMachine+0x264>
    2228:	80 ec       	ldi	r24, 0xC0	; 192
    222a:	80 93 92 01 	sts	0x0192, r24
    222e:	82 e0       	ldi	r24, 0x02	; 2
    2230:	90 e0       	ldi	r25, 0x00	; 0
    2232:	90 93 a7 02 	sts	0x02A7, r25
    2236:	80 93 a6 02 	sts	0x02A6, r24
    223a:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <V2P_SendPacket>
    223e:	10 92 8c 01 	sts	0x018C, r1
    2242:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <BUFF_InitialiseBuffer>
    2246:	10 92 b0 00 	sts	0x00B0, r1
    224a:	10 92 70 00 	sts	0x0070, r1
    224e:	10 e0       	ldi	r17, 0x00	; 0
    2250:	d6 ce       	rjmp	.-596    	; 0x1ffe <V2P_RunStateMachine+0x38>
    2252:	80 e8       	ldi	r24, 0x80	; 128
    2254:	80 93 61 00 	sts	0x0061, r24
    2258:	83 e0       	ldi	r24, 0x03	; 3
    225a:	80 93 61 00 	sts	0x0061, r24
    225e:	10 92 c1 00 	sts	0x00C1, r1
    2262:	0e 94 3f 0c 	call	0x187e	; 0x187e <TOUT_SetupSleepTimer>
    2266:	df 91       	pop	r29
    2268:	cf 91       	pop	r28
    226a:	1f 91       	pop	r17
    226c:	0f 91       	pop	r16
    226e:	ff 90       	pop	r15
    2270:	ef 90       	pop	r14
    2272:	df 90       	pop	r13
    2274:	cf 90       	pop	r12
    2276:	08 95       	ret

00002278 <ISPCC_PollForProgComplete>:
	}
}

void ISPCC_PollForProgComplete(const uint8_t PollData, uint16_t PollAddr)
{
    2278:	1f 93       	push	r17
    227a:	cf 93       	push	r28
    227c:	df 93       	push	r29
    227e:	eb 01       	movw	r28, r22
	uint8_t PollType;
	uint8_t ProgCommand;

	if (PollData & ISPCC_PROG_MODE_PAGE)
    2280:	99 27       	eor	r25, r25
    2282:	80 ff       	sbrs	r24, 0
    2284:	08 c0       	rjmp	.+16     	; 0x2296 <ISPCC_PollForProgComplete+0x1e>
	   PollType = ((PollData & ISPCC_PAGE_POLLTYPE_MASK) >> ISPCC_PAGE_POLLTYPE_MASKSHIFT);
    2286:	80 77       	andi	r24, 0x70	; 112
    2288:	90 70       	andi	r25, 0x00	; 0
    228a:	34 e0       	ldi	r19, 0x04	; 4
    228c:	95 95       	asr	r25
    228e:	87 95       	ror	r24
    2290:	3a 95       	dec	r19
    2292:	e1 f7       	brne	.-8      	; 0x228c <ISPCC_PollForProgComplete+0x14>
    2294:	04 c0       	rjmp	.+8      	; 0x229e <ISPCC_PollForProgComplete+0x26>
	else
	   PollType = ((PollData & ISPCC_WORD_POLLTYPE_MASK) >> ISPCC_WORD_POLLTYPE_MASKSHIFT);	
    2296:	8e 70       	andi	r24, 0x0E	; 14
    2298:	90 70       	andi	r25, 0x00	; 0
    229a:	95 95       	asr	r25
    229c:	87 95       	ror	r24

	switch (PollType & ISPCC_POLLTYPE_MASK)
    229e:	99 27       	eor	r25, r25
    22a0:	87 70       	andi	r24, 0x07	; 7
    22a2:	90 70       	andi	r25, 0x00	; 0
    22a4:	82 30       	cpi	r24, 0x02	; 2
    22a6:	91 05       	cpc	r25, r1
    22a8:	19 f0       	breq	.+6      	; 0x22b0 <ISPCC_PollForProgComplete+0x38>
    22aa:	04 97       	sbiw	r24, 0x04	; 4
    22ac:	41 f5       	brne	.+80     	; 0x22fe <ISPCC_PollForProgComplete+0x86>
    22ae:	1c c0       	rjmp	.+56     	; 0x22e8 <ISPCC_PollForProgComplete+0x70>
	{
		case ISPCC_POLLTYPE_DATA:
			ProgCommand = PacketBytes[7];
    22b0:	10 91 98 01 	lds	r17, 0x0198
			
			if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP) // Flash uses word addresses
    22b4:	80 91 91 01 	lds	r24, 0x0191
    22b8:	83 31       	cpi	r24, 0x13	; 19
    22ba:	41 f4       	brne	.+16     	; 0x22cc <ISPCC_PollForProgComplete+0x54>
			{
				ProgCommand  |= ((PollAddr & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ);
    22bc:	c0 ff       	sbrs	r28, 0
    22be:	02 c0       	rjmp	.+4      	; 0x22c4 <ISPCC_PollForProgComplete+0x4c>
    22c0:	88 e0       	ldi	r24, 0x08	; 8
    22c2:	01 c0       	rjmp	.+2      	; 0x22c6 <ISPCC_PollForProgComplete+0x4e>
    22c4:	80 e0       	ldi	r24, 0x00	; 0
    22c6:	18 2b       	or	r17, r24
				PollAddr    >>= 1;
    22c8:	d6 95       	lsr	r29
    22ca:	c7 95       	ror	r28
			}

			do
			{
				USI_SPITransmit(ProgCommand);
    22cc:	81 2f       	mov	r24, r17
    22ce:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
				USI_SPITransmitWord(PollAddr);
    22d2:	ce 01       	movw	r24, r28
    22d4:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
			}
			while (USI_SPITransmit(0x00) == PacketBytes[8]);
    22d8:	80 e0       	ldi	r24, 0x00	; 0
    22da:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    22de:	90 91 99 01 	lds	r25, 0x0199
    22e2:	89 17       	cp	r24, r25
    22e4:	81 f4       	brne	.+32     	; 0x2306 <ISPCC_PollForProgComplete+0x8e>
    22e6:	f2 cf       	rjmp	.-28     	; 0x22cc <ISPCC_PollForProgComplete+0x54>
						
			break;
		case ISPCC_POLLTYPE_READY:
			do
			   USI_SPITransmitWord(0xF000);
    22e8:	80 e0       	ldi	r24, 0x00	; 0
    22ea:	90 ef       	ldi	r25, 0xF0	; 240
    22ec:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
			while (USI_SPITransmitWord(0x0000) & ISPCC_POLL_BUSYFLAG);
    22f0:	80 e0       	ldi	r24, 0x00	; 0
    22f2:	90 e0       	ldi	r25, 0x00	; 0
    22f4:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
    22f8:	80 ff       	sbrs	r24, 0
    22fa:	05 c0       	rjmp	.+10     	; 0x2306 <ISPCC_PollForProgComplete+0x8e>
    22fc:	f5 cf       	rjmp	.-22     	; 0x22e8 <ISPCC_PollForProgComplete+0x70>

			break;
		default:                                      // Default is Wait polling
			MAIN_Delay1MS(PacketBytes[4]);	
    22fe:	80 91 95 01 	lds	r24, 0x0195
    2302:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2306:	df 91       	pop	r29
    2308:	cf 91       	pop	r28
    230a:	1f 91       	pop	r17
    230c:	08 95       	ret

0000230e <ISPCC_ProgramChip>:
    230e:	4f 92       	push	r4
    2310:	5f 92       	push	r5
    2312:	6f 92       	push	r6
    2314:	7f 92       	push	r7
    2316:	8f 92       	push	r8
    2318:	9f 92       	push	r9
    231a:	af 92       	push	r10
    231c:	bf 92       	push	r11
    231e:	cf 92       	push	r12
    2320:	df 92       	push	r13
    2322:	ef 92       	push	r14
    2324:	ff 92       	push	r15
    2326:	0f 93       	push	r16
    2328:	1f 93       	push	r17
    232a:	cf 93       	push	r28
    232c:	df 93       	push	r29
    232e:	b0 90 94 01 	lds	r11, 0x0194
    2332:	a0 90 96 01 	lds	r10, 0x0196
    2336:	40 90 a9 02 	lds	r4, 0x02A9
    233a:	50 90 aa 02 	lds	r5, 0x02AA
    233e:	60 90 ab 02 	lds	r6, 0x02AB
    2342:	70 90 ac 02 	lds	r7, 0x02AC
    2346:	80 91 92 01 	lds	r24, 0x0192
    234a:	99 27       	eor	r25, r25
    234c:	98 2e       	mov	r9, r24
    234e:	88 24       	eor	r8, r8
    2350:	80 91 93 01 	lds	r24, 0x0193
    2354:	99 27       	eor	r25, r25
    2356:	88 2a       	or	r8, r24
    2358:	99 2a       	or	r9, r25
    235a:	e0 90 91 01 	lds	r14, 0x0191
    235e:	b0 fc       	sbrc	r11, 0
    2360:	09 c0       	rjmp	.+18     	; 0x2374 <ISPCC_ProgramChip+0x66>
    2362:	c0 e0       	ldi	r28, 0x00	; 0
    2364:	d0 e0       	ldi	r29, 0x00	; 0
    2366:	cc 24       	eor	r12, r12
    2368:	dd 24       	eor	r13, r13
    236a:	7b e9       	ldi	r23, 0x9B	; 155
    236c:	67 2e       	mov	r6, r23
    236e:	71 e0       	ldi	r23, 0x01	; 1
    2370:	77 2e       	mov	r7, r23
    2372:	ac c0       	rjmp	.+344    	; 0x24cc <ISPCC_ProgramChip+0x1be>
    2374:	c0 e0       	ldi	r28, 0x00	; 0
    2376:	d0 e0       	ldi	r29, 0x00	; 0
    2378:	00 e0       	ldi	r16, 0x00	; 0
    237a:	10 e0       	ldi	r17, 0x00	; 0
    237c:	6b e9       	ldi	r22, 0x9B	; 155
    237e:	c6 2e       	mov	r12, r22
    2380:	61 e0       	ldi	r22, 0x01	; 1
    2382:	d6 2e       	mov	r13, r22
    2384:	41 c0       	rjmp	.+130    	; 0x2408 <ISPCC_ProgramChip+0xfa>
    2386:	f6 01       	movw	r30, r12
    2388:	f0 80       	ld	r15, Z
    238a:	f3 e1       	ldi	r31, 0x13	; 19
    238c:	ef 16       	cp	r14, r31
    238e:	39 f4       	brne	.+14     	; 0x239e <ISPCC_ProgramChip+0x90>
    2390:	00 ff       	sbrs	r16, 0
    2392:	02 c0       	rjmp	.+4      	; 0x2398 <ISPCC_ProgramChip+0x8a>
    2394:	88 e0       	ldi	r24, 0x08	; 8
    2396:	01 c0       	rjmp	.+2      	; 0x239a <ISPCC_ProgramChip+0x8c>
    2398:	80 e0       	ldi	r24, 0x00	; 0
    239a:	8a 29       	or	r24, r10
    239c:	01 c0       	rjmp	.+2      	; 0x23a0 <ISPCC_ProgramChip+0x92>
    239e:	8a 2d       	mov	r24, r10
    23a0:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    23a4:	80 91 a9 02 	lds	r24, 0x02A9
    23a8:	90 91 aa 02 	lds	r25, 0x02AA
    23ac:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
    23b0:	8f 2d       	mov	r24, r15
    23b2:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    23b6:	20 97       	sbiw	r28, 0x00	; 0
    23b8:	d9 f4       	brne	.+54     	; 0x23f0 <ISPCC_ProgramChip+0xe2>
    23ba:	80 91 99 01 	lds	r24, 0x0199
    23be:	8f 15       	cp	r24, r15
    23c0:	b9 f0       	breq	.+46     	; 0x23f0 <ISPCC_ProgramChip+0xe2>
    23c2:	83 e1       	ldi	r24, 0x13	; 19
    23c4:	e8 16       	cp	r14, r24
    23c6:	49 f0       	breq	.+18     	; 0x23da <ISPCC_ProgramChip+0xcc>
    23c8:	e5 e1       	ldi	r30, 0x15	; 21
    23ca:	ee 16       	cp	r14, r30
    23cc:	89 f4       	brne	.+34     	; 0x23f0 <ISPCC_ProgramChip+0xe2>
    23ce:	80 91 9a 01 	lds	r24, 0x019A
    23d2:	8f 15       	cp	r24, r15
    23d4:	09 f0       	breq	.+2      	; 0x23d8 <ISPCC_ProgramChip+0xca>
    23d6:	7f c0       	rjmp	.+254    	; 0x24d6 <ISPCC_ProgramChip+0x1c8>
    23d8:	0b c0       	rjmp	.+22     	; 0x23f0 <ISPCC_ProgramChip+0xe2>
    23da:	c0 91 a9 02 	lds	r28, 0x02A9
    23de:	d0 91 aa 02 	lds	r29, 0x02AA
    23e2:	cc 0f       	add	r28, r28
    23e4:	dd 1f       	adc	r29, r29
    23e6:	c8 01       	movw	r24, r16
    23e8:	81 70       	andi	r24, 0x01	; 1
    23ea:	90 70       	andi	r25, 0x00	; 0
    23ec:	c8 0f       	add	r28, r24
    23ee:	d9 1f       	adc	r29, r25
    23f0:	00 fd       	sbrc	r16, 0
    23f2:	03 c0       	rjmp	.+6      	; 0x23fa <ISPCC_ProgramChip+0xec>
    23f4:	f5 e1       	ldi	r31, 0x15	; 21
    23f6:	ef 16       	cp	r14, r31
    23f8:	11 f4       	brne	.+4      	; 0x23fe <ISPCC_ProgramChip+0xf0>
    23fa:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <V2P_IncrementCurrAddress>
    23fe:	0f 5f       	subi	r16, 0xFF	; 255
    2400:	1f 4f       	sbci	r17, 0xFF	; 255
    2402:	08 94       	sec
    2404:	c1 1c       	adc	r12, r1
    2406:	d1 1c       	adc	r13, r1
    2408:	08 15       	cp	r16, r8
    240a:	19 05       	cpc	r17, r9
    240c:	09 f0       	breq	.+2      	; 0x2410 <ISPCC_ProgramChip+0x102>
    240e:	bb cf       	rjmp	.-138    	; 0x2386 <ISPCC_ProgramChip+0x78>
    2410:	b7 fe       	sbrs	r11, 7
    2412:	6c c0       	rjmp	.+216    	; 0x24ec <ISPCC_ProgramChip+0x1de>
    2414:	80 91 97 01 	lds	r24, 0x0197
    2418:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    241c:	c2 01       	movw	r24, r4
    241e:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
    2422:	80 e0       	ldi	r24, 0x00	; 0
    2424:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    2428:	20 97       	sbiw	r28, 0x00	; 0
    242a:	11 f0       	breq	.+4      	; 0x2430 <ISPCC_ProgramChip+0x122>
    242c:	8b 2d       	mov	r24, r11
    242e:	03 c0       	rjmp	.+6      	; 0x2436 <ISPCC_ProgramChip+0x128>
    2430:	8b 2d       	mov	r24, r11
    2432:	8f 78       	andi	r24, 0x8F	; 143
    2434:	80 61       	ori	r24, 0x10	; 16
    2436:	be 01       	movw	r22, r28
    2438:	0e 94 3c 11 	call	0x2278	; 0x2278 <ISPCC_PollForProgComplete>
    243c:	57 c0       	rjmp	.+174    	; 0x24ec <ISPCC_ProgramChip+0x1de>
    243e:	f3 01       	movw	r30, r6
    2440:	10 81       	ld	r17, Z
    2442:	f3 e1       	ldi	r31, 0x13	; 19
    2444:	ef 16       	cp	r14, r31
    2446:	39 f4       	brne	.+14     	; 0x2456 <ISPCC_ProgramChip+0x148>
    2448:	c0 fe       	sbrs	r12, 0
    244a:	02 c0       	rjmp	.+4      	; 0x2450 <ISPCC_ProgramChip+0x142>
    244c:	88 e0       	ldi	r24, 0x08	; 8
    244e:	01 c0       	rjmp	.+2      	; 0x2452 <ISPCC_ProgramChip+0x144>
    2450:	80 e0       	ldi	r24, 0x00	; 0
    2452:	8a 29       	or	r24, r10
    2454:	01 c0       	rjmp	.+2      	; 0x2458 <ISPCC_ProgramChip+0x14a>
    2456:	8a 2d       	mov	r24, r10
    2458:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    245c:	80 91 a9 02 	lds	r24, 0x02A9
    2460:	90 91 aa 02 	lds	r25, 0x02AA
    2464:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
    2468:	81 2f       	mov	r24, r17
    246a:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    246e:	80 91 99 01 	lds	r24, 0x0199
    2472:	81 17       	cp	r24, r17
    2474:	b9 f0       	breq	.+46     	; 0x24a4 <ISPCC_ProgramChip+0x196>
    2476:	83 e1       	ldi	r24, 0x13	; 19
    2478:	e8 16       	cp	r14, r24
    247a:	41 f0       	breq	.+16     	; 0x248c <ISPCC_ProgramChip+0x17e>
    247c:	e5 e1       	ldi	r30, 0x15	; 21
    247e:	ee 16       	cp	r14, r30
    2480:	89 f4       	brne	.+34     	; 0x24a4 <ISPCC_ProgramChip+0x196>
    2482:	80 91 9a 01 	lds	r24, 0x019A
    2486:	81 17       	cp	r24, r17
    2488:	59 f5       	brne	.+86     	; 0x24e0 <ISPCC_ProgramChip+0x1d2>
    248a:	0c c0       	rjmp	.+24     	; 0x24a4 <ISPCC_ProgramChip+0x196>
    248c:	c0 91 a9 02 	lds	r28, 0x02A9
    2490:	d0 91 aa 02 	lds	r29, 0x02AA
    2494:	cc 0f       	add	r28, r28
    2496:	dd 1f       	adc	r29, r29
    2498:	c6 01       	movw	r24, r12
    249a:	81 70       	andi	r24, 0x01	; 1
    249c:	90 70       	andi	r25, 0x00	; 0
    249e:	c8 0f       	add	r28, r24
    24a0:	d9 1f       	adc	r29, r25
    24a2:	22 c0       	rjmp	.+68     	; 0x24e8 <ISPCC_ProgramChip+0x1da>
    24a4:	1b 2d       	mov	r17, r11
    24a6:	11 7f       	andi	r17, 0xF1	; 241
    24a8:	12 60       	ori	r17, 0x02	; 2
    24aa:	c0 fc       	sbrc	r12, 0
    24ac:	03 c0       	rjmp	.+6      	; 0x24b4 <ISPCC_ProgramChip+0x1a6>
    24ae:	f5 e1       	ldi	r31, 0x15	; 21
    24b0:	ef 16       	cp	r14, r31
    24b2:	11 f4       	brne	.+4      	; 0x24b8 <ISPCC_ProgramChip+0x1aa>
    24b4:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <V2P_IncrementCurrAddress>
    24b8:	be 01       	movw	r22, r28
    24ba:	81 2f       	mov	r24, r17
    24bc:	0e 94 3c 11 	call	0x2278	; 0x2278 <ISPCC_PollForProgComplete>
    24c0:	08 94       	sec
    24c2:	c1 1c       	adc	r12, r1
    24c4:	d1 1c       	adc	r13, r1
    24c6:	08 94       	sec
    24c8:	61 1c       	adc	r6, r1
    24ca:	71 1c       	adc	r7, r1
    24cc:	c8 14       	cp	r12, r8
    24ce:	d9 04       	cpc	r13, r9
    24d0:	09 f0       	breq	.+2      	; 0x24d4 <ISPCC_ProgramChip+0x1c6>
    24d2:	b5 cf       	rjmp	.-150    	; 0x243e <ISPCC_ProgramChip+0x130>
    24d4:	0b c0       	rjmp	.+22     	; 0x24ec <ISPCC_ProgramChip+0x1de>
    24d6:	c0 91 a9 02 	lds	r28, 0x02A9
    24da:	d0 91 aa 02 	lds	r29, 0x02AA
    24de:	88 cf       	rjmp	.-240    	; 0x23f0 <ISPCC_ProgramChip+0xe2>
    24e0:	c0 91 a9 02 	lds	r28, 0x02A9
    24e4:	d0 91 aa 02 	lds	r29, 0x02AA
    24e8:	1b 2d       	mov	r17, r11
    24ea:	df cf       	rjmp	.-66     	; 0x24aa <ISPCC_ProgramChip+0x19c>
    24ec:	df 91       	pop	r29
    24ee:	cf 91       	pop	r28
    24f0:	1f 91       	pop	r17
    24f2:	0f 91       	pop	r16
    24f4:	ff 90       	pop	r15
    24f6:	ef 90       	pop	r14
    24f8:	df 90       	pop	r13
    24fa:	cf 90       	pop	r12
    24fc:	bf 90       	pop	r11
    24fe:	af 90       	pop	r10
    2500:	9f 90       	pop	r9
    2502:	8f 90       	pop	r8
    2504:	7f 90       	pop	r7
    2506:	6f 90       	pop	r6
    2508:	5f 90       	pop	r5
    250a:	4f 90       	pop	r4
    250c:	08 95       	ret

0000250e <ISPCC_EnterChipProgrammingMode>:
    250e:	ff 92       	push	r15
    2510:	0f 93       	push	r16
    2512:	1f 93       	push	r17
    2514:	00 91 96 01 	lds	r16, 0x0196
    2518:	10 91 95 01 	lds	r17, 0x0195
    251c:	81 b3       	in	r24, 0x11	; 17
    251e:	8f 7c       	andi	r24, 0xCF	; 207
    2520:	80 63       	ori	r24, 0x30	; 48
    2522:	81 bb       	out	0x11, r24	; 17
    2524:	80 91 93 01 	lds	r24, 0x0193
    2528:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    252c:	81 2f       	mov	r24, r17
    252e:	81 50       	subi	r24, 0x01	; 1
    2530:	84 36       	cpi	r24, 0x64	; 100
    2532:	08 f4       	brcc	.+2      	; 0x2536 <ISPCC_EnterChipProgrammingMode+0x28>
    2534:	40 c0       	rjmp	.+128    	; 0x25b6 <ISPCC_EnterChipProgrammingMode+0xa8>
    2536:	18 e1       	ldi	r17, 0x18	; 24
    2538:	3e c0       	rjmp	.+124    	; 0x25b6 <ISPCC_EnterChipProgrammingMode+0xa8>
    253a:	80 91 99 01 	lds	r24, 0x0199
    253e:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    2542:	80 2f       	mov	r24, r16
    2544:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2548:	80 91 9a 01 	lds	r24, 0x019A
    254c:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    2550:	80 2f       	mov	r24, r16
    2552:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2556:	80 91 9b 01 	lds	r24, 0x019B
    255a:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    255e:	f8 2e       	mov	r15, r24
    2560:	80 2f       	mov	r24, r16
    2562:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2566:	80 91 98 01 	lds	r24, 0x0198
    256a:	83 30       	cpi	r24, 0x03	; 3
    256c:	29 f4       	brne	.+10     	; 0x2578 <ISPCC_EnterChipProgrammingMode+0x6a>
    256e:	80 91 9c 01 	lds	r24, 0x019C
    2572:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    2576:	05 c0       	rjmp	.+10     	; 0x2582 <ISPCC_EnterChipProgrammingMode+0x74>
    2578:	80 91 9c 01 	lds	r24, 0x019C
    257c:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    2580:	f8 2e       	mov	r15, r24
    2582:	80 91 98 01 	lds	r24, 0x0198
    2586:	88 23       	and	r24, r24
    2588:	21 f0       	breq	.+8      	; 0x2592 <ISPCC_EnterChipProgrammingMode+0x84>
    258a:	80 91 97 01 	lds	r24, 0x0197
    258e:	f8 16       	cp	r15, r24
    2590:	69 f4       	brne	.+26     	; 0x25ac <ISPCC_EnterChipProgrammingMode+0x9e>
    2592:	80 2f       	mov	r24, r16
    2594:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2598:	81 e0       	ldi	r24, 0x01	; 1
    259a:	80 93 a8 02 	sts	0x02A8, r24
    259e:	81 b3       	in	r24, 0x11	; 17
    25a0:	8f 7c       	andi	r24, 0xCF	; 207
    25a2:	80 62       	ori	r24, 0x20	; 32
    25a4:	81 bb       	out	0x11, r24	; 17
    25a6:	10 92 92 01 	sts	0x0192, r1
    25aa:	0e c0       	rjmp	.+28     	; 0x25c8 <ISPCC_EnterChipProgrammingMode+0xba>
    25ac:	80 2f       	mov	r24, r16
    25ae:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    25b2:	0e 94 3d 0a 	call	0x147a	; 0x147a <USI_SPIToggleClock>
    25b6:	11 50       	subi	r17, 0x01	; 1
    25b8:	00 f6       	brcc	.-128    	; 0x253a <ISPCC_EnterChipProgrammingMode+0x2c>
    25ba:	81 b3       	in	r24, 0x11	; 17
    25bc:	8f 7c       	andi	r24, 0xCF	; 207
    25be:	80 61       	ori	r24, 0x10	; 16
    25c0:	81 bb       	out	0x11, r24	; 17
    25c2:	80 ec       	ldi	r24, 0xC0	; 192
    25c4:	80 93 92 01 	sts	0x0192, r24
    25c8:	1f 91       	pop	r17
    25ca:	0f 91       	pop	r16
    25cc:	ff 90       	pop	r15
    25ce:	08 95       	ret

000025d0 <AICI_InterpretPacket>:

// ======================================================================================

void AICI_InterpretPacket(void)
{
    25d0:	df 92       	push	r13
    25d2:	ef 92       	push	r14
    25d4:	ff 92       	push	r15
    25d6:	0f 93       	push	r16
    25d8:	1f 93       	push	r17
    25da:	cf 93       	push	r28
    25dc:	df 93       	push	r29
	switch (PacketBytes[0])
    25de:	80 91 91 01 	lds	r24, 0x0191
    25e2:	86 31       	cpi	r24, 0x16	; 22
    25e4:	09 f4       	brne	.+2      	; 0x25e8 <AICI_InterpretPacket+0x18>
    25e6:	e5 c0       	rjmp	.+458    	; 0x27b2 <AICI_InterpretPacket+0x1e2>
    25e8:	87 31       	cpi	r24, 0x17	; 23
    25ea:	78 f4       	brcc	.+30     	; 0x260a <AICI_InterpretPacket+0x3a>
    25ec:	82 31       	cpi	r24, 0x12	; 18
    25ee:	09 f4       	brne	.+2      	; 0x25f2 <AICI_InterpretPacket+0x22>
    25f0:	52 c0       	rjmp	.+164    	; 0x2696 <AICI_InterpretPacket+0xc6>
    25f2:	83 31       	cpi	r24, 0x13	; 19
    25f4:	30 f4       	brcc	.+12     	; 0x2602 <AICI_InterpretPacket+0x32>
    25f6:	80 31       	cpi	r24, 0x10	; 16
    25f8:	d9 f0       	breq	.+54     	; 0x2630 <AICI_InterpretPacket+0x60>
    25fa:	81 31       	cpi	r24, 0x11	; 17
    25fc:	09 f0       	breq	.+2      	; 0x2600 <AICI_InterpretPacket+0x30>
    25fe:	2c c1       	rjmp	.+600    	; 0x2858 <AICI_InterpretPacket+0x288>
    2600:	30 c0       	rjmp	.+96     	; 0x2662 <AICI_InterpretPacket+0x92>
    2602:	84 31       	cpi	r24, 0x14	; 20
    2604:	09 f0       	breq	.+2      	; 0x2608 <AICI_InterpretPacket+0x38>
    2606:	1d c1       	rjmp	.+570    	; 0x2842 <AICI_InterpretPacket+0x272>
    2608:	d4 c0       	rjmp	.+424    	; 0x27b2 <AICI_InterpretPacket+0x1e2>
    260a:	89 31       	cpi	r24, 0x19	; 25
    260c:	09 f4       	brne	.+2      	; 0x2610 <AICI_InterpretPacket+0x40>
    260e:	bd c0       	rjmp	.+378    	; 0x278a <AICI_InterpretPacket+0x1ba>
    2610:	8a 31       	cpi	r24, 0x1A	; 26
    2612:	38 f4       	brcc	.+14     	; 0x2622 <AICI_InterpretPacket+0x52>
    2614:	87 31       	cpi	r24, 0x17	; 23
    2616:	09 f4       	brne	.+2      	; 0x261a <AICI_InterpretPacket+0x4a>
    2618:	b8 c0       	rjmp	.+368    	; 0x278a <AICI_InterpretPacket+0x1ba>
    261a:	88 31       	cpi	r24, 0x18	; 24
    261c:	09 f0       	breq	.+2      	; 0x2620 <AICI_InterpretPacket+0x50>
    261e:	1c c1       	rjmp	.+568    	; 0x2858 <AICI_InterpretPacket+0x288>
    2620:	95 c0       	rjmp	.+298    	; 0x274c <AICI_InterpretPacket+0x17c>
    2622:	8d 31       	cpi	r24, 0x1D	; 29
    2624:	08 f4       	brcc	.+2      	; 0x2628 <AICI_InterpretPacket+0x58>
    2626:	92 c0       	rjmp	.+292    	; 0x274c <AICI_InterpretPacket+0x17c>
    2628:	8d 31       	cpi	r24, 0x1D	; 29
    262a:	09 f0       	breq	.+2      	; 0x262e <AICI_InterpretPacket+0x5e>
    262c:	15 c1       	rjmp	.+554    	; 0x2858 <AICI_InterpretPacket+0x288>
    262e:	56 c0       	rjmp	.+172    	; 0x26dc <AICI_InterpretPacket+0x10c>
	{
		case AICB_CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
    2630:	82 e0       	ldi	r24, 0x02	; 2
    2632:	90 e0       	ldi	r25, 0x00	; 0
    2634:	90 93 a7 02 	sts	0x02A7, r25
    2638:	80 93 a6 02 	sts	0x02A6, r24
			
			USI_SPIInitMaster();
    263c:	0e 94 2d 0a 	call	0x145a	; 0x145a <USI_SPIInitMaster>

			MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);  // Pull the slave AVR's RESET line to active
    2640:	80 e0       	ldi	r24, 0x00	; 0
    2642:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
			ISPCC_EnterChipProgrammingMode();       // Run the Enter Programming Mode routine
    2646:	0e 94 87 12 	call	0x250e	; 0x250e <ISPCC_EnterChipProgrammingMode>

			if (InProgrammingMode)
    264a:	80 91 a8 02 	lds	r24, 0x02A8
    264e:	88 23       	and	r24, r24
    2650:	19 f0       	breq	.+6      	; 0x2658 <AICI_InterpretPacket+0x88>
			   LCD_puts_f(AVRISPModeMessage);
    2652:	86 e3       	ldi	r24, 0x36	; 54
    2654:	94 e0       	ldi	r25, 0x04	; 4
    2656:	02 c0       	rjmp	.+4      	; 0x265c <AICI_InterpretPacket+0x8c>
			else
			   LCD_puts_f(SyncErrorMessage);
    2658:	8b e2       	ldi	r24, 0x2B	; 43
    265a:	94 e0       	ldi	r25, 0x04	; 4
    265c:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
    2660:	04 c1       	rjmp	.+520    	; 0x286a <AICI_InterpretPacket+0x29a>
			
			break;
		case AICB_CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;
    2662:	82 e0       	ldi	r24, 0x02	; 2
    2664:	90 e0       	ldi	r25, 0x00	; 0
    2666:	90 93 a7 02 	sts	0x02A7, r25
    266a:	80 93 a6 02 	sts	0x02A6, r24

			MAIN_Delay1MS(PacketBytes[1]);           // Wait for the "PreDelay" amount specified in the packet
    266e:	80 91 92 01 	lds	r24, 0x0192
    2672:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Non programming mode = green status led
    2676:	81 b3       	in	r24, 0x11	; 17
    2678:	8f 7c       	andi	r24, 0xCF	; 207
    267a:	80 61       	ori	r24, 0x10	; 16
    267c:	81 bb       	out	0x11, r24	; 17
			InProgrammingMode = FALSE;
    267e:	10 92 a8 02 	sts	0x02A8, r1
			MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run
    2682:	81 e0       	ldi	r24, 0x01	; 1
    2684:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
			MAIN_Delay1MS(PacketBytes[2]);           // Wait for the "PostDelay" amount specified in the packet
    2688:	80 91 93 01 	lds	r24, 0x0193
    268c:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
			
			USI_SPIOff();
    2690:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <USI_SPIOff>
    2694:	de c0       	rjmp	.+444    	; 0x2852 <AICI_InterpretPacket+0x282>

			PacketBytes[1] = AICB_STATUS_CMD_OK;     // Return OK

			break;
		case AICB_CMD_CHIP_ERASE_ISP:
			MessageSize = 2;
    2696:	82 e0       	ldi	r24, 0x02	; 2
    2698:	90 e0       	ldi	r25, 0x00	; 0
    269a:	90 93 a7 02 	sts	0x02A7, r25
    269e:	80 93 a6 02 	sts	0x02A6, r24
    26a2:	c4 e9       	ldi	r28, 0x94	; 148
    26a4:	d1 e0       	ldi	r29, 0x01	; 1
			
			for (uint8_t PacketB = 3; PacketB <= 6; PacketB++) // Send the erase commands to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    26a6:	89 91       	ld	r24, Y+
    26a8:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    26ac:	81 e0       	ldi	r24, 0x01	; 1
    26ae:	c8 39       	cpi	r28, 0x98	; 152
    26b0:	d8 07       	cpc	r29, r24
    26b2:	c9 f7       	brne	.-14     	; 0x26a6 <AICI_InterpretPacket+0xd6>

			if (PacketBytes[2])                       // Poll mode, value of 1 indicates a busy flag wait
    26b4:	80 91 93 01 	lds	r24, 0x0193
    26b8:	88 23       	and	r24, r24
    26ba:	59 f0       	breq	.+22     	; 0x26d2 <AICI_InterpretPacket+0x102>
			{
				do
					USI_SPITransmitWord(0xF000);
    26bc:	80 e0       	ldi	r24, 0x00	; 0
    26be:	90 ef       	ldi	r25, 0xF0	; 240
    26c0:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
				while (USI_SPITransmitWord(0x0000) & 0x01);
    26c4:	80 e0       	ldi	r24, 0x00	; 0
    26c6:	90 e0       	ldi	r25, 0x00	; 0
    26c8:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
    26cc:	80 ff       	sbrs	r24, 0
    26ce:	c1 c0       	rjmp	.+386    	; 0x2852 <AICI_InterpretPacket+0x282>
    26d0:	f5 cf       	rjmp	.-22     	; 0x26bc <AICI_InterpretPacket+0xec>
			}
			else                                      // Poll mode flag of 0 indicates a predefined delay
			{
				MAIN_Delay1MS(PacketBytes[1]);         // Wait the specified interval to ensure erase complete
    26d2:	80 91 92 01 	lds	r24, 0x0192
    26d6:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    26da:	bb c0       	rjmp	.+374    	; 0x2852 <AICI_InterpretPacket+0x282>
			}
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Always return OK
			
			break;
		case AICB_CMD_SPI_MULTI:
				MessageSize = (3 + PacketBytes[2]);    // Number of recieved bytes, plus two OKs and the command byte
    26dc:	f0 90 93 01 	lds	r15, 0x0193
    26e0:	8f 2d       	mov	r24, r15
    26e2:	99 27       	eor	r25, r25
    26e4:	03 96       	adiw	r24, 0x03	; 3
    26e6:	90 93 a7 02 	sts	0x02A7, r25
    26ea:	80 93 a6 02 	sts	0x02A6, r24
		
				uint8_t TxBytes      = PacketBytes[1]; // \. The packet data is overwritten during the transfer. Because
    26ee:	d0 90 92 01 	lds	r13, 0x0192
				uint8_t RxStartByte  = PacketBytes[2]; // |  of this each data byte must be stored into temp variables
				uint8_t RxBytes      = PacketBytes[3]; // /  so that their contents are not lost.
    26f2:	e0 90 94 01 	lds	r14, 0x0194
    26f6:	11 e0       	ldi	r17, 0x01	; 1
    26f8:	01 e0       	ldi	r16, 0x01	; 1
    26fa:	12 c0       	rjmp	.+36     	; 0x2720 <AICI_InterpretPacket+0x150>
				uint8_t RxByteNum    = 1;
				uint8_t TxByteNum    = 1;
				uint8_t RecievedByte = 0;

				while (TxByteNum++ < TxBytes)          // Still bytes to transfer
    26fc:	0f 5f       	subi	r16, 0xFF	; 255
				{
					RecievedByte = USI_SPITransmit(PacketBytes[3 + TxByteNum]); // Transmit the byte, store the answer
    26fe:	e0 2f       	mov	r30, r16
    2700:	ff 27       	eor	r31, r31
    2702:	ef 56       	subi	r30, 0x6F	; 111
    2704:	fe 4f       	sbci	r31, 0xFE	; 254
    2706:	83 81       	ldd	r24, Z+3	; 0x03
    2708:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>

					if ((TxByteNum >= RxStartByte) && (RxByteNum < RxBytes))
    270c:	0f 15       	cp	r16, r15
    270e:	40 f0       	brcs	.+16     	; 0x2720 <AICI_InterpretPacket+0x150>
    2710:	1e 15       	cp	r17, r14
    2712:	30 f4       	brcc	.+12     	; 0x2720 <AICI_InterpretPacket+0x150>
					   PacketBytes[2 + RxByteNum++] = RecievedByte;
    2714:	e1 2f       	mov	r30, r17
    2716:	ff 27       	eor	r31, r31
    2718:	ef 56       	subi	r30, 0x6F	; 111
    271a:	fe 4f       	sbci	r31, 0xFE	; 254
    271c:	82 83       	std	Z+2, r24	; 0x02
    271e:	1f 5f       	subi	r17, 0xFF	; 255
    2720:	0d 15       	cp	r16, r13
    2722:	60 f3       	brcs	.-40     	; 0x26fc <AICI_InterpretPacket+0x12c>
    2724:	06 c0       	rjmp	.+12     	; 0x2732 <AICI_InterpretPacket+0x162>
				}

				while (RxByteNum++ < RxBytes)                         // Still more bytes to recieve
				   PacketBytes[2 + RxByteNum] = USI_SPITransmit(0x00); // its answer to be recorded (or more bytes than sent need responses), send dummy bytes to fetch the response(s)
    2726:	80 e0       	ldi	r24, 0x00	; 0
    2728:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    272c:	cf 56       	subi	r28, 0x6F	; 111
    272e:	de 4f       	sbci	r29, 0xFE	; 254
    2730:	8a 83       	std	Y+2, r24	; 0x02
    2732:	1f 5f       	subi	r17, 0xFF	; 255
    2734:	81 2f       	mov	r24, r17
    2736:	81 50       	subi	r24, 0x01	; 1
    2738:	c1 2f       	mov	r28, r17
    273a:	dd 27       	eor	r29, r29
    273c:	8e 15       	cp	r24, r14
    273e:	98 f3       	brcs	.-26     	; 0x2726 <AICI_InterpretPacket+0x156>

				PacketBytes[1]             = AICB_STATUS_CMD_OK; // Data should be encompassed
    2740:	10 92 92 01 	sts	0x0192, r1
				PacketBytes[3 + RxByteNum] = AICB_STATUS_CMD_OK; //  by STATS_CMD_OKs
    2744:	cf 56       	subi	r28, 0x6F	; 111
    2746:	de 4f       	sbci	r29, 0xFE	; 254
    2748:	1b 82       	std	Y+3, r1	; 0x03
    274a:	8f c0       	rjmp	.+286    	; 0x286a <AICI_InterpretPacket+0x29a>

				break;
		case AICB_CMD_READ_SIGNATURE_ISP:
		case AICB_CMD_READ_FUSE_ISP:
		case AICB_CMD_READ_LOCK_ISP:
		case AICB_CMD_READ_OSCCAL_ISP:
			MessageSize = 4;
    274c:	84 e0       	ldi	r24, 0x04	; 4
    274e:	90 e0       	ldi	r25, 0x00	; 0
    2750:	90 93 a7 02 	sts	0x02A7, r25
    2754:	80 93 a6 02 	sts	0x02A6, r24
    2758:	c1 e0       	ldi	r28, 0x01	; 1
    275a:	d0 e0       	ldi	r29, 0x00	; 0
    275c:	03 e9       	ldi	r16, 0x93	; 147
    275e:	11 e0       	ldi	r17, 0x01	; 1
	
			for (uint8_t ByteNum = 1; ByteNum <= 4; ByteNum++)
			{
				uint8_t Response = USI_SPITransmit(PacketBytes[1 + ByteNum]); // Transmit the four signature request bytes
    2760:	f8 01       	movw	r30, r16
    2762:	81 91       	ld	r24, Z+
    2764:	8f 01       	movw	r16, r30
    2766:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    276a:	98 2f       	mov	r25, r24

				if (ByteNum == PacketBytes[1])         // If the current byte is the requested signature byte, save the reponse in the packet
    276c:	80 91 92 01 	lds	r24, 0x0192
    2770:	8c 17       	cp	r24, r28
    2772:	11 f4       	brne	.+4      	; 0x2778 <AICI_InterpretPacket+0x1a8>
					PacketBytes[2] = Response;
    2774:	90 93 93 01 	sts	0x0193, r25
    2778:	21 96       	adiw	r28, 0x01	; 1
    277a:	c5 30       	cpi	r28, 0x05	; 5
    277c:	d1 05       	cpc	r29, r1
    277e:	81 f7       	brne	.-32     	; 0x2760 <AICI_InterpretPacket+0x190>
			}

			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Data byte is encased in CMD_OKs
    2780:	10 92 92 01 	sts	0x0192, r1
			PacketBytes[3] = AICB_STATUS_CMD_OK;       // Data byte is encased in CMD_OKs
    2784:	10 92 94 01 	sts	0x0194, r1
    2788:	70 c0       	rjmp	.+224    	; 0x286a <AICI_InterpretPacket+0x29a>

			break;
		case AICB_CMD_PROGRAM_FUSE_ISP:
		case AICB_CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;
    278a:	83 e0       	ldi	r24, 0x03	; 3
    278c:	90 e0       	ldi	r25, 0x00	; 0
    278e:	90 93 a7 02 	sts	0x02A7, r25
    2792:	80 93 a6 02 	sts	0x02A6, r24
    2796:	c2 e9       	ldi	r28, 0x92	; 146
    2798:	d1 e0       	ldi	r29, 0x01	; 1
			
			for (uint8_t PacketB = 1; PacketB <= 4; PacketB++) // Send the lock-byte values to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    279a:	89 91       	ld	r24, Y+
    279c:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    27a0:	f1 e0       	ldi	r31, 0x01	; 1
    27a2:	c6 39       	cpi	r28, 0x96	; 150
    27a4:	df 07       	cpc	r29, r31
    27a6:	c9 f7       	brne	.-14     	; 0x279a <AICI_InterpretPacket+0x1ca>

			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Two CMD_OKs are always returned
    27a8:	10 92 92 01 	sts	0x0192, r1
			PacketBytes[2] = AICB_STATUS_CMD_OK;       // Two CMD_OKs are always returned
    27ac:	10 92 93 01 	sts	0x0193, r1
    27b0:	5c c0       	rjmp	.+184    	; 0x286a <AICI_InterpretPacket+0x29a>

			break;
		case AICB_CMD_READ_FLASH_ISP:
		case AICB_CMD_READ_EEPROM_ISP:
			MessageSize = 0;                           // Here to prevent compiler from complaining if a var dec appears straight after a case

			uint8_t  ReadCommand = PacketBytes[3];
    27b2:	d0 90 94 01 	lds	r13, 0x0194
			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8) // Load in the number of bytes that is to
			                     | PacketBytes[2];                 // be read into a temp variable (MSB first)
    27b6:	80 91 92 01 	lds	r24, 0x0192
    27ba:	99 27       	eor	r25, r25
    27bc:	d8 2f       	mov	r29, r24
    27be:	cc 27       	eor	r28, r28
    27c0:	80 91 93 01 	lds	r24, 0x0193
    27c4:	99 27       	eor	r25, r25
    27c6:	c8 2b       	or	r28, r24
    27c8:	d9 2b       	or	r29, r25

			MessageSize = BytesToRead + 3;
    27ca:	23 96       	adiw	r28, 0x03	; 3
    27cc:	d0 93 a7 02 	sts	0x02A7, r29
    27d0:	c0 93 a6 02 	sts	0x02A6, r28
    27d4:	23 97       	sbiw	r28, 0x03	; 3
    27d6:	00 e0       	ldi	r16, 0x00	; 0
    27d8:	10 e0       	ldi	r17, 0x00	; 0
    27da:	83 e9       	ldi	r24, 0x93	; 147
    27dc:	e8 2e       	mov	r14, r24
    27de:	81 e0       	ldi	r24, 0x01	; 1
    27e0:	f8 2e       	mov	r15, r24
    27e2:	26 c0       	rjmp	.+76     	; 0x2830 <AICI_InterpretPacket+0x260>

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
				if (PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)  // Flash read mode - word addresses so MSB/LSB masking nessesary
    27e4:	80 91 91 01 	lds	r24, 0x0191
    27e8:	84 31       	cpi	r24, 0x14	; 20
    27ea:	39 f4       	brne	.+14     	; 0x27fa <AICI_InterpretPacket+0x22a>
				{
					USI_SPITransmit(ReadCommand | ((ReadByte & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ));
    27ec:	00 ff       	sbrs	r16, 0
    27ee:	02 c0       	rjmp	.+4      	; 0x27f4 <AICI_InterpretPacket+0x224>
    27f0:	88 e0       	ldi	r24, 0x08	; 8
    27f2:	01 c0       	rjmp	.+2      	; 0x27f6 <AICI_InterpretPacket+0x226>
    27f4:	80 e0       	ldi	r24, 0x00	; 0
    27f6:	8d 29       	or	r24, r13
    27f8:	01 c0       	rjmp	.+2      	; 0x27fc <AICI_InterpretPacket+0x22c>
				}
				else                                       // EEPROM read mode, address is in bytes and so no masking nessesary
				{
					USI_SPITransmit(ReadCommand);
    27fa:	8d 2d       	mov	r24, r13
    27fc:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
				}
				
				USI_SPITransmitWord(CurrAddress);          // Transmit the current address to the slave AVR
    2800:	80 91 a9 02 	lds	r24, 0x02A9
    2804:	90 91 aa 02 	lds	r25, 0x02AA
    2808:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>

				PacketBytes[2 + ReadByte] = USI_SPITransmit(0x00); // Read in the byte stored at the requested location
    280c:	80 e0       	ldi	r24, 0x00	; 0
    280e:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    2812:	f7 01       	movw	r30, r14
    2814:	80 83       	st	Z, r24

				if ((ReadByte & 0x01) || (PacketBytes[0] == AICB_CMD_READ_EEPROM_ISP)) // Flash addresses are given in words; only increment on the odd byte if reading the flash.
    2816:	00 fd       	sbrc	r16, 0
    2818:	04 c0       	rjmp	.+8      	; 0x2822 <AICI_InterpretPacket+0x252>
    281a:	80 91 91 01 	lds	r24, 0x0191
    281e:	86 31       	cpi	r24, 0x16	; 22
    2820:	11 f4       	brne	.+4      	; 0x2826 <AICI_InterpretPacket+0x256>
				{
					V2P_IncrementCurrAddress();             // Increment the address counter
    2822:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <V2P_IncrementCurrAddress>
    2826:	0f 5f       	subi	r16, 0xFF	; 255
    2828:	1f 4f       	sbci	r17, 0xFF	; 255
    282a:	08 94       	sec
    282c:	e1 1c       	adc	r14, r1
    282e:	f1 1c       	adc	r15, r1
    2830:	0c 17       	cp	r16, r28
    2832:	1d 07       	cpc	r17, r29
    2834:	b9 f6       	brne	.-82     	; 0x27e4 <AICI_InterpretPacket+0x214>
				}
				else
				{
					if ((CurrAddress & 0x00FF0000) & !(CurrAddress & 0x0000FFFF))
					{
						CurrAddress |= (1UL << 31);        // Set MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
						V2P_CheckForExtendedAddress();
					}
				}
			}
			
			PacketBytes[1]               = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    2836:	10 92 92 01 	sts	0x0192, r1
			PacketBytes[2 + BytesToRead] = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    283a:	cf 56       	subi	r28, 0x6F	; 111
    283c:	de 4f       	sbci	r29, 0xFE	; 254
    283e:	1a 82       	std	Y+2, r1	; 0x02
    2840:	14 c0       	rjmp	.+40     	; 0x286a <AICI_InterpretPacket+0x29a>

			break;
		case AICB_CMD_PROGRAM_FLASH_ISP:
		case AICB_CMD_PROGRAM_EEPROM_ISP:
			ISPCC_ProgramChip();                         // Program the bytes into the chip
    2842:	0e 94 87 11 	call	0x230e	; 0x230e <ISPCC_ProgramChip>
			
			MessageSize = 2;
    2846:	82 e0       	ldi	r24, 0x02	; 2
    2848:	90 e0       	ldi	r25, 0x00	; 0
    284a:	90 93 a7 02 	sts	0x02A7, r25
    284e:	80 93 a6 02 	sts	0x02A6, r24

			PacketBytes[1] = AICB_STATUS_CMD_OK;
    2852:	10 92 92 01 	sts	0x0192, r1
    2856:	09 c0       	rjmp	.+18     	; 0x286a <AICI_InterpretPacket+0x29a>
			
			break;
		default:                                        // Unknown command, return error
			MessageSize = 1;
    2858:	81 e0       	ldi	r24, 0x01	; 1
    285a:	90 e0       	ldi	r25, 0x00	; 0
    285c:	90 93 a7 02 	sts	0x02A7, r25
    2860:	80 93 a6 02 	sts	0x02A6, r24
			
			PacketBytes[1] = AICB_STATUS_CMD_UNKNOWN;
    2864:	89 ec       	ldi	r24, 0xC9	; 201
    2866:	80 93 92 01 	sts	0x0192, r24
	}

	V2P_SendPacket();                                    // Send the response packet
    286a:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <V2P_SendPacket>
    286e:	df 91       	pop	r29
    2870:	cf 91       	pop	r28
    2872:	1f 91       	pop	r17
    2874:	0f 91       	pop	r16
    2876:	ff 90       	pop	r15
    2878:	ef 90       	pop	r14
    287a:	df 90       	pop	r13
    287c:	08 95       	ret

0000287e <PM_SetupDFAddressCounters>:
	  return ProgDataSize;
}

void PM_SetupDFAddressCounters(const uint8_t Type)
{
    287e:	80 93 02 01 	sts	0x0102, r24
	uint32_t StartAddress;
	
	MemoryType  = Type;
	GPageLength = 0;
    2882:	10 92 b0 02 	sts	0x02B0, r1
    2886:	10 92 af 02 	sts	0x02AF, r1
    288a:	20 91 a9 02 	lds	r18, 0x02A9
    288e:	30 91 aa 02 	lds	r19, 0x02AA
    2892:	40 91 ab 02 	lds	r20, 0x02AB
    2896:	50 91 ac 02 	lds	r21, 0x02AC

	if (Type == TYPE_FLASH)                                             // Type 1 = Flash
    289a:	81 30       	cpi	r24, 0x01	; 1
    289c:	39 f4       	brne	.+14     	; 0x28ac <PM_SetupDFAddressCounters+0x2e>
	  StartAddress = (CurrAddress << 1);                                // Convert flash word address to byte address
    289e:	da 01       	movw	r26, r20
    28a0:	c9 01       	movw	r24, r18
    28a2:	88 0f       	add	r24, r24
    28a4:	99 1f       	adc	r25, r25
    28a6:	aa 1f       	adc	r26, r26
    28a8:	bb 1f       	adc	r27, r27
    28aa:	06 c0       	rjmp	.+12     	; 0x28b8 <PM_SetupDFAddressCounters+0x3a>
	else
	  StartAddress = CurrAddress + PM_EEPROM_OFFSET;                    // EEPROM uses byte addresses, and starts at the 257th kilobyte in Dataflash
    28ac:	da 01       	movw	r26, r20
    28ae:	c9 01       	movw	r24, r18
    28b0:	80 50       	subi	r24, 0x00	; 0
    28b2:	9c 4f       	sbci	r25, 0xFC	; 252
    28b4:	ab 4f       	sbci	r26, 0xFB	; 251
    28b6:	bf 4f       	sbci	r27, 0xFF	; 255
	
	DataflashInfo.CurrPageAddress = 0;
    28b8:	10 92 44 01 	sts	0x0144, r1
    28bc:	10 92 43 01 	sts	0x0143, r1
    28c0:	20 e0       	ldi	r18, 0x00	; 0
    28c2:	30 e0       	ldi	r19, 0x00	; 0
    28c4:	06 c0       	rjmp	.+12     	; 0x28d2 <PM_SetupDFAddressCounters+0x54>

	while (StartAddress >= DF_INTERNALDF_BUFFBYTES)                     // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DF_INTERNALDF_BUFFBYTES;                        // Subtract one page's worth of bytes from the desired address
    28c6:	88 50       	subi	r24, 0x08	; 8
    28c8:	91 40       	sbci	r25, 0x01	; 1
    28ca:	a0 40       	sbci	r26, 0x00	; 0
    28cc:	b0 40       	sbci	r27, 0x00	; 0
    28ce:	2f 5f       	subi	r18, 0xFF	; 255
    28d0:	3f 4f       	sbci	r19, 0xFF	; 255
    28d2:	88 30       	cpi	r24, 0x08	; 8
    28d4:	41 e0       	ldi	r20, 0x01	; 1
    28d6:	94 07       	cpc	r25, r20
    28d8:	40 e0       	ldi	r20, 0x00	; 0
    28da:	a4 07       	cpc	r26, r20
    28dc:	40 e0       	ldi	r20, 0x00	; 0
    28de:	b4 07       	cpc	r27, r20
    28e0:	90 f7       	brcc	.-28     	; 0x28c6 <PM_SetupDFAddressCounters+0x48>
    28e2:	30 93 44 01 	sts	0x0144, r19
    28e6:	20 93 43 01 	sts	0x0143, r18
		DataflashInfo.CurrPageAddress++;
	}
	
	DataflashInfo.CurrBuffByte = (uint16_t)StartAddress;                // The buffer byte is the remainder
    28ea:	90 93 46 01 	sts	0x0146, r25
    28ee:	80 93 45 01 	sts	0x0145, r24
    28f2:	08 95       	ret

000028f4 <PM_CheckEndOfFuseLockData>:
}

void PM_StoreProgramByte(const uint8_t Data)
{
	if (DataflashInfo.CurrBuffByte == DF_INTERNALDF_BUFFBYTES)          // Finished current dataflash buffer page; write it to dataflash and get ready for the next one
	{
		DF_CopyBufferToFlashPage(DataflashInfo.CurrPageAddress++);
		DF_BufferWriteEnable(0);
		DataflashInfo.CurrBuffByte = 0;
	}
	
	SPI_SPITransmit(Data);                                              // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
	DataflashInfo.CurrBuffByte++;
	GPageLength++;
}

void PM_InterpretAVRISPPacket(void)
{
	uint8_t* EEPROMAddress;

	switch (PacketBytes[0])
	{
		case AICB_CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
						
			for (uint8_t PacketB = 0; PacketB <= 11; PacketB++)         // Save the enter programming mode command bytes
			  eeprom_write_byte(&EEPROMVars.EnterProgMode[PacketB], PacketBytes[PacketB]);
			
			InProgrammingMode = TRUE;                                   // Set the flag, prevent the user from exiting the V2P state machine			
			CurrentMode = PM_NO_SETUP;                                  // Clear the current mode variable

			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = AICB_STATUS_CMD_OK;

			break;			
		case AICB_CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;

			PM_CheckEndOfFuseLockData();                                // Check for remaining bytes to be stored and general cleanup
			
			InProgrammingMode = FALSE;                                  // Clear the flag, allow the user to exit the V2P state machine

			DF_EnableDataflash(FALSE);

			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
			PacketBytes[1] = AICB_STATUS_CMD_OK;

			break;
		case AICB_CMD_READ_SIGNATURE_ISP:
			MessageSize = 4;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x01;                                      // Signature bytes all return "01" in storage mode
			PacketBytes[3] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_CHIP_ERASE_ISP:
			MessageSize = 2;

			for (uint8_t PacketB = 1; PacketB < 7; PacketB++)           // Save the erase chip command bytes to EEPROM
			  eeprom_write_byte(&EEPROMVars.EraseChip[PacketB], PacketBytes[PacketB]);

			for (uint8_t Byte = 0; Byte < 4; Byte++)                    // Clear the program and EEPROM size counters
			{
				eeprom_write_byte(&EEPROMVars.DataSize[Byte], 0x00);
				eeprom_write_byte(&EEPROMVars.EEPROMSize[Byte], 0x00);
			}
						
			eeprom_write_byte(&EEPROMVars.EraseCmdStored, TRUE);
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;
			
			break;
		case AICB_CMD_READ_OSCCAL_ISP:
			MessageSize = 4;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x00;                                      // Return 0x00 for the OSCCAL byte
			PacketBytes[3] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_PROGRAM_FUSE_ISP:
		case AICB_CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;

			if (CurrentMode != PM_LOCKFUSEBITS_WRITE)                   // First lock or fuse byte being written, set the EEPROM pointer
			{
				CurrentMode   = PM_LOCKFUSEBITS_WRITE;
				DataflashInfo.CurrBuffByte  = 0;                        // CurrBuffByte is used to store the total fuse/lock bytes written
			}

			if (PacketBytes[0] == AICB_CMD_PROGRAM_FUSE_ISP)
			{
				EEPROMAddress = &EEPROMVars.FuseBytes[DataflashInfo.CurrBuffByte][0];
				MemoryType    = TYPE_FUSE;
			}
			else
			{
				EEPROMAddress = &EEPROMVars.LockBytes[DataflashInfo.CurrBuffByte][0];
				MemoryType    = TYPE_LOCK;
			}				
			
			if (DataflashInfo.CurrBuffByte < PM_MAX_FUSELOCKBITS)
			{
				for (uint8_t FLByte = 1; FLByte < 5; FLByte++)
				{
					eeprom_write_byte(EEPROMAddress, PacketBytes[FLByte]);
					EEPROMAddress++;
				}

				DataflashInfo.CurrBuffByte++;                           // Increment the total fuse/lock bytes written counter
			}
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;                        // Two CMD_OKs are always returned
			PacketBytes[2] = AICB_STATUS_CMD_OK;                        // Two CMD_OKs are always returned

			break;
		case AICB_CMD_READ_FUSE_ISP:
		case AICB_CMD_READ_LOCK_ISP:
			MessageSize = 4;
	
			if (CurrentMode != PM_LOCKFUSEBITS_READ)                    // First lock or fuse byte being read, set the EEPROM pointer
			{
				PM_CheckEndOfFuseLockData();                            // Check for remaining bytes to be stored and general cleanup
				
				DataflashInfo.CurrBuffByte = 0;
				CurrentMode  = PM_LOCKFUSEBITS_READ;
			}
			
			if (DataflashInfo.CurrBuffByte > eeprom_read_byte((PacketBytes[0] == AICB_CMD_READ_FUSE_ISP)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes))  // Trying to read more fuse/lock bytes than are stored in memory
			{
				PacketBytes[2] = 0xFF;                                  // Return 0xFF for the fuse/lock byte
			}
			else
			{
				uint8_t FuseLockNum  = DataflashInfo.CurrBuffByte;
				uint8_t FuseLockByte = (PacketBytes[1] - 1);
				
				PacketBytes[2] = eeprom_read_byte((uint8_t*)(((PacketBytes[0] == AICB_CMD_READ_FUSE_ISP)? &EEPROMVars.FuseBytes[FuseLockNum][FuseLockByte] : &EEPROMVars.LockBytes[FuseLockNum][FuseLockByte])));
			}

			DataflashInfo.CurrBuffByte++;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs
			PacketBytes[3] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_PROGRAM_FLASH_ISP:
		case AICB_CMD_PROGRAM_EEPROM_ISP:
			MessageSize = 2;

			if (CurrentMode != PM_DATAFLASH_WRITE)                      // First programming packet
			{
				if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP)       // Flash programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram; // Set the eeprom address to the Program command bytes location
					PM_SetupDFAddressCounters(TYPE_FLASH);
				}
				else                                                    // EEPROM programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;  // Set the eeprom address to the EEPROM command bytes location
					PM_SetupDFAddressCounters(TYPE_EEPROM);
				}
				
				DF_BufferWriteEnable(DataflashInfo.CurrBuffByte);
				CurrentMode = PM_DATAFLASH_WRITE;
				
				for (uint8_t B = 1; B < 10; B++)                        // Save the command bytes
				{
					eeprom_write_byte(EEPROMAddress, PacketBytes[B]);
					EEPROMAddress++;
				}
			}

			uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
			                      | PacketBytes[2];

			for (uint16_t CurrByte = 0; CurrByte < BytesToWrite; CurrByte++)
			  PM_StoreProgramByte(PacketBytes[10 + CurrByte]);

			if (!(GPageLength & PM_PAGELENGTH_FOUNDBIT) && (PacketBytes[3] & ISPCC_PROG_MODE_PAGEDONE) && GPageLength)
			{
				eeprom_write_word(((MemoryType == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength), GPageLength);
		
				GPageLength |= PM_PAGELENGTH_FOUNDBIT;                  // Bit 15 is used to indicate if the length has been found
			}

			PacketBytes[1] = AICB_STATUS_CMD_OK;
		
			break;
		case AICB_CMD_READ_FLASH_ISP:
		case AICB_CMD_READ_EEPROM_ISP:	
			if (CurrentMode != PM_DATAFLASH_READ)
			{
				PM_CheckEndOfFuseLockData();                            // Check for remaining bytes to be stored and general cleanup
				
				PM_SetupDFAddressCounters((PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);
				DF_ContinuousReadEnable(DataflashInfo.CurrPageAddress, DataflashInfo.CurrBuffByte);
				
				CurrentMode = PM_DATAFLASH_READ;
				CurrAddress = 0;
			}

			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8)      // \. Load in the number of bytes that is to
			                     | PacketBytes[2];                      // /  be read into a temp variable (MSB first)
						
			uint16_t BytesInMem  = PM_GetStoredDataSize((PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
			   PacketBytes[2 + ReadByte] = ((CurrAddress < BytesInMem)? SPI_SPITransmit(0x00) : 0xFF); // Read in the next dataflash byte if present
			   V2P_IncrementCurrAddress();
			}
			
			MessageSize = BytesToRead + 3;

			PacketBytes[1]               = AICB_STATUS_CMD_OK;          // Return data should be encompassed in STATUS_CMD_OKs
			PacketBytes[2 + BytesToRead] = AICB_STATUS_CMD_OK;          // Return data should be encompassed in STATUS_CMD_OKs
		
			break;
		default:
			MessageSize = 1;
			
			PacketBytes[1] = AICB_STATUS_CMD_UNKNOWN;
	}

	V2P_SendPacket();                                                   // Send the response packet
}

void PM_CheckEndOfFuseLockData(void)
{
    28f4:	cf 93       	push	r28
    28f6:	df 93       	push	r29
    28f8:	cd b7       	in	r28, 0x3d	; 61
    28fa:	de b7       	in	r29, 0x3e	; 62
    28fc:	24 97       	sbiw	r28, 0x04	; 4
    28fe:	0f b6       	in	r0, 0x3f	; 63
    2900:	f8 94       	cli
    2902:	de bf       	out	0x3e, r29	; 62
    2904:	0f be       	out	0x3f, r0	; 63
    2906:	cd bf       	out	0x3d, r28	; 61
	if (CurrentMode == PM_DATAFLASH_WRITE)
    2908:	80 91 ae 02 	lds	r24, 0x02AE
    290c:	81 30       	cpi	r24, 0x01	; 1
    290e:	09 f0       	breq	.+2      	; 0x2912 <PM_CheckEndOfFuseLockData+0x1e>
    2910:	40 c0       	rjmp	.+128    	; 0x2992 <PM_CheckEndOfFuseLockData+0x9e>
	{
		if (DataflashInfo.CurrBuffByte)                                 // Data in the dataflash buffer, pending to be written
    2912:	80 91 45 01 	lds	r24, 0x0145
    2916:	90 91 46 01 	lds	r25, 0x0146
    291a:	89 2b       	or	r24, r25
    291c:	31 f0       	breq	.+12     	; 0x292a <PM_CheckEndOfFuseLockData+0x36>
		  DF_CopyBufferToFlashPage(DataflashInfo.CurrPageAddress);      // Save the remaining buffer bytes
    291e:	80 91 43 01 	lds	r24, 0x0143
    2922:	90 91 44 01 	lds	r25, 0x0144
    2926:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <DF_CopyBufferToFlashPage>

		uint32_t DataSize = ((DataflashInfo.CurrPageAddress * DF_INTERNALDF_BUFFBYTES) + DataflashInfo.CurrBuffByte);
    292a:	20 91 43 01 	lds	r18, 0x0143
    292e:	30 91 44 01 	lds	r19, 0x0144
    2932:	88 e0       	ldi	r24, 0x08	; 8
    2934:	91 e0       	ldi	r25, 0x01	; 1
    2936:	ac 01       	movw	r20, r24
    2938:	24 9f       	mul	r18, r20
    293a:	c0 01       	movw	r24, r0
    293c:	25 9f       	mul	r18, r21
    293e:	90 0d       	add	r25, r0
    2940:	34 9f       	mul	r19, r20
    2942:	90 0d       	add	r25, r0
    2944:	11 24       	eor	r1, r1
    2946:	20 91 45 01 	lds	r18, 0x0145
    294a:	30 91 46 01 	lds	r19, 0x0146
    294e:	82 0f       	add	r24, r18
    2950:	93 1f       	adc	r25, r19
    2952:	9c 01       	movw	r18, r24
    2954:	44 27       	eor	r20, r20
    2956:	55 27       	eor	r21, r21
    2958:	29 83       	std	Y+1, r18	; 0x01
    295a:	3a 83       	std	Y+2, r19	; 0x02
    295c:	4b 83       	std	Y+3, r20	; 0x03
    295e:	5c 83       	std	Y+4, r21	; 0x04

		if (MemoryType == TYPE_FLASH)
    2960:	80 91 02 01 	lds	r24, 0x0102
    2964:	fe 01       	movw	r30, r28
    2966:	31 96       	adiw	r30, 0x01	; 1
    2968:	81 30       	cpi	r24, 0x01	; 1
    296a:	21 f4       	brne	.+8      	; 0x2974 <PM_CheckEndOfFuseLockData+0x80>
            {
              uint8_t len;
              len = (uint8_t) n;

              asm volatile (
    296c:	84 e0       	ldi	r24, 0x04	; 4
    296e:	af e1       	ldi	r26, 0x1F	; 31
    2970:	b0 e0       	ldi	r27, 0x00	; 0
    2972:	0b c0       	rjmp	.+22     	; 0x298a <PM_CheckEndOfFuseLockData+0x96>
		{
			eeprom_write_block((const void*)&DataSize, (void*)&EEPROMVars.DataSize, sizeof(uint32_t));
		}
		else
		{
			DataSize -= PM_EEPROM_OFFSET;                               // Remove DataFlash EEPROM start offset
    2974:	20 50       	subi	r18, 0x00	; 0
    2976:	34 40       	sbci	r19, 0x04	; 4
    2978:	44 40       	sbci	r20, 0x04	; 4
    297a:	50 40       	sbci	r21, 0x00	; 0
    297c:	29 83       	std	Y+1, r18	; 0x01
    297e:	3a 83       	std	Y+2, r19	; 0x02
    2980:	4b 83       	std	Y+3, r20	; 0x03
    2982:	5c 83       	std	Y+4, r21	; 0x04
            {
              uint8_t len;
              len = (uint8_t) n;

              asm volatile (
    2984:	84 e0       	ldi	r24, 0x04	; 4
    2986:	a3 e2       	ldi	r26, 0x23	; 35
    2988:	b0 e0       	ldi	r27, 0x00	; 0
    298a:	18 2e       	mov	r1, r24
    298c:	0e 94 98 1a 	call	0x3530	; 0x3530 <__eeprom_write_block_1F2021>
    2990:	12 c0       	rjmp	.+36     	; 0x29b6 <PM_CheckEndOfFuseLockData+0xc2>
			eeprom_write_block((const void*)&DataSize, (void*)&EEPROMVars.EEPROMSize, sizeof(uint32_t));
		}
	}
	else if (CurrentMode == PM_LOCKFUSEBITS_WRITE)
    2992:	83 30       	cpi	r24, 0x03	; 3
    2994:	81 f4       	brne	.+32     	; 0x29b6 <PM_CheckEndOfFuseLockData+0xc2>
	{
		// CurrBuffByte stores the total number of fuse/lock bytes written in this case:
		eeprom_write_byte(((MemoryType == TYPE_FUSE)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes), DataflashInfo.CurrBuffByte);
    2996:	20 91 45 01 	lds	r18, 0x0145
    299a:	30 91 46 01 	lds	r19, 0x0146
    299e:	80 91 02 01 	lds	r24, 0x0102
    29a2:	82 30       	cpi	r24, 0x02	; 2
    29a4:	19 f4       	brne	.+6      	; 0x29ac <PM_CheckEndOfFuseLockData+0xb8>
    29a6:	a3 e3       	ldi	r26, 0x33	; 51
    29a8:	b0 e0       	ldi	r27, 0x00	; 0
    29aa:	02 c0       	rjmp	.+4      	; 0x29b0 <PM_CheckEndOfFuseLockData+0xbc>
    29ac:	a4 e3       	ldi	r26, 0x34	; 52
    29ae:	b0 e0       	ldi	r27, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    29b0:	02 2e       	mov	r0, r18
    29b2:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
    29b6:	24 96       	adiw	r28, 0x04	; 4
    29b8:	0f b6       	in	r0, 0x3f	; 63
    29ba:	f8 94       	cli
    29bc:	de bf       	out	0x3e, r29	; 62
    29be:	0f be       	out	0x3f, r0	; 63
    29c0:	cd bf       	out	0x3d, r28	; 61
    29c2:	df 91       	pop	r29
    29c4:	cf 91       	pop	r28
    29c6:	08 95       	ret

000029c8 <PM_GetStoredDataSize>:
    29c8:	cf 93       	push	r28
    29ca:	df 93       	push	r29
    29cc:	cd b7       	in	r28, 0x3d	; 61
    29ce:	de b7       	in	r29, 0x3e	; 62
    29d0:	24 97       	sbiw	r28, 0x04	; 4
    29d2:	0f b6       	in	r0, 0x3f	; 63
    29d4:	f8 94       	cli
    29d6:	de bf       	out	0x3e, r29	; 62
    29d8:	0f be       	out	0x3f, r0	; 63
    29da:	cd bf       	out	0x3d, r28	; 61
    29dc:	81 30       	cpi	r24, 0x01	; 1
    29de:	19 f4       	brne	.+6      	; 0x29e6 <PM_GetStoredDataSize+0x1e>
    29e0:	af e1       	ldi	r26, 0x1F	; 31
    29e2:	b0 e0       	ldi	r27, 0x00	; 0
    29e4:	02 c0       	rjmp	.+4      	; 0x29ea <PM_GetStoredDataSize+0x22>
    29e6:	a3 e2       	ldi	r26, 0x23	; 35
    29e8:	b0 e0       	ldi	r27, 0x00	; 0
              /* Needed in order to truncate to 8 bit.  */
              uint8_t len;
              len = (uint8_t) n; 

              asm volatile (
    29ea:	84 e0       	ldi	r24, 0x04	; 4
    29ec:	fe 01       	movw	r30, r28
    29ee:	31 96       	adiw	r30, 0x01	; 1
    29f0:	18 2e       	mov	r1, r24
    29f2:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <__eeprom_read_block_1F2021>
    29f6:	69 81       	ldd	r22, Y+1	; 0x01
    29f8:	7a 81       	ldd	r23, Y+2	; 0x02
    29fa:	8b 81       	ldd	r24, Y+3	; 0x03
    29fc:	9c 81       	ldd	r25, Y+4	; 0x04
    29fe:	6f 3f       	cpi	r22, 0xFF	; 255
    2a00:	2f ef       	ldi	r18, 0xFF	; 255
    2a02:	72 07       	cpc	r23, r18
    2a04:	2f ef       	ldi	r18, 0xFF	; 255
    2a06:	82 07       	cpc	r24, r18
    2a08:	2f ef       	ldi	r18, 0xFF	; 255
    2a0a:	92 07       	cpc	r25, r18
    2a0c:	21 f4       	brne	.+8      	; 0x2a16 <PM_GetStoredDataSize+0x4e>
    2a0e:	60 e0       	ldi	r22, 0x00	; 0
    2a10:	70 e0       	ldi	r23, 0x00	; 0
    2a12:	80 e0       	ldi	r24, 0x00	; 0
    2a14:	90 e0       	ldi	r25, 0x00	; 0
    2a16:	24 96       	adiw	r28, 0x04	; 4
    2a18:	0f b6       	in	r0, 0x3f	; 63
    2a1a:	f8 94       	cli
    2a1c:	de bf       	out	0x3e, r29	; 62
    2a1e:	0f be       	out	0x3f, r0	; 63
    2a20:	cd bf       	out	0x3d, r28	; 61
    2a22:	df 91       	pop	r29
    2a24:	cf 91       	pop	r28
    2a26:	08 95       	ret

00002a28 <PM_StoreProgramByte>:
    2a28:	1f 93       	push	r17
    2a2a:	18 2f       	mov	r17, r24
    2a2c:	80 91 45 01 	lds	r24, 0x0145
    2a30:	90 91 46 01 	lds	r25, 0x0146
    2a34:	88 50       	subi	r24, 0x08	; 8
    2a36:	91 40       	sbci	r25, 0x01	; 1
    2a38:	a1 f4       	brne	.+40     	; 0x2a62 <PM_StoreProgramByte+0x3a>
    2a3a:	80 91 43 01 	lds	r24, 0x0143
    2a3e:	90 91 44 01 	lds	r25, 0x0144
    2a42:	01 96       	adiw	r24, 0x01	; 1
    2a44:	90 93 44 01 	sts	0x0144, r25
    2a48:	80 93 43 01 	sts	0x0143, r24
    2a4c:	01 97       	sbiw	r24, 0x01	; 1
    2a4e:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <DF_CopyBufferToFlashPage>
    2a52:	80 e0       	ldi	r24, 0x00	; 0
    2a54:	90 e0       	ldi	r25, 0x00	; 0
    2a56:	0e 94 c7 0a 	call	0x158e	; 0x158e <DF_BufferWriteEnable>
    2a5a:	10 92 46 01 	sts	0x0146, r1
    2a5e:	10 92 45 01 	sts	0x0145, r1
    2a62:	81 2f       	mov	r24, r17
    2a64:	0e 94 af 09 	call	0x135e	; 0x135e <SPI_SPITransmit>
    2a68:	80 91 45 01 	lds	r24, 0x0145
    2a6c:	90 91 46 01 	lds	r25, 0x0146
    2a70:	01 96       	adiw	r24, 0x01	; 1
    2a72:	90 93 46 01 	sts	0x0146, r25
    2a76:	80 93 45 01 	sts	0x0145, r24
    2a7a:	80 91 af 02 	lds	r24, 0x02AF
    2a7e:	90 91 b0 02 	lds	r25, 0x02B0
    2a82:	01 96       	adiw	r24, 0x01	; 1
    2a84:	90 93 b0 02 	sts	0x02B0, r25
    2a88:	80 93 af 02 	sts	0x02AF, r24
    2a8c:	1f 91       	pop	r17
    2a8e:	08 95       	ret

00002a90 <PM_SendFuseLockBytes>:
	}
}

void PM_SendFuseLockBytes(const uint8_t Type)
{
    2a90:	ef 92       	push	r14
    2a92:	ff 92       	push	r15
    2a94:	0f 93       	push	r16
    2a96:	1f 93       	push	r17
    2a98:	cf 93       	push	r28
    2a9a:	df 93       	push	r29
	uint8_t  TotalBytes;
	uint8_t* EEPROMAddress;

	if (Type == TYPE_FUSE)
    2a9c:	82 30       	cpi	r24, 0x02	; 2
    2a9e:	59 f4       	brne	.+22     	; 0x2ab6 <PM_SendFuseLockBytes+0x26>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2aa0:	43 e3       	ldi	r20, 0x33	; 51
    2aa2:	50 e0       	ldi	r21, 0x00	; 0
    2aa4:	da 01       	movw	r26, r20
    2aa6:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
    2aaa:	80 2d       	mov	r24, r0
	{
		TotalBytes    = eeprom_read_byte(&EEPROMVars.TotalFuseBytes);
    2aac:	18 2f       	mov	r17, r24
		EEPROMAddress = &EEPROMVars.FuseBytes[0][0];
    2aae:	62 e0       	ldi	r22, 0x02	; 2
    2ab0:	e6 2e       	mov	r14, r22
    2ab2:	f1 2c       	mov	r15, r1
    2ab4:	0a c0       	rjmp	.+20     	; 0x2aca <PM_SendFuseLockBytes+0x3a>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2ab6:	44 e3       	ldi	r20, 0x34	; 52
    2ab8:	50 e0       	ldi	r21, 0x00	; 0
    2aba:	da 01       	movw	r26, r20
    2abc:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
    2ac0:	80 2d       	mov	r24, r0
	}
	else
	{
		TotalBytes    = eeprom_read_byte(&EEPROMVars.TotalLockBytes);
    2ac2:	18 2f       	mov	r17, r24
		EEPROMAddress = &EEPROMVars.LockBytes[0][0];	
    2ac4:	39 e2       	ldi	r19, 0x29	; 41
    2ac6:	e3 2e       	mov	r14, r19
    2ac8:	f1 2c       	mov	r15, r1
    2aca:	e4 0e       	add	r14, r20
    2acc:	f5 1e       	adc	r15, r21
    2ace:	15 c0       	rjmp	.+42     	; 0x2afa <PM_SendFuseLockBytes+0x6a>
    2ad0:	e7 01       	movw	r28, r14
    2ad2:	00 e0       	ldi	r16, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2ad4:	de 01       	movw	r26, r28
    2ad6:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
    2ada:	80 2d       	mov	r24, r0
	}

	while (TotalBytes--)                                                // Write each of the fuse/lock bytes stored in memory to the slave AVR
	{
		for (uint8_t CommandByte = 0; CommandByte < 4; CommandByte++)   // Write each individual command byte
		{
			USI_SPITransmit(eeprom_read_byte(EEPROMAddress));
    2adc:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
			EEPROMAddress++;
    2ae0:	21 96       	adiw	r28, 0x01	; 1
    2ae2:	0f 5f       	subi	r16, 0xFF	; 255
    2ae4:	04 30       	cpi	r16, 0x04	; 4
    2ae6:	b1 f7       	brne	.-20     	; 0x2ad4 <PM_SendFuseLockBytes+0x44>
    2ae8:	84 e0       	ldi	r24, 0x04	; 4
    2aea:	90 e0       	ldi	r25, 0x00	; 0
    2aec:	e8 0e       	add	r14, r24
    2aee:	f9 1e       	adc	r15, r25
		}
		
		// Add some delay before programming next byte, if there is one:
		if (TotalBytes)
    2af0:	11 23       	and	r17, r17
    2af2:	19 f0       	breq	.+6      	; 0x2afa <PM_SendFuseLockBytes+0x6a>
		  MAIN_Delay10MS(5);
    2af4:	85 e0       	ldi	r24, 0x05	; 5
    2af6:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
    2afa:	11 50       	subi	r17, 0x01	; 1
    2afc:	48 f7       	brcc	.-46     	; 0x2ad0 <PM_SendFuseLockBytes+0x40>
    2afe:	df 91       	pop	r29
    2b00:	cf 91       	pop	r28
    2b02:	1f 91       	pop	r17
    2b04:	0f 91       	pop	r16
    2b06:	ff 90       	pop	r15
    2b08:	ef 90       	pop	r14
    2b0a:	08 95       	ret

00002b0c <PM_SendEraseCommand>:
	}
}

void PM_SendEraseCommand(void)
{			
    2b0c:	cf 93       	push	r28
    2b0e:	df 93       	push	r29
    2b10:	cb e1       	ldi	r28, 0x1B	; 27
    2b12:	d0 e0       	ldi	r29, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2b14:	de 01       	movw	r26, r28
    2b16:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
    2b1a:	80 2d       	mov	r24, r0
	for (uint8_t B = 3; B < 7 ; B++)                                    // Read out the erase chip command bytes
	  USI_SPITransmit(eeprom_read_byte(&EEPROMVars.EraseChip[B]));      // Send the erase chip commands
    2b1c:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
    2b20:	21 96       	adiw	r28, 0x01	; 1
    2b22:	80 e0       	ldi	r24, 0x00	; 0
    2b24:	cf 31       	cpi	r28, 0x1F	; 31
    2b26:	d8 07       	cpc	r29, r24
    2b28:	a9 f7       	brne	.-22     	; 0x2b14 <PM_SendEraseCommand+0x8>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2b2a:	25 97       	sbiw	r28, 0x05	; 5
    2b2c:	de 01       	movw	r26, r28
    2b2e:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
    2b32:	80 2d       	mov	r24, r0
    2b34:	25 96       	adiw	r28, 0x05	; 5
			
	if (eeprom_read_byte(&EEPROMVars.EraseChip[2]))                     // Value of 1 indicates a busy flag test
    2b36:	88 23       	and	r24, r24
    2b38:	59 f0       	breq	.+22     	; 0x2b50 <PM_SendEraseCommand+0x44>
	{
		do
		  USI_SPITransmitWord(0xF000);
    2b3a:	80 e0       	ldi	r24, 0x00	; 0
    2b3c:	90 ef       	ldi	r25, 0xF0	; 240
    2b3e:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
		while (USI_SPITransmitWord(0x0000) & 0x01);
    2b42:	80 e0       	ldi	r24, 0x00	; 0
    2b44:	90 e0       	ldi	r25, 0x00	; 0
    2b46:	0e 94 01 0a 	call	0x1402	; 0x1402 <USI_SPITransmitWord>
    2b4a:	80 ff       	sbrs	r24, 0
    2b4c:	08 c0       	rjmp	.+16     	; 0x2b5e <PM_SendEraseCommand+0x52>
    2b4e:	f5 cf       	rjmp	.-22     	; 0x2b3a <PM_SendEraseCommand+0x2e>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2b50:	26 97       	sbiw	r28, 0x06	; 6
    2b52:	de 01       	movw	r26, r28
    2b54:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
    2b58:	80 2d       	mov	r24, r0
	}
	else                                                                // Cleared flag means use a predefined delay
	{		
		MAIN_Delay1MS(eeprom_read_byte(&EEPROMVars.EraseChip[1]));      // Wait the erase delay
    2b5a:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2b5e:	df 91       	pop	r29
    2b60:	cf 91       	pop	r28
    2b62:	08 95       	ret

00002b64 <PM_CreateProgrammingPackets>:
	}
}

void PM_CreateProgrammingPackets(const uint8_t Type)
{			
    2b64:	3f 92       	push	r3
    2b66:	4f 92       	push	r4
    2b68:	5f 92       	push	r5
    2b6a:	6f 92       	push	r6
    2b6c:	7f 92       	push	r7
    2b6e:	8f 92       	push	r8
    2b70:	9f 92       	push	r9
    2b72:	af 92       	push	r10
    2b74:	bf 92       	push	r11
    2b76:	cf 92       	push	r12
    2b78:	df 92       	push	r13
    2b7a:	ef 92       	push	r14
    2b7c:	ff 92       	push	r15
    2b7e:	0f 93       	push	r16
    2b80:	1f 93       	push	r17
    2b82:	cf 93       	push	r28
    2b84:	df 93       	push	r29
    2b86:	18 2f       	mov	r17, r24
	uint32_t BytesRead       = 0;
	uint32_t BytesToRead     = PM_GetStoredDataSize(Type);              // Get the byte size of the stored program
    2b88:	0e 94 e4 14 	call	0x29c8	; 0x29c8 <PM_GetStoredDataSize>
    2b8c:	2b 01       	movw	r4, r22
    2b8e:	3c 01       	movw	r6, r24
	uint16_t BytesPerProgram;
	uint16_t PageLength      = eeprom_read_word((Type == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength);
    2b90:	11 30       	cpi	r17, 0x01	; 1
    2b92:	09 f0       	breq	.+2      	; 0x2b96 <PM_CreateProgrammingPackets+0x32>
    2b94:	d7 c0       	rjmp	.+430    	; 0x2d44 <PM_CreateProgrammingPackets+0x1e0>
eeprom_read_word (const uint16_t *addr)
{
  uint16_t result;

  asm ( 
    2b96:	a5 e8       	ldi	r26, 0x85	; 133
    2b98:	b0 e0       	ldi	r27, 0x00	; 0
    2b9a:	0e 94 82 1a 	call	0x3504	; 0x3504 <__eeprom_read_word_1F2021>
    2b9e:	4f 01       	movw	r8, r30
	uint8_t  ContinuedPage   = FALSE;
	uint8_t* EEPROMAddress;

	CurrAddress = 0;
    2ba0:	10 92 a9 02 	sts	0x02A9, r1
    2ba4:	10 92 aa 02 	sts	0x02AA, r1
    2ba8:	10 92 ab 02 	sts	0x02AB, r1
    2bac:	10 92 ac 02 	sts	0x02AC, r1

	if (Type == TYPE_FLASH)
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram;             // Set the EEPROM pointer to the write flash command bytes location
		DF_ContinuousReadEnable(0, 0);
    2bb0:	60 e0       	ldi	r22, 0x00	; 0
    2bb2:	70 e0       	ldi	r23, 0x00	; 0
    2bb4:	80 e0       	ldi	r24, 0x00	; 0
    2bb6:	90 e0       	ldi	r25, 0x00	; 0
    2bb8:	0e 94 8c 0a 	call	0x1518	; 0x1518 <DF_ContinuousReadEnable>
		PacketBytes[0] = AICB_CMD_PROGRAM_FLASH_ISP;
    2bbc:	83 e1       	ldi	r24, 0x13	; 19
    2bbe:	80 93 91 01 	sts	0x0191, r24
    2bc2:	23 e0       	ldi	r18, 0x03	; 3
    2bc4:	30 e0       	ldi	r19, 0x00	; 0
    2bc6:	e1 e9       	ldi	r30, 0x91	; 145
    2bc8:	f1 e0       	ldi	r31, 0x01	; 1
	}
	else
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;              // Set the EEPROM pointer to the write EEPROM command bytes location
		DF_ContinuousReadEnable(PM_EEPROM_OFFSET / DF_INTERNALDF_BUFFBYTES, PM_EEPROM_OFFSET % DF_INTERNALDF_BUFFBYTES); // Start read from the EEPROM offset location
		PacketBytes[0] = AICB_CMD_PROGRAM_EEPROM_ISP;
	}

	for (uint8_t B = 0; B < 9 ; B++)                                    // Load in the write data command bytes
	{
		EEPROMAddress++;                                                // Increment the EEPROM location counter
    2bca:	2f 5f       	subi	r18, 0xFF	; 255
    2bcc:	3f 4f       	sbci	r19, 0xFF	; 255
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2bce:	d9 01       	movw	r26, r18
    2bd0:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
    2bd4:	80 2d       	mov	r24, r0
		PacketBytes[B] = eeprom_read_byte(EEPROMAddress);               // Synthesise a write packet header
    2bd6:	81 93       	st	Z+, r24
    2bd8:	81 e0       	ldi	r24, 0x01	; 1
    2bda:	ea 39       	cpi	r30, 0x9A	; 154
    2bdc:	f8 07       	cpc	r31, r24
    2bde:	a9 f7       	brne	.-22     	; 0x2bca <PM_CreateProgrammingPackets+0x66>
	}
	
	BytesPerProgram = ((uint16_t)PacketBytes[1] << 8)
    2be0:	80 91 92 01 	lds	r24, 0x0192
    2be4:	99 27       	eor	r25, r25
    2be6:	d8 2f       	mov	r29, r24
    2be8:	cc 27       	eor	r28, r28
    2bea:	80 91 93 01 	lds	r24, 0x0193
    2bee:	99 27       	eor	r25, r25
    2bf0:	c8 2b       	or	r28, r24
    2bf2:	d9 2b       	or	r29, r25
    2bf4:	aa 24       	eor	r10, r10
    2bf6:	bb 24       	eor	r11, r11
    2bf8:	65 01       	movw	r12, r10
    2bfa:	33 24       	eor	r3, r3
    2bfc:	9c c0       	rjmp	.+312    	; 0x2d36 <PM_CreateProgrammingPackets+0x1d2>
	                | PacketBytes[2];

	while (BytesRead < BytesToRead)
	{
		if (PacketBytes[3] & ISPCC_PROG_MODE_PAGE)
    2bfe:	80 91 94 01 	lds	r24, 0x0194
    2c02:	80 ff       	sbrs	r24, 0
    2c04:	4b c0       	rjmp	.+150    	; 0x2c9c <PM_CreateProgrammingPackets+0x138>
		{
			if (PageLength > 160)                                       // Max 160 bytes at a time
    2c06:	91 ea       	ldi	r25, 0xA1	; 161
    2c08:	89 16       	cp	r8, r25
    2c0a:	91 04       	cpc	r9, r1
    2c0c:	18 f4       	brcc	.+6      	; 0x2c14 <PM_CreateProgrammingPackets+0xb0>
    2c0e:	01 e9       	ldi	r16, 0x91	; 145
    2c10:	11 e0       	ldi	r17, 0x01	; 1
    2c12:	2f c0       	rjmp	.+94     	; 0x2c72 <PM_CreateProgrammingPackets+0x10e>
			{
				if (!(ContinuedPage))                                   // Start of a new page, program in the first 150 bytes
    2c14:	33 20       	and	r3, r3
    2c16:	41 f4       	brne	.+16     	; 0x2c28 <PM_CreateProgrammingPackets+0xc4>
				{
					BytesPerProgram = 160;
					PacketBytes[3] &= ~ISPCC_PROG_MODE_PAGEDONE;		
    2c18:	8f 77       	andi	r24, 0x7F	; 127
    2c1a:	80 93 94 01 	sts	0x0194, r24
    2c1e:	c0 ea       	ldi	r28, 0xA0	; 160
    2c20:	d0 e0       	ldi	r29, 0x00	; 0
    2c22:	11 e0       	ldi	r17, 0x01	; 1
    2c24:	31 2e       	mov	r3, r17
    2c26:	07 c0       	rjmp	.+14     	; 0x2c36 <PM_CreateProgrammingPackets+0xd2>
					ContinuedPage   = TRUE;
				}
				else                                                    // Middle of a page, program in the remainder
				{
					BytesPerProgram = PageLength - 160;
    2c28:	e4 01       	movw	r28, r8
    2c2a:	c0 5a       	subi	r28, 0xA0	; 160
    2c2c:	d0 40       	sbci	r29, 0x00	; 0
					PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
    2c2e:	80 68       	ori	r24, 0x80	; 128
    2c30:	80 93 94 01 	sts	0x0194, r24
    2c34:	33 24       	eor	r3, r3
    2c36:	01 e9       	ldi	r16, 0x91	; 145
    2c38:	11 e0       	ldi	r17, 0x01	; 1
    2c3a:	07 c0       	rjmp	.+14     	; 0x2c4a <PM_CreateProgrammingPackets+0xe6>
					ContinuedPage   = FALSE;
				}
				
				for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
				  PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);    // Load in the page				
    2c3c:	80 e0       	ldi	r24, 0x00	; 0
    2c3e:	0e 94 af 09 	call	0x135e	; 0x135e <SPI_SPITransmit>
    2c42:	f8 01       	movw	r30, r16
    2c44:	82 87       	std	Z+10, r24	; 0x0a
    2c46:	0f 5f       	subi	r16, 0xFF	; 255
    2c48:	1f 4f       	sbci	r17, 0xFF	; 255
    2c4a:	ce 01       	movw	r24, r28
    2c4c:	8f 56       	subi	r24, 0x6F	; 111
    2c4e:	9e 4f       	sbci	r25, 0xFE	; 254
    2c50:	08 17       	cp	r16, r24
    2c52:	19 07       	cpc	r17, r25
    2c54:	99 f7       	brne	.-26     	; 0x2c3c <PM_CreateProgrammingPackets+0xd8>

				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);
    2c56:	8d 2f       	mov	r24, r29
    2c58:	99 27       	eor	r25, r25
    2c5a:	80 93 92 01 	sts	0x0192, r24
				PacketBytes[2] = (uint8_t)(BytesPerProgram);
    2c5e:	c0 93 93 01 	sts	0x0193, r28
    2c62:	41 c0       	rjmp	.+130    	; 0x2ce6 <PM_CreateProgrammingPackets+0x182>

				BytesRead += BytesPerProgram;                           // Increment the counter
			}
			else
			{
				for (uint16_t LoadB = 0; LoadB < PageLength; LoadB++)
				  PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);    // Load in the page
    2c64:	80 e0       	ldi	r24, 0x00	; 0
    2c66:	0e 94 af 09 	call	0x135e	; 0x135e <SPI_SPITransmit>
    2c6a:	f8 01       	movw	r30, r16
    2c6c:	82 87       	std	Z+10, r24	; 0x0a
    2c6e:	0f 5f       	subi	r16, 0xFF	; 255
    2c70:	1f 4f       	sbci	r17, 0xFF	; 255
    2c72:	c4 01       	movw	r24, r8
    2c74:	8f 56       	subi	r24, 0x6F	; 111
    2c76:	9e 4f       	sbci	r25, 0xFE	; 254
    2c78:	08 17       	cp	r16, r24
    2c7a:	19 07       	cpc	r17, r25
    2c7c:	99 f7       	brne	.-26     	; 0x2c64 <PM_CreateProgrammingPackets+0x100>
			
				PacketBytes[1]  = (uint8_t)(PageLength >> 8);
    2c7e:	89 2d       	mov	r24, r9
    2c80:	99 27       	eor	r25, r25
    2c82:	80 93 92 01 	sts	0x0192, r24
				PacketBytes[2]  = (uint8_t)(PageLength);
    2c86:	80 92 93 01 	sts	0x0193, r8
				PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
    2c8a:	80 91 94 01 	lds	r24, 0x0194
    2c8e:	80 68       	ori	r24, 0x80	; 128
    2c90:	80 93 94 01 	sts	0x0194, r24

				BytesRead += PageLength;                                // Increment the counter
    2c94:	c4 01       	movw	r24, r8
    2c96:	aa 27       	eor	r26, r26
    2c98:	bb 27       	eor	r27, r27
    2c9a:	28 c0       	rjmp	.+80     	; 0x2cec <PM_CreateProgrammingPackets+0x188>
			}
		}
		else
		{
			if ((BytesRead + BytesPerProgram) > BytesToRead)            // Less than a whole BytesPerProgram left of data to write
    2c9c:	ce 01       	movw	r24, r28
    2c9e:	aa 27       	eor	r26, r26
    2ca0:	bb 27       	eor	r27, r27
    2ca2:	8a 0d       	add	r24, r10
    2ca4:	9b 1d       	adc	r25, r11
    2ca6:	ac 1d       	adc	r26, r12
    2ca8:	bd 1d       	adc	r27, r13
    2caa:	48 16       	cp	r4, r24
    2cac:	59 06       	cpc	r5, r25
    2cae:	6a 06       	cpc	r6, r26
    2cb0:	7b 06       	cpc	r7, r27
    2cb2:	48 f4       	brcc	.+18     	; 0x2cc6 <PM_CreateProgrammingPackets+0x162>
			{
				BytesPerProgram = BytesToRead - BytesRead;              // Next lot of bytes will be the remaining data length
    2cb4:	e2 01       	movw	r28, r4
    2cb6:	ca 19       	sub	r28, r10
    2cb8:	db 09       	sbc	r29, r11
				PacketBytes[1]  = (uint8_t)(BytesPerProgram >> 8);      // \. Save the new length
    2cba:	8d 2f       	mov	r24, r29
    2cbc:	99 27       	eor	r25, r25
    2cbe:	80 93 92 01 	sts	0x0192, r24
				PacketBytes[2]  = (uint8_t)(BytesPerProgram);           // /  into the data packet
    2cc2:	c0 93 93 01 	sts	0x0193, r28
    2cc6:	01 e9       	ldi	r16, 0x91	; 145
    2cc8:	11 e0       	ldi	r17, 0x01	; 1
    2cca:	07 c0       	rjmp	.+14     	; 0x2cda <PM_CreateProgrammingPackets+0x176>
			}

			for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
			  PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);          // Load in the page
    2ccc:	80 e0       	ldi	r24, 0x00	; 0
    2cce:	0e 94 af 09 	call	0x135e	; 0x135e <SPI_SPITransmit>
    2cd2:	f8 01       	movw	r30, r16
    2cd4:	82 87       	std	Z+10, r24	; 0x0a
    2cd6:	0f 5f       	subi	r16, 0xFF	; 255
    2cd8:	1f 4f       	sbci	r17, 0xFF	; 255
    2cda:	ce 01       	movw	r24, r28
    2cdc:	8f 56       	subi	r24, 0x6F	; 111
    2cde:	9e 4f       	sbci	r25, 0xFE	; 254
    2ce0:	08 17       	cp	r16, r24
    2ce2:	19 07       	cpc	r17, r25
    2ce4:	99 f7       	brne	.-26     	; 0x2ccc <PM_CreateProgrammingPackets+0x168>
		
			BytesRead += BytesPerProgram;                               // Increment the counter
    2ce6:	ce 01       	movw	r24, r28
    2ce8:	aa 27       	eor	r26, r26
    2cea:	bb 27       	eor	r27, r27
    2cec:	a8 0e       	add	r10, r24
    2cee:	b9 1e       	adc	r11, r25
    2cf0:	ca 1e       	adc	r12, r26
    2cf2:	db 1e       	adc	r13, r27
		}
	
		if (!(BytesRead & 0xFFFF) && (BytesRead & 0x00FF0000))          // Extended address required
    2cf4:	a1 14       	cp	r10, r1
    2cf6:	b1 04       	cpc	r11, r1
    2cf8:	e1 f4       	brne	.+56     	; 0x2d32 <PM_CreateProgrammingPackets+0x1ce>
    2cfa:	e1 2c       	mov	r14, r1
    2cfc:	f1 2c       	mov	r15, r1
    2cfe:	ef ef       	ldi	r30, 0xFF	; 255
    2d00:	0e 2f       	mov	r16, r30
    2d02:	11 2d       	mov	r17, r1
    2d04:	ea 20       	and	r14, r10
    2d06:	fb 20       	and	r15, r11
    2d08:	0c 21       	and	r16, r12
    2d0a:	1d 21       	and	r17, r13
    2d0c:	e1 14       	cp	r14, r1
    2d0e:	f1 04       	cpc	r15, r1
    2d10:	01 05       	cpc	r16, r1
    2d12:	11 05       	cpc	r17, r1
    2d14:	71 f0       	breq	.+28     	; 0x2d32 <PM_CreateProgrammingPackets+0x1ce>
		{
			USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);                // Load extended address command
    2d16:	8d e4       	ldi	r24, 0x4D	; 77
    2d18:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
			USI_SPITransmit(0x00);
    2d1c:	80 e0       	ldi	r24, 0x00	; 0
    2d1e:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
			USI_SPITransmit((BytesRead & 0x00FF0000) >> 16);            // The 3rd byte of the long holds the extended address
    2d22:	c8 01       	movw	r24, r16
    2d24:	aa 27       	eor	r26, r26
    2d26:	bb 27       	eor	r27, r27
    2d28:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
			USI_SPITransmit(0x00);
    2d2c:	80 e0       	ldi	r24, 0x00	; 0
    2d2e:	0e 94 ee 09 	call	0x13dc	; 0x13dc <USI_SPITransmit>
		}

		ISPCC_ProgramChip();                                            // Start the program cycle
    2d32:	0e 94 87 11 	call	0x230e	; 0x230e <ISPCC_ProgramChip>
    2d36:	a4 14       	cp	r10, r4
    2d38:	b5 04       	cpc	r11, r5
    2d3a:	c6 04       	cpc	r12, r6
    2d3c:	d7 04       	cpc	r13, r7
    2d3e:	08 f4       	brcc	.+2      	; 0x2d42 <PM_CreateProgrammingPackets+0x1de>
    2d40:	5e cf       	rjmp	.-324    	; 0x2bfe <PM_CreateProgrammingPackets+0x9a>
    2d42:	19 c0       	rjmp	.+50     	; 0x2d76 <PM_CreateProgrammingPackets+0x212>
eeprom_read_word (const uint16_t *addr)
{
  uint16_t result;

  asm ( 
    2d44:	a7 e8       	ldi	r26, 0x87	; 135
    2d46:	b0 e0       	ldi	r27, 0x00	; 0
    2d48:	0e 94 82 1a 	call	0x3504	; 0x3504 <__eeprom_read_word_1F2021>
    2d4c:	4f 01       	movw	r8, r30
    2d4e:	10 92 a9 02 	sts	0x02A9, r1
    2d52:	10 92 aa 02 	sts	0x02AA, r1
    2d56:	10 92 ab 02 	sts	0x02AB, r1
    2d5a:	10 92 ac 02 	sts	0x02AC, r1
    2d5e:	60 ee       	ldi	r22, 0xE0	; 224
    2d60:	70 e0       	ldi	r23, 0x00	; 0
    2d62:	84 ee       	ldi	r24, 0xE4	; 228
    2d64:	93 e0       	ldi	r25, 0x03	; 3
    2d66:	0e 94 8c 0a 	call	0x1518	; 0x1518 <DF_ContinuousReadEnable>
    2d6a:	85 e1       	ldi	r24, 0x15	; 21
    2d6c:	80 93 91 01 	sts	0x0191, r24
    2d70:	2d e0       	ldi	r18, 0x0D	; 13
    2d72:	30 e0       	ldi	r19, 0x00	; 0
    2d74:	28 cf       	rjmp	.-432    	; 0x2bc6 <PM_CreateProgrammingPackets+0x62>
    2d76:	df 91       	pop	r29
    2d78:	cf 91       	pop	r28
    2d7a:	1f 91       	pop	r17
    2d7c:	0f 91       	pop	r16
    2d7e:	ff 90       	pop	r15
    2d80:	ef 90       	pop	r14
    2d82:	df 90       	pop	r13
    2d84:	cf 90       	pop	r12
    2d86:	bf 90       	pop	r11
    2d88:	af 90       	pop	r10
    2d8a:	9f 90       	pop	r9
    2d8c:	8f 90       	pop	r8
    2d8e:	7f 90       	pop	r7
    2d90:	6f 90       	pop	r6
    2d92:	5f 90       	pop	r5
    2d94:	4f 90       	pop	r4
    2d96:	3f 90       	pop	r3
    2d98:	08 95       	ret

00002d9a <PM_ShowStoredItemSizes>:
	}
}

void PM_ShowStoredItemSizes(void)
{
    2d9a:	1f 93       	push	r17
    2d9c:	cf 93       	push	r28
    2d9e:	df 93       	push	r29
    2da0:	cd b7       	in	r28, 0x3d	; 61
    2da2:	de b7       	in	r29, 0x3e	; 62
    2da4:	2e 97       	sbiw	r28, 0x0e	; 14
    2da6:	0f b6       	in	r0, 0x3f	; 63
    2da8:	f8 94       	cli
    2daa:	de bf       	out	0x3e, r29	; 62
    2dac:	0f be       	out	0x3f, r0	; 63
    2dae:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[14];
	uint8_t ItemInfoIndex = 0;
	uint8_t TempB;
	
	JoyStatus = JOY_INVALID;                     // Use an invalid joystick value to force the program to write the
    2db0:	81 e0       	ldi	r24, 0x01	; 1
    2db2:	8e bb       	out	0x1e, r24	; 30
    2db4:	10 e0       	ldi	r17, 0x00	; 0
	                                             // name of the default command onto the LCD
	for (;;)
	{
		if (JoyStatus)
    2db6:	8e b3       	in	r24, 0x1e	; 30
    2db8:	88 23       	and	r24, r24
    2dba:	e9 f3       	breq	.-6      	; 0x2db6 <PM_ShowStoredItemSizes+0x1c>
		{
			if (JoyStatus & JOY_UP)
    2dbc:	f6 9b       	sbis	0x1e, 6	; 30
    2dbe:	04 c0       	rjmp	.+8      	; 0x2dc8 <PM_ShowStoredItemSizes+0x2e>
			  (ItemInfoIndex == 0)? ItemInfoIndex = 3 : ItemInfoIndex--;
    2dc0:	11 23       	and	r17, r17
    2dc2:	81 f1       	breq	.+96     	; 0x2e24 <PM_ShowStoredItemSizes+0x8a>
    2dc4:	11 50       	subi	r17, 0x01	; 1
    2dc6:	0a c0       	rjmp	.+20     	; 0x2ddc <PM_ShowStoredItemSizes+0x42>
			else if (JoyStatus & JOY_DOWN)
    2dc8:	f7 9b       	sbis	0x1e, 7	; 30
    2dca:	06 c0       	rjmp	.+12     	; 0x2dd8 <PM_ShowStoredItemSizes+0x3e>
			  (ItemInfoIndex == 3)? ItemInfoIndex = 0 : ItemInfoIndex++;
    2dcc:	13 30       	cpi	r17, 0x03	; 3
    2dce:	11 f4       	brne	.+4      	; 0x2dd4 <PM_ShowStoredItemSizes+0x3a>
    2dd0:	10 e0       	ldi	r17, 0x00	; 0
    2dd2:	0d c0       	rjmp	.+26     	; 0x2dee <PM_ShowStoredItemSizes+0x54>
    2dd4:	1f 5f       	subi	r17, 0xFF	; 255
    2dd6:	02 c0       	rjmp	.+4      	; 0x2ddc <PM_ShowStoredItemSizes+0x42>
			else if (JoyStatus & JOY_LEFT)
    2dd8:	f2 99       	sbic	0x1e, 2	; 30
    2dda:	49 c0       	rjmp	.+146    	; 0x2e6e <PM_ShowStoredItemSizes+0xd4>
			  return;
		
			switch (ItemInfoIndex)
    2ddc:	11 30       	cpi	r17, 0x01	; 1
    2dde:	79 f0       	breq	.+30     	; 0x2dfe <PM_ShowStoredItemSizes+0x64>
    2de0:	11 30       	cpi	r17, 0x01	; 1
    2de2:	28 f0       	brcs	.+10     	; 0x2dee <PM_ShowStoredItemSizes+0x54>
    2de4:	12 30       	cpi	r17, 0x02	; 2
    2de6:	a9 f0       	breq	.+42     	; 0x2e12 <PM_ShowStoredItemSizes+0x78>
    2de8:	13 30       	cpi	r17, 0x03	; 3
    2dea:	d1 f5       	brne	.+116    	; 0x2e60 <PM_ShowStoredItemSizes+0xc6>
    2dec:	1c c0       	rjmp	.+56     	; 0x2e26 <PM_ShowStoredItemSizes+0x8c>
			{
				case 0:
					strcpy_P(Buffer, PSTR("DATA-"));
    2dee:	68 e5       	ldi	r22, 0x58	; 88
    2df0:	74 e0       	ldi	r23, 0x04	; 4
    2df2:	ce 01       	movw	r24, r28
    2df4:	01 96       	adiw	r24, 0x01	; 1
    2df6:	0e 94 39 1a 	call	0x3472	; 0x3472 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_FLASH), &Buffer[5], 10);
    2dfa:	81 e0       	ldi	r24, 0x01	; 1
    2dfc:	07 c0       	rjmp	.+14     	; 0x2e0c <PM_ShowStoredItemSizes+0x72>
					break;
				case 1:
					strcpy_P(Buffer, PSTR("EPRM-"));
    2dfe:	62 e5       	ldi	r22, 0x52	; 82
    2e00:	74 e0       	ldi	r23, 0x04	; 4
    2e02:	ce 01       	movw	r24, r28
    2e04:	01 96       	adiw	r24, 0x01	; 1
    2e06:	0e 94 39 1a 	call	0x3472	; 0x3472 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_EEPROM), &Buffer[5], 10);
    2e0a:	80 e0       	ldi	r24, 0x00	; 0
    2e0c:	0e 94 e4 14 	call	0x29c8	; 0x29c8 <PM_GetStoredDataSize>
    2e10:	20 c0       	rjmp	.+64     	; 0x2e52 <PM_ShowStoredItemSizes+0xb8>
					break;
				case 2:
					strcpy_P(Buffer, PSTR("FUSE-"));
    2e12:	6c e4       	ldi	r22, 0x4C	; 76
    2e14:	74 e0       	ldi	r23, 0x04	; 4
    2e16:	ce 01       	movw	r24, r28
    2e18:	01 96       	adiw	r24, 0x01	; 1
    2e1a:	0e 94 39 1a 	call	0x3472	; 0x3472 <strcpy_P>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2e1e:	a3 e3       	ldi	r26, 0x33	; 51
    2e20:	b0 e0       	ldi	r27, 0x00	; 0
    2e22:	09 c0       	rjmp	.+18     	; 0x2e36 <PM_ShowStoredItemSizes+0x9c>
					TempB = eeprom_read_byte(&EEPROMVars.TotalFuseBytes);
					ultoa(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5], 10);
					break;
    2e24:	13 e0       	ldi	r17, 0x03	; 3
				case 3:
					strcpy_P(Buffer, PSTR("LOCK-"));
    2e26:	66 e4       	ldi	r22, 0x46	; 70
    2e28:	74 e0       	ldi	r23, 0x04	; 4
    2e2a:	ce 01       	movw	r24, r28
    2e2c:	01 96       	adiw	r24, 0x01	; 1
    2e2e:	0e 94 39 1a 	call	0x3472	; 0x3472 <strcpy_P>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2e32:	a4 e3       	ldi	r26, 0x34	; 52
    2e34:	b0 e0       	ldi	r27, 0x00	; 0
    2e36:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
    2e3a:	80 2d       	mov	r24, r0
					TempB = eeprom_read_byte(&EEPROMVars.TotalLockBytes);
					ultoa(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5], 10);
    2e3c:	8f 3f       	cpi	r24, 0xFF	; 255
    2e3e:	29 f4       	brne	.+10     	; 0x2e4a <PM_ShowStoredItemSizes+0xb0>
    2e40:	60 e0       	ldi	r22, 0x00	; 0
    2e42:	70 e0       	ldi	r23, 0x00	; 0
    2e44:	80 e0       	ldi	r24, 0x00	; 0
    2e46:	90 e0       	ldi	r25, 0x00	; 0
    2e48:	04 c0       	rjmp	.+8      	; 0x2e52 <PM_ShowStoredItemSizes+0xb8>
    2e4a:	68 2f       	mov	r22, r24
    2e4c:	77 27       	eor	r23, r23
    2e4e:	88 27       	eor	r24, r24
    2e50:	99 27       	eor	r25, r25
    2e52:	2a e0       	ldi	r18, 0x0A	; 10
    2e54:	30 e0       	ldi	r19, 0x00	; 0
    2e56:	ae 01       	movw	r20, r28
    2e58:	4a 5f       	subi	r20, 0xFA	; 250
    2e5a:	5f 4f       	sbci	r21, 0xFF	; 255
    2e5c:	0e 94 40 1a 	call	0x3480	; 0x3480 <ultoa>
			}
	
			LCD_puts(Buffer);
    2e60:	ce 01       	movw	r24, r28
    2e62:	01 96       	adiw	r24, 0x01	; 1
    2e64:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <LCD_puts>

			MAIN_WaitForJoyRelease();
    2e68:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
    2e6c:	a4 cf       	rjmp	.-184    	; 0x2db6 <PM_ShowStoredItemSizes+0x1c>
    2e6e:	2e 96       	adiw	r28, 0x0e	; 14
    2e70:	0f b6       	in	r0, 0x3f	; 63
    2e72:	f8 94       	cli
    2e74:	de bf       	out	0x3e, r29	; 62
    2e76:	0f be       	out	0x3f, r0	; 63
    2e78:	cd bf       	out	0x3d, r28	; 61
    2e7a:	df 91       	pop	r29
    2e7c:	cf 91       	pop	r28
    2e7e:	1f 91       	pop	r17
    2e80:	08 95       	ret

00002e82 <PM_InterpretAVRISPPacket>:
    2e82:	ef 92       	push	r14
    2e84:	ff 92       	push	r15
    2e86:	0f 93       	push	r16
    2e88:	1f 93       	push	r17
    2e8a:	cf 93       	push	r28
    2e8c:	df 93       	push	r29
    2e8e:	20 91 91 01 	lds	r18, 0x0191
    2e92:	26 31       	cpi	r18, 0x16	; 22
    2e94:	09 f4       	brne	.+2      	; 0x2e98 <PM_InterpretAVRISPPacket+0x16>
    2e96:	a6 c1       	rjmp	.+844    	; 0x31e4 <PM_InterpretAVRISPPacket+0x362>
    2e98:	27 31       	cpi	r18, 0x17	; 23
    2e9a:	78 f4       	brcc	.+30     	; 0x2eba <PM_InterpretAVRISPPacket+0x38>
    2e9c:	22 31       	cpi	r18, 0x12	; 18
    2e9e:	09 f4       	brne	.+2      	; 0x2ea2 <PM_InterpretAVRISPPacket+0x20>
    2ea0:	5f c0       	rjmp	.+190    	; 0x2f60 <PM_InterpretAVRISPPacket+0xde>
    2ea2:	23 31       	cpi	r18, 0x13	; 19
    2ea4:	30 f4       	brcc	.+12     	; 0x2eb2 <PM_InterpretAVRISPPacket+0x30>
    2ea6:	20 31       	cpi	r18, 0x10	; 16
    2ea8:	e9 f0       	breq	.+58     	; 0x2ee4 <PM_InterpretAVRISPPacket+0x62>
    2eaa:	21 31       	cpi	r18, 0x11	; 17
    2eac:	09 f0       	breq	.+2      	; 0x2eb0 <PM_InterpretAVRISPPacket+0x2e>
    2eae:	00 c2       	rjmp	.+1024   	; 0x32b0 <PM_InterpretAVRISPPacket+0x42e>
    2eb0:	37 c0       	rjmp	.+110    	; 0x2f20 <PM_InterpretAVRISPPacket+0x9e>
    2eb2:	24 31       	cpi	r18, 0x14	; 20
    2eb4:	09 f0       	breq	.+2      	; 0x2eb8 <PM_InterpretAVRISPPacket+0x36>
    2eb6:	2d c1       	rjmp	.+602    	; 0x3112 <PM_InterpretAVRISPPacket+0x290>
    2eb8:	95 c1       	rjmp	.+810    	; 0x31e4 <PM_InterpretAVRISPPacket+0x362>
    2eba:	29 31       	cpi	r18, 0x19	; 25
    2ebc:	09 f4       	brne	.+2      	; 0x2ec0 <PM_InterpretAVRISPPacket+0x3e>
    2ebe:	8c c0       	rjmp	.+280    	; 0x2fd8 <PM_InterpretAVRISPPacket+0x156>
    2ec0:	2a 31       	cpi	r18, 0x1A	; 26
    2ec2:	38 f4       	brcc	.+14     	; 0x2ed2 <PM_InterpretAVRISPPacket+0x50>
    2ec4:	27 31       	cpi	r18, 0x17	; 23
    2ec6:	09 f4       	brne	.+2      	; 0x2eca <PM_InterpretAVRISPPacket+0x48>
    2ec8:	87 c0       	rjmp	.+270    	; 0x2fd8 <PM_InterpretAVRISPPacket+0x156>
    2eca:	28 31       	cpi	r18, 0x18	; 24
    2ecc:	09 f0       	breq	.+2      	; 0x2ed0 <PM_InterpretAVRISPPacket+0x4e>
    2ece:	f0 c1       	rjmp	.+992    	; 0x32b0 <PM_InterpretAVRISPPacket+0x42e>
    2ed0:	ce c0       	rjmp	.+412    	; 0x306e <PM_InterpretAVRISPPacket+0x1ec>
    2ed2:	2b 31       	cpi	r18, 0x1B	; 27
    2ed4:	c9 f1       	breq	.+114    	; 0x2f48 <PM_InterpretAVRISPPacket+0xc6>
    2ed6:	2b 31       	cpi	r18, 0x1B	; 27
    2ed8:	08 f4       	brcc	.+2      	; 0x2edc <PM_InterpretAVRISPPacket+0x5a>
    2eda:	c9 c0       	rjmp	.+402    	; 0x306e <PM_InterpretAVRISPPacket+0x1ec>
    2edc:	2c 31       	cpi	r18, 0x1C	; 28
    2ede:	09 f0       	breq	.+2      	; 0x2ee2 <PM_InterpretAVRISPPacket+0x60>
    2ee0:	e7 c1       	rjmp	.+974    	; 0x32b0 <PM_InterpretAVRISPPacket+0x42e>
    2ee2:	6d c0       	rjmp	.+218    	; 0x2fbe <PM_InterpretAVRISPPacket+0x13c>
    2ee4:	82 e0       	ldi	r24, 0x02	; 2
    2ee6:	90 e0       	ldi	r25, 0x00	; 0
    2ee8:	90 93 a7 02 	sts	0x02A7, r25
    2eec:	80 93 a6 02 	sts	0x02A6, r24
    2ef0:	e1 e9       	ldi	r30, 0x91	; 145
    2ef2:	f1 e0       	ldi	r31, 0x01	; 1
    2ef4:	27 e2       	ldi	r18, 0x27	; 39
    2ef6:	30 e0       	ldi	r19, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2ef8:	81 91       	ld	r24, Z+
    2efa:	d9 01       	movw	r26, r18
    2efc:	08 2e       	mov	r0, r24
    2efe:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
    2f02:	2f 5f       	subi	r18, 0xFF	; 255
    2f04:	3f 4f       	sbci	r19, 0xFF	; 255
    2f06:	81 e0       	ldi	r24, 0x01	; 1
    2f08:	ed 39       	cpi	r30, 0x9D	; 157
    2f0a:	f8 07       	cpc	r31, r24
    2f0c:	a9 f7       	brne	.-22     	; 0x2ef8 <PM_InterpretAVRISPPacket+0x76>
    2f0e:	81 e0       	ldi	r24, 0x01	; 1
    2f10:	80 93 a8 02 	sts	0x02A8, r24
    2f14:	10 92 ae 02 	sts	0x02AE, r1
    2f18:	81 b3       	in	r24, 0x11	; 17
    2f1a:	8f 7c       	andi	r24, 0xCF	; 207
    2f1c:	80 62       	ori	r24, 0x20	; 32
    2f1e:	10 c0       	rjmp	.+32     	; 0x2f40 <PM_InterpretAVRISPPacket+0xbe>
    2f20:	82 e0       	ldi	r24, 0x02	; 2
    2f22:	90 e0       	ldi	r25, 0x00	; 0
    2f24:	90 93 a7 02 	sts	0x02A7, r25
    2f28:	80 93 a6 02 	sts	0x02A6, r24
    2f2c:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <PM_CheckEndOfFuseLockData>
    2f30:	10 92 a8 02 	sts	0x02A8, r1
    2f34:	80 e0       	ldi	r24, 0x00	; 0
    2f36:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    2f3a:	81 b3       	in	r24, 0x11	; 17
    2f3c:	8f 7c       	andi	r24, 0xCF	; 207
    2f3e:	80 61       	ori	r24, 0x10	; 16
    2f40:	81 bb       	out	0x11, r24	; 17
    2f42:	10 92 92 01 	sts	0x0192, r1
    2f46:	bd c1       	rjmp	.+890    	; 0x32c2 <PM_InterpretAVRISPPacket+0x440>
    2f48:	84 e0       	ldi	r24, 0x04	; 4
    2f4a:	90 e0       	ldi	r25, 0x00	; 0
    2f4c:	90 93 a7 02 	sts	0x02A7, r25
    2f50:	80 93 a6 02 	sts	0x02A6, r24
    2f54:	10 92 92 01 	sts	0x0192, r1
    2f58:	81 e0       	ldi	r24, 0x01	; 1
    2f5a:	80 93 93 01 	sts	0x0193, r24
    2f5e:	39 c0       	rjmp	.+114    	; 0x2fd2 <PM_InterpretAVRISPPacket+0x150>
    2f60:	82 e0       	ldi	r24, 0x02	; 2
    2f62:	90 e0       	ldi	r25, 0x00	; 0
    2f64:	90 93 a7 02 	sts	0x02A7, r25
    2f68:	80 93 a6 02 	sts	0x02A6, r24
    2f6c:	e2 e9       	ldi	r30, 0x92	; 146
    2f6e:	f1 e0       	ldi	r31, 0x01	; 1
    2f70:	29 e1       	ldi	r18, 0x19	; 25
    2f72:	30 e0       	ldi	r19, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2f74:	81 91       	ld	r24, Z+
    2f76:	d9 01       	movw	r26, r18
    2f78:	08 2e       	mov	r0, r24
    2f7a:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
    2f7e:	2f 5f       	subi	r18, 0xFF	; 255
    2f80:	3f 4f       	sbci	r19, 0xFF	; 255
    2f82:	91 e0       	ldi	r25, 0x01	; 1
    2f84:	e8 39       	cpi	r30, 0x98	; 152
    2f86:	f9 07       	cpc	r31, r25
    2f88:	a9 f7       	brne	.-22     	; 0x2f74 <PM_InterpretAVRISPPacket+0xf2>
    2f8a:	2f e1       	ldi	r18, 0x1F	; 31
    2f8c:	30 e0       	ldi	r19, 0x00	; 0
    2f8e:	80 e0       	ldi	r24, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2f90:	d9 01       	movw	r26, r18
    2f92:	08 2e       	mov	r0, r24
    2f94:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
    2f98:	d9 01       	movw	r26, r18
    2f9a:	14 96       	adiw	r26, 0x04	; 4
    2f9c:	08 2e       	mov	r0, r24
    2f9e:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
    2fa2:	2f 5f       	subi	r18, 0xFF	; 255
    2fa4:	3f 4f       	sbci	r19, 0xFF	; 255
    2fa6:	e0 e0       	ldi	r30, 0x00	; 0
    2fa8:	23 32       	cpi	r18, 0x23	; 35
    2faa:	3e 07       	cpc	r19, r30
    2fac:	89 f7       	brne	.-30     	; 0x2f90 <PM_InterpretAVRISPPacket+0x10e>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2fae:	81 e0       	ldi	r24, 0x01	; 1
    2fb0:	2c 50       	subi	r18, 0x0C	; 12
    2fb2:	30 40       	sbci	r19, 0x00	; 0
    2fb4:	d9 01       	movw	r26, r18
    2fb6:	08 2e       	mov	r0, r24
    2fb8:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
    2fbc:	c2 cf       	rjmp	.-124    	; 0x2f42 <PM_InterpretAVRISPPacket+0xc0>
    2fbe:	84 e0       	ldi	r24, 0x04	; 4
    2fc0:	90 e0       	ldi	r25, 0x00	; 0
    2fc2:	90 93 a7 02 	sts	0x02A7, r25
    2fc6:	80 93 a6 02 	sts	0x02A6, r24
    2fca:	10 92 92 01 	sts	0x0192, r1
    2fce:	10 92 93 01 	sts	0x0193, r1
    2fd2:	10 92 94 01 	sts	0x0194, r1
    2fd6:	75 c1       	rjmp	.+746    	; 0x32c2 <PM_InterpretAVRISPPacket+0x440>
    2fd8:	83 e0       	ldi	r24, 0x03	; 3
    2fda:	90 e0       	ldi	r25, 0x00	; 0
    2fdc:	90 93 a7 02 	sts	0x02A7, r25
    2fe0:	80 93 a6 02 	sts	0x02A6, r24
    2fe4:	80 91 ae 02 	lds	r24, 0x02AE
    2fe8:	83 30       	cpi	r24, 0x03	; 3
    2fea:	39 f0       	breq	.+14     	; 0x2ffa <PM_InterpretAVRISPPacket+0x178>
    2fec:	83 e0       	ldi	r24, 0x03	; 3
    2fee:	80 93 ae 02 	sts	0x02AE, r24
    2ff2:	10 92 46 01 	sts	0x0146, r1
    2ff6:	10 92 45 01 	sts	0x0145, r1
    2ffa:	80 91 45 01 	lds	r24, 0x0145
    2ffe:	90 91 46 01 	lds	r25, 0x0146
    3002:	27 31       	cpi	r18, 0x17	; 23
    3004:	49 f4       	brne	.+18     	; 0x3018 <PM_InterpretAVRISPPacket+0x196>
    3006:	9c 01       	movw	r18, r24
    3008:	22 0f       	add	r18, r18
    300a:	33 1f       	adc	r19, r19
    300c:	22 0f       	add	r18, r18
    300e:	33 1f       	adc	r19, r19
    3010:	2b 5c       	subi	r18, 0xCB	; 203
    3012:	3f 4f       	sbci	r19, 0xFF	; 255
    3014:	82 e0       	ldi	r24, 0x02	; 2
    3016:	08 c0       	rjmp	.+16     	; 0x3028 <PM_InterpretAVRISPPacket+0x1a6>
    3018:	9c 01       	movw	r18, r24
    301a:	22 0f       	add	r18, r18
    301c:	33 1f       	adc	r19, r19
    301e:	22 0f       	add	r18, r18
    3020:	33 1f       	adc	r19, r19
    3022:	23 5a       	subi	r18, 0xA3	; 163
    3024:	3f 4f       	sbci	r19, 0xFF	; 255
    3026:	83 e0       	ldi	r24, 0x03	; 3
    3028:	80 93 02 01 	sts	0x0102, r24
    302c:	80 91 45 01 	lds	r24, 0x0145
    3030:	90 91 46 01 	lds	r25, 0x0146
    3034:	0a 97       	sbiw	r24, 0x0a	; 10
    3036:	b0 f4       	brcc	.+44     	; 0x3064 <PM_InterpretAVRISPPacket+0x1e2>
    3038:	e2 e9       	ldi	r30, 0x92	; 146
    303a:	f1 e0       	ldi	r31, 0x01	; 1

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    303c:	81 91       	ld	r24, Z+
    303e:	d9 01       	movw	r26, r18
    3040:	08 2e       	mov	r0, r24
    3042:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
    3046:	2f 5f       	subi	r18, 0xFF	; 255
    3048:	3f 4f       	sbci	r19, 0xFF	; 255
    304a:	81 e0       	ldi	r24, 0x01	; 1
    304c:	e6 39       	cpi	r30, 0x96	; 150
    304e:	f8 07       	cpc	r31, r24
    3050:	a9 f7       	brne	.-22     	; 0x303c <PM_InterpretAVRISPPacket+0x1ba>
    3052:	80 91 45 01 	lds	r24, 0x0145
    3056:	90 91 46 01 	lds	r25, 0x0146
    305a:	01 96       	adiw	r24, 0x01	; 1
    305c:	90 93 46 01 	sts	0x0146, r25
    3060:	80 93 45 01 	sts	0x0145, r24
    3064:	10 92 92 01 	sts	0x0192, r1
    3068:	10 92 93 01 	sts	0x0193, r1
    306c:	2a c1       	rjmp	.+596    	; 0x32c2 <PM_InterpretAVRISPPacket+0x440>
    306e:	84 e0       	ldi	r24, 0x04	; 4
    3070:	90 e0       	ldi	r25, 0x00	; 0
    3072:	90 93 a7 02 	sts	0x02A7, r25
    3076:	80 93 a6 02 	sts	0x02A6, r24
    307a:	80 91 ae 02 	lds	r24, 0x02AE
    307e:	84 30       	cpi	r24, 0x04	; 4
    3080:	49 f0       	breq	.+18     	; 0x3094 <PM_InterpretAVRISPPacket+0x212>
    3082:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <PM_CheckEndOfFuseLockData>
    3086:	10 92 46 01 	sts	0x0146, r1
    308a:	10 92 45 01 	sts	0x0145, r1
    308e:	84 e0       	ldi	r24, 0x04	; 4
    3090:	80 93 ae 02 	sts	0x02AE, r24
    3094:	40 91 45 01 	lds	r20, 0x0145
    3098:	50 91 46 01 	lds	r21, 0x0146
    309c:	60 91 91 01 	lds	r22, 0x0191
    30a0:	68 31       	cpi	r22, 0x18	; 24
    30a2:	19 f0       	breq	.+6      	; 0x30aa <PM_InterpretAVRISPPacket+0x228>
    30a4:	a4 e3       	ldi	r26, 0x34	; 52
    30a6:	b0 e0       	ldi	r27, 0x00	; 0
    30a8:	02 c0       	rjmp	.+4      	; 0x30ae <PM_InterpretAVRISPPacket+0x22c>
    30aa:	a3 e3       	ldi	r26, 0x33	; 51
    30ac:	b0 e0       	ldi	r27, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    30ae:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
    30b2:	80 2d       	mov	r24, r0
    30b4:	99 27       	eor	r25, r25
    30b6:	84 17       	cp	r24, r20
    30b8:	95 07       	cpc	r25, r21
    30ba:	10 f4       	brcc	.+4      	; 0x30c0 <PM_InterpretAVRISPPacket+0x23e>
    30bc:	8f ef       	ldi	r24, 0xFF	; 255
    30be:	1e c0       	rjmp	.+60     	; 0x30fc <PM_InterpretAVRISPPacket+0x27a>
    30c0:	80 91 92 01 	lds	r24, 0x0192
    30c4:	81 50       	subi	r24, 0x01	; 1
    30c6:	24 2f       	mov	r18, r20
    30c8:	33 27       	eor	r19, r19
    30ca:	99 27       	eor	r25, r25
    30cc:	68 31       	cpi	r22, 0x18	; 24
    30ce:	51 f4       	brne	.+20     	; 0x30e4 <PM_InterpretAVRISPPacket+0x262>
    30d0:	d9 01       	movw	r26, r18
    30d2:	aa 0f       	add	r26, r26
    30d4:	bb 1f       	adc	r27, r27
    30d6:	aa 0f       	add	r26, r26
    30d8:	bb 1f       	adc	r27, r27
    30da:	a8 0f       	add	r26, r24
    30dc:	b9 1f       	adc	r27, r25
    30de:	ab 5c       	subi	r26, 0xCB	; 203
    30e0:	bf 4f       	sbci	r27, 0xFF	; 255
    30e2:	09 c0       	rjmp	.+18     	; 0x30f6 <PM_InterpretAVRISPPacket+0x274>
    30e4:	d9 01       	movw	r26, r18
    30e6:	aa 0f       	add	r26, r26
    30e8:	bb 1f       	adc	r27, r27
    30ea:	aa 0f       	add	r26, r26
    30ec:	bb 1f       	adc	r27, r27
    30ee:	a8 0f       	add	r26, r24
    30f0:	b9 1f       	adc	r27, r25
    30f2:	a3 5a       	subi	r26, 0xA3	; 163
    30f4:	bf 4f       	sbci	r27, 0xFF	; 255
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    30f6:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__eeprom_read_byte_1F2021>
    30fa:	80 2d       	mov	r24, r0
    30fc:	80 93 93 01 	sts	0x0193, r24
    3100:	4f 5f       	subi	r20, 0xFF	; 255
    3102:	5f 4f       	sbci	r21, 0xFF	; 255
    3104:	50 93 46 01 	sts	0x0146, r21
    3108:	40 93 45 01 	sts	0x0145, r20
    310c:	10 92 92 01 	sts	0x0192, r1
    3110:	60 cf       	rjmp	.-320    	; 0x2fd2 <PM_InterpretAVRISPPacket+0x150>
    3112:	82 e0       	ldi	r24, 0x02	; 2
    3114:	90 e0       	ldi	r25, 0x00	; 0
    3116:	90 93 a7 02 	sts	0x02A7, r25
    311a:	80 93 a6 02 	sts	0x02A6, r24
    311e:	80 91 ae 02 	lds	r24, 0x02AE
    3122:	81 30       	cpi	r24, 0x01	; 1
    3124:	11 f1       	breq	.+68     	; 0x316a <PM_InterpretAVRISPPacket+0x2e8>
    3126:	23 31       	cpi	r18, 0x13	; 19
    3128:	31 f4       	brne	.+12     	; 0x3136 <PM_InterpretAVRISPPacket+0x2b4>
    312a:	81 e0       	ldi	r24, 0x01	; 1
    312c:	0e 94 3f 14 	call	0x287e	; 0x287e <PM_SetupDFAddressCounters>
    3130:	c3 e0       	ldi	r28, 0x03	; 3
    3132:	d0 e0       	ldi	r29, 0x00	; 0
    3134:	05 c0       	rjmp	.+10     	; 0x3140 <PM_InterpretAVRISPPacket+0x2be>
    3136:	80 e0       	ldi	r24, 0x00	; 0
    3138:	0e 94 3f 14 	call	0x287e	; 0x287e <PM_SetupDFAddressCounters>
    313c:	cd e0       	ldi	r28, 0x0D	; 13
    313e:	d0 e0       	ldi	r29, 0x00	; 0
    3140:	80 91 45 01 	lds	r24, 0x0145
    3144:	90 91 46 01 	lds	r25, 0x0146
    3148:	0e 94 c7 0a 	call	0x158e	; 0x158e <DF_BufferWriteEnable>
    314c:	81 e0       	ldi	r24, 0x01	; 1
    314e:	80 93 ae 02 	sts	0x02AE, r24
    3152:	e2 e9       	ldi	r30, 0x92	; 146
    3154:	f1 e0       	ldi	r31, 0x01	; 1

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    3156:	81 91       	ld	r24, Z+
    3158:	de 01       	movw	r26, r28
    315a:	08 2e       	mov	r0, r24
    315c:	0e 94 87 1a 	call	0x350e	; 0x350e <__eeprom_write_byte_1F2021>
    3160:	21 96       	adiw	r28, 0x01	; 1
    3162:	91 e0       	ldi	r25, 0x01	; 1
    3164:	eb 39       	cpi	r30, 0x9B	; 155
    3166:	f9 07       	cpc	r31, r25
    3168:	b1 f7       	brne	.-20     	; 0x3156 <PM_InterpretAVRISPPacket+0x2d4>
    316a:	80 91 92 01 	lds	r24, 0x0192
    316e:	99 27       	eor	r25, r25
    3170:	d8 2f       	mov	r29, r24
    3172:	cc 27       	eor	r28, r28
    3174:	80 91 93 01 	lds	r24, 0x0193
    3178:	99 27       	eor	r25, r25
    317a:	c8 2b       	or	r28, r24
    317c:	d9 2b       	or	r29, r25
    317e:	01 e9       	ldi	r16, 0x91	; 145
    3180:	11 e0       	ldi	r17, 0x01	; 1
    3182:	06 c0       	rjmp	.+12     	; 0x3190 <PM_InterpretAVRISPPacket+0x30e>
    3184:	f8 01       	movw	r30, r16
    3186:	82 85       	ldd	r24, Z+10	; 0x0a
    3188:	0e 94 14 15 	call	0x2a28	; 0x2a28 <PM_StoreProgramByte>
    318c:	0f 5f       	subi	r16, 0xFF	; 255
    318e:	1f 4f       	sbci	r17, 0xFF	; 255
    3190:	ce 01       	movw	r24, r28
    3192:	8f 56       	subi	r24, 0x6F	; 111
    3194:	9e 4f       	sbci	r25, 0xFE	; 254
    3196:	08 17       	cp	r16, r24
    3198:	19 07       	cpc	r17, r25
    319a:	a1 f7       	brne	.-24     	; 0x3184 <PM_InterpretAVRISPPacket+0x302>
    319c:	20 91 af 02 	lds	r18, 0x02AF
    31a0:	30 91 b0 02 	lds	r19, 0x02B0
    31a4:	37 fd       	sbrc	r19, 7
    31a6:	cd ce       	rjmp	.-614    	; 0x2f42 <PM_InterpretAVRISPPacket+0xc0>
    31a8:	80 91 94 01 	lds	r24, 0x0194
    31ac:	87 ff       	sbrs	r24, 7
    31ae:	c9 ce       	rjmp	.-622    	; 0x2f42 <PM_InterpretAVRISPPacket+0xc0>
    31b0:	21 15       	cp	r18, r1
    31b2:	31 05       	cpc	r19, r1
    31b4:	09 f4       	brne	.+2      	; 0x31b8 <PM_InterpretAVRISPPacket+0x336>
    31b6:	c5 ce       	rjmp	.-630    	; 0x2f42 <PM_InterpretAVRISPPacket+0xc0>
    31b8:	80 91 02 01 	lds	r24, 0x0102
    31bc:	81 30       	cpi	r24, 0x01	; 1
    31be:	19 f4       	brne	.+6      	; 0x31c6 <PM_InterpretAVRISPPacket+0x344>
    31c0:	a5 e8       	ldi	r26, 0x85	; 133
    31c2:	b0 e0       	ldi	r27, 0x00	; 0
    31c4:	02 c0       	rjmp	.+4      	; 0x31ca <PM_InterpretAVRISPPacket+0x348>
    31c6:	a7 e8       	ldi	r26, 0x87	; 135
    31c8:	b0 e0       	ldi	r27, 0x00	; 0

void 
eeprom_write_word (uint16_t *addr,uint16_t value)
{
  asm volatile (
    31ca:	09 01       	movw	r0, r18
    31cc:	0e 94 93 1a 	call	0x3526	; 0x3526 <__eeprom_write_word_1F2021>
    31d0:	80 91 af 02 	lds	r24, 0x02AF
    31d4:	90 91 b0 02 	lds	r25, 0x02B0
    31d8:	90 68       	ori	r25, 0x80	; 128
    31da:	90 93 b0 02 	sts	0x02B0, r25
    31de:	80 93 af 02 	sts	0x02AF, r24
    31e2:	af ce       	rjmp	.-674    	; 0x2f42 <PM_InterpretAVRISPPacket+0xc0>
    31e4:	80 91 ae 02 	lds	r24, 0x02AE
    31e8:	82 30       	cpi	r24, 0x02	; 2
    31ea:	01 f1       	breq	.+64     	; 0x322c <PM_InterpretAVRISPPacket+0x3aa>
    31ec:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <PM_CheckEndOfFuseLockData>
    31f0:	90 e0       	ldi	r25, 0x00	; 0
    31f2:	80 91 91 01 	lds	r24, 0x0191
    31f6:	84 31       	cpi	r24, 0x14	; 20
    31f8:	09 f4       	brne	.+2      	; 0x31fc <PM_InterpretAVRISPPacket+0x37a>
    31fa:	91 e0       	ldi	r25, 0x01	; 1
    31fc:	89 2f       	mov	r24, r25
    31fe:	0e 94 3f 14 	call	0x287e	; 0x287e <PM_SetupDFAddressCounters>
    3202:	60 91 45 01 	lds	r22, 0x0145
    3206:	70 91 46 01 	lds	r23, 0x0146
    320a:	80 91 43 01 	lds	r24, 0x0143
    320e:	90 91 44 01 	lds	r25, 0x0144
    3212:	0e 94 8c 0a 	call	0x1518	; 0x1518 <DF_ContinuousReadEnable>
    3216:	82 e0       	ldi	r24, 0x02	; 2
    3218:	80 93 ae 02 	sts	0x02AE, r24
    321c:	10 92 a9 02 	sts	0x02A9, r1
    3220:	10 92 aa 02 	sts	0x02AA, r1
    3224:	10 92 ab 02 	sts	0x02AB, r1
    3228:	10 92 ac 02 	sts	0x02AC, r1
    322c:	80 91 92 01 	lds	r24, 0x0192
    3230:	99 27       	eor	r25, r25
    3232:	d8 2f       	mov	r29, r24
    3234:	cc 27       	eor	r28, r28
    3236:	80 91 93 01 	lds	r24, 0x0193
    323a:	99 27       	eor	r25, r25
    323c:	c8 2b       	or	r28, r24
    323e:	d9 2b       	or	r29, r25
    3240:	90 e0       	ldi	r25, 0x00	; 0
    3242:	80 91 91 01 	lds	r24, 0x0191
    3246:	84 31       	cpi	r24, 0x14	; 20
    3248:	09 f4       	brne	.+2      	; 0x324c <PM_InterpretAVRISPPacket+0x3ca>
    324a:	91 e0       	ldi	r25, 0x01	; 1
    324c:	89 2f       	mov	r24, r25
    324e:	0e 94 e4 14 	call	0x29c8	; 0x29c8 <PM_GetStoredDataSize>
    3252:	7b 01       	movw	r14, r22
    3254:	01 e9       	ldi	r16, 0x91	; 145
    3256:	11 e0       	ldi	r17, 0x01	; 1
    3258:	1b c0       	rjmp	.+54     	; 0x3290 <PM_InterpretAVRISPPacket+0x40e>
    325a:	97 01       	movw	r18, r14
    325c:	44 27       	eor	r20, r20
    325e:	55 27       	eor	r21, r21
    3260:	80 91 a9 02 	lds	r24, 0x02A9
    3264:	90 91 aa 02 	lds	r25, 0x02AA
    3268:	a0 91 ab 02 	lds	r26, 0x02AB
    326c:	b0 91 ac 02 	lds	r27, 0x02AC
    3270:	82 17       	cp	r24, r18
    3272:	93 07       	cpc	r25, r19
    3274:	a4 07       	cpc	r26, r20
    3276:	b5 07       	cpc	r27, r21
    3278:	10 f0       	brcs	.+4      	; 0x327e <PM_InterpretAVRISPPacket+0x3fc>
    327a:	8f ef       	ldi	r24, 0xFF	; 255
    327c:	03 c0       	rjmp	.+6      	; 0x3284 <PM_InterpretAVRISPPacket+0x402>
    327e:	80 e0       	ldi	r24, 0x00	; 0
    3280:	0e 94 af 09 	call	0x135e	; 0x135e <SPI_SPITransmit>
    3284:	f8 01       	movw	r30, r16
    3286:	82 83       	std	Z+2, r24	; 0x02
    3288:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <V2P_IncrementCurrAddress>
    328c:	0f 5f       	subi	r16, 0xFF	; 255
    328e:	1f 4f       	sbci	r17, 0xFF	; 255
    3290:	ce 01       	movw	r24, r28
    3292:	8f 56       	subi	r24, 0x6F	; 111
    3294:	9e 4f       	sbci	r25, 0xFE	; 254
    3296:	08 17       	cp	r16, r24
    3298:	19 07       	cpc	r17, r25
    329a:	f9 f6       	brne	.-66     	; 0x325a <PM_InterpretAVRISPPacket+0x3d8>
    329c:	23 96       	adiw	r28, 0x03	; 3
    329e:	d0 93 a7 02 	sts	0x02A7, r29
    32a2:	c0 93 a6 02 	sts	0x02A6, r28
    32a6:	10 92 92 01 	sts	0x0192, r1
    32aa:	f8 01       	movw	r30, r16
    32ac:	12 82       	std	Z+2, r1	; 0x02
    32ae:	09 c0       	rjmp	.+18     	; 0x32c2 <PM_InterpretAVRISPPacket+0x440>
    32b0:	81 e0       	ldi	r24, 0x01	; 1
    32b2:	90 e0       	ldi	r25, 0x00	; 0
    32b4:	90 93 a7 02 	sts	0x02A7, r25
    32b8:	80 93 a6 02 	sts	0x02A6, r24
    32bc:	89 ec       	ldi	r24, 0xC9	; 201
    32be:	80 93 92 01 	sts	0x0192, r24
    32c2:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <V2P_SendPacket>
    32c6:	df 91       	pop	r29
    32c8:	cf 91       	pop	r28
    32ca:	1f 91       	pop	r17
    32cc:	0f 91       	pop	r16
    32ce:	ff 90       	pop	r15
    32d0:	ef 90       	pop	r14
    32d2:	08 95       	ret

000032d4 <TM_FindNextTag>:
	DF_EnableDataflash(FALSE);
}

void TM_FindNextTag(void)
{
    32d4:	cf 92       	push	r12
    32d6:	df 92       	push	r13
    32d8:	ef 92       	push	r14
    32da:	ff 92       	push	r15
    32dc:	0f 93       	push	r16
    32de:	1f 93       	push	r17
    32e0:	cf 93       	push	r28
    32e2:	df 93       	push	r29
    32e4:	cd b7       	in	r28, 0x3d	; 61
    32e6:	de b7       	in	r29, 0x3e	; 62
    32e8:	69 97       	sbiw	r28, 0x19	; 25
    32ea:	0f b6       	in	r0, 0x3f	; 63
    32ec:	f8 94       	cli
    32ee:	de bf       	out	0x3e, r29	; 62
    32f0:	0f be       	out	0x3f, r0	; 63
    32f2:	cd bf       	out	0x3d, r28	; 61
	uint8_t  Buffer[21];
	uint8_t  HeadBuff[4]      = BT_TAGHEADER;
    32f4:	80 e4       	ldi	r24, 0x40	; 64
    32f6:	89 83       	std	Y+1, r24	; 0x01
    32f8:	88 e2       	ldi	r24, 0x28	; 40
    32fa:	8a 83       	std	Y+2, r24	; 0x02
    32fc:	83 e2       	ldi	r24, 0x23	; 35
    32fe:	8b 83       	std	Y+3, r24	; 0x03
    3300:	89 e2       	ldi	r24, 0x29	; 41
    3302:	8c 83       	std	Y+4, r24	; 0x04
	uint32_t ProgDataSize     = PM_GetStoredDataSize(TYPE_FLASH);
    3304:	81 e0       	ldi	r24, 0x01	; 1
    3306:	0e 94 e4 14 	call	0x29c8	; 0x29c8 <PM_GetStoredDataSize>
    330a:	6b 01       	movw	r12, r22
    330c:	7c 01       	movw	r14, r24
	uint8_t  TotalOkHeadBytes = 0;
	uint8_t  TagByte;
	uint8_t  BytesRead;
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);    // Orange = busy
    330e:	81 b3       	in	r24, 0x11	; 17
    3310:	8f 7c       	andi	r24, 0xCF	; 207
    3312:	80 63       	ori	r24, 0x30	; 48
    3314:	81 bb       	out	0x11, r24	; 17

	while (DFPos < ProgDataSize)
	{
		BytesRead = 1;
		
		TagByte = SPI_SPITransmit(0x00);       // Get next byte from dataflash
		if (TagByte == HeadBuff[TotalOkHeadBytes++])
		{
			if (TotalOkHeadBytes == 4)
			{
				uint8_t HB;
			
				for (HB = 0; HB < 20; HB++)
				{
					TagByte = SPI_SPITransmit(0x00);
					Buffer[HB] = TagByte;
					
					if (TagByte == 0x00)
					  break;
				}
				
				Buffer[20] = '\0';             // Make sure string is null-terminated

				TagExists = TRUE;
				BytesRead = (HB + 2);

				LCD_puts(Buffer);
				MAIN_SETSTATUSLED(MAIN_STATLED_GREEN); // Green = ready
				return;
			}
		}
		else
		{
			TotalOkHeadBytes = ((TagByte == HeadBuff[0])? 1 : 0);
    3316:	09 81       	ldd	r16, Y+1	; 0x01
    3318:	10 e0       	ldi	r17, 0x00	; 0
    331a:	42 c0       	rjmp	.+132    	; 0x33a0 <TM_FindNextTag+0xcc>
    331c:	80 e0       	ldi	r24, 0x00	; 0
    331e:	0e 94 af 09 	call	0x135e	; 0x135e <SPI_SPITransmit>
    3322:	98 2f       	mov	r25, r24
    3324:	fe 01       	movw	r30, r28
    3326:	e1 0f       	add	r30, r17
    3328:	f1 1d       	adc	r31, r1
    332a:	81 81       	ldd	r24, Z+1	; 0x01
    332c:	98 17       	cp	r25, r24
    332e:	09 f5       	brne	.+66     	; 0x3372 <TM_FindNextTag+0x9e>
    3330:	1f 5f       	subi	r17, 0xFF	; 255
    3332:	14 30       	cpi	r17, 0x04	; 4
    3334:	11 f5       	brne	.+68     	; 0x337a <TM_FindNextTag+0xa6>
    3336:	8e 01       	movw	r16, r28
    3338:	0b 5f       	subi	r16, 0xFB	; 251
    333a:	1f 4f       	sbci	r17, 0xFF	; 255
    333c:	80 e0       	ldi	r24, 0x00	; 0
    333e:	0e 94 af 09 	call	0x135e	; 0x135e <SPI_SPITransmit>
    3342:	f8 01       	movw	r30, r16
    3344:	80 83       	st	Z, r24
    3346:	88 23       	and	r24, r24
    3348:	39 f0       	breq	.+14     	; 0x3358 <TM_FindNextTag+0x84>
    334a:	0f 5f       	subi	r16, 0xFF	; 255
    334c:	1f 4f       	sbci	r17, 0xFF	; 255
    334e:	ce 01       	movw	r24, r28
    3350:	49 96       	adiw	r24, 0x19	; 25
    3352:	08 17       	cp	r16, r24
    3354:	19 07       	cpc	r17, r25
    3356:	91 f7       	brne	.-28     	; 0x333c <TM_FindNextTag+0x68>
    3358:	19 8e       	std	Y+25, r1	; 0x19
    335a:	81 e0       	ldi	r24, 0x01	; 1
    335c:	80 93 b1 02 	sts	0x02B1, r24
    3360:	ce 01       	movw	r24, r28
    3362:	05 96       	adiw	r24, 0x05	; 5
    3364:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <LCD_puts>
    3368:	81 b3       	in	r24, 0x11	; 17
    336a:	8f 7c       	andi	r24, 0xCF	; 207
    336c:	80 61       	ori	r24, 0x10	; 16
    336e:	81 bb       	out	0x11, r24	; 17
    3370:	42 c0       	rjmp	.+132    	; 0x33f6 <TM_FindNextTag+0x122>
    3372:	10 e0       	ldi	r17, 0x00	; 0
    3374:	90 17       	cp	r25, r16
    3376:	09 f4       	brne	.+2      	; 0x337a <TM_FindNextTag+0xa6>
    3378:	11 e0       	ldi	r17, 0x01	; 1
		}

		DFPos += BytesRead;
    337a:	80 91 b2 02 	lds	r24, 0x02B2
    337e:	90 91 b3 02 	lds	r25, 0x02B3
    3382:	a0 91 b4 02 	lds	r26, 0x02B4
    3386:	b0 91 b5 02 	lds	r27, 0x02B5
    338a:	01 96       	adiw	r24, 0x01	; 1
    338c:	a1 1d       	adc	r26, r1
    338e:	b1 1d       	adc	r27, r1
    3390:	80 93 b2 02 	sts	0x02B2, r24
    3394:	90 93 b3 02 	sts	0x02B3, r25
    3398:	a0 93 b4 02 	sts	0x02B4, r26
    339c:	b0 93 b5 02 	sts	0x02B5, r27
    33a0:	80 91 b2 02 	lds	r24, 0x02B2
    33a4:	90 91 b3 02 	lds	r25, 0x02B3
    33a8:	a0 91 b4 02 	lds	r26, 0x02B4
    33ac:	b0 91 b5 02 	lds	r27, 0x02B5
    33b0:	8c 15       	cp	r24, r12
    33b2:	9d 05       	cpc	r25, r13
    33b4:	ae 05       	cpc	r26, r14
    33b6:	bf 05       	cpc	r27, r15
    33b8:	08 f4       	brcc	.+2      	; 0x33bc <TM_FindNextTag+0xe8>
    33ba:	b0 cf       	rjmp	.-160    	; 0x331c <TM_FindNextTag+0x48>
	}
	
	DF_ContinuousReadEnable(0, 0);
    33bc:	60 e0       	ldi	r22, 0x00	; 0
    33be:	70 e0       	ldi	r23, 0x00	; 0
    33c0:	80 e0       	ldi	r24, 0x00	; 0
    33c2:	90 e0       	ldi	r25, 0x00	; 0
    33c4:	0e 94 8c 0a 	call	0x1518	; 0x1518 <DF_ContinuousReadEnable>
	DFPos = 0;
    33c8:	10 92 b2 02 	sts	0x02B2, r1
    33cc:	10 92 b3 02 	sts	0x02B3, r1
    33d0:	10 92 b4 02 	sts	0x02B4, r1
    33d4:	10 92 b5 02 	sts	0x02B5, r1
	
	if (TagExists == FALSE)
    33d8:	80 91 b1 02 	lds	r24, 0x02B1
    33dc:	88 23       	and	r24, r24
    33de:	49 f4       	brne	.+18     	; 0x33f2 <TM_FindNextTag+0x11e>
	{
		MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);  // Green = ready
    33e0:	81 b3       	in	r24, 0x11	; 17
    33e2:	8f 7c       	andi	r24, 0xCF	; 207
    33e4:	80 61       	ori	r24, 0x10	; 16
    33e6:	81 bb       	out	0x11, r24	; 17
		MAIN_ShowError(PSTR("NO TAGS"));
    33e8:	8e e5       	ldi	r24, 0x5E	; 94
    33ea:	94 e0       	ldi	r25, 0x04	; 4
    33ec:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
    33f0:	02 c0       	rjmp	.+4      	; 0x33f6 <TM_FindNextTag+0x122>
	}
	else
	{
		/* The following line _is_ recursion, but the function will only ever call itself
		   a maximum of one time. The function will call itself upon skipping from the last
		   tag stored in the program data to the first; to guard against infinite recursion
		   if no tags are present, the system will error out if the TagExists flag is empty
		   after a full data read. Once a tag has been read and displayed onto the LCD, the
           function returns to the main tag handling routine.                               */
		TM_FindNextTag();
    33f2:	0e 94 6a 19 	call	0x32d4	; 0x32d4 <TM_FindNextTag>
    33f6:	69 96       	adiw	r28, 0x19	; 25
    33f8:	0f b6       	in	r0, 0x3f	; 63
    33fa:	f8 94       	cli
    33fc:	de bf       	out	0x3e, r29	; 62
    33fe:	0f be       	out	0x3f, r0	; 63
    3400:	cd bf       	out	0x3d, r28	; 61
    3402:	df 91       	pop	r29
    3404:	cf 91       	pop	r28
    3406:	1f 91       	pop	r17
    3408:	0f 91       	pop	r16
    340a:	ff 90       	pop	r15
    340c:	ef 90       	pop	r14
    340e:	df 90       	pop	r13
    3410:	cf 90       	pop	r12
    3412:	08 95       	ret

00003414 <TM_ShowTags>:
    3414:	60 e0       	ldi	r22, 0x00	; 0
    3416:	70 e0       	ldi	r23, 0x00	; 0
    3418:	80 e0       	ldi	r24, 0x00	; 0
    341a:	90 e0       	ldi	r25, 0x00	; 0
    341c:	0e 94 8c 0a 	call	0x1518	; 0x1518 <DF_ContinuousReadEnable>
    3420:	10 92 b1 02 	sts	0x02B1, r1
    3424:	10 92 b2 02 	sts	0x02B2, r1
    3428:	10 92 b3 02 	sts	0x02B3, r1
    342c:	10 92 b4 02 	sts	0x02B4, r1
    3430:	10 92 b5 02 	sts	0x02B5, r1
    3434:	0e 94 6a 19 	call	0x32d4	; 0x32d4 <TM_FindNextTag>
    3438:	80 91 b1 02 	lds	r24, 0x02B1
    343c:	88 23       	and	r24, r24
    343e:	71 f0       	breq	.+28     	; 0x345c <TM_ShowTags+0x48>
    3440:	8e b3       	in	r24, 0x1e	; 30
    3442:	88 23       	and	r24, r24
    3444:	e9 f3       	breq	.-6      	; 0x3440 <TM_ShowTags+0x2c>
    3446:	f7 9b       	sbis	0x1e, 7	; 30
    3448:	03 c0       	rjmp	.+6      	; 0x3450 <TM_ShowTags+0x3c>
    344a:	0e 94 6a 19 	call	0x32d4	; 0x32d4 <TM_FindNextTag>
    344e:	02 c0       	rjmp	.+4      	; 0x3454 <TM_ShowTags+0x40>
    3450:	f2 99       	sbic	0x1e, 2	; 30
    3452:	03 c0       	rjmp	.+6      	; 0x345a <TM_ShowTags+0x46>
    3454:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
    3458:	f3 cf       	rjmp	.-26     	; 0x3440 <TM_ShowTags+0x2c>
    345a:	80 e0       	ldi	r24, 0x00	; 0
    345c:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DF_EnableDataflash>
    3460:	08 95       	ret

00003462 <__vector_2>:
.global PCINT0_vect             ; Pin change 0 (joystick)
.global PCINT1_vect             ; Pin change 1 (joystick)

PCINT0_vect:
  jmp PCINT1_vect
    3462:	0c 94 bb 02 	jmp	0x576	; 0x576 <__vector_3>

00003466 <__vector_10>:

.global TIMER0_COMP_vect             ; Timer 0 compare

TIMER0_COMP_vect:
  push r24
    3466:	8f 93       	push	r24
  ldi r24, (USI_CONTROL_REG_FLAGS | (1<<USITC))
    3468:	8b e5       	ldi	r24, 0x5B	; 91
  sts _SFR_MEM_ADDR(USICR), r24
    346a:	80 93 b8 00 	sts	0x00B8, r24
  pop r24
    346e:	8f 91       	pop	r24
  reti
    3470:	18 95       	reti

00003472 <strcpy_P>:
    3472:	fb 01       	movw	r30, r22
    3474:	dc 01       	movw	r26, r24
    3476:	05 90       	lpm	r0, Z+
    3478:	0d 92       	st	X+, r0
    347a:	00 20       	and	r0, r0
    347c:	e1 f7       	brne	.-8      	; 0x3476 <strcpy_P+0x4>
    347e:	08 95       	ret

00003480 <ultoa>:
    3480:	fa 01       	movw	r30, r20
    3482:	cf 93       	push	r28
    3484:	ff 93       	push	r31
    3486:	ef 93       	push	r30
    3488:	22 30       	cpi	r18, 0x02	; 2
    348a:	cc f0       	brlt	.+50     	; 0x34be <ultoa+0x3e>
    348c:	25 32       	cpi	r18, 0x25	; 37
    348e:	bc f4       	brge	.+46     	; 0x34be <ultoa+0x3e>
    3490:	c2 2f       	mov	r28, r18
    3492:	2c 2f       	mov	r18, r28
    3494:	33 27       	eor	r19, r19
    3496:	44 27       	eor	r20, r20
    3498:	55 27       	eor	r21, r21
    349a:	ff 93       	push	r31
    349c:	ef 93       	push	r30
    349e:	0e 94 9d 1a 	call	0x353a	; 0x353a <__udivmodsi4>
    34a2:	ef 91       	pop	r30
    34a4:	ff 91       	pop	r31
    34a6:	60 5d       	subi	r22, 0xD0	; 208
    34a8:	6a 33       	cpi	r22, 0x3A	; 58
    34aa:	0c f0       	brlt	.+2      	; 0x34ae <ultoa+0x2e>
    34ac:	69 5d       	subi	r22, 0xD9	; 217
    34ae:	61 93       	st	Z+, r22
    34b0:	b9 01       	movw	r22, r18
    34b2:	ca 01       	movw	r24, r20
    34b4:	60 50       	subi	r22, 0x00	; 0
    34b6:	70 40       	sbci	r23, 0x00	; 0
    34b8:	80 40       	sbci	r24, 0x00	; 0
    34ba:	90 40       	sbci	r25, 0x00	; 0
    34bc:	51 f7       	brne	.-44     	; 0x3492 <ultoa+0x12>
    34be:	10 82       	st	Z, r1
    34c0:	8f 91       	pop	r24
    34c2:	9f 91       	pop	r25
    34c4:	cf 91       	pop	r28
    34c6:	0c 94 65 1a 	jmp	0x34ca	; 0x34ca <strrev>

000034ca <strrev>:
    34ca:	dc 01       	movw	r26, r24
    34cc:	fc 01       	movw	r30, r24
    34ce:	01 90       	ld	r0, Z+
    34d0:	00 20       	and	r0, r0
    34d2:	e9 f7       	brne	.-6      	; 0x34ce <strrev+0x4>
    34d4:	32 97       	sbiw	r30, 0x02	; 2
    34d6:	ae 17       	cp	r26, r30
    34d8:	bf 07       	cpc	r27, r31
    34da:	30 f4       	brcc	.+12     	; 0x34e8 <strrev+0x1e>
    34dc:	7c 91       	ld	r23, X
    34de:	60 81       	ld	r22, Z
    34e0:	70 83       	st	Z, r23
    34e2:	31 97       	sbiw	r30, 0x01	; 1
    34e4:	6d 93       	st	X+, r22
    34e6:	f7 cf       	rjmp	.-18     	; 0x34d6 <strrev+0xc>
    34e8:	08 95       	ret

000034ea <__eeprom_read_byte_1F2021>:
    34ea:	f9 99       	sbic	0x1f, 1	; 31
    34ec:	fe cf       	rjmp	.-4      	; 0x34ea <__eeprom_read_byte_1F2021>
    34ee:	b2 bd       	out	0x22, r27	; 34
    34f0:	a1 bd       	out	0x21, r26	; 33
    34f2:	f8 9a       	sbi	0x1f, 0	; 31
    34f4:	11 96       	adiw	r26, 0x01	; 1
    34f6:	00 b4       	in	r0, 0x20	; 32
    34f8:	08 95       	ret

000034fa <__eeprom_read_block_1F2021>:
    34fa:	f7 df       	rcall	.-18     	; 0x34ea <__eeprom_read_byte_1F2021>
    34fc:	01 92       	st	Z+, r0
    34fe:	1a 94       	dec	r1
    3500:	e1 f7       	brne	.-8      	; 0x34fa <__eeprom_read_block_1F2021>
    3502:	08 95       	ret

00003504 <__eeprom_read_word_1F2021>:
    3504:	f2 df       	rcall	.-28     	; 0x34ea <__eeprom_read_byte_1F2021>
    3506:	e0 2d       	mov	r30, r0
    3508:	f0 df       	rcall	.-32     	; 0x34ea <__eeprom_read_byte_1F2021>
    350a:	f0 2d       	mov	r31, r0
    350c:	08 95       	ret

0000350e <__eeprom_write_byte_1F2021>:
    350e:	f9 99       	sbic	0x1f, 1	; 31
    3510:	fe cf       	rjmp	.-4      	; 0x350e <__eeprom_write_byte_1F2021>
    3512:	b2 bd       	out	0x22, r27	; 34
    3514:	a1 bd       	out	0x21, r26	; 33
    3516:	00 bc       	out	0x20, r0	; 32
    3518:	11 96       	adiw	r26, 0x01	; 1
    351a:	0f b6       	in	r0, 0x3f	; 63
    351c:	f8 94       	cli
    351e:	fa 9a       	sbi	0x1f, 2	; 31
    3520:	f9 9a       	sbi	0x1f, 1	; 31
    3522:	0f be       	out	0x3f, r0	; 63
    3524:	08 95       	ret

00003526 <__eeprom_write_word_1F2021>:
    3526:	f3 df       	rcall	.-26     	; 0x350e <__eeprom_write_byte_1F2021>
    3528:	01 2c       	mov	r0, r1
    352a:	f1 df       	rcall	.-30     	; 0x350e <__eeprom_write_byte_1F2021>
    352c:	11 24       	eor	r1, r1
    352e:	08 95       	ret

00003530 <__eeprom_write_block_1F2021>:
    3530:	01 90       	ld	r0, Z+
    3532:	ed df       	rcall	.-38     	; 0x350e <__eeprom_write_byte_1F2021>
    3534:	1a 94       	dec	r1
    3536:	e1 f7       	brne	.-8      	; 0x3530 <__eeprom_write_block_1F2021>
    3538:	08 95       	ret

0000353a <__udivmodsi4>:
    353a:	a1 e2       	ldi	r26, 0x21	; 33
    353c:	1a 2e       	mov	r1, r26
    353e:	aa 1b       	sub	r26, r26
    3540:	bb 1b       	sub	r27, r27
    3542:	fd 01       	movw	r30, r26
    3544:	0d c0       	rjmp	.+26     	; 0x3560 <__udivmodsi4_ep>

00003546 <__udivmodsi4_loop>:
    3546:	aa 1f       	adc	r26, r26
    3548:	bb 1f       	adc	r27, r27
    354a:	ee 1f       	adc	r30, r30
    354c:	ff 1f       	adc	r31, r31
    354e:	a2 17       	cp	r26, r18
    3550:	b3 07       	cpc	r27, r19
    3552:	e4 07       	cpc	r30, r20
    3554:	f5 07       	cpc	r31, r21
    3556:	20 f0       	brcs	.+8      	; 0x3560 <__udivmodsi4_ep>
    3558:	a2 1b       	sub	r26, r18
    355a:	b3 0b       	sbc	r27, r19
    355c:	e4 0b       	sbc	r30, r20
    355e:	f5 0b       	sbc	r31, r21

00003560 <__udivmodsi4_ep>:
    3560:	66 1f       	adc	r22, r22
    3562:	77 1f       	adc	r23, r23
    3564:	88 1f       	adc	r24, r24
    3566:	99 1f       	adc	r25, r25
    3568:	1a 94       	dec	r1
    356a:	69 f7       	brne	.-38     	; 0x3546 <__udivmodsi4_loop>
    356c:	60 95       	com	r22
    356e:	70 95       	com	r23
    3570:	80 95       	com	r24
    3572:	90 95       	com	r25
    3574:	9b 01       	movw	r18, r22
    3576:	ac 01       	movw	r20, r24
    3578:	bd 01       	movw	r22, r26
    357a:	cf 01       	movw	r24, r30
    357c:	08 95       	ret

0000357e <_exit>:
    357e:	ff cf       	rjmp	.-2      	; 0x357e <_exit>
