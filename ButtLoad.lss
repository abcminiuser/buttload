
ButtLoad.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  00003556  0000360a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003556  00000000  00000000  000000b4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b4  00800104  00800104  0000360e  2**0
                  ALLOC
  3 .noinit       00000000  008002b8  008002b8  00003697  2**0
                  CONTENTS
  4 .eeprom       00000089  00810000  00810000  0000360e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  5 .stab         000003e4  00000000  00000000  00003698  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      000000fb  00000000  00000000  00003a7c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 0000012c  00000000  00000000  00003b77  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000d49  00000000  00000000  00003ca3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000041ec  00000000  00000000  000049ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000100a  00000000  00000000  00008bd8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000033c8  00000000  00000000  00009be2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0000114f  00000000  00000000  0000cfaa  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 14 02 	jmp	0x428 <__init>
       4:	0c 94 2f 02 	jmp	0x45e <__bad_interrupt>
       8:	0c 94 1d 1a 	jmp	0x343a <__vector_2>
       c:	0c 94 95 03 	jmp	0x72a <__vector_3>
      10:	0c 94 d9 0b 	jmp	0x17b2 <__vector_4>
      14:	0c 94 f6 07 	jmp	0xfec <__vector_5>
      18:	0c 94 2f 02 	jmp	0x45e <__bad_interrupt>
      1c:	0c 94 2f 02 	jmp	0x45e <__bad_interrupt>
      20:	0c 94 2f 02 	jmp	0x45e <__bad_interrupt>
      24:	0c 94 1d 0c 	jmp	0x183a <__vector_9>
      28:	0c 94 1f 1a 	jmp	0x343e <__vector_10>
      2c:	0c 94 2f 02 	jmp	0x45e <__bad_interrupt>
      30:	0c 94 2f 02 	jmp	0x45e <__bad_interrupt>
      34:	0c 94 5f 0b 	jmp	0x16be <__vector_13>
      38:	0c 94 2f 02 	jmp	0x45e <__bad_interrupt>
      3c:	0c 94 2f 02 	jmp	0x45e <__bad_interrupt>
      40:	0c 94 2f 02 	jmp	0x45e <__bad_interrupt>
      44:	0c 94 58 09 	jmp	0x12b0 <__vector_17>
      48:	0c 94 2f 02 	jmp	0x45e <__bad_interrupt>
      4c:	0c 94 2f 02 	jmp	0x45e <__bad_interrupt>
      50:	0c 94 2f 02 	jmp	0x45e <__bad_interrupt>
      54:	0c 94 2f 02 	jmp	0x45e <__bad_interrupt>
      58:	0c 94 a3 08 	jmp	0x1146 <__vector_22>

0000005c <SIFONames>:
      5c:	53 54 4f 52 41 47 45 20 53 49 5a 45 53 00 00 56     STORAGE SIZES..V
      6c:	49 45 57 20 44 41 54 41 20 54 41 47 53 00           IEW DATA TAGS.

0000007a <USISpeeds>:
      7a:	20 35 37 31 35 33 20 48 5a 00 20 38 36 37 33 38      57153 HZ. 86738
      8a:	20 48 5a 00 31 31 33 34 32 37 20 48 5a 00 32 31      HZ.113427 HZ.21
      9a:	30 36 35 31 20 48 5a 00                             0651 HZ.

000000a2 <ProgOptions>:
      a2:	0b 01 ff 00 ef 00 df 00 cf 00 bb 00 b0 00           ..............

000000b0 <PRG_C>:
      b0:	45 52 41 53 45 20 4f 4e 4c 59 00                    ERASE ONLY.

000000bb <PRG_FL>:
      bb:	46 55 53 45 20 41 4e 44 20 4c 4f 43 4b 20 42 59     FUSE AND LOCK BY
      cb:	54 45 53 00                                         TES.

000000cf <PRG_L>:
      cf:	4c 4f 43 4b 20 42 59 54 45 53 20 4f 4e 4c 59 00     LOCK BYTES ONLY.

000000df <PRG_F>:
      df:	46 55 53 45 20 42 59 54 45 53 20 4f 4e 4c 59 00     FUSE BYTES ONLY.

000000ef <PRG_DE>:
      ef:	44 41 54 41 20 41 4e 44 20 45 45 50 52 4f 4d 00     DATA AND EEPROM.

000000ff <PRG_E>:
      ff:	45 45 50 52 4f 4d 20 4f 4e 4c 59 00                 EEPROM ONLY.

0000010b <PRG_D>:
     10b:	44 41 54 41 20 4f 4e 4c 59 00                       DATA ONLY.

00000115 <SettingFunctionPtrs>:
     115:	dd 05 30 06 68 06 b4 06 aa 05 81 07                 ..0.h.......

00000121 <SettingFunctionNames>:
     121:	7e 01 70 01 5f 01 4d 01 40 01 2d 01                 ~.p._.M.@.-.

0000012d <SFunc_GOBOOTLOADER>:
     12d:	4a 55 4d 50 20 54 4f 20 42 4f 4f 54 4c 4f 41 44     JUMP TO BOOTLOAD
     13d:	45 52 00                                            ER.

00000140 <SFunc_CLEARMEM>:
     140:	43 4c 45 41 52 20 4d 45 4d 4f 52 59 00              CLEAR MEMORY.

0000014d <SFunc_SETAUTOSLEEPTO>:
     14d:	53 45 54 20 53 4c 45 45 50 20 54 49 4d 45 4f 55     SET SLEEP TIMEOU
     15d:	54 00                                               T.

0000015f <SFunc_SETFIRMMINOR>:
     15f:	53 45 54 20 46 49 52 4d 20 56 45 52 53 49 4f 4e     SET FIRM VERSION
	...

00000170 <SFunc_SETSPISPEED>:
     170:	53 45 54 20 53 50 49 20 53 50 45 45 44 00           SET SPI SPEED.

0000017e <SFunc_SETCONTRAST>:
     17e:	53 45 54 20 43 4f 4e 54 52 41 53 54 00              SET CONTRAST.

0000018b <MainFunctionPtrs>:
     18b:	ee 03 78 05 38 04 07 04 2b 07 b9 03 17 07           ..x.8...+.....

00000199 <MainFunctionNames>:
     199:	f0 01 e5 01 d9 01 ca 01 bb 01 b2 01 a7 01           ..............

000001a7 <Func_SLEEP>:
     1a7:	53 4c 45 45 50 20 4d 4f 44 45 00                    SLEEP MODE.

000001b2 <Func_SETTINGS>:
     1b2:	53 45 54 54 49 4e 47 53 00                          SETTINGS.

000001bb <Func_PRGMSTOREINFO>:
     1bb:	44 41 54 41 53 54 4f 52 45 20 49 4e 46 4f 00        DATASTORE INFO.

000001ca <Func_PRGMDATAFLASH>:
     1ca:	44 41 54 41 46 4c 41 53 48 20 50 52 47 4d 00        DATAFLASH PRGM.

000001d9 <Func_PRGMAVR>:
     1d9:	50 52 4f 47 52 41 4d 20 41 56 52 00                 PROGRAM AVR.

000001e5 <Func_STOREPRGM>:
     1e5:	53 54 4f 52 45 20 50 52 47 4d 00                    STORE PRGM.

000001f0 <Func_ISPPRGM>:
     1f0:	41 56 52 49 53 50 20 4d 4f 44 45 00                 AVRISP MODE.

000001fc <AboutTextPtrs>:
     1fc:	27 02 22 02 13 02 04 02                             '.".....

00000204 <CopyRight>:
     204:	3c 43 3e 20 32 30 30 36 20 2d 20 47 50 4c 00        <C> 2006 - GPL.

00000213 <AuthorName>:
     213:	42 59 20 44 45 41 4e 20 43 41 4d 45 52 41 00        BY DEAN CAMERA.

00000222 <VersionInfo>:
     222:	56 31 2d 34 00                                      V1-4.

00000227 <ProgrammerName>:
     227:	42 55 54 54 4c 4f 41 44 00                          BUTTLOAD.

00000230 <WaitText>:
     230:	2a 57 41 49 54 2a 00                                *WAIT*.

00000237 <BUTTTAG_Name>:
     237:	40 28 23 29 42 55 54 54 4c 4f 41 44 20 41 56 52     @(#)BUTTLOAD AVR
     247:	49 53 50 00                                         ISP.

0000024b <BUTTTAG_Author>:
     24b:	40 28 23 29 42 59 20 44 45 41 4e 20 43 41 4d 45     @(#)BY DEAN CAME
     25b:	52 41 00                                            RA.

0000025e <__c.17>:
     25e:	50 52 47 3e 20 20 00                                PRG>  .

00000265 <__c.16>:
     265:	42 41 44 49 53 52 00                                BADISR.

0000026c <__c.9>:
     26c:	4e 4f 20 45 52 41 53 45 20 43 4d 44 00              NO ERASE CMD.

00000279 <__c.10>:
     279:	4e 4f 20 44 41 54 41 00                             NO DATA.

00000281 <__c.11>:
     281:	4e 4f 20 45 45 50 52 4f 4d 00                       NO EEPROM.

0000028b <__c.12>:
     28b:	4e 4f 20 46 55 53 45 20 42 59 54 45 53 00           NO FUSE BYTES.

00000299 <__c.13>:
     299:	4e 4f 20 4c 4f 43 4b 20 42 59 54 45 53 00           NO LOCK BYTES.

000002a7 <__c.14>:
     2a7:	50 52 4f 47 52 41 4d 4d 49 4e 47 20 44 4f 4e 45     PROGRAMMING DONE
	...

000002b8 <__c.15>:
     2b8:	46 41 49 4c 45 44 00                                FAILED.

000002bf <__c.8>:
     2bf:	2a 53 54 4f 52 41 47 45 20 4d 4f 44 45 2a 00        *STORAGE MODE*.

000002ce <__c.5>:
     2ce:	43 4f 4e 46 49 52 4d 00                             CONFIRM.

000002d6 <__c.6>:
     2d6:	3c 4e 20 59 3e 00                                   <N Y>.

000002dc <__c.7>:
     2dc:	4d 45 4d 20 43 4c 45 41 52 45 44 00                 MEM CLEARED.

000002e8 <__c.4>:
     2e8:	56 32 2d 20 00                                      V2- .

000002ed <__c.2>:
     2ed:	20 20 20 20 53 45 43 00                                 SEC.

000002f5 <__c.3>:
     2f5:	4f 46 46 00                                         OFF.

000002f9 <__c.1>:
     2f9:	4e 4f 20 53 54 4f 52 45 44 20 50 52 47 4d 00        NO STORED PRGM.

00000308 <__c.0>:
     308:	2a 4a 54 41 47 20 4f 4e 2a 00                       *JTAG ON*.

00000312 <LCD_SegTable>:
     312:	a8 ea 80 2a 00 40 00 0a 51 0a 08 40 59 55 18 01     ...*.@..Q..@YU..
     322:	11 1e 11 1b 50 0b 41 1b 41 1f 11 01 51 1f 51 1b     ....P.A.A...Q.Q.
     332:	00 00 00 00 08 80 00 1a 20 40 00 00 00 00 51 0f     ........ @....Q.
     342:	91 39 41 14 91 31 41 1e 41 0e 41 1d 50 0f 80 20     .9A..1A.A.A.P.. 
     352:	10 15 48 86 40 14 78 05 70 85 51 15 51 0e 51 95     ..H.@.x.p.Q.Q.Q.
     362:	51 8e 21 90 81 20 50 15 48 44 50 c5 28 c0 28 20     Q.!.. P.HDP.(.( 
     372:	09 50 41 14 20 80 11 11 00 00 00 10                 .PA. .......

0000037e <USIPSValues>:
     37e:	03 80 02 54 01 40 00 22                             ...T.@."

00000386 <DataFlashError>:
     386:	44 41 54 41 46 4c 41 53 48 20 45 52 52 4f 52 00     DATAFLASH ERROR.

00000396 <DF_Pages>:
     396:	00 01 00 02 00 04 00 08 00 10 00 10 00 20 00 20     ............. . 

000003a6 <DF_PageSize>:
     3a6:	08 01 08 01 08 01 08 01 08 01 10 02 10 02 20 04     .............. .

000003b6 <DF_PageBits>:
     3b6:	09 09 09 09 09 0a 0a 0b                             ........

000003be <__c.0>:
     3be:	42 55 46 46 20 4f 56 45 52 46 4c 4f 57 00           BUFF OVERFLOW.

000003cc <AutoSleepTOValues>:
     3cc:	00 0f 1e 3c 78                                      ...<x

000003d1 <DataFlashProgMode>:
     3d1:	2a 44 41 54 41 46 4c 41 53 48 20 4d 4f 44 45 2a     *DATAFLASH MODE*
	...

000003e2 <SignonResponse>:
     3e2:	01 00 08 41 56 52 49 53 50 5f 32                    ...AVRISP_2

000003ed <SyncErrorMessage>:
     3ed:	53 59 4e 43 20 45 52 52 4f 52 00                    SYNC ERROR.

000003f8 <AVRISPModeMessage>:
     3f8:	2a 41 54 41 56 52 49 53 50 20 4d 4f 44 45 2a 00     *ATAVRISP MODE*.

00000408 <__c.0>:
     408:	44 41 54 41 2d 00                                   DATA-.

0000040e <__c.1>:
     40e:	45 50 52 4d 2d 00                                   EPRM-.

00000414 <__c.2>:
     414:	46 55 53 45 2d 00                                   FUSE-.

0000041a <__c.3>:
     41a:	4c 4f 43 4b 2d 00                                   LOCK-.

00000420 <__c.0>:
     420:	4e 4f 20 54 41 47 53 00                             NO TAGS.

00000428 <__init>:
     428:	11 24       	eor	r1, r1
     42a:	1f be       	out	0x3f, r1	; 63
     42c:	cf ef       	ldi	r28, 0xFF	; 255
     42e:	d4 e0       	ldi	r29, 0x04	; 4
     430:	de bf       	out	0x3e, r29	; 62
     432:	cd bf       	out	0x3d, r28	; 61

00000434 <__do_copy_data>:
     434:	11 e0       	ldi	r17, 0x01	; 1
     436:	a0 e0       	ldi	r26, 0x00	; 0
     438:	b1 e0       	ldi	r27, 0x01	; 1
     43a:	e6 e5       	ldi	r30, 0x56	; 86
     43c:	f5 e3       	ldi	r31, 0x35	; 53
     43e:	02 c0       	rjmp	.+4      	; 0x444 <.do_copy_data_start>

00000440 <.do_copy_data_loop>:
     440:	05 90       	lpm	r0, Z+
     442:	0d 92       	st	X+, r0

00000444 <.do_copy_data_start>:
     444:	a4 30       	cpi	r26, 0x04	; 4
     446:	b1 07       	cpc	r27, r17
     448:	d9 f7       	brne	.-10     	; 0x440 <.do_copy_data_loop>

0000044a <__do_clear_bss>:
     44a:	12 e0       	ldi	r17, 0x02	; 2
     44c:	a4 e0       	ldi	r26, 0x04	; 4
     44e:	b1 e0       	ldi	r27, 0x01	; 1
     450:	01 c0       	rjmp	.+2      	; 0x454 <.do_clear_bss_start>

00000452 <.do_clear_bss_loop>:
     452:	1d 92       	st	X+, r1

00000454 <.do_clear_bss_start>:
     454:	a8 3b       	cpi	r26, 0xB8	; 184
     456:	b1 07       	cpc	r27, r17
     458:	e1 f7       	brne	.-8      	; 0x452 <.do_clear_bss_loop>
     45a:	0c 94 75 02 	jmp	0x4ea <main>

0000045e <__bad_interrupt>:
     45e:	0c 94 b4 03 	jmp	0x768 <__vector_default>

00000462 <MAIN_Delay10MS>:

// ======================================================================================

void MAIN_Delay10MS(uint8_t loops)
{
     462:	cf 93       	push	r28
     464:	df 93       	push	r29
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     466:	28 2f       	mov	r18, r24
     468:	21 50       	subi	r18, 0x01	; 1
     46a:	2f 3f       	cpi	r18, 0xFF	; 255
     46c:	49 f0       	breq	.+18     	; 0x480 <MAIN_Delay10MS+0x1e>
     46e:	a0 e0       	ldi	r26, 0x00	; 0
     470:	b8 e4       	ldi	r27, 0x48	; 72
     472:	c0 e0       	ldi	r28, 0x00	; 0
     474:	d0 e0       	ldi	r29, 0x00	; 0
     476:	cd 01       	movw	r24, r26
     478:	01 97       	sbiw	r24, 0x01	; 1
     47a:	f1 f7       	brne	.-4      	; 0x478 <MAIN_Delay10MS+0x16>
     47c:	21 50       	subi	r18, 0x01	; 1
     47e:	d8 f7       	brcc	.-10     	; 0x476 <MAIN_Delay10MS+0x14>
     480:	df 91       	pop	r29
     482:	cf 91       	pop	r28
     484:	08 95       	ret

00000486 <MAIN_WaitForJoyRelease>:
  /* Prevents the use of floating point libraries. Delaying in groups of
     10ms increases accuracy by reducing the time overhead for each loop
     interation of the while.                                            */

	while (loops--)
	  _delay_ms(10);
}

void MAIN_Delay1MS(uint8_t loops)
{
  /* Prevents the use of floating point libraries. Less accurate than the
     Delay10MS routine, but nessesary for many commands. The overhead required
     to call the routine is substantially less than the overhead required to
     calculate the float at compile time, so this actually saves execution time. */

	while (loops--)
	  _delay_ms(1);
}

void MAIN_ResetCSLine(const uint8_t ActiveInactive)
{
	/* ActiveInactive controls the /Reset line to an AVR device or external dataflash
	/CS line. If the reset polarity parameter is a 0 then interfacing with AT89
	devices which has an active high reset. Pins are tristated when inactive.         */
	
	switch (ActiveInactive)
	{
		case MAIN_RESETCS_ACTIVE:      // The target RESET line may be either active high or low.
			DDRF |= (1 << 6);
		
			if (!(eeprom_read_byte(&EEPROMVars.ResetPolarity))) // Translate to correct logic level for target device type
			  PORTF |=  (1 << 6);
			else
			  PORTF &= ~(1 << 6);
		
			break;
		case MAIN_RESETCS_EXTDFACTIVE: // Dataflashes are always active low.
			DDRF  |=  (1 << 6);
			PORTF &= ~(1 << 6);
			
			break;
		case MAIN_RESETCS_INACTIVE:    // Both modes tristate the pins when inactive.
			DDRF  &= ~(1 << 6);
			PORTF &= ~(1 << 6);
	}
}

void MAIN_WaitForJoyRelease(void)
{
	while (1)
	{
		while (JoyStatus) {};                   // Wait until joystick released
     486:	8e b3       	in	r24, 0x1e	; 30
     488:	88 23       	and	r24, r24
     48a:	e9 f7       	brne	.-6      	; 0x486 <MAIN_WaitForJoyRelease>

		MAIN_Delay10MS(1);
     48c:	81 e0       	ldi	r24, 0x01	; 1
     48e:	0e 94 31 02 	call	0x462 <MAIN_Delay10MS>

		if (!(JoyStatus))                       // Joystick still released (not bouncing), return
     492:	8e b3       	in	r24, 0x1e	; 30
     494:	88 23       	and	r24, r24
     496:	b9 f7       	brne	.-18     	; 0x486 <MAIN_WaitForJoyRelease>
     498:	08 95       	ret

0000049a <FUNCShowAbout>:
		  return;
	}
}

void MAIN_IntToStr(uint16_t IntV, uint8_t* Buff)
{
	// Shows leading zeros, unlike itoa.

	uint8_t Temp = 0;
	
	while (IntV >= 100)
	{
		Temp++;
		IntV -= 100;
	}

	*(Buff++) = '0' + Temp;
	
	Temp = 0;
	
	while (IntV >= 10)
	{
		Temp++;
		IntV -= 10;
	}
		
	*(Buff++) = '0' + Temp;
	*(Buff++) = '0' + IntV;
	*(Buff)   = '\0';
}

void MAIN_ShowProgType(const uint8_t Letter)
{
	uint8_t ProgTypeBuffer[7];

	strcpy_P(ProgTypeBuffer, PSTR("PRG>  "));
	ProgTypeBuffer[5] = Letter;
	
	LCD_puts(ProgTypeBuffer);
}

void MAIN_ShowError(const uint8_t *pFlashStr)
{
	uint8_t ErrorBuff[LCD_TEXTBUFFER_SIZE];   // New buffer, LCD text buffer size
	
	ErrorBuff[0] = 'E';
	ErrorBuff[1] = '>';

	strcpy_P(&ErrorBuff[2], pFlashStr);       // WARNING: If error text is larger than (TEXTBUFFER_SIZE - 2),
	                                          // this will overflow the buffer and probably crash the micro!
	LCD_puts(ErrorBuff);
	
	MAIN_WaitForJoyRelease();
	while (!(JoyStatus & JOY_PRESS)) {};
	MAIN_WaitForJoyRelease();
}

// ======================================================================================

ISR(PCINT1_vect, ISR_NOBLOCK)                 // Joystick routine; PCINT0_vect is bound to this also via JoystickInterrupt.S
{
	JoyStatus = (~PINB & JOY_BMASK)
	          | (~PINE & JOY_EMASK);
			  
	TIMEOUT_SLEEP_TIMEOUT_RESET();
}

ISR(BADISR_vect, ISR_NAKED)                   // Bad ISR routine; should never be called, here for safety
{
	MAIN_ShowError(PSTR("BADISR"));
	while (1) {};
}

// ======================================================================================

void FUNCChangeSettings(void)
{
	uint8_t CurrSFunc = 0;
	
	JoyStatus = 1;

	while (1)
	{
		if (JoyStatus)                         // Joystick is in the non-center position
		{
			if (JoyStatus & JOY_UP)            // Previous function
			  (CurrSFunc == 0)? CurrSFunc = ARRAY_UPPERBOUND(SettingFunctionPtrs) : CurrSFunc--;
			else if (JoyStatus & JOY_DOWN)     // Next function
			  (CurrSFunc == ARRAY_UPPERBOUND(SettingFunctionPtrs))? CurrSFunc = 0 : CurrSFunc++;
			else if (JoyStatus & JOY_PRESS)    // Select current function
			  ((FuncPtr)pgm_read_word(&SettingFunctionPtrs[CurrSFunc]))(); // Run associated function
			else if (JoyStatus & JOY_LEFT)
			  return;
		
			// Show current function onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&SettingFunctionNames[CurrSFunc]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCShowAbout(void)
{
     49a:	cf 93       	push	r28
	uint8_t InfoNum = 0;
     49c:	c0 e0       	ldi	r28, 0x00	; 0
	
	JoyStatus = 1;
     49e:	81 e0       	ldi	r24, 0x01	; 1
     4a0:	8e bb       	out	0x1e, r24	; 30
			
	while (1)
	{
		if (JoyStatus)
     4a2:	8e b3       	in	r24, 0x1e	; 30
     4a4:	88 23       	and	r24, r24
     4a6:	e9 f3       	breq	.-6      	; 0x4a2 <FUNCShowAbout+0x8>
		{
			if (JoyStatus & JOY_UP)
     4a8:	f6 9b       	sbis	0x1e, 6	; 30
     4aa:	06 c0       	rjmp	.+12     	; 0x4b8 <FUNCShowAbout+0x1e>
			  (InfoNum == 0)? InfoNum = ARRAY_UPPERBOUND(AboutTextPtrs) : InfoNum--;
     4ac:	cc 23       	and	r28, r28
     4ae:	11 f4       	brne	.+4      	; 0x4b4 <FUNCShowAbout+0x1a>
     4b0:	c3 e0       	ldi	r28, 0x03	; 3
     4b2:	0c c0       	rjmp	.+24     	; 0x4cc <FUNCShowAbout+0x32>
     4b4:	c1 50       	subi	r28, 0x01	; 1
     4b6:	0a c0       	rjmp	.+20     	; 0x4cc <FUNCShowAbout+0x32>
			else if (JoyStatus & JOY_DOWN)
     4b8:	f7 9b       	sbis	0x1e, 7	; 30
     4ba:	06 c0       	rjmp	.+12     	; 0x4c8 <FUNCShowAbout+0x2e>
			  (InfoNum == ARRAY_UPPERBOUND(AboutTextPtrs))? InfoNum = 0 : InfoNum++;
     4bc:	c3 30       	cpi	r28, 0x03	; 3
     4be:	11 f4       	brne	.+4      	; 0x4c4 <FUNCShowAbout+0x2a>
     4c0:	c0 e0       	ldi	r28, 0x00	; 0
     4c2:	04 c0       	rjmp	.+8      	; 0x4cc <FUNCShowAbout+0x32>
     4c4:	cf 5f       	subi	r28, 0xFF	; 255
     4c6:	02 c0       	rjmp	.+4      	; 0x4cc <FUNCShowAbout+0x32>
			else if (JoyStatus & JOY_LEFT)
     4c8:	f2 99       	sbic	0x1e, 2	; 30
     4ca:	0d c0       	rjmp	.+26     	; 0x4e6 <FUNCShowAbout+0x4c>
			  return;

			LCD_puts_f((uint8_t*)pgm_read_word(&AboutTextPtrs[InfoNum]));
     4cc:	ec 2f       	mov	r30, r28
     4ce:	ff 27       	eor	r31, r31
     4d0:	ee 0f       	add	r30, r30
     4d2:	ff 1f       	adc	r31, r31
     4d4:	e4 50       	subi	r30, 0x04	; 4
     4d6:	fe 4f       	sbci	r31, 0xFE	; 254
     4d8:	85 91       	lpm	r24, Z+
     4da:	94 91       	lpm	r25, Z
     4dc:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     4e0:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>
     4e4:	de cf       	rjmp	.-68     	; 0x4a2 <FUNCShowAbout+0x8>
     4e6:	cf 91       	pop	r28
     4e8:	08 95       	ret

000004ea <main>:
     4ea:	cf ef       	ldi	r28, 0xFF	; 255
     4ec:	d4 e0       	ldi	r29, 0x04	; 4
     4ee:	de bf       	out	0x3e, r29	; 62
     4f0:	cd bf       	out	0x3d, r28	; 61
     4f2:	c0 e0       	ldi	r28, 0x00	; 0
     4f4:	80 e8       	ldi	r24, 0x80	; 128
     4f6:	85 bf       	out	0x35, r24	; 53
     4f8:	85 bf       	out	0x35, r24	; 53
     4fa:	80 bf       	out	0x30, r24	; 48
     4fc:	85 e0       	ldi	r24, 0x05	; 5
     4fe:	80 93 64 00 	sts	0x0064, r24
     502:	80 e3       	ldi	r24, 0x30	; 48
     504:	80 bb       	out	0x10, r24	; 16
     506:	87 e2       	ldi	r24, 0x27	; 39
     508:	84 b9       	out	0x04, r24	; 4
     50a:	8f ed       	ldi	r24, 0xDF	; 223
     50c:	85 b9       	out	0x05, r24	; 5
     50e:	8c e0       	ldi	r24, 0x0C	; 12
     510:	8e b9       	out	0x0e, r24	; 14
     512:	80 93 6b 00 	sts	0x006B, r24
     516:	80 ed       	ldi	r24, 0xD0	; 208
     518:	80 93 6c 00 	sts	0x006C, r24
     51c:	80 ec       	ldi	r24, 0xC0	; 192
     51e:	8d bb       	out	0x1d, r24	; 29
     520:	8c bb       	out	0x1c, r24	; 28
     522:	81 b3       	in	r24, 0x11	; 17
     524:	8f 7c       	andi	r24, 0xCF	; 207
     526:	80 62       	ori	r24, 0x20	; 32
     528:	81 bb       	out	0x11, r24	; 17
     52a:	0e 94 17 08 	call	0x102e <LCD_Init>
     52e:	8f e0       	ldi	r24, 0x0F	; 15
     530:	80 93 e7 00 	sts	0x00E7, r24
     534:	80 e3       	ldi	r24, 0x30	; 48
     536:	92 e0       	ldi	r25, 0x02	; 2
     538:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>
     53c:	78 94       	sei
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     53e:	28 e8       	ldi	r18, 0x88	; 136
     540:	30 e0       	ldi	r19, 0x00	; 0
  uint8_t result;
  asm volatile
     542:	d9 01       	movw	r26, r18
     544:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
     548:	80 2d       	mov	r24, r0
     54a:	8a 37       	cpi	r24, 0x7A	; 122
     54c:	81 f0       	breq	.+32     	; 0x56e <__stack+0x6f>
     54e:	80 e0       	ldi	r24, 0x00	; 0
     550:	90 e0       	ldi	r25, 0x00	; 0
     552:	4f ef       	ldi	r20, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     554:	dc 01       	movw	r26, r24
     556:	04 2e       	mov	r0, r20
     558:	0e 94 73 1a 	call	0x34e6 <__eeprom_write_byte_1F2021>
     55c:	01 96       	adiw	r24, 0x01	; 1
     55e:	89 38       	cpi	r24, 0x89	; 137
     560:	91 05       	cpc	r25, r1
     562:	c0 f3       	brcs	.-16     	; 0x554 <__stack+0x55>
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
     564:	8a e7       	ldi	r24, 0x7A	; 122
  asm volatile (
     566:	d9 01       	movw	r26, r18
     568:	08 2e       	mov	r0, r24
     56a:	0e 94 73 1a 	call	0x34e6 <__eeprom_write_byte_1F2021>
     56e:	a5 e8       	ldi	r26, 0x85	; 133
     570:	b0 e0       	ldi	r27, 0x00	; 0
     572:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
     576:	80 2d       	mov	r24, r0
     578:	8f 70       	andi	r24, 0x0F	; 15
     57a:	80 93 e7 00 	sts	0x00E7, r24
     57e:	80 e0       	ldi	r24, 0x00	; 0
     580:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
     584:	81 b3       	in	r24, 0x11	; 17
     586:	80 63       	ori	r24, 0x30	; 48
     588:	81 bb       	out	0x11, r24	; 17
     58a:	0e 94 14 09 	call	0x1228 <USART_Init>
     58e:	0e 94 91 07 	call	0xf22 <OSCCAL_Calibrate>
     592:	0e 94 f4 0b 	call	0x17e8 <TOUT_SetupSleepTimer>
     596:	81 b3       	in	r24, 0x11	; 17
     598:	8f 7c       	andi	r24, 0xCF	; 207
     59a:	80 61       	ori	r24, 0x10	; 16
     59c:	81 bb       	out	0x11, r24	; 17
     59e:	81 e0       	ldi	r24, 0x01	; 1
     5a0:	8e bb       	out	0x1e, r24	; 30
     5a2:	80 e8       	ldi	r24, 0x80	; 128
     5a4:	80 93 61 00 	sts	0x0061, r24
     5a8:	83 e0       	ldi	r24, 0x03	; 3
     5aa:	80 93 61 00 	sts	0x0061, r24
     5ae:	8e b3       	in	r24, 0x1e	; 30
     5b0:	88 23       	and	r24, r24
     5b2:	e9 f3       	breq	.-6      	; 0x5ae <__stack+0xaf>
     5b4:	f6 9b       	sbis	0x1e, 6	; 30
     5b6:	06 c0       	rjmp	.+12     	; 0x5c4 <__stack+0xc5>
     5b8:	cc 23       	and	r28, r28
     5ba:	11 f4       	brne	.+4      	; 0x5c0 <__stack+0xc1>
     5bc:	c6 e0       	ldi	r28, 0x06	; 6
     5be:	1b c0       	rjmp	.+54     	; 0x5f6 <__stack+0xf7>
     5c0:	c1 50       	subi	r28, 0x01	; 1
     5c2:	19 c0       	rjmp	.+50     	; 0x5f6 <__stack+0xf7>
     5c4:	f7 9b       	sbis	0x1e, 7	; 30
     5c6:	06 c0       	rjmp	.+12     	; 0x5d4 <__stack+0xd5>
     5c8:	c6 30       	cpi	r28, 0x06	; 6
     5ca:	11 f4       	brne	.+4      	; 0x5d0 <__stack+0xd1>
     5cc:	c0 e0       	ldi	r28, 0x00	; 0
     5ce:	13 c0       	rjmp	.+38     	; 0x5f6 <__stack+0xf7>
     5d0:	cf 5f       	subi	r28, 0xFF	; 255
     5d2:	11 c0       	rjmp	.+34     	; 0x5f6 <__stack+0xf7>
     5d4:	f4 9b       	sbis	0x1e, 4	; 30
     5d6:	0b c0       	rjmp	.+22     	; 0x5ee <__stack+0xef>
     5d8:	ec 2f       	mov	r30, r28
     5da:	ff 27       	eor	r31, r31
     5dc:	ee 0f       	add	r30, r30
     5de:	ff 1f       	adc	r31, r31
     5e0:	e5 57       	subi	r30, 0x75	; 117
     5e2:	fe 4f       	sbci	r31, 0xFE	; 254
     5e4:	85 91       	lpm	r24, Z+
     5e6:	94 91       	lpm	r25, Z
     5e8:	fc 01       	movw	r30, r24
     5ea:	09 95       	icall
     5ec:	04 c0       	rjmp	.+8      	; 0x5f6 <__stack+0xf7>
     5ee:	f3 9b       	sbis	0x1e, 3	; 30
     5f0:	02 c0       	rjmp	.+4      	; 0x5f6 <__stack+0xf7>
     5f2:	0e 94 4d 02 	call	0x49a <FUNCShowAbout>
     5f6:	ec 2f       	mov	r30, r28
     5f8:	ff 27       	eor	r31, r31
     5fa:	ee 0f       	add	r30, r30
     5fc:	ff 1f       	adc	r31, r31
     5fe:	e7 56       	subi	r30, 0x67	; 103
     600:	fe 4f       	sbci	r31, 0xFE	; 254
     602:	85 91       	lpm	r24, Z+
     604:	94 91       	lpm	r25, Z
     606:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>
     60a:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>
     60e:	cf cf       	rjmp	.-98     	; 0x5ae <__stack+0xaf>

00000610 <MAIN_Delay1MS>:
     610:	cf 93       	push	r28
     612:	df 93       	push	r29
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     614:	28 2f       	mov	r18, r24
     616:	21 50       	subi	r18, 0x01	; 1
     618:	2f 3f       	cpi	r18, 0xFF	; 255
     61a:	49 f0       	breq	.+18     	; 0x62e <MAIN_Delay1MS+0x1e>
     61c:	a3 e3       	ldi	r26, 0x33	; 51
     61e:	b7 e0       	ldi	r27, 0x07	; 7
     620:	c0 e0       	ldi	r28, 0x00	; 0
     622:	d0 e0       	ldi	r29, 0x00	; 0
     624:	cd 01       	movw	r24, r26
     626:	01 97       	sbiw	r24, 0x01	; 1
     628:	f1 f7       	brne	.-4      	; 0x626 <MAIN_Delay1MS+0x16>
     62a:	21 50       	subi	r18, 0x01	; 1
     62c:	d8 f7       	brcc	.-10     	; 0x624 <MAIN_Delay1MS+0x14>
     62e:	df 91       	pop	r29
     630:	cf 91       	pop	r28
     632:	08 95       	ret

00000634 <MAIN_ResetCSLine>:
     634:	99 27       	eor	r25, r25
     636:	81 30       	cpi	r24, 0x01	; 1
     638:	91 05       	cpc	r25, r1
     63a:	b1 f0       	breq	.+44     	; 0x668 <MAIN_ResetCSLine+0x34>
     63c:	82 30       	cpi	r24, 0x02	; 2
     63e:	91 05       	cpc	r25, r1
     640:	1c f4       	brge	.+6      	; 0x648 <MAIN_ResetCSLine+0x14>
     642:	89 2b       	or	r24, r25
     644:	21 f0       	breq	.+8      	; 0x64e <MAIN_ResetCSLine+0x1a>
     646:	08 95       	ret
     648:	02 97       	sbiw	r24, 0x02	; 2
     64a:	59 f0       	breq	.+22     	; 0x662 <MAIN_ResetCSLine+0x2e>
     64c:	08 95       	ret
     64e:	86 9a       	sbi	0x10, 6	; 16
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     650:	a0 e0       	ldi	r26, 0x00	; 0
     652:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     654:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
     658:	80 2d       	mov	r24, r0
     65a:	88 23       	and	r24, r24
     65c:	19 f4       	brne	.+6      	; 0x664 <MAIN_ResetCSLine+0x30>
     65e:	8e 9a       	sbi	0x11, 6	; 17
     660:	08 95       	ret
     662:	86 9a       	sbi	0x10, 6	; 16
     664:	8e 98       	cbi	0x11, 6	; 17
     666:	08 95       	ret
     668:	86 98       	cbi	0x10, 6	; 16
     66a:	fc cf       	rjmp	.-8      	; 0x664 <MAIN_ResetCSLine+0x30>

0000066c <MAIN_IntToStr>:
     66c:	fb 01       	movw	r30, r22
     66e:	20 e0       	ldi	r18, 0x00	; 0
     670:	84 36       	cpi	r24, 0x64	; 100
     672:	91 05       	cpc	r25, r1
     674:	20 f0       	brcs	.+8      	; 0x67e <MAIN_IntToStr+0x12>
     676:	2f 5f       	subi	r18, 0xFF	; 255
     678:	84 56       	subi	r24, 0x64	; 100
     67a:	90 40       	sbci	r25, 0x00	; 0
     67c:	f9 cf       	rjmp	.-14     	; 0x670 <MAIN_IntToStr+0x4>
     67e:	20 5d       	subi	r18, 0xD0	; 208
     680:	21 93       	st	Z+, r18
     682:	20 e0       	ldi	r18, 0x00	; 0
     684:	8a 30       	cpi	r24, 0x0A	; 10
     686:	91 05       	cpc	r25, r1
     688:	18 f0       	brcs	.+6      	; 0x690 <MAIN_IntToStr+0x24>
     68a:	2f 5f       	subi	r18, 0xFF	; 255
     68c:	0a 97       	sbiw	r24, 0x0a	; 10
     68e:	fa cf       	rjmp	.-12     	; 0x684 <MAIN_IntToStr+0x18>
     690:	20 5d       	subi	r18, 0xD0	; 208
     692:	21 93       	st	Z+, r18
     694:	80 5d       	subi	r24, 0xD0	; 208
     696:	81 93       	st	Z+, r24
     698:	10 82       	st	Z, r1
     69a:	08 95       	ret

0000069c <MAIN_ShowProgType>:
     69c:	1f 93       	push	r17
     69e:	cf 93       	push	r28
     6a0:	df 93       	push	r29
     6a2:	cd b7       	in	r28, 0x3d	; 61
     6a4:	de b7       	in	r29, 0x3e	; 62
     6a6:	27 97       	sbiw	r28, 0x07	; 7
     6a8:	0f b6       	in	r0, 0x3f	; 63
     6aa:	f8 94       	cli
     6ac:	de bf       	out	0x3e, r29	; 62
     6ae:	0f be       	out	0x3f, r0	; 63
     6b0:	cd bf       	out	0x3d, r28	; 61
     6b2:	18 2f       	mov	r17, r24
     6b4:	6e e5       	ldi	r22, 0x5E	; 94
     6b6:	72 e0       	ldi	r23, 0x02	; 2
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	0e 94 25 1a 	call	0x344a <strcpy_P>
     6c0:	1e 83       	std	Y+6, r17	; 0x06
     6c2:	ce 01       	movw	r24, r28
     6c4:	01 96       	adiw	r24, 0x01	; 1
     6c6:	0e 94 24 08 	call	0x1048 <LCD_puts>
     6ca:	27 96       	adiw	r28, 0x07	; 7
     6cc:	0f b6       	in	r0, 0x3f	; 63
     6ce:	f8 94       	cli
     6d0:	de bf       	out	0x3e, r29	; 62
     6d2:	0f be       	out	0x3f, r0	; 63
     6d4:	cd bf       	out	0x3d, r28	; 61
     6d6:	df 91       	pop	r29
     6d8:	cf 91       	pop	r28
     6da:	1f 91       	pop	r17
     6dc:	08 95       	ret

000006de <MAIN_ShowError>:
     6de:	cf 93       	push	r28
     6e0:	df 93       	push	r29
     6e2:	cd b7       	in	r28, 0x3d	; 61
     6e4:	de b7       	in	r29, 0x3e	; 62
     6e6:	64 97       	sbiw	r28, 0x14	; 20
     6e8:	0f b6       	in	r0, 0x3f	; 63
     6ea:	f8 94       	cli
     6ec:	de bf       	out	0x3e, r29	; 62
     6ee:	0f be       	out	0x3f, r0	; 63
     6f0:	cd bf       	out	0x3d, r28	; 61
     6f2:	25 e4       	ldi	r18, 0x45	; 69
     6f4:	29 83       	std	Y+1, r18	; 0x01
     6f6:	2e e3       	ldi	r18, 0x3E	; 62
     6f8:	2a 83       	std	Y+2, r18	; 0x02
     6fa:	bc 01       	movw	r22, r24
     6fc:	ce 01       	movw	r24, r28
     6fe:	03 96       	adiw	r24, 0x03	; 3
     700:	0e 94 25 1a 	call	0x344a <strcpy_P>
     704:	ce 01       	movw	r24, r28
     706:	01 96       	adiw	r24, 0x01	; 1
     708:	0e 94 24 08 	call	0x1048 <LCD_puts>
     70c:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>
     710:	f4 9b       	sbis	0x1e, 4	; 30
     712:	fe cf       	rjmp	.-4      	; 0x710 <MAIN_ShowError+0x32>
     714:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>
     718:	64 96       	adiw	r28, 0x14	; 20
     71a:	0f b6       	in	r0, 0x3f	; 63
     71c:	f8 94       	cli
     71e:	de bf       	out	0x3e, r29	; 62
     720:	0f be       	out	0x3f, r0	; 63
     722:	cd bf       	out	0x3d, r28	; 61
     724:	df 91       	pop	r29
     726:	cf 91       	pop	r28
     728:	08 95       	ret

0000072a <__vector_3>:
     72a:	78 94       	sei
     72c:	1f 92       	push	r1
     72e:	0f 92       	push	r0
     730:	0f b6       	in	r0, 0x3f	; 63
     732:	0f 92       	push	r0
     734:	11 24       	eor	r1, r1
     736:	8f 93       	push	r24
     738:	9f 93       	push	r25
     73a:	93 b1       	in	r25, 0x03	; 3
     73c:	90 95       	com	r25
     73e:	90 7d       	andi	r25, 0xD0	; 208
     740:	8c b1       	in	r24, 0x0c	; 12
     742:	80 95       	com	r24
     744:	8c 70       	andi	r24, 0x0C	; 12
     746:	98 2b       	or	r25, r24
     748:	9e bb       	out	0x1e, r25	; 30
     74a:	10 92 3e 01 	sts	0x013E, r1
     74e:	10 92 3d 01 	sts	0x013D, r1
     752:	10 92 85 00 	sts	0x0085, r1
     756:	10 92 84 00 	sts	0x0084, r1
     75a:	9f 91       	pop	r25
     75c:	8f 91       	pop	r24
     75e:	0f 90       	pop	r0
     760:	0f be       	out	0x3f, r0	; 63
     762:	0f 90       	pop	r0
     764:	1f 90       	pop	r1
     766:	18 95       	reti

00000768 <__vector_default>:
     768:	85 e6       	ldi	r24, 0x65	; 101
     76a:	92 e0       	ldi	r25, 0x02	; 2
     76c:	0e 94 6f 03 	call	0x6de <MAIN_ShowError>
     770:	ff cf       	rjmp	.-2      	; 0x770 <__vector_default+0x8>

00000772 <FUNCChangeSettings>:
     772:	cf 93       	push	r28
     774:	c0 e0       	ldi	r28, 0x00	; 0
     776:	81 e0       	ldi	r24, 0x01	; 1
     778:	8e bb       	out	0x1e, r24	; 30
     77a:	8e b3       	in	r24, 0x1e	; 30
     77c:	88 23       	and	r24, r24
     77e:	e9 f3       	breq	.-6      	; 0x77a <FUNCChangeSettings+0x8>
     780:	f6 9b       	sbis	0x1e, 6	; 30
     782:	06 c0       	rjmp	.+12     	; 0x790 <FUNCChangeSettings+0x1e>
     784:	cc 23       	and	r28, r28
     786:	11 f4       	brne	.+4      	; 0x78c <FUNCChangeSettings+0x1a>
     788:	c5 e0       	ldi	r28, 0x05	; 5
     78a:	19 c0       	rjmp	.+50     	; 0x7be <FUNCChangeSettings+0x4c>
     78c:	c1 50       	subi	r28, 0x01	; 1
     78e:	17 c0       	rjmp	.+46     	; 0x7be <FUNCChangeSettings+0x4c>
     790:	f7 9b       	sbis	0x1e, 7	; 30
     792:	06 c0       	rjmp	.+12     	; 0x7a0 <FUNCChangeSettings+0x2e>
     794:	c5 30       	cpi	r28, 0x05	; 5
     796:	11 f4       	brne	.+4      	; 0x79c <FUNCChangeSettings+0x2a>
     798:	c0 e0       	ldi	r28, 0x00	; 0
     79a:	11 c0       	rjmp	.+34     	; 0x7be <FUNCChangeSettings+0x4c>
     79c:	cf 5f       	subi	r28, 0xFF	; 255
     79e:	0f c0       	rjmp	.+30     	; 0x7be <FUNCChangeSettings+0x4c>
     7a0:	f4 9b       	sbis	0x1e, 4	; 30
     7a2:	0b c0       	rjmp	.+22     	; 0x7ba <FUNCChangeSettings+0x48>
     7a4:	ec 2f       	mov	r30, r28
     7a6:	ff 27       	eor	r31, r31
     7a8:	ee 0f       	add	r30, r30
     7aa:	ff 1f       	adc	r31, r31
     7ac:	eb 5e       	subi	r30, 0xEB	; 235
     7ae:	fe 4f       	sbci	r31, 0xFE	; 254
     7b0:	85 91       	lpm	r24, Z+
     7b2:	94 91       	lpm	r25, Z
     7b4:	fc 01       	movw	r30, r24
     7b6:	09 95       	icall
     7b8:	02 c0       	rjmp	.+4      	; 0x7be <FUNCChangeSettings+0x4c>
     7ba:	f2 99       	sbic	0x1e, 2	; 30
     7bc:	0d c0       	rjmp	.+26     	; 0x7d8 <FUNCChangeSettings+0x66>
     7be:	ec 2f       	mov	r30, r28
     7c0:	ff 27       	eor	r31, r31
     7c2:	ee 0f       	add	r30, r30
     7c4:	ff 1f       	adc	r31, r31
     7c6:	ef 5d       	subi	r30, 0xDF	; 223
     7c8:	fe 4f       	sbci	r31, 0xFE	; 254
     7ca:	85 91       	lpm	r24, Z+
     7cc:	94 91       	lpm	r25, Z
     7ce:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>
     7d2:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>
     7d6:	d1 cf       	rjmp	.-94     	; 0x77a <FUNCChangeSettings+0x8>
     7d8:	cf 91       	pop	r28
     7da:	08 95       	ret

000007dc <FUNCAVRISPMode>:
		}
	}
}

void FUNCAVRISPMode(void)
{
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
     7dc:	80 e3       	ldi	r24, 0x30	; 48
     7de:	92 e0       	ldi	r25, 0x02	; 2
     7e0:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>
     7e4:	0e 94 91 07 	call	0xf22 <OSCCAL_Calibrate>
     7e8:	80 91 c1 00 	lds	r24, 0x00C1
     7ec:	80 78       	andi	r24, 0x80	; 128
     7ee:	88 61       	ori	r24, 0x18	; 24
     7f0:	80 93 c1 00 	sts	0x00C1, r24
	LCD_puts_f(AVRISPModeMessage);
     7f4:	88 ef       	ldi	r24, 0xF8	; 248
     7f6:	93 e0       	ldi	r25, 0x03	; 3
     7f8:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>
	
	InterpretPacketRoutine = (FuncPtr)AICI_InterpretPacket;
     7fc:	8d e7       	ldi	r24, 0x7D	; 125
     7fe:	92 e1       	ldi	r25, 0x12	; 18
     800:	90 93 03 01 	sts	0x0103, r25
     804:	80 93 02 01 	sts	0x0102, r24
	V2P_RunStateMachine();
     808:	0e 94 83 0f 	call	0x1f06 <V2P_RunStateMachine>
     80c:	08 95       	ret

0000080e <FUNCProgramDataflash>:
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     80e:	a1 e0       	ldi	r26, 0x01	; 1
     810:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     812:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
     816:	80 2d       	mov	r24, r0
     818:	0e 94 8e 09 	call	0x131c <USI_SPIInitMaster>
}

void FUNCProgramDataflash(void)
{
	USI_SPIInitMaster(eeprom_read_byte(&EEPROMVars.SCKDuration));
	UseExernalDF = TRUE;
     81c:	81 e0       	ldi	r24, 0x01	; 1
     81e:	80 93 65 02 	sts	0x0265, r24
	DFSPIRoutinePointer = USI_SPITransmit;
     822:	88 ea       	ldi	r24, 0xA8	; 168
     824:	99 e0       	ldi	r25, 0x09	; 9
     826:	90 93 01 01 	sts	0x0101, r25
     82a:	80 93 00 01 	sts	0x0100, r24
	
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
     82e:	80 e3       	ldi	r24, 0x30	; 48
     830:	92 e0       	ldi	r25, 0x02	; 2
     832:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>
     836:	0e 94 91 07 	call	0xf22 <OSCCAL_Calibrate>
     83a:	80 91 c1 00 	lds	r24, 0x00C1
     83e:	80 78       	andi	r24, 0x80	; 128
     840:	88 61       	ori	r24, 0x18	; 24
     842:	80 93 c1 00 	sts	0x00C1, r24
	LCD_puts_f(DataFlashProgMode);
     846:	81 ed       	ldi	r24, 0xD1	; 209
     848:	93 e0       	ldi	r25, 0x03	; 3
     84a:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>

	InterpretPacketRoutine = (FuncPtr)PD_InterpretAVRISPPacket;
     84e:	84 eb       	ldi	r24, 0xB4	; 180
     850:	9c e0       	ldi	r25, 0x0C	; 12
     852:	90 93 03 01 	sts	0x0103, r25
     856:	80 93 02 01 	sts	0x0102, r24
	V2P_RunStateMachine();
     85a:	0e 94 83 0f 	call	0x1f06 <V2P_RunStateMachine>
	   
	DF_EnableDataflash(FALSE);
     85e:	80 e0       	ldi	r24, 0x00	; 0
     860:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
	SPI_SPIOFF();
     864:	80 91 64 00 	lds	r24, 0x0064
     868:	84 60       	ori	r24, 0x04	; 4
     86a:	80 93 64 00 	sts	0x0064, r24
     86e:	08 95       	ret

00000870 <FUNCProgramAVR>:
}

void FUNCProgramAVR(void)
{
     870:	0f 93       	push	r16
     872:	1f 93       	push	r17
     874:	cf 93       	push	r28
     876:	df 93       	push	r29
     878:	cd b7       	in	r28, 0x3d	; 61
     87a:	de b7       	in	r29, 0x3e	; 62
     87c:	63 97       	sbiw	r28, 0x13	; 19
     87e:	0f b6       	in	r0, 0x3f	; 63
     880:	f8 94       	cli
     882:	de bf       	out	0x3e, r29	; 62
     884:	0f be       	out	0x3f, r0	; 63
     886:	cd bf       	out	0x3d, r28	; 61
	uint8_t  DoneFailMessageBuff[19];
	uint8_t  Fault    = ISPCC_NO_FAULT;
     888:	00 e0       	ldi	r16, 0x00	; 0
	uint8_t  ProgMode = 0;
     88a:	10 2f       	mov	r17, r16

	SPI_SPIInit();
     88c:	0e 94 39 09 	call	0x1272 <SPI_SPIInit>
	UseExernalDF = FALSE;
     890:	00 93 65 02 	sts	0x0265, r16
	DFSPIRoutinePointer = SPI_SPITransmit;
     894:	83 e4       	ldi	r24, 0x43	; 67
     896:	99 e0       	ldi	r25, 0x09	; 9
     898:	90 93 01 01 	sts	0x0101, r25
     89c:	80 93 00 01 	sts	0x0100, r24
	
	if (!(DF_CheckCorrectOnboardChip()))
     8a0:	0e 94 47 0b 	call	0x168e <DF_CheckCorrectOnboardChip>
     8a4:	88 23       	and	r24, r24
     8a6:	09 f4       	brne	.+2      	; 0x8aa <FUNCProgramAVR+0x3a>
     8a8:	18 c1       	rjmp	.+560    	; 0xada <FUNCProgramAVR+0x26a>
	  return;

	MAIN_WaitForJoyRelease();
     8aa:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>
	
	JoyStatus = 1;                              // Use an invalid joystick value to force the program to write the
     8ae:	81 e0       	ldi	r24, 0x01	; 1
     8b0:	8e bb       	out	0x1e, r24	; 30
	                                            // name of the default command onto the LCD
	while (1)
	{
		if (JoyStatus)
     8b2:	8e b3       	in	r24, 0x1e	; 30
     8b4:	88 23       	and	r24, r24
     8b6:	e9 f3       	breq	.-6      	; 0x8b2 <FUNCProgramAVR+0x42>
		{
			if (JoyStatus & JOY_LEFT)
     8b8:	f2 99       	sbic	0x1e, 2	; 30
     8ba:	0f c1       	rjmp	.+542    	; 0xada <FUNCProgramAVR+0x26a>
			  return;
			else if (JoyStatus & JOY_PRESS)
     8bc:	f4 99       	sbic	0x1e, 4	; 30
     8be:	1c c0       	rjmp	.+56     	; 0x8f8 <FUNCProgramAVR+0x88>
			  break;
			else if (JoyStatus & JOY_UP)
     8c0:	f6 9b       	sbis	0x1e, 6	; 30
     8c2:	06 c0       	rjmp	.+12     	; 0x8d0 <FUNCProgramAVR+0x60>
			  (ProgMode == 0)? ProgMode = ARRAY_UPPERBOUND(ProgOptions) : ProgMode--;
     8c4:	11 23       	and	r17, r17
     8c6:	11 f4       	brne	.+4      	; 0x8cc <FUNCProgramAVR+0x5c>
     8c8:	16 e0       	ldi	r17, 0x06	; 6
     8ca:	09 c0       	rjmp	.+18     	; 0x8de <FUNCProgramAVR+0x6e>
     8cc:	11 50       	subi	r17, 0x01	; 1
     8ce:	07 c0       	rjmp	.+14     	; 0x8de <FUNCProgramAVR+0x6e>
			else if (JoyStatus & JOY_DOWN)
     8d0:	f7 9b       	sbis	0x1e, 7	; 30
     8d2:	05 c0       	rjmp	.+10     	; 0x8de <FUNCProgramAVR+0x6e>
			  (ProgMode == ARRAY_UPPERBOUND(ProgOptions))? ProgMode = 0 : ProgMode++;
     8d4:	16 30       	cpi	r17, 0x06	; 6
     8d6:	11 f4       	brne	.+4      	; 0x8dc <FUNCProgramAVR+0x6c>
     8d8:	10 e0       	ldi	r17, 0x00	; 0
     8da:	01 c0       	rjmp	.+2      	; 0x8de <FUNCProgramAVR+0x6e>
     8dc:	1f 5f       	subi	r17, 0xFF	; 255

			LCD_puts_f((uint8_t*)pgm_read_word(&ProgOptions[ProgMode])); // Show current function onto the LCD
     8de:	e1 2f       	mov	r30, r17
     8e0:	ff 27       	eor	r31, r31
     8e2:	ee 0f       	add	r30, r30
     8e4:	ff 1f       	adc	r31, r31
     8e6:	ee 55       	subi	r30, 0x5E	; 94
     8e8:	ff 4f       	sbci	r31, 0xFF	; 255
     8ea:	85 91       	lpm	r24, Z+
     8ec:	94 91       	lpm	r25, Z
     8ee:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     8f2:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>
     8f6:	dd cf       	rjmp	.-70     	; 0x8b2 <FUNCProgramAVR+0x42>
		}
	}

	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_CLOCKSPEED_8MHZ);
     8f8:	80 e8       	ldi	r24, 0x80	; 128
     8fa:	80 93 61 00 	sts	0x0061, r24
     8fe:	10 92 61 00 	sts	0x0061, r1
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);                // Orange = busy
     902:	81 b3       	in	r24, 0x11	; 17
     904:	80 63       	ori	r24, 0x30	; 48
     906:	81 bb       	out	0x11, r24	; 17
	LCD_puts_f(WaitText);
     908:	80 e3       	ldi	r24, 0x30	; 48
     90a:	92 e0       	ldi	r25, 0x02	; 2
     90c:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     910:	a1 e0       	ldi	r26, 0x01	; 1
     912:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     914:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
     918:	80 2d       	mov	r24, r0
     91a:	0e 94 8e 09 	call	0x131c <USI_SPIInitMaster>

	USI_SPIInitMaster(eeprom_read_byte(&EEPROMVars.SCKDuration));
	MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE); // Capture the RESET line of the slave AVR
     91e:	80 e0       	ldi	r24, 0x00	; 0
     920:	0e 94 1a 03 	call	0x634 <MAIN_ResetCSLine>
     924:	eb e4       	ldi	r30, 0x4B	; 75
     926:	f1 e0       	ldi	r31, 0x01	; 1
     928:	20 e0       	ldi	r18, 0x00	; 0
     92a:	30 e0       	ldi	r19, 0x00	; 0
     92c:	9b e0       	ldi	r25, 0x0B	; 11
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     92e:	d9 01       	movw	r26, r18
     930:	ad 5d       	subi	r26, 0xDD	; 221
     932:	bf 4f       	sbci	r27, 0xFF	; 255
  uint8_t result;
  asm volatile
     934:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
     938:	80 2d       	mov	r24, r0
     93a:	81 93       	st	Z+, r24
			
	for (uint8_t PacketB = 0; PacketB <= 11; PacketB++) // Read the enter programming mode command bytes
     93c:	91 50       	subi	r25, 0x01	; 1
     93e:	2f 5f       	subi	r18, 0xFF	; 255
     940:	3f 4f       	sbci	r19, 0xFF	; 255
     942:	97 ff       	sbrs	r25, 7
     944:	f4 cf       	rjmp	.-24     	; 0x92e <FUNCProgramAVR+0xbe>
	  PacketBytes[PacketB] = eeprom_read_byte(&EEPROMVars.EnterProgMode[PacketB]);
	
	ISPCC_EnterChipProgrammingMode();    // Try to sync with the slave AVR
     946:	0e 94 ed 10 	call	0x21da <ISPCC_EnterChipProgrammingMode>

	CurrAddress = 0;
     94a:	10 92 42 01 	sts	0x0142, r1
     94e:	10 92 43 01 	sts	0x0143, r1
     952:	10 92 44 01 	sts	0x0144, r1
     956:	10 92 45 01 	sts	0x0145, r1

	if (PacketBytes[1] == AICB_STATUS_CMD_OK) // ISPCC_EnterChipProgrammingMode alters the PacketBytes buffer rather than returning a value
     95a:	80 91 4c 01 	lds	r24, 0x014C
     95e:	88 23       	and	r24, r24
     960:	09 f0       	breq	.+2      	; 0x964 <FUNCProgramAVR+0xf4>
     962:	a0 c0       	rjmp	.+320    	; 0xaa4 <FUNCProgramAVR+0x234>
	{						
		if ((ProgMode == 6) || (ProgMode == 0) || (ProgMode == 2)) // Erase chip, or program flash mode
     964:	16 30       	cpi	r17, 0x06	; 6
     966:	21 f0       	breq	.+8      	; 0x970 <FUNCProgramAVR+0x100>
     968:	11 23       	and	r17, r17
     96a:	11 f0       	breq	.+4      	; 0x970 <FUNCProgramAVR+0x100>
     96c:	12 30       	cpi	r17, 0x02	; 2
     96e:	91 f4       	brne	.+36     	; 0x994 <FUNCProgramAVR+0x124>
		{
			MAIN_ShowProgType('C');
     970:	83 e4       	ldi	r24, 0x43	; 67
     972:	0e 94 4e 03 	call	0x69c <MAIN_ShowProgType>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     976:	a4 e1       	ldi	r26, 0x14	; 20
     978:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     97a:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
     97e:	80 2d       	mov	r24, r0
     980:	81 30       	cpi	r24, 0x01	; 1
     982:	31 f0       	breq	.+12     	; 0x990 <FUNCProgramAVR+0x120>
			
			if (!(eeprom_read_byte(&EEPROMVars.EraseCmdStored) == TRUE))
			{
				Fault = ISPCC_FAULT_NOERASE;
     984:	02 e0       	ldi	r16, 0x02	; 2
				MAIN_ShowError(PSTR("NO ERASE CMD"));
     986:	8c e6       	ldi	r24, 0x6C	; 108
     988:	92 e0       	ldi	r25, 0x02	; 2
     98a:	0e 94 6f 03 	call	0x6de <MAIN_ShowError>
     98e:	02 c0       	rjmp	.+4      	; 0x994 <FUNCProgramAVR+0x124>
			}
			else
			{
				PM_SendEraseCommand();
     990:	0e 94 81 17 	call	0x2f02 <PM_SendEraseCommand>
			}
		}

		if (((ProgMode == 0) || (ProgMode == 2)) && (Fault == ISPCC_NO_FAULT)) // Program flash
     994:	11 23       	and	r17, r17
     996:	11 f0       	breq	.+4      	; 0x99c <FUNCProgramAVR+0x12c>
     998:	12 30       	cpi	r17, 0x02	; 2
     99a:	b9 f4       	brne	.+46     	; 0x9ca <FUNCProgramAVR+0x15a>
     99c:	00 23       	and	r16, r16
     99e:	a9 f4       	brne	.+42     	; 0x9ca <FUNCProgramAVR+0x15a>
		{
			MAIN_ShowProgType('D');
     9a0:	84 e4       	ldi	r24, 0x44	; 68
     9a2:	0e 94 4e 03 	call	0x69c <MAIN_ShowProgType>

			if (!(PM_GetStoredDataSize(TYPE_FLASH))) // Check to make sure a program is present in memory
     9a6:	81 e0       	ldi	r24, 0x01	; 1
     9a8:	0e 94 ed 13 	call	0x27da <PM_GetStoredDataSize>
     9ac:	dc 01       	movw	r26, r24
     9ae:	cb 01       	movw	r24, r22
     9b0:	00 97       	sbiw	r24, 0x00	; 0
     9b2:	a1 05       	cpc	r26, r1
     9b4:	b1 05       	cpc	r27, r1
     9b6:	31 f4       	brne	.+12     	; 0x9c4 <FUNCProgramAVR+0x154>
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
     9b8:	03 e0       	ldi	r16, 0x03	; 3
				MAIN_ShowError(PSTR("NO DATA"));
     9ba:	89 e7       	ldi	r24, 0x79	; 121
     9bc:	92 e0       	ldi	r25, 0x02	; 2
     9be:	0e 94 6f 03 	call	0x6de <MAIN_ShowError>
     9c2:	03 c0       	rjmp	.+6      	; 0x9ca <FUNCProgramAVR+0x15a>
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_FLASH);
     9c4:	81 e0       	ldi	r24, 0x01	; 1
     9c6:	0e 94 b0 17 	call	0x2f60 <PM_CreateProgrammingPackets>
			}
		}
	
		if ((ProgMode == 1) || (ProgMode == 2)) // Program EEPROM
     9ca:	81 2f       	mov	r24, r17
     9cc:	81 50       	subi	r24, 0x01	; 1
     9ce:	82 30       	cpi	r24, 0x02	; 2
     9d0:	a8 f4       	brcc	.+42     	; 0x9fc <FUNCProgramAVR+0x18c>
		{
			MAIN_ShowProgType('E');
     9d2:	85 e4       	ldi	r24, 0x45	; 69
     9d4:	0e 94 4e 03 	call	0x69c <MAIN_ShowProgType>
				
			if (!(PM_GetStoredDataSize(TYPE_EEPROM))) // Check to make sure EEPROM data is present in memory
     9d8:	80 e0       	ldi	r24, 0x00	; 0
     9da:	0e 94 ed 13 	call	0x27da <PM_GetStoredDataSize>
     9de:	dc 01       	movw	r26, r24
     9e0:	cb 01       	movw	r24, r22
     9e2:	00 97       	sbiw	r24, 0x00	; 0
     9e4:	a1 05       	cpc	r26, r1
     9e6:	b1 05       	cpc	r27, r1
     9e8:	31 f4       	brne	.+12     	; 0x9f6 <FUNCProgramAVR+0x186>
			{
				Fault = ISPCC_FAULT_NODATATYPE;
     9ea:	03 e0       	ldi	r16, 0x03	; 3
				MAIN_ShowError(PSTR("NO EEPROM"));
     9ec:	81 e8       	ldi	r24, 0x81	; 129
     9ee:	92 e0       	ldi	r25, 0x02	; 2
     9f0:	0e 94 6f 03 	call	0x6de <MAIN_ShowError>
     9f4:	03 c0       	rjmp	.+6      	; 0x9fc <FUNCProgramAVR+0x18c>
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_EEPROM);
     9f6:	80 e0       	ldi	r24, 0x00	; 0
     9f8:	0e 94 b0 17 	call	0x2f60 <PM_CreateProgrammingPackets>
			}
		}

		if ((ProgMode == 3) || (ProgMode == 5)) // Program Fuse bytes
     9fc:	13 30       	cpi	r17, 0x03	; 3
     9fe:	11 f0       	breq	.+4      	; 0xa04 <FUNCProgramAVR+0x194>
     a00:	15 30       	cpi	r17, 0x05	; 5
     a02:	99 f4       	brne	.+38     	; 0xa2a <FUNCProgramAVR+0x1ba>
		{
			MAIN_ShowProgType('F');
     a04:	86 e4       	ldi	r24, 0x46	; 70
     a06:	0e 94 4e 03 	call	0x69c <MAIN_ShowProgType>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     a0a:	af e2       	ldi	r26, 0x2F	; 47
     a0c:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     a0e:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
     a12:	80 2d       	mov	r24, r0
     a14:	88 23       	and	r24, r24
     a16:	31 f4       	brne	.+12     	; 0xa24 <FUNCProgramAVR+0x1b4>
			
			if (!(eeprom_read_byte(&EEPROMVars.TotalFuseBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
     a18:	03 e0       	ldi	r16, 0x03	; 3
				MAIN_ShowError(PSTR("NO FUSE BYTES"));
     a1a:	8b e8       	ldi	r24, 0x8B	; 139
     a1c:	92 e0       	ldi	r25, 0x02	; 2
     a1e:	0e 94 6f 03 	call	0x6de <MAIN_ShowError>
     a22:	03 c0       	rjmp	.+6      	; 0xa2a <FUNCProgramAVR+0x1ba>
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_FUSE);
     a24:	82 e0       	ldi	r24, 0x02	; 2
     a26:	0e 94 50 17 	call	0x2ea0 <PM_SendFuseLockBytes>
			}
		}

		if ((ProgMode == 4) || (ProgMode == 5)) // Program Lock bytes
     a2a:	81 2f       	mov	r24, r17
     a2c:	84 50       	subi	r24, 0x04	; 4
     a2e:	82 30       	cpi	r24, 0x02	; 2
     a30:	00 f5       	brcc	.+64     	; 0xa72 <FUNCProgramAVR+0x202>
		{
			if (ProgMode == 5)                    // If fusebytes have already been written, we need to reenter programming mode to latch them
     a32:	15 30       	cpi	r17, 0x05	; 5
     a34:	59 f4       	brne	.+22     	; 0xa4c <FUNCProgramAVR+0x1dc>
			{
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line of the slave AVR
     a36:	81 e0       	ldi	r24, 0x01	; 1
     a38:	0e 94 1a 03 	call	0x634 <MAIN_ResetCSLine>
				MAIN_Delay10MS(1);
     a3c:	81 e0       	ldi	r24, 0x01	; 1
     a3e:	0e 94 31 02 	call	0x462 <MAIN_Delay10MS>
				MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE); // Capture the RESET line of the slave AVR
     a42:	80 e0       	ldi	r24, 0x00	; 0
     a44:	0e 94 1a 03 	call	0x634 <MAIN_ResetCSLine>
				ISPCC_EnterChipProgrammingMode(); // Try to sync with the slave AVR
     a48:	0e 94 ed 10 	call	0x21da <ISPCC_EnterChipProgrammingMode>
			}

			MAIN_ShowProgType('L');
     a4c:	8c e4       	ldi	r24, 0x4C	; 76
     a4e:	0e 94 4e 03 	call	0x69c <MAIN_ShowProgType>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     a52:	a0 e3       	ldi	r26, 0x30	; 48
     a54:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
     a56:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
     a5a:	80 2d       	mov	r24, r0
     a5c:	88 23       	and	r24, r24
     a5e:	31 f4       	brne	.+12     	; 0xa6c <FUNCProgramAVR+0x1fc>
		
			if (!(eeprom_read_byte(&EEPROMVars.TotalLockBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;
     a60:	03 e0       	ldi	r16, 0x03	; 3
				MAIN_ShowError(PSTR("NO LOCK BYTES"));
     a62:	89 e9       	ldi	r24, 0x99	; 153
     a64:	92 e0       	ldi	r25, 0x02	; 2
     a66:	0e 94 6f 03 	call	0x6de <MAIN_ShowError>
     a6a:	03 c0       	rjmp	.+6      	; 0xa72 <FUNCProgramAVR+0x202>
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_LOCK);
     a6c:	83 e0       	ldi	r24, 0x03	; 3
     a6e:	0e 94 50 17 	call	0x2ea0 <PM_SendFuseLockBytes>
			}
		}

		strcpy_P(DoneFailMessageBuff, PSTR("PROGRAMMING DONE"));
     a72:	67 ea       	ldi	r22, 0xA7	; 167
     a74:	72 e0       	ldi	r23, 0x02	; 2
     a76:	ce 01       	movw	r24, r28
     a78:	01 96       	adiw	r24, 0x01	; 1
     a7a:	0e 94 25 1a 	call	0x344a <strcpy_P>

		if (Fault != ISPCC_NO_FAULT)         // Takes less code to just overwrite part of the string on fail
     a7e:	00 23       	and	r16, r16
     a80:	31 f0       	breq	.+12     	; 0xa8e <FUNCProgramAVR+0x21e>
		  strcpy_P(&DoneFailMessageBuff[12], PSTR("FAILED"));
     a82:	68 eb       	ldi	r22, 0xB8	; 184
     a84:	72 e0       	ldi	r23, 0x02	; 2
     a86:	ce 01       	movw	r24, r28
     a88:	0d 96       	adiw	r24, 0x0d	; 13
     a8a:	0e 94 25 1a 	call	0x344a <strcpy_P>

		LCD_puts(DoneFailMessageBuff);
     a8e:	ce 01       	movw	r24, r28
     a90:	01 96       	adiw	r24, 0x01	; 1
     a92:	0e 94 24 08 	call	0x1048 <LCD_puts>

		MAIN_Delay10MS(255);
     a96:	8f ef       	ldi	r24, 0xFF	; 255
     a98:	0e 94 31 02 	call	0x462 <MAIN_Delay10MS>
		MAIN_Delay10MS(100);
     a9c:	84 e6       	ldi	r24, 0x64	; 100
     a9e:	0e 94 31 02 	call	0x462 <MAIN_Delay10MS>
     aa2:	04 c0       	rjmp	.+8      	; 0xaac <FUNCProgramAVR+0x23c>
	}
	else
	{
		MAIN_ShowError(SyncErrorMessage);
     aa4:	8d ee       	ldi	r24, 0xED	; 237
     aa6:	93 e0       	ldi	r25, 0x03	; 3
     aa8:	0e 94 6f 03 	call	0x6de <MAIN_ShowError>
	}
	
	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_CLOCKSPEED_1MHZ);
     aac:	80 e8       	ldi	r24, 0x80	; 128
     aae:	80 93 61 00 	sts	0x0061, r24
     ab2:	83 e0       	ldi	r24, 0x03	; 3
     ab4:	80 93 61 00 	sts	0x0061, r24
	MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run	
     ab8:	81 e0       	ldi	r24, 0x01	; 1
     aba:	0e 94 1a 03 	call	0x634 <MAIN_ResetCSLine>
	USI_SPIOff();
     abe:	0e 94 9e 09 	call	0x133c <USI_SPIOff>
	DF_EnableDataflash(FALSE);
     ac2:	80 e0       	ldi	r24, 0x00	; 0
     ac4:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
	SPI_SPIOFF();
     ac8:	80 91 64 00 	lds	r24, 0x0064
     acc:	84 60       	ori	r24, 0x04	; 4
     ace:	80 93 64 00 	sts	0x0064, r24
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Green = ready
     ad2:	81 b3       	in	r24, 0x11	; 17
     ad4:	8f 7c       	andi	r24, 0xCF	; 207
     ad6:	80 61       	ori	r24, 0x10	; 16
     ad8:	81 bb       	out	0x11, r24	; 17
     ada:	63 96       	adiw	r28, 0x13	; 19
     adc:	0f b6       	in	r0, 0x3f	; 63
     ade:	f8 94       	cli
     ae0:	de bf       	out	0x3e, r29	; 62
     ae2:	0f be       	out	0x3f, r0	; 63
     ae4:	cd bf       	out	0x3d, r28	; 61
     ae6:	df 91       	pop	r29
     ae8:	cf 91       	pop	r28
     aea:	1f 91       	pop	r17
     aec:	0f 91       	pop	r16
     aee:	08 95       	ret

00000af0 <FUNCStoreProgram>:
}

void FUNCStoreProgram(void)
{
	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
     af0:	83 e4       	ldi	r24, 0x43	; 67
     af2:	99 e0       	ldi	r25, 0x09	; 9
     af4:	90 93 01 01 	sts	0x0101, r25
     af8:	80 93 00 01 	sts	0x0100, r24
	SPI_SPIInit();
     afc:	0e 94 39 09 	call	0x1272 <SPI_SPIInit>
	UseExernalDF = FALSE;
     b00:	10 92 65 02 	sts	0x0265, r1
	DF_EnableDataflash(TRUE);
     b04:	81 e0       	ldi	r24, 0x01	; 1
     b06:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>

	if (!(DF_CheckCorrectOnboardChip()))
     b0a:	0e 94 47 0b 	call	0x168e <DF_CheckCorrectOnboardChip>
     b0e:	88 23       	and	r24, r24
     b10:	01 f1       	breq	.+64     	; 0xb52 <FUNCStoreProgram+0x62>
	  return;
			
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
     b12:	80 e3       	ldi	r24, 0x30	; 48
     b14:	92 e0       	ldi	r25, 0x02	; 2
     b16:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>
     b1a:	0e 94 91 07 	call	0xf22 <OSCCAL_Calibrate>
     b1e:	80 91 c1 00 	lds	r24, 0x00C1
     b22:	80 78       	andi	r24, 0x80	; 128
     b24:	88 61       	ori	r24, 0x18	; 24
     b26:	80 93 c1 00 	sts	0x00C1, r24
	LCD_puts_f(PSTR("*STORAGE MODE*"));
     b2a:	8f eb       	ldi	r24, 0xBF	; 191
     b2c:	92 e0       	ldi	r25, 0x02	; 2
     b2e:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>

	InterpretPacketRoutine = (FuncPtr)PM_InterpretAVRISPPacket;
     b32:	82 e0       	ldi	r24, 0x02	; 2
     b34:	95 e1       	ldi	r25, 0x15	; 21
     b36:	90 93 03 01 	sts	0x0103, r25
     b3a:	80 93 02 01 	sts	0x0102, r24
	V2P_RunStateMachine();
     b3e:	0e 94 83 0f 	call	0x1f06 <V2P_RunStateMachine>
	
	DF_EnableDataflash(FALSE);
     b42:	80 e0       	ldi	r24, 0x00	; 0
     b44:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
	SPI_SPIOFF();
     b48:	80 91 64 00 	lds	r24, 0x0064
     b4c:	84 60       	ori	r24, 0x04	; 4
     b4e:	80 93 64 00 	sts	0x0064, r24
     b52:	08 95       	ret

00000b54 <FUNCClearMem>:
}

void FUNCClearMem(void)
{
     b54:	cf 93       	push	r28
     b56:	df 93       	push	r29
	LCD_puts_f(PSTR("CONFIRM"));
     b58:	8e ec       	ldi	r24, 0xCE	; 206
     b5a:	92 e0       	ldi	r25, 0x02	; 2
     b5c:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>
	MAIN_Delay10MS(180);
     b60:	84 eb       	ldi	r24, 0xB4	; 180
     b62:	0e 94 31 02 	call	0x462 <MAIN_Delay10MS>

	LCD_puts_f(PSTR("<N Y>"));
     b66:	86 ed       	ldi	r24, 0xD6	; 214
     b68:	92 e0       	ldi	r25, 0x02	; 2
     b6a:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>

	while (1)
	{
		if (JoyStatus)
     b6e:	8e b3       	in	r24, 0x1e	; 30
     b70:	88 23       	and	r24, r24
     b72:	e9 f3       	breq	.-6      	; 0xb6e <FUNCClearMem+0x1a>
		{
			if (JoyStatus & JOY_LEFT)
     b74:	8e b3       	in	r24, 0x1e	; 30
     b76:	99 27       	eor	r25, r25
     b78:	ec 01       	movw	r28, r24
     b7a:	c4 70       	andi	r28, 0x04	; 4
     b7c:	d0 70       	andi	r29, 0x00	; 0
     b7e:	82 fd       	sbrc	r24, 2
     b80:	19 c0       	rjmp	.+50     	; 0xbb4 <FUNCClearMem+0x60>
			  return;
			else if (JoyStatus & JOY_RIGHT)
     b82:	f3 9b       	sbis	0x1e, 3	; 30
     b84:	f4 cf       	rjmp	.-24     	; 0xb6e <FUNCClearMem+0x1a>
			  break;
		}
	}

	MAIN_WaitForJoyRelease();
     b86:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>

	LCD_puts_f(WaitText);
     b8a:	80 e3       	ldi	r24, 0x30	; 48
     b8c:	92 e0       	ldi	r25, 0x02	; 2
     b8e:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>

	for (uint16_t EAddr = 0; EAddr < sizeof(EEPROMVars); EAddr++)
     b92:	ce 01       	movw	r24, r28
     b94:	2f ef       	ldi	r18, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     b96:	dc 01       	movw	r26, r24
     b98:	02 2e       	mov	r0, r18
     b9a:	0e 94 73 1a 	call	0x34e6 <__eeprom_write_byte_1F2021>
     b9e:	01 96       	adiw	r24, 0x01	; 1
     ba0:	89 38       	cpi	r24, 0x89	; 137
     ba2:	91 05       	cpc	r25, r1
     ba4:	c0 f3       	brcs	.-16     	; 0xb96 <FUNCClearMem+0x42>
	  eeprom_write_byte((uint8_t*)EAddr, 0xFF);

	LCD_puts_f(PSTR("MEM CLEARED"));
     ba6:	8c ed       	ldi	r24, 0xDC	; 220
     ba8:	92 e0       	ldi	r25, 0x02	; 2
     baa:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>
	MAIN_Delay10MS(255);
     bae:	8f ef       	ldi	r24, 0xFF	; 255
     bb0:	0e 94 31 02 	call	0x462 <MAIN_Delay10MS>
     bb4:	df 91       	pop	r29
     bb6:	cf 91       	pop	r28
     bb8:	08 95       	ret

00000bba <FUNCSetContrast>:
}

void FUNCSetContrast(void)
{
     bba:	ef 92       	push	r14
     bbc:	ff 92       	push	r15
     bbe:	1f 93       	push	r17
     bc0:	cf 93       	push	r28
     bc2:	df 93       	push	r29
     bc4:	cd b7       	in	r28, 0x3d	; 61
     bc6:	de b7       	in	r29, 0x3e	; 62
     bc8:	26 97       	sbiw	r28, 0x06	; 6
     bca:	0f b6       	in	r0, 0x3f	; 63
     bcc:	f8 94       	cli
     bce:	de bf       	out	0x3e, r29	; 62
     bd0:	0f be       	out	0x3f, r0	; 63
     bd2:	cd bf       	out	0x3d, r28	; 61
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     bd4:	85 e8       	ldi	r24, 0x85	; 133
     bd6:	e8 2e       	mov	r14, r24
     bd8:	80 e0       	ldi	r24, 0x00	; 0
     bda:	f8 2e       	mov	r15, r24
  uint8_t result;
  asm volatile
     bdc:	d7 01       	movw	r26, r14
     bde:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
     be2:	80 2d       	mov	r24, r0
     be4:	18 2f       	mov	r17, r24
     be6:	1f 70       	andi	r17, 0x0F	; 15
	uint8_t Buffer[6];
	uint8_t Contrast = (eeprom_read_byte(&EEPROMVars.LCDContrast) & 0x0F); // Ranges from 0-15 so mask retuns 15 on blank EEPROM (0xFF)
	
	JoyStatus = 1;                          // Invalid value to force the LCD to update
     be8:	81 e0       	ldi	r24, 0x01	; 1
     bea:	8e bb       	out	0x1e, r24	; 30
	
	while (1)
	{
		if (JoyStatus)
     bec:	8e b3       	in	r24, 0x1e	; 30
     bee:	88 23       	and	r24, r24
     bf0:	e9 f3       	breq	.-6      	; 0xbec <FUNCSetContrast+0x32>
		{
			if (JoyStatus & JOY_UP)
     bf2:	f6 9b       	sbis	0x1e, 6	; 30
     bf4:	04 c0       	rjmp	.+8      	; 0xbfe <FUNCSetContrast+0x44>
			{
				if (Contrast < 15)
     bf6:	1f 30       	cpi	r17, 0x0F	; 15
     bf8:	78 f4       	brcc	.+30     	; 0xc18 <FUNCSetContrast+0x5e>
				  Contrast++;
     bfa:	1f 5f       	subi	r17, 0xFF	; 255
     bfc:	0d c0       	rjmp	.+26     	; 0xc18 <FUNCSetContrast+0x5e>
			}
			else if (JoyStatus & JOY_DOWN)
     bfe:	f7 9b       	sbis	0x1e, 7	; 30
     c00:	04 c0       	rjmp	.+8      	; 0xc0a <FUNCSetContrast+0x50>
			{
				if (Contrast > 1)          // Zero is non-visible, so 1 is the minimum
     c02:	12 30       	cpi	r17, 0x02	; 2
     c04:	48 f0       	brcs	.+18     	; 0xc18 <FUNCSetContrast+0x5e>
				  Contrast--;
     c06:	11 50       	subi	r17, 0x01	; 1
     c08:	07 c0       	rjmp	.+14     	; 0xc18 <FUNCSetContrast+0x5e>
			}
			else if (JoyStatus & JOY_LEFT)
     c0a:	f2 9b       	sbis	0x1e, 2	; 30
     c0c:	05 c0       	rjmp	.+10     	; 0xc18 <FUNCSetContrast+0x5e>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     c0e:	d7 01       	movw	r26, r14
     c10:	01 2e       	mov	r0, r17
     c12:	0e 94 73 1a 	call	0x34e6 <__eeprom_write_byte_1F2021>
			{
				eeprom_write_byte(&EEPROMVars.LCDContrast, Contrast);
				return;
     c16:	18 c0       	rjmp	.+48     	; 0xc48 <FUNCSetContrast+0x8e>
			}
					
			Buffer[0] = 'C';
     c18:	83 e4       	ldi	r24, 0x43	; 67
     c1a:	89 83       	std	Y+1, r24	; 0x01
			Buffer[1] = 'T';
     c1c:	84 e5       	ldi	r24, 0x54	; 84
     c1e:	8a 83       	std	Y+2, r24	; 0x02
			Buffer[2] = ' ';
     c20:	80 e2       	ldi	r24, 0x20	; 32
     c22:	8b 83       	std	Y+3, r24	; 0x03

			MAIN_IntToStr((uint16_t)Contrast, &Buffer[3]);
     c24:	be 01       	movw	r22, r28
     c26:	6c 5f       	subi	r22, 0xFC	; 252
     c28:	7f 4f       	sbci	r23, 0xFF	; 255
     c2a:	81 2f       	mov	r24, r17
     c2c:	99 27       	eor	r25, r25
     c2e:	0e 94 36 03 	call	0x66c <MAIN_IntToStr>
			LCD_puts(Buffer);
     c32:	ce 01       	movw	r24, r28
     c34:	01 96       	adiw	r24, 0x01	; 1
     c36:	0e 94 24 08 	call	0x1048 <LCD_puts>

			LCD_CONTRAST_LEVEL(Contrast);
     c3a:	81 2f       	mov	r24, r17
     c3c:	8f 70       	andi	r24, 0x0F	; 15
     c3e:	80 93 e7 00 	sts	0x00E7, r24

			MAIN_WaitForJoyRelease();
     c42:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>
     c46:	d2 cf       	rjmp	.-92     	; 0xbec <FUNCSetContrast+0x32>
     c48:	26 96       	adiw	r28, 0x06	; 6
     c4a:	0f b6       	in	r0, 0x3f	; 63
     c4c:	f8 94       	cli
     c4e:	de bf       	out	0x3e, r29	; 62
     c50:	0f be       	out	0x3f, r0	; 63
     c52:	cd bf       	out	0x3d, r28	; 61
     c54:	df 91       	pop	r29
     c56:	cf 91       	pop	r28
     c58:	1f 91       	pop	r17
     c5a:	ff 90       	pop	r15
     c5c:	ef 90       	pop	r14
     c5e:	08 95       	ret

00000c60 <FUNCSetISPSpeed>:
		}
	}
}

void FUNCSetISPSpeed(void)
{
     c60:	0f 93       	push	r16
     c62:	1f 93       	push	r17
     c64:	cf 93       	push	r28
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     c66:	01 e0       	ldi	r16, 0x01	; 1
     c68:	10 e0       	ldi	r17, 0x00	; 0
  uint8_t result;
  asm volatile
     c6a:	d8 01       	movw	r26, r16
     c6c:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
     c70:	80 2d       	mov	r24, r0
     c72:	c8 2f       	mov	r28, r24
	uint8_t CurrSpeed = eeprom_read_byte(&EEPROMVars.SCKDuration);

	if (CurrSpeed > ARRAY_UPPERBOUND(USISpeeds)) CurrSpeed = ARRAY_UPPERBOUND(USISpeeds); // Protection against blank EEPROM
     c74:	84 30       	cpi	r24, 0x04	; 4
     c76:	08 f0       	brcs	.+2      	; 0xc7a <FUNCSetISPSpeed+0x1a>
     c78:	c3 e0       	ldi	r28, 0x03	; 3

	JoyStatus = 1;                         // Invalid value to force the LCD to update
     c7a:	81 e0       	ldi	r24, 0x01	; 1
     c7c:	8e bb       	out	0x1e, r24	; 30

	while (1)
	{
		if (JoyStatus)
     c7e:	8e b3       	in	r24, 0x1e	; 30
     c80:	88 23       	and	r24, r24
     c82:	e9 f3       	breq	.-6      	; 0xc7e <FUNCSetISPSpeed+0x1e>
		{
			if (JoyStatus & JOY_UP)
     c84:	f6 9b       	sbis	0x1e, 6	; 30
     c86:	06 c0       	rjmp	.+12     	; 0xc94 <FUNCSetISPSpeed+0x34>
			{
				(CurrSpeed == 0)? CurrSpeed = ARRAY_UPPERBOUND(USISpeeds) : CurrSpeed--;
     c88:	cc 23       	and	r28, r28
     c8a:	11 f4       	brne	.+4      	; 0xc90 <FUNCSetISPSpeed+0x30>
     c8c:	c3 e0       	ldi	r28, 0x03	; 3
     c8e:	11 c0       	rjmp	.+34     	; 0xcb2 <FUNCSetISPSpeed+0x52>
     c90:	c1 50       	subi	r28, 0x01	; 1
     c92:	0f c0       	rjmp	.+30     	; 0xcb2 <FUNCSetISPSpeed+0x52>
			}
			else if (JoyStatus & JOY_DOWN)
     c94:	f7 9b       	sbis	0x1e, 7	; 30
     c96:	06 c0       	rjmp	.+12     	; 0xca4 <FUNCSetISPSpeed+0x44>
			{
				(CurrSpeed == ARRAY_UPPERBOUND(USISpeeds))? CurrSpeed = 0 : CurrSpeed++;
     c98:	c3 30       	cpi	r28, 0x03	; 3
     c9a:	11 f4       	brne	.+4      	; 0xca0 <FUNCSetISPSpeed+0x40>
     c9c:	c0 e0       	ldi	r28, 0x00	; 0
     c9e:	09 c0       	rjmp	.+18     	; 0xcb2 <FUNCSetISPSpeed+0x52>
     ca0:	cf 5f       	subi	r28, 0xFF	; 255
     ca2:	07 c0       	rjmp	.+14     	; 0xcb2 <FUNCSetISPSpeed+0x52>
			}
			else if (JoyStatus & JOY_LEFT)
     ca4:	f2 9b       	sbis	0x1e, 2	; 30
     ca6:	05 c0       	rjmp	.+10     	; 0xcb2 <FUNCSetISPSpeed+0x52>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     ca8:	d8 01       	movw	r26, r16
     caa:	0c 2e       	mov	r0, r28
     cac:	0e 94 73 1a 	call	0x34e6 <__eeprom_write_byte_1F2021>
			{
				eeprom_write_byte(&EEPROMVars.SCKDuration, CurrSpeed);
				return;
     cb0:	0b c0       	rjmp	.+22     	; 0xcc8 <FUNCSetISPSpeed+0x68>
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f(USISpeeds[CurrSpeed]);
     cb2:	8a e0       	ldi	r24, 0x0A	; 10
     cb4:	c8 9f       	mul	r28, r24
     cb6:	c0 01       	movw	r24, r0
     cb8:	11 24       	eor	r1, r1
     cba:	86 58       	subi	r24, 0x86	; 134
     cbc:	9f 4f       	sbci	r25, 0xFF	; 255
     cbe:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     cc2:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>
     cc6:	db cf       	rjmp	.-74     	; 0xc7e <FUNCSetISPSpeed+0x1e>
     cc8:	cf 91       	pop	r28
     cca:	1f 91       	pop	r17
     ccc:	0f 91       	pop	r16
     cce:	08 95       	ret

00000cd0 <FUNCSetFirmMinorVer>:
		}
	}
}

void FUNCSetFirmMinorVer(void)
{
     cd0:	ef 92       	push	r14
     cd2:	ff 92       	push	r15
     cd4:	1f 93       	push	r17
     cd6:	cf 93       	push	r28
     cd8:	df 93       	push	r29
     cda:	cd b7       	in	r28, 0x3d	; 61
     cdc:	de b7       	in	r29, 0x3e	; 62
     cde:	25 97       	sbiw	r28, 0x05	; 5
     ce0:	0f b6       	in	r0, 0x3f	; 63
     ce2:	f8 94       	cli
     ce4:	de bf       	out	0x3e, r29	; 62
     ce6:	0f be       	out	0x3f, r0	; 63
     ce8:	cd bf       	out	0x3d, r28	; 61
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     cea:	96 e8       	ldi	r25, 0x86	; 134
     cec:	e9 2e       	mov	r14, r25
     cee:	90 e0       	ldi	r25, 0x00	; 0
     cf0:	f9 2e       	mov	r15, r25
  uint8_t result;
  asm volatile
     cf2:	d7 01       	movw	r26, r14
     cf4:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
     cf8:	80 2d       	mov	r24, r0
     cfa:	18 2f       	mov	r17, r24
	uint8_t VerBuffer[5];
	uint8_t VerMinor = eeprom_read_byte(&EEPROMVars.FirmVerMinor);

	if (VerMinor > 9)
     cfc:	8a 30       	cpi	r24, 0x0A	; 10
     cfe:	08 f0       	brcs	.+2      	; 0xd02 <FUNCSetFirmMinorVer+0x32>
	  VerMinor = V2P_SW_VERSION_MINOR_DEFAULT;
     d00:	14 e0       	ldi	r17, 0x04	; 4
	
	strcpy_P(VerBuffer, PSTR("V2- "));
     d02:	68 ee       	ldi	r22, 0xE8	; 232
     d04:	72 e0       	ldi	r23, 0x02	; 2
     d06:	ce 01       	movw	r24, r28
     d08:	01 96       	adiw	r24, 0x01	; 1
     d0a:	0e 94 25 1a 	call	0x344a <strcpy_P>

	JoyStatus = 1;                        // Invalid value to force the LCD to update
     d0e:	81 e0       	ldi	r24, 0x01	; 1
     d10:	8e bb       	out	0x1e, r24	; 30

	while (1)
	{
		if (JoyStatus)
     d12:	8e b3       	in	r24, 0x1e	; 30
     d14:	88 23       	and	r24, r24
     d16:	e9 f3       	breq	.-6      	; 0xd12 <FUNCSetFirmMinorVer+0x42>
		{
			if (JoyStatus & JOY_UP)
     d18:	f6 9b       	sbis	0x1e, 6	; 30
     d1a:	03 c0       	rjmp	.+6      	; 0xd22 <FUNCSetFirmMinorVer+0x52>
			{
				if (VerMinor < 9)
     d1c:	19 30       	cpi	r17, 0x09	; 9
     d1e:	08 f4       	brcc	.+2      	; 0xd22 <FUNCSetFirmMinorVer+0x52>
				  VerMinor++;
     d20:	1f 5f       	subi	r17, 0xFF	; 255
			}
			if (JoyStatus & JOY_DOWN)
     d22:	f7 9b       	sbis	0x1e, 7	; 30
     d24:	04 c0       	rjmp	.+8      	; 0xd2e <FUNCSetFirmMinorVer+0x5e>
			{
				if (VerMinor)
     d26:	11 23       	and	r17, r17
     d28:	49 f0       	breq	.+18     	; 0xd3c <FUNCSetFirmMinorVer+0x6c>
				  VerMinor--;
     d2a:	11 50       	subi	r17, 0x01	; 1
     d2c:	07 c0       	rjmp	.+14     	; 0xd3c <FUNCSetFirmMinorVer+0x6c>
			}
			else if (JoyStatus & JOY_LEFT)
     d2e:	f2 9b       	sbis	0x1e, 2	; 30
     d30:	05 c0       	rjmp	.+10     	; 0xd3c <FUNCSetFirmMinorVer+0x6c>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     d32:	d7 01       	movw	r26, r14
     d34:	01 2e       	mov	r0, r17
     d36:	0e 94 73 1a 	call	0x34e6 <__eeprom_write_byte_1F2021>
			{
				eeprom_write_byte(&EEPROMVars.FirmVerMinor, VerMinor);
				return;
     d3a:	0a c0       	rjmp	.+20     	; 0xd50 <FUNCSetFirmMinorVer+0x80>
			}
			
			VerBuffer[3] = ('0' + VerMinor);
     d3c:	10 5d       	subi	r17, 0xD0	; 208
     d3e:	1c 83       	std	Y+4, r17	; 0x04
     d40:	10 53       	subi	r17, 0x30	; 48
			LCD_puts(VerBuffer);
     d42:	ce 01       	movw	r24, r28
     d44:	01 96       	adiw	r24, 0x01	; 1
     d46:	0e 94 24 08 	call	0x1048 <LCD_puts>

			MAIN_WaitForJoyRelease();
     d4a:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>
     d4e:	e1 cf       	rjmp	.-62     	; 0xd12 <FUNCSetFirmMinorVer+0x42>
     d50:	25 96       	adiw	r28, 0x05	; 5
     d52:	0f b6       	in	r0, 0x3f	; 63
     d54:	f8 94       	cli
     d56:	de bf       	out	0x3e, r29	; 62
     d58:	0f be       	out	0x3f, r0	; 63
     d5a:	cd bf       	out	0x3d, r28	; 61
     d5c:	df 91       	pop	r29
     d5e:	cf 91       	pop	r28
     d60:	1f 91       	pop	r17
     d62:	ff 90       	pop	r15
     d64:	ef 90       	pop	r14
     d66:	08 95       	ret

00000d68 <FUNCSetAutoSleepTimeOut>:
		}
	}	
}

void FUNCSetAutoSleepTimeOut(void)
{
     d68:	ef 92       	push	r14
     d6a:	ff 92       	push	r15
     d6c:	1f 93       	push	r17
     d6e:	cf 93       	push	r28
     d70:	df 93       	push	r29
     d72:	cd b7       	in	r28, 0x3d	; 61
     d74:	de b7       	in	r29, 0x3e	; 62
     d76:	28 97       	sbiw	r28, 0x08	; 8
     d78:	0f b6       	in	r0, 0x3f	; 63
     d7a:	f8 94       	cli
     d7c:	de bf       	out	0x3e, r29	; 62
     d7e:	0f be       	out	0x3f, r0	; 63
     d80:	cd bf       	out	0x3d, r28	; 61
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
     d82:	27 e8       	ldi	r18, 0x87	; 135
     d84:	e2 2e       	mov	r14, r18
     d86:	20 e0       	ldi	r18, 0x00	; 0
     d88:	f2 2e       	mov	r15, r18
  uint8_t result;
  asm volatile
     d8a:	d7 01       	movw	r26, r14
     d8c:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
     d90:	80 2d       	mov	r24, r0
     d92:	18 2f       	mov	r17, r24
	uint8_t SleepTxtBuffer[8];
	uint8_t SleepVal = eeprom_read_byte(&EEPROMVars.AutoSleepValIndex);

	if (SleepVal > 4)
     d94:	85 30       	cpi	r24, 0x05	; 5
     d96:	08 f0       	brcs	.+2      	; 0xd9a <FUNCSetAutoSleepTimeOut+0x32>
	  SleepVal = 4;
     d98:	14 e0       	ldi	r17, 0x04	; 4

	strcpy_P(SleepTxtBuffer, PSTR("    SEC"));
     d9a:	6d ee       	ldi	r22, 0xED	; 237
     d9c:	72 e0       	ldi	r23, 0x02	; 2
     d9e:	ce 01       	movw	r24, r28
     da0:	01 96       	adiw	r24, 0x01	; 1
     da2:	0e 94 25 1a 	call	0x344a <strcpy_P>
	
	JoyStatus = 1;                        // Invalid value to force the LCD to update
     da6:	81 e0       	ldi	r24, 0x01	; 1
     da8:	8e bb       	out	0x1e, r24	; 30

	while (1)
	{
		if (JoyStatus)
     daa:	8e b3       	in	r24, 0x1e	; 30
     dac:	88 23       	and	r24, r24
     dae:	e9 f3       	breq	.-6      	; 0xdaa <FUNCSetAutoSleepTimeOut+0x42>
		{
			if (JoyStatus & JOY_UP)
     db0:	f6 9b       	sbis	0x1e, 6	; 30
     db2:	05 c0       	rjmp	.+10     	; 0xdbe <FUNCSetAutoSleepTimeOut+0x56>
			{
				(SleepVal == 0)? SleepVal = ARRAY_UPPERBOUND(AutoSleepTOValues) : SleepVal--;
     db4:	11 23       	and	r17, r17
     db6:	11 f4       	brne	.+4      	; 0xdbc <FUNCSetAutoSleepTimeOut+0x54>
     db8:	14 e0       	ldi	r17, 0x04	; 4
     dba:	01 c0       	rjmp	.+2      	; 0xdbe <FUNCSetAutoSleepTimeOut+0x56>
     dbc:	11 50       	subi	r17, 0x01	; 1
			}
			if (JoyStatus & JOY_DOWN)
     dbe:	f7 9b       	sbis	0x1e, 7	; 30
     dc0:	06 c0       	rjmp	.+12     	; 0xdce <FUNCSetAutoSleepTimeOut+0x66>
			{
				(SleepVal == ARRAY_UPPERBOUND(AutoSleepTOValues))? SleepVal = 0 : SleepVal++;
     dc2:	14 30       	cpi	r17, 0x04	; 4
     dc4:	11 f4       	brne	.+4      	; 0xdca <FUNCSetAutoSleepTimeOut+0x62>
     dc6:	10 e0       	ldi	r17, 0x00	; 0
     dc8:	0d c0       	rjmp	.+26     	; 0xde4 <FUNCSetAutoSleepTimeOut+0x7c>
     dca:	1f 5f       	subi	r17, 0xFF	; 255
     dcc:	09 c0       	rjmp	.+18     	; 0xde0 <FUNCSetAutoSleepTimeOut+0x78>
			}
			else if (JoyStatus & JOY_LEFT)
     dce:	f2 9b       	sbis	0x1e, 2	; 30
     dd0:	07 c0       	rjmp	.+14     	; 0xde0 <FUNCSetAutoSleepTimeOut+0x78>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     dd2:	d7 01       	movw	r26, r14
     dd4:	01 2e       	mov	r0, r17
     dd6:	0e 94 73 1a 	call	0x34e6 <__eeprom_write_byte_1F2021>
			{
				eeprom_write_byte(&EEPROMVars.AutoSleepValIndex, SleepVal);
				TOUT_SetupSleepTimer();
     dda:	0e 94 f4 0b 	call	0x17e8 <TOUT_SetupSleepTimer>
				return;
     dde:	1b c0       	rjmp	.+54     	; 0xe16 <FUNCSetAutoSleepTimeOut+0xae>
			}

			if (!(SleepVal))
     de0:	11 23       	and	r17, r17
     de2:	29 f4       	brne	.+10     	; 0xdee <FUNCSetAutoSleepTimeOut+0x86>
			{
				LCD_puts_f(PSTR("OFF"));
     de4:	85 ef       	ldi	r24, 0xF5	; 245
     de6:	92 e0       	ldi	r25, 0x02	; 2
     de8:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>
     dec:	11 c0       	rjmp	.+34     	; 0xe10 <FUNCSetAutoSleepTimeOut+0xa8>
			}
			else
			{
				MAIN_IntToStr(pgm_read_byte(&AutoSleepTOValues[SleepVal]), &SleepTxtBuffer[0]);
     dee:	e1 2f       	mov	r30, r17
     df0:	ff 27       	eor	r31, r31
     df2:	e4 53       	subi	r30, 0x34	; 52
     df4:	fc 4f       	sbci	r31, 0xFC	; 252
     df6:	84 91       	lpm	r24, Z
     df8:	be 01       	movw	r22, r28
     dfa:	6f 5f       	subi	r22, 0xFF	; 255
     dfc:	7f 4f       	sbci	r23, 0xFF	; 255
     dfe:	99 27       	eor	r25, r25
     e00:	0e 94 36 03 	call	0x66c <MAIN_IntToStr>
				SleepTxtBuffer[3] = ' '; // Remove the auto-string termination from the buffer
     e04:	80 e2       	ldi	r24, 0x20	; 32
     e06:	8c 83       	std	Y+4, r24	; 0x04
				LCD_puts(SleepTxtBuffer);
     e08:	ce 01       	movw	r24, r28
     e0a:	01 96       	adiw	r24, 0x01	; 1
     e0c:	0e 94 24 08 	call	0x1048 <LCD_puts>
			}

			MAIN_WaitForJoyRelease();
     e10:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>
     e14:	ca cf       	rjmp	.-108    	; 0xdaa <FUNCSetAutoSleepTimeOut+0x42>
     e16:	28 96       	adiw	r28, 0x08	; 8
     e18:	0f b6       	in	r0, 0x3f	; 63
     e1a:	f8 94       	cli
     e1c:	de bf       	out	0x3e, r29	; 62
     e1e:	0f be       	out	0x3f, r0	; 63
     e20:	cd bf       	out	0x3d, r28	; 61
     e22:	df 91       	pop	r29
     e24:	cf 91       	pop	r28
     e26:	1f 91       	pop	r17
     e28:	ff 90       	pop	r15
     e2a:	ef 90       	pop	r14
     e2c:	08 95       	ret

00000e2e <FUNCSleepMode>:
		}
	}	
}

void FUNCSleepMode(void)
{
	SMCR    = ((1 << SM1) | (1 << SE));    // Power down sleep mode
     e2e:	85 e0       	ldi	r24, 0x05	; 5
     e30:	83 bf       	out	0x33, r24	; 51
	LCDCRA &= ~(1 << LCDEN); 
     e32:	80 91 e4 00 	lds	r24, 0x00E4
     e36:	8f 77       	andi	r24, 0x7F	; 127
     e38:	80 93 e4 00 	sts	0x00E4, r24
	
	while (!(JoyStatus & JOY_UP))         // Joystick interrupt wakes the micro
	  SLEEP();
     e3c:	f6 99       	sbic	0x1e, 6	; 30
     e3e:	03 c0       	rjmp	.+6      	; 0xe46 <FUNCSleepMode+0x18>
     e40:	88 95       	sleep
     e42:	f6 9b       	sbis	0x1e, 6	; 30
     e44:	fd cf       	rjmp	.-6      	; 0xe40 <FUNCSleepMode+0x12>
	   
	LCDCRA |= (1 << LCDEN);
     e46:	80 91 e4 00 	lds	r24, 0x00E4
     e4a:	80 68       	ori	r24, 0x80	; 128
     e4c:	80 93 e4 00 	sts	0x00E4, r24
	
	MAIN_WaitForJoyRelease();
     e50:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>
     e54:	08 95       	ret

00000e56 <FUNCStorageInfo>:
}

void FUNCStorageInfo(void)
{
     e56:	1f 93       	push	r17
     e58:	cf 93       	push	r28
	uint8_t SelectedItem = 0;
     e5a:	10 e0       	ldi	r17, 0x00	; 0

	MAIN_WaitForJoyRelease();
     e5c:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>

	JoyStatus = 1;                        // Invalid value to force the LCD to update
     e60:	81 e0       	ldi	r24, 0x01	; 1
     e62:	8e bb       	out	0x1e, r24	; 30

	while (1)
	{
		if (JoyStatus)
     e64:	8e b3       	in	r24, 0x1e	; 30
     e66:	88 23       	and	r24, r24
     e68:	e9 f3       	breq	.-6      	; 0xe64 <FUNCStorageInfo+0xe>
		{
			if (JoyStatus & (JOY_UP | JOY_DOWN))
     e6a:	ce b3       	in	r28, 0x1e	; 30
     e6c:	c0 7c       	andi	r28, 0xC0	; 192
     e6e:	19 f0       	breq	.+6      	; 0xe76 <FUNCStorageInfo+0x20>
			{
				SelectedItem ^= 1;
     e70:	81 e0       	ldi	r24, 0x01	; 1
     e72:	18 27       	eor	r17, r24
     e74:	38 c0       	rjmp	.+112    	; 0xee6 <FUNCStorageInfo+0x90>
			}
			else if (JoyStatus & JOY_LEFT)
     e76:	f2 99       	sbic	0x1e, 2	; 30
     e78:	41 c0       	rjmp	.+130    	; 0xefc <FUNCStorageInfo+0xa6>
			{
				return;
			}
			else if (JoyStatus & JOY_PRESS)
     e7a:	f4 9b       	sbis	0x1e, 4	; 30
     e7c:	34 c0       	rjmp	.+104    	; 0xee6 <FUNCStorageInfo+0x90>
			{
				if (SelectedItem == 1)    // View storage tags
     e7e:	11 30       	cpi	r17, 0x01	; 1
     e80:	81 f5       	brne	.+96     	; 0xee2 <FUNCStorageInfo+0x8c>
				{
					DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
     e82:	83 e4       	ldi	r24, 0x43	; 67
     e84:	99 e0       	ldi	r25, 0x09	; 9
     e86:	90 93 01 01 	sts	0x0101, r25
     e8a:	80 93 00 01 	sts	0x0100, r24
					SPI_SPIInit();
     e8e:	0e 94 39 09 	call	0x1272 <SPI_SPIInit>
					UseExernalDF = FALSE;
     e92:	c0 93 65 02 	sts	0x0265, r28
					DF_EnableDataflash(TRUE);
     e96:	81 2f       	mov	r24, r17
     e98:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>

					if (DF_CheckCorrectOnboardChip())
     e9c:	0e 94 47 0b 	call	0x168e <DF_CheckCorrectOnboardChip>
     ea0:	c8 2f       	mov	r28, r24
     ea2:	88 23       	and	r24, r24
     ea4:	41 f0       	breq	.+16     	; 0xeb6 <FUNCStorageInfo+0x60>
					{
						TM_ShowTags();
     ea6:	0e 94 f7 19 	call	0x33ee <TM_ShowTags>
						SPI_SPIOFF();
     eaa:	80 91 64 00 	lds	r24, 0x0064
     eae:	84 60       	ori	r24, 0x04	; 4
     eb0:	80 93 64 00 	sts	0x0064, r24
     eb4:	18 c0       	rjmp	.+48     	; 0xee6 <FUNCStorageInfo+0x90>
					}
					else if (!(PM_GetStoredDataSize(TYPE_FLASH)))
     eb6:	81 2f       	mov	r24, r17
     eb8:	0e 94 ed 13 	call	0x27da <PM_GetStoredDataSize>
     ebc:	dc 01       	movw	r26, r24
     ebe:	cb 01       	movw	r24, r22
     ec0:	00 97       	sbiw	r24, 0x00	; 0
     ec2:	a1 05       	cpc	r26, r1
     ec4:	b1 05       	cpc	r27, r1
     ec6:	79 f4       	brne	.+30     	; 0xee6 <FUNCStorageInfo+0x90>
					{
						DF_EnableDataflash(FALSE);
     ec8:	8c 2f       	mov	r24, r28
     eca:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
						SPI_SPIOFF();
     ece:	80 91 64 00 	lds	r24, 0x0064
     ed2:	84 60       	ori	r24, 0x04	; 4
     ed4:	80 93 64 00 	sts	0x0064, r24

						MAIN_ShowError(PSTR("NO STORED PRGM"));
     ed8:	89 ef       	ldi	r24, 0xF9	; 249
     eda:	92 e0       	ldi	r25, 0x02	; 2
     edc:	0e 94 6f 03 	call	0x6de <MAIN_ShowError>
     ee0:	02 c0       	rjmp	.+4      	; 0xee6 <FUNCStorageInfo+0x90>
					}	
				}
				else                      // View stored data sizes
				{
					PM_ShowStoredItemSizes();
     ee2:	0e 94 d2 18 	call	0x31a4 <PM_ShowStoredItemSizes>
				}
			}
			
			LCD_puts_f(SIFONames[SelectedItem]);
     ee6:	8f e0       	ldi	r24, 0x0F	; 15
     ee8:	18 9f       	mul	r17, r24
     eea:	c0 01       	movw	r24, r0
     eec:	11 24       	eor	r1, r1
     eee:	84 5a       	subi	r24, 0xA4	; 164
     ef0:	9f 4f       	sbci	r25, 0xFF	; 255
     ef2:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     ef6:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>
     efa:	b4 cf       	rjmp	.-152    	; 0xe64 <FUNCStorageInfo+0xe>
     efc:	cf 91       	pop	r28
     efe:	1f 91       	pop	r17
     f00:	08 95       	ret

00000f02 <FUNCGoBootloader>:
		}
	}
}

void FUNCGoBootloader(void)
{
	uint8_t MD = (MCUCR & ~(1 << JTD));   // Forces compiler to use IN, AND plus two OUTs rather than two lots of IN/AND/OUTs
     f02:	85 b7       	in	r24, 0x35	; 53
     f04:	8f 77       	andi	r24, 0x7F	; 127
	MCUCR = MD;                           // Turn on JTAG via code
     f06:	85 bf       	out	0x35, r24	; 53
	MCUCR = MD;                           // Set bit twice as specified in datasheet        
     f08:	85 bf       	out	0x35, r24	; 53

	TIMEOUT_SLEEP_TIMER_OFF();
     f0a:	10 92 81 00 	sts	0x0081, r1
	
	LCD_puts_f(PSTR("*JTAG ON*"));
     f0e:	88 e0       	ldi	r24, 0x08	; 8
     f10:	93 e0       	ldi	r25, 0x03	; 3
     f12:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>
	
	MAIN_WaitForJoyRelease();
     f16:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>
	
	WDTCR = ((1<<WDCE) | (1<<WDE));       // Enable Watchdog Timer to give reset after minimum timeout
     f1a:	88 e1       	ldi	r24, 0x18	; 24
     f1c:	80 93 60 00 	sts	0x0060, r24
	while (1) {};                        // Eternal loop - when watchdog resets the AVR it will enter the bootloader
     f20:	ff cf       	rjmp	.-2      	; 0xf20 <FUNCGoBootloader+0x1e>

00000f22 <OSCCAL_Calibrate>:

static volatile uint16_t ActualCount;

void OSCCAL_Calibrate(void)
{
     f22:	cf 93       	push	r28
     f24:	df 93       	push	r29
	uint8_t SREG_Backup;
	uint8_t LoopCount = (0x7F / 2); // Maximum range is 128, and starts from the middle, so 64 is the max number of iterations required
     f26:	4f e3       	ldi	r20, 0x3F	; 63
	uint8_t PrevOSCALValues[2];
   
	// Reset ActualCount
	ActualCount = 0;
     f28:	10 92 05 01 	sts	0x0105, r1
     f2c:	10 92 04 01 	sts	0x0104, r1
   
	// Make sure all clock division is turned off (8Mhz RC clock)
	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_CLOCKSPEED_8MHZ);
     f30:	80 e8       	ldi	r24, 0x80	; 128
     f32:	80 93 61 00 	sts	0x0061, r24
     f36:	10 92 61 00 	sts	0x0061, r1

	// Inital OSCCAL of half its maximum
	OSCCAL = (0x7F / 2);
     f3a:	40 93 66 00 	sts	0x0066, r20

	// Save the SREG
	SREG_Backup = SREG;
     f3e:	5f b7       	in	r21, 0x3f	; 63
    
	// Disable all timer 1 interrupts
	TIMSK1 = 0;
     f40:	10 92 6f 00 	sts	0x006F, r1
        
	// Set timer 2 to asyncronous mode (32.768KHz crystal)
	ASSR   = (1 << AS2);
     f44:	88 e0       	ldi	r24, 0x08	; 8
     f46:	80 93 b6 00 	sts	0x00B6, r24
        
	// Timer 2 overflow interrupt enable
	TIMSK2 = (1 << TOIE2);
     f4a:	81 e0       	ldi	r24, 0x01	; 1
     f4c:	80 93 70 00 	sts	0x0070, r24

	// Enable interrupts
	sei();
     f50:	78 94       	sei

	// Start both counters with no prescaling
	TCCR1B = (1 << CS10);
     f52:	80 93 81 00 	sts	0x0081, r24
	TCCR2A = (1 << CS20);
     f56:	80 93 b0 00 	sts	0x00B0, r24
	 	 
	// Previous OSCCAL value of 0
	PrevOSCALValues[0] = 0;
     f5a:	20 e0       	ldi	r18, 0x00	; 0
     f5c:	30 e0       	ldi	r19, 0x00	; 0

	// Wait until timer 2's external 32.768KHz crystal is stable
	while (ASSR & ((1 << TCN2UB) | (1 << TCR2UB) | (1 << OCR2UB)));
     f5e:	80 91 b6 00 	lds	r24, 0x00B6
     f62:	99 27       	eor	r25, r25
     f64:	87 70       	andi	r24, 0x07	; 7
     f66:	90 70       	andi	r25, 0x00	; 0
     f68:	00 97       	sbiw	r24, 0x00	; 0
     f6a:	c9 f7       	brne	.-14     	; 0xf5e <OSCCAL_Calibrate+0x3c>
    
	// Clear the timer values
	TCNT1  = 0;
     f6c:	90 93 85 00 	sts	0x0085, r25
     f70:	80 93 84 00 	sts	0x0084, r24
	TCNT2  = 0;
     f74:	10 92 b2 00 	sts	0x00B2, r1
    
	while (LoopCount--)
	{
		// Let it take a few readings (14ms, approx 2 readings)
		_delay_ms(14);

		PrevOSCALValues[1] = PrevOSCALValues[0];
		PrevOSCALValues[0] = OSCCAL;
        
		if (ActualCount > OSCCAL_UPPERCOUNTBOUND)       // Clock is running too fast
			OSCCAL--;
		else if (ActualCount < OSCCAL_LOWERCOUNTBOUND) // Clock is running too slow
			OSCCAL++;
		else		                                     // Clock is just right
			break;
		
		// If the routine cannot find a value withing the count tollerance,
		// it will cause the OSCCAL to hover around the closest two values.
		// If the current value is the same as the 2*n previous, exit the
		// routine as the best value has been found.
		if (OSCCAL == PrevOSCALValues[1])
		  break;
     f78:	4e e3       	ldi	r20, 0x3E	; 62
     f7a:	ac ec       	ldi	r26, 0xCC	; 204
     f7c:	b4 e6       	ldi	r27, 0x64	; 100
     f7e:	c0 e0       	ldi	r28, 0x00	; 0
     f80:	d0 e0       	ldi	r29, 0x00	; 0
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     f82:	cd 01       	movw	r24, r26
     f84:	01 97       	sbiw	r24, 0x01	; 1
     f86:	f1 f7       	brne	.-4      	; 0xf84 <OSCCAL_Calibrate+0x62>
     f88:	32 2f       	mov	r19, r18
     f8a:	80 91 66 00 	lds	r24, 0x0066
     f8e:	28 2f       	mov	r18, r24
     f90:	80 91 04 01 	lds	r24, 0x0104
     f94:	90 91 05 01 	lds	r25, 0x0105
     f98:	81 50       	subi	r24, 0x01	; 1
     f9a:	91 4e       	sbci	r25, 0xE1	; 225
     f9c:	20 f0       	brcs	.+8      	; 0xfa6 <OSCCAL_Calibrate+0x84>
     f9e:	80 91 66 00 	lds	r24, 0x0066
     fa2:	81 50       	subi	r24, 0x01	; 1
     fa4:	0a c0       	rjmp	.+20     	; 0xfba <OSCCAL_Calibrate+0x98>
     fa6:	80 91 04 01 	lds	r24, 0x0104
     faa:	90 91 05 01 	lds	r25, 0x0105
     fae:	86 5f       	subi	r24, 0xF6	; 246
     fb0:	90 4e       	sbci	r25, 0xE0	; 224
     fb2:	58 f4       	brcc	.+22     	; 0xfca <OSCCAL_Calibrate+0xa8>
     fb4:	80 91 66 00 	lds	r24, 0x0066
     fb8:	8f 5f       	subi	r24, 0xFF	; 255
     fba:	80 93 66 00 	sts	0x0066, r24
     fbe:	80 91 66 00 	lds	r24, 0x0066
     fc2:	83 17       	cp	r24, r19
     fc4:	11 f0       	breq	.+4      	; 0xfca <OSCCAL_Calibrate+0xa8>
     fc6:	41 50       	subi	r20, 0x01	; 1
     fc8:	e0 f6       	brcc	.-72     	; 0xf82 <OSCCAL_Calibrate+0x60>
	}

	// Disable all timer interrupts
	TIMSK1 = 0;
     fca:	10 92 6f 00 	sts	0x006F, r1
	TIMSK2 = 0;
     fce:	10 92 70 00 	sts	0x0070, r1
    
	// Stop the timers
	TCCR1B = 0x00;
     fd2:	10 92 81 00 	sts	0x0081, r1
	TCCR2A = 0x00;
     fd6:	10 92 b0 00 	sts	0x00B0, r1

	// Turn off timer 2 asynchronous mode
	ASSR  &= ~(1 << AS2);
     fda:	80 91 b6 00 	lds	r24, 0x00B6
     fde:	87 7f       	andi	r24, 0xF7	; 247
     fe0:	80 93 b6 00 	sts	0x00B6, r24

	// Restore SREG
	SREG = SREG_Backup;
     fe4:	5f bf       	out	0x3f, r21	; 63
     fe6:	df 91       	pop	r29
     fe8:	cf 91       	pop	r28
     fea:	08 95       	ret

00000fec <__vector_5>:
        
	return;
}

ISR(TIMER2_OVF_vect, ISR_BLOCK) // Occurs 32768/256 timers per second, or 128Hz
{
     fec:	1f 92       	push	r1
     fee:	0f 92       	push	r0
     ff0:	0f b6       	in	r0, 0x3f	; 63
     ff2:	0f 92       	push	r0
     ff4:	11 24       	eor	r1, r1
     ff6:	8f 93       	push	r24
     ff8:	9f 93       	push	r25
	// Stop timer 1 so it can be read
	TCCR1B = 0x00;
     ffa:	10 92 81 00 	sts	0x0081, r1
    
	// Record timer 1's value
	ActualCount = TCNT1;
     ffe:	80 91 84 00 	lds	r24, 0x0084
    1002:	90 91 85 00 	lds	r25, 0x0085
    1006:	90 93 05 01 	sts	0x0105, r25
    100a:	80 93 04 01 	sts	0x0104, r24
	     
	// Reset counters and restart timer 1
	TCNT1  = 0;
    100e:	10 92 85 00 	sts	0x0085, r1
    1012:	10 92 84 00 	sts	0x0084, r1
	TCNT2  = 0;
    1016:	10 92 b2 00 	sts	0x00B2, r1
	TCCR1B = (1 << CS10);
    101a:	81 e0       	ldi	r24, 0x01	; 1
    101c:	80 93 81 00 	sts	0x0081, r24
    1020:	9f 91       	pop	r25
    1022:	8f 91       	pop	r24
    1024:	0f 90       	pop	r0
    1026:	0f be       	out	0x3f, r0	; 63
    1028:	0f 90       	pop	r0
    102a:	1f 90       	pop	r1
    102c:	18 95       	reti

0000102e <LCD_Init>:

void LCD_Init(void)
{
	// Set the initial contrast level to maximum:
	LCDCCR = 0x0F;
    102e:	8f e0       	ldi	r24, 0x0F	; 15
    1030:	80 93 e7 00 	sts	0x00E7, r24

    // Select asynchronous clock source, enable all COM pins and enable all segment pins:
    LCDCRB  = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
    1034:	87 eb       	ldi	r24, 0xB7	; 183
    1036:	80 93 e5 00 	sts	0x00E5, r24

    // Set LCD prescaler to give a framerate of 32Hz:
    LCDFRR  = (7<<LCDCD0);    
    103a:	87 e0       	ldi	r24, 0x07	; 7
    103c:	80 93 e6 00 	sts	0x00E6, r24

	// Enable LCD and set low power waveform, enable start of frame interrupt:
    LCDCRA  = (1<<LCDEN) | (1<<LCDAB) | (1<<LCDIE);
    1040:	88 ec       	ldi	r24, 0xC8	; 200
    1042:	80 93 e4 00 	sts	0x00E4, r24
    1046:	08 95       	ret

00001048 <LCD_puts>:
}

void LCD_puts_f(const uint8_t *FlashData)
{
	uint8_t StrBuff[LCD_TEXTBUFFER_SIZE];

	strcpy_P(StrBuff, FlashData);
	LCD_puts(StrBuff);
}

void LCD_puts(const uint8_t *Data)
{
    1048:	dc 01       	movw	r26, r24
	uint8_t LoadB;
	
	for (LoadB = 0; LoadB < 20; LoadB++)
    104a:	20 e0       	ldi	r18, 0x00	; 0
    104c:	3f ef       	ldi	r19, 0xFF	; 255
    104e:	e6 e0       	ldi	r30, 0x06	; 6
    1050:	f1 e0       	ldi	r31, 0x01	; 1
	{
		uint8_t CByte = *(Data++);
    1052:	9d 91       	ld	r25, X+
	
		if ((CByte >= '*') && (CByte <= 'z') && (CByte != ' '))
    1054:	89 2f       	mov	r24, r25
    1056:	8a 52       	subi	r24, 0x2A	; 42
    1058:	81 35       	cpi	r24, 0x51	; 81
    105a:	10 f4       	brcc	.+4      	; 0x1060 <LCD_puts+0x18>
		  TextBuffer[LoadB] = (CByte - '*');
    105c:	80 83       	st	Z, r24
    105e:	03 c0       	rjmp	.+6      	; 0x1066 <LCD_puts+0x1e>
		else if (CByte == 0x00)
    1060:	99 23       	and	r25, r25
    1062:	29 f0       	breq	.+10     	; 0x106e <LCD_puts+0x26>
		  break;
		else
		  TextBuffer[LoadB] = 0xFF;		
    1064:	30 83       	st	Z, r19
    1066:	2f 5f       	subi	r18, 0xFF	; 255
    1068:	31 96       	adiw	r30, 0x01	; 1
    106a:	24 31       	cpi	r18, 0x14	; 20
    106c:	90 f3       	brcs	.-28     	; 0x1052 <LCD_puts+0xa>
	}

	ScrollMode  = ((LoadB > 6)? TRUE : FALSE);
    106e:	80 e0       	ldi	r24, 0x00	; 0
    1070:	27 30       	cpi	r18, 0x07	; 7
    1072:	08 f0       	brcs	.+2      	; 0x1076 <LCD_puts+0x2e>
    1074:	81 e0       	ldi	r24, 0x01	; 1
    1076:	80 93 37 01 	sts	0x0137, r24
	ScrollCount = 0;
    107a:	10 92 38 01 	sts	0x0138, r1
    107e:	9f ef       	ldi	r25, 0xFF	; 255
    1080:	86 e0       	ldi	r24, 0x06	; 6

	for (uint8_t Nulls = 0; Nulls < 7; Nulls++)
		TextBuffer[LoadB++] = 0xFF;
    1082:	e2 2f       	mov	r30, r18
    1084:	ff 27       	eor	r31, r31
    1086:	ea 5f       	subi	r30, 0xFA	; 250
    1088:	fe 4f       	sbci	r31, 0xFE	; 254
    108a:	90 83       	st	Z, r25
    108c:	2f 5f       	subi	r18, 0xFF	; 255
    108e:	81 50       	subi	r24, 0x01	; 1
    1090:	87 ff       	sbrs	r24, 7
    1092:	f7 cf       	rjmp	.-18     	; 0x1082 <LCD_puts+0x3a>
	
	TextBuffer[LoadB] = 0x00;
    1094:	e2 2f       	mov	r30, r18
    1096:	ff 27       	eor	r31, r31
    1098:	ea 5f       	subi	r30, 0xFA	; 250
    109a:	fe 4f       	sbci	r31, 0xFE	; 254
    109c:	10 82       	st	Z, r1
	StrStart   = 0;
    109e:	10 92 35 01 	sts	0x0135, r1
	StrEnd     = LoadB;	
    10a2:	20 93 36 01 	sts	0x0136, r18
	DelayCount = LCD_DELAYCOUNT_DEFAULT;
    10a6:	8a e0       	ldi	r24, 0x0A	; 10
    10a8:	80 93 39 01 	sts	0x0139, r24

	UpdateLCD  = TRUE;
    10ac:	81 e0       	ldi	r24, 0x01	; 1
    10ae:	80 93 3a 01 	sts	0x013A, r24
    10b2:	08 95       	ret

000010b4 <LCD_puts_f>:
    10b4:	cf 93       	push	r28
    10b6:	df 93       	push	r29
    10b8:	cd b7       	in	r28, 0x3d	; 61
    10ba:	de b7       	in	r29, 0x3e	; 62
    10bc:	64 97       	sbiw	r28, 0x14	; 20
    10be:	0f b6       	in	r0, 0x3f	; 63
    10c0:	f8 94       	cli
    10c2:	de bf       	out	0x3e, r29	; 62
    10c4:	0f be       	out	0x3f, r0	; 63
    10c6:	cd bf       	out	0x3d, r28	; 61
    10c8:	bc 01       	movw	r22, r24
    10ca:	ce 01       	movw	r24, r28
    10cc:	01 96       	adiw	r24, 0x01	; 1
    10ce:	0e 94 25 1a 	call	0x344a <strcpy_P>
    10d2:	ce 01       	movw	r24, r28
    10d4:	01 96       	adiw	r24, 0x01	; 1
    10d6:	0e 94 24 08 	call	0x1048 <LCD_puts>
    10da:	64 96       	adiw	r28, 0x14	; 20
    10dc:	0f b6       	in	r0, 0x3f	; 63
    10de:	f8 94       	cli
    10e0:	de bf       	out	0x3e, r29	; 62
    10e2:	0f be       	out	0x3f, r0	; 63
    10e4:	cd bf       	out	0x3d, r28	; 61
    10e6:	df 91       	pop	r29
    10e8:	cf 91       	pop	r28
    10ea:	08 95       	ret

000010ec <LCD_WriteChar>:
}

void LCD_WriteChar(const uint8_t Byte, const uint8_t Digit)
{
    10ec:	e8 2f       	mov	r30, r24
	uint16_t SegData  = 0x00;
    10ee:	20 e0       	ldi	r18, 0x00	; 0
    10f0:	30 e0       	ldi	r19, 0x00	; 0
	uint8_t  *BuffPtr = (&SegBuffer[0] + (Digit >> 1));
    10f2:	86 2f       	mov	r24, r22
    10f4:	86 95       	lsr	r24
    10f6:	a8 2f       	mov	r26, r24
    10f8:	bb 27       	eor	r27, r27
    10fa:	af 5d       	subi	r26, 0xDF	; 223
    10fc:	be 4f       	sbci	r27, 0xFE	; 254

	if (Byte != 0xFF)
    10fe:	ef 3f       	cpi	r30, 0xFF	; 255
    1100:	39 f0       	breq	.+14     	; 0x1110 <LCD_WriteChar+0x24>
	  SegData = pgm_read_word(&LCD_SegTable[Byte]);	
    1102:	ff 27       	eor	r31, r31
    1104:	ee 0f       	add	r30, r30
    1106:	ff 1f       	adc	r31, r31
    1108:	ee 5e       	subi	r30, 0xEE	; 238
    110a:	fc 4f       	sbci	r31, 0xFC	; 252
    110c:	25 91       	lpm	r18, Z+
    110e:	34 91       	lpm	r19, Z
    1110:	77 27       	eor	r23, r23
    1112:	61 70       	andi	r22, 0x01	; 1
    1114:	70 70       	andi	r23, 0x00	; 0
    1116:	43 e0       	ldi	r20, 0x03	; 3

	for (uint8_t BNib = 0; BNib < 4; BNib++)
	{
		uint8_t Mask          = 0xF0;
    1118:	50 ef       	ldi	r21, 0xF0	; 240
		uint8_t MaskedSegData = (SegData & 0x0000F);
    111a:	92 2f       	mov	r25, r18
    111c:	9f 70       	andi	r25, 0x0F	; 15
	
		if (Digit & 0x01)
    111e:	61 15       	cp	r22, r1
    1120:	71 05       	cpc	r23, r1
    1122:	19 f0       	breq	.+6      	; 0x112a <LCD_WriteChar+0x3e>
		{
			Mask = 0x0F;
    1124:	5f e0       	ldi	r21, 0x0F	; 15
			MaskedSegData <<= 4;
    1126:	92 95       	swap	r25
    1128:	90 7f       	andi	r25, 0xF0	; 240
		}
		
		*BuffPtr = ((*BuffPtr & Mask) | MaskedSegData);
    112a:	8c 91       	ld	r24, X
    112c:	85 23       	and	r24, r21
    112e:	89 2b       	or	r24, r25
    1130:	8c 93       	st	X, r24

		SegData >>= 4;
    1132:	84 e0       	ldi	r24, 0x04	; 4
    1134:	36 95       	lsr	r19
    1136:	27 95       	ror	r18
    1138:	8a 95       	dec	r24
    113a:	e1 f7       	brne	.-8      	; 0x1134 <LCD_WriteChar+0x48>
		BuffPtr  += 5;
    113c:	15 96       	adiw	r26, 0x05	; 5
    113e:	41 50       	subi	r20, 0x01	; 1
    1140:	47 ff       	sbrs	r20, 7
    1142:	ea cf       	rjmp	.-44     	; 0x1118 <LCD_WriteChar+0x2c>
    1144:	08 95       	ret

00001146 <__vector_22>:
	}
}

ISR(LCD_vect, ISR_NOBLOCK)
{
    1146:	78 94       	sei
    1148:	1f 92       	push	r1
    114a:	0f 92       	push	r0
    114c:	0f b6       	in	r0, 0x3f	; 63
    114e:	0f 92       	push	r0
    1150:	11 24       	eor	r1, r1
    1152:	2f 93       	push	r18
    1154:	3f 93       	push	r19
    1156:	4f 93       	push	r20
    1158:	5f 93       	push	r21
    115a:	6f 93       	push	r22
    115c:	7f 93       	push	r23
    115e:	8f 93       	push	r24
    1160:	9f 93       	push	r25
    1162:	af 93       	push	r26
    1164:	bf 93       	push	r27
    1166:	cf 93       	push	r28
    1168:	ef 93       	push	r30
    116a:	ff 93       	push	r31
	if (ScrollMode)
    116c:	80 91 37 01 	lds	r24, 0x0137
    1170:	88 23       	and	r24, r24
    1172:	99 f0       	breq	.+38     	; 0x119a <__vector_22+0x54>
	{
		if (DelayCount)
    1174:	80 91 39 01 	lds	r24, 0x0139
    1178:	88 23       	and	r24, r24
    117a:	21 f0       	breq	.+8      	; 0x1184 <__vector_22+0x3e>
		{
			DelayCount--;
    117c:	81 50       	subi	r24, 0x01	; 1
    117e:	80 93 39 01 	sts	0x0139, r24
    1182:	0b c0       	rjmp	.+22     	; 0x119a <__vector_22+0x54>
		}
		else
		{
			if (!(ScrollCount))
    1184:	80 91 38 01 	lds	r24, 0x0138
    1188:	88 23       	and	r24, r24
    118a:	21 f4       	brne	.+8      	; 0x1194 <__vector_22+0x4e>
			  UpdateLCD = TRUE;
    118c:	81 e0       	ldi	r24, 0x01	; 1
    118e:	80 93 3a 01 	sts	0x013A, r24
    1192:	03 c0       	rjmp	.+6      	; 0x119a <__vector_22+0x54>
			else
			  ScrollCount--;
    1194:	81 50       	subi	r24, 0x01	; 1
    1196:	80 93 38 01 	sts	0x0138, r24
		}
	}

	if (UpdateLCD)
    119a:	80 91 3a 01 	lds	r24, 0x013A
    119e:	88 23       	and	r24, r24
    11a0:	39 f1       	breq	.+78     	; 0x11f0 <__vector_22+0xaa>
	{
		for (uint8_t Character = 0; Character < 6; Character++)
    11a2:	c0 e0       	ldi	r28, 0x00	; 0
		{
			uint8_t Byte = (StrStart + Character);
    11a4:	80 91 35 01 	lds	r24, 0x0135
    11a8:	8c 0f       	add	r24, r28

			if (Byte >= StrEnd)
    11aa:	90 91 36 01 	lds	r25, 0x0136
    11ae:	e8 2f       	mov	r30, r24
    11b0:	ff 27       	eor	r31, r31
    11b2:	89 17       	cp	r24, r25
    11b4:	10 f0       	brcs	.+4      	; 0x11ba <__vector_22+0x74>
			  Byte = TextBuffer[Byte - StrEnd];
    11b6:	e9 1b       	sub	r30, r25
    11b8:	f1 09       	sbc	r31, r1
			else
			  Byte = TextBuffer[Byte];
    11ba:	ea 5f       	subi	r30, 0xFA	; 250
    11bc:	fe 4f       	sbci	r31, 0xFE	; 254
    11be:	80 81       	ld	r24, Z
			
			LCD_WriteChar(Byte, Character);
    11c0:	6c 2f       	mov	r22, r28
    11c2:	0e 94 76 08 	call	0x10ec <LCD_WriteChar>
    11c6:	cf 5f       	subi	r28, 0xFF	; 255
    11c8:	c6 30       	cpi	r28, 0x06	; 6
    11ca:	60 f3       	brcs	.-40     	; 0x11a4 <__vector_22+0x5e>
		}
		
		if (StrStart++ == StrEnd)
    11cc:	80 91 35 01 	lds	r24, 0x0135
    11d0:	98 2f       	mov	r25, r24
    11d2:	8f 5f       	subi	r24, 0xFF	; 255
    11d4:	80 93 35 01 	sts	0x0135, r24
    11d8:	80 91 36 01 	lds	r24, 0x0136
    11dc:	98 17       	cp	r25, r24
    11de:	19 f4       	brne	.+6      	; 0x11e6 <__vector_22+0xa0>
		  StrStart = 1;
    11e0:	81 e0       	ldi	r24, 0x01	; 1
    11e2:	80 93 35 01 	sts	0x0135, r24
		
		ScrollCount = LCD_SCROLLCOUNT_DEFAULT;
    11e6:	83 e0       	ldi	r24, 0x03	; 3
    11e8:	80 93 38 01 	sts	0x0138, r24
		UpdateLCD = FALSE;
    11ec:	10 92 3a 01 	sts	0x013A, r1
    11f0:	ac ee       	ldi	r26, 0xEC	; 236
    11f2:	b0 e0       	ldi	r27, 0x00	; 0
    11f4:	e1 e2       	ldi	r30, 0x21	; 33
    11f6:	f1 e0       	ldi	r31, 0x01	; 1
    11f8:	93 e1       	ldi	r25, 0x13	; 19
	}

	for (uint8_t LCDChar = 0; LCDChar < LCD_SEGBUFFER_SIZE; LCDChar++)
	  *(pLCDREG + LCDChar) = SegBuffer[LCDChar];
    11fa:	81 91       	ld	r24, Z+
    11fc:	8d 93       	st	X+, r24
    11fe:	91 50       	subi	r25, 0x01	; 1
    1200:	97 ff       	sbrs	r25, 7
    1202:	fb cf       	rjmp	.-10     	; 0x11fa <__vector_22+0xb4>
    1204:	ff 91       	pop	r31
    1206:	ef 91       	pop	r30
    1208:	cf 91       	pop	r28
    120a:	bf 91       	pop	r27
    120c:	af 91       	pop	r26
    120e:	9f 91       	pop	r25
    1210:	8f 91       	pop	r24
    1212:	7f 91       	pop	r23
    1214:	6f 91       	pop	r22
    1216:	5f 91       	pop	r21
    1218:	4f 91       	pop	r20
    121a:	3f 91       	pop	r19
    121c:	2f 91       	pop	r18
    121e:	0f 90       	pop	r0
    1220:	0f be       	out	0x3f, r0	; 63
    1222:	0f 90       	pop	r0
    1224:	1f 90       	pop	r1
    1226:	18 95       	reti

00001228 <USART_Init>:
*****************************************************************************/
void USART_Init(void)
{
    // Set baud rate
    UBRRH = (uint8_t)(USART_BAUDVALUE >> 8);
    1228:	10 92 c5 00 	sts	0x00C5, r1
    UBRRL = (uint8_t)(USART_BAUDVALUE);
    122c:	87 e0       	ldi	r24, 0x07	; 7
    122e:	80 93 c4 00 	sts	0x00C4, r24

    // Double speed
	UCSRA = (USART_DOUBLESPEED << U2X);
    1232:	82 e0       	ldi	r24, 0x02	; 2
    1234:	80 93 c0 00 	sts	0x00C0, r24

    // Enable recieve complete interrupt
	UCSRB = (1 << RXCIE);
    1238:	80 e8       	ldi	r24, 0x80	; 128
    123a:	80 93 c1 00 	sts	0x00C1, r24
	 
    // Async. mode, 8N1
    UCSRC = (3 << UCSZ0);
    123e:	86 e0       	ldi	r24, 0x06	; 6
    1240:	80 93 c2 00 	sts	0x00C2, r24
	 
	 // Initalise ringbuffer
	BUFF_InitialiseBuffer();
    1244:	0e 94 aa 0b 	call	0x1754 <BUFF_InitialiseBuffer>
    1248:	08 95       	ret

0000124a <USART_Tx>:
}

/*****************************************************************************
*
*   Function name : Usart_Tx
*
*   Returns :       None
*
*   Parameters :    char data: byte to send
*
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_Tx(const char data)
{
    124a:	98 2f       	mov	r25, r24
    while (!(UCSRA & (1 << UDRE)));
    124c:	80 91 c0 00 	lds	r24, 0x00C0
    1250:	85 ff       	sbrs	r24, 5
    1252:	fc cf       	rjmp	.-8      	; 0x124c <USART_Tx+0x2>
    UDR = data;
    1254:	90 93 c6 00 	sts	0x00C6, r25
    1258:	08 95       	ret

0000125a <USART_Rx>:
}

/*****************************************************************************
*
*   Function name : Usart_Rx
*
*   Returns :       char: byte received
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART
*
*****************************************************************************/
char USART_Rx(void)
{
    while (!(BuffElements) && !(PacketTimeOut)) {};
    125a:	80 91 b3 02 	lds	r24, 0x02B3
    125e:	88 23       	and	r24, r24
    1260:	21 f4       	brne	.+8      	; 0x126a <USART_Rx+0x10>
    1262:	80 91 3f 01 	lds	r24, 0x013F
    1266:	88 23       	and	r24, r24
    1268:	c1 f3       	breq	.-16     	; 0x125a <USART_Rx>
    return BUFF_GetBuffByte();
    126a:	0e 94 b7 0b 	call	0x176e <BUFF_GetBuffByte>
}
    126e:	99 27       	eor	r25, r25
    1270:	08 95       	ret

00001272 <SPI_SPIInit>:
// ======================================================================================

void SPI_SPIInit(void)
{
	PRR &= ~(1 << PRSPI);              // Enable the SPI system by clearing the power save register SPI disable bit
    1272:	80 91 64 00 	lds	r24, 0x0064
    1276:	8b 7f       	andi	r24, 0xFB	; 251
    1278:	80 93 64 00 	sts	0x0064, r24

	// Master, Sample falling edge (setup rising), Fosc/2 speed (8Mhz/2 = 4MHz)
	SPSR = (1 << SPI2X);
    127c:	81 e0       	ldi	r24, 0x01	; 1
    127e:	8d bd       	out	0x2d, r24	; 45
	SPCR = ((1 << SPE) | (1 << MSTR) | (1 << CPHA) | (1 << CPOL));
    1280:	8c e5       	ldi	r24, 0x5C	; 92
    1282:	8c bd       	out	0x2c, r24	; 44
    1284:	08 95       	ret

00001286 <SPI_SPITransmit>:
}

uint8_t SPI_SPITransmit(const uint8_t Data)
{
	SPDR = Data;                       // Loading a byte into the register starts the transmission
    1286:	8e bd       	out	0x2e, r24	; 46
	while (!(SPSR & (1 << SPIF)));    // Wait until transmission completed
    1288:	0d b4       	in	r0, 0x2d	; 45
    128a:	07 fe       	sbrs	r0, 7
    128c:	fd cf       	rjmp	.-6      	; 0x1288 <SPI_SPITransmit+0x2>
	return SPDR;
    128e:	8e b5       	in	r24, 0x2e	; 46
}
    1290:	99 27       	eor	r25, r25
    1292:	08 95       	ret

00001294 <SPI_SPITransmitWord>:

uint8_t SPI_SPITransmitWord(const uint16_t Data)
{
    1294:	0f 93       	push	r16
    1296:	1f 93       	push	r17
    1298:	8c 01       	movw	r16, r24
	SPI_SPITransmit((uint8_t)(Data >> 8));
    129a:	81 2f       	mov	r24, r17
    129c:	99 27       	eor	r25, r25
    129e:	0e 94 43 09 	call	0x1286 <SPI_SPITransmit>
	return SPI_SPITransmit((uint8_t)Data);
    12a2:	80 2f       	mov	r24, r16
    12a4:	0e 94 43 09 	call	0x1286 <SPI_SPITransmit>
}
    12a8:	99 27       	eor	r25, r25
    12aa:	1f 91       	pop	r17
    12ac:	0f 91       	pop	r16
    12ae:	08 95       	ret

000012b0 <__vector_17>:
 *  have to stop the timer tick.
 *  For all modes the USIDR contents are stored and flags are updated.
 */
ISR(USI_OVERFLOW_vect, ISR_BLOCK)
{
    12b0:	1f 92       	push	r1
    12b2:	0f 92       	push	r0
    12b4:	0f b6       	in	r0, 0x3f	; 63
    12b6:	0f 92       	push	r0
    12b8:	11 24       	eor	r1, r1
    12ba:	8f 93       	push	r24
	// Master must now disable the compare match interrupt
	// to prevent more USI counter clocks.
	TIMSK0 &= ~(1<<OCIE0A);
    12bc:	80 91 6e 00 	lds	r24, 0x006E
    12c0:	8d 7f       	andi	r24, 0xFD	; 253
    12c2:	80 93 6e 00 	sts	0x006E, r24
	
	// Update flags and clear USI counter
	USISR = (1<<USIOIF);
    12c6:	80 e4       	ldi	r24, 0x40	; 64
    12c8:	80 93 b9 00 	sts	0x00B9, r24
	TransferComplete = 1;
    12cc:	81 e0       	ldi	r24, 0x01	; 1
    12ce:	80 93 63 02 	sts	0x0263, r24

	// Copy USIDR to buffer to prevent overwrite on next transfer.
	storedUSIDR = USIDR;
    12d2:	80 91 ba 00 	lds	r24, 0x00BA
    12d6:	80 93 64 02 	sts	0x0264, r24
    12da:	8f 91       	pop	r24
    12dc:	0f 90       	pop	r0
    12de:	0f be       	out	0x3f, r0	; 63
    12e0:	0f 90       	pop	r0
    12e2:	1f 90       	pop	r1
    12e4:	18 95       	reti

000012e6 <USI_SPISetSpeed>:
}



/*! \brief  Initialize USI as SPI master.
 *
 *  This function sets up all pin directions and module configurations.
 *  Use this function initially or when changing from slave to master mode.
 *  Note that the stored USIDR value is cleared.
 *
 */
void USI_SPIInitMaster(const uint8_t Freq)
{
	// Configure port directions.
 	USI_DIR_REG |= (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN);  // Outputs.
	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN);                       // Inputs.
	USI_OUT_REG |= (1<<USI_DATAIN_PIN);                        // Pull-ups.
	USI_OUT_REG &= ~(1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN); // Pull-ups.
	
	// Configure USI to 3-wire master mode with overflow interrupt.
	USICR = USI_CONTROL_REG_FLAGS;

	// Set the compare and prescaler for the requested frequency:
	USI_SPISetSpeed(Freq);
	
	// Init driver status register.
	TransferComplete = 0;
	
	storedUSIDR = 0;
}

void USI_SPIOff(void)
{
	USI_DIR_REG &= ~((1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN));                        // Inputs.
	USI_OUT_REG &= ~((1<<USI_DATAIN_PIN)  | (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN)); // Pull-ups.
	DDRF  &= ~(1 << 6);
	PORTF &= ~(1 << 6);
	
	USI_STOPUSITIMER();
}

/*! \brief  Put one byte on bus.
 *
 *  Use this function like you would write to the SPDR register in the native SPI module.
 *  Calling this function in master mode starts a transfer, while in slave mode, a
 *  byte will be prepared for the next transfer initiated by the master device.
 *  If a transfer is in progress, this function will set the write collision flag
 *  and return without altering the data registers.
 *
 *  \returns  Value returned by slave.
 */
uint8_t USI_SPITransmit(uint8_t val)
{
	// Reinit flags.
	TransferComplete = 0;

	// Put data in USI data register.
	USIDR = val;
	
	TIFR0  |= (1<<OCF0A);  // Clear compare match flag.
	TIMSK0 |= (1<<OCIE0A); // Enable compare match interrupt.

	// Clear the timer 0 value
	TCNT0 = 0;

	while (!(TransferComplete));

	return storedUSIDR;
}

uint8_t USI_SPITransmitWord(const uint16_t val )
{
	USI_SPITransmit((uint8_t)(val >> 8));
	return USI_SPITransmit((uint8_t)val);
}

void USI_SPIToggleClock(void)
{
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);	
}

void USI_SPISetSpeed(const uint8_t Freq)
{
    12e6:	48 2f       	mov	r20, r24
	for (uint8_t MatchIndex = 0; MatchIndex < USI_PRESET_SPEEDS; MatchIndex++)
    12e8:	90 e0       	ldi	r25, 0x00	; 0
    12ea:	6f e7       	ldi	r22, 0x7F	; 127
    12ec:	73 e0       	ldi	r23, 0x03	; 3
    12ee:	9b 01       	movw	r18, r22
    12f0:	21 50       	subi	r18, 0x01	; 1
    12f2:	30 40       	sbci	r19, 0x00	; 0
	{
		if ((pgm_read_byte(&USIPSValues[MatchIndex][0]) == Freq) || (MatchIndex == (USI_PRESET_SPEEDS - 1)))
    12f4:	f9 01       	movw	r30, r18
    12f6:	84 91       	lpm	r24, Z
    12f8:	84 17       	cp	r24, r20
    12fa:	11 f0       	breq	.+4      	; 0x1300 <USI_SPISetSpeed+0x1a>
    12fc:	93 30       	cpi	r25, 0x03	; 3
    12fe:	31 f4       	brne	.+12     	; 0x130c <USI_SPISetSpeed+0x26>
		{
			// Init Output Compare Register.
			OCR0A = pgm_read_byte(&USIPSValues[MatchIndex][1]);
    1300:	fb 01       	movw	r30, r22
    1302:	84 91       	lpm	r24, Z
    1304:	87 bd       	out	0x27, r24	; 39

			// Enable 'Clear Timer on Compare match' and set prescaler, which starts the timer
			TCCR0A = ((1<<WGM01) | TC0_PS_1);
    1306:	89 e0       	ldi	r24, 0x09	; 9
    1308:	84 bd       	out	0x24, r24	; 36
				
			return;
    130a:	08 95       	ret
    130c:	9f 5f       	subi	r25, 0xFF	; 255
    130e:	2e 5f       	subi	r18, 0xFE	; 254
    1310:	3f 4f       	sbci	r19, 0xFF	; 255
    1312:	6e 5f       	subi	r22, 0xFE	; 254
    1314:	7f 4f       	sbci	r23, 0xFF	; 255
    1316:	94 30       	cpi	r25, 0x04	; 4
    1318:	68 f3       	brcs	.-38     	; 0x12f4 <USI_SPISetSpeed+0xe>
    131a:	08 95       	ret

0000131c <USI_SPIInitMaster>:
    131c:	9d b1       	in	r25, 0x0d	; 13
    131e:	90 65       	ori	r25, 0x50	; 80
    1320:	9d b9       	out	0x0d, r25	; 13
    1322:	6d 98       	cbi	0x0d, 5	; 13
    1324:	75 9a       	sbi	0x0e, 5	; 14
    1326:	76 98       	cbi	0x0e, 6	; 14
    1328:	9a e5       	ldi	r25, 0x5A	; 90
    132a:	90 93 b8 00 	sts	0x00B8, r25
    132e:	0e 94 73 09 	call	0x12e6 <USI_SPISetSpeed>
    1332:	10 92 63 02 	sts	0x0263, r1
    1336:	10 92 64 02 	sts	0x0264, r1
    133a:	08 95       	ret

0000133c <USI_SPIOff>:
    133c:	8d b1       	in	r24, 0x0d	; 13
    133e:	8f 7a       	andi	r24, 0xAF	; 175
    1340:	8d b9       	out	0x0d, r24	; 13
    1342:	8e b1       	in	r24, 0x0e	; 14
    1344:	8f 78       	andi	r24, 0x8F	; 143
    1346:	8e b9       	out	0x0e, r24	; 14
    1348:	86 98       	cbi	0x10, 6	; 16
    134a:	8e 98       	cbi	0x11, 6	; 17
    134c:	14 bc       	out	0x24, r1	; 36
    134e:	08 95       	ret

00001350 <USI_SPITransmit>:
    1350:	10 92 63 02 	sts	0x0263, r1
    1354:	80 93 ba 00 	sts	0x00BA, r24
    1358:	a9 9a       	sbi	0x15, 1	; 21
    135a:	80 91 6e 00 	lds	r24, 0x006E
    135e:	82 60       	ori	r24, 0x02	; 2
    1360:	80 93 6e 00 	sts	0x006E, r24
    1364:	16 bc       	out	0x26, r1	; 38
    1366:	80 91 63 02 	lds	r24, 0x0263
    136a:	88 23       	and	r24, r24
    136c:	e1 f3       	breq	.-8      	; 0x1366 <USI_SPITransmit+0x16>
    136e:	80 91 64 02 	lds	r24, 0x0264
    1372:	99 27       	eor	r25, r25
    1374:	08 95       	ret

00001376 <USI_SPITransmitWord>:
    1376:	0f 93       	push	r16
    1378:	1f 93       	push	r17
    137a:	8c 01       	movw	r16, r24
    137c:	81 2f       	mov	r24, r17
    137e:	99 27       	eor	r25, r25
    1380:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    1384:	80 2f       	mov	r24, r16
    1386:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    138a:	99 27       	eor	r25, r25
    138c:	1f 91       	pop	r17
    138e:	0f 91       	pop	r16
    1390:	08 95       	ret

00001392 <USI_SPIToggleClock>:
    1392:	81 e0       	ldi	r24, 0x01	; 1
    1394:	0e 94 08 03 	call	0x610 <MAIN_Delay1MS>
    1398:	80 91 b8 00 	lds	r24, 0x00B8
    139c:	81 60       	ori	r24, 0x01	; 1
    139e:	80 93 b8 00 	sts	0x00B8, r24
    13a2:	81 e0       	ldi	r24, 0x01	; 1
    13a4:	0e 94 08 03 	call	0x610 <MAIN_Delay1MS>
    13a8:	80 91 b8 00 	lds	r24, 0x00B8
    13ac:	81 60       	ori	r24, 0x01	; 1
    13ae:	80 93 b8 00 	sts	0x00B8, r24
    13b2:	81 e0       	ldi	r24, 0x01	; 1
    13b4:	0e 94 08 03 	call	0x610 <MAIN_Delay1MS>
    13b8:	08 95       	ret

000013ba <DF_EnableDataflash>:
	DF_WaitWhileBusy();
}

void DF_EnableDataflash(const uint8_t Enabled)
{
    13ba:	90 91 65 02 	lds	r25, 0x0265
	if (Enabled == TRUE)
    13be:	81 30       	cpi	r24, 0x01	; 1
    13c0:	31 f4       	brne	.+12     	; 0x13ce <DF_EnableDataflash+0x14>
	{
		if (UseExernalDF == TRUE)
    13c2:	91 30       	cpi	r25, 0x01	; 1
    13c4:	11 f4       	brne	.+4      	; 0x13ca <DF_EnableDataflash+0x10>
		  MAIN_ResetCSLine(MAIN_RESETCS_EXTDFACTIVE);
    13c6:	82 e0       	ldi	r24, 0x02	; 2
    13c8:	05 c0       	rjmp	.+10     	; 0x13d4 <DF_EnableDataflash+0x1a>
		else
		  PORTB &= ~(1 << 0);
    13ca:	28 98       	cbi	0x05, 0	; 5
    13cc:	08 95       	ret
	}
	else
	{
		if (UseExernalDF == TRUE)
    13ce:	91 30       	cpi	r25, 0x01	; 1
    13d0:	21 f4       	brne	.+8      	; 0x13da <DF_EnableDataflash+0x20>
		  MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);
    13d2:	89 2f       	mov	r24, r25
    13d4:	0e 94 1a 03 	call	0x634 <MAIN_ResetCSLine>
    13d8:	08 95       	ret
		else
		  PORTB |= (1 << 0);
    13da:	28 9a       	sbi	0x05, 0	; 5
    13dc:	08 95       	ret

000013de <DF_ReadBufferByte>:
    13de:	ef 92       	push	r14
    13e0:	ff 92       	push	r15
    13e2:	0f 93       	push	r16
    13e4:	1f 93       	push	r17
    13e6:	7c 01       	movw	r14, r24
    13e8:	00 91 00 01 	lds	r16, 0x0100
    13ec:	10 91 01 01 	lds	r17, 0x0101
    13f0:	80 e0       	ldi	r24, 0x00	; 0
    13f2:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    13f6:	81 e0       	ldi	r24, 0x01	; 1
    13f8:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    13fc:	84 e5       	ldi	r24, 0x54	; 84
    13fe:	f8 01       	movw	r30, r16
    1400:	09 95       	icall
    1402:	8f 2d       	mov	r24, r15
    1404:	99 27       	eor	r25, r25
    1406:	f8 01       	movw	r30, r16
    1408:	09 95       	icall
    140a:	8e 2d       	mov	r24, r14
    140c:	f8 01       	movw	r30, r16
    140e:	09 95       	icall
    1410:	80 e0       	ldi	r24, 0x00	; 0
    1412:	f8 01       	movw	r30, r16
    1414:	09 95       	icall
    1416:	80 e0       	ldi	r24, 0x00	; 0
    1418:	f8 01       	movw	r30, r16
    141a:	09 95       	icall
    141c:	99 27       	eor	r25, r25
    141e:	1f 91       	pop	r17
    1420:	0f 91       	pop	r16
    1422:	ff 90       	pop	r15
    1424:	ef 90       	pop	r14
    1426:	08 95       	ret

00001428 <DF_ContinuousReadEnable>:
    1428:	ef 92       	push	r14
    142a:	ff 92       	push	r15
    142c:	0f 93       	push	r16
    142e:	1f 93       	push	r17
    1430:	cf 93       	push	r28
    1432:	df 93       	push	r29
    1434:	8c 01       	movw	r16, r24
    1436:	7b 01       	movw	r14, r22
    1438:	c0 91 00 01 	lds	r28, 0x0100
    143c:	d0 91 01 01 	lds	r29, 0x0101
    1440:	80 e0       	ldi	r24, 0x00	; 0
    1442:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    1446:	81 e0       	ldi	r24, 0x01	; 1
    1448:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    144c:	88 e6       	ldi	r24, 0x68	; 104
    144e:	fe 01       	movw	r30, r28
    1450:	09 95       	icall
    1452:	8a b5       	in	r24, 0x2a	; 42
    1454:	98 01       	movw	r18, r16
    1456:	02 c0       	rjmp	.+4      	; 0x145c <DF_ContinuousReadEnable+0x34>
    1458:	36 95       	lsr	r19
    145a:	27 95       	ror	r18
    145c:	8a 95       	dec	r24
    145e:	e2 f7       	brpl	.-8      	; 0x1458 <DF_ContinuousReadEnable+0x30>
    1460:	c9 01       	movw	r24, r18
    1462:	fe 01       	movw	r30, r28
    1464:	09 95       	icall
    1466:	8b b5       	in	r24, 0x2b	; 43
    1468:	98 01       	movw	r18, r16
    146a:	02 c0       	rjmp	.+4      	; 0x1470 <DF_ContinuousReadEnable+0x48>
    146c:	22 0f       	add	r18, r18
    146e:	33 1f       	adc	r19, r19
    1470:	8a 95       	dec	r24
    1472:	e2 f7       	brpl	.-8      	; 0x146c <DF_ContinuousReadEnable+0x44>
    1474:	8f 2d       	mov	r24, r15
    1476:	99 27       	eor	r25, r25
    1478:	82 0f       	add	r24, r18
    147a:	fe 01       	movw	r30, r28
    147c:	09 95       	icall
    147e:	8e 2d       	mov	r24, r14
    1480:	fe 01       	movw	r30, r28
    1482:	09 95       	icall
    1484:	03 e0       	ldi	r16, 0x03	; 3
    1486:	80 e0       	ldi	r24, 0x00	; 0
    1488:	fe 01       	movw	r30, r28
    148a:	09 95       	icall
    148c:	01 50       	subi	r16, 0x01	; 1
    148e:	07 ff       	sbrs	r16, 7
    1490:	fa cf       	rjmp	.-12     	; 0x1486 <DF_ContinuousReadEnable+0x5e>
    1492:	df 91       	pop	r29
    1494:	cf 91       	pop	r28
    1496:	1f 91       	pop	r17
    1498:	0f 91       	pop	r16
    149a:	ff 90       	pop	r15
    149c:	ef 90       	pop	r14
    149e:	08 95       	ret

000014a0 <DF_BufferWriteEnable>:
    14a0:	ef 92       	push	r14
    14a2:	ff 92       	push	r15
    14a4:	0f 93       	push	r16
    14a6:	1f 93       	push	r17
    14a8:	7c 01       	movw	r14, r24
    14aa:	00 91 00 01 	lds	r16, 0x0100
    14ae:	10 91 01 01 	lds	r17, 0x0101
    14b2:	80 e0       	ldi	r24, 0x00	; 0
    14b4:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    14b8:	81 e0       	ldi	r24, 0x01	; 1
    14ba:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    14be:	84 e8       	ldi	r24, 0x84	; 132
    14c0:	f8 01       	movw	r30, r16
    14c2:	09 95       	icall
    14c4:	80 e0       	ldi	r24, 0x00	; 0
    14c6:	f8 01       	movw	r30, r16
    14c8:	09 95       	icall
    14ca:	8f 2d       	mov	r24, r15
    14cc:	99 27       	eor	r25, r25
    14ce:	f8 01       	movw	r30, r16
    14d0:	09 95       	icall
    14d2:	8e 2d       	mov	r24, r14
    14d4:	f8 01       	movw	r30, r16
    14d6:	09 95       	icall
    14d8:	1f 91       	pop	r17
    14da:	0f 91       	pop	r16
    14dc:	ff 90       	pop	r15
    14de:	ef 90       	pop	r14
    14e0:	08 95       	ret

000014e2 <DF_WaitWhileBusy>:
    14e2:	cf 93       	push	r28
    14e4:	df 93       	push	r29
    14e6:	c0 91 00 01 	lds	r28, 0x0100
    14ea:	d0 91 01 01 	lds	r29, 0x0101
    14ee:	80 e0       	ldi	r24, 0x00	; 0
    14f0:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    14f4:	81 e0       	ldi	r24, 0x01	; 1
    14f6:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    14fa:	87 e5       	ldi	r24, 0x57	; 87
    14fc:	fe 01       	movw	r30, r28
    14fe:	09 95       	icall
    1500:	80 e0       	ldi	r24, 0x00	; 0
    1502:	fe 01       	movw	r30, r28
    1504:	09 95       	icall
    1506:	88 23       	and	r24, r24
    1508:	dc f7       	brge	.-10     	; 0x1500 <DF_WaitWhileBusy+0x1e>
    150a:	df 91       	pop	r29
    150c:	cf 91       	pop	r28
    150e:	08 95       	ret

00001510 <DF_EraseBlock>:
    1510:	ef 92       	push	r14
    1512:	ff 92       	push	r15
    1514:	0f 93       	push	r16
    1516:	1f 93       	push	r17
    1518:	7c 01       	movw	r14, r24
    151a:	00 91 00 01 	lds	r16, 0x0100
    151e:	10 91 01 01 	lds	r17, 0x0101
    1522:	80 e0       	ldi	r24, 0x00	; 0
    1524:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    1528:	81 e0       	ldi	r24, 0x01	; 1
    152a:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    152e:	80 e5       	ldi	r24, 0x50	; 80
    1530:	f8 01       	movw	r30, r16
    1532:	09 95       	icall
    1534:	8f 2d       	mov	r24, r15
    1536:	99 27       	eor	r25, r25
    1538:	f8 01       	movw	r30, r16
    153a:	09 95       	icall
    153c:	8e 2d       	mov	r24, r14
    153e:	f8 01       	movw	r30, r16
    1540:	09 95       	icall
    1542:	80 e0       	ldi	r24, 0x00	; 0
    1544:	f8 01       	movw	r30, r16
    1546:	09 95       	icall
    1548:	0e 94 71 0a 	call	0x14e2 <DF_WaitWhileBusy>
    154c:	1f 91       	pop	r17
    154e:	0f 91       	pop	r16
    1550:	ff 90       	pop	r15
    1552:	ef 90       	pop	r14
    1554:	08 95       	ret

00001556 <DF_CopyFlashPageToBuffer>:
    1556:	ef 92       	push	r14
    1558:	ff 92       	push	r15
    155a:	0f 93       	push	r16
    155c:	1f 93       	push	r17
    155e:	7c 01       	movw	r14, r24
    1560:	00 91 00 01 	lds	r16, 0x0100
    1564:	10 91 01 01 	lds	r17, 0x0101
    1568:	80 e0       	ldi	r24, 0x00	; 0
    156a:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    156e:	81 e0       	ldi	r24, 0x01	; 1
    1570:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    1574:	83 e5       	ldi	r24, 0x53	; 83
    1576:	f8 01       	movw	r30, r16
    1578:	09 95       	icall
    157a:	8a b5       	in	r24, 0x2a	; 42
    157c:	97 01       	movw	r18, r14
    157e:	02 c0       	rjmp	.+4      	; 0x1584 <DF_CopyFlashPageToBuffer+0x2e>
    1580:	36 95       	lsr	r19
    1582:	27 95       	ror	r18
    1584:	8a 95       	dec	r24
    1586:	e2 f7       	brpl	.-8      	; 0x1580 <DF_CopyFlashPageToBuffer+0x2a>
    1588:	c9 01       	movw	r24, r18
    158a:	f8 01       	movw	r30, r16
    158c:	09 95       	icall
    158e:	8b b5       	in	r24, 0x2b	; 43
    1590:	02 c0       	rjmp	.+4      	; 0x1596 <DF_CopyFlashPageToBuffer+0x40>
    1592:	ee 0c       	add	r14, r14
    1594:	ff 1c       	adc	r15, r15
    1596:	8a 95       	dec	r24
    1598:	e2 f7       	brpl	.-8      	; 0x1592 <DF_CopyFlashPageToBuffer+0x3c>
    159a:	c7 01       	movw	r24, r14
    159c:	f8 01       	movw	r30, r16
    159e:	09 95       	icall
    15a0:	80 e0       	ldi	r24, 0x00	; 0
    15a2:	f8 01       	movw	r30, r16
    15a4:	09 95       	icall
    15a6:	0e 94 71 0a 	call	0x14e2 <DF_WaitWhileBusy>
    15aa:	1f 91       	pop	r17
    15ac:	0f 91       	pop	r16
    15ae:	ff 90       	pop	r15
    15b0:	ef 90       	pop	r14
    15b2:	08 95       	ret

000015b4 <DF_CopyBufferToFlashPage>:
    15b4:	ef 92       	push	r14
    15b6:	ff 92       	push	r15
    15b8:	0f 93       	push	r16
    15ba:	1f 93       	push	r17
    15bc:	7c 01       	movw	r14, r24
    15be:	00 91 00 01 	lds	r16, 0x0100
    15c2:	10 91 01 01 	lds	r17, 0x0101
    15c6:	80 e0       	ldi	r24, 0x00	; 0
    15c8:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    15cc:	81 e0       	ldi	r24, 0x01	; 1
    15ce:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    15d2:	83 e8       	ldi	r24, 0x83	; 131
    15d4:	f8 01       	movw	r30, r16
    15d6:	09 95       	icall
    15d8:	8a b5       	in	r24, 0x2a	; 42
    15da:	97 01       	movw	r18, r14
    15dc:	02 c0       	rjmp	.+4      	; 0x15e2 <DF_CopyBufferToFlashPage+0x2e>
    15de:	36 95       	lsr	r19
    15e0:	27 95       	ror	r18
    15e2:	8a 95       	dec	r24
    15e4:	e2 f7       	brpl	.-8      	; 0x15de <DF_CopyBufferToFlashPage+0x2a>
    15e6:	c9 01       	movw	r24, r18
    15e8:	f8 01       	movw	r30, r16
    15ea:	09 95       	icall
    15ec:	8b b5       	in	r24, 0x2b	; 43
    15ee:	02 c0       	rjmp	.+4      	; 0x15f4 <DF_CopyBufferToFlashPage+0x40>
    15f0:	ee 0c       	add	r14, r14
    15f2:	ff 1c       	adc	r15, r15
    15f4:	8a 95       	dec	r24
    15f6:	e2 f7       	brpl	.-8      	; 0x15f0 <DF_CopyBufferToFlashPage+0x3c>
    15f8:	c7 01       	movw	r24, r14
    15fa:	f8 01       	movw	r30, r16
    15fc:	09 95       	icall
    15fe:	80 e0       	ldi	r24, 0x00	; 0
    1600:	f8 01       	movw	r30, r16
    1602:	09 95       	icall
    1604:	0e 94 71 0a 	call	0x14e2 <DF_WaitWhileBusy>
    1608:	1f 91       	pop	r17
    160a:	0f 91       	pop	r16
    160c:	ff 90       	pop	r15
    160e:	ef 90       	pop	r14
    1610:	08 95       	ret

00001612 <DF_GetChipCharacteristics>:
    1612:	0f 93       	push	r16
    1614:	1f 93       	push	r17
    1616:	00 91 00 01 	lds	r16, 0x0100
    161a:	10 91 01 01 	lds	r17, 0x0101
    161e:	80 e0       	ldi	r24, 0x00	; 0
    1620:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    1624:	81 e0       	ldi	r24, 0x01	; 1
    1626:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    162a:	87 e5       	ldi	r24, 0x57	; 87
    162c:	f8 01       	movw	r30, r16
    162e:	09 95       	icall
    1630:	80 e0       	ldi	r24, 0x00	; 0
    1632:	f8 01       	movw	r30, r16
    1634:	09 95       	icall
    1636:	99 27       	eor	r25, r25
    1638:	88 73       	andi	r24, 0x38	; 56
    163a:	90 70       	andi	r25, 0x00	; 0
    163c:	43 e0       	ldi	r20, 0x03	; 3
    163e:	95 95       	asr	r25
    1640:	87 95       	ror	r24
    1642:	4a 95       	dec	r20
    1644:	e1 f7       	brne	.-8      	; 0x163e <DF_GetChipCharacteristics+0x2c>
    1646:	99 27       	eor	r25, r25
    1648:	fc 01       	movw	r30, r24
    164a:	ea 54       	subi	r30, 0x4A	; 74
    164c:	fc 4f       	sbci	r31, 0xFC	; 252
    164e:	44 91       	lpm	r20, Z
    1650:	40 93 68 02 	sts	0x0268, r20
    1654:	9c 01       	movw	r18, r24
    1656:	28 0f       	add	r18, r24
    1658:	39 1f       	adc	r19, r25
    165a:	f9 01       	movw	r30, r18
    165c:	ea 55       	subi	r30, 0x5A	; 90
    165e:	fc 4f       	sbci	r31, 0xFC	; 252
    1660:	85 91       	lpm	r24, Z+
    1662:	94 91       	lpm	r25, Z
    1664:	90 93 6a 02 	sts	0x026A, r25
    1668:	80 93 69 02 	sts	0x0269, r24
    166c:	f9 01       	movw	r30, r18
    166e:	ea 56       	subi	r30, 0x6A	; 106
    1670:	fc 4f       	sbci	r31, 0xFC	; 252
    1672:	85 91       	lpm	r24, Z+
    1674:	94 91       	lpm	r25, Z
    1676:	90 93 6c 02 	sts	0x026C, r25
    167a:	80 93 6b 02 	sts	0x026B, r24
    167e:	80 e1       	ldi	r24, 0x10	; 16
    1680:	84 1b       	sub	r24, r20
    1682:	8a bd       	out	0x2a, r24	; 42
    1684:	48 50       	subi	r20, 0x08	; 8
    1686:	4b bd       	out	0x2b, r20	; 43
    1688:	1f 91       	pop	r17
    168a:	0f 91       	pop	r16
    168c:	08 95       	ret

0000168e <DF_CheckCorrectOnboardChip>:
    168e:	0e 94 09 0b 	call	0x1612 <DF_GetChipCharacteristics>
    1692:	80 91 6b 02 	lds	r24, 0x026B
    1696:	90 91 6c 02 	lds	r25, 0x026C
    169a:	80 50       	subi	r24, 0x00	; 0
    169c:	98 40       	sbci	r25, 0x08	; 8
    169e:	61 f0       	breq	.+24     	; 0x16b8 <DF_CheckCorrectOnboardChip+0x2a>
    16a0:	80 91 64 00 	lds	r24, 0x0064
    16a4:	84 60       	ori	r24, 0x04	; 4
    16a6:	80 93 64 00 	sts	0x0064, r24
    16aa:	86 e8       	ldi	r24, 0x86	; 134
    16ac:	93 e0       	ldi	r25, 0x03	; 3
    16ae:	0e 94 6f 03 	call	0x6de <MAIN_ShowError>
    16b2:	80 e0       	ldi	r24, 0x00	; 0
    16b4:	90 e0       	ldi	r25, 0x00	; 0
    16b6:	08 95       	ret
    16b8:	81 e0       	ldi	r24, 0x01	; 1
    16ba:	90 e0       	ldi	r25, 0x00	; 0
    16bc:	08 95       	ret

000016be <__vector_13>:

// ======================================================================================

ISR(USART0_RX_vect, ISR_BLOCK)
{
    16be:	1f 92       	push	r1
    16c0:	0f 92       	push	r0
    16c2:	0f b6       	in	r0, 0x3f	; 63
    16c4:	0f 92       	push	r0
    16c6:	11 24       	eor	r1, r1
    16c8:	2f 93       	push	r18
    16ca:	3f 93       	push	r19
    16cc:	4f 93       	push	r20
    16ce:	5f 93       	push	r21
    16d0:	6f 93       	push	r22
    16d2:	7f 93       	push	r23
    16d4:	8f 93       	push	r24
    16d6:	9f 93       	push	r25
    16d8:	af 93       	push	r26
    16da:	bf 93       	push	r27
    16dc:	ef 93       	push	r30
    16de:	ff 93       	push	r31
	if (BuffElements == BUFF_BUFFLEN)     // Buffer full
    16e0:	80 91 b3 02 	lds	r24, 0x02B3
    16e4:	80 34       	cpi	r24, 0x40	; 64
    16e6:	29 f4       	brne	.+10     	; 0x16f2 <__vector_13+0x34>
	{
		MAIN_ShowError(PSTR("BUFF OVERFLOW"));
    16e8:	8e eb       	ldi	r24, 0xBE	; 190
    16ea:	93 e0       	ldi	r25, 0x03	; 3
    16ec:	0e 94 6f 03 	call	0x6de <MAIN_ShowError>
		return;
    16f0:	20 c0       	rjmp	.+64     	; 0x1732 <__vector_13+0x74>
	}
		
	*StoreLoc = UDR;                      // Store the data
    16f2:	e0 91 af 02 	lds	r30, 0x02AF
    16f6:	f0 91 b0 02 	lds	r31, 0x02B0
    16fa:	80 91 c6 00 	lds	r24, 0x00C6
    16fe:	80 83       	st	Z, r24

	StoreLoc++;                           // Increment the IN pointer to the next element
    1700:	40 91 af 02 	lds	r20, 0x02AF
    1704:	50 91 b0 02 	lds	r21, 0x02B0
    1708:	9a 01       	movw	r18, r20
    170a:	2f 5f       	subi	r18, 0xFF	; 255
    170c:	3f 4f       	sbci	r19, 0xFF	; 255
    170e:	30 93 b0 02 	sts	0x02B0, r19
    1712:	20 93 af 02 	sts	0x02AF, r18
	BuffElements++;                       // Increment the total elements variable
    1716:	80 91 b3 02 	lds	r24, 0x02B3
    171a:	8f 5f       	subi	r24, 0xFF	; 255
    171c:	80 93 b3 02 	sts	0x02B3, r24

	if (StoreLoc == (BuffType*)&RingBuffer[BUFF_BUFFLEN])
    1720:	2f 5a       	subi	r18, 0xAF	; 175
    1722:	32 40       	sbci	r19, 0x02	; 2
    1724:	31 f4       	brne	.+12     	; 0x1732 <__vector_13+0x74>
		StoreLoc = (BuffType*)&RingBuffer[0]; // Wrap pointer if end of array reached
    1726:	4f 53       	subi	r20, 0x3F	; 63
    1728:	50 40       	sbci	r21, 0x00	; 0
    172a:	50 93 b0 02 	sts	0x02B0, r21
    172e:	40 93 af 02 	sts	0x02AF, r20
    1732:	ff 91       	pop	r31
    1734:	ef 91       	pop	r30
    1736:	bf 91       	pop	r27
    1738:	af 91       	pop	r26
    173a:	9f 91       	pop	r25
    173c:	8f 91       	pop	r24
    173e:	7f 91       	pop	r23
    1740:	6f 91       	pop	r22
    1742:	5f 91       	pop	r21
    1744:	4f 91       	pop	r20
    1746:	3f 91       	pop	r19
    1748:	2f 91       	pop	r18
    174a:	0f 90       	pop	r0
    174c:	0f be       	out	0x3f, r0	; 63
    174e:	0f 90       	pop	r0
    1750:	1f 90       	pop	r1
    1752:	18 95       	reti

00001754 <BUFF_InitialiseBuffer>:
}	

// ======================================================================================

void BUFF_InitialiseBuffer(void)
{
	StoreLoc    = (BuffType*)&RingBuffer[0]; // Set up the IN pointer to the start of the buffer
    1754:	8f e6       	ldi	r24, 0x6F	; 111
    1756:	92 e0       	ldi	r25, 0x02	; 2
    1758:	90 93 b0 02 	sts	0x02B0, r25
    175c:	80 93 af 02 	sts	0x02AF, r24
	RetrieveLoc = (BuffType*)&RingBuffer[0]; // Set up the OUT pointer to the start of the buffer
    1760:	90 93 b2 02 	sts	0x02B2, r25
    1764:	80 93 b1 02 	sts	0x02B1, r24

	BuffElements = 0;                     // Reset the buffer elements counter
    1768:	10 92 b3 02 	sts	0x02B3, r1
    176c:	08 95       	ret

0000176e <BUFF_GetBuffByte>:
}

BuffType BUFF_GetBuffByte(void)
{
	if (!(BuffElements))                  // No elements in the buffer
    176e:	80 91 b3 02 	lds	r24, 0x02B3
    1772:	88 23       	and	r24, r24
    1774:	19 f4       	brne	.+6      	; 0x177c <BUFF_GetBuffByte+0xe>
		return 0;
    1776:	80 e0       	ldi	r24, 0x00	; 0
    1778:	90 e0       	ldi	r25, 0x00	; 0
    177a:	08 95       	ret

	BuffType RetrievedData = *RetrieveLoc; // Grab the stored byte into a temp variable
    177c:	20 91 b1 02 	lds	r18, 0x02B1
    1780:	30 91 b2 02 	lds	r19, 0x02B2
    1784:	f9 01       	movw	r30, r18
    1786:	91 91       	ld	r25, Z+

	RetrieveLoc++;                         // Increment the OUT pointer to the next element if flag set
    1788:	f0 93 b2 02 	sts	0x02B2, r31
    178c:	e0 93 b1 02 	sts	0x02B1, r30
	BuffElements--;                        // Decrement the total elements variable
    1790:	80 91 b3 02 	lds	r24, 0x02B3
    1794:	81 50       	subi	r24, 0x01	; 1
    1796:	80 93 b3 02 	sts	0x02B3, r24
	
	if (RetrieveLoc == (BuffType*)&RingBuffer[BUFF_BUFFLEN])
    179a:	ef 5a       	subi	r30, 0xAF	; 175
    179c:	f2 40       	sbci	r31, 0x02	; 2
    179e:	31 f4       	brne	.+12     	; 0x17ac <BUFF_GetBuffByte+0x3e>
		RetrieveLoc = (BuffType*)&RingBuffer[0]; // Wrap pointer if end of array reached
    17a0:	2f 53       	subi	r18, 0x3F	; 63
    17a2:	30 40       	sbci	r19, 0x00	; 0
    17a4:	30 93 b2 02 	sts	0x02B2, r19
    17a8:	20 93 b1 02 	sts	0x02B1, r18
		
	return RetrievedData;                 // Return the retrieved data
    17ac:	89 2f       	mov	r24, r25
    17ae:	99 27       	eor	r25, r25
}
    17b0:	08 95       	ret

000017b2 <__vector_4>:
// ======================================================================================

// Packet Timeout = ((F_CPU / 1024) / (240 * TIMEOUT_TICKSBEFORETIMEOUT)) per second
ISR(TIMER2_COMP_vect, ISR_NOBLOCK)
{
    17b2:	78 94       	sei
    17b4:	1f 92       	push	r1
    17b6:	0f 92       	push	r0
    17b8:	0f b6       	in	r0, 0x3f	; 63
    17ba:	0f 92       	push	r0
    17bc:	11 24       	eor	r1, r1
    17be:	8f 93       	push	r24
	if (PacketTimeOutTicks++ == TIMEOUT_PACKET_TIMEOUTTICKS)
    17c0:	80 91 40 01 	lds	r24, 0x0140
    17c4:	8f 5f       	subi	r24, 0xFF	; 255
    17c6:	80 93 40 01 	sts	0x0140, r24
    17ca:	80 91 40 01 	lds	r24, 0x0140
    17ce:	87 39       	cpi	r24, 0x97	; 151
    17d0:	29 f4       	brne	.+10     	; 0x17dc <__vector_4+0x2a>
	{
		PacketTimeOutTicks   = 0;
    17d2:	10 92 40 01 	sts	0x0140, r1
		PacketTimeOut        = TRUE;
    17d6:	81 e0       	ldi	r24, 0x01	; 1
    17d8:	80 93 3f 01 	sts	0x013F, r24
    17dc:	8f 91       	pop	r24
    17de:	0f 90       	pop	r0
    17e0:	0f be       	out	0x3f, r0	; 63
    17e2:	0f 90       	pop	r0
    17e4:	1f 90       	pop	r1
    17e6:	18 95       	reti

000017e8 <TOUT_SetupSleepTimer>:
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    17e8:	a7 e8       	ldi	r26, 0x87	; 135
    17ea:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    17ec:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
    17f0:	80 2d       	mov	r24, r0
    17f2:	28 2f       	mov	r18, r24
	}
}

// Autosleep Timeout = (TIMEOUT_TICKSBEFORETIMEOUT / 10) secs between timeouts
ISR(TIMER1_OVF_vect, ISR_NOBLOCK)
{
	if (SleepTimeOutTicks++ == TicksBeforeAutoSleep)
	{
		TIMEOUT_SLEEP_TIMER_OFF();
		FUNCSleepMode();
		TOUT_SetupSleepTimer();
	}
}

// ======================================================================================

void TOUT_SetupSleepTimer(void)
{
	uint8_t NewTicksIndex = eeprom_read_byte(&EEPROMVars.AutoSleepValIndex);

	if (NewTicksIndex == 0xFF)
    17f4:	8f 3f       	cpi	r24, 0xFF	; 255
    17f6:	09 f4       	brne	.+2      	; 0x17fa <TOUT_SetupSleepTimer+0x12>
	  NewTicksIndex = 4;
    17f8:	24 e0       	ldi	r18, 0x04	; 4

	TIMSK1 = (1 << TOIE1);
    17fa:	31 e0       	ldi	r19, 0x01	; 1
    17fc:	30 93 6f 00 	sts	0x006F, r19
	TicksBeforeAutoSleep = (pgm_read_byte(&AutoSleepTOValues[NewTicksIndex]) * 10);
    1800:	e2 2f       	mov	r30, r18
    1802:	ff 27       	eor	r31, r31
    1804:	e4 53       	subi	r30, 0x34	; 52
    1806:	fc 4f       	sbci	r31, 0xFC	; 252
    1808:	94 91       	lpm	r25, Z
    180a:	8a e0       	ldi	r24, 0x0A	; 10
    180c:	98 9f       	mul	r25, r24
    180e:	c0 01       	movw	r24, r0
    1810:	11 24       	eor	r1, r1
    1812:	90 93 3c 01 	sts	0x013C, r25
    1816:	80 93 3b 01 	sts	0x013B, r24

	TIMEOUT_SLEEP_TIMEOUT_RESET();
    181a:	10 92 3e 01 	sts	0x013E, r1
    181e:	10 92 3d 01 	sts	0x013D, r1
    1822:	10 92 85 00 	sts	0x0085, r1
    1826:	10 92 84 00 	sts	0x0084, r1
	
	if (NewTicksIndex)
    182a:	22 23       	and	r18, r18
    182c:	19 f0       	breq	.+6      	; 0x1834 <TOUT_SetupSleepTimer+0x4c>
	  TIMEOUT_SLEEP_TIMER_ON();
    182e:	30 93 81 00 	sts	0x0081, r19
    1832:	08 95       	ret
	else
	  TIMEOUT_SLEEP_TIMER_OFF();
    1834:	20 93 81 00 	sts	0x0081, r18
    1838:	08 95       	ret

0000183a <__vector_9>:
    183a:	78 94       	sei
    183c:	1f 92       	push	r1
    183e:	0f 92       	push	r0
    1840:	0f b6       	in	r0, 0x3f	; 63
    1842:	0f 92       	push	r0
    1844:	11 24       	eor	r1, r1
    1846:	2f 93       	push	r18
    1848:	3f 93       	push	r19
    184a:	4f 93       	push	r20
    184c:	5f 93       	push	r21
    184e:	6f 93       	push	r22
    1850:	7f 93       	push	r23
    1852:	8f 93       	push	r24
    1854:	9f 93       	push	r25
    1856:	af 93       	push	r26
    1858:	bf 93       	push	r27
    185a:	ef 93       	push	r30
    185c:	ff 93       	push	r31
    185e:	80 91 3d 01 	lds	r24, 0x013D
    1862:	90 91 3e 01 	lds	r25, 0x013E
    1866:	9c 01       	movw	r18, r24
    1868:	01 96       	adiw	r24, 0x01	; 1
    186a:	90 93 3e 01 	sts	0x013E, r25
    186e:	80 93 3d 01 	sts	0x013D, r24
    1872:	80 91 3b 01 	lds	r24, 0x013B
    1876:	90 91 3c 01 	lds	r25, 0x013C
    187a:	28 17       	cp	r18, r24
    187c:	39 07       	cpc	r19, r25
    187e:	31 f4       	brne	.+12     	; 0x188c <__vector_9+0x52>
    1880:	10 92 81 00 	sts	0x0081, r1
    1884:	0e 94 17 07 	call	0xe2e <FUNCSleepMode>
    1888:	0e 94 f4 0b 	call	0x17e8 <TOUT_SetupSleepTimer>
    188c:	ff 91       	pop	r31
    188e:	ef 91       	pop	r30
    1890:	bf 91       	pop	r27
    1892:	af 91       	pop	r26
    1894:	9f 91       	pop	r25
    1896:	8f 91       	pop	r24
    1898:	7f 91       	pop	r23
    189a:	6f 91       	pop	r22
    189c:	5f 91       	pop	r21
    189e:	4f 91       	pop	r20
    18a0:	3f 91       	pop	r19
    18a2:	2f 91       	pop	r18
    18a4:	0f 90       	pop	r0
    18a6:	0f be       	out	0x3f, r0	; 63
    18a8:	0f 90       	pop	r0
    18aa:	1f 90       	pop	r1
    18ac:	18 95       	reti

000018ae <PD_SetupDFAddressCounters>:
}

void PD_SetupDFAddressCounters(void)
{
	uint32_t StartAddress = CurrAddress;
    18ae:	20 91 42 01 	lds	r18, 0x0142
    18b2:	30 91 43 01 	lds	r19, 0x0143
    18b6:	40 91 44 01 	lds	r20, 0x0144
    18ba:	50 91 45 01 	lds	r21, 0x0145

	CurrPageAddress = 0;
    18be:	10 92 6e 02 	sts	0x026E, r1
    18c2:	10 92 6d 02 	sts	0x026D, r1

	while (StartAddress > DataflashInfo.PageSize)      // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DataflashInfo.PageSize;         // Subtract one page's worth of bytes from the desired address
		CurrPageAddress++;
    18c6:	80 91 69 02 	lds	r24, 0x0269
    18ca:	90 91 6a 02 	lds	r25, 0x026A
    18ce:	aa 27       	eor	r26, r26
    18d0:	bb 27       	eor	r27, r27
    18d2:	82 17       	cp	r24, r18
    18d4:	93 07       	cpc	r25, r19
    18d6:	a4 07       	cpc	r26, r20
    18d8:	b5 07       	cpc	r27, r21
    18da:	88 f4       	brcc	.+34     	; 0x18fe <PD_SetupDFAddressCounters+0x50>
    18dc:	60 e0       	ldi	r22, 0x00	; 0
    18de:	70 e0       	ldi	r23, 0x00	; 0
    18e0:	28 1b       	sub	r18, r24
    18e2:	39 0b       	sbc	r19, r25
    18e4:	4a 0b       	sbc	r20, r26
    18e6:	5b 0b       	sbc	r21, r27
    18e8:	6f 5f       	subi	r22, 0xFF	; 255
    18ea:	7f 4f       	sbci	r23, 0xFF	; 255
    18ec:	82 17       	cp	r24, r18
    18ee:	93 07       	cpc	r25, r19
    18f0:	a4 07       	cpc	r26, r20
    18f2:	b5 07       	cpc	r27, r21
    18f4:	a8 f3       	brcs	.-22     	; 0x18e0 <PD_SetupDFAddressCounters+0x32>
    18f6:	70 93 6e 02 	sts	0x026E, r23
    18fa:	60 93 6d 02 	sts	0x026D, r22
	}
	
	CurrBuffByte = (uint16_t)StartAddress;              // The buffer byte is the remainder
    18fe:	30 93 67 02 	sts	0x0267, r19
    1902:	20 93 66 02 	sts	0x0266, r18
    1906:	08 95       	ret

00001908 <PD_StoreDataflashByte>:
}

void PD_StoreDataflashByte(const uint8_t Data)
{
    1908:	cf 93       	push	r28
    190a:	c8 2f       	mov	r28, r24
	if (CurrBuffByte == DataflashInfo.PageSize)
    190c:	20 91 66 02 	lds	r18, 0x0266
    1910:	30 91 67 02 	lds	r19, 0x0267
    1914:	80 91 69 02 	lds	r24, 0x0269
    1918:	90 91 6a 02 	lds	r25, 0x026A
    191c:	28 17       	cp	r18, r24
    191e:	39 07       	cpc	r19, r25
    1920:	a9 f4       	brne	.+42     	; 0x194c <PD_StoreDataflashByte+0x44>
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
    1922:	80 91 6d 02 	lds	r24, 0x026D
    1926:	90 91 6e 02 	lds	r25, 0x026E
    192a:	9c 01       	movw	r18, r24
    192c:	01 96       	adiw	r24, 0x01	; 1
    192e:	90 93 6e 02 	sts	0x026E, r25
    1932:	80 93 6d 02 	sts	0x026D, r24
    1936:	c9 01       	movw	r24, r18
    1938:	0e 94 da 0a 	call	0x15b4 <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    193c:	80 e0       	ldi	r24, 0x00	; 0
    193e:	90 e0       	ldi	r25, 0x00	; 0
    1940:	0e 94 50 0a 	call	0x14a0 <DF_BufferWriteEnable>
		CurrBuffByte = 0;
    1944:	10 92 67 02 	sts	0x0267, r1
    1948:	10 92 66 02 	sts	0x0266, r1
	}
	
	USI_SPITransmit(Data);                                 // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    194c:	8c 2f       	mov	r24, r28
    194e:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
	CurrBuffByte++;
    1952:	80 91 66 02 	lds	r24, 0x0266
    1956:	90 91 67 02 	lds	r25, 0x0267
    195a:	01 96       	adiw	r24, 0x01	; 1
    195c:	90 93 67 02 	sts	0x0267, r25
    1960:	80 93 66 02 	sts	0x0266, r24
    1964:	cf 91       	pop	r28
    1966:	08 95       	ret

00001968 <PD_InterpretAVRISPPacket>:
    1968:	df 92       	push	r13
    196a:	ef 92       	push	r14
    196c:	ff 92       	push	r15
    196e:	0f 93       	push	r16
    1970:	1f 93       	push	r17
    1972:	cf 93       	push	r28
    1974:	df 93       	push	r29
    1976:	dd 24       	eor	r13, r13
    1978:	80 91 4b 01 	lds	r24, 0x014B
    197c:	99 27       	eor	r25, r25
    197e:	86 31       	cpi	r24, 0x16	; 22
    1980:	91 05       	cpc	r25, r1
    1982:	09 f4       	brne	.+2      	; 0x1986 <PD_InterpretAVRISPPacket+0x1e>
    1984:	00 c1       	rjmp	.+512    	; 0x1b86 <PD_InterpretAVRISPPacket+0x21e>
    1986:	87 31       	cpi	r24, 0x17	; 23
    1988:	91 05       	cpc	r25, r1
    198a:	b4 f4       	brge	.+44     	; 0x19b8 <PD_InterpretAVRISPPacket+0x50>
    198c:	82 31       	cpi	r24, 0x12	; 18
    198e:	91 05       	cpc	r25, r1
    1990:	09 f4       	brne	.+2      	; 0x1994 <PD_InterpretAVRISPPacket+0x2c>
    1992:	6f c0       	rjmp	.+222    	; 0x1a72 <PD_InterpretAVRISPPacket+0x10a>
    1994:	83 31       	cpi	r24, 0x13	; 19
    1996:	91 05       	cpc	r25, r1
    1998:	3c f4       	brge	.+14     	; 0x19a8 <PD_InterpretAVRISPPacket+0x40>
    199a:	80 31       	cpi	r24, 0x10	; 16
    199c:	91 05       	cpc	r25, r1
    199e:	31 f1       	breq	.+76     	; 0x19ec <PD_InterpretAVRISPPacket+0x84>
    19a0:	41 97       	sbiw	r24, 0x11	; 17
    19a2:	09 f4       	brne	.+2      	; 0x19a6 <PD_InterpretAVRISPPacket+0x3e>
    19a4:	46 c0       	rjmp	.+140    	; 0x1a32 <PD_InterpretAVRISPPacket+0xca>
    19a6:	40 c1       	rjmp	.+640    	; 0x1c28 <PD_InterpretAVRISPPacket+0x2c0>
    19a8:	84 31       	cpi	r24, 0x14	; 20
    19aa:	91 05       	cpc	r25, r1
    19ac:	09 f4       	brne	.+2      	; 0x19b0 <PD_InterpretAVRISPPacket+0x48>
    19ae:	8a c0       	rjmp	.+276    	; 0x1ac4 <PD_InterpretAVRISPPacket+0x15c>
    19b0:	45 97       	sbiw	r24, 0x15	; 21
    19b2:	0c f0       	brlt	.+2      	; 0x19b6 <PD_InterpretAVRISPPacket+0x4e>
    19b4:	af c0       	rjmp	.+350    	; 0x1b14 <PD_InterpretAVRISPPacket+0x1ac>
    19b6:	7f c0       	rjmp	.+254    	; 0x1ab6 <PD_InterpretAVRISPPacket+0x14e>
    19b8:	89 31       	cpi	r24, 0x19	; 25
    19ba:	91 05       	cpc	r25, r1
    19bc:	09 f4       	brne	.+2      	; 0x19c0 <PD_InterpretAVRISPPacket+0x58>
    19be:	70 c0       	rjmp	.+224    	; 0x1aa0 <PD_InterpretAVRISPPacket+0x138>
    19c0:	8a 31       	cpi	r24, 0x1A	; 26
    19c2:	91 05       	cpc	r25, r1
    19c4:	44 f4       	brge	.+16     	; 0x19d6 <PD_InterpretAVRISPPacket+0x6e>
    19c6:	87 31       	cpi	r24, 0x17	; 23
    19c8:	91 05       	cpc	r25, r1
    19ca:	09 f4       	brne	.+2      	; 0x19ce <PD_InterpretAVRISPPacket+0x66>
    19cc:	69 c0       	rjmp	.+210    	; 0x1aa0 <PD_InterpretAVRISPPacket+0x138>
    19ce:	48 97       	sbiw	r24, 0x18	; 24
    19d0:	09 f4       	brne	.+2      	; 0x19d4 <PD_InterpretAVRISPPacket+0x6c>
    19d2:	58 c0       	rjmp	.+176    	; 0x1a84 <PD_InterpretAVRISPPacket+0x11c>
    19d4:	29 c1       	rjmp	.+594    	; 0x1c28 <PD_InterpretAVRISPPacket+0x2c0>
    19d6:	8b 31       	cpi	r24, 0x1B	; 27
    19d8:	91 05       	cpc	r25, r1
    19da:	e9 f1       	breq	.+122    	; 0x1a56 <PD_InterpretAVRISPPacket+0xee>
    19dc:	8b 31       	cpi	r24, 0x1B	; 27
    19de:	91 05       	cpc	r25, r1
    19e0:	0c f4       	brge	.+2      	; 0x19e4 <PD_InterpretAVRISPPacket+0x7c>
    19e2:	50 c0       	rjmp	.+160    	; 0x1a84 <PD_InterpretAVRISPPacket+0x11c>
    19e4:	4c 97       	sbiw	r24, 0x1c	; 28
    19e6:	09 f4       	brne	.+2      	; 0x19ea <PD_InterpretAVRISPPacket+0x82>
    19e8:	4d c0       	rjmp	.+154    	; 0x1a84 <PD_InterpretAVRISPPacket+0x11c>
    19ea:	1e c1       	rjmp	.+572    	; 0x1c28 <PD_InterpretAVRISPPacket+0x2c0>
    19ec:	82 e0       	ldi	r24, 0x02	; 2
    19ee:	90 e0       	ldi	r25, 0x00	; 0
    19f0:	90 93 48 01 	sts	0x0148, r25
    19f4:	80 93 47 01 	sts	0x0147, r24
    19f8:	81 e0       	ldi	r24, 0x01	; 1
    19fa:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    19fe:	0e 94 09 0b 	call	0x1612 <DF_GetChipCharacteristics>
    1a02:	80 91 68 02 	lds	r24, 0x0268
    1a06:	88 23       	and	r24, r24
    1a08:	59 f0       	breq	.+22     	; 0x1a20 <PD_InterpretAVRISPPacket+0xb8>
    1a0a:	81 ed       	ldi	r24, 0xD1	; 209
    1a0c:	93 e0       	ldi	r25, 0x03	; 3
    1a0e:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>
    1a12:	81 e0       	ldi	r24, 0x01	; 1
    1a14:	80 93 46 01 	sts	0x0146, r24
    1a18:	81 b3       	in	r24, 0x11	; 17
    1a1a:	8f 7c       	andi	r24, 0xCF	; 207
    1a1c:	80 62       	ori	r24, 0x20	; 32
    1a1e:	17 c0       	rjmp	.+46     	; 0x1a4e <PD_InterpretAVRISPPacket+0xe6>
    1a20:	86 e8       	ldi	r24, 0x86	; 134
    1a22:	93 e0       	ldi	r25, 0x03	; 3
    1a24:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>
    1a28:	8d 2d       	mov	r24, r13
    1a2a:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    1a2e:	80 ec       	ldi	r24, 0xC0	; 192
    1a30:	02 c1       	rjmp	.+516    	; 0x1c36 <PD_InterpretAVRISPPacket+0x2ce>
    1a32:	82 e0       	ldi	r24, 0x02	; 2
    1a34:	90 e0       	ldi	r25, 0x00	; 0
    1a36:	90 93 48 01 	sts	0x0148, r25
    1a3a:	80 93 47 01 	sts	0x0147, r24
    1a3e:	d0 92 46 01 	sts	0x0146, r13
    1a42:	8d 2d       	mov	r24, r13
    1a44:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    1a48:	81 b3       	in	r24, 0x11	; 17
    1a4a:	8f 7c       	andi	r24, 0xCF	; 207
    1a4c:	80 61       	ori	r24, 0x10	; 16
    1a4e:	81 bb       	out	0x11, r24	; 17
    1a50:	d0 92 4c 01 	sts	0x014C, r13
    1a54:	f2 c0       	rjmp	.+484    	; 0x1c3a <PD_InterpretAVRISPPacket+0x2d2>
    1a56:	84 e0       	ldi	r24, 0x04	; 4
    1a58:	90 e0       	ldi	r25, 0x00	; 0
    1a5a:	90 93 48 01 	sts	0x0148, r25
    1a5e:	80 93 47 01 	sts	0x0147, r24
    1a62:	d0 92 4c 01 	sts	0x014C, r13
    1a66:	82 e0       	ldi	r24, 0x02	; 2
    1a68:	80 93 4d 01 	sts	0x014D, r24
    1a6c:	d0 92 4e 01 	sts	0x014E, r13
    1a70:	e4 c0       	rjmp	.+456    	; 0x1c3a <PD_InterpretAVRISPPacket+0x2d2>
    1a72:	82 e0       	ldi	r24, 0x02	; 2
    1a74:	90 e0       	ldi	r25, 0x00	; 0
    1a76:	90 93 48 01 	sts	0x0148, r25
    1a7a:	80 93 47 01 	sts	0x0147, r24
    1a7e:	e1 e0       	ldi	r30, 0x01	; 1
    1a80:	de 2e       	mov	r13, r30
    1a82:	7e c0       	rjmp	.+252    	; 0x1b80 <PD_InterpretAVRISPPacket+0x218>
    1a84:	84 e0       	ldi	r24, 0x04	; 4
    1a86:	90 e0       	ldi	r25, 0x00	; 0
    1a88:	90 93 48 01 	sts	0x0148, r25
    1a8c:	80 93 47 01 	sts	0x0147, r24
    1a90:	10 92 4c 01 	sts	0x014C, r1
    1a94:	8f ef       	ldi	r24, 0xFF	; 255
    1a96:	80 93 4d 01 	sts	0x014D, r24
    1a9a:	10 92 4e 01 	sts	0x014E, r1
    1a9e:	cd c0       	rjmp	.+410    	; 0x1c3a <PD_InterpretAVRISPPacket+0x2d2>
    1aa0:	83 e0       	ldi	r24, 0x03	; 3
    1aa2:	90 e0       	ldi	r25, 0x00	; 0
    1aa4:	90 93 48 01 	sts	0x0148, r25
    1aa8:	80 93 47 01 	sts	0x0147, r24
    1aac:	10 92 4c 01 	sts	0x014C, r1
    1ab0:	10 92 4d 01 	sts	0x014D, r1
    1ab4:	c2 c0       	rjmp	.+388    	; 0x1c3a <PD_InterpretAVRISPPacket+0x2d2>
    1ab6:	82 e0       	ldi	r24, 0x02	; 2
    1ab8:	90 e0       	ldi	r25, 0x00	; 0
    1aba:	90 93 48 01 	sts	0x0148, r25
    1abe:	80 93 47 01 	sts	0x0147, r24
    1ac2:	5e c0       	rjmp	.+188    	; 0x1b80 <PD_InterpretAVRISPPacket+0x218>
    1ac4:	80 91 4c 01 	lds	r24, 0x014C
    1ac8:	99 27       	eor	r25, r25
    1aca:	98 2f       	mov	r25, r24
    1acc:	88 27       	eor	r24, r24
    1ace:	20 91 4d 01 	lds	r18, 0x014D
    1ad2:	33 27       	eor	r19, r19
    1ad4:	82 2b       	or	r24, r18
    1ad6:	93 2b       	or	r25, r19
    1ad8:	03 96       	adiw	r24, 0x03	; 3
    1ada:	90 93 48 01 	sts	0x0148, r25
    1ade:	80 93 47 01 	sts	0x0147, r24
    1ae2:	21 e0       	ldi	r18, 0x01	; 1
    1ae4:	30 e0       	ldi	r19, 0x00	; 0
    1ae6:	02 97       	sbiw	r24, 0x02	; 2
    1ae8:	28 17       	cp	r18, r24
    1aea:	39 07       	cpc	r19, r25
    1aec:	48 f4       	brcc	.+18     	; 0x1b00 <PD_InterpretAVRISPPacket+0x198>
    1aee:	4f ef       	ldi	r20, 0xFF	; 255
    1af0:	ec e4       	ldi	r30, 0x4C	; 76
    1af2:	f1 e0       	ldi	r31, 0x01	; 1
    1af4:	41 93       	st	Z+, r20
    1af6:	2f 5f       	subi	r18, 0xFF	; 255
    1af8:	3f 4f       	sbci	r19, 0xFF	; 255
    1afa:	28 17       	cp	r18, r24
    1afc:	39 07       	cpc	r19, r25
    1afe:	d0 f3       	brcs	.-12     	; 0x1af4 <PD_InterpretAVRISPPacket+0x18c>
    1b00:	10 92 4c 01 	sts	0x014C, r1
    1b04:	e0 91 47 01 	lds	r30, 0x0147
    1b08:	f0 91 48 01 	lds	r31, 0x0148
    1b0c:	e6 5b       	subi	r30, 0xB6	; 182
    1b0e:	fe 4f       	sbci	r31, 0xFE	; 254
    1b10:	10 82       	st	Z, r1
    1b12:	93 c0       	rjmp	.+294    	; 0x1c3a <PD_InterpretAVRISPPacket+0x2d2>
    1b14:	0e 94 57 0c 	call	0x18ae <PD_SetupDFAddressCounters>
    1b18:	80 91 6d 02 	lds	r24, 0x026D
    1b1c:	90 91 6e 02 	lds	r25, 0x026E
    1b20:	0e 94 ab 0a 	call	0x1556 <DF_CopyFlashPageToBuffer>
    1b24:	80 91 66 02 	lds	r24, 0x0266
    1b28:	90 91 67 02 	lds	r25, 0x0267
    1b2c:	0e 94 50 0a 	call	0x14a0 <DF_BufferWriteEnable>
    1b30:	80 91 4c 01 	lds	r24, 0x014C
    1b34:	99 27       	eor	r25, r25
    1b36:	d8 2f       	mov	r29, r24
    1b38:	cc 27       	eor	r28, r28
    1b3a:	80 91 4d 01 	lds	r24, 0x014D
    1b3e:	99 27       	eor	r25, r25
    1b40:	c8 2b       	or	r28, r24
    1b42:	d9 2b       	or	r29, r25
    1b44:	00 e0       	ldi	r16, 0x00	; 0
    1b46:	10 e0       	ldi	r17, 0x00	; 0
    1b48:	0c 17       	cp	r16, r28
    1b4a:	1d 07       	cpc	r17, r29
    1b4c:	c8 f4       	brcc	.+50     	; 0x1b80 <PD_InterpretAVRISPPacket+0x218>
    1b4e:	55 e5       	ldi	r21, 0x55	; 85
    1b50:	e5 2e       	mov	r14, r21
    1b52:	51 e0       	ldi	r21, 0x01	; 1
    1b54:	f5 2e       	mov	r15, r21
    1b56:	f7 01       	movw	r30, r14
    1b58:	81 91       	ld	r24, Z+
    1b5a:	7f 01       	movw	r14, r30
    1b5c:	0e 94 84 0c 	call	0x1908 <PD_StoreDataflashByte>
    1b60:	80 91 66 02 	lds	r24, 0x0266
    1b64:	90 91 67 02 	lds	r25, 0x0267
    1b68:	01 96       	adiw	r24, 0x01	; 1
    1b6a:	90 93 67 02 	sts	0x0267, r25
    1b6e:	80 93 66 02 	sts	0x0266, r24
    1b72:	0e 94 46 0f 	call	0x1e8c <V2P_IncrementCurrAddress>
    1b76:	0f 5f       	subi	r16, 0xFF	; 255
    1b78:	1f 4f       	sbci	r17, 0xFF	; 255
    1b7a:	0c 17       	cp	r16, r28
    1b7c:	1d 07       	cpc	r17, r29
    1b7e:	58 f3       	brcs	.-42     	; 0x1b56 <PD_InterpretAVRISPPacket+0x1ee>
    1b80:	10 92 4c 01 	sts	0x014C, r1
    1b84:	5a c0       	rjmp	.+180    	; 0x1c3a <PD_InterpretAVRISPPacket+0x2d2>
    1b86:	0e 94 57 0c 	call	0x18ae <PD_SetupDFAddressCounters>
    1b8a:	80 91 6d 02 	lds	r24, 0x026D
    1b8e:	90 91 6e 02 	lds	r25, 0x026E
    1b92:	0e 94 ab 0a 	call	0x1556 <DF_CopyFlashPageToBuffer>
    1b96:	80 91 4c 01 	lds	r24, 0x014C
    1b9a:	99 27       	eor	r25, r25
    1b9c:	d8 2f       	mov	r29, r24
    1b9e:	cc 27       	eor	r28, r28
    1ba0:	80 91 4d 01 	lds	r24, 0x014D
    1ba4:	99 27       	eor	r25, r25
    1ba6:	c8 2b       	or	r28, r24
    1ba8:	d9 2b       	or	r29, r25
    1baa:	00 e0       	ldi	r16, 0x00	; 0
    1bac:	10 e0       	ldi	r17, 0x00	; 0
    1bae:	0c 17       	cp	r16, r28
    1bb0:	1d 07       	cpc	r17, r29
    1bb2:	70 f5       	brcc	.+92     	; 0x1c10 <PD_InterpretAVRISPPacket+0x2a8>
    1bb4:	3d e4       	ldi	r19, 0x4D	; 77
    1bb6:	e3 2e       	mov	r14, r19
    1bb8:	31 e0       	ldi	r19, 0x01	; 1
    1bba:	f3 2e       	mov	r15, r19
    1bbc:	20 91 66 02 	lds	r18, 0x0266
    1bc0:	30 91 67 02 	lds	r19, 0x0267
    1bc4:	80 91 69 02 	lds	r24, 0x0269
    1bc8:	90 91 6a 02 	lds	r25, 0x026A
    1bcc:	28 17       	cp	r18, r24
    1bce:	39 07       	cpc	r19, r25
    1bd0:	41 f4       	brne	.+16     	; 0x1be2 <PD_InterpretAVRISPPacket+0x27a>
    1bd2:	0e 94 57 0c 	call	0x18ae <PD_SetupDFAddressCounters>
    1bd6:	80 91 6d 02 	lds	r24, 0x026D
    1bda:	90 91 6e 02 	lds	r25, 0x026E
    1bde:	0e 94 ab 0a 	call	0x1556 <DF_CopyFlashPageToBuffer>
    1be2:	80 91 66 02 	lds	r24, 0x0266
    1be6:	90 91 67 02 	lds	r25, 0x0267
    1bea:	9c 01       	movw	r18, r24
    1bec:	01 96       	adiw	r24, 0x01	; 1
    1bee:	90 93 67 02 	sts	0x0267, r25
    1bf2:	80 93 66 02 	sts	0x0266, r24
    1bf6:	c9 01       	movw	r24, r18
    1bf8:	0e 94 ef 09 	call	0x13de <DF_ReadBufferByte>
    1bfc:	f7 01       	movw	r30, r14
    1bfe:	81 93       	st	Z+, r24
    1c00:	7f 01       	movw	r14, r30
    1c02:	0e 94 46 0f 	call	0x1e8c <V2P_IncrementCurrAddress>
    1c06:	0f 5f       	subi	r16, 0xFF	; 255
    1c08:	1f 4f       	sbci	r17, 0xFF	; 255
    1c0a:	0c 17       	cp	r16, r28
    1c0c:	1d 07       	cpc	r17, r29
    1c0e:	b0 f2       	brcs	.-84     	; 0x1bbc <PD_InterpretAVRISPPacket+0x254>
    1c10:	23 96       	adiw	r28, 0x03	; 3
    1c12:	d0 93 48 01 	sts	0x0148, r29
    1c16:	c0 93 47 01 	sts	0x0147, r28
    1c1a:	23 97       	sbiw	r28, 0x03	; 3
    1c1c:	10 92 4c 01 	sts	0x014C, r1
    1c20:	c5 5b       	subi	r28, 0xB5	; 181
    1c22:	de 4f       	sbci	r29, 0xFE	; 254
    1c24:	1a 82       	std	Y+2, r1	; 0x02
    1c26:	09 c0       	rjmp	.+18     	; 0x1c3a <PD_InterpretAVRISPPacket+0x2d2>
    1c28:	81 e0       	ldi	r24, 0x01	; 1
    1c2a:	90 e0       	ldi	r25, 0x00	; 0
    1c2c:	90 93 48 01 	sts	0x0148, r25
    1c30:	80 93 47 01 	sts	0x0147, r24
    1c34:	89 ec       	ldi	r24, 0xC9	; 201
    1c36:	80 93 4c 01 	sts	0x014C, r24
    1c3a:	0e 94 65 0e 	call	0x1cca <V2P_SendPacket>
    1c3e:	dd 20       	and	r13, r13
    1c40:	d9 f0       	breq	.+54     	; 0x1c78 <PD_InterpretAVRISPPacket+0x310>
    1c42:	80 e3       	ldi	r24, 0x30	; 48
    1c44:	92 e0       	ldi	r25, 0x02	; 2
    1c46:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>
    1c4a:	c0 e0       	ldi	r28, 0x00	; 0
    1c4c:	d0 e0       	ldi	r29, 0x00	; 0
    1c4e:	80 91 6b 02 	lds	r24, 0x026B
    1c52:	90 91 6c 02 	lds	r25, 0x026C
    1c56:	23 e0       	ldi	r18, 0x03	; 3
    1c58:	96 95       	lsr	r25
    1c5a:	87 95       	ror	r24
    1c5c:	2a 95       	dec	r18
    1c5e:	e1 f7       	brne	.-8      	; 0x1c58 <PD_InterpretAVRISPPacket+0x2f0>
    1c60:	c8 17       	cp	r28, r24
    1c62:	d9 07       	cpc	r29, r25
    1c64:	28 f4       	brcc	.+10     	; 0x1c70 <PD_InterpretAVRISPPacket+0x308>
    1c66:	ce 01       	movw	r24, r28
    1c68:	0e 94 88 0a 	call	0x1510 <DF_EraseBlock>
    1c6c:	21 96       	adiw	r28, 0x01	; 1
    1c6e:	ef cf       	rjmp	.-34     	; 0x1c4e <PD_InterpretAVRISPPacket+0x2e6>
    1c70:	81 ed       	ldi	r24, 0xD1	; 209
    1c72:	93 e0       	ldi	r25, 0x03	; 3
    1c74:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>
    1c78:	df 91       	pop	r29
    1c7a:	cf 91       	pop	r28
    1c7c:	1f 91       	pop	r17
    1c7e:	0f 91       	pop	r16
    1c80:	ff 90       	pop	r15
    1c82:	ef 90       	pop	r14
    1c84:	df 90       	pop	r13
    1c86:	08 95       	ret

00001c88 <V2P_GetChecksum>:
	
	/* Checksum for the V2 protocol is comprised of an XOR of all the packet 
      bytes, including the start, sequence number, size and token bytes.    */
	
	CheckSumByte  = AICB_MESSAGE_START;
    1c88:	6b e1       	ldi	r22, 0x1B	; 27
	CheckSumByte ^= SequenceNum;
    1c8a:	80 91 49 01 	lds	r24, 0x0149
    1c8e:	68 27       	eor	r22, r24
	CheckSumByte ^= (uint8_t)(MessageSize >> 8);
    1c90:	20 91 47 01 	lds	r18, 0x0147
    1c94:	30 91 48 01 	lds	r19, 0x0148
    1c98:	83 2f       	mov	r24, r19
    1c9a:	99 27       	eor	r25, r25
    1c9c:	68 27       	eor	r22, r24
	CheckSumByte ^= (uint8_t)(MessageSize);
    1c9e:	80 91 47 01 	lds	r24, 0x0147
    1ca2:	68 27       	eor	r22, r24
	CheckSumByte ^= AICB_TOKEN;
    1ca4:	8e e0       	ldi	r24, 0x0E	; 14
    1ca6:	68 27       	eor	r22, r24
	
	for (uint16_t CByteIndex = 0; CByteIndex < MessageSize; CByteIndex++)
    1ca8:	40 e0       	ldi	r20, 0x00	; 0
    1caa:	50 e0       	ldi	r21, 0x00	; 0
    1cac:	42 17       	cp	r20, r18
    1cae:	53 07       	cpc	r21, r19
    1cb0:	48 f4       	brcc	.+18     	; 0x1cc4 <V2P_GetChecksum+0x3c>
    1cb2:	eb e4       	ldi	r30, 0x4B	; 75
    1cb4:	f1 e0       	ldi	r31, 0x01	; 1
	   CheckSumByte ^= PacketBytes[CByteIndex];
    1cb6:	81 91       	ld	r24, Z+
    1cb8:	68 27       	eor	r22, r24
    1cba:	4f 5f       	subi	r20, 0xFF	; 255
    1cbc:	5f 4f       	sbci	r21, 0xFF	; 255
    1cbe:	42 17       	cp	r20, r18
    1cc0:	53 07       	cpc	r21, r19
    1cc2:	c8 f3       	brcs	.-14     	; 0x1cb6 <V2P_GetChecksum+0x2e>

	return CheckSumByte;
}
    1cc4:	86 2f       	mov	r24, r22
    1cc6:	99 27       	eor	r25, r25
    1cc8:	08 95       	ret

00001cca <V2P_SendPacket>:
    1cca:	0f 93       	push	r16
    1ccc:	1f 93       	push	r17
    1cce:	cf 93       	push	r28
    1cd0:	df 93       	push	r29
    1cd2:	8b e1       	ldi	r24, 0x1B	; 27
    1cd4:	0e 94 25 09 	call	0x124a <USART_Tx>
    1cd8:	80 91 49 01 	lds	r24, 0x0149
    1cdc:	0e 94 25 09 	call	0x124a <USART_Tx>
    1ce0:	80 91 48 01 	lds	r24, 0x0148
    1ce4:	0e 94 25 09 	call	0x124a <USART_Tx>
    1ce8:	80 91 47 01 	lds	r24, 0x0147
    1cec:	0e 94 25 09 	call	0x124a <USART_Tx>
    1cf0:	8e e0       	ldi	r24, 0x0E	; 14
    1cf2:	0e 94 25 09 	call	0x124a <USART_Tx>
    1cf6:	c0 e0       	ldi	r28, 0x00	; 0
    1cf8:	d0 e0       	ldi	r29, 0x00	; 0
    1cfa:	80 91 47 01 	lds	r24, 0x0147
    1cfe:	90 91 48 01 	lds	r25, 0x0148
    1d02:	c8 17       	cp	r28, r24
    1d04:	d9 07       	cpc	r29, r25
    1d06:	78 f4       	brcc	.+30     	; 0x1d26 <V2P_SendPacket+0x5c>
    1d08:	0b e4       	ldi	r16, 0x4B	; 75
    1d0a:	11 e0       	ldi	r17, 0x01	; 1
    1d0c:	f8 01       	movw	r30, r16
    1d0e:	81 91       	ld	r24, Z+
    1d10:	8f 01       	movw	r16, r30
    1d12:	0e 94 25 09 	call	0x124a <USART_Tx>
    1d16:	21 96       	adiw	r28, 0x01	; 1
    1d18:	80 91 47 01 	lds	r24, 0x0147
    1d1c:	90 91 48 01 	lds	r25, 0x0148
    1d20:	c8 17       	cp	r28, r24
    1d22:	d9 07       	cpc	r29, r25
    1d24:	98 f3       	brcs	.-26     	; 0x1d0c <V2P_SendPacket+0x42>
    1d26:	0e 94 44 0e 	call	0x1c88 <V2P_GetChecksum>
    1d2a:	0e 94 25 09 	call	0x124a <USART_Tx>
    1d2e:	80 91 49 01 	lds	r24, 0x0149
    1d32:	90 91 4a 01 	lds	r25, 0x014A
    1d36:	01 96       	adiw	r24, 0x01	; 1
    1d38:	90 93 4a 01 	sts	0x014A, r25
    1d3c:	80 93 49 01 	sts	0x0149, r24
    1d40:	df 91       	pop	r29
    1d42:	cf 91       	pop	r28
    1d44:	1f 91       	pop	r17
    1d46:	0f 91       	pop	r16
    1d48:	08 95       	ret

00001d4a <V2P_GetSetParamater>:

void V2P_GetSetParamater(void)
{
	uint8_t Param_Name = PacketBytes[1];    // Save the parameter number
    1d4a:	20 91 4c 01 	lds	r18, 0x014C

	MessageSize = 3;                        // Set the default response message size to 3 bytes     
    1d4e:	83 e0       	ldi	r24, 0x03	; 3
    1d50:	90 e0       	ldi	r25, 0x00	; 0
    1d52:	90 93 48 01 	sts	0x0148, r25
    1d56:	80 93 47 01 	sts	0x0147, r24
	PacketBytes[1] = AICB_STATUS_CMD_OK;    // Set the default response to OK
    1d5a:	10 92 4c 01 	sts	0x014C, r1

	switch (Param_Name)                    // Switch based on the recieved parameter byte
    1d5e:	33 27       	eor	r19, r19
    1d60:	22 39       	cpi	r18, 0x92	; 146
    1d62:	31 05       	cpc	r19, r1
    1d64:	51 f1       	breq	.+84     	; 0x1dba <V2P_GetSetParamater+0x70>
    1d66:	23 39       	cpi	r18, 0x93	; 147
    1d68:	31 05       	cpc	r19, r1
    1d6a:	8c f4       	brge	.+34     	; 0x1d8e <V2P_GetSetParamater+0x44>
    1d6c:	21 38       	cpi	r18, 0x81	; 129
    1d6e:	31 05       	cpc	r19, r1
    1d70:	01 f1       	breq	.+64     	; 0x1db2 <V2P_GetSetParamater+0x68>
    1d72:	22 38       	cpi	r18, 0x82	; 130
    1d74:	31 05       	cpc	r19, r1
    1d76:	24 f4       	brge	.+8      	; 0x1d80 <V2P_GetSetParamater+0x36>
    1d78:	20 38       	cpi	r18, 0x80	; 128
    1d7a:	31 05       	cpc	r19, r1
    1d7c:	41 f1       	breq	.+80     	; 0x1dce <V2P_GetSetParamater+0x84>
    1d7e:	7a c0       	rjmp	.+244    	; 0x1e74 <V2P_GetSetParamater+0x12a>
    1d80:	20 39       	cpi	r18, 0x90	; 144
    1d82:	31 05       	cpc	r19, r1
    1d84:	c1 f0       	breq	.+48     	; 0x1db6 <V2P_GetSetParamater+0x6c>
    1d86:	21 39       	cpi	r18, 0x91	; 145
    1d88:	31 05       	cpc	r19, r1
    1d8a:	a9 f0       	breq	.+42     	; 0x1db6 <V2P_GetSetParamater+0x6c>
    1d8c:	73 c0       	rjmp	.+230    	; 0x1e74 <V2P_GetSetParamater+0x12a>
    1d8e:	28 39       	cpi	r18, 0x98	; 152
    1d90:	31 05       	cpc	r19, r1
    1d92:	89 f1       	breq	.+98     	; 0x1df6 <V2P_GetSetParamater+0xac>
    1d94:	29 39       	cpi	r18, 0x99	; 153
    1d96:	31 05       	cpc	r19, r1
    1d98:	2c f4       	brge	.+10     	; 0x1da4 <V2P_GetSetParamater+0x5a>
    1d9a:	26 39       	cpi	r18, 0x96	; 150
    1d9c:	31 05       	cpc	r19, r1
    1d9e:	0c f4       	brge	.+2      	; 0x1da2 <V2P_GetSetParamater+0x58>
    1da0:	69 c0       	rjmp	.+210    	; 0x1e74 <V2P_GetSetParamater+0x12a>
    1da2:	5a c0       	rjmp	.+180    	; 0x1e58 <V2P_GetSetParamater+0x10e>
    1da4:	2e 39       	cpi	r18, 0x9E	; 158
    1da6:	31 05       	cpc	r19, r1
    1da8:	e1 f1       	breq	.+120    	; 0x1e22 <V2P_GetSetParamater+0xd8>
    1daa:	2f 39       	cpi	r18, 0x9F	; 159
    1dac:	31 05       	cpc	r19, r1
    1dae:	89 f0       	breq	.+34     	; 0x1dd2 <V2P_GetSetParamater+0x88>
    1db0:	61 c0       	rjmp	.+194    	; 0x1e74 <V2P_GetSetParamater+0x12a>
	{
		case AICB_PARAM_BUILD_NUMBER_LOW:
			PacketBytes[2] = VERSION_MINOR;

			break;
		case AICB_PARAM_BUILD_NUMBER_HIGH:
			PacketBytes[2] = VERSION_MAJOR;
    1db2:	81 e0       	ldi	r24, 0x01	; 1
    1db4:	3f c0       	rjmp	.+126    	; 0x1e34 <V2P_GetSetParamater+0xea>

			break;
		case AICB_PARAM_HARDWARE_VERSION:
			PacketBytes[2] = V2P_HW_VERSION;

			break;
		case AICB_PARAM_SW_MAJOR:
			PacketBytes[2] = V2P_SW_VERSION_MAJOR;
    1db6:	82 e0       	ldi	r24, 0x02	; 2
    1db8:	3d c0       	rjmp	.+122    	; 0x1e34 <V2P_GetSetParamater+0xea>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    1dba:	a6 e8       	ldi	r26, 0x86	; 134
    1dbc:	b0 e0       	ldi	r27, 0x00	; 0
    1dbe:	9d 01       	movw	r18, r26
  uint8_t result;
  asm volatile
    1dc0:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
    1dc4:	80 2d       	mov	r24, r0
    1dc6:	8f 3f       	cpi	r24, 0xFF	; 255
    1dc8:	11 f0       	breq	.+4      	; 0x1dce <V2P_GetSetParamater+0x84>
    1dca:	d9 01       	movw	r26, r18
    1dcc:	30 c0       	rjmp	.+96     	; 0x1e2e <V2P_GetSetParamater+0xe4>
    1dce:	84 e0       	ldi	r24, 0x04	; 4
    1dd0:	31 c0       	rjmp	.+98     	; 0x1e34 <V2P_GetSetParamater+0xea>

			break;
		case AICB_PARAM_SW_MINOR:
			PacketBytes[2] = ((eeprom_read_byte(&EEPROMVars.FirmVerMinor) == 0xFF)? V2P_SW_VERSION_MINOR_DEFAULT : eeprom_read_byte(&EEPROMVars.FirmVerMinor));

			break;
		case AICB_PARAM_CONTROLLER_INIT:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
    1dd2:	80 91 4b 01 	lds	r24, 0x014B
    1dd6:	83 30       	cpi	r24, 0x03	; 3
    1dd8:	19 f4       	brne	.+6      	; 0x1de0 <V2P_GetSetParamater+0x96>
			{
				PacketBytes[2] = Param_ControllerInit;
    1dda:	80 91 41 01 	lds	r24, 0x0141
    1dde:	2a c0       	rjmp	.+84     	; 0x1e34 <V2P_GetSetParamater+0xea>
			}
			else
			{
				MessageSize = 2;
    1de0:	82 e0       	ldi	r24, 0x02	; 2
    1de2:	90 e0       	ldi	r25, 0x00	; 0
    1de4:	90 93 48 01 	sts	0x0148, r25
    1de8:	80 93 47 01 	sts	0x0147, r24
				Param_ControllerInit = PacketBytes[2];
    1dec:	80 91 4d 01 	lds	r24, 0x014D
    1df0:	80 93 41 01 	sts	0x0141, r24
			}
			
			break;
    1df4:	48 c0       	rjmp	.+144    	; 0x1e86 <V2P_GetSetParamater+0x13c>
		case AICB_PARAM_SCK_DURATION:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
    1df6:	80 91 4b 01 	lds	r24, 0x014B
    1dfa:	a1 e0       	ldi	r26, 0x01	; 1
    1dfc:	b0 e0       	ldi	r27, 0x00	; 0
    1dfe:	83 30       	cpi	r24, 0x03	; 3
    1e00:	b1 f0       	breq	.+44     	; 0x1e2e <V2P_GetSetParamater+0xe4>
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.SCKDuration);
			}
			else
			{
				MessageSize = 2;
    1e02:	82 e0       	ldi	r24, 0x02	; 2
    1e04:	90 e0       	ldi	r25, 0x00	; 0
    1e06:	90 93 48 01 	sts	0x0148, r25
    1e0a:	80 93 47 01 	sts	0x0147, r24
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    1e0e:	80 91 4d 01 	lds	r24, 0x014D
  asm volatile (
    1e12:	08 2e       	mov	r0, r24
    1e14:	0e 94 73 1a 	call	0x34e6 <__eeprom_write_byte_1F2021>
				eeprom_write_byte(&EEPROMVars.SCKDuration, PacketBytes[2]);
				USI_SPISetSpeed(PacketBytes[2]); // Re-Initialise the USI system with the new frequency
    1e18:	80 91 4d 01 	lds	r24, 0x014D
    1e1c:	0e 94 73 09 	call	0x12e6 <USI_SPISetSpeed>
			}
					
			break;
    1e20:	32 c0       	rjmp	.+100    	; 0x1e86 <V2P_GetSetParamater+0x13c>
		case AICB_PARAM_RESET_POLARITY:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
    1e22:	80 91 4b 01 	lds	r24, 0x014B
    1e26:	a0 e0       	ldi	r26, 0x00	; 0
    1e28:	b0 e0       	ldi	r27, 0x00	; 0
    1e2a:	83 30       	cpi	r24, 0x03	; 3
    1e2c:	31 f4       	brne	.+12     	; 0x1e3a <V2P_GetSetParamater+0xf0>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1e2e:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
    1e32:	80 2d       	mov	r24, r0
    1e34:	80 93 4d 01 	sts	0x014D, r24
    1e38:	26 c0       	rjmp	.+76     	; 0x1e86 <V2P_GetSetParamater+0x13c>
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.ResetPolarity);		
			}
			else
			{
				MessageSize = 2;
    1e3a:	82 e0       	ldi	r24, 0x02	; 2
    1e3c:	90 e0       	ldi	r25, 0x00	; 0
    1e3e:	90 93 48 01 	sts	0x0148, r25
    1e42:	80 93 47 01 	sts	0x0147, r24
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    1e46:	80 91 4d 01 	lds	r24, 0x014D
  asm volatile (
    1e4a:	08 2e       	mov	r0, r24
    1e4c:	0e 94 73 1a 	call	0x34e6 <__eeprom_write_byte_1F2021>
				eeprom_write_byte(&EEPROMVars.ResetPolarity, PacketBytes[2]);
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Change takes effect immediatly
    1e50:	81 e0       	ldi	r24, 0x01	; 1
    1e52:	0e 94 1a 03 	call	0x634 <MAIN_ResetCSLine>
			}
			
			break;
    1e56:	17 c0       	rjmp	.+46     	; 0x1e86 <V2P_GetSetParamater+0x13c>
		case AICB_PARAM_OSC_PSCALE:
		case AICB_PARAM_OSC_CMATCH:
			/* Despite not supporting these parameters (STK500 only), the AVR Studio programmer
			   sends them along with the SCK duration. A OK must be returned or the sequence will fail
			   and the SCK duration byte will not be sent.                                             */
		
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
    1e58:	80 91 4b 01 	lds	r24, 0x014B
    1e5c:	83 30       	cpi	r24, 0x03	; 3
    1e5e:	19 f4       	brne	.+6      	; 0x1e66 <V2P_GetSetParamater+0x11c>
			  PacketBytes[2] = 0;             // If the command is a read, return a 0 for both parameters
    1e60:	10 92 4d 01 	sts	0x014D, r1
    1e64:	10 c0       	rjmp	.+32     	; 0x1e86 <V2P_GetSetParamater+0x13c>
			else
			  MessageSize = 2;                // Otherwise just send back an OK if the command is a set		
    1e66:	82 e0       	ldi	r24, 0x02	; 2
    1e68:	90 e0       	ldi	r25, 0x00	; 0
    1e6a:	90 93 48 01 	sts	0x0148, r25
    1e6e:	80 93 47 01 	sts	0x0147, r24
			
			break;
    1e72:	09 c0       	rjmp	.+18     	; 0x1e86 <V2P_GetSetParamater+0x13c>
		default:                             // Unrecognised parameter
			MessageSize = 2;
    1e74:	82 e0       	ldi	r24, 0x02	; 2
    1e76:	90 e0       	ldi	r25, 0x00	; 0
    1e78:	90 93 48 01 	sts	0x0148, r25
    1e7c:	80 93 47 01 	sts	0x0147, r24
			PacketBytes[1] = AICB_STATUS_CMD_FAILED;			
    1e80:	80 ec       	ldi	r24, 0xC0	; 192
    1e82:	80 93 4c 01 	sts	0x014C, r24
	}
	
	V2P_SendPacket();
    1e86:	0e 94 65 0e 	call	0x1cca <V2P_SendPacket>
    1e8a:	08 95       	ret

00001e8c <V2P_IncrementCurrAddress>:
}

void V2P_IncrementCurrAddress(void)
{
	// Incrementing a 32-bit unsigned variable takes a lot of code. Because much of the code is
	// not very time critical (much of it is waiting for the hardware), i've chosen to waste
	// a few extra cycles per increment and save a good 60 bytes or so of code space by putting
	// the incrmement inside a function.

	CurrAddress++;
    1e8c:	80 91 42 01 	lds	r24, 0x0142
    1e90:	90 91 43 01 	lds	r25, 0x0143
    1e94:	a0 91 44 01 	lds	r26, 0x0144
    1e98:	b0 91 45 01 	lds	r27, 0x0145
    1e9c:	01 96       	adiw	r24, 0x01	; 1
    1e9e:	a1 1d       	adc	r26, r1
    1ea0:	b1 1d       	adc	r27, r1
    1ea2:	80 93 42 01 	sts	0x0142, r24
    1ea6:	90 93 43 01 	sts	0x0143, r25
    1eaa:	a0 93 44 01 	sts	0x0144, r26
    1eae:	b0 93 45 01 	sts	0x0145, r27
    1eb2:	08 95       	ret

00001eb4 <V2P_CheckForExtendedAddress>:
}

void V2P_CheckForExtendedAddress(void)
{
	if (CurrAddress & V2P_LOAD_EXTENDED_ADDR_FLAG)     // MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
    1eb4:	80 91 42 01 	lds	r24, 0x0142
    1eb8:	90 91 43 01 	lds	r25, 0x0143
    1ebc:	a0 91 44 01 	lds	r26, 0x0144
    1ec0:	b0 91 45 01 	lds	r27, 0x0145
    1ec4:	b7 ff       	sbrs	r27, 7
    1ec6:	1e c0       	rjmp	.+60     	; 0x1f04 <V2P_CheckForExtendedAddress+0x50>
	{
		USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);   // Load extended address command
    1ec8:	8d e4       	ldi	r24, 0x4D	; 77
    1eca:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1ece:	80 e0       	ldi	r24, 0x00	; 0
    1ed0:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
		USI_SPITransmit((CurrAddress & V2P_LOAD_EXTENDED_ADDR_MASK) >> V2P_LOAD_EXTENDED_ADDR_SHIFT);
    1ed4:	80 91 44 01 	lds	r24, 0x0144
    1ed8:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1edc:	80 e0       	ldi	r24, 0x00	; 0
    1ede:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
		
		CurrAddress &= ~(V2P_LOAD_EXTENDED_ADDR_FLAG); // Clear the flag
    1ee2:	80 91 42 01 	lds	r24, 0x0142
    1ee6:	90 91 43 01 	lds	r25, 0x0143
    1eea:	a0 91 44 01 	lds	r26, 0x0144
    1eee:	b0 91 45 01 	lds	r27, 0x0145
    1ef2:	bf 77       	andi	r27, 0x7F	; 127
    1ef4:	80 93 42 01 	sts	0x0142, r24
    1ef8:	90 93 43 01 	sts	0x0143, r25
    1efc:	a0 93 44 01 	sts	0x0144, r26
    1f00:	b0 93 45 01 	sts	0x0145, r27
    1f04:	08 95       	ret

00001f06 <V2P_RunStateMachine>:
    1f06:	ef 92       	push	r14
    1f08:	ff 92       	push	r15
    1f0a:	0f 93       	push	r16
    1f0c:	1f 93       	push	r17
    1f0e:	cf 93       	push	r28
    1f10:	c0 e0       	ldi	r28, 0x00	; 0
    1f12:	ee 24       	eor	r14, r14
    1f14:	ff 24       	eor	r15, r15
    1f16:	0e 94 aa 0b 	call	0x1754 <BUFF_InitialiseBuffer>
    1f1a:	c0 93 81 00 	sts	0x0081, r28
    1f1e:	c0 93 46 01 	sts	0x0146, r28
    1f22:	10 92 42 01 	sts	0x0142, r1
    1f26:	10 92 43 01 	sts	0x0143, r1
    1f2a:	10 92 44 01 	sts	0x0144, r1
    1f2e:	10 92 45 01 	sts	0x0145, r1
    1f32:	80 91 3f 01 	lds	r24, 0x013F
    1f36:	81 30       	cpi	r24, 0x01	; 1
    1f38:	11 f4       	brne	.+4      	; 0x1f3e <V2P_RunStateMachine+0x38>
    1f3a:	ca e0       	ldi	r28, 0x0A	; 10
    1f3c:	11 c0       	rjmp	.+34     	; 0x1f60 <V2P_RunStateMachine+0x5a>
    1f3e:	cc 23       	and	r28, r28
    1f40:	79 f0       	breq	.+30     	; 0x1f60 <V2P_RunStateMachine+0x5a>
    1f42:	10 92 3f 01 	sts	0x013F, r1
    1f46:	10 92 40 01 	sts	0x0140, r1
    1f4a:	10 92 b2 00 	sts	0x00B2, r1
    1f4e:	80 ef       	ldi	r24, 0xF0	; 240
    1f50:	80 93 b3 00 	sts	0x00B3, r24
    1f54:	82 e0       	ldi	r24, 0x02	; 2
    1f56:	80 93 70 00 	sts	0x0070, r24
    1f5a:	8f e0       	ldi	r24, 0x0F	; 15
    1f5c:	80 93 b0 00 	sts	0x00B0, r24
    1f60:	8c 2f       	mov	r24, r28
    1f62:	99 27       	eor	r25, r25
    1f64:	85 30       	cpi	r24, 0x05	; 5
    1f66:	91 05       	cpc	r25, r1
    1f68:	09 f4       	brne	.+2      	; 0x1f6c <V2P_RunStateMachine+0x66>
    1f6a:	87 c0       	rjmp	.+270    	; 0x207a <V2P_RunStateMachine+0x174>
    1f6c:	86 30       	cpi	r24, 0x06	; 6
    1f6e:	91 05       	cpc	r25, r1
    1f70:	ac f4       	brge	.+42     	; 0x1f9c <V2P_RunStateMachine+0x96>
    1f72:	82 30       	cpi	r24, 0x02	; 2
    1f74:	91 05       	cpc	r25, r1
    1f76:	09 f4       	brne	.+2      	; 0x1f7a <V2P_RunStateMachine+0x74>
    1f78:	57 c0       	rjmp	.+174    	; 0x2028 <V2P_RunStateMachine+0x122>
    1f7a:	83 30       	cpi	r24, 0x03	; 3
    1f7c:	91 05       	cpc	r25, r1
    1f7e:	34 f4       	brge	.+12     	; 0x1f8c <V2P_RunStateMachine+0x86>
    1f80:	00 97       	sbiw	r24, 0x00	; 0
    1f82:	99 f1       	breq	.+102    	; 0x1fea <V2P_RunStateMachine+0xe4>
    1f84:	01 97       	sbiw	r24, 0x01	; 1
    1f86:	09 f4       	brne	.+2      	; 0x1f8a <V2P_RunStateMachine+0x84>
    1f88:	49 c0       	rjmp	.+146    	; 0x201c <V2P_RunStateMachine+0x116>
    1f8a:	d3 cf       	rjmp	.-90     	; 0x1f32 <V2P_RunStateMachine+0x2c>
    1f8c:	83 30       	cpi	r24, 0x03	; 3
    1f8e:	91 05       	cpc	r25, r1
    1f90:	09 f4       	brne	.+2      	; 0x1f94 <V2P_RunStateMachine+0x8e>
    1f92:	53 c0       	rjmp	.+166    	; 0x203a <V2P_RunStateMachine+0x134>
    1f94:	04 97       	sbiw	r24, 0x04	; 4
    1f96:	09 f4       	brne	.+2      	; 0x1f9a <V2P_RunStateMachine+0x94>
    1f98:	5b c0       	rjmp	.+182    	; 0x2050 <V2P_RunStateMachine+0x14a>
    1f9a:	cb cf       	rjmp	.-106    	; 0x1f32 <V2P_RunStateMachine+0x2c>
    1f9c:	88 30       	cpi	r24, 0x08	; 8
    1f9e:	91 05       	cpc	r25, r1
    1fa0:	d1 f0       	breq	.+52     	; 0x1fd6 <V2P_RunStateMachine+0xd0>
    1fa2:	89 30       	cpi	r24, 0x09	; 9
    1fa4:	91 05       	cpc	r25, r1
    1fa6:	44 f4       	brge	.+16     	; 0x1fb8 <V2P_RunStateMachine+0xb2>
    1fa8:	86 30       	cpi	r24, 0x06	; 6
    1faa:	91 05       	cpc	r25, r1
    1fac:	09 f4       	brne	.+2      	; 0x1fb0 <V2P_RunStateMachine+0xaa>
    1fae:	6d c0       	rjmp	.+218    	; 0x208a <V2P_RunStateMachine+0x184>
    1fb0:	07 97       	sbiw	r24, 0x07	; 7
    1fb2:	09 f4       	brne	.+2      	; 0x1fb6 <V2P_RunStateMachine+0xb0>
    1fb4:	7e c0       	rjmp	.+252    	; 0x20b2 <V2P_RunStateMachine+0x1ac>
    1fb6:	bd cf       	rjmp	.-134    	; 0x1f32 <V2P_RunStateMachine+0x2c>
    1fb8:	89 30       	cpi	r24, 0x09	; 9
    1fba:	91 05       	cpc	r25, r1
    1fbc:	09 f4       	brne	.+2      	; 0x1fc0 <V2P_RunStateMachine+0xba>
    1fbe:	ab c0       	rjmp	.+342    	; 0x2116 <V2P_RunStateMachine+0x210>
    1fc0:	0a 97       	sbiw	r24, 0x0a	; 10
    1fc2:	09 f0       	breq	.+2      	; 0x1fc6 <V2P_RunStateMachine+0xc0>
    1fc4:	b6 cf       	rjmp	.-148    	; 0x1f32 <V2P_RunStateMachine+0x2c>
    1fc6:	82 e0       	ldi	r24, 0x02	; 2
    1fc8:	90 e0       	ldi	r25, 0x00	; 0
    1fca:	90 93 48 01 	sts	0x0148, r25
    1fce:	80 93 47 01 	sts	0x0147, r24
    1fd2:	80 e8       	ldi	r24, 0x80	; 128
    1fd4:	f6 c0       	rjmp	.+492    	; 0x21c2 <V2P_RunStateMachine+0x2bc>
    1fd6:	10 92 3f 01 	sts	0x013F, r1
    1fda:	0e 94 aa 0b 	call	0x1754 <BUFF_InitialiseBuffer>
    1fde:	10 92 b0 00 	sts	0x00B0, r1
    1fe2:	10 92 70 00 	sts	0x0070, r1
    1fe6:	c0 e0       	ldi	r28, 0x00	; 0
    1fe8:	a4 cf       	rjmp	.-184    	; 0x1f32 <V2P_RunStateMachine+0x2c>
    1fea:	80 91 b3 02 	lds	r24, 0x02B3
    1fee:	81 11       	cpse	r24, r1
    1ff0:	c1 e0       	ldi	r28, 0x01	; 1
    1ff2:	f2 9b       	sbis	0x1e, 2	; 30
    1ff4:	9e cf       	rjmp	.-196    	; 0x1f32 <V2P_RunStateMachine+0x2c>
    1ff6:	80 91 46 01 	lds	r24, 0x0146
    1ffa:	88 23       	and	r24, r24
    1ffc:	09 f0       	breq	.+2      	; 0x2000 <V2P_RunStateMachine+0xfa>
    1ffe:	99 cf       	rjmp	.-206    	; 0x1f32 <V2P_RunStateMachine+0x2c>
    2000:	80 e8       	ldi	r24, 0x80	; 128
    2002:	80 93 61 00 	sts	0x0061, r24
    2006:	83 e0       	ldi	r24, 0x03	; 3
    2008:	80 93 61 00 	sts	0x0061, r24
    200c:	80 91 c1 00 	lds	r24, 0x00C1
    2010:	80 78       	andi	r24, 0x80	; 128
    2012:	80 93 c1 00 	sts	0x00C1, r24
    2016:	0e 94 f4 0b 	call	0x17e8 <TOUT_SetupSleepTimer>
    201a:	d9 c0       	rjmp	.+434    	; 0x21ce <V2P_RunStateMachine+0x2c8>
    201c:	0e 94 2d 09 	call	0x125a <USART_Rx>
    2020:	8b 31       	cpi	r24, 0x1B	; 27
    2022:	89 f5       	brne	.+98     	; 0x2086 <V2P_RunStateMachine+0x180>
    2024:	c2 e0       	ldi	r28, 0x02	; 2
    2026:	85 cf       	rjmp	.-246    	; 0x1f32 <V2P_RunStateMachine+0x2c>
    2028:	0e 94 2d 09 	call	0x125a <USART_Rx>
    202c:	99 27       	eor	r25, r25
    202e:	90 93 4a 01 	sts	0x014A, r25
    2032:	80 93 49 01 	sts	0x0149, r24
    2036:	c3 e0       	ldi	r28, 0x03	; 3
    2038:	7c cf       	rjmp	.-264    	; 0x1f32 <V2P_RunStateMachine+0x2c>
    203a:	0e 94 2d 09 	call	0x125a <USART_Rx>
    203e:	99 27       	eor	r25, r25
    2040:	98 2f       	mov	r25, r24
    2042:	88 27       	eor	r24, r24
    2044:	90 93 48 01 	sts	0x0148, r25
    2048:	80 93 47 01 	sts	0x0147, r24
    204c:	c4 e0       	ldi	r28, 0x04	; 4
    204e:	71 cf       	rjmp	.-286    	; 0x1f32 <V2P_RunStateMachine+0x2c>
    2050:	0e 94 2d 09 	call	0x125a <USART_Rx>
    2054:	28 2f       	mov	r18, r24
    2056:	33 27       	eor	r19, r19
    2058:	80 91 47 01 	lds	r24, 0x0147
    205c:	90 91 48 01 	lds	r25, 0x0148
    2060:	82 2b       	or	r24, r18
    2062:	93 2b       	or	r25, r19
    2064:	90 93 48 01 	sts	0x0148, r25
    2068:	80 93 47 01 	sts	0x0147, r24
    206c:	83 51       	subi	r24, 0x13	; 19
    206e:	91 40       	sbci	r25, 0x01	; 1
    2070:	50 f4       	brcc	.+20     	; 0x2086 <V2P_RunStateMachine+0x180>
    2072:	c5 e0       	ldi	r28, 0x05	; 5
    2074:	ee 24       	eor	r14, r14
    2076:	ff 24       	eor	r15, r15
    2078:	5c cf       	rjmp	.-328    	; 0x1f32 <V2P_RunStateMachine+0x2c>
    207a:	0e 94 2d 09 	call	0x125a <USART_Rx>
    207e:	8e 30       	cpi	r24, 0x0E	; 14
    2080:	11 f4       	brne	.+4      	; 0x2086 <V2P_RunStateMachine+0x180>
    2082:	c6 e0       	ldi	r28, 0x06	; 6
    2084:	56 cf       	rjmp	.-340    	; 0x1f32 <V2P_RunStateMachine+0x2c>
    2086:	c9 e0       	ldi	r28, 0x09	; 9
    2088:	54 cf       	rjmp	.-344    	; 0x1f32 <V2P_RunStateMachine+0x2c>
    208a:	80 91 47 01 	lds	r24, 0x0147
    208e:	90 91 48 01 	lds	r25, 0x0148
    2092:	e8 16       	cp	r14, r24
    2094:	f9 06       	cpc	r15, r25
    2096:	11 f4       	brne	.+4      	; 0x209c <V2P_RunStateMachine+0x196>
    2098:	c7 e0       	ldi	r28, 0x07	; 7
    209a:	4b cf       	rjmp	.-362    	; 0x1f32 <V2P_RunStateMachine+0x2c>
    209c:	87 01       	movw	r16, r14
    209e:	05 5b       	subi	r16, 0xB5	; 181
    20a0:	1e 4f       	sbci	r17, 0xFE	; 254
    20a2:	08 94       	sec
    20a4:	e1 1c       	adc	r14, r1
    20a6:	f1 1c       	adc	r15, r1
    20a8:	0e 94 2d 09 	call	0x125a <USART_Rx>
    20ac:	f8 01       	movw	r30, r16
    20ae:	80 83       	st	Z, r24
    20b0:	40 cf       	rjmp	.-384    	; 0x1f32 <V2P_RunStateMachine+0x2c>
    20b2:	0e 94 44 0e 	call	0x1c88 <V2P_GetChecksum>
    20b6:	18 2f       	mov	r17, r24
    20b8:	0e 94 2d 09 	call	0x125a <USART_Rx>
    20bc:	18 17       	cp	r17, r24
    20be:	09 f0       	breq	.+2      	; 0x20c2 <V2P_RunStateMachine+0x1bc>
    20c0:	79 c0       	rjmp	.+242    	; 0x21b4 <V2P_RunStateMachine+0x2ae>
    20c2:	c0 91 3f 01 	lds	r28, 0x013F
    20c6:	cc 23       	and	r28, r28
    20c8:	09 f0       	breq	.+2      	; 0x20cc <V2P_RunStateMachine+0x1c6>
    20ca:	74 c0       	rjmp	.+232    	; 0x21b4 <V2P_RunStateMachine+0x2ae>
    20cc:	80 91 4b 01 	lds	r24, 0x014B
    20d0:	99 27       	eor	r25, r25
    20d2:	84 30       	cpi	r24, 0x04	; 4
    20d4:	91 05       	cpc	r25, r1
    20d6:	3c f4       	brge	.+14     	; 0x20e6 <V2P_RunStateMachine+0x1e0>
    20d8:	82 30       	cpi	r24, 0x02	; 2
    20da:	91 05       	cpc	r25, r1
    20dc:	0c f0       	brlt	.+2      	; 0x20e0 <V2P_RunStateMachine+0x1da>
    20de:	61 c0       	rjmp	.+194    	; 0x21a2 <V2P_RunStateMachine+0x29c>
    20e0:	01 97       	sbiw	r24, 0x01	; 1
    20e2:	39 f0       	breq	.+14     	; 0x20f2 <V2P_RunStateMachine+0x1ec>
    20e4:	61 c0       	rjmp	.+194    	; 0x21a8 <V2P_RunStateMachine+0x2a2>
    20e6:	86 30       	cpi	r24, 0x06	; 6
    20e8:	91 05       	cpc	r25, r1
    20ea:	e9 f0       	breq	.+58     	; 0x2126 <V2P_RunStateMachine+0x220>
    20ec:	07 97       	sbiw	r24, 0x07	; 7
    20ee:	99 f0       	breq	.+38     	; 0x2116 <V2P_RunStateMachine+0x210>
    20f0:	5b c0       	rjmp	.+182    	; 0x21a8 <V2P_RunStateMachine+0x2a2>
    20f2:	8b e0       	ldi	r24, 0x0B	; 11
    20f4:	90 e0       	ldi	r25, 0x00	; 0
    20f6:	90 93 48 01 	sts	0x0148, r25
    20fa:	80 93 47 01 	sts	0x0147, r24
    20fe:	ab e4       	ldi	r26, 0x4B	; 75
    2100:	b1 e0       	ldi	r27, 0x01	; 1
    2102:	e2 ee       	ldi	r30, 0xE2	; 226
    2104:	f3 e0       	ldi	r31, 0x03	; 3
    2106:	9a e0       	ldi	r25, 0x0A	; 10
    2108:	84 91       	lpm	r24, Z
    210a:	8d 93       	st	X+, r24
    210c:	91 50       	subi	r25, 0x01	; 1
    210e:	31 96       	adiw	r30, 0x01	; 1
    2110:	97 ff       	sbrs	r25, 7
    2112:	fa cf       	rjmp	.-12     	; 0x2108 <V2P_RunStateMachine+0x202>
    2114:	58 c0       	rjmp	.+176    	; 0x21c6 <V2P_RunStateMachine+0x2c0>
    2116:	82 e0       	ldi	r24, 0x02	; 2
    2118:	90 e0       	ldi	r25, 0x00	; 0
    211a:	90 93 48 01 	sts	0x0148, r25
    211e:	80 93 47 01 	sts	0x0147, r24
    2122:	80 ec       	ldi	r24, 0xC0	; 192
    2124:	4e c0       	rjmp	.+156    	; 0x21c2 <V2P_RunStateMachine+0x2bc>
    2126:	82 e0       	ldi	r24, 0x02	; 2
    2128:	90 e0       	ldi	r25, 0x00	; 0
    212a:	90 93 48 01 	sts	0x0148, r25
    212e:	80 93 47 01 	sts	0x0147, r24
    2132:	0e 94 5a 0f 	call	0x1eb4 <V2P_CheckForExtendedAddress>
    2136:	80 91 4c 01 	lds	r24, 0x014C
    213a:	99 27       	eor	r25, r25
    213c:	aa 27       	eor	r26, r26
    213e:	bb 27       	eor	r27, r27
    2140:	b8 2f       	mov	r27, r24
    2142:	aa 27       	eor	r26, r26
    2144:	99 27       	eor	r25, r25
    2146:	88 27       	eor	r24, r24
    2148:	20 91 4d 01 	lds	r18, 0x014D
    214c:	33 27       	eor	r19, r19
    214e:	44 27       	eor	r20, r20
    2150:	55 27       	eor	r21, r21
    2152:	a9 01       	movw	r20, r18
    2154:	33 27       	eor	r19, r19
    2156:	22 27       	eor	r18, r18
    2158:	82 2b       	or	r24, r18
    215a:	93 2b       	or	r25, r19
    215c:	a4 2b       	or	r26, r20
    215e:	b5 2b       	or	r27, r21
    2160:	20 91 4e 01 	lds	r18, 0x014E
    2164:	33 27       	eor	r19, r19
    2166:	44 27       	eor	r20, r20
    2168:	55 27       	eor	r21, r21
    216a:	54 2f       	mov	r21, r20
    216c:	43 2f       	mov	r20, r19
    216e:	32 2f       	mov	r19, r18
    2170:	22 27       	eor	r18, r18
    2172:	82 2b       	or	r24, r18
    2174:	93 2b       	or	r25, r19
    2176:	a4 2b       	or	r26, r20
    2178:	b5 2b       	or	r27, r21
    217a:	20 91 4f 01 	lds	r18, 0x014F
    217e:	33 27       	eor	r19, r19
    2180:	44 27       	eor	r20, r20
    2182:	55 27       	eor	r21, r21
    2184:	82 2b       	or	r24, r18
    2186:	93 2b       	or	r25, r19
    2188:	a4 2b       	or	r26, r20
    218a:	b5 2b       	or	r27, r21
    218c:	80 93 42 01 	sts	0x0142, r24
    2190:	90 93 43 01 	sts	0x0143, r25
    2194:	a0 93 44 01 	sts	0x0144, r26
    2198:	b0 93 45 01 	sts	0x0145, r27
    219c:	c0 93 4c 01 	sts	0x014C, r28
    21a0:	12 c0       	rjmp	.+36     	; 0x21c6 <V2P_RunStateMachine+0x2c0>
    21a2:	0e 94 a5 0e 	call	0x1d4a <V2P_GetSetParamater>
    21a6:	11 c0       	rjmp	.+34     	; 0x21ca <V2P_RunStateMachine+0x2c4>
    21a8:	e0 91 02 01 	lds	r30, 0x0102
    21ac:	f0 91 03 01 	lds	r31, 0x0103
    21b0:	09 95       	icall
    21b2:	0b c0       	rjmp	.+22     	; 0x21ca <V2P_RunStateMachine+0x2c4>
    21b4:	82 e0       	ldi	r24, 0x02	; 2
    21b6:	90 e0       	ldi	r25, 0x00	; 0
    21b8:	90 93 48 01 	sts	0x0148, r25
    21bc:	80 93 47 01 	sts	0x0147, r24
    21c0:	81 ec       	ldi	r24, 0xC1	; 193
    21c2:	80 93 4c 01 	sts	0x014C, r24
    21c6:	0e 94 65 0e 	call	0x1cca <V2P_SendPacket>
    21ca:	c8 e0       	ldi	r28, 0x08	; 8
    21cc:	b2 ce       	rjmp	.-668    	; 0x1f32 <V2P_RunStateMachine+0x2c>
    21ce:	cf 91       	pop	r28
    21d0:	1f 91       	pop	r17
    21d2:	0f 91       	pop	r16
    21d4:	ff 90       	pop	r15
    21d6:	ef 90       	pop	r14
    21d8:	08 95       	ret

000021da <ISPCC_EnterChipProgrammingMode>:

// ======================================================================================

void ISPCC_EnterChipProgrammingMode(void)
{
    21da:	0f 93       	push	r16
    21dc:	1f 93       	push	r17
    21de:	cf 93       	push	r28
	uint8_t ByteDelay = PacketBytes[5];
    21e0:	10 91 50 01 	lds	r17, 0x0150
	uint8_t Attempts  = PacketBytes[4];
    21e4:	c0 91 4f 01 	lds	r28, 0x014F
	uint8_t Response;

	MAIN_Delay1MS(PacketBytes[2]);         // Wait before continuing, amount specified in the packet
    21e8:	80 91 4d 01 	lds	r24, 0x014D
    21ec:	0e 94 08 03 	call	0x610 <MAIN_Delay1MS>

	if ((!(Attempts)) || (Attempts > 100)) // if no attempts or too high a value is specified, a fixed number is chosen
    21f0:	8c 2f       	mov	r24, r28
    21f2:	81 50       	subi	r24, 0x01	; 1
    21f4:	84 36       	cpi	r24, 0x64	; 100
    21f6:	08 f0       	brcs	.+2      	; 0x21fa <ISPCC_EnterChipProgrammingMode+0x20>
	   Attempts = 24;
    21f8:	c8 e1       	ldi	r28, 0x18	; 24
		
	while (Attempts--)
	{
		USI_SPITransmit(PacketBytes[8]);
		MAIN_Delay1MS(ByteDelay);
		USI_SPITransmit(PacketBytes[9]);
		MAIN_Delay1MS(ByteDelay);
			
		Response = USI_SPITransmit(PacketBytes[10]);
		MAIN_Delay1MS(ByteDelay);

		if (PacketBytes[7] == ISPCC_POLL_MODE_AVR)
		  USI_SPITransmit(PacketBytes[11]);
		else
		  Response = USI_SPITransmit(PacketBytes[11]);
				
		if (!(PacketBytes[7]) || (Response == PacketBytes[6])) // Polling disabled, or returned value matches expected poll value
		{
			MAIN_Delay1MS(ByteDelay);

			InProgrammingMode = TRUE;
			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = AICB_STATUS_CMD_OK;
			return;
		}
		
		MAIN_Delay1MS(ByteDelay);
		USI_SPIToggleClock();            // Out of sync, shift in one bit and try again
    21fa:	c1 50       	subi	r28, 0x01	; 1
    21fc:	cf 3f       	cpi	r28, 0xFF	; 255
    21fe:	09 f4       	brne	.+2      	; 0x2202 <ISPCC_EnterChipProgrammingMode+0x28>
    2200:	3f c0       	rjmp	.+126    	; 0x2280 <ISPCC_EnterChipProgrammingMode+0xa6>
    2202:	80 91 53 01 	lds	r24, 0x0153
    2206:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    220a:	81 2f       	mov	r24, r17
    220c:	0e 94 08 03 	call	0x610 <MAIN_Delay1MS>
    2210:	80 91 54 01 	lds	r24, 0x0154
    2214:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    2218:	81 2f       	mov	r24, r17
    221a:	0e 94 08 03 	call	0x610 <MAIN_Delay1MS>
    221e:	80 91 55 01 	lds	r24, 0x0155
    2222:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    2226:	08 2f       	mov	r16, r24
    2228:	81 2f       	mov	r24, r17
    222a:	0e 94 08 03 	call	0x610 <MAIN_Delay1MS>
    222e:	80 91 52 01 	lds	r24, 0x0152
    2232:	83 30       	cpi	r24, 0x03	; 3
    2234:	29 f4       	brne	.+10     	; 0x2240 <ISPCC_EnterChipProgrammingMode+0x66>
    2236:	80 91 56 01 	lds	r24, 0x0156
    223a:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    223e:	05 c0       	rjmp	.+10     	; 0x224a <ISPCC_EnterChipProgrammingMode+0x70>
    2240:	80 91 56 01 	lds	r24, 0x0156
    2244:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    2248:	08 2f       	mov	r16, r24
    224a:	80 91 52 01 	lds	r24, 0x0152
    224e:	88 23       	and	r24, r24
    2250:	21 f0       	breq	.+8      	; 0x225a <ISPCC_EnterChipProgrammingMode+0x80>
    2252:	80 91 51 01 	lds	r24, 0x0151
    2256:	08 17       	cp	r16, r24
    2258:	69 f4       	brne	.+26     	; 0x2274 <ISPCC_EnterChipProgrammingMode+0x9a>
    225a:	81 2f       	mov	r24, r17
    225c:	0e 94 08 03 	call	0x610 <MAIN_Delay1MS>
    2260:	81 e0       	ldi	r24, 0x01	; 1
    2262:	80 93 46 01 	sts	0x0146, r24
    2266:	81 b3       	in	r24, 0x11	; 17
    2268:	8f 7c       	andi	r24, 0xCF	; 207
    226a:	80 62       	ori	r24, 0x20	; 32
    226c:	81 bb       	out	0x11, r24	; 17
    226e:	10 92 4c 01 	sts	0x014C, r1
    2272:	0d c0       	rjmp	.+26     	; 0x228e <ISPCC_EnterChipProgrammingMode+0xb4>
    2274:	81 2f       	mov	r24, r17
    2276:	0e 94 08 03 	call	0x610 <MAIN_Delay1MS>
    227a:	0e 94 c9 09 	call	0x1392 <USI_SPIToggleClock>
    227e:	bd cf       	rjmp	.-134    	; 0x21fa <ISPCC_EnterChipProgrammingMode+0x20>
	}

	// If function hasn't returned by now, all the attempts have failed. Show this by
	// resetting the status leds to green (ready) and send a fail message.

	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
    2280:	81 b3       	in	r24, 0x11	; 17
    2282:	8f 7c       	andi	r24, 0xCF	; 207
    2284:	80 61       	ori	r24, 0x10	; 16
    2286:	81 bb       	out	0x11, r24	; 17
	PacketBytes[1] = AICB_STATUS_CMD_FAILED;
    2288:	80 ec       	ldi	r24, 0xC0	; 192
    228a:	80 93 4c 01 	sts	0x014C, r24
    228e:	cf 91       	pop	r28
    2290:	1f 91       	pop	r17
    2292:	0f 91       	pop	r16
    2294:	08 95       	ret

00002296 <ISPCC_PollForProgComplete>:
}

void ISPCC_ProgramChip(void)
{
	uint16_t PollAddress  = 0;
	uint8_t  ProgMode     = PacketBytes[3];
	uint8_t  WriteCommand = PacketBytes[5];
	uint16_t StartAddress = (uint16_t)CurrAddress;
	uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
	                      | PacketBytes[2];
	uint8_t  PollType;
	uint8_t  ByteToWrite;
			
	if (ProgMode & ISPCC_PROG_MODE_PAGE)                 // Page writing mode
	{
		for (uint16_t WriteByte = 0; WriteByte < BytesToWrite; WriteByte++) // Transmit the page bytes
		{
			ByteToWrite = PacketBytes[10 + WriteByte];
		
			if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP) // Flash write mode - word addresses so MSB/LSB masking 
			   USI_SPITransmit(WriteCommand | ((WriteByte & 0x01)? ISPCC_HIGH_BYTE_WRITE : ISPCC_LOW_BYTE_WRITE));
			else                                         // EEPROM write mode - byte addresses so no masking 
			   USI_SPITransmit(WriteCommand);

			USI_SPITransmitWord(CurrAddress & 0xFFFF);    // Only the LSW of the address should be sent
			USI_SPITransmit(ByteToWrite);                 // Send one of the new bytes to be written

			if (!(PollAddress))
			{
				if ((PacketBytes[8] != ByteToWrite)       // Can do polling
				   && ((PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP) || ((PacketBytes[0] == AICB_CMD_PROGRAM_EEPROM_ISP) && (PacketBytes[9] != ByteToWrite))))
				{
					PollAddress = (CurrAddress & 0xFFFF); // Save the current address
				
					if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP)
					   PollAddress = ((PollAddress << 1) + (WriteByte & 0x01));
				}
			}

			// Flash addresses are in words; only increment address on odd byte, OR if it's the EEPROM being programmed (byte addresses)
			if ((WriteByte & 0x01) || (PacketBytes[0] == AICB_CMD_PROGRAM_EEPROM_ISP))
			   V2P_IncrementCurrAddress();
		}

		PollType = ProgMode;

		if (ProgMode & ISPCC_PROG_MODE_PAGEDONE)         // If this packet is the end of a page, we need to send the program page command
		{
			USI_SPITransmit(PacketBytes[6]);             // Send the write program memory page command
			USI_SPITransmitWord(StartAddress);           // Send the page address word
			USI_SPITransmit(0x00);

			if (!(PollAddress))                          // No polling address
			   PollType = ((ProgMode & ~ISPCC_PAGE_POLLTYPE_MASK) | ISPCC_PAGE_POLLTYPE_WAIT);

			ISPCC_PollForProgComplete(PollType, PollAddress);
		}
	}
	else                                                 // Flash Word writing mode or EEPROM byte writing mode
	{
		for (uint16_t WriteByte = 0; WriteByte < BytesToWrite; WriteByte++)
		{
			ByteToWrite = PacketBytes[10 + WriteByte];

			if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP)
			   USI_SPITransmit(WriteCommand | ((WriteByte & 0x01)? ISPCC_HIGH_BYTE_WRITE : ISPCC_LOW_BYTE_WRITE));
			else
			   USI_SPITransmit(WriteCommand);					
					
			USI_SPITransmitWord(CurrAddress & 0xFFFF);    // Transmit the current address to the slave AVR
			USI_SPITransmit(ByteToWrite);                 // Send one of the new bytes to be written

			PollType = ProgMode;

			if ((PacketBytes[8] != ByteToWrite)           // Can do polling
			   && ((PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP) || ((PacketBytes[0] == AICB_CMD_PROGRAM_EEPROM_ISP) && (PacketBytes[9] != ByteToWrite))))
			{
				PollAddress = (CurrAddress & 0xFFFF);     // Save the current address;

				if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP)
				   PollAddress = ((PollAddress << 1) + (WriteByte & 0x01));
			}
			else
			{
				PollType = ((ProgMode & ~ISPCC_WORD_POLLTYPE_MASK) | ISPCC_WORD_POLLTYPE_WAIT);
			}					

			// Flash addresses are in words; only increment address on the odd byte, OR if it's the EEPROM being programmed (byte addresses)
			if ((WriteByte & 0x01) || (PacketBytes[0] == AICB_CMD_PROGRAM_EEPROM_ISP))
			   V2P_IncrementCurrAddress();

			ISPCC_PollForProgComplete(PollType, PollAddress);
		}
	}
}

void ISPCC_PollForProgComplete(const uint8_t PollData, uint16_t PollAddr)
{
    2296:	1f 93       	push	r17
    2298:	cf 93       	push	r28
    229a:	df 93       	push	r29
    229c:	eb 01       	movw	r28, r22
	uint8_t PollType;
	uint8_t ProgCommand;

	if (PollData & ISPCC_PROG_MODE_PAGE)
    229e:	99 27       	eor	r25, r25
    22a0:	80 ff       	sbrs	r24, 0
    22a2:	08 c0       	rjmp	.+16     	; 0x22b4 <ISPCC_PollForProgComplete+0x1e>
	   PollType = ((PollData & ISPCC_PAGE_POLLTYPE_MASK) >> ISPCC_PAGE_POLLTYPE_MASKSHIFT);
    22a4:	80 77       	andi	r24, 0x70	; 112
    22a6:	90 70       	andi	r25, 0x00	; 0
    22a8:	34 e0       	ldi	r19, 0x04	; 4
    22aa:	95 95       	asr	r25
    22ac:	87 95       	ror	r24
    22ae:	3a 95       	dec	r19
    22b0:	e1 f7       	brne	.-8      	; 0x22aa <ISPCC_PollForProgComplete+0x14>
    22b2:	04 c0       	rjmp	.+8      	; 0x22bc <ISPCC_PollForProgComplete+0x26>
	else
	   PollType = ((PollData & ISPCC_WORD_POLLTYPE_MASK) >> ISPCC_WORD_POLLTYPE_MASKSHIFT);	
    22b4:	8e 70       	andi	r24, 0x0E	; 14
    22b6:	90 70       	andi	r25, 0x00	; 0
    22b8:	95 95       	asr	r25
    22ba:	87 95       	ror	r24

	switch (PollType & ISPCC_POLLTYPE_MASK)
    22bc:	99 27       	eor	r25, r25
    22be:	87 70       	andi	r24, 0x07	; 7
    22c0:	90 70       	andi	r25, 0x00	; 0
    22c2:	82 30       	cpi	r24, 0x02	; 2
    22c4:	91 05       	cpc	r25, r1
    22c6:	19 f0       	breq	.+6      	; 0x22ce <ISPCC_PollForProgComplete+0x38>
    22c8:	04 97       	sbiw	r24, 0x04	; 4
    22ca:	e1 f0       	breq	.+56     	; 0x2304 <ISPCC_PollForProgComplete+0x6e>
    22cc:	26 c0       	rjmp	.+76     	; 0x231a <ISPCC_PollForProgComplete+0x84>
	{
		case ISPCC_POLLTYPE_DATA:
			ProgCommand = PacketBytes[7];
    22ce:	10 91 52 01 	lds	r17, 0x0152
			
			if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP) // Flash uses word addresses
    22d2:	80 91 4b 01 	lds	r24, 0x014B
    22d6:	83 31       	cpi	r24, 0x13	; 19
    22d8:	39 f4       	brne	.+14     	; 0x22e8 <ISPCC_PollForProgComplete+0x52>
			{
				ProgCommand  |= ((PollAddr & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ);
    22da:	81 2f       	mov	r24, r17
    22dc:	99 27       	eor	r25, r25
    22de:	c0 fd       	sbrc	r28, 0
    22e0:	88 60       	ori	r24, 0x08	; 8
    22e2:	18 2f       	mov	r17, r24
				PollAddr    >>= 1;
    22e4:	d6 95       	lsr	r29
    22e6:	c7 95       	ror	r28
			}

			do
			{
				USI_SPITransmit(ProgCommand);
    22e8:	81 2f       	mov	r24, r17
    22ea:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
				USI_SPITransmitWord(PollAddr);
    22ee:	ce 01       	movw	r24, r28
    22f0:	0e 94 bb 09 	call	0x1376 <USI_SPITransmitWord>
			}
    22f4:	80 e0       	ldi	r24, 0x00	; 0
    22f6:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    22fa:	90 91 53 01 	lds	r25, 0x0153
    22fe:	89 17       	cp	r24, r25
    2300:	99 f3       	breq	.-26     	; 0x22e8 <ISPCC_PollForProgComplete+0x52>
			while (USI_SPITransmit(0x00) == PacketBytes[8]);
						
			break;
    2302:	0f c0       	rjmp	.+30     	; 0x2322 <ISPCC_PollForProgComplete+0x8c>
		case ISPCC_POLLTYPE_READY:
			do
			   USI_SPITransmitWord(0xF000);
    2304:	80 e0       	ldi	r24, 0x00	; 0
    2306:	90 ef       	ldi	r25, 0xF0	; 240
    2308:	0e 94 bb 09 	call	0x1376 <USI_SPITransmitWord>
    230c:	80 e0       	ldi	r24, 0x00	; 0
    230e:	90 e0       	ldi	r25, 0x00	; 0
    2310:	0e 94 bb 09 	call	0x1376 <USI_SPITransmitWord>
    2314:	80 fd       	sbrc	r24, 0
    2316:	f6 cf       	rjmp	.-20     	; 0x2304 <ISPCC_PollForProgComplete+0x6e>
			while (USI_SPITransmitWord(0x0000) & ISPCC_POLL_BUSYFLAG);

			break;
    2318:	04 c0       	rjmp	.+8      	; 0x2322 <ISPCC_PollForProgComplete+0x8c>
		default:                                      // Default is Wait polling
			MAIN_Delay1MS(PacketBytes[4]);	
    231a:	80 91 4f 01 	lds	r24, 0x014F
    231e:	0e 94 08 03 	call	0x610 <MAIN_Delay1MS>
    2322:	df 91       	pop	r29
    2324:	cf 91       	pop	r28
    2326:	1f 91       	pop	r17
    2328:	08 95       	ret

0000232a <ISPCC_ProgramChip>:
    232a:	6f 92       	push	r6
    232c:	7f 92       	push	r7
    232e:	9f 92       	push	r9
    2330:	af 92       	push	r10
    2332:	bf 92       	push	r11
    2334:	cf 92       	push	r12
    2336:	df 92       	push	r13
    2338:	ef 92       	push	r14
    233a:	ff 92       	push	r15
    233c:	0f 93       	push	r16
    233e:	1f 93       	push	r17
    2340:	cf 93       	push	r28
    2342:	df 93       	push	r29
    2344:	00 e0       	ldi	r16, 0x00	; 0
    2346:	10 e0       	ldi	r17, 0x00	; 0
    2348:	90 90 4e 01 	lds	r9, 0x014E
    234c:	c0 90 50 01 	lds	r12, 0x0150
    2350:	60 90 42 01 	lds	r6, 0x0142
    2354:	70 90 43 01 	lds	r7, 0x0143
    2358:	80 91 4c 01 	lds	r24, 0x014C
    235c:	99 27       	eor	r25, r25
    235e:	b8 2e       	mov	r11, r24
    2360:	aa 24       	eor	r10, r10
    2362:	80 91 4d 01 	lds	r24, 0x014D
    2366:	99 27       	eor	r25, r25
    2368:	a8 2a       	or	r10, r24
    236a:	b9 2a       	or	r11, r25
    236c:	90 fe       	sbrs	r9, 0
    236e:	62 c0       	rjmp	.+196    	; 0x2434 <ISPCC_ProgramChip+0x10a>
    2370:	78 01       	movw	r14, r16
    2372:	0a 15       	cp	r16, r10
    2374:	1b 05       	cpc	r17, r11
    2376:	08 f0       	brcs	.+2      	; 0x237a <ISPCC_ProgramChip+0x50>
    2378:	46 c0       	rjmp	.+140    	; 0x2406 <ISPCC_ProgramChip+0xdc>
    237a:	c5 e5       	ldi	r28, 0x55	; 85
    237c:	d1 e0       	ldi	r29, 0x01	; 1
    237e:	d9 90       	ld	r13, Y+
    2380:	80 91 4b 01 	lds	r24, 0x014B
    2384:	83 31       	cpi	r24, 0x13	; 19
    2386:	31 f4       	brne	.+12     	; 0x2394 <ISPCC_ProgramChip+0x6a>
    2388:	8c 2d       	mov	r24, r12
    238a:	99 27       	eor	r25, r25
    238c:	e0 fe       	sbrs	r14, 0
    238e:	03 c0       	rjmp	.+6      	; 0x2396 <ISPCC_ProgramChip+0x6c>
    2390:	88 60       	ori	r24, 0x08	; 8
    2392:	01 c0       	rjmp	.+2      	; 0x2396 <ISPCC_ProgramChip+0x6c>
    2394:	8c 2d       	mov	r24, r12
    2396:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    239a:	80 91 42 01 	lds	r24, 0x0142
    239e:	90 91 43 01 	lds	r25, 0x0143
    23a2:	0e 94 bb 09 	call	0x1376 <USI_SPITransmitWord>
    23a6:	8d 2d       	mov	r24, r13
    23a8:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    23ac:	01 15       	cp	r16, r1
    23ae:	11 05       	cpc	r17, r1
    23b0:	d9 f4       	brne	.+54     	; 0x23e8 <ISPCC_ProgramChip+0xbe>
    23b2:	80 91 53 01 	lds	r24, 0x0153
    23b6:	8d 15       	cp	r24, r13
    23b8:	b9 f0       	breq	.+46     	; 0x23e8 <ISPCC_ProgramChip+0xbe>
    23ba:	90 91 4b 01 	lds	r25, 0x014B
    23be:	93 31       	cpi	r25, 0x13	; 19
    23c0:	31 f0       	breq	.+12     	; 0x23ce <ISPCC_ProgramChip+0xa4>
    23c2:	95 31       	cpi	r25, 0x15	; 21
    23c4:	89 f4       	brne	.+34     	; 0x23e8 <ISPCC_ProgramChip+0xbe>
    23c6:	80 91 54 01 	lds	r24, 0x0154
    23ca:	8d 15       	cp	r24, r13
    23cc:	69 f0       	breq	.+26     	; 0x23e8 <ISPCC_ProgramChip+0xbe>
    23ce:	00 91 42 01 	lds	r16, 0x0142
    23d2:	10 91 43 01 	lds	r17, 0x0143
    23d6:	93 31       	cpi	r25, 0x13	; 19
    23d8:	39 f4       	brne	.+14     	; 0x23e8 <ISPCC_ProgramChip+0xbe>
    23da:	00 0f       	add	r16, r16
    23dc:	11 1f       	adc	r17, r17
    23de:	c7 01       	movw	r24, r14
    23e0:	81 70       	andi	r24, 0x01	; 1
    23e2:	90 70       	andi	r25, 0x00	; 0
    23e4:	08 0f       	add	r16, r24
    23e6:	19 1f       	adc	r17, r25
    23e8:	e0 fc       	sbrc	r14, 0
    23ea:	04 c0       	rjmp	.+8      	; 0x23f4 <ISPCC_ProgramChip+0xca>
    23ec:	80 91 4b 01 	lds	r24, 0x014B
    23f0:	85 31       	cpi	r24, 0x15	; 21
    23f2:	11 f4       	brne	.+4      	; 0x23f8 <ISPCC_ProgramChip+0xce>
    23f4:	0e 94 46 0f 	call	0x1e8c <V2P_IncrementCurrAddress>
    23f8:	08 94       	sec
    23fa:	e1 1c       	adc	r14, r1
    23fc:	f1 1c       	adc	r15, r1
    23fe:	ea 14       	cp	r14, r10
    2400:	fb 04       	cpc	r15, r11
    2402:	08 f4       	brcc	.+2      	; 0x2406 <ISPCC_ProgramChip+0xdc>
    2404:	bc cf       	rjmp	.-136    	; 0x237e <ISPCC_ProgramChip+0x54>
    2406:	c9 2d       	mov	r28, r9
    2408:	97 fe       	sbrs	r9, 7
    240a:	69 c0       	rjmp	.+210    	; 0x24de <ISPCC_ProgramChip+0x1b4>
    240c:	80 91 51 01 	lds	r24, 0x0151
    2410:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    2414:	c3 01       	movw	r24, r6
    2416:	0e 94 bb 09 	call	0x1376 <USI_SPITransmitWord>
    241a:	80 e0       	ldi	r24, 0x00	; 0
    241c:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    2420:	01 15       	cp	r16, r1
    2422:	11 05       	cpc	r17, r1
    2424:	11 f4       	brne	.+4      	; 0x242a <ISPCC_ProgramChip+0x100>
    2426:	cf 78       	andi	r28, 0x8F	; 143
    2428:	c0 61       	ori	r28, 0x10	; 16
    242a:	b8 01       	movw	r22, r16
    242c:	8c 2f       	mov	r24, r28
    242e:	0e 94 4b 11 	call	0x2296 <ISPCC_PollForProgComplete>
    2432:	55 c0       	rjmp	.+170    	; 0x24de <ISPCC_ProgramChip+0x1b4>
    2434:	78 01       	movw	r14, r16
    2436:	0a 15       	cp	r16, r10
    2438:	1b 05       	cpc	r17, r11
    243a:	08 f0       	brcs	.+2      	; 0x243e <ISPCC_ProgramChip+0x114>
    243c:	50 c0       	rjmp	.+160    	; 0x24de <ISPCC_ProgramChip+0x1b4>
    243e:	55 e5       	ldi	r21, 0x55	; 85
    2440:	65 2e       	mov	r6, r21
    2442:	51 e0       	ldi	r21, 0x01	; 1
    2444:	75 2e       	mov	r7, r21
    2446:	f3 01       	movw	r30, r6
    2448:	d1 90       	ld	r13, Z+
    244a:	3f 01       	movw	r6, r30
    244c:	80 91 4b 01 	lds	r24, 0x014B
    2450:	83 31       	cpi	r24, 0x13	; 19
    2452:	31 f4       	brne	.+12     	; 0x2460 <ISPCC_ProgramChip+0x136>
    2454:	8c 2d       	mov	r24, r12
    2456:	99 27       	eor	r25, r25
    2458:	e0 fe       	sbrs	r14, 0
    245a:	03 c0       	rjmp	.+6      	; 0x2462 <ISPCC_ProgramChip+0x138>
    245c:	88 60       	ori	r24, 0x08	; 8
    245e:	01 c0       	rjmp	.+2      	; 0x2462 <ISPCC_ProgramChip+0x138>
    2460:	8c 2d       	mov	r24, r12
    2462:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    2466:	80 91 42 01 	lds	r24, 0x0142
    246a:	90 91 43 01 	lds	r25, 0x0143
    246e:	0e 94 bb 09 	call	0x1376 <USI_SPITransmitWord>
    2472:	8d 2d       	mov	r24, r13
    2474:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    2478:	c9 2d       	mov	r28, r9
    247a:	80 91 53 01 	lds	r24, 0x0153
    247e:	8d 15       	cp	r24, r13
    2480:	c1 f0       	breq	.+48     	; 0x24b2 <ISPCC_ProgramChip+0x188>
    2482:	90 91 4b 01 	lds	r25, 0x014B
    2486:	93 31       	cpi	r25, 0x13	; 19
    2488:	31 f0       	breq	.+12     	; 0x2496 <ISPCC_ProgramChip+0x16c>
    248a:	95 31       	cpi	r25, 0x15	; 21
    248c:	91 f4       	brne	.+36     	; 0x24b2 <ISPCC_ProgramChip+0x188>
    248e:	80 91 54 01 	lds	r24, 0x0154
    2492:	8d 15       	cp	r24, r13
    2494:	71 f0       	breq	.+28     	; 0x24b2 <ISPCC_ProgramChip+0x188>
    2496:	00 91 42 01 	lds	r16, 0x0142
    249a:	10 91 43 01 	lds	r17, 0x0143
    249e:	93 31       	cpi	r25, 0x13	; 19
    24a0:	59 f4       	brne	.+22     	; 0x24b8 <ISPCC_ProgramChip+0x18e>
    24a2:	00 0f       	add	r16, r16
    24a4:	11 1f       	adc	r17, r17
    24a6:	c7 01       	movw	r24, r14
    24a8:	81 70       	andi	r24, 0x01	; 1
    24aa:	90 70       	andi	r25, 0x00	; 0
    24ac:	08 0f       	add	r16, r24
    24ae:	19 1f       	adc	r17, r25
    24b0:	03 c0       	rjmp	.+6      	; 0x24b8 <ISPCC_ProgramChip+0x18e>
    24b2:	c9 2d       	mov	r28, r9
    24b4:	c1 7f       	andi	r28, 0xF1	; 241
    24b6:	c2 60       	ori	r28, 0x02	; 2
    24b8:	e0 fc       	sbrc	r14, 0
    24ba:	04 c0       	rjmp	.+8      	; 0x24c4 <ISPCC_ProgramChip+0x19a>
    24bc:	80 91 4b 01 	lds	r24, 0x014B
    24c0:	85 31       	cpi	r24, 0x15	; 21
    24c2:	11 f4       	brne	.+4      	; 0x24c8 <ISPCC_ProgramChip+0x19e>
    24c4:	0e 94 46 0f 	call	0x1e8c <V2P_IncrementCurrAddress>
    24c8:	b8 01       	movw	r22, r16
    24ca:	8c 2f       	mov	r24, r28
    24cc:	0e 94 4b 11 	call	0x2296 <ISPCC_PollForProgComplete>
    24d0:	08 94       	sec
    24d2:	e1 1c       	adc	r14, r1
    24d4:	f1 1c       	adc	r15, r1
    24d6:	ea 14       	cp	r14, r10
    24d8:	fb 04       	cpc	r15, r11
    24da:	08 f4       	brcc	.+2      	; 0x24de <ISPCC_ProgramChip+0x1b4>
    24dc:	b4 cf       	rjmp	.-152    	; 0x2446 <ISPCC_ProgramChip+0x11c>
    24de:	df 91       	pop	r29
    24e0:	cf 91       	pop	r28
    24e2:	1f 91       	pop	r17
    24e4:	0f 91       	pop	r16
    24e6:	ff 90       	pop	r15
    24e8:	ef 90       	pop	r14
    24ea:	df 90       	pop	r13
    24ec:	cf 90       	pop	r12
    24ee:	bf 90       	pop	r11
    24f0:	af 90       	pop	r10
    24f2:	9f 90       	pop	r9
    24f4:	7f 90       	pop	r7
    24f6:	6f 90       	pop	r6
    24f8:	08 95       	ret

000024fa <AICI_InterpretPacket>:

// ======================================================================================

void AICI_InterpretPacket(void)
{
    24fa:	df 92       	push	r13
    24fc:	ef 92       	push	r14
    24fe:	ff 92       	push	r15
    2500:	0f 93       	push	r16
    2502:	1f 93       	push	r17
    2504:	cf 93       	push	r28
    2506:	df 93       	push	r29
	switch (PacketBytes[0])
    2508:	80 91 4b 01 	lds	r24, 0x014B
    250c:	99 27       	eor	r25, r25
    250e:	86 31       	cpi	r24, 0x16	; 22
    2510:	91 05       	cpc	r25, r1
    2512:	09 f4       	brne	.+2      	; 0x2516 <AICI_InterpretPacket+0x1c>
    2514:	fb c0       	rjmp	.+502    	; 0x270c <AICI_InterpretPacket+0x212>
    2516:	87 31       	cpi	r24, 0x17	; 23
    2518:	91 05       	cpc	r25, r1
    251a:	94 f4       	brge	.+36     	; 0x2540 <AICI_InterpretPacket+0x46>
    251c:	82 31       	cpi	r24, 0x12	; 18
    251e:	91 05       	cpc	r25, r1
    2520:	09 f4       	brne	.+2      	; 0x2524 <AICI_InterpretPacket+0x2a>
    2522:	60 c0       	rjmp	.+192    	; 0x25e4 <AICI_InterpretPacket+0xea>
    2524:	83 31       	cpi	r24, 0x13	; 19
    2526:	91 05       	cpc	r25, r1
    2528:	3c f4       	brge	.+14     	; 0x2538 <AICI_InterpretPacket+0x3e>
    252a:	80 31       	cpi	r24, 0x10	; 16
    252c:	91 05       	cpc	r25, r1
    252e:	f9 f0       	breq	.+62     	; 0x256e <AICI_InterpretPacket+0x74>
    2530:	41 97       	sbiw	r24, 0x11	; 17
    2532:	09 f4       	brne	.+2      	; 0x2536 <AICI_InterpretPacket+0x3c>
    2534:	3d c0       	rjmp	.+122    	; 0x25b0 <AICI_InterpretPacket+0xb6>
    2536:	3e c1       	rjmp	.+636    	; 0x27b4 <AICI_InterpretPacket+0x2ba>
    2538:	44 97       	sbiw	r24, 0x14	; 20
    253a:	09 f4       	brne	.+2      	; 0x253e <AICI_InterpretPacket+0x44>
    253c:	e7 c0       	rjmp	.+462    	; 0x270c <AICI_InterpretPacket+0x212>
    253e:	2f c1       	rjmp	.+606    	; 0x279e <AICI_InterpretPacket+0x2a4>
    2540:	89 31       	cpi	r24, 0x19	; 25
    2542:	91 05       	cpc	r25, r1
    2544:	09 f4       	brne	.+2      	; 0x2548 <AICI_InterpretPacket+0x4e>
    2546:	cc c0       	rjmp	.+408    	; 0x26e0 <AICI_InterpretPacket+0x1e6>
    2548:	8a 31       	cpi	r24, 0x1A	; 26
    254a:	91 05       	cpc	r25, r1
    254c:	44 f4       	brge	.+16     	; 0x255e <AICI_InterpretPacket+0x64>
    254e:	87 31       	cpi	r24, 0x17	; 23
    2550:	91 05       	cpc	r25, r1
    2552:	09 f4       	brne	.+2      	; 0x2556 <AICI_InterpretPacket+0x5c>
    2554:	c5 c0       	rjmp	.+394    	; 0x26e0 <AICI_InterpretPacket+0x1e6>
    2556:	48 97       	sbiw	r24, 0x18	; 24
    2558:	09 f4       	brne	.+2      	; 0x255c <AICI_InterpretPacket+0x62>
    255a:	a5 c0       	rjmp	.+330    	; 0x26a6 <AICI_InterpretPacket+0x1ac>
    255c:	2b c1       	rjmp	.+598    	; 0x27b4 <AICI_InterpretPacket+0x2ba>
    255e:	8d 31       	cpi	r24, 0x1D	; 29
    2560:	91 05       	cpc	r25, r1
    2562:	0c f4       	brge	.+2      	; 0x2566 <AICI_InterpretPacket+0x6c>
    2564:	a0 c0       	rjmp	.+320    	; 0x26a6 <AICI_InterpretPacket+0x1ac>
    2566:	4d 97       	sbiw	r24, 0x1d	; 29
    2568:	09 f4       	brne	.+2      	; 0x256c <AICI_InterpretPacket+0x72>
    256a:	61 c0       	rjmp	.+194    	; 0x262e <AICI_InterpretPacket+0x134>
    256c:	23 c1       	rjmp	.+582    	; 0x27b4 <AICI_InterpretPacket+0x2ba>
	{
		case AICB_CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
    256e:	82 e0       	ldi	r24, 0x02	; 2
    2570:	90 e0       	ldi	r25, 0x00	; 0
    2572:	90 93 48 01 	sts	0x0148, r25
    2576:	80 93 47 01 	sts	0x0147, r24
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    257a:	a1 e0       	ldi	r26, 0x01	; 1
    257c:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    257e:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
    2582:	80 2d       	mov	r24, r0
    2584:	0e 94 8e 09 	call	0x131c <USI_SPIInitMaster>
			
			USI_SPIInitMaster(eeprom_read_byte(&EEPROMVars.SCKDuration));

			MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);  // Pull the slave AVR's RESET line to active
    2588:	80 e0       	ldi	r24, 0x00	; 0
    258a:	0e 94 1a 03 	call	0x634 <MAIN_ResetCSLine>
			MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE); // Orange = Busy
    258e:	81 b3       	in	r24, 0x11	; 17
    2590:	80 63       	ori	r24, 0x30	; 48
    2592:	81 bb       	out	0x11, r24	; 17
			ISPCC_EnterChipProgrammingMode();       // Run the Enter Programming Mode routine
    2594:	0e 94 ed 10 	call	0x21da <ISPCC_EnterChipProgrammingMode>

			if (InProgrammingMode)
    2598:	80 91 46 01 	lds	r24, 0x0146
    259c:	88 23       	and	r24, r24
    259e:	19 f0       	breq	.+6      	; 0x25a6 <AICI_InterpretPacket+0xac>
			   LCD_puts_f(AVRISPModeMessage);
    25a0:	88 ef       	ldi	r24, 0xF8	; 248
    25a2:	93 e0       	ldi	r25, 0x03	; 3
    25a4:	02 c0       	rjmp	.+4      	; 0x25aa <AICI_InterpretPacket+0xb0>
			else
			   LCD_puts_f(SyncErrorMessage);
    25a6:	8d ee       	ldi	r24, 0xED	; 237
    25a8:	93 e0       	ldi	r25, 0x03	; 3
    25aa:	0e 94 5a 08 	call	0x10b4 <LCD_puts_f>
			
			break;
    25ae:	0b c1       	rjmp	.+534    	; 0x27c6 <AICI_InterpretPacket+0x2cc>
		case AICB_CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;
    25b0:	82 e0       	ldi	r24, 0x02	; 2
    25b2:	90 e0       	ldi	r25, 0x00	; 0
    25b4:	90 93 48 01 	sts	0x0148, r25
    25b8:	80 93 47 01 	sts	0x0147, r24

			MAIN_Delay1MS(PacketBytes[1]);           // Wait for the "PreDelay" amount specified in the packet
    25bc:	80 91 4c 01 	lds	r24, 0x014C
    25c0:	0e 94 08 03 	call	0x610 <MAIN_Delay1MS>
			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Non programming mode = green status led
    25c4:	81 b3       	in	r24, 0x11	; 17
    25c6:	8f 7c       	andi	r24, 0xCF	; 207
    25c8:	80 61       	ori	r24, 0x10	; 16
    25ca:	81 bb       	out	0x11, r24	; 17
			InProgrammingMode = FALSE;
    25cc:	10 92 46 01 	sts	0x0146, r1
			MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run
    25d0:	81 e0       	ldi	r24, 0x01	; 1
    25d2:	0e 94 1a 03 	call	0x634 <MAIN_ResetCSLine>
			MAIN_Delay1MS(PacketBytes[2]);           // Wait for the "PostDelay" amount specified in the packet
    25d6:	80 91 4d 01 	lds	r24, 0x014D
    25da:	0e 94 08 03 	call	0x610 <MAIN_Delay1MS>
			
			USI_SPIOff();
    25de:	0e 94 9e 09 	call	0x133c <USI_SPIOff>
    25e2:	e5 c0       	rjmp	.+458    	; 0x27ae <AICI_InterpretPacket+0x2b4>

			PacketBytes[1] = AICB_STATUS_CMD_OK;     // Return OK

			break;
		case AICB_CMD_CHIP_ERASE_ISP:
			MessageSize = 2;
    25e4:	82 e0       	ldi	r24, 0x02	; 2
    25e6:	90 e0       	ldi	r25, 0x00	; 0
    25e8:	90 93 48 01 	sts	0x0148, r25
    25ec:	80 93 47 01 	sts	0x0147, r24
			
			for (uint8_t PacketB = 3; PacketB <= 6; PacketB++) // Send the erase commands to the slave AVR
    25f0:	c3 e0       	ldi	r28, 0x03	; 3
    25f2:	0e e4       	ldi	r16, 0x4E	; 78
    25f4:	11 e0       	ldi	r17, 0x01	; 1
				USI_SPITransmit(PacketBytes[PacketB]);
    25f6:	f8 01       	movw	r30, r16
    25f8:	81 91       	ld	r24, Z+
    25fa:	8f 01       	movw	r16, r30
    25fc:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    2600:	c1 50       	subi	r28, 0x01	; 1
    2602:	c7 ff       	sbrs	r28, 7
    2604:	f8 cf       	rjmp	.-16     	; 0x25f6 <AICI_InterpretPacket+0xfc>

			if (PacketBytes[2])                       // Poll mode, value of 1 indicates a busy flag wait
    2606:	80 91 4d 01 	lds	r24, 0x014D
    260a:	88 23       	and	r24, r24
    260c:	59 f0       	breq	.+22     	; 0x2624 <AICI_InterpretPacket+0x12a>
			{
				do
					USI_SPITransmitWord(0xF000);
    260e:	80 e0       	ldi	r24, 0x00	; 0
    2610:	90 ef       	ldi	r25, 0xF0	; 240
    2612:	0e 94 bb 09 	call	0x1376 <USI_SPITransmitWord>
    2616:	80 e0       	ldi	r24, 0x00	; 0
    2618:	90 e0       	ldi	r25, 0x00	; 0
    261a:	0e 94 bb 09 	call	0x1376 <USI_SPITransmitWord>
    261e:	80 fd       	sbrc	r24, 0
    2620:	f6 cf       	rjmp	.-20     	; 0x260e <AICI_InterpretPacket+0x114>
    2622:	c5 c0       	rjmp	.+394    	; 0x27ae <AICI_InterpretPacket+0x2b4>
				while (USI_SPITransmitWord(0x0000) & 0x01);
			}
			else                                      // Poll mode flag of 0 indicates a predefined delay
			{
				MAIN_Delay1MS(PacketBytes[1]);         // Wait the specified interval to ensure erase complete
    2624:	80 91 4c 01 	lds	r24, 0x014C
    2628:	0e 94 08 03 	call	0x610 <MAIN_Delay1MS>
    262c:	c0 c0       	rjmp	.+384    	; 0x27ae <AICI_InterpretPacket+0x2b4>
			}
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Always return OK
			
			break;
		case AICB_CMD_SPI_MULTI:
				MessageSize = (3 + PacketBytes[2]);    // Number of recieved bytes, plus two OKs and the command byte
    262e:	e0 90 4d 01 	lds	r14, 0x014D
    2632:	8e 2d       	mov	r24, r14
    2634:	99 27       	eor	r25, r25
    2636:	03 96       	adiw	r24, 0x03	; 3
    2638:	90 93 48 01 	sts	0x0148, r25
    263c:	80 93 47 01 	sts	0x0147, r24
		
				uint8_t TxBytes      = PacketBytes[1]; // \. The packet data is overwritten during the transfer. Because
    2640:	00 91 4c 01 	lds	r16, 0x014C
				uint8_t RxStartByte  = PacketBytes[2]; // |  of this each data byte must be stored into temp variables
				uint8_t RxBytes      = PacketBytes[3]; // /  so that their contents are not lost.
    2644:	f0 90 4e 01 	lds	r15, 0x014E
				uint8_t RxByteNum    = 1;
    2648:	c1 e0       	ldi	r28, 0x01	; 1
				uint8_t TxByteNum    = 1;
				uint8_t RecievedByte = 0;

				while (TxByteNum++ < TxBytes)          // Still bytes to transfer
				{
					RecievedByte = USI_SPITransmit(PacketBytes[3 + TxByteNum]); // Transmit the byte, store the answer

					if ((TxByteNum >= RxStartByte) && (RxByteNum < RxBytes))
					   PacketBytes[2 + RxByteNum++] = RecievedByte;
    264a:	12 e0       	ldi	r17, 0x02	; 2
    264c:	c0 17       	cp	r28, r16
    264e:	a8 f4       	brcc	.+42     	; 0x267a <AICI_InterpretPacket+0x180>
    2650:	e1 2f       	mov	r30, r17
    2652:	ff 27       	eor	r31, r31
    2654:	e5 5b       	subi	r30, 0xB5	; 181
    2656:	fe 4f       	sbci	r31, 0xFE	; 254
    2658:	83 81       	ldd	r24, Z+3	; 0x03
    265a:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    265e:	1e 15       	cp	r17, r14
    2660:	40 f0       	brcs	.+16     	; 0x2672 <AICI_InterpretPacket+0x178>
    2662:	cf 15       	cp	r28, r15
    2664:	30 f4       	brcc	.+12     	; 0x2672 <AICI_InterpretPacket+0x178>
    2666:	ec 2f       	mov	r30, r28
    2668:	ff 27       	eor	r31, r31
    266a:	e5 5b       	subi	r30, 0xB5	; 181
    266c:	fe 4f       	sbci	r31, 0xFE	; 254
    266e:	82 83       	std	Z+2, r24	; 0x02
    2670:	cf 5f       	subi	r28, 0xFF	; 255
    2672:	81 2f       	mov	r24, r17
    2674:	1f 5f       	subi	r17, 0xFF	; 255
    2676:	80 17       	cp	r24, r16
    2678:	58 f3       	brcs	.-42     	; 0x2650 <AICI_InterpretPacket+0x156>
				}

				while (RxByteNum++ < RxBytes)                         // Still more bytes to recieve
				   PacketBytes[2 + RxByteNum] = USI_SPITransmit(0x00); // its answer to be recorded (or more bytes than sent need responses), send dummy bytes to fetch the response(s)
    267a:	8c 2f       	mov	r24, r28
    267c:	cf 5f       	subi	r28, 0xFF	; 255
    267e:	8f 15       	cp	r24, r15
    2680:	50 f4       	brcc	.+20     	; 0x2696 <AICI_InterpretPacket+0x19c>
    2682:	0c 2f       	mov	r16, r28
    2684:	11 27       	eor	r17, r17
    2686:	05 5b       	subi	r16, 0xB5	; 181
    2688:	1e 4f       	sbci	r17, 0xFE	; 254
    268a:	80 e0       	ldi	r24, 0x00	; 0
    268c:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    2690:	f8 01       	movw	r30, r16
    2692:	82 83       	std	Z+2, r24	; 0x02
    2694:	f2 cf       	rjmp	.-28     	; 0x267a <AICI_InterpretPacket+0x180>

				PacketBytes[1]             = AICB_STATUS_CMD_OK; // Data should be encompassed
    2696:	10 92 4c 01 	sts	0x014C, r1
				PacketBytes[3 + RxByteNum] = AICB_STATUS_CMD_OK; //  by STATS_CMD_OKs
    269a:	ec 2f       	mov	r30, r28
    269c:	ff 27       	eor	r31, r31
    269e:	e5 5b       	subi	r30, 0xB5	; 181
    26a0:	fe 4f       	sbci	r31, 0xFE	; 254
    26a2:	13 82       	std	Z+3, r1	; 0x03

				break;
    26a4:	90 c0       	rjmp	.+288    	; 0x27c6 <AICI_InterpretPacket+0x2cc>
		case AICB_CMD_READ_SIGNATURE_ISP:
		case AICB_CMD_READ_FUSE_ISP:
		case AICB_CMD_READ_LOCK_ISP:
		case AICB_CMD_READ_OSCCAL_ISP:
			MessageSize = 4;
    26a6:	84 e0       	ldi	r24, 0x04	; 4
    26a8:	90 e0       	ldi	r25, 0x00	; 0
    26aa:	90 93 48 01 	sts	0x0148, r25
    26ae:	80 93 47 01 	sts	0x0147, r24
	
			for (uint8_t ByteNum = 1; ByteNum <= 4; ByteNum++)
    26b2:	c1 e0       	ldi	r28, 0x01	; 1
    26b4:	0d e4       	ldi	r16, 0x4D	; 77
    26b6:	11 e0       	ldi	r17, 0x01	; 1
			{
				uint8_t Response = USI_SPITransmit(PacketBytes[1 + ByteNum]); // Transmit the four signature request bytes
    26b8:	f8 01       	movw	r30, r16
    26ba:	81 91       	ld	r24, Z+
    26bc:	8f 01       	movw	r16, r30
    26be:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    26c2:	98 2f       	mov	r25, r24

				if (ByteNum == PacketBytes[1])         // If the current byte is the requested signature byte, save the reponse in the packet
    26c4:	80 91 4c 01 	lds	r24, 0x014C
    26c8:	c8 17       	cp	r28, r24
    26ca:	11 f4       	brne	.+4      	; 0x26d0 <AICI_InterpretPacket+0x1d6>
					PacketBytes[2] = Response;
    26cc:	90 93 4d 01 	sts	0x014D, r25
    26d0:	cf 5f       	subi	r28, 0xFF	; 255
    26d2:	c5 30       	cpi	r28, 0x05	; 5
    26d4:	88 f3       	brcs	.-30     	; 0x26b8 <AICI_InterpretPacket+0x1be>
			}

			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Data byte is encased in CMD_OKs
    26d6:	10 92 4c 01 	sts	0x014C, r1
			PacketBytes[3] = AICB_STATUS_CMD_OK;       // Data byte is encased in CMD_OKs
    26da:	10 92 4e 01 	sts	0x014E, r1

			break;
    26de:	73 c0       	rjmp	.+230    	; 0x27c6 <AICI_InterpretPacket+0x2cc>
		case AICB_CMD_PROGRAM_FUSE_ISP:
		case AICB_CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;
    26e0:	83 e0       	ldi	r24, 0x03	; 3
    26e2:	90 e0       	ldi	r25, 0x00	; 0
    26e4:	90 93 48 01 	sts	0x0148, r25
    26e8:	80 93 47 01 	sts	0x0147, r24
    26ec:	0c e4       	ldi	r16, 0x4C	; 76
    26ee:	11 e0       	ldi	r17, 0x01	; 1
    26f0:	c3 e0       	ldi	r28, 0x03	; 3
			
			for (uint8_t PacketB = 1; PacketB <= 4; PacketB++) // Send the lock-byte values to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    26f2:	f8 01       	movw	r30, r16
    26f4:	81 91       	ld	r24, Z+
    26f6:	8f 01       	movw	r16, r30
    26f8:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    26fc:	c1 50       	subi	r28, 0x01	; 1
    26fe:	c7 ff       	sbrs	r28, 7
    2700:	f8 cf       	rjmp	.-16     	; 0x26f2 <AICI_InterpretPacket+0x1f8>

			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Two CMD_OKs are always returned
    2702:	10 92 4c 01 	sts	0x014C, r1
			PacketBytes[2] = AICB_STATUS_CMD_OK;       // Two CMD_OKs are always returned
    2706:	10 92 4d 01 	sts	0x014D, r1

			break;
    270a:	5d c0       	rjmp	.+186    	; 0x27c6 <AICI_InterpretPacket+0x2cc>
		case AICB_CMD_READ_FLASH_ISP:
		case AICB_CMD_READ_EEPROM_ISP:
			MessageSize = 0;                           // Here to prevent compiler from complaining if a var dec appears straight after a case

			uint8_t  ReadCommand = PacketBytes[3];
    270c:	d0 90 4e 01 	lds	r13, 0x014E
			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8) // Load in the number of bytes that is to
    2710:	80 91 4c 01 	lds	r24, 0x014C
    2714:	99 27       	eor	r25, r25
    2716:	d8 2f       	mov	r29, r24
    2718:	cc 27       	eor	r28, r28
    271a:	80 91 4d 01 	lds	r24, 0x014D
    271e:	99 27       	eor	r25, r25
    2720:	c8 2b       	or	r28, r24
    2722:	d9 2b       	or	r29, r25
			                     | PacketBytes[2];                 // be read into a temp variable (MSB first)

			MessageSize = BytesToRead + 3;
    2724:	23 96       	adiw	r28, 0x03	; 3
    2726:	d0 93 48 01 	sts	0x0148, r29
    272a:	c0 93 47 01 	sts	0x0147, r28
    272e:	23 97       	sbiw	r28, 0x03	; 3

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
    2730:	00 e0       	ldi	r16, 0x00	; 0
    2732:	10 e0       	ldi	r17, 0x00	; 0
    2734:	0c 17       	cp	r16, r28
    2736:	1d 07       	cpc	r17, r29
    2738:	60 f5       	brcc	.+88     	; 0x2792 <AICI_InterpretPacket+0x298>
    273a:	8d e4       	ldi	r24, 0x4D	; 77
    273c:	e8 2e       	mov	r14, r24
    273e:	81 e0       	ldi	r24, 0x01	; 1
    2740:	f8 2e       	mov	r15, r24
			{
				if (PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)  // Flash read mode - word addresses so MSB/LSB masking nessesary
    2742:	80 91 4b 01 	lds	r24, 0x014B
    2746:	84 31       	cpi	r24, 0x14	; 20
    2748:	31 f4       	brne	.+12     	; 0x2756 <AICI_InterpretPacket+0x25c>
				{
					USI_SPITransmit(ReadCommand | ((ReadByte & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ));
    274a:	8d 2d       	mov	r24, r13
    274c:	99 27       	eor	r25, r25
    274e:	00 ff       	sbrs	r16, 0
    2750:	03 c0       	rjmp	.+6      	; 0x2758 <AICI_InterpretPacket+0x25e>
    2752:	88 60       	ori	r24, 0x08	; 8
    2754:	01 c0       	rjmp	.+2      	; 0x2758 <AICI_InterpretPacket+0x25e>
				}
				else                                       // EEPROM read mode, address is in bytes and so no masking nessesary
				{
					USI_SPITransmit(ReadCommand);
    2756:	8d 2d       	mov	r24, r13
    2758:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
				}
				
				USI_SPITransmitWord(CurrAddress);          // Transmit the current address to the slave AVR
    275c:	80 91 42 01 	lds	r24, 0x0142
    2760:	90 91 43 01 	lds	r25, 0x0143
    2764:	0e 94 bb 09 	call	0x1376 <USI_SPITransmitWord>

				PacketBytes[2 + ReadByte] = USI_SPITransmit(0x00); // Read in the byte stored at the requested location
    2768:	80 e0       	ldi	r24, 0x00	; 0
    276a:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    276e:	f7 01       	movw	r30, r14
    2770:	80 83       	st	Z, r24

				if ((ReadByte & 0x01) || (PacketBytes[0] == AICB_CMD_READ_EEPROM_ISP)) // Flash addresses are given in words; only increment on the odd byte if reading the flash.
    2772:	00 fd       	sbrc	r16, 0
    2774:	04 c0       	rjmp	.+8      	; 0x277e <AICI_InterpretPacket+0x284>
    2776:	80 91 4b 01 	lds	r24, 0x014B
    277a:	86 31       	cpi	r24, 0x16	; 22
    277c:	11 f4       	brne	.+4      	; 0x2782 <AICI_InterpretPacket+0x288>
				{
					V2P_IncrementCurrAddress();             // Increment the address counter
    277e:	0e 94 46 0f 	call	0x1e8c <V2P_IncrementCurrAddress>
    2782:	0f 5f       	subi	r16, 0xFF	; 255
    2784:	1f 4f       	sbci	r17, 0xFF	; 255
    2786:	08 94       	sec
    2788:	e1 1c       	adc	r14, r1
    278a:	f1 1c       	adc	r15, r1
    278c:	0c 17       	cp	r16, r28
    278e:	1d 07       	cpc	r17, r29
    2790:	c0 f2       	brcs	.-80     	; 0x2742 <AICI_InterpretPacket+0x248>
				}
				else
				{
					if ((CurrAddress & 0x00FF0000) & !(CurrAddress & 0x0000FFFF))
					{
						CurrAddress |= (1UL << 31);        // Set MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
						V2P_CheckForExtendedAddress();
					}
				}
			}
			
			PacketBytes[1]               = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    2792:	10 92 4c 01 	sts	0x014C, r1
			PacketBytes[2 + BytesToRead] = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    2796:	c5 5b       	subi	r28, 0xB5	; 181
    2798:	de 4f       	sbci	r29, 0xFE	; 254
    279a:	1a 82       	std	Y+2, r1	; 0x02

			break;
    279c:	14 c0       	rjmp	.+40     	; 0x27c6 <AICI_InterpretPacket+0x2cc>
		case AICB_CMD_PROGRAM_FLASH_ISP:
		case AICB_CMD_PROGRAM_EEPROM_ISP:
			ISPCC_ProgramChip();                          // Program the bytes into the chip
    279e:	0e 94 95 11 	call	0x232a <ISPCC_ProgramChip>
			
			MessageSize = 2;
    27a2:	82 e0       	ldi	r24, 0x02	; 2
    27a4:	90 e0       	ldi	r25, 0x00	; 0
    27a6:	90 93 48 01 	sts	0x0148, r25
    27aa:	80 93 47 01 	sts	0x0147, r24

			PacketBytes[1] = AICB_STATUS_CMD_OK;
    27ae:	10 92 4c 01 	sts	0x014C, r1
			
			break;
    27b2:	09 c0       	rjmp	.+18     	; 0x27c6 <AICI_InterpretPacket+0x2cc>
		default:                                        // Unknown command, return error
			MessageSize = 1;
    27b4:	81 e0       	ldi	r24, 0x01	; 1
    27b6:	90 e0       	ldi	r25, 0x00	; 0
    27b8:	90 93 48 01 	sts	0x0148, r25
    27bc:	80 93 47 01 	sts	0x0147, r24
			
			PacketBytes[1] = AICB_STATUS_CMD_UNKNOWN;
    27c0:	89 ec       	ldi	r24, 0xC9	; 201
    27c2:	80 93 4c 01 	sts	0x014C, r24
	}

	V2P_SendPacket();                                   // Send the response packet
    27c6:	0e 94 65 0e 	call	0x1cca <V2P_SendPacket>
    27ca:	df 91       	pop	r29
    27cc:	cf 91       	pop	r28
    27ce:	1f 91       	pop	r17
    27d0:	0f 91       	pop	r16
    27d2:	ff 90       	pop	r15
    27d4:	ef 90       	pop	r14
    27d6:	df 90       	pop	r13
    27d8:	08 95       	ret

000027da <PM_GetStoredDataSize>:

// ======================================================================================

uint32_t PM_GetStoredDataSize(const uint8_t Type)
{
    27da:	cf 93       	push	r28
    27dc:	df 93       	push	r29
    27de:	cd b7       	in	r28, 0x3d	; 61
    27e0:	de b7       	in	r29, 0x3e	; 62
    27e2:	24 97       	sbiw	r28, 0x04	; 4
    27e4:	0f b6       	in	r0, 0x3f	; 63
    27e6:	f8 94       	cli
    27e8:	de bf       	out	0x3e, r29	; 62
    27ea:	0f be       	out	0x3f, r0	; 63
    27ec:	cd bf       	out	0x3d, r28	; 61
	/* This take a **LOT** of code and is accessed several times throughout
	   the program, so I've put it into a seperate function to save on flash. */

	uint32_t ProgDataSize = 0;
    27ee:	19 82       	std	Y+1, r1	; 0x01
    27f0:	1a 82       	std	Y+2, r1	; 0x02
    27f2:	1b 82       	std	Y+3, r1	; 0x03
    27f4:	1c 82       	std	Y+4, r1	; 0x04
void 
eeprom_read_block (void *pointer_ram,
                   const void *pointer_eeprom,
                   size_t n)
{
    27f6:	fe 01       	movw	r30, r28
    27f8:	31 96       	adiw	r30, 0x01	; 1
    27fa:	81 30       	cpi	r24, 0x01	; 1
    27fc:	19 f4       	brne	.+6      	; 0x2804 <PM_GetStoredDataSize+0x2a>
    27fe:	ab e1       	ldi	r26, 0x1B	; 27
    2800:	b0 e0       	ldi	r27, 0x00	; 0
    2802:	02 c0       	rjmp	.+4      	; 0x2808 <PM_GetStoredDataSize+0x2e>
    2804:	af e1       	ldi	r26, 0x1F	; 31
    2806:	b0 e0       	ldi	r27, 0x00	; 0
  if (!__builtin_constant_p (n)
      || n > 256)
    {
      /* make sure size is a 16 bit variable.  */
      uint16_t size = n; 

      asm volatile ( 
            ".%=_start:" CR_TAB
            "sbiw %2,1" CR_TAB
            "brlt .%=_finished" CR_TAB
             XCALL " __eeprom_read_byte_" _REG_LOCATION_SUFFIX CR_TAB
            "st z+,__tmp_reg__" CR_TAB
            "rjmp .%=_start" CR_TAB
            ".%=_finished:" 
          : "=x" (pointer_eeprom),
            "=z" (pointer_ram),
            "+w" (size)
           : "x" (pointer_eeprom), 
             "z" (pointer_ram)
           : "memory");
    }
  else
    {
      if (n != 0)
        {
          if (n == 256)
            {
              asm volatile (
                  XCALL " __eeprom_read_block_" _REG_LOCATION_SUFFIX 
                : "+x" (pointer_eeprom),
                  "=z" (pointer_ram)
                : "z"  (pointer_ram)
                : "memory");
            }
          else
            {
              /* Needed in order to truncate to 8 bit.  */
              uint8_t len;
              len = (uint8_t) n; 
    2808:	84 e0       	ldi	r24, 0x04	; 4

              asm volatile (
    280a:	18 2e       	mov	r1, r24
    280c:	0e 94 69 1a 	call	0x34d2 <__eeprom_read_block_1F2021>

	eeprom_read_block((void*)&ProgDataSize, (const void*)((Type == TYPE_FLASH)? &EEPROMVars.DataSize : &EEPROMVars.EEPROMSize), sizeof(uint32_t));

	if (ProgDataSize == 0xFFFFFFFF)                                      // Blank EEPROM, return a size  of 0 bytes
    2810:	89 81       	ldd	r24, Y+1	; 0x01
    2812:	9a 81       	ldd	r25, Y+2	; 0x02
    2814:	ab 81       	ldd	r26, Y+3	; 0x03
    2816:	bc 81       	ldd	r27, Y+4	; 0x04
    2818:	8f 5f       	subi	r24, 0xFF	; 255
    281a:	9f 4f       	sbci	r25, 0xFF	; 255
    281c:	af 4f       	sbci	r26, 0xFF	; 255
    281e:	bf 4f       	sbci	r27, 0xFF	; 255
    2820:	21 f4       	brne	.+8      	; 0x282a <PM_GetStoredDataSize+0x50>
	  ProgDataSize = 0x00;
    2822:	19 82       	std	Y+1, r1	; 0x01
    2824:	1a 82       	std	Y+2, r1	; 0x02
    2826:	1b 82       	std	Y+3, r1	; 0x03
    2828:	1c 82       	std	Y+4, r1	; 0x04

	return ProgDataSize;
    282a:	89 81       	ldd	r24, Y+1	; 0x01
    282c:	9a 81       	ldd	r25, Y+2	; 0x02
    282e:	ab 81       	ldd	r26, Y+3	; 0x03
    2830:	bc 81       	ldd	r27, Y+4	; 0x04
}
    2832:	bc 01       	movw	r22, r24
    2834:	cd 01       	movw	r24, r26
    2836:	24 96       	adiw	r28, 0x04	; 4
    2838:	0f b6       	in	r0, 0x3f	; 63
    283a:	f8 94       	cli
    283c:	de bf       	out	0x3e, r29	; 62
    283e:	0f be       	out	0x3f, r0	; 63
    2840:	cd bf       	out	0x3d, r28	; 61
    2842:	df 91       	pop	r29
    2844:	cf 91       	pop	r28
    2846:	08 95       	ret

00002848 <PM_SetupDFAddressCounters>:

void PM_SetupDFAddressCounters(const uint8_t Type)
{
	uint32_t StartAddress;
	
	MemoryType  = Type;
    2848:	80 93 61 02 	sts	0x0261, r24
	GPageLength = 0;
    284c:	10 92 5f 02 	sts	0x025F, r1
    2850:	10 92 5e 02 	sts	0x025E, r1
    2854:	20 91 42 01 	lds	r18, 0x0142
    2858:	30 91 43 01 	lds	r19, 0x0143
    285c:	40 91 44 01 	lds	r20, 0x0144
    2860:	50 91 45 01 	lds	r21, 0x0145

	if (Type == TYPE_FLASH)                                              // Type 1 = Flash
    2864:	81 30       	cpi	r24, 0x01	; 1
    2866:	39 f4       	brne	.+14     	; 0x2876 <PM_SetupDFAddressCounters+0x2e>
	  StartAddress = (CurrAddress << 1);                               // Convert flash word address to byte address
    2868:	da 01       	movw	r26, r20
    286a:	c9 01       	movw	r24, r18
    286c:	88 0f       	add	r24, r24
    286e:	99 1f       	adc	r25, r25
    2870:	aa 1f       	adc	r26, r26
    2872:	bb 1f       	adc	r27, r27
    2874:	06 c0       	rjmp	.+12     	; 0x2882 <PM_SetupDFAddressCounters+0x3a>
	else
	  StartAddress = CurrAddress + PM_EEPROM_OFFSET;                   // EEPROM uses byte addresses, and starts at the 257th kilobyte in Dataflash
    2876:	da 01       	movw	r26, r20
    2878:	c9 01       	movw	r24, r18
    287a:	80 50       	subi	r24, 0x00	; 0
    287c:	9c 4f       	sbci	r25, 0xFC	; 252
    287e:	ab 4f       	sbci	r26, 0xFB	; 251
    2880:	bf 4f       	sbci	r27, 0xFF	; 255
	
	CurrPageAddress = 0;
    2882:	10 92 6e 02 	sts	0x026E, r1
    2886:	10 92 6d 02 	sts	0x026D, r1

	while (StartAddress >= DF_INTERNALDF_BUFFBYTES)                      // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DF_INTERNALDF_BUFFBYTES;                         // Subtract one page's worth of bytes from the desired address
		CurrPageAddress++;
    288a:	88 30       	cpi	r24, 0x08	; 8
    288c:	21 e0       	ldi	r18, 0x01	; 1
    288e:	92 07       	cpc	r25, r18
    2890:	20 e0       	ldi	r18, 0x00	; 0
    2892:	a2 07       	cpc	r26, r18
    2894:	20 e0       	ldi	r18, 0x00	; 0
    2896:	b2 07       	cpc	r27, r18
    2898:	a0 f0       	brcs	.+40     	; 0x28c2 <PM_SetupDFAddressCounters+0x7a>
    289a:	20 e0       	ldi	r18, 0x00	; 0
    289c:	30 e0       	ldi	r19, 0x00	; 0
    289e:	88 50       	subi	r24, 0x08	; 8
    28a0:	91 40       	sbci	r25, 0x01	; 1
    28a2:	a0 40       	sbci	r26, 0x00	; 0
    28a4:	b0 40       	sbci	r27, 0x00	; 0
    28a6:	2f 5f       	subi	r18, 0xFF	; 255
    28a8:	3f 4f       	sbci	r19, 0xFF	; 255
    28aa:	88 30       	cpi	r24, 0x08	; 8
    28ac:	41 e0       	ldi	r20, 0x01	; 1
    28ae:	94 07       	cpc	r25, r20
    28b0:	40 e0       	ldi	r20, 0x00	; 0
    28b2:	a4 07       	cpc	r26, r20
    28b4:	40 e0       	ldi	r20, 0x00	; 0
    28b6:	b4 07       	cpc	r27, r20
    28b8:	90 f7       	brcc	.-28     	; 0x289e <PM_SetupDFAddressCounters+0x56>
    28ba:	30 93 6e 02 	sts	0x026E, r19
    28be:	20 93 6d 02 	sts	0x026D, r18
	}
	
	CurrBuffByte = (uint16_t)StartAddress;                               // The buffer byte is the remainder
    28c2:	90 93 67 02 	sts	0x0267, r25
    28c6:	80 93 66 02 	sts	0x0266, r24
    28ca:	08 95       	ret

000028cc <PM_StoreProgramByte>:
}

void PM_StoreProgramByte(const uint8_t Data)
{
    28cc:	cf 93       	push	r28
    28ce:	c8 2f       	mov	r28, r24
	if (CurrBuffByte == DF_INTERNALDF_BUFFBYTES)
    28d0:	80 91 66 02 	lds	r24, 0x0266
    28d4:	90 91 67 02 	lds	r25, 0x0267
    28d8:	88 50       	subi	r24, 0x08	; 8
    28da:	91 40       	sbci	r25, 0x01	; 1
    28dc:	a9 f4       	brne	.+42     	; 0x2908 <PM_StoreProgramByte+0x3c>
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
    28de:	80 91 6d 02 	lds	r24, 0x026D
    28e2:	90 91 6e 02 	lds	r25, 0x026E
    28e6:	9c 01       	movw	r18, r24
    28e8:	01 96       	adiw	r24, 0x01	; 1
    28ea:	90 93 6e 02 	sts	0x026E, r25
    28ee:	80 93 6d 02 	sts	0x026D, r24
    28f2:	c9 01       	movw	r24, r18
    28f4:	0e 94 da 0a 	call	0x15b4 <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    28f8:	80 e0       	ldi	r24, 0x00	; 0
    28fa:	90 e0       	ldi	r25, 0x00	; 0
    28fc:	0e 94 50 0a 	call	0x14a0 <DF_BufferWriteEnable>
		CurrBuffByte = 0;
    2900:	10 92 67 02 	sts	0x0267, r1
    2904:	10 92 66 02 	sts	0x0266, r1
	}
	
	SPI_SPITransmit(Data);                                               // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    2908:	8c 2f       	mov	r24, r28
    290a:	0e 94 43 09 	call	0x1286 <SPI_SPITransmit>
	CurrBuffByte++;
    290e:	80 91 66 02 	lds	r24, 0x0266
    2912:	90 91 67 02 	lds	r25, 0x0267
    2916:	01 96       	adiw	r24, 0x01	; 1
    2918:	90 93 67 02 	sts	0x0267, r25
    291c:	80 93 66 02 	sts	0x0266, r24
	GPageLength++;
    2920:	80 91 5e 02 	lds	r24, 0x025E
    2924:	90 91 5f 02 	lds	r25, 0x025F
    2928:	01 96       	adiw	r24, 0x01	; 1
    292a:	90 93 5f 02 	sts	0x025F, r25
    292e:	80 93 5e 02 	sts	0x025E, r24
    2932:	cf 91       	pop	r28
    2934:	08 95       	ret

00002936 <PM_CheckEndOfFuseLockData>:
}

void PM_InterpretAVRISPPacket(void)
{
	uint8_t* EEPROMAddress;

	switch (PacketBytes[0])
	{
		case AICB_CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
						
			for (uint8_t PacketB = 0; PacketB <= 11; PacketB++)          // Save the enter programming mode command bytes
			  eeprom_write_byte(&EEPROMVars.EnterProgMode[PacketB], PacketBytes[PacketB]);
			
			InProgrammingMode = TRUE;                                    // Set the flag, prevent the user from exiting the V2P state machine			
			CurrentMode = PM_NO_SETUP;                                   // Clear the current mode variable

			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = AICB_STATUS_CMD_OK;

			break;			
		case AICB_CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;

			PM_CheckEndOfFuseLockData();                                 // Check for remaining bytes to be stored and general cleanup
			
			InProgrammingMode = FALSE;                                   // Clear the flag, allow the user to exit the V2P state machine

			DF_EnableDataflash(FALSE);

			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
			PacketBytes[1] = AICB_STATUS_CMD_OK;

			break;
		case AICB_CMD_READ_SIGNATURE_ISP:
			MessageSize = 4;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                          // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x01;                                        // Signature bytes all return "01" in storage mode
			PacketBytes[3] = AICB_STATUS_CMD_OK;                          // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_CHIP_ERASE_ISP:
			MessageSize = 2;

			for (uint8_t PacketB = 1; PacketB <= 6; PacketB++)          // Save the erase chip command bytes to EEPROM
			  eeprom_write_byte(&EEPROMVars.EraseChip[PacketB], PacketBytes[PacketB]);

			for (uint8_t Byte = 0; Byte < 8; Byte++)                    // Clear the program and EEPROM size counters
			{
				eeprom_write_byte(&EEPROMVars.DataSize[Byte], 0x00);
				eeprom_write_byte(&EEPROMVars.EEPROMSize[Byte], 0x00);
			}
						
			eeprom_write_byte(&EEPROMVars.EraseCmdStored, TRUE);
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;
			
			break;
		case AICB_CMD_READ_OSCCAL_ISP:
			MessageSize = 4;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x00;                                      // Return 0x00 for the OSCCAL byte
			PacketBytes[3] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_READ_FUSE_ISP:
		case AICB_CMD_READ_LOCK_ISP:
			MessageSize = 4;
	
			if (CurrentMode != PM_LOCKFUSEBITS_READ)                    // First lock or fuse byte being read, set the EEPROM pointer
			{
				PM_CheckEndOfFuseLockData();                            // Check for remaining bytes to be stored and general cleanup
				
				CurrBuffByte = 0;
				CurrentMode  = PM_LOCKFUSEBITS_READ;
			}
			
			if (CurrBuffByte > eeprom_read_byte((PacketBytes[0] == AICB_CMD_READ_FUSE_ISP)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes))  // Trying to read more fuse/lock bytes than are stored in memory
			{
				PacketBytes[2] = 0xFF;                                 // Return 0xFF for the fuse/lock byte
			}
			else
			{
				PacketBytes[2] = eeprom_read_byte((uint8_t*)(((PacketBytes[0] == AICB_CMD_READ_FUSE_ISP)? &EEPROMVars.FuseBytes : &EEPROMVars.LockBytes) // Starting location
									                         + (CurrBuffByte << 2) + (PacketBytes[1] - 1)));                                             // The start position of the actual fuse/lock byte to read (4 bytes each));
			}

			PacketBytes[1] = AICB_STATUS_CMD_OK;                       // Data byte is encased in CMD_OKs
			PacketBytes[3] = AICB_STATUS_CMD_OK;                       // Data byte is encased in CMD_OKs

			CurrBuffByte++;

			break;
		case AICB_CMD_PROGRAM_FUSE_ISP:
		case AICB_CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;

			if (CurrentMode != PM_LOCKFUSEBITS_WRITE)                  // First lock or fuse byte being written, set the EEPROM pointer
			{
				CurrentMode   = PM_LOCKFUSEBITS_WRITE;
				CurrBuffByte  = 0;                                     // CurrBuffByte is used to store the total fuse/lock bytes written
			}

			if (PacketBytes[0] == AICB_CMD_PROGRAM_FUSE_ISP)
			{
				EEPROMAddress = (uint8_t*)(&EEPROMVars.FuseBytes + (CurrBuffByte << 2));
				MemoryType    = TYPE_FUSE;
			}
			else
			{
				EEPROMAddress = (uint8_t*)(&EEPROMVars.LockBytes + (CurrBuffByte << 2));
				MemoryType    = TYPE_LOCK;
			}				
			
			if (CurrBuffByte < PM_MAX_FUSELOCKBITS)
			{
				for (uint8_t FLByte = 1; FLByte <= 4; FLByte++)
				{
					eeprom_write_byte(EEPROMAddress, PacketBytes[FLByte]);
					EEPROMAddress++;
				}

				CurrBuffByte++;                                        // Increment the total fuse/lock bytes written counter
			}
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;                       // Two CMD_OKs are always returned
			PacketBytes[2] = AICB_STATUS_CMD_OK;                       // Two CMD_OKs are always returned

			break;
		case AICB_CMD_PROGRAM_FLASH_ISP:
		case AICB_CMD_PROGRAM_EEPROM_ISP:
			MessageSize = 2;

			if (CurrentMode != PM_DATAFLASH_WRITE)                      // First programming packet
			{
				if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP)       // Flash programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram; // Set the eeprom address to the Program command bytes location
					PM_SetupDFAddressCounters(TYPE_FLASH);
				}
				else                                                   // EEPROM programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;  // Set the eeprom address to the EEPROM command bytes location
					PM_SetupDFAddressCounters(TYPE_EEPROM);
				}
				
				DF_BufferWriteEnable(CurrBuffByte);
				CurrentMode = PM_DATAFLASH_WRITE;
				
				for (uint8_t B = 1; B <= 9; B++)                       // Save the command bytes
				  eeprom_write_byte(EEPROMAddress, PacketBytes[B]);
			}

			uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
			                      | PacketBytes[2];

			for (uint16_t CurrByte = 0; CurrByte < BytesToWrite; CurrByte++)
				PM_StoreProgramByte(PacketBytes[10 + CurrByte]);

			if (!(GPageLength & PM_PAGELENGTH_FOUNDBIT) && (PacketBytes[3] & ISPCC_PROG_MODE_PAGEDONE) && GPageLength)
			{
				eeprom_write_word(((MemoryType == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength), GPageLength);
		
				GPageLength |= PM_PAGELENGTH_FOUNDBIT;                 // Bit 15 is used to indicate if the length has been found
			}

			PacketBytes[1] = AICB_STATUS_CMD_OK;
		
			break;
		case AICB_CMD_READ_FLASH_ISP:
		case AICB_CMD_READ_EEPROM_ISP:	
			if (CurrentMode != PM_DATAFLASH_READ)
			{
				PM_CheckEndOfFuseLockData();                           // Check for remaining bytes to be stored and general cleanup
				
				PM_SetupDFAddressCounters((PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);
				DF_ContinuousReadEnable(CurrPageAddress, CurrBuffByte);
				
				CurrentMode = PM_DATAFLASH_READ;
				CurrAddress = 0;
			}

			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8)    // \. Load in the number of bytes that is to
			                     | PacketBytes[2];                    // /  be read into a temp variable (MSB first)
						
			uint16_t BytesInMem  = PM_GetStoredDataSize((PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
			   PacketBytes[2 + ReadByte] = ((CurrAddress < BytesInMem)? SPI_SPITransmit(0x00) : 0xFF); // Read in the next dataflash byte if present
			   V2P_IncrementCurrAddress();
			}
			
			MessageSize = BytesToRead + 3;

			PacketBytes[1]               = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
			PacketBytes[2 + BytesToRead] = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
		
			break;
		default:
			MessageSize = 1;
			
			PacketBytes[1] = AICB_STATUS_CMD_UNKNOWN;
	}

	V2P_SendPacket();                                   // Send the response packet
}

void PM_CheckEndOfFuseLockData(void)
{
    2936:	cf 93       	push	r28
    2938:	df 93       	push	r29
    293a:	cd b7       	in	r28, 0x3d	; 61
    293c:	de b7       	in	r29, 0x3e	; 62
    293e:	24 97       	sbiw	r28, 0x04	; 4
    2940:	0f b6       	in	r0, 0x3f	; 63
    2942:	f8 94       	cli
    2944:	de bf       	out	0x3e, r29	; 62
    2946:	0f be       	out	0x3f, r0	; 63
    2948:	cd bf       	out	0x3d, r28	; 61
	if (CurrentMode == PM_DATAFLASH_WRITE)
    294a:	80 91 60 02 	lds	r24, 0x0260
    294e:	81 30       	cpi	r24, 0x01	; 1
    2950:	09 f0       	breq	.+2      	; 0x2954 <PM_CheckEndOfFuseLockData+0x1e>
    2952:	3f c0       	rjmp	.+126    	; 0x29d2 <PM_CheckEndOfFuseLockData+0x9c>
	{
		if (CurrBuffByte)                               // Data in the dataflash buffer, pending to be written
    2954:	80 91 66 02 	lds	r24, 0x0266
    2958:	90 91 67 02 	lds	r25, 0x0267
    295c:	89 2b       	or	r24, r25
    295e:	31 f0       	breq	.+12     	; 0x296c <PM_CheckEndOfFuseLockData+0x36>
		  DF_CopyBufferToFlashPage(CurrPageAddress);    // Save the remaining buffer bytes
    2960:	80 91 6d 02 	lds	r24, 0x026D
    2964:	90 91 6e 02 	lds	r25, 0x026E
    2968:	0e 94 da 0a 	call	0x15b4 <DF_CopyBufferToFlashPage>

		uint32_t DataSize = ((CurrPageAddress * DF_INTERNALDF_BUFFBYTES) + CurrBuffByte);
    296c:	20 91 6d 02 	lds	r18, 0x026D
    2970:	30 91 6e 02 	lds	r19, 0x026E
    2974:	88 e0       	ldi	r24, 0x08	; 8
    2976:	91 e0       	ldi	r25, 0x01	; 1
    2978:	28 9f       	mul	r18, r24
    297a:	a0 01       	movw	r20, r0
    297c:	29 9f       	mul	r18, r25
    297e:	50 0d       	add	r21, r0
    2980:	38 9f       	mul	r19, r24
    2982:	50 0d       	add	r21, r0
    2984:	11 24       	eor	r1, r1
    2986:	ca 01       	movw	r24, r20
    2988:	20 91 66 02 	lds	r18, 0x0266
    298c:	30 91 67 02 	lds	r19, 0x0267
    2990:	82 0f       	add	r24, r18
    2992:	93 1f       	adc	r25, r19
    2994:	9c 01       	movw	r18, r24
    2996:	44 27       	eor	r20, r20
    2998:	55 27       	eor	r21, r21
    299a:	29 83       	std	Y+1, r18	; 0x01
    299c:	3a 83       	std	Y+2, r19	; 0x02
    299e:	4b 83       	std	Y+3, r20	; 0x03
    29a0:	5c 83       	std	Y+4, r21	; 0x04

		if (MemoryType == TYPE_FLASH)
    29a2:	80 91 61 02 	lds	r24, 0x0261
    29a6:	fe 01       	movw	r30, r28
    29a8:	31 96       	adiw	r30, 0x01	; 1
    29aa:	81 30       	cpi	r24, 0x01	; 1
    29ac:	19 f4       	brne	.+6      	; 0x29b4 <PM_CheckEndOfFuseLockData+0x7e>
void 
eeprom_write_block (const void *pointer_ram,
                    void *pointer_eeprom,
                    size_t n)
{
    29ae:	ab e1       	ldi	r26, 0x1B	; 27
    29b0:	b0 e0       	ldi	r27, 0x00	; 0
    29b2:	0a c0       	rjmp	.+20     	; 0x29c8 <PM_CheckEndOfFuseLockData+0x92>
		{
			eeprom_write_block((const void*)&DataSize, (void*)&EEPROMVars.DataSize, sizeof(uint32_t));
		}
		else
		{
			DataSize -= PM_EEPROM_OFFSET;                // Remove DataFlash EEPROM start offset
    29b4:	20 50       	subi	r18, 0x00	; 0
    29b6:	34 40       	sbci	r19, 0x04	; 4
    29b8:	44 40       	sbci	r20, 0x04	; 4
    29ba:	50 40       	sbci	r21, 0x00	; 0
    29bc:	29 83       	std	Y+1, r18	; 0x01
    29be:	3a 83       	std	Y+2, r19	; 0x02
    29c0:	4b 83       	std	Y+3, r20	; 0x03
    29c2:	5c 83       	std	Y+4, r21	; 0x04
void 
eeprom_write_block (const void *pointer_ram,
                    void *pointer_eeprom,
                    size_t n)
{
    29c4:	af e1       	ldi	r26, 0x1F	; 31
    29c6:	b0 e0       	ldi	r27, 0x00	; 0
  if (!__builtin_constant_p (n)
      || n > 256)
    {
      /* make sure size is a 16 bit variable.  */
      uint16_t size = n; 

      asm volatile ( 
            ".%=_start:" CR_TAB
            "sbiw %2,1" CR_TAB
            "brlt .%=_finished" CR_TAB
            "ld __tmp_reg__,z+" CR_TAB
             XCALL " __eeprom_write_byte_" _REG_LOCATION_SUFFIX CR_TAB
            "rjmp .%=_start" CR_TAB
            ".%=_finished:" 
          : "=x" (pointer_eeprom),
            "=z" (pointer_ram),
            "+w" (size)
           : "x" (pointer_eeprom), 
             "z" (pointer_ram)
           : "memory");
    }
  else
    {
      /* Do nothing for compile time constant transfer size n == 0.  */
      if (n != 0)
        {
          if (n == 256)
            {
              asm volatile (
                 XCALL " __eeprom_write_block_" _REG_LOCATION_SUFFIX
               : "+x" (pointer_eeprom),
                 "=z" (pointer_ram)
               : "z"  (pointer_ram)
               : "memory" );
            }
          else
            {
              uint8_t len;
              len = (uint8_t) n;
    29c8:	84 e0       	ldi	r24, 0x04	; 4

              asm volatile (
    29ca:	18 2e       	mov	r1, r24
    29cc:	0e 94 84 1a 	call	0x3508 <__eeprom_write_block_1F2021>
    29d0:	10 c0       	rjmp	.+32     	; 0x29f2 <PM_CheckEndOfFuseLockData+0xbc>
			eeprom_write_block((const void*)&DataSize, (void*)&EEPROMVars.EEPROMSize, sizeof(uint32_t));
		}
	}
	else if (CurrentMode == PM_LOCKFUSEBITS_WRITE)
    29d2:	83 30       	cpi	r24, 0x03	; 3
    29d4:	71 f4       	brne	.+28     	; 0x29f2 <PM_CheckEndOfFuseLockData+0xbc>
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    29d6:	80 91 61 02 	lds	r24, 0x0261
    29da:	82 30       	cpi	r24, 0x02	; 2
    29dc:	19 f4       	brne	.+6      	; 0x29e4 <PM_CheckEndOfFuseLockData+0xae>
    29de:	af e2       	ldi	r26, 0x2F	; 47
    29e0:	b0 e0       	ldi	r27, 0x00	; 0
    29e2:	02 c0       	rjmp	.+4      	; 0x29e8 <PM_CheckEndOfFuseLockData+0xb2>
    29e4:	a0 e3       	ldi	r26, 0x30	; 48
    29e6:	b0 e0       	ldi	r27, 0x00	; 0
    29e8:	80 91 66 02 	lds	r24, 0x0266
  asm volatile (
    29ec:	08 2e       	mov	r0, r24
    29ee:	0e 94 73 1a 	call	0x34e6 <__eeprom_write_byte_1F2021>
    29f2:	24 96       	adiw	r28, 0x04	; 4
    29f4:	0f b6       	in	r0, 0x3f	; 63
    29f6:	f8 94       	cli
    29f8:	de bf       	out	0x3e, r29	; 62
    29fa:	0f be       	out	0x3f, r0	; 63
    29fc:	cd bf       	out	0x3d, r28	; 61
    29fe:	df 91       	pop	r29
    2a00:	cf 91       	pop	r28
    2a02:	08 95       	ret

00002a04 <PM_InterpretAVRISPPacket>:
    2a04:	cf 92       	push	r12
    2a06:	df 92       	push	r13
    2a08:	ef 92       	push	r14
    2a0a:	ff 92       	push	r15
    2a0c:	0f 93       	push	r16
    2a0e:	1f 93       	push	r17
    2a10:	cf 93       	push	r28
    2a12:	df 93       	push	r29
    2a14:	40 91 4b 01 	lds	r20, 0x014B
    2a18:	84 2f       	mov	r24, r20
    2a1a:	99 27       	eor	r25, r25
    2a1c:	86 31       	cpi	r24, 0x16	; 22
    2a1e:	91 05       	cpc	r25, r1
    2a20:	09 f4       	brne	.+2      	; 0x2a24 <PM_InterpretAVRISPPacket+0x20>
    2a22:	bc c1       	rjmp	.+888    	; 0x2d9c <PM_InterpretAVRISPPacket+0x398>
    2a24:	87 31       	cpi	r24, 0x17	; 23
    2a26:	91 05       	cpc	r25, r1
    2a28:	94 f4       	brge	.+36     	; 0x2a4e <PM_InterpretAVRISPPacket+0x4a>
    2a2a:	82 31       	cpi	r24, 0x12	; 18
    2a2c:	91 05       	cpc	r25, r1
    2a2e:	09 f4       	brne	.+2      	; 0x2a32 <PM_InterpretAVRISPPacket+0x2e>
    2a30:	66 c0       	rjmp	.+204    	; 0x2afe <PM_InterpretAVRISPPacket+0xfa>
    2a32:	83 31       	cpi	r24, 0x13	; 19
    2a34:	91 05       	cpc	r25, r1
    2a36:	3c f4       	brge	.+14     	; 0x2a46 <PM_InterpretAVRISPPacket+0x42>
    2a38:	80 31       	cpi	r24, 0x10	; 16
    2a3a:	91 05       	cpc	r25, r1
    2a3c:	11 f1       	breq	.+68     	; 0x2a82 <PM_InterpretAVRISPPacket+0x7e>
    2a3e:	41 97       	sbiw	r24, 0x11	; 17
    2a40:	09 f4       	brne	.+2      	; 0x2a44 <PM_InterpretAVRISPPacket+0x40>
    2a42:	3f c0       	rjmp	.+126    	; 0x2ac2 <PM_InterpretAVRISPPacket+0xbe>
    2a44:	19 c2       	rjmp	.+1074   	; 0x2e78 <PM_InterpretAVRISPPacket+0x474>
    2a46:	44 97       	sbiw	r24, 0x14	; 20
    2a48:	09 f4       	brne	.+2      	; 0x2a4c <PM_InterpretAVRISPPacket+0x48>
    2a4a:	a8 c1       	rjmp	.+848    	; 0x2d9c <PM_InterpretAVRISPPacket+0x398>
    2a4c:	3c c1       	rjmp	.+632    	; 0x2cc6 <PM_InterpretAVRISPPacket+0x2c2>
    2a4e:	89 31       	cpi	r24, 0x19	; 25
    2a50:	91 05       	cpc	r25, r1
    2a52:	09 f4       	brne	.+2      	; 0x2a56 <PM_InterpretAVRISPPacket+0x52>
    2a54:	e6 c0       	rjmp	.+460    	; 0x2c22 <PM_InterpretAVRISPPacket+0x21e>
    2a56:	8a 31       	cpi	r24, 0x1A	; 26
    2a58:	91 05       	cpc	r25, r1
    2a5a:	44 f4       	brge	.+16     	; 0x2a6c <PM_InterpretAVRISPPacket+0x68>
    2a5c:	87 31       	cpi	r24, 0x17	; 23
    2a5e:	91 05       	cpc	r25, r1
    2a60:	09 f4       	brne	.+2      	; 0x2a64 <PM_InterpretAVRISPPacket+0x60>
    2a62:	df c0       	rjmp	.+446    	; 0x2c22 <PM_InterpretAVRISPPacket+0x21e>
    2a64:	48 97       	sbiw	r24, 0x18	; 24
    2a66:	09 f4       	brne	.+2      	; 0x2a6a <PM_InterpretAVRISPPacket+0x66>
    2a68:	89 c0       	rjmp	.+274    	; 0x2b7c <PM_InterpretAVRISPPacket+0x178>
    2a6a:	06 c2       	rjmp	.+1036   	; 0x2e78 <PM_InterpretAVRISPPacket+0x474>
    2a6c:	8b 31       	cpi	r24, 0x1B	; 27
    2a6e:	91 05       	cpc	r25, r1
    2a70:	d1 f1       	breq	.+116    	; 0x2ae6 <PM_InterpretAVRISPPacket+0xe2>
    2a72:	8b 31       	cpi	r24, 0x1B	; 27
    2a74:	91 05       	cpc	r25, r1
    2a76:	0c f4       	brge	.+2      	; 0x2a7a <PM_InterpretAVRISPPacket+0x76>
    2a78:	81 c0       	rjmp	.+258    	; 0x2b7c <PM_InterpretAVRISPPacket+0x178>
    2a7a:	4c 97       	sbiw	r24, 0x1c	; 28
    2a7c:	09 f4       	brne	.+2      	; 0x2a80 <PM_InterpretAVRISPPacket+0x7c>
    2a7e:	71 c0       	rjmp	.+226    	; 0x2b62 <PM_InterpretAVRISPPacket+0x15e>
    2a80:	fb c1       	rjmp	.+1014   	; 0x2e78 <PM_InterpretAVRISPPacket+0x474>
    2a82:	82 e0       	ldi	r24, 0x02	; 2
    2a84:	90 e0       	ldi	r25, 0x00	; 0
    2a86:	90 93 48 01 	sts	0x0148, r25
    2a8a:	80 93 47 01 	sts	0x0147, r24
    2a8e:	eb e4       	ldi	r30, 0x4B	; 75
    2a90:	f1 e0       	ldi	r31, 0x01	; 1
    2a92:	20 e0       	ldi	r18, 0x00	; 0
    2a94:	30 e0       	ldi	r19, 0x00	; 0
    2a96:	9b e0       	ldi	r25, 0x0B	; 11
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    2a98:	d9 01       	movw	r26, r18
    2a9a:	ad 5d       	subi	r26, 0xDD	; 221
    2a9c:	bf 4f       	sbci	r27, 0xFF	; 255
    2a9e:	81 91       	ld	r24, Z+
  asm volatile (
    2aa0:	08 2e       	mov	r0, r24
    2aa2:	0e 94 73 1a 	call	0x34e6 <__eeprom_write_byte_1F2021>
    2aa6:	91 50       	subi	r25, 0x01	; 1
    2aa8:	2f 5f       	subi	r18, 0xFF	; 255
    2aaa:	3f 4f       	sbci	r19, 0xFF	; 255
    2aac:	97 ff       	sbrs	r25, 7
    2aae:	f4 cf       	rjmp	.-24     	; 0x2a98 <PM_InterpretAVRISPPacket+0x94>
    2ab0:	81 e0       	ldi	r24, 0x01	; 1
    2ab2:	80 93 46 01 	sts	0x0146, r24
    2ab6:	10 92 60 02 	sts	0x0260, r1
    2aba:	81 b3       	in	r24, 0x11	; 17
    2abc:	8f 7c       	andi	r24, 0xCF	; 207
    2abe:	80 62       	ori	r24, 0x20	; 32
    2ac0:	10 c0       	rjmp	.+32     	; 0x2ae2 <PM_InterpretAVRISPPacket+0xde>
    2ac2:	82 e0       	ldi	r24, 0x02	; 2
    2ac4:	90 e0       	ldi	r25, 0x00	; 0
    2ac6:	90 93 48 01 	sts	0x0148, r25
    2aca:	80 93 47 01 	sts	0x0147, r24
    2ace:	0e 94 9b 14 	call	0x2936 <PM_CheckEndOfFuseLockData>
    2ad2:	10 92 46 01 	sts	0x0146, r1
    2ad6:	80 e0       	ldi	r24, 0x00	; 0
    2ad8:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    2adc:	81 b3       	in	r24, 0x11	; 17
    2ade:	8f 7c       	andi	r24, 0xCF	; 207
    2ae0:	80 61       	ori	r24, 0x10	; 16
    2ae2:	81 bb       	out	0x11, r24	; 17
    2ae4:	58 c1       	rjmp	.+688    	; 0x2d96 <PM_InterpretAVRISPPacket+0x392>
    2ae6:	84 e0       	ldi	r24, 0x04	; 4
    2ae8:	90 e0       	ldi	r25, 0x00	; 0
    2aea:	90 93 48 01 	sts	0x0148, r25
    2aee:	80 93 47 01 	sts	0x0147, r24
    2af2:	10 92 4c 01 	sts	0x014C, r1
    2af6:	81 e0       	ldi	r24, 0x01	; 1
    2af8:	80 93 4d 01 	sts	0x014D, r24
    2afc:	3c c0       	rjmp	.+120    	; 0x2b76 <PM_InterpretAVRISPPacket+0x172>
    2afe:	82 e0       	ldi	r24, 0x02	; 2
    2b00:	90 e0       	ldi	r25, 0x00	; 0
    2b02:	90 93 48 01 	sts	0x0148, r25
    2b06:	80 93 47 01 	sts	0x0147, r24
    2b0a:	ec e4       	ldi	r30, 0x4C	; 76
    2b0c:	f1 e0       	ldi	r31, 0x01	; 1
    2b0e:	21 e0       	ldi	r18, 0x01	; 1
    2b10:	30 e0       	ldi	r19, 0x00	; 0
    2b12:	95 e0       	ldi	r25, 0x05	; 5
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    2b14:	d9 01       	movw	r26, r18
    2b16:	ab 5e       	subi	r26, 0xEB	; 235
    2b18:	bf 4f       	sbci	r27, 0xFF	; 255
    2b1a:	81 91       	ld	r24, Z+
  asm volatile (
    2b1c:	08 2e       	mov	r0, r24
    2b1e:	0e 94 73 1a 	call	0x34e6 <__eeprom_write_byte_1F2021>
    2b22:	91 50       	subi	r25, 0x01	; 1
    2b24:	2f 5f       	subi	r18, 0xFF	; 255
    2b26:	3f 4f       	sbci	r19, 0xFF	; 255
    2b28:	97 ff       	sbrs	r25, 7
    2b2a:	f4 cf       	rjmp	.-24     	; 0x2b14 <PM_InterpretAVRISPPacket+0x110>
    2b2c:	20 e0       	ldi	r18, 0x00	; 0
    2b2e:	80 e0       	ldi	r24, 0x00	; 0
    2b30:	90 e0       	ldi	r25, 0x00	; 0
    2b32:	37 e0       	ldi	r19, 0x07	; 7
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    2b34:	dc 01       	movw	r26, r24
    2b36:	a5 5e       	subi	r26, 0xE5	; 229
    2b38:	bf 4f       	sbci	r27, 0xFF	; 255
  asm volatile (
    2b3a:	02 2e       	mov	r0, r18
    2b3c:	0e 94 73 1a 	call	0x34e6 <__eeprom_write_byte_1F2021>
    2b40:	dc 01       	movw	r26, r24
    2b42:	a1 5e       	subi	r26, 0xE1	; 225
    2b44:	bf 4f       	sbci	r27, 0xFF	; 255
    2b46:	02 2e       	mov	r0, r18
    2b48:	0e 94 73 1a 	call	0x34e6 <__eeprom_write_byte_1F2021>
    2b4c:	31 50       	subi	r19, 0x01	; 1
    2b4e:	01 96       	adiw	r24, 0x01	; 1
    2b50:	37 ff       	sbrs	r19, 7
    2b52:	f0 cf       	rjmp	.-32     	; 0x2b34 <PM_InterpretAVRISPPacket+0x130>
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    2b54:	a4 e1       	ldi	r26, 0x14	; 20
    2b56:	b0 e0       	ldi	r27, 0x00	; 0
    2b58:	81 e0       	ldi	r24, 0x01	; 1
  asm volatile (
    2b5a:	08 2e       	mov	r0, r24
    2b5c:	0e 94 73 1a 	call	0x34e6 <__eeprom_write_byte_1F2021>
    2b60:	1a c1       	rjmp	.+564    	; 0x2d96 <PM_InterpretAVRISPPacket+0x392>
    2b62:	84 e0       	ldi	r24, 0x04	; 4
    2b64:	90 e0       	ldi	r25, 0x00	; 0
    2b66:	90 93 48 01 	sts	0x0148, r25
    2b6a:	80 93 47 01 	sts	0x0147, r24
    2b6e:	10 92 4c 01 	sts	0x014C, r1
    2b72:	10 92 4d 01 	sts	0x014D, r1
    2b76:	10 92 4e 01 	sts	0x014E, r1
    2b7a:	87 c1       	rjmp	.+782    	; 0x2e8a <PM_InterpretAVRISPPacket+0x486>
    2b7c:	84 e0       	ldi	r24, 0x04	; 4
    2b7e:	90 e0       	ldi	r25, 0x00	; 0
    2b80:	90 93 48 01 	sts	0x0148, r25
    2b84:	80 93 47 01 	sts	0x0147, r24
    2b88:	80 91 60 02 	lds	r24, 0x0260
    2b8c:	84 30       	cpi	r24, 0x04	; 4
    2b8e:	49 f0       	breq	.+18     	; 0x2ba2 <PM_InterpretAVRISPPacket+0x19e>
    2b90:	0e 94 9b 14 	call	0x2936 <PM_CheckEndOfFuseLockData>
    2b94:	10 92 67 02 	sts	0x0267, r1
    2b98:	10 92 66 02 	sts	0x0266, r1
    2b9c:	84 e0       	ldi	r24, 0x04	; 4
    2b9e:	80 93 60 02 	sts	0x0260, r24
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2ba2:	60 91 4b 01 	lds	r22, 0x014B
    2ba6:	68 31       	cpi	r22, 0x18	; 24
    2ba8:	19 f4       	brne	.+6      	; 0x2bb0 <PM_InterpretAVRISPPacket+0x1ac>
    2baa:	af e2       	ldi	r26, 0x2F	; 47
    2bac:	b0 e0       	ldi	r27, 0x00	; 0
    2bae:	02 c0       	rjmp	.+4      	; 0x2bb4 <PM_InterpretAVRISPPacket+0x1b0>
    2bb0:	a0 e3       	ldi	r26, 0x30	; 48
    2bb2:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    2bb4:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
    2bb8:	80 2d       	mov	r24, r0
    2bba:	99 27       	eor	r25, r25
    2bbc:	40 91 66 02 	lds	r20, 0x0266
    2bc0:	50 91 67 02 	lds	r21, 0x0267
    2bc4:	84 17       	cp	r24, r20
    2bc6:	95 07       	cpc	r25, r21
    2bc8:	10 f4       	brcc	.+4      	; 0x2bce <PM_InterpretAVRISPPacket+0x1ca>
    2bca:	8f ef       	ldi	r24, 0xFF	; 255
    2bcc:	1d c0       	rjmp	.+58     	; 0x2c08 <PM_InterpretAVRISPPacket+0x204>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2bce:	80 ea       	ldi	r24, 0xA0	; 160
    2bd0:	90 e0       	ldi	r25, 0x00	; 0
    2bd2:	48 9f       	mul	r20, r24
    2bd4:	90 01       	movw	r18, r0
    2bd6:	49 9f       	mul	r20, r25
    2bd8:	30 0d       	add	r19, r0
    2bda:	58 9f       	mul	r21, r24
    2bdc:	30 0d       	add	r19, r0
    2bde:	11 24       	eor	r1, r1
    2be0:	90 91 4c 01 	lds	r25, 0x014C
    2be4:	88 e2       	ldi	r24, 0x28	; 40
    2be6:	98 9f       	mul	r25, r24
    2be8:	c0 01       	movw	r24, r0
    2bea:	11 24       	eor	r1, r1
    2bec:	28 0f       	add	r18, r24
    2bee:	39 1f       	adc	r19, r25
    2bf0:	68 31       	cpi	r22, 0x18	; 24
    2bf2:	21 f4       	brne	.+8      	; 0x2bfc <PM_InterpretAVRISPPacket+0x1f8>
    2bf4:	d9 01       	movw	r26, r18
    2bf6:	a7 5f       	subi	r26, 0xF7	; 247
    2bf8:	bf 4f       	sbci	r27, 0xFF	; 255
    2bfa:	03 c0       	rjmp	.+6      	; 0x2c02 <PM_InterpretAVRISPPacket+0x1fe>
    2bfc:	d9 01       	movw	r26, r18
    2bfe:	af 5c       	subi	r26, 0xCF	; 207
    2c00:	bf 4f       	sbci	r27, 0xFF	; 255
  uint8_t result;
  asm volatile
    2c02:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
    2c06:	80 2d       	mov	r24, r0
    2c08:	80 93 4d 01 	sts	0x014D, r24
    2c0c:	10 92 4c 01 	sts	0x014C, r1
    2c10:	10 92 4e 01 	sts	0x014E, r1
    2c14:	4f 5f       	subi	r20, 0xFF	; 255
    2c16:	5f 4f       	sbci	r21, 0xFF	; 255
    2c18:	50 93 67 02 	sts	0x0267, r21
    2c1c:	40 93 66 02 	sts	0x0266, r20
    2c20:	34 c1       	rjmp	.+616    	; 0x2e8a <PM_InterpretAVRISPPacket+0x486>
    2c22:	83 e0       	ldi	r24, 0x03	; 3
    2c24:	90 e0       	ldi	r25, 0x00	; 0
    2c26:	90 93 48 01 	sts	0x0148, r25
    2c2a:	80 93 47 01 	sts	0x0147, r24
    2c2e:	80 91 60 02 	lds	r24, 0x0260
    2c32:	83 30       	cpi	r24, 0x03	; 3
    2c34:	39 f0       	breq	.+14     	; 0x2c44 <PM_InterpretAVRISPPacket+0x240>
    2c36:	83 e0       	ldi	r24, 0x03	; 3
    2c38:	80 93 60 02 	sts	0x0260, r24
    2c3c:	10 92 67 02 	sts	0x0267, r1
    2c40:	10 92 66 02 	sts	0x0266, r1
    2c44:	20 91 66 02 	lds	r18, 0x0266
    2c48:	30 91 67 02 	lds	r19, 0x0267
    2c4c:	47 31       	cpi	r20, 0x17	; 23
    2c4e:	69 f4       	brne	.+26     	; 0x2c6a <PM_InterpretAVRISPPacket+0x266>
    2c50:	80 ea       	ldi	r24, 0xA0	; 160
    2c52:	90 e0       	ldi	r25, 0x00	; 0
    2c54:	28 9f       	mul	r18, r24
    2c56:	e0 01       	movw	r28, r0
    2c58:	29 9f       	mul	r18, r25
    2c5a:	d0 0d       	add	r29, r0
    2c5c:	38 9f       	mul	r19, r24
    2c5e:	d0 0d       	add	r29, r0
    2c60:	11 24       	eor	r1, r1
    2c62:	cf 5c       	subi	r28, 0xCF	; 207
    2c64:	df 4f       	sbci	r29, 0xFF	; 255
    2c66:	82 e0       	ldi	r24, 0x02	; 2
    2c68:	0c c0       	rjmp	.+24     	; 0x2c82 <PM_InterpretAVRISPPacket+0x27e>
    2c6a:	80 ea       	ldi	r24, 0xA0	; 160
    2c6c:	90 e0       	ldi	r25, 0x00	; 0
    2c6e:	28 9f       	mul	r18, r24
    2c70:	e0 01       	movw	r28, r0
    2c72:	29 9f       	mul	r18, r25
    2c74:	d0 0d       	add	r29, r0
    2c76:	38 9f       	mul	r19, r24
    2c78:	d0 0d       	add	r29, r0
    2c7a:	11 24       	eor	r1, r1
    2c7c:	c7 5a       	subi	r28, 0xA7	; 167
    2c7e:	df 4f       	sbci	r29, 0xFF	; 255
    2c80:	83 e0       	ldi	r24, 0x03	; 3
    2c82:	80 93 61 02 	sts	0x0261, r24
    2c86:	80 91 66 02 	lds	r24, 0x0266
    2c8a:	90 91 67 02 	lds	r25, 0x0267
    2c8e:	0a 97       	sbiw	r24, 0x0a	; 10
    2c90:	a8 f4       	brcc	.+42     	; 0x2cbc <PM_InterpretAVRISPPacket+0x2b8>
    2c92:	ec e4       	ldi	r30, 0x4C	; 76
    2c94:	f1 e0       	ldi	r31, 0x01	; 1
    2c96:	93 e0       	ldi	r25, 0x03	; 3
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    2c98:	81 91       	ld	r24, Z+
  asm volatile (
    2c9a:	de 01       	movw	r26, r28
    2c9c:	08 2e       	mov	r0, r24
    2c9e:	0e 94 73 1a 	call	0x34e6 <__eeprom_write_byte_1F2021>
    2ca2:	21 96       	adiw	r28, 0x01	; 1
    2ca4:	91 50       	subi	r25, 0x01	; 1
    2ca6:	97 ff       	sbrs	r25, 7
    2ca8:	f7 cf       	rjmp	.-18     	; 0x2c98 <PM_InterpretAVRISPPacket+0x294>
    2caa:	80 91 66 02 	lds	r24, 0x0266
    2cae:	90 91 67 02 	lds	r25, 0x0267
    2cb2:	01 96       	adiw	r24, 0x01	; 1
    2cb4:	90 93 67 02 	sts	0x0267, r25
    2cb8:	80 93 66 02 	sts	0x0266, r24
    2cbc:	10 92 4c 01 	sts	0x014C, r1
    2cc0:	10 92 4d 01 	sts	0x014D, r1
    2cc4:	e2 c0       	rjmp	.+452    	; 0x2e8a <PM_InterpretAVRISPPacket+0x486>
    2cc6:	82 e0       	ldi	r24, 0x02	; 2
    2cc8:	90 e0       	ldi	r25, 0x00	; 0
    2cca:	90 93 48 01 	sts	0x0148, r25
    2cce:	80 93 47 01 	sts	0x0147, r24
    2cd2:	80 91 60 02 	lds	r24, 0x0260
    2cd6:	81 30       	cpi	r24, 0x01	; 1
    2cd8:	f9 f0       	breq	.+62     	; 0x2d18 <PM_InterpretAVRISPPacket+0x314>
    2cda:	43 31       	cpi	r20, 0x13	; 19
    2cdc:	21 f4       	brne	.+8      	; 0x2ce6 <PM_InterpretAVRISPPacket+0x2e2>
    2cde:	c2 e0       	ldi	r28, 0x02	; 2
    2ce0:	d0 e0       	ldi	r29, 0x00	; 0
    2ce2:	81 e0       	ldi	r24, 0x01	; 1
    2ce4:	03 c0       	rjmp	.+6      	; 0x2cec <PM_InterpretAVRISPPacket+0x2e8>
    2ce6:	cb e0       	ldi	r28, 0x0B	; 11
    2ce8:	d0 e0       	ldi	r29, 0x00	; 0
    2cea:	80 e0       	ldi	r24, 0x00	; 0
    2cec:	0e 94 24 14 	call	0x2848 <PM_SetupDFAddressCounters>
    2cf0:	80 91 66 02 	lds	r24, 0x0266
    2cf4:	90 91 67 02 	lds	r25, 0x0267
    2cf8:	0e 94 50 0a 	call	0x14a0 <DF_BufferWriteEnable>
    2cfc:	81 e0       	ldi	r24, 0x01	; 1
    2cfe:	80 93 60 02 	sts	0x0260, r24
    2d02:	ec e4       	ldi	r30, 0x4C	; 76
    2d04:	f1 e0       	ldi	r31, 0x01	; 1
    2d06:	98 e0       	ldi	r25, 0x08	; 8
    Write a byte \c value to EEPROM address \c addr. */

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
    2d08:	81 91       	ld	r24, Z+
  asm volatile (
    2d0a:	de 01       	movw	r26, r28
    2d0c:	08 2e       	mov	r0, r24
    2d0e:	0e 94 73 1a 	call	0x34e6 <__eeprom_write_byte_1F2021>
    2d12:	91 50       	subi	r25, 0x01	; 1
    2d14:	97 ff       	sbrs	r25, 7
    2d16:	f8 cf       	rjmp	.-16     	; 0x2d08 <PM_InterpretAVRISPPacket+0x304>
    2d18:	80 91 4c 01 	lds	r24, 0x014C
    2d1c:	99 27       	eor	r25, r25
    2d1e:	d8 2f       	mov	r29, r24
    2d20:	cc 27       	eor	r28, r28
    2d22:	80 91 4d 01 	lds	r24, 0x014D
    2d26:	99 27       	eor	r25, r25
    2d28:	c8 2b       	or	r28, r24
    2d2a:	d9 2b       	or	r29, r25
    2d2c:	00 e0       	ldi	r16, 0x00	; 0
    2d2e:	10 e0       	ldi	r17, 0x00	; 0
    2d30:	0c 17       	cp	r16, r28
    2d32:	1d 07       	cpc	r17, r29
    2d34:	70 f4       	brcc	.+28     	; 0x2d52 <PM_InterpretAVRISPPacket+0x34e>
    2d36:	55 e5       	ldi	r21, 0x55	; 85
    2d38:	e5 2e       	mov	r14, r21
    2d3a:	51 e0       	ldi	r21, 0x01	; 1
    2d3c:	f5 2e       	mov	r15, r21
    2d3e:	f7 01       	movw	r30, r14
    2d40:	81 91       	ld	r24, Z+
    2d42:	7f 01       	movw	r14, r30
    2d44:	0e 94 66 14 	call	0x28cc <PM_StoreProgramByte>
    2d48:	0f 5f       	subi	r16, 0xFF	; 255
    2d4a:	1f 4f       	sbci	r17, 0xFF	; 255
    2d4c:	0c 17       	cp	r16, r28
    2d4e:	1d 07       	cpc	r17, r29
    2d50:	b0 f3       	brcs	.-20     	; 0x2d3e <PM_InterpretAVRISPPacket+0x33a>
    2d52:	20 91 5e 02 	lds	r18, 0x025E
    2d56:	30 91 5f 02 	lds	r19, 0x025F
    2d5a:	37 fd       	sbrc	r19, 7
    2d5c:	1c c0       	rjmp	.+56     	; 0x2d96 <PM_InterpretAVRISPPacket+0x392>
    2d5e:	80 91 4e 01 	lds	r24, 0x014E
    2d62:	87 ff       	sbrs	r24, 7
    2d64:	18 c0       	rjmp	.+48     	; 0x2d96 <PM_InterpretAVRISPPacket+0x392>
    2d66:	21 15       	cp	r18, r1
    2d68:	31 05       	cpc	r19, r1
    2d6a:	a9 f0       	breq	.+42     	; 0x2d96 <PM_InterpretAVRISPPacket+0x392>
    Write a word \c value to EEPROM address \c addr. */

void 
eeprom_write_word (uint16_t *addr,uint16_t value)
{
    2d6c:	80 91 61 02 	lds	r24, 0x0261
    2d70:	81 30       	cpi	r24, 0x01	; 1
    2d72:	19 f4       	brne	.+6      	; 0x2d7a <PM_InterpretAVRISPPacket+0x376>
    2d74:	a1 e8       	ldi	r26, 0x81	; 129
    2d76:	b0 e0       	ldi	r27, 0x00	; 0
    2d78:	02 c0       	rjmp	.+4      	; 0x2d7e <PM_InterpretAVRISPPacket+0x37a>
    2d7a:	a3 e8       	ldi	r26, 0x83	; 131
    2d7c:	b0 e0       	ldi	r27, 0x00	; 0
  asm volatile (
    2d7e:	09 01       	movw	r0, r18
    2d80:	0e 94 7f 1a 	call	0x34fe <__eeprom_write_word_1F2021>
    2d84:	80 91 5e 02 	lds	r24, 0x025E
    2d88:	90 91 5f 02 	lds	r25, 0x025F
    2d8c:	90 68       	ori	r25, 0x80	; 128
    2d8e:	90 93 5f 02 	sts	0x025F, r25
    2d92:	80 93 5e 02 	sts	0x025E, r24
    2d96:	10 92 4c 01 	sts	0x014C, r1
    2d9a:	77 c0       	rjmp	.+238    	; 0x2e8a <PM_InterpretAVRISPPacket+0x486>
    2d9c:	80 91 60 02 	lds	r24, 0x0260
    2da0:	82 30       	cpi	r24, 0x02	; 2
    2da2:	01 f1       	breq	.+64     	; 0x2de4 <PM_InterpretAVRISPPacket+0x3e0>
    2da4:	0e 94 9b 14 	call	0x2936 <PM_CheckEndOfFuseLockData>
    2da8:	90 e0       	ldi	r25, 0x00	; 0
    2daa:	80 91 4b 01 	lds	r24, 0x014B
    2dae:	84 31       	cpi	r24, 0x14	; 20
    2db0:	09 f4       	brne	.+2      	; 0x2db4 <PM_InterpretAVRISPPacket+0x3b0>
    2db2:	91 e0       	ldi	r25, 0x01	; 1
    2db4:	89 2f       	mov	r24, r25
    2db6:	0e 94 24 14 	call	0x2848 <PM_SetupDFAddressCounters>
    2dba:	60 91 66 02 	lds	r22, 0x0266
    2dbe:	70 91 67 02 	lds	r23, 0x0267
    2dc2:	80 91 6d 02 	lds	r24, 0x026D
    2dc6:	90 91 6e 02 	lds	r25, 0x026E
    2dca:	0e 94 14 0a 	call	0x1428 <DF_ContinuousReadEnable>
    2dce:	82 e0       	ldi	r24, 0x02	; 2
    2dd0:	80 93 60 02 	sts	0x0260, r24
    2dd4:	10 92 42 01 	sts	0x0142, r1
    2dd8:	10 92 43 01 	sts	0x0143, r1
    2ddc:	10 92 44 01 	sts	0x0144, r1
    2de0:	10 92 45 01 	sts	0x0145, r1
    2de4:	80 91 4c 01 	lds	r24, 0x014C
    2de8:	99 27       	eor	r25, r25
    2dea:	d8 2f       	mov	r29, r24
    2dec:	cc 27       	eor	r28, r28
    2dee:	80 91 4d 01 	lds	r24, 0x014D
    2df2:	99 27       	eor	r25, r25
    2df4:	c8 2b       	or	r28, r24
    2df6:	d9 2b       	or	r29, r25
    2df8:	90 e0       	ldi	r25, 0x00	; 0
    2dfa:	80 91 4b 01 	lds	r24, 0x014B
    2dfe:	84 31       	cpi	r24, 0x14	; 20
    2e00:	09 f4       	brne	.+2      	; 0x2e04 <PM_InterpretAVRISPPacket+0x400>
    2e02:	91 e0       	ldi	r25, 0x01	; 1
    2e04:	89 2f       	mov	r24, r25
    2e06:	0e 94 ed 13 	call	0x27da <PM_GetStoredDataSize>
    2e0a:	dc 01       	movw	r26, r24
    2e0c:	cb 01       	movw	r24, r22
    2e0e:	7c 01       	movw	r14, r24
    2e10:	00 e0       	ldi	r16, 0x00	; 0
    2e12:	10 e0       	ldi	r17, 0x00	; 0
    2e14:	0c 17       	cp	r16, r28
    2e16:	1d 07       	cpc	r17, r29
    2e18:	18 f5       	brcc	.+70     	; 0x2e60 <PM_InterpretAVRISPPacket+0x45c>
    2e1a:	3d e4       	ldi	r19, 0x4D	; 77
    2e1c:	c3 2e       	mov	r12, r19
    2e1e:	31 e0       	ldi	r19, 0x01	; 1
    2e20:	d3 2e       	mov	r13, r19
    2e22:	97 01       	movw	r18, r14
    2e24:	44 27       	eor	r20, r20
    2e26:	55 27       	eor	r21, r21
    2e28:	80 91 42 01 	lds	r24, 0x0142
    2e2c:	90 91 43 01 	lds	r25, 0x0143
    2e30:	a0 91 44 01 	lds	r26, 0x0144
    2e34:	b0 91 45 01 	lds	r27, 0x0145
    2e38:	82 17       	cp	r24, r18
    2e3a:	93 07       	cpc	r25, r19
    2e3c:	a4 07       	cpc	r26, r20
    2e3e:	b5 07       	cpc	r27, r21
    2e40:	20 f4       	brcc	.+8      	; 0x2e4a <PM_InterpretAVRISPPacket+0x446>
    2e42:	80 e0       	ldi	r24, 0x00	; 0
    2e44:	0e 94 43 09 	call	0x1286 <SPI_SPITransmit>
    2e48:	01 c0       	rjmp	.+2      	; 0x2e4c <PM_InterpretAVRISPPacket+0x448>
    2e4a:	8f ef       	ldi	r24, 0xFF	; 255
    2e4c:	f6 01       	movw	r30, r12
    2e4e:	81 93       	st	Z+, r24
    2e50:	6f 01       	movw	r12, r30
    2e52:	0e 94 46 0f 	call	0x1e8c <V2P_IncrementCurrAddress>
    2e56:	0f 5f       	subi	r16, 0xFF	; 255
    2e58:	1f 4f       	sbci	r17, 0xFF	; 255
    2e5a:	0c 17       	cp	r16, r28
    2e5c:	1d 07       	cpc	r17, r29
    2e5e:	08 f3       	brcs	.-62     	; 0x2e22 <PM_InterpretAVRISPPacket+0x41e>
    2e60:	23 96       	adiw	r28, 0x03	; 3
    2e62:	d0 93 48 01 	sts	0x0148, r29
    2e66:	c0 93 47 01 	sts	0x0147, r28
    2e6a:	23 97       	sbiw	r28, 0x03	; 3
    2e6c:	10 92 4c 01 	sts	0x014C, r1
    2e70:	c5 5b       	subi	r28, 0xB5	; 181
    2e72:	de 4f       	sbci	r29, 0xFE	; 254
    2e74:	1a 82       	std	Y+2, r1	; 0x02
    2e76:	09 c0       	rjmp	.+18     	; 0x2e8a <PM_InterpretAVRISPPacket+0x486>
    2e78:	81 e0       	ldi	r24, 0x01	; 1
    2e7a:	90 e0       	ldi	r25, 0x00	; 0
    2e7c:	90 93 48 01 	sts	0x0148, r25
    2e80:	80 93 47 01 	sts	0x0147, r24
    2e84:	89 ec       	ldi	r24, 0xC9	; 201
    2e86:	80 93 4c 01 	sts	0x014C, r24
    2e8a:	0e 94 65 0e 	call	0x1cca <V2P_SendPacket>
    2e8e:	df 91       	pop	r29
    2e90:	cf 91       	pop	r28
    2e92:	1f 91       	pop	r17
    2e94:	0f 91       	pop	r16
    2e96:	ff 90       	pop	r15
    2e98:	ef 90       	pop	r14
    2e9a:	df 90       	pop	r13
    2e9c:	cf 90       	pop	r12
    2e9e:	08 95       	ret

00002ea0 <PM_SendFuseLockBytes>:
	{
		// CurrBuffByte stores the total number of fuse/lock bytes written in this case:
		eeprom_write_byte(((MemoryType == TYPE_FUSE)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes), CurrBuffByte);
	}
}

void PM_SendFuseLockBytes(const uint8_t Type)
{
    2ea0:	0f 93       	push	r16
    2ea2:	1f 93       	push	r17
    2ea4:	cf 93       	push	r28
    2ea6:	df 93       	push	r29
	uint8_t* EEPROMAddress;
	uint8_t  TotalBytes;

	if (Type == TYPE_FUSE)
    2ea8:	82 30       	cpi	r24, 0x02	; 2
    2eaa:	49 f4       	brne	.+18     	; 0x2ebe <PM_SendFuseLockBytes+0x1e>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2eac:	af e2       	ldi	r26, 0x2F	; 47
    2eae:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    2eb0:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
    2eb4:	80 2d       	mov	r24, r0
    2eb6:	18 2f       	mov	r17, r24
	{
		TotalBytes    = eeprom_read_byte(&EEPROMVars.TotalFuseBytes);
		EEPROMAddress = EEPROMVars.FuseBytes;
    2eb8:	c1 e3       	ldi	r28, 0x31	; 49
    2eba:	d0 e0       	ldi	r29, 0x00	; 0
    2ebc:	08 c0       	rjmp	.+16     	; 0x2ece <PM_SendFuseLockBytes+0x2e>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2ebe:	a0 e3       	ldi	r26, 0x30	; 48
    2ec0:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    2ec2:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
    2ec6:	80 2d       	mov	r24, r0
    2ec8:	18 2f       	mov	r17, r24
	}
	else
	{
		TotalBytes    = eeprom_read_byte(&EEPROMVars.TotalLockBytes);
		EEPROMAddress = EEPROMVars.LockBytes;	
    2eca:	c9 e5       	ldi	r28, 0x59	; 89
    2ecc:	d0 e0       	ldi	r29, 0x00	; 0
	}

	while (TotalBytes--)                              // Write each of the fuse/lock bytes stored in memory to the slave AVR
	{
		for (uint8_t CommandByte = 0; CommandByte < 4; CommandByte++)      // Write each individual command byte
		{
			USI_SPITransmit(eeprom_read_byte(EEPROMAddress));
			EEPROMAddress++;
		}
		
		// Add some delay before programming next byte, if there is one:
		if (TotalBytes)
		  MAIN_Delay10MS(5);
    2ece:	11 50       	subi	r17, 0x01	; 1
    2ed0:	1f 3f       	cpi	r17, 0xFF	; 255
    2ed2:	91 f0       	breq	.+36     	; 0x2ef8 <PM_SendFuseLockBytes+0x58>
    2ed4:	03 e0       	ldi	r16, 0x03	; 3
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2ed6:	de 01       	movw	r26, r28
    2ed8:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
    2edc:	80 2d       	mov	r24, r0
    2ede:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    2ee2:	21 96       	adiw	r28, 0x01	; 1
    2ee4:	01 50       	subi	r16, 0x01	; 1
    2ee6:	07 ff       	sbrs	r16, 7
    2ee8:	f6 cf       	rjmp	.-20     	; 0x2ed6 <PM_SendFuseLockBytes+0x36>
    2eea:	11 23       	and	r17, r17
    2eec:	19 f0       	breq	.+6      	; 0x2ef4 <PM_SendFuseLockBytes+0x54>
    2eee:	85 e0       	ldi	r24, 0x05	; 5
    2ef0:	0e 94 31 02 	call	0x462 <MAIN_Delay10MS>
    2ef4:	11 50       	subi	r17, 0x01	; 1
    2ef6:	70 f7       	brcc	.-36     	; 0x2ed4 <PM_SendFuseLockBytes+0x34>
    2ef8:	df 91       	pop	r29
    2efa:	cf 91       	pop	r28
    2efc:	1f 91       	pop	r17
    2efe:	0f 91       	pop	r16
    2f00:	08 95       	ret

00002f02 <PM_SendEraseCommand>:
	}
}

void PM_SendEraseCommand(void)
{			
    2f02:	1f 93       	push	r17
    2f04:	cf 93       	push	r28
    2f06:	df 93       	push	r29
    2f08:	c2 e0       	ldi	r28, 0x02	; 2
    2f0a:	d0 e0       	ldi	r29, 0x00	; 0
    2f0c:	13 e0       	ldi	r17, 0x03	; 3
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2f0e:	de 01       	movw	r26, r28
    2f10:	ab 5e       	subi	r26, 0xEB	; 235
    2f12:	bf 4f       	sbci	r27, 0xFF	; 255
  uint8_t result;
  asm volatile
    2f14:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
    2f18:	80 2d       	mov	r24, r0
    2f1a:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
	for (uint8_t B = 2; B < 6 ; B++)                  // Read out the erase chip command bytes
    2f1e:	11 50       	subi	r17, 0x01	; 1
    2f20:	21 96       	adiw	r28, 0x01	; 1
    2f22:	17 ff       	sbrs	r17, 7
    2f24:	f4 cf       	rjmp	.-24     	; 0x2f0e <PM_SendEraseCommand+0xc>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2f26:	a6 e1       	ldi	r26, 0x16	; 22
    2f28:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    2f2a:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
    2f2e:	80 2d       	mov	r24, r0
    2f30:	88 23       	and	r24, r24
    2f32:	59 f0       	breq	.+22     	; 0x2f4a <PM_SendEraseCommand+0x48>
	  USI_SPITransmit(eeprom_read_byte(&EEPROMVars.EraseChip[B])); // Send the erase chip commands
			
	if (eeprom_read_byte(&EEPROMVars.EraseChip[1]))   // Value of 1 indicates a busy flag test
	{
		do
			USI_SPITransmitWord(0xF000);
    2f34:	80 e0       	ldi	r24, 0x00	; 0
    2f36:	90 ef       	ldi	r25, 0xF0	; 240
    2f38:	0e 94 bb 09 	call	0x1376 <USI_SPITransmitWord>
    2f3c:	80 e0       	ldi	r24, 0x00	; 0
    2f3e:	90 e0       	ldi	r25, 0x00	; 0
    2f40:	0e 94 bb 09 	call	0x1376 <USI_SPITransmitWord>
    2f44:	80 fd       	sbrc	r24, 0
    2f46:	f6 cf       	rjmp	.-20     	; 0x2f34 <PM_SendEraseCommand+0x32>
    2f48:	07 c0       	rjmp	.+14     	; 0x2f58 <PM_SendEraseCommand+0x56>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    2f4a:	a5 e1       	ldi	r26, 0x15	; 21
    2f4c:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    2f4e:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
    2f52:	80 2d       	mov	r24, r0
    2f54:	0e 94 08 03 	call	0x610 <MAIN_Delay1MS>
    2f58:	df 91       	pop	r29
    2f5a:	cf 91       	pop	r28
    2f5c:	1f 91       	pop	r17
    2f5e:	08 95       	ret

00002f60 <PM_CreateProgrammingPackets>:
		while (USI_SPITransmitWord(0x0000) & 0x01);
	}
	else                                              // Cleared flag means use a predefined delay
	{		
		MAIN_Delay1MS(eeprom_read_byte(&EEPROMVars.EraseChip[0])); // Wait the erase delay
	}
}

void PM_CreateProgrammingPackets(const uint8_t Type)
{			
    2f60:	3f 92       	push	r3
    2f62:	4f 92       	push	r4
    2f64:	5f 92       	push	r5
    2f66:	6f 92       	push	r6
    2f68:	7f 92       	push	r7
    2f6a:	8f 92       	push	r8
    2f6c:	9f 92       	push	r9
    2f6e:	af 92       	push	r10
    2f70:	bf 92       	push	r11
    2f72:	cf 92       	push	r12
    2f74:	df 92       	push	r13
    2f76:	ef 92       	push	r14
    2f78:	ff 92       	push	r15
    2f7a:	0f 93       	push	r16
    2f7c:	1f 93       	push	r17
    2f7e:	cf 93       	push	r28
    2f80:	df 93       	push	r29
    2f82:	c8 2f       	mov	r28, r24
	uint32_t BytesRead       = 0;
    2f84:	aa 24       	eor	r10, r10
    2f86:	bb 24       	eor	r11, r11
    2f88:	65 01       	movw	r12, r10
	uint32_t BytesToRead     = PM_GetStoredDataSize(Type);      // Get the byte size of the stored program
    2f8a:	0e 94 ed 13 	call	0x27da <PM_GetStoredDataSize>
    2f8e:	2b 01       	movw	r4, r22
    2f90:	3c 01       	movw	r6, r24
	uint16_t BytesPerProgram;
	uint16_t PageLength;
	uint8_t* EEPROMAddress;
	uint8_t  ContinuedPage   = FALSE;
    2f92:	33 24       	eor	r3, r3
/** \ingroup avr_eeprom
    Read one 16-bit word (little endian) from EEPROM address \c addr. */
uint16_t
eeprom_read_word (const uint16_t *addr)
{
    2f94:	c1 30       	cpi	r28, 0x01	; 1
    2f96:	19 f4       	brne	.+6      	; 0x2f9e <PM_CreateProgrammingPackets+0x3e>
    2f98:	a1 e8       	ldi	r26, 0x81	; 129
    2f9a:	b0 e0       	ldi	r27, 0x00	; 0
    2f9c:	02 c0       	rjmp	.+4      	; 0x2fa2 <PM_CreateProgrammingPackets+0x42>
    2f9e:	a3 e8       	ldi	r26, 0x83	; 131
    2fa0:	b0 e0       	ldi	r27, 0x00	; 0
  uint16_t result;

  asm ( 
    2fa2:	0e 94 6e 1a 	call	0x34dc <__eeprom_read_word_1F2021>
    2fa6:	4f 01       	movw	r8, r30

	PageLength  = eeprom_read_word((Type == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength);
	CurrAddress = 0;
    2fa8:	10 92 42 01 	sts	0x0142, r1
    2fac:	10 92 43 01 	sts	0x0143, r1
    2fb0:	10 92 44 01 	sts	0x0144, r1
    2fb4:	10 92 45 01 	sts	0x0145, r1

	if (Type == TYPE_FLASH)
    2fb8:	c1 30       	cpi	r28, 0x01	; 1
    2fba:	49 f4       	brne	.+18     	; 0x2fce <PM_CreateProgrammingPackets+0x6e>
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram;       // Set the EEPROM pointer to the write flash command bytes location
    2fbc:	c2 e0       	ldi	r28, 0x02	; 2
    2fbe:	d0 e0       	ldi	r29, 0x00	; 0
		DF_ContinuousReadEnable(0, 0);
    2fc0:	60 e0       	ldi	r22, 0x00	; 0
    2fc2:	70 e0       	ldi	r23, 0x00	; 0
    2fc4:	cb 01       	movw	r24, r22
    2fc6:	0e 94 14 0a 	call	0x1428 <DF_ContinuousReadEnable>
		PacketBytes[0] = AICB_CMD_PROGRAM_FLASH_ISP;
    2fca:	83 e1       	ldi	r24, 0x13	; 19
    2fcc:	09 c0       	rjmp	.+18     	; 0x2fe0 <PM_CreateProgrammingPackets+0x80>
	}
	else
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;        // Set the EEPROM pointer to the write EEPROM command bytes location
    2fce:	cb e0       	ldi	r28, 0x0B	; 11
    2fd0:	d0 e0       	ldi	r29, 0x00	; 0
		DF_ContinuousReadEnable(PM_EEPROM_OFFSET / DF_INTERNALDF_BUFFBYTES, PM_EEPROM_OFFSET % DF_INTERNALDF_BUFFBYTES); // Start read from the EEPROM offset location
    2fd2:	60 ee       	ldi	r22, 0xE0	; 224
    2fd4:	70 e0       	ldi	r23, 0x00	; 0
    2fd6:	84 ee       	ldi	r24, 0xE4	; 228
    2fd8:	93 e0       	ldi	r25, 0x03	; 3
    2fda:	0e 94 14 0a 	call	0x1428 <DF_ContinuousReadEnable>
		PacketBytes[0] = AICB_CMD_PROGRAM_EEPROM_ISP;
    2fde:	85 e1       	ldi	r24, 0x15	; 21
    2fe0:	80 93 4b 01 	sts	0x014B, r24
    2fe4:	ec e4       	ldi	r30, 0x4C	; 76
    2fe6:	f1 e0       	ldi	r31, 0x01	; 1
    2fe8:	98 e0       	ldi	r25, 0x08	; 8
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2fea:	de 01       	movw	r26, r28
    2fec:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
    2ff0:	80 2d       	mov	r24, r0
    2ff2:	81 93       	st	Z+, r24
	}

	for (uint8_t B = 1; B <= 9 ; B++)                 // Load in the write data command bytes
	{
		PacketBytes[B] = eeprom_read_byte(EEPROMAddress); // Synthesise a write packet header
		EEPROMAddress++;                               // Increment the EEPROM location counter
    2ff4:	21 96       	adiw	r28, 0x01	; 1
    2ff6:	91 50       	subi	r25, 0x01	; 1
    2ff8:	97 ff       	sbrs	r25, 7
    2ffa:	f7 cf       	rjmp	.-18     	; 0x2fea <PM_CreateProgrammingPackets+0x8a>
	}
	
	BytesPerProgram = ((uint16_t)PacketBytes[1] << 8)
    2ffc:	80 91 4c 01 	lds	r24, 0x014C
    3000:	99 27       	eor	r25, r25
    3002:	d8 2f       	mov	r29, r24
    3004:	cc 27       	eor	r28, r28
    3006:	80 91 4d 01 	lds	r24, 0x014D
    300a:	99 27       	eor	r25, r25
    300c:	c8 2b       	or	r28, r24
    300e:	d9 2b       	or	r29, r25
	                | PacketBytes[2];

	while (BytesRead < BytesToRead)
	{
		if (PacketBytes[3] & ISPCC_PROG_MODE_PAGE)
		{
			if (PageLength > 160) // Max 160 bytes at a time
			{
				if (!(ContinuedPage))                      // Start of a new page, program in the first 150 bytes
				{
					BytesPerProgram = 160;
					PacketBytes[3] &= ~ISPCC_PROG_MODE_PAGEDONE;		
					ContinuedPage = TRUE;
				}
				else                                       // Middle of a page, program in the remainder
				{
					BytesPerProgram = PageLength - 160;
					PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
					ContinuedPage = FALSE;
				}
				
				for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page				

				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);
				PacketBytes[2] = (uint8_t)(BytesPerProgram);

				BytesRead += BytesPerProgram;                         // Increment the counter
			}
			else
			{
				for (uint16_t LoadB = 0; LoadB < PageLength; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page
			
				PacketBytes[1]  = (uint8_t)(PageLength >> 8);
				PacketBytes[2]  = (uint8_t)(PageLength);
				PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;

				BytesRead += PageLength;                            // Increment the counter
			}
		}
		else
		{
			if ((BytesRead + BytesPerProgram) > BytesToRead)        // Less than a whole BytesPerProgram left of data to write
			{
				BytesPerProgram = BytesToRead - BytesRead;          // Next lot of bytes will be the remaining data length
				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);   // \. Save the new length
				PacketBytes[2] = (uint8_t)(BytesPerProgram);        // /  into the data packet
			}

			for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
				PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);    // Load in the page
			
			BytesRead += BytesPerProgram;                           // Increment the counter
		}
	
		if (!(BytesRead & 0xFFFF) && (BytesRead & 0x00FF0000))      // Extended address required
		{
			USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);            // Load extended address command
			USI_SPITransmit(0x00);
			USI_SPITransmit((BytesRead & 0x00FF0000) >> 16);        // The 3rd byte of the long holds the extended address
			USI_SPITransmit(0x00);
		}

		ISPCC_ProgramChip();                                        // Start the program cycle
    3010:	a4 14       	cp	r10, r4
    3012:	b5 04       	cpc	r11, r5
    3014:	c6 04       	cpc	r12, r6
    3016:	d7 04       	cpc	r13, r7
    3018:	08 f0       	brcs	.+2      	; 0x301c <PM_CreateProgrammingPackets+0xbc>
    301a:	b2 c0       	rjmp	.+356    	; 0x3180 <PM_CreateProgrammingPackets+0x220>
    301c:	20 91 4e 01 	lds	r18, 0x014E
    3020:	82 2f       	mov	r24, r18
    3022:	99 27       	eor	r25, r25
    3024:	ac 01       	movw	r20, r24
    3026:	41 70       	andi	r20, 0x01	; 1
    3028:	50 70       	andi	r21, 0x00	; 0
    302a:	80 ff       	sbrs	r24, 0
    302c:	53 c0       	rjmp	.+166    	; 0x30d4 <PM_CreateProgrammingPackets+0x174>
    302e:	f1 ea       	ldi	r31, 0xA1	; 161
    3030:	8f 16       	cp	r8, r31
    3032:	91 04       	cpc	r9, r1
    3034:	60 f1       	brcs	.+88     	; 0x308e <PM_CreateProgrammingPackets+0x12e>
    3036:	33 20       	and	r3, r3
    3038:	41 f4       	brne	.+16     	; 0x304a <PM_CreateProgrammingPackets+0xea>
    303a:	c0 ea       	ldi	r28, 0xA0	; 160
    303c:	d0 e0       	ldi	r29, 0x00	; 0
    303e:	2f 77       	andi	r18, 0x7F	; 127
    3040:	20 93 4e 01 	sts	0x014E, r18
    3044:	31 e0       	ldi	r19, 0x01	; 1
    3046:	33 2e       	mov	r3, r19
    3048:	07 c0       	rjmp	.+14     	; 0x3058 <PM_CreateProgrammingPackets+0xf8>
    304a:	e4 01       	movw	r28, r8
    304c:	c0 5a       	subi	r28, 0xA0	; 160
    304e:	d0 40       	sbci	r29, 0x00	; 0
    3050:	20 68       	ori	r18, 0x80	; 128
    3052:	20 93 4e 01 	sts	0x014E, r18
    3056:	33 24       	eor	r3, r3
    3058:	00 e0       	ldi	r16, 0x00	; 0
    305a:	10 e0       	ldi	r17, 0x00	; 0
    305c:	0c 17       	cp	r16, r28
    305e:	1d 07       	cpc	r17, r29
    3060:	78 f4       	brcc	.+30     	; 0x3080 <PM_CreateProgrammingPackets+0x120>
    3062:	25 e5       	ldi	r18, 0x55	; 85
    3064:	e2 2e       	mov	r14, r18
    3066:	21 e0       	ldi	r18, 0x01	; 1
    3068:	f2 2e       	mov	r15, r18
    306a:	80 e0       	ldi	r24, 0x00	; 0
    306c:	0e 94 43 09 	call	0x1286 <SPI_SPITransmit>
    3070:	f7 01       	movw	r30, r14
    3072:	81 93       	st	Z+, r24
    3074:	7f 01       	movw	r14, r30
    3076:	0f 5f       	subi	r16, 0xFF	; 255
    3078:	1f 4f       	sbci	r17, 0xFF	; 255
    307a:	0c 17       	cp	r16, r28
    307c:	1d 07       	cpc	r17, r29
    307e:	a8 f3       	brcs	.-22     	; 0x306a <PM_CreateProgrammingPackets+0x10a>
    3080:	8d 2f       	mov	r24, r29
    3082:	99 27       	eor	r25, r25
    3084:	80 93 4c 01 	sts	0x014C, r24
    3088:	c0 93 4d 01 	sts	0x014D, r28
    308c:	4b c0       	rjmp	.+150    	; 0x3124 <PM_CreateProgrammingPackets+0x1c4>
    308e:	00 e0       	ldi	r16, 0x00	; 0
    3090:	10 e0       	ldi	r17, 0x00	; 0
    3092:	08 15       	cp	r16, r8
    3094:	19 05       	cpc	r17, r9
    3096:	78 f4       	brcc	.+30     	; 0x30b6 <PM_CreateProgrammingPackets+0x156>
    3098:	85 e5       	ldi	r24, 0x55	; 85
    309a:	e8 2e       	mov	r14, r24
    309c:	81 e0       	ldi	r24, 0x01	; 1
    309e:	f8 2e       	mov	r15, r24
    30a0:	80 e0       	ldi	r24, 0x00	; 0
    30a2:	0e 94 43 09 	call	0x1286 <SPI_SPITransmit>
    30a6:	f7 01       	movw	r30, r14
    30a8:	81 93       	st	Z+, r24
    30aa:	7f 01       	movw	r14, r30
    30ac:	0f 5f       	subi	r16, 0xFF	; 255
    30ae:	1f 4f       	sbci	r17, 0xFF	; 255
    30b0:	08 15       	cp	r16, r8
    30b2:	19 05       	cpc	r17, r9
    30b4:	a8 f3       	brcs	.-22     	; 0x30a0 <PM_CreateProgrammingPackets+0x140>
    30b6:	89 2d       	mov	r24, r9
    30b8:	99 27       	eor	r25, r25
    30ba:	80 93 4c 01 	sts	0x014C, r24
    30be:	80 92 4d 01 	sts	0x014D, r8
    30c2:	80 91 4e 01 	lds	r24, 0x014E
    30c6:	80 68       	ori	r24, 0x80	; 128
    30c8:	80 93 4e 01 	sts	0x014E, r24
    30cc:	c4 01       	movw	r24, r8
    30ce:	aa 27       	eor	r26, r26
    30d0:	bb 27       	eor	r27, r27
    30d2:	2b c0       	rjmp	.+86     	; 0x312a <PM_CreateProgrammingPackets+0x1ca>
    30d4:	ce 01       	movw	r24, r28
    30d6:	aa 27       	eor	r26, r26
    30d8:	bb 27       	eor	r27, r27
    30da:	8a 0d       	add	r24, r10
    30dc:	9b 1d       	adc	r25, r11
    30de:	ac 1d       	adc	r26, r12
    30e0:	bd 1d       	adc	r27, r13
    30e2:	48 16       	cp	r4, r24
    30e4:	59 06       	cpc	r5, r25
    30e6:	6a 06       	cpc	r6, r26
    30e8:	7b 06       	cpc	r7, r27
    30ea:	48 f4       	brcc	.+18     	; 0x30fe <PM_CreateProgrammingPackets+0x19e>
    30ec:	e2 01       	movw	r28, r4
    30ee:	ca 19       	sub	r28, r10
    30f0:	db 09       	sbc	r29, r11
    30f2:	8d 2f       	mov	r24, r29
    30f4:	99 27       	eor	r25, r25
    30f6:	80 93 4c 01 	sts	0x014C, r24
    30fa:	c0 93 4d 01 	sts	0x014D, r28
    30fe:	8a 01       	movw	r16, r20
    3100:	4c 17       	cp	r20, r28
    3102:	5d 07       	cpc	r21, r29
    3104:	78 f4       	brcc	.+30     	; 0x3124 <PM_CreateProgrammingPackets+0x1c4>
    3106:	f5 e5       	ldi	r31, 0x55	; 85
    3108:	ef 2e       	mov	r14, r31
    310a:	f1 e0       	ldi	r31, 0x01	; 1
    310c:	ff 2e       	mov	r15, r31
    310e:	80 e0       	ldi	r24, 0x00	; 0
    3110:	0e 94 43 09 	call	0x1286 <SPI_SPITransmit>
    3114:	f7 01       	movw	r30, r14
    3116:	81 93       	st	Z+, r24
    3118:	7f 01       	movw	r14, r30
    311a:	0f 5f       	subi	r16, 0xFF	; 255
    311c:	1f 4f       	sbci	r17, 0xFF	; 255
    311e:	0c 17       	cp	r16, r28
    3120:	1d 07       	cpc	r17, r29
    3122:	a8 f3       	brcs	.-22     	; 0x310e <PM_CreateProgrammingPackets+0x1ae>
    3124:	ce 01       	movw	r24, r28
    3126:	aa 27       	eor	r26, r26
    3128:	bb 27       	eor	r27, r27
    312a:	a8 0e       	add	r10, r24
    312c:	b9 1e       	adc	r11, r25
    312e:	ca 1e       	adc	r12, r26
    3130:	db 1e       	adc	r13, r27
    3132:	a1 14       	cp	r10, r1
    3134:	b1 04       	cpc	r11, r1
    3136:	e1 f4       	brne	.+56     	; 0x3170 <PM_CreateProgrammingPackets+0x210>
    3138:	e1 2c       	mov	r14, r1
    313a:	f1 2c       	mov	r15, r1
    313c:	ef ef       	ldi	r30, 0xFF	; 255
    313e:	0e 2f       	mov	r16, r30
    3140:	11 2d       	mov	r17, r1
    3142:	ea 20       	and	r14, r10
    3144:	fb 20       	and	r15, r11
    3146:	0c 21       	and	r16, r12
    3148:	1d 21       	and	r17, r13
    314a:	e1 14       	cp	r14, r1
    314c:	f1 04       	cpc	r15, r1
    314e:	01 05       	cpc	r16, r1
    3150:	11 05       	cpc	r17, r1
    3152:	71 f0       	breq	.+28     	; 0x3170 <PM_CreateProgrammingPackets+0x210>
    3154:	8d e4       	ldi	r24, 0x4D	; 77
    3156:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    315a:	80 e0       	ldi	r24, 0x00	; 0
    315c:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    3160:	c8 01       	movw	r24, r16
    3162:	aa 27       	eor	r26, r26
    3164:	bb 27       	eor	r27, r27
    3166:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    316a:	80 e0       	ldi	r24, 0x00	; 0
    316c:	0e 94 a8 09 	call	0x1350 <USI_SPITransmit>
    3170:	0e 94 95 11 	call	0x232a <ISPCC_ProgramChip>
    3174:	a4 14       	cp	r10, r4
    3176:	b5 04       	cpc	r11, r5
    3178:	c6 04       	cpc	r12, r6
    317a:	d7 04       	cpc	r13, r7
    317c:	08 f4       	brcc	.+2      	; 0x3180 <PM_CreateProgrammingPackets+0x220>
    317e:	4e cf       	rjmp	.-356    	; 0x301c <PM_CreateProgrammingPackets+0xbc>
    3180:	df 91       	pop	r29
    3182:	cf 91       	pop	r28
    3184:	1f 91       	pop	r17
    3186:	0f 91       	pop	r16
    3188:	ff 90       	pop	r15
    318a:	ef 90       	pop	r14
    318c:	df 90       	pop	r13
    318e:	cf 90       	pop	r12
    3190:	bf 90       	pop	r11
    3192:	af 90       	pop	r10
    3194:	9f 90       	pop	r9
    3196:	8f 90       	pop	r8
    3198:	7f 90       	pop	r7
    319a:	6f 90       	pop	r6
    319c:	5f 90       	pop	r5
    319e:	4f 90       	pop	r4
    31a0:	3f 90       	pop	r3
    31a2:	08 95       	ret

000031a4 <PM_ShowStoredItemSizes>:
	}
}

void PM_ShowStoredItemSizes(void)
{
    31a4:	1f 93       	push	r17
    31a6:	cf 93       	push	r28
    31a8:	df 93       	push	r29
    31aa:	cd b7       	in	r28, 0x3d	; 61
    31ac:	de b7       	in	r29, 0x3e	; 62
    31ae:	2e 97       	sbiw	r28, 0x0e	; 14
    31b0:	0f b6       	in	r0, 0x3f	; 63
    31b2:	f8 94       	cli
    31b4:	de bf       	out	0x3e, r29	; 62
    31b6:	0f be       	out	0x3f, r0	; 63
    31b8:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[14];
	uint8_t ItemInfoIndex = 0;
    31ba:	10 e0       	ldi	r17, 0x00	; 0
	uint8_t TempB;
	
	JoyStatus = 1;
    31bc:	81 e0       	ldi	r24, 0x01	; 1
    31be:	8e bb       	out	0x1e, r24	; 30
	
	while (1)
	{
		if (JoyStatus)                           // Joystick is in the non-center position
    31c0:	8e b3       	in	r24, 0x1e	; 30
    31c2:	88 23       	and	r24, r24
    31c4:	e9 f3       	breq	.-6      	; 0x31c0 <PM_ShowStoredItemSizes+0x1c>
		{
			if (JoyStatus & JOY_UP)              // Previous item
    31c6:	f6 9b       	sbis	0x1e, 6	; 30
    31c8:	06 c0       	rjmp	.+12     	; 0x31d6 <PM_ShowStoredItemSizes+0x32>
				(ItemInfoIndex == 0)? ItemInfoIndex = 3 : ItemInfoIndex--;
    31ca:	11 23       	and	r17, r17
    31cc:	11 f4       	brne	.+4      	; 0x31d2 <PM_ShowStoredItemSizes+0x2e>
    31ce:	13 e0       	ldi	r17, 0x03	; 3
    31d0:	0c c0       	rjmp	.+24     	; 0x31ea <PM_ShowStoredItemSizes+0x46>
    31d2:	11 50       	subi	r17, 0x01	; 1
    31d4:	0a c0       	rjmp	.+20     	; 0x31ea <PM_ShowStoredItemSizes+0x46>
			else if (JoyStatus & JOY_DOWN)      // Next item
    31d6:	f7 9b       	sbis	0x1e, 7	; 30
    31d8:	06 c0       	rjmp	.+12     	; 0x31e6 <PM_ShowStoredItemSizes+0x42>
				(ItemInfoIndex == 3)? ItemInfoIndex = 0 : ItemInfoIndex++;
    31da:	13 30       	cpi	r17, 0x03	; 3
    31dc:	11 f4       	brne	.+4      	; 0x31e2 <PM_ShowStoredItemSizes+0x3e>
    31de:	10 e0       	ldi	r17, 0x00	; 0
    31e0:	04 c0       	rjmp	.+8      	; 0x31ea <PM_ShowStoredItemSizes+0x46>
    31e2:	1f 5f       	subi	r17, 0xFF	; 255
    31e4:	02 c0       	rjmp	.+4      	; 0x31ea <PM_ShowStoredItemSizes+0x46>
			else if (JoyStatus & JOY_LEFT)
    31e6:	f2 99       	sbic	0x1e, 2	; 30
    31e8:	54 c0       	rjmp	.+168    	; 0x3292 <PM_ShowStoredItemSizes+0xee>
				return;
		
			switch (ItemInfoIndex)
    31ea:	81 2f       	mov	r24, r17
    31ec:	99 27       	eor	r25, r25
    31ee:	81 30       	cpi	r24, 0x01	; 1
    31f0:	91 05       	cpc	r25, r1
    31f2:	a1 f0       	breq	.+40     	; 0x321c <PM_ShowStoredItemSizes+0x78>
    31f4:	82 30       	cpi	r24, 0x02	; 2
    31f6:	91 05       	cpc	r25, r1
    31f8:	1c f4       	brge	.+6      	; 0x3200 <PM_ShowStoredItemSizes+0x5c>
    31fa:	89 2b       	or	r24, r25
    31fc:	39 f0       	breq	.+14     	; 0x320c <PM_ShowStoredItemSizes+0x68>
    31fe:	42 c0       	rjmp	.+132    	; 0x3284 <PM_ShowStoredItemSizes+0xe0>
    3200:	82 30       	cpi	r24, 0x02	; 2
    3202:	91 05       	cpc	r25, r1
    3204:	01 f1       	breq	.+64     	; 0x3246 <PM_ShowStoredItemSizes+0xa2>
    3206:	03 97       	sbiw	r24, 0x03	; 3
    3208:	39 f1       	breq	.+78     	; 0x3258 <PM_ShowStoredItemSizes+0xb4>
    320a:	3c c0       	rjmp	.+120    	; 0x3284 <PM_ShowStoredItemSizes+0xe0>
			{
				case 0:
					strcpy_P(Buffer, PSTR("DATA-"));
    320c:	68 e0       	ldi	r22, 0x08	; 8
    320e:	74 e0       	ldi	r23, 0x04	; 4
    3210:	ce 01       	movw	r24, r28
    3212:	01 96       	adiw	r24, 0x01	; 1
    3214:	0e 94 25 1a 	call	0x344a <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_FLASH), &Buffer[5], 10);
    3218:	81 e0       	ldi	r24, 0x01	; 1
    321a:	07 c0       	rjmp	.+14     	; 0x322a <PM_ShowStoredItemSizes+0x86>
					break;
				case 1:
					strcpy_P(Buffer, PSTR("EPRM-"));
    321c:	6e e0       	ldi	r22, 0x0E	; 14
    321e:	74 e0       	ldi	r23, 0x04	; 4
    3220:	ce 01       	movw	r24, r28
    3222:	01 96       	adiw	r24, 0x01	; 1
    3224:	0e 94 25 1a 	call	0x344a <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_EEPROM), &Buffer[5], 10);
    3228:	80 e0       	ldi	r24, 0x00	; 0
    322a:	0e 94 ed 13 	call	0x27da <PM_GetStoredDataSize>
    322e:	dc 01       	movw	r26, r24
    3230:	cb 01       	movw	r24, r22
    3232:	2a e0       	ldi	r18, 0x0A	; 10
    3234:	30 e0       	ldi	r19, 0x00	; 0
    3236:	ae 01       	movw	r20, r28
    3238:	4a 5f       	subi	r20, 0xFA	; 250
    323a:	5f 4f       	sbci	r21, 0xFF	; 255
    323c:	bc 01       	movw	r22, r24
    323e:	cd 01       	movw	r24, r26
    3240:	0e 94 2c 1a 	call	0x3458 <ultoa>
					break;
    3244:	1f c0       	rjmp	.+62     	; 0x3284 <PM_ShowStoredItemSizes+0xe0>
				case 2:
					strcpy_P(Buffer, PSTR("FUSE-"));
    3246:	64 e1       	ldi	r22, 0x14	; 20
    3248:	74 e0       	ldi	r23, 0x04	; 4
    324a:	ce 01       	movw	r24, r28
    324c:	01 96       	adiw	r24, 0x01	; 1
    324e:	0e 94 25 1a 	call	0x344a <strcpy_P>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    3252:	af e2       	ldi	r26, 0x2F	; 47
    3254:	b0 e0       	ldi	r27, 0x00	; 0
    3256:	08 c0       	rjmp	.+16     	; 0x3268 <PM_ShowStoredItemSizes+0xc4>
					TempB = eeprom_read_byte(&EEPROMVars.TotalFuseBytes);
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);
					break;
				case 3:
					strcpy_P(Buffer, PSTR("LOCK-"));
    3258:	6a e1       	ldi	r22, 0x1A	; 26
    325a:	74 e0       	ldi	r23, 0x04	; 4
    325c:	ce 01       	movw	r24, r28
    325e:	01 96       	adiw	r24, 0x01	; 1
    3260:	0e 94 25 1a 	call	0x344a <strcpy_P>
    Read one byte from EEPROM address \c addr. */

uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
    3264:	a0 e3       	ldi	r26, 0x30	; 48
    3266:	b0 e0       	ldi	r27, 0x00	; 0
  uint8_t result;
  asm volatile
    3268:	0e 94 61 1a 	call	0x34c2 <__eeprom_read_byte_1F2021>
    326c:	80 2d       	mov	r24, r0
					TempB = eeprom_read_byte(&EEPROMVars.TotalLockBytes);
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);		
    326e:	8f 3f       	cpi	r24, 0xFF	; 255
    3270:	11 f0       	breq	.+4      	; 0x3276 <PM_ShowStoredItemSizes+0xd2>
    3272:	99 27       	eor	r25, r25
    3274:	02 c0       	rjmp	.+4      	; 0x327a <PM_ShowStoredItemSizes+0xd6>
    3276:	80 e0       	ldi	r24, 0x00	; 0
    3278:	90 e0       	ldi	r25, 0x00	; 0
    327a:	be 01       	movw	r22, r28
    327c:	6a 5f       	subi	r22, 0xFA	; 250
    327e:	7f 4f       	sbci	r23, 0xFF	; 255
    3280:	0e 94 36 03 	call	0x66c <MAIN_IntToStr>
			}
	
			LCD_puts(Buffer);
    3284:	ce 01       	movw	r24, r28
    3286:	01 96       	adiw	r24, 0x01	; 1
    3288:	0e 94 24 08 	call	0x1048 <LCD_puts>

			MAIN_WaitForJoyRelease();
    328c:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>
    3290:	97 cf       	rjmp	.-210    	; 0x31c0 <PM_ShowStoredItemSizes+0x1c>
    3292:	2e 96       	adiw	r28, 0x0e	; 14
    3294:	0f b6       	in	r0, 0x3f	; 63
    3296:	f8 94       	cli
    3298:	de bf       	out	0x3e, r29	; 62
    329a:	0f be       	out	0x3f, r0	; 63
    329c:	cd bf       	out	0x3d, r28	; 61
    329e:	df 91       	pop	r29
    32a0:	cf 91       	pop	r28
    32a2:	1f 91       	pop	r17
    32a4:	08 95       	ret

000032a6 <TM_FindNextTag>:
	DF_EnableDataflash(FALSE);
}

void TM_FindNextTag(void)
{
    32a6:	af 92       	push	r10
    32a8:	bf 92       	push	r11
    32aa:	df 92       	push	r13
    32ac:	ef 92       	push	r14
    32ae:	ff 92       	push	r15
    32b0:	0f 93       	push	r16
    32b2:	1f 93       	push	r17
    32b4:	cf 93       	push	r28
    32b6:	df 93       	push	r29
    32b8:	cd b7       	in	r28, 0x3d	; 61
    32ba:	de b7       	in	r29, 0x3e	; 62
    32bc:	69 97       	sbiw	r28, 0x19	; 25
    32be:	0f b6       	in	r0, 0x3f	; 63
    32c0:	f8 94       	cli
    32c2:	de bf       	out	0x3e, r29	; 62
    32c4:	0f be       	out	0x3f, r0	; 63
    32c6:	cd bf       	out	0x3d, r28	; 61
	uint8_t  Buffer[21];
	uint8_t  HeadBuff[4]      = BT_TAGHEADER;
    32c8:	80 e4       	ldi	r24, 0x40	; 64
    32ca:	8e 8b       	std	Y+22, r24	; 0x16
    32cc:	86 e1       	ldi	r24, 0x16	; 22
    32ce:	a8 2e       	mov	r10, r24
    32d0:	b1 2c       	mov	r11, r1
    32d2:	ac 0e       	add	r10, r28
    32d4:	bd 1e       	adc	r11, r29
    32d6:	88 e2       	ldi	r24, 0x28	; 40
    32d8:	8f 8b       	std	Y+23, r24	; 0x17
    32da:	83 e2       	ldi	r24, 0x23	; 35
    32dc:	88 8f       	std	Y+24, r24	; 0x18
    32de:	89 e2       	ldi	r24, 0x29	; 41
    32e0:	89 8f       	std	Y+25, r24	; 0x19
	uint32_t ProgDataSize     = PM_GetStoredDataSize(TYPE_FLASH);
    32e2:	81 e0       	ldi	r24, 0x01	; 1
    32e4:	0e 94 ed 13 	call	0x27da <PM_GetStoredDataSize>
    32e8:	7b 01       	movw	r14, r22
    32ea:	8c 01       	movw	r16, r24
	uint8_t  TotalOkHeadBytes = 0;
    32ec:	dd 24       	eor	r13, r13
	uint8_t  TagByte;
	uint8_t  BytesRead;
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);    // Orange = busy
    32ee:	81 b3       	in	r24, 0x11	; 17
    32f0:	80 63       	ori	r24, 0x30	; 48
    32f2:	81 bb       	out	0x11, r24	; 17

	while (DFPos < ProgDataSize)
	{
		BytesRead = 1;
		
		if (SPI_SPITransmit(0x00) == HeadBuff[TotalOkHeadBytes++])
		{
			if (TotalOkHeadBytes == 4)
			{
				uint8_t HB;
			
				for (HB = 0; HB < 20; HB++)
				{
					TagByte = SPI_SPITransmit(0x00);
					Buffer[HB] = TagByte;
					
					if (TagByte == 0x00)
					  break;
				}
				
				Buffer[20] = '\0';             // Make sure string is null-terminated

				TagExists = TRUE;
				BytesRead = (HB + 2);

				LCD_puts(Buffer);
				MAIN_SETSTATUSLED(MAIN_STATLED_GREEN); // Green = ready
				return;
			}
		}
		else
		{
			TotalOkHeadBytes = 0;
		}

		DFPos += BytesRead;
    32f4:	80 91 b4 02 	lds	r24, 0x02B4
    32f8:	90 91 b5 02 	lds	r25, 0x02B5
    32fc:	a0 91 b6 02 	lds	r26, 0x02B6
    3300:	b0 91 b7 02 	lds	r27, 0x02B7
    3304:	8e 15       	cp	r24, r14
    3306:	9f 05       	cpc	r25, r15
    3308:	a0 07       	cpc	r26, r16
    330a:	b1 07       	cpc	r27, r17
    330c:	08 f0       	brcs	.+2      	; 0x3310 <TM_FindNextTag+0x6a>
    330e:	43 c0       	rjmp	.+134    	; 0x3396 <TM_FindNextTag+0xf0>
    3310:	80 e0       	ldi	r24, 0x00	; 0
    3312:	0e 94 43 09 	call	0x1286 <SPI_SPITransmit>
    3316:	f5 01       	movw	r30, r10
    3318:	ed 0d       	add	r30, r13
    331a:	f1 1d       	adc	r31, r1
    331c:	d3 94       	inc	r13
    331e:	90 81       	ld	r25, Z
    3320:	89 17       	cp	r24, r25
    3322:	21 f5       	brne	.+72     	; 0x336c <TM_FindNextTag+0xc6>
    3324:	84 e0       	ldi	r24, 0x04	; 4
    3326:	d8 16       	cp	r13, r24
    3328:	11 f5       	brne	.+68     	; 0x336e <TM_FindNextTag+0xc8>
    332a:	ff 24       	eor	r15, r15
    332c:	00 e0       	ldi	r16, 0x00	; 0
    332e:	10 e0       	ldi	r17, 0x00	; 0
    3330:	80 e0       	ldi	r24, 0x00	; 0
    3332:	0e 94 43 09 	call	0x1286 <SPI_SPITransmit>
    3336:	9e 01       	movw	r18, r28
    3338:	2f 5f       	subi	r18, 0xFF	; 255
    333a:	3f 4f       	sbci	r19, 0xFF	; 255
    333c:	f8 01       	movw	r30, r16
    333e:	e2 0f       	add	r30, r18
    3340:	f3 1f       	adc	r31, r19
    3342:	80 83       	st	Z, r24
    3344:	88 23       	and	r24, r24
    3346:	31 f0       	breq	.+12     	; 0x3354 <TM_FindNextTag+0xae>
    3348:	f3 94       	inc	r15
    334a:	0f 5f       	subi	r16, 0xFF	; 255
    334c:	1f 4f       	sbci	r17, 0xFF	; 255
    334e:	83 e1       	ldi	r24, 0x13	; 19
    3350:	8f 15       	cp	r24, r15
    3352:	70 f7       	brcc	.-36     	; 0x3330 <TM_FindNextTag+0x8a>
    3354:	1d 8a       	std	Y+21, r1	; 0x15
    3356:	81 e0       	ldi	r24, 0x01	; 1
    3358:	80 93 62 02 	sts	0x0262, r24
    335c:	c9 01       	movw	r24, r18
    335e:	0e 94 24 08 	call	0x1048 <LCD_puts>
    3362:	81 b3       	in	r24, 0x11	; 17
    3364:	8f 7c       	andi	r24, 0xCF	; 207
    3366:	80 61       	ori	r24, 0x10	; 16
    3368:	81 bb       	out	0x11, r24	; 17
    336a:	31 c0       	rjmp	.+98     	; 0x33ce <TM_FindNextTag+0x128>
    336c:	dd 24       	eor	r13, r13
    336e:	80 91 b4 02 	lds	r24, 0x02B4
    3372:	90 91 b5 02 	lds	r25, 0x02B5
    3376:	a0 91 b6 02 	lds	r26, 0x02B6
    337a:	b0 91 b7 02 	lds	r27, 0x02B7
    337e:	01 96       	adiw	r24, 0x01	; 1
    3380:	a1 1d       	adc	r26, r1
    3382:	b1 1d       	adc	r27, r1
    3384:	80 93 b4 02 	sts	0x02B4, r24
    3388:	90 93 b5 02 	sts	0x02B5, r25
    338c:	a0 93 b6 02 	sts	0x02B6, r26
    3390:	b0 93 b7 02 	sts	0x02B7, r27
    3394:	b7 cf       	rjmp	.-146    	; 0x3304 <TM_FindNextTag+0x5e>
	}
	
	DF_ContinuousReadEnable(0, 0);
    3396:	60 e0       	ldi	r22, 0x00	; 0
    3398:	70 e0       	ldi	r23, 0x00	; 0
    339a:	cb 01       	movw	r24, r22
    339c:	0e 94 14 0a 	call	0x1428 <DF_ContinuousReadEnable>
	DFPos = 0;
    33a0:	10 92 b4 02 	sts	0x02B4, r1
    33a4:	10 92 b5 02 	sts	0x02B5, r1
    33a8:	10 92 b6 02 	sts	0x02B6, r1
    33ac:	10 92 b7 02 	sts	0x02B7, r1
	
	if (TagExists == FALSE)
    33b0:	80 91 62 02 	lds	r24, 0x0262
    33b4:	88 23       	and	r24, r24
    33b6:	49 f4       	brne	.+18     	; 0x33ca <TM_FindNextTag+0x124>
	{
		MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);  // Green = ready
    33b8:	81 b3       	in	r24, 0x11	; 17
    33ba:	8f 7c       	andi	r24, 0xCF	; 207
    33bc:	80 61       	ori	r24, 0x10	; 16
    33be:	81 bb       	out	0x11, r24	; 17
		MAIN_ShowError(PSTR("NO TAGS"));
    33c0:	80 e2       	ldi	r24, 0x20	; 32
    33c2:	94 e0       	ldi	r25, 0x04	; 4
    33c4:	0e 94 6f 03 	call	0x6de <MAIN_ShowError>
    33c8:	02 c0       	rjmp	.+4      	; 0x33ce <TM_FindNextTag+0x128>
	}
	else
	{
		/* The following line _is_ recursion, but the function will only ever call itself
		   a maximum of one time. The function will call itself upon skipping from the last
		   tag stored in the program data to the first; to guard against infinite recursion
		   if no tags are present, the system will error out if the TagExists flag is empty
		   after a full data read. Once a tag has been read and displayed onto the LCD, the
           function returns to the main tag handling routine.                               */
		TM_FindNextTag();
    33ca:	0e 94 53 19 	call	0x32a6 <TM_FindNextTag>
    33ce:	69 96       	adiw	r28, 0x19	; 25
    33d0:	0f b6       	in	r0, 0x3f	; 63
    33d2:	f8 94       	cli
    33d4:	de bf       	out	0x3e, r29	; 62
    33d6:	0f be       	out	0x3f, r0	; 63
    33d8:	cd bf       	out	0x3d, r28	; 61
    33da:	df 91       	pop	r29
    33dc:	cf 91       	pop	r28
    33de:	1f 91       	pop	r17
    33e0:	0f 91       	pop	r16
    33e2:	ff 90       	pop	r15
    33e4:	ef 90       	pop	r14
    33e6:	df 90       	pop	r13
    33e8:	bf 90       	pop	r11
    33ea:	af 90       	pop	r10
    33ec:	08 95       	ret

000033ee <TM_ShowTags>:
    33ee:	60 e0       	ldi	r22, 0x00	; 0
    33f0:	70 e0       	ldi	r23, 0x00	; 0
    33f2:	cb 01       	movw	r24, r22
    33f4:	0e 94 14 0a 	call	0x1428 <DF_ContinuousReadEnable>
    33f8:	10 92 62 02 	sts	0x0262, r1
    33fc:	10 92 b4 02 	sts	0x02B4, r1
    3400:	10 92 b5 02 	sts	0x02B5, r1
    3404:	10 92 b6 02 	sts	0x02B6, r1
    3408:	10 92 b7 02 	sts	0x02B7, r1
    340c:	0e 94 53 19 	call	0x32a6 <TM_FindNextTag>
    3410:	80 91 62 02 	lds	r24, 0x0262
    3414:	88 23       	and	r24, r24
    3416:	71 f0       	breq	.+28     	; 0x3434 <TM_ShowTags+0x46>
    3418:	8e b3       	in	r24, 0x1e	; 30
    341a:	88 23       	and	r24, r24
    341c:	e9 f3       	breq	.-6      	; 0x3418 <TM_ShowTags+0x2a>
    341e:	f7 9b       	sbis	0x1e, 7	; 30
    3420:	03 c0       	rjmp	.+6      	; 0x3428 <TM_ShowTags+0x3a>
    3422:	0e 94 53 19 	call	0x32a6 <TM_FindNextTag>
    3426:	02 c0       	rjmp	.+4      	; 0x342c <TM_ShowTags+0x3e>
    3428:	f2 99       	sbic	0x1e, 2	; 30
    342a:	03 c0       	rjmp	.+6      	; 0x3432 <TM_ShowTags+0x44>
    342c:	0e 94 43 02 	call	0x486 <MAIN_WaitForJoyRelease>
    3430:	f3 cf       	rjmp	.-26     	; 0x3418 <TM_ShowTags+0x2a>
    3432:	80 e0       	ldi	r24, 0x00	; 0
    3434:	0e 94 dd 09 	call	0x13ba <DF_EnableDataflash>
    3438:	08 95       	ret

0000343a <__vector_2>:
.global PCINT0_vect             ; Pin change 0 (joystick)
.global PCINT1_vect             ; Pin change 1 (joystick)

PCINT0_vect:
  jmp PCINT1_vect
    343a:	0c 94 95 03 	jmp	0x72a <__vector_3>

0000343e <__vector_10>:

.global TIMER0_COMP_vect             ; Timer 0 compare

TIMER0_COMP_vect:
  push r24
    343e:	8f 93       	push	r24
  ldi r24, (USI_CONTROL_REG_FLAGS | (1<<USITC))
    3440:	8b e5       	ldi	r24, 0x5B	; 91
  sts _SFR_MEM_ADDR(USICR), r24
    3442:	80 93 b8 00 	sts	0x00B8, r24
  pop r24
    3446:	8f 91       	pop	r24
  reti
    3448:	18 95       	reti

0000344a <strcpy_P>:
    344a:	fb 01       	movw	r30, r22
    344c:	dc 01       	movw	r26, r24
    344e:	05 90       	lpm	r0, Z+
    3450:	0d 92       	st	X+, r0
    3452:	00 20       	and	r0, r0
    3454:	e1 f7       	brne	.-8      	; 0x344e <strcpy_P+0x4>
    3456:	08 95       	ret

00003458 <ultoa>:
    3458:	fa 01       	movw	r30, r20
    345a:	cf 93       	push	r28
    345c:	ff 93       	push	r31
    345e:	ef 93       	push	r30
    3460:	22 30       	cpi	r18, 0x02	; 2
    3462:	cc f0       	brlt	.+50     	; 0x3496 <ultoa+0x3e>
    3464:	25 32       	cpi	r18, 0x25	; 37
    3466:	bc f4       	brge	.+46     	; 0x3496 <ultoa+0x3e>
    3468:	c2 2f       	mov	r28, r18
    346a:	2c 2f       	mov	r18, r28
    346c:	33 27       	eor	r19, r19
    346e:	44 27       	eor	r20, r20
    3470:	55 27       	eor	r21, r21
    3472:	ff 93       	push	r31
    3474:	ef 93       	push	r30
    3476:	0e 94 89 1a 	call	0x3512 <__udivmodsi4>
    347a:	ef 91       	pop	r30
    347c:	ff 91       	pop	r31
    347e:	60 5d       	subi	r22, 0xD0	; 208
    3480:	6a 33       	cpi	r22, 0x3A	; 58
    3482:	0c f0       	brlt	.+2      	; 0x3486 <ultoa+0x2e>
    3484:	69 5d       	subi	r22, 0xD9	; 217
    3486:	61 93       	st	Z+, r22
    3488:	b9 01       	movw	r22, r18
    348a:	ca 01       	movw	r24, r20
    348c:	60 50       	subi	r22, 0x00	; 0
    348e:	70 40       	sbci	r23, 0x00	; 0
    3490:	80 40       	sbci	r24, 0x00	; 0
    3492:	90 40       	sbci	r25, 0x00	; 0
    3494:	51 f7       	brne	.-44     	; 0x346a <ultoa+0x12>
    3496:	10 82       	st	Z, r1
    3498:	8f 91       	pop	r24
    349a:	9f 91       	pop	r25
    349c:	cf 91       	pop	r28
    349e:	0c 94 51 1a 	jmp	0x34a2 <strrev>

000034a2 <strrev>:
    34a2:	dc 01       	movw	r26, r24
    34a4:	fc 01       	movw	r30, r24
    34a6:	01 90       	ld	r0, Z+
    34a8:	00 20       	and	r0, r0
    34aa:	e9 f7       	brne	.-6      	; 0x34a6 <strrev+0x4>
    34ac:	32 97       	sbiw	r30, 0x02	; 2
    34ae:	ae 17       	cp	r26, r30
    34b0:	bf 07       	cpc	r27, r31
    34b2:	30 f4       	brcc	.+12     	; 0x34c0 <strrev+0x1e>
    34b4:	7c 91       	ld	r23, X
    34b6:	60 81       	ld	r22, Z
    34b8:	70 83       	st	Z, r23
    34ba:	31 97       	sbiw	r30, 0x01	; 1
    34bc:	6d 93       	st	X+, r22
    34be:	f7 cf       	rjmp	.-18     	; 0x34ae <strrev+0xc>
    34c0:	08 95       	ret

000034c2 <__eeprom_read_byte_1F2021>:
    34c2:	f9 99       	sbic	0x1f, 1	; 31
    34c4:	fe cf       	rjmp	.-4      	; 0x34c2 <__eeprom_read_byte_1F2021>
    34c6:	b2 bd       	out	0x22, r27	; 34
    34c8:	a1 bd       	out	0x21, r26	; 33
    34ca:	f8 9a       	sbi	0x1f, 0	; 31
    34cc:	11 96       	adiw	r26, 0x01	; 1
    34ce:	00 b4       	in	r0, 0x20	; 32
    34d0:	08 95       	ret

000034d2 <__eeprom_read_block_1F2021>:
    34d2:	f7 df       	rcall	.-18     	; 0x34c2 <__eeprom_read_byte_1F2021>
    34d4:	01 92       	st	Z+, r0
    34d6:	1a 94       	dec	r1
    34d8:	e1 f7       	brne	.-8      	; 0x34d2 <__eeprom_read_block_1F2021>
    34da:	08 95       	ret

000034dc <__eeprom_read_word_1F2021>:
    34dc:	f2 df       	rcall	.-28     	; 0x34c2 <__eeprom_read_byte_1F2021>
    34de:	e0 2d       	mov	r30, r0
    34e0:	f0 df       	rcall	.-32     	; 0x34c2 <__eeprom_read_byte_1F2021>
    34e2:	f0 2d       	mov	r31, r0
    34e4:	08 95       	ret

000034e6 <__eeprom_write_byte_1F2021>:
    34e6:	f9 99       	sbic	0x1f, 1	; 31
    34e8:	fe cf       	rjmp	.-4      	; 0x34e6 <__eeprom_write_byte_1F2021>
    34ea:	b2 bd       	out	0x22, r27	; 34
    34ec:	a1 bd       	out	0x21, r26	; 33
    34ee:	00 bc       	out	0x20, r0	; 32
    34f0:	11 96       	adiw	r26, 0x01	; 1
    34f2:	0f b6       	in	r0, 0x3f	; 63
    34f4:	f8 94       	cli
    34f6:	fa 9a       	sbi	0x1f, 2	; 31
    34f8:	f9 9a       	sbi	0x1f, 1	; 31
    34fa:	0f be       	out	0x3f, r0	; 63
    34fc:	08 95       	ret

000034fe <__eeprom_write_word_1F2021>:
    34fe:	f3 df       	rcall	.-26     	; 0x34e6 <__eeprom_write_byte_1F2021>
    3500:	01 2c       	mov	r0, r1
    3502:	f1 df       	rcall	.-30     	; 0x34e6 <__eeprom_write_byte_1F2021>
    3504:	11 24       	eor	r1, r1
    3506:	08 95       	ret

00003508 <__eeprom_write_block_1F2021>:
    3508:	01 90       	ld	r0, Z+
    350a:	ed df       	rcall	.-38     	; 0x34e6 <__eeprom_write_byte_1F2021>
    350c:	1a 94       	dec	r1
    350e:	e1 f7       	brne	.-8      	; 0x3508 <__eeprom_write_block_1F2021>
    3510:	08 95       	ret

00003512 <__udivmodsi4>:
    3512:	a1 e2       	ldi	r26, 0x21	; 33
    3514:	1a 2e       	mov	r1, r26
    3516:	aa 1b       	sub	r26, r26
    3518:	bb 1b       	sub	r27, r27
    351a:	fd 01       	movw	r30, r26
    351c:	0d c0       	rjmp	.+26     	; 0x3538 <__udivmodsi4_ep>

0000351e <__udivmodsi4_loop>:
    351e:	aa 1f       	adc	r26, r26
    3520:	bb 1f       	adc	r27, r27
    3522:	ee 1f       	adc	r30, r30
    3524:	ff 1f       	adc	r31, r31
    3526:	a2 17       	cp	r26, r18
    3528:	b3 07       	cpc	r27, r19
    352a:	e4 07       	cpc	r30, r20
    352c:	f5 07       	cpc	r31, r21
    352e:	20 f0       	brcs	.+8      	; 0x3538 <__udivmodsi4_ep>
    3530:	a2 1b       	sub	r26, r18
    3532:	b3 0b       	sbc	r27, r19
    3534:	e4 0b       	sbc	r30, r20
    3536:	f5 0b       	sbc	r31, r21

00003538 <__udivmodsi4_ep>:
    3538:	66 1f       	adc	r22, r22
    353a:	77 1f       	adc	r23, r23
    353c:	88 1f       	adc	r24, r24
    353e:	99 1f       	adc	r25, r25
    3540:	1a 94       	dec	r1
    3542:	69 f7       	brne	.-38     	; 0x351e <__udivmodsi4_loop>
    3544:	60 95       	com	r22
    3546:	70 95       	com	r23
    3548:	80 95       	com	r24
    354a:	90 95       	com	r25
    354c:	9b 01       	movw	r18, r22
    354e:	ac 01       	movw	r20, r24
    3550:	bd 01       	movw	r22, r26
    3552:	cf 01       	movw	r24, r30
    3554:	08 95       	ret
