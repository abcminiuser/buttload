
ButtLoad.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  000035b6  0000366a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000035b6  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b2  00800104  00800104  0000366e  2**0
                  ALLOC
  3 .eeprom       0000008e  00810000  00810000  0000366e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00000084  00000000  00000000  000036fc  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00000078  00000000  00000000  00003780  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 0000012c  00000000  00000000  000037f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 00000d48  00000000  00000000  00003924  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0000451b  00000000  00000000  0000466c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000012e7  00000000  00000000  00008b87  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0000333f  00000000  00000000  00009e6e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000004ec  00000000  00000000  0000d1ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000011a2  00000000  00000000  0000d699  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000110e  00000000  00000000  0000e83b  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000070  00000000  00000000  0000f949  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 33 02 	jmp	0x466	; 0x466 <__ctors_end>
       4:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
       8:	0c 94 4c 1a 	jmp	0x3498	; 0x3498 <__vector_2>
       c:	0c 94 bb 02 	jmp	0x576	; 0x576 <__vector_3>
      10:	0c 94 ae 0c 	jmp	0x195c	; 0x195c <__vector_4>
      14:	0c 94 4b 08 	jmp	0x1096	; 0x1096 <__vector_5>
      18:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      1c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      20:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      24:	0c 94 74 0c 	jmp	0x18e8	; 0x18e8 <__vector_9>
      28:	0c 94 4e 1a 	jmp	0x349c	; 0x349c <__vector_10>
      2c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      30:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      34:	0c 94 02 0c 	jmp	0x1804	; 0x1804 <__vector_13>
      38:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      3c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      40:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      44:	0c 94 c8 09 	jmp	0x1390	; 0x1390 <__vector_17>
      48:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      4c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      50:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      54:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      58:	0c 94 be 08 	jmp	0x117c	; 0x117c <__vector_22>

0000005c <BUTTTAG_Title>:
      5c:	40 28 23 29 42 55 54 54 4c 4f 41 44 20 41 56 52     @(#)BUTTLOAD AVR
      6c:	49 53 50 00                                         ISP.

00000070 <BUTTTAG_Version>:
      70:	40 28 23 29 56 31 2d 34 00                          @(#)V1-4.

00000079 <BUTTTAG_Author>:
      79:	40 28 23 29 42 59 20 44 45 41 4e 20 43 41 4d 45     @(#)BY DEAN CAME
      89:	52 41 00                                            RA.

0000008c <BUTTTAG_Copyright>:
      8c:	40 28 23 29 3c 43 3e 20 32 30 30 36 20 2d 20 47     @(#)<C> 2006 - G
      9c:	50 4c 00                                            PL.

0000009f <AboutTextPtrs>:
      9f:	60 00 74 00 7d 00 90 00                             `.t.}...

000000a7 <WaitText>:
      a7:	2a 57 41 49 54 2a 00                                *WAIT*.

000000ae <Func_ISPPRGM>:
      ae:	41 56 52 49 53 50 20 4d 4f 44 45 00                 AVRISP MODE.

000000ba <Func_STOREPRGM>:
      ba:	53 54 4f 52 45 20 50 52 47 4d 00                    STORE PRGM.

000000c5 <Func_PRGMAVR>:
      c5:	50 52 4f 47 52 41 4d 20 41 56 52 00                 PROGRAM AVR.

000000d1 <Func_PRGMDATAFLASH>:
      d1:	44 41 54 41 46 4c 41 53 48 20 50 52 47 4d 00        DATAFLASH PRGM.

000000e0 <Func_PRGMSTOREINFO>:
      e0:	44 41 54 41 53 54 4f 52 45 20 49 4e 46 4f 00        DATASTORE INFO.

000000ef <Func_SETTINGS>:
      ef:	53 45 54 54 49 4e 47 53 00                          SETTINGS.

000000f8 <Func_SLEEP>:
      f8:	53 4c 45 45 50 20 4d 4f 44 45 00                    SLEEP MODE.

00000103 <MainFunctionNames>:
     103:	ae 00 ba 00 c5 00 d1 00 e0 00 ef 00 f8 00           ..............

00000111 <MainFunctionPtrs>:
     111:	8f 04 61 04 f4 04 a4 04 e9 03 2c 03 da 02           ..a.......,...

0000011f <SFunc_SETCONTRAST>:
     11f:	53 45 54 20 43 4f 4e 54 52 41 53 54 00              SET CONTRAST.

0000012c <SFunc_SETSPISPEED>:
     12c:	53 45 54 20 49 53 50 20 53 50 45 45 44 00           SET ISP SPEED.

0000013a <SFunc_SETRESETMODE>:
     13a:	53 45 54 20 52 45 53 45 54 20 4d 4f 44 45 00        SET RESET MODE.

00000149 <SFunc_SETFIRMMINOR>:
     149:	53 45 54 20 46 49 52 4d 20 56 45 52 53 49 4f 4e     SET FIRM VERSION
	...

0000015a <SFunc_SETAUTOSLEEPTO>:
     15a:	53 45 54 20 53 4c 45 45 50 20 54 49 4d 45 4f 55     SET SLEEP TIMEOU
     16a:	54 00                                               T.

0000016c <SFunc_CLEARMEM>:
     16c:	43 4c 45 41 52 20 4d 45 4d 4f 52 59 00              CLEAR MEMORY.

00000179 <SFunc_GOBOOTLOADER>:
     179:	4a 55 4d 50 20 54 4f 20 42 4f 4f 54 4c 4f 41 44     JUMP TO BOOTLOAD
     189:	45 52 00                                            ER.

0000018c <SettingFunctionNames>:
     18c:	1f 01 2c 01 3a 01 49 01 5a 01 6c 01 79 01           ..,.:.I.Z.l.y.

0000019a <SettingFunctionPtrs>:
     19a:	f8 06 44 07 77 07 9f 07 61 03 c5 06 f4 02           ..D.w...a.....

000001a8 <PRG_A>:
     1a8:	50 52 47 4d 20 41 4c 4c 00                          PRGM ALL.

000001b1 <PRG_D>:
     1b1:	44 41 54 41 20 4f 4e 4c 59 00                       DATA ONLY.

000001bb <PRG_E>:
     1bb:	45 45 50 52 4f 4d 20 4f 4e 4c 59 00                 EEPROM ONLY.

000001c7 <PRG_DE>:
     1c7:	44 41 54 41 20 41 4e 44 20 45 45 50 52 4f 4d 00     DATA AND EEPROM.

000001d7 <PRG_F>:
     1d7:	46 55 53 45 20 42 59 54 45 53 20 4f 4e 4c 59 00     FUSE BYTES ONLY.

000001e7 <PRG_L>:
     1e7:	4c 4f 43 4b 20 42 59 54 45 53 20 4f 4e 4c 59 00     LOCK BYTES ONLY.

000001f7 <PRG_FL>:
     1f7:	46 55 53 45 20 41 4e 44 20 4c 4f 43 4b 20 42 59     FUSE AND LOCK BY
     207:	54 45 53 00                                         TES.

0000020b <PRG_C>:
     20b:	45 52 41 53 45 20 4f 4e 4c 59 00                    ERASE ONLY.

00000216 <ProgOptions>:
     216:	a8 01 b1 01 bb 01 c7 01 d7 01 e7 01 f7 01 0b 02     ................

00000226 <USISpeeds>:
     226:	20 35 37 31 35 33 20 48 5a 00 20 38 36 37 33 38      57153 HZ. 86738
     236:	20 48 5a 00 31 31 33 34 32 37 20 48 5a 00 32 31      HZ.113427 HZ.21
     246:	30 36 35 31 20 48 5a 00                             0651 HZ.

0000024e <SPIResetModes>:
     24e:	4c 4f 47 49 43 00 46 4c 4f 41 54 00                 LOGIC.FLOAT.

0000025a <SIFONames>:
     25a:	53 54 4f 52 41 47 45 20 53 49 5a 45 53 00 00 56     STORAGE SIZES..V
     26a:	49 45 57 20 44 41 54 41 20 54 41 47 53 00           IEW DATA TAGS.

00000278 <__c.2509>:
     278:	2a 4a 54 41 47 20 4f 4e 2a 00                       *JTAG ON*.

00000282 <__c.2478>:
     282:	4e 4f 20 53 54 4f 52 45 44 20 50 52 47 4d 00        NO STORED PRGM.

00000291 <__c.2424>:
     291:	4f 46 46 00                                         OFF.

00000295 <__c.2422>:
     295:	20 20 20 20 53 45 43 00                                 SEC.

0000029d <__c.2401>:
     29d:	56 32 2d 20 00                                      V2- .

000002a2 <__c.2303>:
     2a2:	4d 45 4d 20 43 4c 45 41 52 45 44 00                 MEM CLEARED.

000002ae <__c.2295>:
     2ae:	3c 4e 20 59 3e 00                                   <N Y>.

000002b4 <__c.2293>:
     2b4:	43 4f 4e 46 49 52 4d 00                             CONFIRM.

000002bc <__c.2276>:
     2bc:	2a 53 54 4f 52 41 47 45 20 4d 4f 44 45 2a 00        *STORAGE MODE*.

000002cb <__c.2209>:
     2cb:	46 41 49 4c 45 44 00                                FAILED.

000002d2 <__c.2207>:
     2d2:	50 52 4f 47 52 41 4d 4d 49 4e 47 20 44 4f 4e 45     PROGRAMMING DONE
	...

000002e3 <__c.2205>:
     2e3:	4e 4f 20 4c 4f 43 4b 20 42 59 54 45 53 00           NO LOCK BYTES.

000002f1 <__c.2203>:
     2f1:	4e 4f 20 46 55 53 45 20 42 59 54 45 53 00           NO FUSE BYTES.

000002ff <__c.2201>:
     2ff:	4e 4f 20 45 45 50 52 4f 4d 00                       NO EEPROM.

00000309 <__c.2199>:
     309:	4e 4f 20 44 41 54 41 00                             NO DATA.

00000311 <__c.2197>:
     311:	4e 4f 20 45 52 41 53 45 20 43 4d 44 00              NO ERASE CMD.

0000031e <__c.2094>:
     31e:	42 41 44 49 53 52 00                                BADISR.

00000325 <__c.2031>:
     325:	50 52 47 3e 20 20 00                                PRG>  .

0000032c <LCD_SegTable>:
     32c:	a8 ea 80 2a 00 40 00 0a 51 0a 08 40 59 55 18 01     ...*.@..Q..@YU..
     33c:	11 1e 11 1b 50 0b 41 1b 41 1f 11 01 51 1f 51 1b     ....P.A.A...Q.Q.
     34c:	00 00 00 00 08 80 00 1a 20 40 00 00 00 00 51 0f     ........ @....Q.
     35c:	91 39 41 14 91 31 41 1e 41 0e 41 1d 50 0f 80 20     .9A..1A.A.A.P.. 
     36c:	10 15 48 86 40 14 78 05 70 85 51 15 51 0e 51 95     ..H.@.x.p.Q.Q.Q.
     37c:	51 8e 21 90 81 20 50 15 48 44 50 c5 28 c0 28 20     Q.!.. P.HDP.(.( 
     38c:	09 50 41 14 20 80 11 11 00 00 00 10                 .PA. .......

00000398 <USIPSValues>:
     398:	03 80 02 54 01 40 00 22                             ...T.@."

000003a0 <DF_PageBits>:
     3a0:	09 09 09 09 09 0a 0a 0b                             ........

000003a8 <DF_PageSize>:
     3a8:	08 01 08 01 08 01 08 01 08 01 10 02 10 02 20 04     .............. .

000003b8 <DF_Pages>:
     3b8:	00 01 00 02 00 04 00 08 00 10 00 10 00 20 00 20     ............. . 

000003c8 <DataFlashError>:
     3c8:	44 41 54 41 46 4c 41 53 48 20 45 52 52 4f 52 00     DATAFLASH ERROR.

000003d8 <__c.1862>:
     3d8:	42 55 46 46 20 4f 56 46 00                          BUFF OVF.

000003e1 <AutoSleepTOValues>:
     3e1:	00 0f 1e 3c 78                                      ...<x

000003e6 <__c.1865>:
     3e6:	46 52 41 4d 45 20 45 52 52 00                       FRAME ERR.

000003f0 <__c.1863>:
     3f0:	44 41 54 41 20 4f 56 52 00                          DATA OVR.

000003f9 <DataFlashProgMode>:
     3f9:	2a 44 41 54 41 46 4c 41 53 48 20 4d 4f 44 45 2a     *DATAFLASH MODE*
	...

0000040a <SignonResponse>:
     40a:	01 00 08 41 56 52 49 53 50 5f 32 00                 ...AVRISP_2.

00000416 <ButtLoadData>:
     416:	40 28 23 29 2a 53 43 52 45 57 20 52 45 54 52 4f     @(#)*SCREW RETRO
     426:	44 41 4e 00 2a                                      DAN.*

0000042b <SyncErrorMessage>:
     42b:	53 59 4e 43 20 45 52 52 4f 52 00                    SYNC ERROR.

00000436 <AVRISPModeMessage>:
     436:	2a 41 54 41 56 52 49 53 50 20 4d 4f 44 45 2a 00     *ATAVRISP MODE*.

00000446 <__c.2148>:
     446:	4c 4f 43 4b 2d 00                                   LOCK-.

0000044c <__c.2145>:
     44c:	46 55 53 45 2d 00                                   FUSE-.

00000452 <__c.2142>:
     452:	45 50 52 4d 2d 00                                   EPRM-.

00000458 <__c.2138>:
     458:	44 41 54 41 2d 00                                   DATA-.

0000045e <__c.1884>:
     45e:	4e 4f 20 54 41 47 53 00                             NO TAGS.

00000466 <__ctors_end>:
     466:	11 24       	eor	r1, r1
     468:	1f be       	out	0x3f, r1	; 63
     46a:	cf ef       	ldi	r28, 0xFF	; 255
     46c:	d4 e0       	ldi	r29, 0x04	; 4
     46e:	de bf       	out	0x3e, r29	; 62
     470:	cd bf       	out	0x3d, r28	; 61

00000472 <__do_copy_data>:
     472:	11 e0       	ldi	r17, 0x01	; 1
     474:	a0 e0       	ldi	r26, 0x00	; 0
     476:	b1 e0       	ldi	r27, 0x01	; 1
     478:	e6 eb       	ldi	r30, 0xB6	; 182
     47a:	f5 e3       	ldi	r31, 0x35	; 53
     47c:	02 c0       	rjmp	.+4      	; 0x482 <.do_copy_data_start>

0000047e <.do_copy_data_loop>:
     47e:	05 90       	lpm	r0, Z+
     480:	0d 92       	st	X+, r0

00000482 <.do_copy_data_start>:
     482:	a4 30       	cpi	r26, 0x04	; 4
     484:	b1 07       	cpc	r27, r17
     486:	d9 f7       	brne	.-10     	; 0x47e <.do_copy_data_loop>

00000488 <__do_clear_bss>:
     488:	12 e0       	ldi	r17, 0x02	; 2
     48a:	a4 e0       	ldi	r26, 0x04	; 4
     48c:	b1 e0       	ldi	r27, 0x01	; 1
     48e:	01 c0       	rjmp	.+2      	; 0x492 <.do_clear_bss_start>

00000490 <.do_clear_bss_loop>:
     490:	1d 92       	st	X+, r1

00000492 <.do_clear_bss_start>:
     492:	a6 3b       	cpi	r26, 0xB6	; 182
     494:	b1 07       	cpc	r27, r17
     496:	e1 f7       	brne	.-8      	; 0x490 <.do_clear_bss_loop>
     498:	0e 94 37 06 	call	0xc6e	; 0xc6e <main>
     49c:	0c 94 da 1a 	jmp	0x35b4	; 0x35b4 <_exit>

000004a0 <__bad_interrupt>:
     4a0:	0c 94 f0 04 	jmp	0x9e0	; 0x9e0 <__vector_default>

000004a4 <MAIN_Delay10MS>:

// ======================================================================================

void MAIN_Delay10MS(uint8_t loops)
{
     4a4:	28 2f       	mov	r18, r24
     4a6:	e0 e0       	ldi	r30, 0x00	; 0
     4a8:	f8 e4       	ldi	r31, 0x48	; 72
     4aa:	03 c0       	rjmp	.+6      	; 0x4b2 <MAIN_Delay10MS+0xe>
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     4ac:	cf 01       	movw	r24, r30
     4ae:	01 97       	sbiw	r24, 0x01	; 1
     4b0:	f1 f7       	brne	.-4      	; 0x4ae <MAIN_Delay10MS+0xa>
  /* Prevents the use of floating point libraries. Delaying in groups of
     10ms increases accuracy by reducing the time overhead for each loop
     interation of the while.                                            */

	while (loops--)
     4b2:	21 50       	subi	r18, 0x01	; 1
     4b4:	d8 f7       	brcc	.-10     	; 0x4ac <MAIN_Delay10MS+0x8>
     4b6:	08 95       	ret

000004b8 <MAIN_Delay1MS>:
	  _delay_ms(10);
}

void MAIN_Delay1MS(uint8_t loops)
{
     4b8:	28 2f       	mov	r18, r24
     4ba:	e3 e3       	ldi	r30, 0x33	; 51
     4bc:	f7 e0       	ldi	r31, 0x07	; 7
     4be:	03 c0       	rjmp	.+6      	; 0x4c6 <MAIN_Delay1MS+0xe>
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     4c0:	cf 01       	movw	r24, r30
     4c2:	01 97       	sbiw	r24, 0x01	; 1
     4c4:	f1 f7       	brne	.-4      	; 0x4c2 <MAIN_Delay1MS+0xa>
  /* Prevents the use of floating point libraries. Less accurate than the
     Delay10MS routine, but nessesary for many commands. The overhead required
     to call the routine is substantially less than the overhead required to
     calculate the float at compile time, so this actually saves execution time. */

	while (loops--)
     4c6:	21 50       	subi	r18, 0x01	; 1
     4c8:	d8 f7       	brcc	.-10     	; 0x4c0 <MAIN_Delay1MS+0x8>
     4ca:	08 95       	ret

000004cc <MAIN_ResetCSLine>:
	  _delay_ms(1);
}

void MAIN_ResetCSLine(const uint8_t ActiveInactive)
{
     4cc:	81 30       	cpi	r24, 0x01	; 1
     4ce:	81 f0       	breq	.+32     	; 0x4f0 <MAIN_ResetCSLine+0x24>
	/* ActiveInactive controls the /Reset line to an AVR device or external dataflash
	/CS line. If the reset polarity parameter is a 0 then interfacing with AT89
	devices which has an active high reset. Pins are tristated when inactive.         */
	
	switch (ActiveInactive)
     4d0:	81 30       	cpi	r24, 0x01	; 1
     4d2:	18 f0       	brcs	.+6      	; 0x4da <MAIN_ResetCSLine+0xe>
     4d4:	82 30       	cpi	r24, 0x02	; 2
     4d6:	01 f5       	brne	.+64     	; 0x518 <__stack+0x19>
     4d8:	09 c0       	rjmp	.+18     	; 0x4ec <MAIN_ResetCSLine+0x20>
	{
		case MAIN_RESETCS_ACTIVE:                // The target RESET line may be either active high or low.
			DDRF |= (1 << 6);
     4da:	86 9a       	sbi	0x10, 6	; 16
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     4dc:	a1 e0       	ldi	r26, 0x01	; 1
     4de:	b0 e0       	ldi	r27, 0x00	; 0
     4e0:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
     4e4:	80 2d       	mov	r24, r0
		
			if (eeprom_read_byte(&EEPROMVars.ResetPolarity)) // Translate to correct active logic level for target device type
     4e6:	88 23       	and	r24, r24
     4e8:	59 f4       	brne	.+22     	; 0x500 <__stack+0x1>
     4ea:	13 c0       	rjmp	.+38     	; 0x512 <__stack+0x13>
			  PORTF &= ~(1 << 6);
			else
			  PORTF |= (1 << 6);
		
			break;
		case MAIN_RESETCS_EXTDFACTIVE:           // Dataflashes are always active low.
			DDRF  |=  (1 << 6);
     4ec:	86 9a       	sbi	0x10, 6	; 16
     4ee:	08 c0       	rjmp	.+16     	; 0x500 <__stack+0x1>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     4f0:	ac e8       	ldi	r26, 0x8C	; 140
     4f2:	b0 e0       	ldi	r27, 0x00	; 0
     4f4:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
     4f8:	80 2d       	mov	r24, r0
			PORTF &= ~(1 << 6);
			
			break;
		case MAIN_RESETCS_INACTIVE:              // Must determine what to do for inactive RESET.
			if (eeprom_read_byte(&EEPROMVars.SPIResetMode)) // FLOAT mode reset
     4fa:	88 23       	and	r24, r24
     4fc:	19 f0       	breq	.+6      	; 0x504 <__stack+0x5>
			{
				DDRF  &= ~(1 << 6);
     4fe:	86 98       	cbi	0x10, 6	; 16
				PORTF &= ~(1 << 6);
     500:	8e 98       	cbi	0x11, 6	; 17
     502:	08 95       	ret
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     504:	a1 e0       	ldi	r26, 0x01	; 1
     506:	b0 e0       	ldi	r27, 0x00	; 0
     508:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
     50c:	80 2d       	mov	r24, r0
			}
			else                                 // ACTIVE mode reset
			{
				if (eeprom_read_byte(&EEPROMVars.ResetPolarity)) // Translate to correct inactive logic level for target device type
     50e:	88 23       	and	r24, r24
     510:	11 f0       	breq	.+4      	; 0x516 <__stack+0x17>
				  PORTF |= (1 << 6);
     512:	8e 9a       	sbi	0x11, 6	; 17
     514:	08 95       	ret
				else
				  PORTF &= ~(1 << 6);			
     516:	8e 98       	cbi	0x11, 6	; 17
     518:	08 95       	ret

0000051a <MAIN_WaitForJoyRelease>:
			}
	}
}

void MAIN_WaitForJoyRelease(void)
{
     51a:	8e b3       	in	r24, 0x1e	; 30
     51c:	81 30       	cpi	r24, 0x01	; 1
     51e:	11 f4       	brne	.+4      	; 0x524 <MAIN_WaitForJoyRelease+0xa>
	if (JoyStatus == 1)                          // If invalid value used to force menu drawing, reset value and exit
	{
		JoyStatus = 0;
     520:	1e ba       	out	0x1e, r1	; 30
     522:	08 95       	ret
		return;
	}

	for (;;)
	{
		while (JoyStatus) {};                    // Wait until joystick released
     524:	8e b3       	in	r24, 0x1e	; 30
     526:	88 23       	and	r24, r24
     528:	e9 f7       	brne	.-6      	; 0x524 <MAIN_WaitForJoyRelease+0xa>

		MAIN_Delay10MS(2);
     52a:	82 e0       	ldi	r24, 0x02	; 2
     52c:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>

		if (!(JoyStatus))                        // Joystick still released (not bouncing), return
     530:	8e b3       	in	r24, 0x1e	; 30
     532:	88 23       	and	r24, r24
     534:	b9 f7       	brne	.-18     	; 0x524 <MAIN_WaitForJoyRelease+0xa>
     536:	08 95       	ret

00000538 <MAIN_IntToStr>:
		  return;
	}
}

void MAIN_IntToStr(uint16_t IntV, uint8_t* Buff)
{
     538:	cf 93       	push	r28
     53a:	df 93       	push	r29
     53c:	fb 01       	movw	r30, r22
     53e:	20 e0       	ldi	r18, 0x00	; 0
     540:	03 c0       	rjmp	.+6      	; 0x548 <MAIN_IntToStr+0x10>
	// Shows leading zeros, unlike itoa.

	uint8_t Temp = 0;
	
	while (IntV >= 100)
	{
		Temp++;
     542:	2f 5f       	subi	r18, 0xFF	; 255
		IntV -= 100;
     544:	84 56       	subi	r24, 0x64	; 100
     546:	90 40       	sbci	r25, 0x00	; 0
     548:	84 36       	cpi	r24, 0x64	; 100
     54a:	91 05       	cpc	r25, r1
     54c:	d0 f7       	brcc	.-12     	; 0x542 <MAIN_IntToStr+0xa>
	}

	*(Buff++) = '0' + Temp;
     54e:	20 5d       	subi	r18, 0xD0	; 208
     550:	21 93       	st	Z+, r18
     552:	df 01       	movw	r26, r30
     554:	20 e0       	ldi	r18, 0x00	; 0
     556:	02 c0       	rjmp	.+4      	; 0x55c <MAIN_IntToStr+0x24>
	
	Temp = 0;
	
	while (IntV >= 10)
	{
		Temp++;
     558:	2f 5f       	subi	r18, 0xFF	; 255
		IntV -= 10;
     55a:	0a 97       	sbiw	r24, 0x0a	; 10
     55c:	8a 30       	cpi	r24, 0x0A	; 10
     55e:	91 05       	cpc	r25, r1
     560:	d8 f7       	brcc	.-10     	; 0x558 <MAIN_IntToStr+0x20>
	}
		
	*(Buff++) = '0' + Temp;
     562:	20 5d       	subi	r18, 0xD0	; 208
     564:	fd 01       	movw	r30, r26
     566:	21 93       	st	Z+, r18
	*(Buff++) = '0' + IntV;
     568:	80 5d       	subi	r24, 0xD0	; 208
     56a:	ed 01       	movw	r28, r26
     56c:	89 83       	std	Y+1, r24	; 0x01
	*(Buff)   = '\0';
     56e:	11 82       	std	Z+1, r1	; 0x01
     570:	df 91       	pop	r29
     572:	cf 91       	pop	r28
     574:	08 95       	ret

00000576 <__vector_3>:
}

void MAIN_ShowProgType(const uint8_t Letter)
{
	uint8_t ProgTypeBuffer[7];

	strcpy_P(ProgTypeBuffer, PSTR("PRG>  "));
	ProgTypeBuffer[5] = Letter;
	
	LCD_puts(ProgTypeBuffer);
}

void MAIN_ShowError(const uint8_t *pFlashStr)
{
	uint8_t ErrorBuff[LCD_TEXTBUFFER_SIZE];      // New buffer, LCD text buffer size
	
	ErrorBuff[0] = 'E';
	ErrorBuff[1] = '>';

	strcpy_P(&ErrorBuff[2], pFlashStr);          // WARNING: If flash error text is larger than (TEXTBUFFER_SIZE - 1),
	                                             // this will overflow the buffer and crash the program!
	LCD_puts(ErrorBuff);
	
	MAIN_WaitForJoyRelease();
	while (!(JoyStatus & JOY_PRESS)) {};
	MAIN_WaitForJoyRelease();
}

void MAIN_CrashProgram(const uint8_t *ErrTxtPtr)
{
	SPI_SPIOFF();
	USI_SPIOff();
	TIMEOUT_PACKET_TIMER_OFF();
	TIMEOUT_SLEEP_TIMER_OFF();
	USART_ENABLE(USART_TX_OFF, USART_RX_OFF);

	LCD_puts_f(ErrTxtPtr);
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);	

	for (;;)
	{
		MAIN_Delay10MS(50);
		PORTF ^= MAIN_STATLED_RED;               // Loop forever, blinking the status LED from orange to red and back
	}
}

// ======================================================================================

ISR(PCINT1_vect, ISR_NOBLOCK)                    // Joystick routine; PCINT0_vect is bound to this also via JoystickInterrupt.S
{
     576:	78 94       	sei
     578:	1f 92       	push	r1
     57a:	0f 92       	push	r0
     57c:	0f b6       	in	r0, 0x3f	; 63
     57e:	0f 92       	push	r0
     580:	11 24       	eor	r1, r1
     582:	8f 93       	push	r24
     584:	9f 93       	push	r25
	JoyStatus = (~PINB & JOY_BMASK)
     586:	83 b1       	in	r24, 0x03	; 3
     588:	9c b1       	in	r25, 0x0c	; 12
     58a:	80 95       	com	r24
     58c:	80 7d       	andi	r24, 0xD0	; 208
     58e:	90 95       	com	r25
     590:	9c 70       	andi	r25, 0x0C	; 12
     592:	89 2b       	or	r24, r25
     594:	8e bb       	out	0x1e, r24	; 30
	          | (~PINE & JOY_EMASK);
			  
	TIMEOUT_SLEEP_TIMEOUT_RESET();
     596:	10 92 8e 01 	sts	0x018E, r1
     59a:	10 92 8d 01 	sts	0x018D, r1
     59e:	10 92 85 00 	sts	0x0085, r1
     5a2:	10 92 84 00 	sts	0x0084, r1
     5a6:	9f 91       	pop	r25
     5a8:	8f 91       	pop	r24
     5aa:	0f 90       	pop	r0
     5ac:	0f be       	out	0x3f, r0	; 63
     5ae:	0f 90       	pop	r0
     5b0:	1f 90       	pop	r1
     5b2:	18 95       	reti

000005b4 <FUNCSleepMode>:
}

ISR(BADISR_vect, ISR_NAKED)                      // Bad ISR routine; should never be called, here for safety
{
	MAIN_CrashProgram(PSTR("BADISR"));
}

// ======================================================================================

void FUNCChangeSettings(void)
{
	uint8_t CurrSFunc = 0;
	
	JoyStatus = 1;

	for (;;)
	{
		if (JoyStatus)                           // Joystick is in the non-center position
		{
			if (JoyStatus & JOY_UP)              // Previous function
			  (CurrSFunc == 0)? CurrSFunc = ARRAY_UPPERBOUND(SettingFunctionPtrs) : CurrSFunc--;
			else if (JoyStatus & JOY_DOWN)       // Next function
			  (CurrSFunc == ARRAY_UPPERBOUND(SettingFunctionPtrs))? CurrSFunc = 0 : CurrSFunc++;
			else if (JoyStatus & JOY_PRESS)      // Select current function
			  ((FuncPtr)pgm_read_word(&SettingFunctionPtrs[CurrSFunc]))(); // Run associated function
			else if (JoyStatus & JOY_LEFT)
			  return;
		
			// Show current function onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&SettingFunctionNames[CurrSFunc]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCShowAbout(void)
{
	uint8_t InfoNum = 0;
	
	JoyStatus = 1;
			
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			  (InfoNum == 0)? InfoNum = ARRAY_UPPERBOUND(AboutTextPtrs) : InfoNum--;
			else if (JoyStatus & JOY_DOWN)
			  (InfoNum == ARRAY_UPPERBOUND(AboutTextPtrs))? InfoNum = 0 : InfoNum++;
			else if (JoyStatus & JOY_LEFT)
			  return;

			LCD_puts_f((uint8_t*)pgm_read_word(&AboutTextPtrs[InfoNum]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCAVRISPMode(void)
{
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(AVRISPModeMessage);
	
	V2P_RunStateMachine(AICI_InterpretPacket);
}

void FUNCProgramDataflash(void)
{
	USI_SPIInitMaster();
	DataflashInfo.UseExernalDF = TRUE;
	DFSPIRoutinePointer = USI_SPITransmit;
	
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(DataFlashProgMode);

	V2P_RunStateMachine(PD_InterpretAVRISPPacket);
	   
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
}

void FUNCProgramAVR(void)
{
	uint8_t  DoneFailMessageBuff[19];
	uint8_t  Fault    = ISPCC_NO_FAULT;
	uint8_t  ProgMode = 0;

	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
	SPI_SPIInit();
	DataflashInfo.UseExernalDF = FALSE;
	
	if (!(DF_CheckCorrectOnboardChip()))
	  return;

	MAIN_WaitForJoyRelease();
	
	JoyStatus = 1;                               // Use an invalid joystick value to force the program to write the
	                                             // name of the default command onto the LCD
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_LEFT)
			  return;
			else if (JoyStatus & JOY_PRESS)
			  break;
			else if (JoyStatus & JOY_UP)
			  (ProgMode == 0)? ProgMode = ARRAY_UPPERBOUND(ProgOptions) : ProgMode--;
			else if (JoyStatus & JOY_DOWN)
			  (ProgMode == ARRAY_UPPERBOUND(ProgOptions))? ProgMode = 0 : ProgMode++;

			LCD_puts_f((uint8_t*)pgm_read_word(&ProgOptions[ProgMode])); // Show current function onto the LCD

			MAIN_WaitForJoyRelease();
		}
	}

	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_BASECLOCKSPEED_8MHZ);
	LCD_puts_f(WaitText);

	TIMEOUT_SLEEP_TIMER_OFF();

	USI_SPIInitMaster();
	MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);       // Capture the RESET line of the slave AVR
			
	for (uint8_t PacketB = 0; PacketB < 12; PacketB++) // Read the enter programming mode command bytes
	  PacketBytes[PacketB] = eeprom_read_byte(&EEPROMVars.EnterProgMode[PacketB]);
	
	ISPCC_EnterChipProgrammingMode();            // Try to sync with the slave AVR

	CurrAddress = 0;

	if (PacketBytes[1] == AICB_STATUS_CMD_OK)    // ISPCC_EnterChipProgrammingMode alters the PacketBytes buffer rather than returning a value
	{						
		if (!(ProgMode) || (ProgMode == 7) || (ProgMode == 1) || (ProgMode == 3)) // All, erase chip, flash and eeprom, or program flash mode
		{
			MAIN_ShowProgType('C');
			
			if (!(eeprom_read_byte(&EEPROMVars.EraseCmdStored) == TRUE))
			{
				Fault = ISPCC_FAULT_NOERASE;
				MAIN_ShowError(PSTR("NO ERASE CMD"));
			}
			else
			{
				PM_SendEraseCommand();
			}
		}

		if ((!(ProgMode) || (ProgMode == 1) || (ProgMode == 3)) && (Fault == ISPCC_NO_FAULT)) // All, flash and EEPROM, or program flash mode
		{
			MAIN_ShowProgType('D');

			if (!(PM_GetStoredDataSize(TYPE_FLASH))) // Check to make sure a program is present in memory
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
				MAIN_ShowError(PSTR("NO DATA"));
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_FLASH);
			}
		}
	
		if (!(ProgMode) || (ProgMode == 2) || (ProgMode == 3)) // All, flash and EEPROM, or program EEPROM mode
		{
			MAIN_ShowProgType('E');
				
			if (!(PM_GetStoredDataSize(TYPE_EEPROM))) // Check to make sure EEPROM data is present in memory
			{
				Fault = ISPCC_FAULT_NODATATYPE;
				MAIN_ShowError(PSTR("NO EEPROM"));
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_EEPROM);
			}
		}

		if (!(ProgMode) || (ProgMode == 4) || (ProgMode == 6)) // All, fuse and lock bytes, or program fuse bytes mode
		{
			MAIN_ShowProgType('F');
			
			if (!(eeprom_read_byte(&EEPROMVars.TotalFuseBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
				MAIN_ShowError(PSTR("NO FUSE BYTES"));
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_FUSE);
			}
		}

		if (!(ProgMode) || (ProgMode == 5) || (ProgMode == 6)) // All, fuse and lock bytes, or program lock bytes mode
		{
			if (ProgMode == 6)                           // If fusebytes have already been written, we need to reenter programming mode to latch them
			{
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line of the slave AVR
				MAIN_Delay10MS(1);
				MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);   // Capture the RESET line of the slave AVR
				ISPCC_EnterChipProgrammingMode();        // Try to sync with the slave AVR
			}

			MAIN_ShowProgType('L');
		
			if (!(eeprom_read_byte(&EEPROMVars.TotalLockBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;
				MAIN_ShowError(PSTR("NO LOCK BYTES"));
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_LOCK);
			}
		}

		strcpy_P(DoneFailMessageBuff, PSTR("PROGRAMMING DONE"));

		if (Fault != ISPCC_NO_FAULT)             // Takes less code to just overwrite part of the string on fail
		  strcpy_P(&DoneFailMessageBuff[12], PSTR("FAILED"));

		LCD_puts(DoneFailMessageBuff);

		MAIN_Delay10MS(250);
		MAIN_Delay10MS(200);
	}
	else
	{
		MAIN_ShowError(SyncErrorMessage);
	}
	
	TOUT_SetupSleepTimer();
	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_BASECLOCKSPEED_1MHZ);
	MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);     // Release the RESET line and allow the slave AVR to run	
	USI_SPIOff();
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);       // Set status LEDs to green (ready)
}

void FUNCStoreProgram(void)
{
	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
	SPI_SPIInit();
	DataflashInfo.UseExernalDF = FALSE;
	DF_EnableDataflash(TRUE);

	if (!(DF_CheckCorrectOnboardChip()))
	  return;
			
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(PSTR("*STORAGE MODE*"));

	V2P_RunStateMachine(PM_InterpretAVRISPPacket);
	
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
}

void FUNCClearMem(void)
{
	LCD_puts_f(PSTR("CONFIRM"));
	MAIN_Delay10MS(180);

	LCD_puts_f(PSTR("<N Y>"));

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_LEFT)
			  return;
			else if (JoyStatus & JOY_RIGHT)
			  break;
		}
	}

	MAIN_WaitForJoyRelease();

	LCD_puts_f(WaitText);
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);      // Set status LEDs to orange (busy)

	for (uint16_t EAddr = 0; EAddr < sizeof(EEPROMVars); EAddr++)
	  eeprom_write_byte((uint8_t*)EAddr, 0xFF);

	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);       // Set status LEDs to green (ready)
	LCD_puts_f(PSTR("MEM CLEARED"));
	MAIN_Delay10MS(250);
}

void FUNCSetContrast(void)
{
	uint8_t Buffer[6];
	uint8_t Contrast = (eeprom_read_byte(&EEPROMVars.LCDContrast) & 0x0F); // Ranges from 0-15 so mask retuns 15 on blank EEPROM (0xFF)
	
	JoyStatus = 1;                               // Invalid value to force the LCD to update
	
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				if (Contrast < 15)
				  Contrast++;
			}
			else if (JoyStatus & JOY_DOWN)
			{
				if (Contrast > 1)                // Zero is non-visible, so 1 is the minimum
				  Contrast--;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.LCDContrast, Contrast);
				return;
			}
					
			Buffer[0] = 'C';
			Buffer[1] = 'T';
			Buffer[2] = ' ';

			MAIN_IntToStr((uint16_t)Contrast, &Buffer[3]);
			LCD_puts(Buffer);

			LCD_CONTRAST_LEVEL(Contrast);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCSetISPSpeed(void)
{
	uint8_t CurrSpeed = eeprom_read_byte(&EEPROMVars.SCKDuration);

	if (CurrSpeed > ARRAY_UPPERBOUND(USISpeeds))
	  CurrSpeed = ARRAY_UPPERBOUND(USISpeeds);   // Protection against blank EEPROM

	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				(CurrSpeed == 0)? CurrSpeed = ARRAY_UPPERBOUND(USISpeeds) : CurrSpeed--;
			}
			else if (JoyStatus & JOY_DOWN)
			{
				(CurrSpeed == ARRAY_UPPERBOUND(USISpeeds))? CurrSpeed = 0 : CurrSpeed++;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.SCKDuration, CurrSpeed);
				return;
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f(USISpeeds[CurrSpeed]);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCSetResetMode(void)
{
	uint8_t CurrMode = (eeprom_read_byte(&EEPROMVars.SPIResetMode) & 0x01);

	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if ((JoyStatus & JOY_UP) || (JoyStatus & JOY_DOWN))
			{
				CurrMode ^= 1;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.SPIResetMode, CurrMode);
				return;
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f(SPIResetModes[CurrMode]);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCSetFirmMinorVer(void)
{
	uint8_t VerBuffer[5];
	uint8_t VerMinor = eeprom_read_byte(&EEPROMVars.FirmVerMinor);

	if (VerMinor > 9)
	  VerMinor = V2P_SW_VERSION_MINOR_DEFAULT;
	
	strcpy_P(VerBuffer, PSTR("V2- "));

	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				if (VerMinor < 9)
				  VerMinor++;
			}
			if (JoyStatus & JOY_DOWN)
			{
				if (VerMinor)
				  VerMinor--;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.FirmVerMinor, VerMinor);
				return;
			}
			
			VerBuffer[3] = ('0' + VerMinor);
			LCD_puts(VerBuffer);

			MAIN_WaitForJoyRelease();
		}
	}	
}

void FUNCSetAutoSleepTimeOut(void)
{
	uint8_t SleepTxtBuffer[8];
	uint8_t SleepVal = eeprom_read_byte(&EEPROMVars.AutoSleepValIndex);

	if (SleepVal > ARRAY_UPPERBOUND(AutoSleepTOValues))
	  SleepVal = ARRAY_UPPERBOUND(AutoSleepTOValues);

	strcpy_P(SleepTxtBuffer, PSTR("    SEC"));
	
	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				(SleepVal == 0)? SleepVal = ARRAY_UPPERBOUND(AutoSleepTOValues) : SleepVal--;
			}
			if (JoyStatus & JOY_DOWN)
			{
				(SleepVal == ARRAY_UPPERBOUND(AutoSleepTOValues))? SleepVal = 0 : SleepVal++;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.AutoSleepValIndex, SleepVal);
				TOUT_SetupSleepTimer();
				return;
			}

			if (!(SleepVal))
			{
				LCD_puts_f(PSTR("OFF"));
			}
			else
			{
				MAIN_IntToStr(pgm_read_byte(&AutoSleepTOValues[SleepVal]), &SleepTxtBuffer[0]);
				SleepTxtBuffer[3] = ' ';         // Remove the auto-string termination from the buffer
				LCD_puts(SleepTxtBuffer);
			}

			MAIN_WaitForJoyRelease();
		}
	}	
}

void FUNCSleepMode(void)
{
     5b4:	85 e0       	ldi	r24, 0x05	; 5
     5b6:	83 bf       	out	0x33, r24	; 51
	SMCR    = ((1 << SM1) | (1 << SE));          // Power down sleep mode
	LCDCRA &= ~(1 << LCDEN); 
     5b8:	80 91 e4 00 	lds	r24, 0x00E4
     5bc:	8f 77       	andi	r24, 0x7F	; 127
     5be:	80 93 e4 00 	sts	0x00E4, r24
	
	MAIN_SETSTATUSLED(MAIN_STATLED_OFF);         // Save battery power - turn off status LED
     5c2:	81 b3       	in	r24, 0x11	; 17
     5c4:	8f 7c       	andi	r24, 0xCF	; 207
     5c6:	81 bb       	out	0x11, r24	; 17
     5c8:	01 c0       	rjmp	.+2      	; 0x5cc <FUNCSleepMode+0x18>

	while (!(JoyStatus & JOY_UP))                // Joystick interrupt wakes the micro
	  SLEEP();
     5ca:	88 95       	sleep
     5cc:	f6 9b       	sbis	0x1e, 6	; 30
     5ce:	fd cf       	rjmp	.-6      	; 0x5ca <FUNCSleepMode+0x16>
	   
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);       // Turn status LED back on
     5d0:	81 b3       	in	r24, 0x11	; 17
     5d2:	8f 7c       	andi	r24, 0xCF	; 207
     5d4:	80 61       	ori	r24, 0x10	; 16
     5d6:	81 bb       	out	0x11, r24	; 17

	LCDCRA |= (1 << LCDEN);
     5d8:	80 91 e4 00 	lds	r24, 0x00E4
     5dc:	80 68       	ori	r24, 0x80	; 128
     5de:	80 93 e4 00 	sts	0x00E4, r24
	
	MAIN_WaitForJoyRelease();
     5e2:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     5e6:	08 95       	ret

000005e8 <FUNCGoBootloader>:
}

void FUNCStorageInfo(void)
{
	uint8_t SelectedItem = 0;

	MAIN_WaitForJoyRelease();

	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & (JOY_UP | JOY_DOWN))
			{
				SelectedItem ^= 1;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				return;
			}
			else if (JoyStatus & JOY_PRESS)
			{
				if (SelectedItem == 1)           // View storage tags
				{
					DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
					SPI_SPIInit();
					DataflashInfo.UseExernalDF = FALSE;
					DF_EnableDataflash(TRUE);

					if (DF_CheckCorrectOnboardChip())
					{
						TM_ShowTags();
						SPI_SPIOFF();
					}
					else if (!(PM_GetStoredDataSize(TYPE_FLASH)))
					{
						DF_EnableDataflash(FALSE);
						SPI_SPIOFF();

						MAIN_ShowError(PSTR("NO STORED PRGM"));
					}	
				}
				else                             // View stored data sizes
				{
					PM_ShowStoredItemSizes();
				}
			}
			
			LCD_puts_f(SIFONames[SelectedItem]);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCGoBootloader(void)
{
     5e8:	85 b7       	in	r24, 0x35	; 53
     5ea:	8f 77       	andi	r24, 0x7F	; 127
	uint8_t MD = (MCUCR & ~(1 << JTD));         // Forces compiler to use IN, AND plus two OUTs rather than two lots of IN/AND/OUTs
	MCUCR = MD;                                 // Turn on JTAG via code
     5ec:	85 bf       	out	0x35, r24	; 53
	MCUCR = MD;                                 // Set bit twice as specified in datasheet        
     5ee:	85 bf       	out	0x35, r24	; 53

	TIMEOUT_SLEEP_TIMER_OFF();
     5f0:	10 92 81 00 	sts	0x0081, r1
	
	LCD_puts_f(PSTR("*JTAG ON*"));
     5f4:	88 e7       	ldi	r24, 0x78	; 120
     5f6:	92 e0       	ldi	r25, 0x02	; 2
     5f8:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
	
	MAIN_WaitForJoyRelease();
     5fc:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
	
	WDTCR = ((1<<WDCE) | (1<<WDE));             // Enable Watchdog Timer to give reset after minimum timeout
     600:	88 e1       	ldi	r24, 0x18	; 24
     602:	80 93 60 00 	sts	0x0060, r24
     606:	ff cf       	rjmp	.-2      	; 0x606 <FUNCGoBootloader+0x1e>

00000608 <FUNCShowAbout>:
     608:	1f 93       	push	r17
     60a:	81 e0       	ldi	r24, 0x01	; 1
     60c:	8e bb       	out	0x1e, r24	; 30
     60e:	10 e0       	ldi	r17, 0x00	; 0
     610:	8e b3       	in	r24, 0x1e	; 30
     612:	88 23       	and	r24, r24
     614:	e9 f3       	breq	.-6      	; 0x610 <FUNCShowAbout+0x8>
     616:	f6 9b       	sbis	0x1e, 6	; 30
     618:	06 c0       	rjmp	.+12     	; 0x626 <FUNCShowAbout+0x1e>
     61a:	11 23       	and	r17, r17
     61c:	11 f4       	brne	.+4      	; 0x622 <FUNCShowAbout+0x1a>
     61e:	13 e0       	ldi	r17, 0x03	; 3
     620:	0c c0       	rjmp	.+24     	; 0x63a <FUNCShowAbout+0x32>
     622:	11 50       	subi	r17, 0x01	; 1
     624:	0a c0       	rjmp	.+20     	; 0x63a <FUNCShowAbout+0x32>
     626:	f7 9b       	sbis	0x1e, 7	; 30
     628:	06 c0       	rjmp	.+12     	; 0x636 <FUNCShowAbout+0x2e>
     62a:	13 30       	cpi	r17, 0x03	; 3
     62c:	11 f4       	brne	.+4      	; 0x632 <FUNCShowAbout+0x2a>
     62e:	10 e0       	ldi	r17, 0x00	; 0
     630:	04 c0       	rjmp	.+8      	; 0x63a <FUNCShowAbout+0x32>
     632:	1f 5f       	subi	r17, 0xFF	; 255
     634:	02 c0       	rjmp	.+4      	; 0x63a <FUNCShowAbout+0x32>
     636:	f2 99       	sbic	0x1e, 2	; 30
     638:	0d c0       	rjmp	.+26     	; 0x654 <FUNCShowAbout+0x4c>
     63a:	e1 2f       	mov	r30, r17
     63c:	ff 27       	eor	r31, r31
     63e:	ee 0f       	add	r30, r30
     640:	ff 1f       	adc	r31, r31
     642:	e1 56       	subi	r30, 0x61	; 97
     644:	ff 4f       	sbci	r31, 0xFF	; 255
     646:	85 91       	lpm	r24, Z+
     648:	94 91       	lpm	r25, Z
     64a:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     64e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     652:	de cf       	rjmp	.-68     	; 0x610 <FUNCShowAbout+0x8>
     654:	1f 91       	pop	r17
     656:	08 95       	ret

00000658 <FUNCChangeSettings>:
     658:	1f 93       	push	r17
     65a:	81 e0       	ldi	r24, 0x01	; 1
     65c:	8e bb       	out	0x1e, r24	; 30
     65e:	10 e0       	ldi	r17, 0x00	; 0
     660:	8e b3       	in	r24, 0x1e	; 30
     662:	88 23       	and	r24, r24
     664:	e9 f3       	breq	.-6      	; 0x660 <FUNCChangeSettings+0x8>
     666:	f6 9b       	sbis	0x1e, 6	; 30
     668:	06 c0       	rjmp	.+12     	; 0x676 <FUNCChangeSettings+0x1e>
     66a:	11 23       	and	r17, r17
     66c:	11 f4       	brne	.+4      	; 0x672 <FUNCChangeSettings+0x1a>
     66e:	16 e0       	ldi	r17, 0x06	; 6
     670:	19 c0       	rjmp	.+50     	; 0x6a4 <FUNCChangeSettings+0x4c>
     672:	11 50       	subi	r17, 0x01	; 1
     674:	17 c0       	rjmp	.+46     	; 0x6a4 <FUNCChangeSettings+0x4c>
     676:	f7 9b       	sbis	0x1e, 7	; 30
     678:	06 c0       	rjmp	.+12     	; 0x686 <FUNCChangeSettings+0x2e>
     67a:	16 30       	cpi	r17, 0x06	; 6
     67c:	11 f4       	brne	.+4      	; 0x682 <FUNCChangeSettings+0x2a>
     67e:	10 e0       	ldi	r17, 0x00	; 0
     680:	11 c0       	rjmp	.+34     	; 0x6a4 <FUNCChangeSettings+0x4c>
     682:	1f 5f       	subi	r17, 0xFF	; 255
     684:	0f c0       	rjmp	.+30     	; 0x6a4 <FUNCChangeSettings+0x4c>
     686:	f4 9b       	sbis	0x1e, 4	; 30
     688:	0b c0       	rjmp	.+22     	; 0x6a0 <FUNCChangeSettings+0x48>
     68a:	e1 2f       	mov	r30, r17
     68c:	ff 27       	eor	r31, r31
     68e:	ee 0f       	add	r30, r30
     690:	ff 1f       	adc	r31, r31
     692:	e6 56       	subi	r30, 0x66	; 102
     694:	fe 4f       	sbci	r31, 0xFE	; 254
     696:	85 91       	lpm	r24, Z+
     698:	94 91       	lpm	r25, Z
     69a:	fc 01       	movw	r30, r24
     69c:	09 95       	icall
     69e:	02 c0       	rjmp	.+4      	; 0x6a4 <FUNCChangeSettings+0x4c>
     6a0:	f2 99       	sbic	0x1e, 2	; 30
     6a2:	0d c0       	rjmp	.+26     	; 0x6be <FUNCChangeSettings+0x66>
     6a4:	e1 2f       	mov	r30, r17
     6a6:	ff 27       	eor	r31, r31
     6a8:	ee 0f       	add	r30, r30
     6aa:	ff 1f       	adc	r31, r31
     6ac:	e4 57       	subi	r30, 0x74	; 116
     6ae:	fe 4f       	sbci	r31, 0xFE	; 254
     6b0:	85 91       	lpm	r24, Z+
     6b2:	94 91       	lpm	r25, Z
     6b4:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     6b8:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     6bc:	d1 cf       	rjmp	.-94     	; 0x660 <FUNCChangeSettings+0x8>
     6be:	1f 91       	pop	r17
     6c0:	08 95       	ret

000006c2 <FUNCSetAutoSleepTimeOut>:
     6c2:	ef 92       	push	r14
     6c4:	ff 92       	push	r15
     6c6:	0f 93       	push	r16
     6c8:	cf 93       	push	r28
     6ca:	df 93       	push	r29
     6cc:	cd b7       	in	r28, 0x3d	; 61
     6ce:	de b7       	in	r29, 0x3e	; 62
     6d0:	28 97       	sbiw	r28, 0x08	; 8
     6d2:	0f b6       	in	r0, 0x3f	; 63
     6d4:	f8 94       	cli
     6d6:	de bf       	out	0x3e, r29	; 62
     6d8:	0f be       	out	0x3f, r0	; 63
     6da:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     6dc:	ab e8       	ldi	r26, 0x8B	; 139
     6de:	b0 e0       	ldi	r27, 0x00	; 0
     6e0:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
     6e4:	80 2d       	mov	r24, r0
     6e6:	08 2f       	mov	r16, r24
     6e8:	85 30       	cpi	r24, 0x05	; 5
     6ea:	08 f0       	brcs	.+2      	; 0x6ee <FUNCSetAutoSleepTimeOut+0x2c>
     6ec:	04 e0       	ldi	r16, 0x04	; 4
     6ee:	65 e9       	ldi	r22, 0x95	; 149
     6f0:	72 e0       	ldi	r23, 0x02	; 2
     6f2:	ce 01       	movw	r24, r28
     6f4:	01 96       	adiw	r24, 0x01	; 1
     6f6:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <strcpy_P>
     6fa:	81 e0       	ldi	r24, 0x01	; 1
     6fc:	8e bb       	out	0x1e, r24	; 30
     6fe:	8e b3       	in	r24, 0x1e	; 30
     700:	88 23       	and	r24, r24
     702:	e9 f3       	breq	.-6      	; 0x6fe <FUNCSetAutoSleepTimeOut+0x3c>
     704:	f6 9b       	sbis	0x1e, 6	; 30
     706:	05 c0       	rjmp	.+10     	; 0x712 <FUNCSetAutoSleepTimeOut+0x50>
     708:	00 23       	and	r16, r16
     70a:	11 f4       	brne	.+4      	; 0x710 <FUNCSetAutoSleepTimeOut+0x4e>
     70c:	04 e0       	ldi	r16, 0x04	; 4
     70e:	01 c0       	rjmp	.+2      	; 0x712 <FUNCSetAutoSleepTimeOut+0x50>
     710:	01 50       	subi	r16, 0x01	; 1
     712:	f7 9b       	sbis	0x1e, 7	; 30
     714:	06 c0       	rjmp	.+12     	; 0x722 <FUNCSetAutoSleepTimeOut+0x60>
     716:	04 30       	cpi	r16, 0x04	; 4
     718:	11 f4       	brne	.+4      	; 0x71e <FUNCSetAutoSleepTimeOut+0x5c>
     71a:	00 e0       	ldi	r16, 0x00	; 0
     71c:	06 c0       	rjmp	.+12     	; 0x72a <FUNCSetAutoSleepTimeOut+0x68>
     71e:	0f 5f       	subi	r16, 0xFF	; 255
     720:	02 c0       	rjmp	.+4      	; 0x726 <FUNCSetAutoSleepTimeOut+0x64>
     722:	f2 99       	sbic	0x1e, 2	; 30
     724:	1d c0       	rjmp	.+58     	; 0x760 <FUNCSetAutoSleepTimeOut+0x9e>
     726:	00 23       	and	r16, r16
     728:	29 f4       	brne	.+10     	; 0x734 <FUNCSetAutoSleepTimeOut+0x72>
     72a:	81 e9       	ldi	r24, 0x91	; 145
     72c:	92 e0       	ldi	r25, 0x02	; 2
     72e:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     732:	13 c0       	rjmp	.+38     	; 0x75a <FUNCSetAutoSleepTimeOut+0x98>
     734:	e0 2f       	mov	r30, r16
     736:	ff 27       	eor	r31, r31
     738:	ef 51       	subi	r30, 0x1F	; 31
     73a:	fc 4f       	sbci	r31, 0xFC	; 252
     73c:	e4 91       	lpm	r30, Z
     73e:	7e 01       	movw	r14, r28
     740:	08 94       	sec
     742:	e1 1c       	adc	r14, r1
     744:	f1 1c       	adc	r15, r1
     746:	b7 01       	movw	r22, r14
     748:	8e 2f       	mov	r24, r30
     74a:	99 27       	eor	r25, r25
     74c:	0e 94 9c 02 	call	0x538	; 0x538 <MAIN_IntToStr>
     750:	80 e2       	ldi	r24, 0x20	; 32
     752:	8c 83       	std	Y+4, r24	; 0x04
     754:	c7 01       	movw	r24, r14
     756:	0e 94 7f 08 	call	0x10fe	; 0x10fe <LCD_puts>
     75a:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     75e:	cf cf       	rjmp	.-98     	; 0x6fe <FUNCSetAutoSleepTimeOut+0x3c>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     760:	ab e8       	ldi	r26, 0x8B	; 139
     762:	b0 e0       	ldi	r27, 0x00	; 0
     764:	00 2e       	mov	r0, r16
     766:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
     76a:	0e 94 43 0c 	call	0x1886	; 0x1886 <TOUT_SetupSleepTimer>
     76e:	28 96       	adiw	r28, 0x08	; 8
     770:	0f b6       	in	r0, 0x3f	; 63
     772:	f8 94       	cli
     774:	de bf       	out	0x3e, r29	; 62
     776:	0f be       	out	0x3f, r0	; 63
     778:	cd bf       	out	0x3d, r28	; 61
     77a:	df 91       	pop	r29
     77c:	cf 91       	pop	r28
     77e:	0f 91       	pop	r16
     780:	ff 90       	pop	r15
     782:	ef 90       	pop	r14
     784:	08 95       	ret

00000786 <MAIN_ShowError>:
     786:	cf 93       	push	r28
     788:	df 93       	push	r29
     78a:	cd b7       	in	r28, 0x3d	; 61
     78c:	de b7       	in	r29, 0x3e	; 62
     78e:	64 97       	sbiw	r28, 0x14	; 20
     790:	0f b6       	in	r0, 0x3f	; 63
     792:	f8 94       	cli
     794:	de bf       	out	0x3e, r29	; 62
     796:	0f be       	out	0x3f, r0	; 63
     798:	cd bf       	out	0x3d, r28	; 61
     79a:	25 e4       	ldi	r18, 0x45	; 69
     79c:	29 83       	std	Y+1, r18	; 0x01
     79e:	2e e3       	ldi	r18, 0x3E	; 62
     7a0:	2a 83       	std	Y+2, r18	; 0x02
     7a2:	bc 01       	movw	r22, r24
     7a4:	ce 01       	movw	r24, r28
     7a6:	03 96       	adiw	r24, 0x03	; 3
     7a8:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <strcpy_P>
     7ac:	ce 01       	movw	r24, r28
     7ae:	01 96       	adiw	r24, 0x01	; 1
     7b0:	0e 94 7f 08 	call	0x10fe	; 0x10fe <LCD_puts>
     7b4:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     7b8:	f4 9b       	sbis	0x1e, 4	; 30
     7ba:	fe cf       	rjmp	.-4      	; 0x7b8 <MAIN_ShowError+0x32>
     7bc:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     7c0:	64 96       	adiw	r28, 0x14	; 20
     7c2:	0f b6       	in	r0, 0x3f	; 63
     7c4:	f8 94       	cli
     7c6:	de bf       	out	0x3e, r29	; 62
     7c8:	0f be       	out	0x3f, r0	; 63
     7ca:	cd bf       	out	0x3d, r28	; 61
     7cc:	df 91       	pop	r29
     7ce:	cf 91       	pop	r28
     7d0:	08 95       	ret

000007d2 <FUNCStorageInfo>:
     7d2:	1f 93       	push	r17
     7d4:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     7d8:	81 e0       	ldi	r24, 0x01	; 1
     7da:	8e bb       	out	0x1e, r24	; 30
     7dc:	10 e0       	ldi	r17, 0x00	; 0
     7de:	8e b3       	in	r24, 0x1e	; 30
     7e0:	88 23       	and	r24, r24
     7e2:	e9 f3       	breq	.-6      	; 0x7de <FUNCStorageInfo+0xc>
     7e4:	8e b3       	in	r24, 0x1e	; 30
     7e6:	80 7c       	andi	r24, 0xC0	; 192
     7e8:	19 f0       	breq	.+6      	; 0x7f0 <FUNCStorageInfo+0x1e>
     7ea:	81 e0       	ldi	r24, 0x01	; 1
     7ec:	18 27       	eor	r17, r24
     7ee:	36 c0       	rjmp	.+108    	; 0x85c <FUNCStorageInfo+0x8a>
     7f0:	f2 99       	sbic	0x1e, 2	; 30
     7f2:	3f c0       	rjmp	.+126    	; 0x872 <FUNCStorageInfo+0xa0>
     7f4:	f4 9b       	sbis	0x1e, 4	; 30
     7f6:	32 c0       	rjmp	.+100    	; 0x85c <FUNCStorageInfo+0x8a>
     7f8:	11 30       	cpi	r17, 0x01	; 1
     7fa:	71 f5       	brne	.+92     	; 0x858 <FUNCStorageInfo+0x86>
     7fc:	82 eb       	ldi	r24, 0xB2	; 178
     7fe:	99 e0       	ldi	r25, 0x09	; 9
     800:	90 93 01 01 	sts	0x0101, r25
     804:	80 93 00 01 	sts	0x0100, r24
     808:	0e 94 aa 09 	call	0x1354	; 0x1354 <SPI_SPIInit>
     80c:	10 92 47 01 	sts	0x0147, r1
     810:	81 e0       	ldi	r24, 0x01	; 1
     812:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
     816:	0e 94 c4 0b 	call	0x1788	; 0x1788 <DF_CheckCorrectOnboardChip>
     81a:	88 23       	and	r24, r24
     81c:	41 f0       	breq	.+16     	; 0x82e <FUNCStorageInfo+0x5c>
     81e:	0e 94 25 1a 	call	0x344a	; 0x344a <TM_ShowTags>
     822:	80 91 64 00 	lds	r24, 0x0064
     826:	84 60       	ori	r24, 0x04	; 4
     828:	80 93 64 00 	sts	0x0064, r24
     82c:	17 c0       	rjmp	.+46     	; 0x85c <FUNCStorageInfo+0x8a>
     82e:	81 e0       	ldi	r24, 0x01	; 1
     830:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <PM_GetStoredDataSize>
     834:	61 15       	cp	r22, r1
     836:	71 05       	cpc	r23, r1
     838:	81 05       	cpc	r24, r1
     83a:	91 05       	cpc	r25, r1
     83c:	79 f4       	brne	.+30     	; 0x85c <FUNCStorageInfo+0x8a>
     83e:	80 e0       	ldi	r24, 0x00	; 0
     840:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
     844:	80 91 64 00 	lds	r24, 0x0064
     848:	84 60       	ori	r24, 0x04	; 4
     84a:	80 93 64 00 	sts	0x0064, r24
     84e:	82 e8       	ldi	r24, 0x82	; 130
     850:	92 e0       	ldi	r25, 0x02	; 2
     852:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     856:	02 c0       	rjmp	.+4      	; 0x85c <FUNCStorageInfo+0x8a>
     858:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <PM_ShowStoredItemSizes>
     85c:	8f e0       	ldi	r24, 0x0F	; 15
     85e:	18 9f       	mul	r17, r24
     860:	c0 01       	movw	r24, r0
     862:	11 24       	eor	r1, r1
     864:	86 5a       	subi	r24, 0xA6	; 166
     866:	9d 4f       	sbci	r25, 0xFD	; 253
     868:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     86c:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     870:	b6 cf       	rjmp	.-148    	; 0x7de <FUNCStorageInfo+0xc>
     872:	1f 91       	pop	r17
     874:	08 95       	ret

00000876 <MAIN_ShowProgType>:
     876:	ff 92       	push	r15
     878:	0f 93       	push	r16
     87a:	1f 93       	push	r17
     87c:	cf 93       	push	r28
     87e:	df 93       	push	r29
     880:	cd b7       	in	r28, 0x3d	; 61
     882:	de b7       	in	r29, 0x3e	; 62
     884:	27 97       	sbiw	r28, 0x07	; 7
     886:	0f b6       	in	r0, 0x3f	; 63
     888:	f8 94       	cli
     88a:	de bf       	out	0x3e, r29	; 62
     88c:	0f be       	out	0x3f, r0	; 63
     88e:	cd bf       	out	0x3d, r28	; 61
     890:	f8 2e       	mov	r15, r24
     892:	8e 01       	movw	r16, r28
     894:	0f 5f       	subi	r16, 0xFF	; 255
     896:	1f 4f       	sbci	r17, 0xFF	; 255
     898:	65 e2       	ldi	r22, 0x25	; 37
     89a:	73 e0       	ldi	r23, 0x03	; 3
     89c:	c8 01       	movw	r24, r16
     89e:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <strcpy_P>
     8a2:	fe 82       	std	Y+6, r15	; 0x06
     8a4:	c8 01       	movw	r24, r16
     8a6:	0e 94 7f 08 	call	0x10fe	; 0x10fe <LCD_puts>
     8aa:	27 96       	adiw	r28, 0x07	; 7
     8ac:	0f b6       	in	r0, 0x3f	; 63
     8ae:	f8 94       	cli
     8b0:	de bf       	out	0x3e, r29	; 62
     8b2:	0f be       	out	0x3f, r0	; 63
     8b4:	cd bf       	out	0x3d, r28	; 61
     8b6:	df 91       	pop	r29
     8b8:	cf 91       	pop	r28
     8ba:	1f 91       	pop	r17
     8bc:	0f 91       	pop	r16
     8be:	ff 90       	pop	r15
     8c0:	08 95       	ret

000008c2 <FUNCStoreProgram>:
     8c2:	82 eb       	ldi	r24, 0xB2	; 178
     8c4:	99 e0       	ldi	r25, 0x09	; 9
     8c6:	90 93 01 01 	sts	0x0101, r25
     8ca:	80 93 00 01 	sts	0x0100, r24
     8ce:	0e 94 aa 09 	call	0x1354	; 0x1354 <SPI_SPIInit>
     8d2:	10 92 47 01 	sts	0x0147, r1
     8d6:	81 e0       	ldi	r24, 0x01	; 1
     8d8:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
     8dc:	0e 94 c4 0b 	call	0x1788	; 0x1788 <DF_CheckCorrectOnboardChip>
     8e0:	88 23       	and	r24, r24
     8e2:	e1 f0       	breq	.+56     	; 0x91c <FUNCStoreProgram+0x5a>
     8e4:	87 ea       	ldi	r24, 0xA7	; 167
     8e6:	90 e0       	ldi	r25, 0x00	; 0
     8e8:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     8ec:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <OSCCAL_Calibrate>
     8f0:	80 91 c1 00 	lds	r24, 0x00C1
     8f4:	80 78       	andi	r24, 0x80	; 128
     8f6:	88 61       	ori	r24, 0x18	; 24
     8f8:	80 93 c1 00 	sts	0x00C1, r24
     8fc:	8c eb       	ldi	r24, 0xBC	; 188
     8fe:	92 e0       	ldi	r25, 0x02	; 2
     900:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     904:	84 e5       	ldi	r24, 0x54	; 84
     906:	97 e1       	ldi	r25, 0x17	; 23
     908:	0e 94 e7 0f 	call	0x1fce	; 0x1fce <V2P_RunStateMachine>
     90c:	80 e0       	ldi	r24, 0x00	; 0
     90e:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
     912:	80 91 64 00 	lds	r24, 0x0064
     916:	84 60       	ori	r24, 0x04	; 4
     918:	80 93 64 00 	sts	0x0064, r24
     91c:	08 95       	ret

0000091e <FUNCAVRISPMode>:
     91e:	87 ea       	ldi	r24, 0xA7	; 167
     920:	90 e0       	ldi	r25, 0x00	; 0
     922:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     926:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <OSCCAL_Calibrate>
     92a:	e1 ec       	ldi	r30, 0xC1	; 193
     92c:	f0 e0       	ldi	r31, 0x00	; 0
     92e:	80 81       	ld	r24, Z
     930:	80 78       	andi	r24, 0x80	; 128
     932:	88 61       	ori	r24, 0x18	; 24
     934:	80 83       	st	Z, r24
     936:	86 e3       	ldi	r24, 0x36	; 54
     938:	94 e0       	ldi	r25, 0x04	; 4
     93a:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     93e:	8c ee       	ldi	r24, 0xEC	; 236
     940:	92 e1       	ldi	r25, 0x12	; 18
     942:	0e 94 e7 0f 	call	0x1fce	; 0x1fce <V2P_RunStateMachine>
     946:	08 95       	ret

00000948 <FUNCProgramDataflash>:
     948:	0e 94 31 0a 	call	0x1462	; 0x1462 <USI_SPIInitMaster>
     94c:	81 e0       	ldi	r24, 0x01	; 1
     94e:	80 93 47 01 	sts	0x0147, r24
     952:	81 ef       	ldi	r24, 0xF1	; 241
     954:	99 e0       	ldi	r25, 0x09	; 9
     956:	90 93 01 01 	sts	0x0101, r25
     95a:	80 93 00 01 	sts	0x0100, r24
     95e:	87 ea       	ldi	r24, 0xA7	; 167
     960:	90 e0       	ldi	r25, 0x00	; 0
     962:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     966:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <OSCCAL_Calibrate>
     96a:	e1 ec       	ldi	r30, 0xC1	; 193
     96c:	f0 e0       	ldi	r31, 0x00	; 0
     96e:	80 81       	ld	r24, Z
     970:	80 78       	andi	r24, 0x80	; 128
     972:	88 61       	ori	r24, 0x18	; 24
     974:	80 83       	st	Z, r24
     976:	89 ef       	ldi	r24, 0xF9	; 249
     978:	93 e0       	ldi	r25, 0x03	; 3
     97a:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     97e:	85 e5       	ldi	r24, 0x55	; 85
     980:	9d e0       	ldi	r25, 0x0D	; 13
     982:	0e 94 e7 0f 	call	0x1fce	; 0x1fce <V2P_RunStateMachine>
     986:	80 e0       	ldi	r24, 0x00	; 0
     988:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
     98c:	e4 e6       	ldi	r30, 0x64	; 100
     98e:	f0 e0       	ldi	r31, 0x00	; 0
     990:	80 81       	ld	r24, Z
     992:	84 60       	ori	r24, 0x04	; 4
     994:	80 83       	st	Z, r24
     996:	08 95       	ret

00000998 <MAIN_CrashProgram>:
     998:	8c 01       	movw	r16, r24
     99a:	80 91 64 00 	lds	r24, 0x0064
     99e:	84 60       	ori	r24, 0x04	; 4
     9a0:	80 93 64 00 	sts	0x0064, r24
     9a4:	0e 94 e7 09 	call	0x13ce	; 0x13ce <USI_SPIOff>
     9a8:	10 92 b0 00 	sts	0x00B0, r1
     9ac:	10 92 70 00 	sts	0x0070, r1
     9b0:	10 92 81 00 	sts	0x0081, r1
     9b4:	80 e8       	ldi	r24, 0x80	; 128
     9b6:	80 93 61 00 	sts	0x0061, r24
     9ba:	83 e0       	ldi	r24, 0x03	; 3
     9bc:	80 93 61 00 	sts	0x0061, r24
     9c0:	10 92 c1 00 	sts	0x00C1, r1
     9c4:	c8 01       	movw	r24, r16
     9c6:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     9ca:	81 b3       	in	r24, 0x11	; 17
     9cc:	8f 7c       	andi	r24, 0xCF	; 207
     9ce:	80 63       	ori	r24, 0x30	; 48
     9d0:	81 bb       	out	0x11, r24	; 17
     9d2:	82 e3       	ldi	r24, 0x32	; 50
     9d4:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     9d8:	81 b3       	in	r24, 0x11	; 17
     9da:	90 e2       	ldi	r25, 0x20	; 32
     9dc:	89 27       	eor	r24, r25
     9de:	f8 cf       	rjmp	.-16     	; 0x9d0 <MAIN_CrashProgram+0x38>

000009e0 <__vector_default>:
     9e0:	8e e1       	ldi	r24, 0x1E	; 30
     9e2:	93 e0       	ldi	r25, 0x03	; 3
     9e4:	0e 94 cc 04 	call	0x998	; 0x998 <MAIN_CrashProgram>

000009e8 <FUNCProgramAVR>:
     9e8:	0f 93       	push	r16
     9ea:	1f 93       	push	r17
     9ec:	cf 93       	push	r28
     9ee:	df 93       	push	r29
     9f0:	cd b7       	in	r28, 0x3d	; 61
     9f2:	de b7       	in	r29, 0x3e	; 62
     9f4:	63 97       	sbiw	r28, 0x13	; 19
     9f6:	0f b6       	in	r0, 0x3f	; 63
     9f8:	f8 94       	cli
     9fa:	de bf       	out	0x3e, r29	; 62
     9fc:	0f be       	out	0x3f, r0	; 63
     9fe:	cd bf       	out	0x3d, r28	; 61
     a00:	82 eb       	ldi	r24, 0xB2	; 178
     a02:	99 e0       	ldi	r25, 0x09	; 9
     a04:	90 93 01 01 	sts	0x0101, r25
     a08:	80 93 00 01 	sts	0x0100, r24
     a0c:	0e 94 aa 09 	call	0x1354	; 0x1354 <SPI_SPIInit>
     a10:	10 92 47 01 	sts	0x0147, r1
     a14:	0e 94 c4 0b 	call	0x1788	; 0x1788 <DF_CheckCorrectOnboardChip>
     a18:	88 23       	and	r24, r24
     a1a:	09 f4       	brne	.+2      	; 0xa1e <FUNCProgramAVR+0x36>
     a1c:	1d c1       	rjmp	.+570    	; 0xc58 <FUNCProgramAVR+0x270>
     a1e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     a22:	81 e0       	ldi	r24, 0x01	; 1
     a24:	8e bb       	out	0x1e, r24	; 30
     a26:	10 e0       	ldi	r17, 0x00	; 0
     a28:	8e b3       	in	r24, 0x1e	; 30
     a2a:	88 23       	and	r24, r24
     a2c:	e9 f3       	breq	.-6      	; 0xa28 <FUNCProgramAVR+0x40>
     a2e:	f2 99       	sbic	0x1e, 2	; 30
     a30:	13 c1       	rjmp	.+550    	; 0xc58 <FUNCProgramAVR+0x270>
     a32:	f4 99       	sbic	0x1e, 4	; 30
     a34:	1c c0       	rjmp	.+56     	; 0xa6e <FUNCProgramAVR+0x86>
     a36:	f6 9b       	sbis	0x1e, 6	; 30
     a38:	06 c0       	rjmp	.+12     	; 0xa46 <FUNCProgramAVR+0x5e>
     a3a:	11 23       	and	r17, r17
     a3c:	11 f4       	brne	.+4      	; 0xa42 <FUNCProgramAVR+0x5a>
     a3e:	17 e0       	ldi	r17, 0x07	; 7
     a40:	09 c0       	rjmp	.+18     	; 0xa54 <FUNCProgramAVR+0x6c>
     a42:	11 50       	subi	r17, 0x01	; 1
     a44:	07 c0       	rjmp	.+14     	; 0xa54 <FUNCProgramAVR+0x6c>
     a46:	f7 9b       	sbis	0x1e, 7	; 30
     a48:	05 c0       	rjmp	.+10     	; 0xa54 <FUNCProgramAVR+0x6c>
     a4a:	17 30       	cpi	r17, 0x07	; 7
     a4c:	11 f4       	brne	.+4      	; 0xa52 <FUNCProgramAVR+0x6a>
     a4e:	10 e0       	ldi	r17, 0x00	; 0
     a50:	01 c0       	rjmp	.+2      	; 0xa54 <FUNCProgramAVR+0x6c>
     a52:	1f 5f       	subi	r17, 0xFF	; 255
     a54:	e1 2f       	mov	r30, r17
     a56:	ff 27       	eor	r31, r31
     a58:	ee 0f       	add	r30, r30
     a5a:	ff 1f       	adc	r31, r31
     a5c:	ea 5e       	subi	r30, 0xEA	; 234
     a5e:	fd 4f       	sbci	r31, 0xFD	; 253
     a60:	85 91       	lpm	r24, Z+
     a62:	94 91       	lpm	r25, Z
     a64:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     a68:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     a6c:	dd cf       	rjmp	.-70     	; 0xa28 <FUNCProgramAVR+0x40>
     a6e:	80 e8       	ldi	r24, 0x80	; 128
     a70:	80 93 61 00 	sts	0x0061, r24
     a74:	10 92 61 00 	sts	0x0061, r1
     a78:	87 ea       	ldi	r24, 0xA7	; 167
     a7a:	90 e0       	ldi	r25, 0x00	; 0
     a7c:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     a80:	10 92 81 00 	sts	0x0081, r1
     a84:	0e 94 31 0a 	call	0x1462	; 0x1462 <USI_SPIInitMaster>
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     a8e:	27 e2       	ldi	r18, 0x27	; 39
     a90:	30 e0       	ldi	r19, 0x00	; 0
     a92:	e1 e9       	ldi	r30, 0x91	; 145
     a94:	f1 e0       	ldi	r31, 0x01	; 1
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     a96:	d9 01       	movw	r26, r18
     a98:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
     a9c:	80 2d       	mov	r24, r0
     a9e:	81 93       	st	Z+, r24
     aa0:	2f 5f       	subi	r18, 0xFF	; 255
     aa2:	3f 4f       	sbci	r19, 0xFF	; 255
     aa4:	80 e0       	ldi	r24, 0x00	; 0
     aa6:	23 33       	cpi	r18, 0x33	; 51
     aa8:	38 07       	cpc	r19, r24
     aaa:	a9 f7       	brne	.-22     	; 0xa96 <FUNCProgramAVR+0xae>
     aac:	0e 94 8b 12 	call	0x2516	; 0x2516 <ISPCC_EnterChipProgrammingMode>
     ab0:	10 92 a9 02 	sts	0x02A9, r1
     ab4:	10 92 aa 02 	sts	0x02AA, r1
     ab8:	10 92 ab 02 	sts	0x02AB, r1
     abc:	10 92 ac 02 	sts	0x02AC, r1
     ac0:	80 91 92 01 	lds	r24, 0x0192
     ac4:	88 23       	and	r24, r24
     ac6:	09 f0       	breq	.+2      	; 0xaca <FUNCProgramAVR+0xe2>
     ac8:	aa c0       	rjmp	.+340    	; 0xc1e <FUNCProgramAVR+0x236>
     aca:	11 23       	and	r17, r17
     acc:	31 f0       	breq	.+12     	; 0xada <FUNCProgramAVR+0xf2>
     ace:	17 30       	cpi	r17, 0x07	; 7
     ad0:	21 f0       	breq	.+8      	; 0xada <FUNCProgramAVR+0xf2>
     ad2:	11 30       	cpi	r17, 0x01	; 1
     ad4:	11 f0       	breq	.+4      	; 0xada <FUNCProgramAVR+0xf2>
     ad6:	13 30       	cpi	r17, 0x03	; 3
     ad8:	91 f4       	brne	.+36     	; 0xafe <FUNCProgramAVR+0x116>
     ada:	83 e4       	ldi	r24, 0x43	; 67
     adc:	0e 94 3b 04 	call	0x876	; 0x876 <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     ae0:	a7 e1       	ldi	r26, 0x17	; 23
     ae2:	b0 e0       	ldi	r27, 0x00	; 0
     ae4:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
     ae8:	80 2d       	mov	r24, r0
     aea:	81 30       	cpi	r24, 0x01	; 1
     aec:	31 f0       	breq	.+12     	; 0xafa <FUNCProgramAVR+0x112>
     aee:	81 e1       	ldi	r24, 0x11	; 17
     af0:	93 e0       	ldi	r25, 0x03	; 3
     af2:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     af6:	02 e0       	ldi	r16, 0x02	; 2
     af8:	03 c0       	rjmp	.+6      	; 0xb00 <FUNCProgramAVR+0x118>
     afa:	0e 94 8a 15 	call	0x2b14	; 0x2b14 <PM_SendEraseCommand>
     afe:	00 e0       	ldi	r16, 0x00	; 0
     b00:	12 30       	cpi	r17, 0x02	; 2
     b02:	10 f0       	brcs	.+4      	; 0xb08 <FUNCProgramAVR+0x120>
     b04:	13 30       	cpi	r17, 0x03	; 3
     b06:	c1 f4       	brne	.+48     	; 0xb38 <FUNCProgramAVR+0x150>
     b08:	00 23       	and	r16, r16
     b0a:	a1 f4       	brne	.+40     	; 0xb34 <FUNCProgramAVR+0x14c>
     b0c:	84 e4       	ldi	r24, 0x44	; 68
     b0e:	0e 94 3b 04 	call	0x876	; 0x876 <MAIN_ShowProgType>
     b12:	81 e0       	ldi	r24, 0x01	; 1
     b14:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <PM_GetStoredDataSize>
     b18:	61 15       	cp	r22, r1
     b1a:	71 05       	cpc	r23, r1
     b1c:	81 05       	cpc	r24, r1
     b1e:	91 05       	cpc	r25, r1
     b20:	31 f4       	brne	.+12     	; 0xb2e <FUNCProgramAVR+0x146>
     b22:	89 e0       	ldi	r24, 0x09	; 9
     b24:	93 e0       	ldi	r25, 0x03	; 3
     b26:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     b2a:	03 e0       	ldi	r16, 0x03	; 3
     b2c:	03 c0       	rjmp	.+6      	; 0xb34 <FUNCProgramAVR+0x14c>
     b2e:	81 e0       	ldi	r24, 0x01	; 1
     b30:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <PM_CreateProgrammingPackets>
     b34:	11 23       	and	r17, r17
     b36:	21 f0       	breq	.+8      	; 0xb40 <FUNCProgramAVR+0x158>
     b38:	12 30       	cpi	r17, 0x02	; 2
     b3a:	11 f0       	breq	.+4      	; 0xb40 <FUNCProgramAVR+0x158>
     b3c:	13 30       	cpi	r17, 0x03	; 3
     b3e:	b1 f4       	brne	.+44     	; 0xb6c <FUNCProgramAVR+0x184>
     b40:	85 e4       	ldi	r24, 0x45	; 69
     b42:	0e 94 3b 04 	call	0x876	; 0x876 <MAIN_ShowProgType>
     b46:	80 e0       	ldi	r24, 0x00	; 0
     b48:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <PM_GetStoredDataSize>
     b4c:	61 15       	cp	r22, r1
     b4e:	71 05       	cpc	r23, r1
     b50:	81 05       	cpc	r24, r1
     b52:	91 05       	cpc	r25, r1
     b54:	31 f4       	brne	.+12     	; 0xb62 <FUNCProgramAVR+0x17a>
     b56:	8f ef       	ldi	r24, 0xFF	; 255
     b58:	92 e0       	ldi	r25, 0x02	; 2
     b5a:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     b5e:	03 e0       	ldi	r16, 0x03	; 3
     b60:	03 c0       	rjmp	.+6      	; 0xb68 <FUNCProgramAVR+0x180>
     b62:	80 e0       	ldi	r24, 0x00	; 0
     b64:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <PM_CreateProgrammingPackets>
     b68:	11 23       	and	r17, r17
     b6a:	21 f0       	breq	.+8      	; 0xb74 <FUNCProgramAVR+0x18c>
     b6c:	14 30       	cpi	r17, 0x04	; 4
     b6e:	11 f0       	breq	.+4      	; 0xb74 <FUNCProgramAVR+0x18c>
     b70:	16 30       	cpi	r17, 0x06	; 6
     b72:	a9 f4       	brne	.+42     	; 0xb9e <FUNCProgramAVR+0x1b6>
     b74:	86 e4       	ldi	r24, 0x46	; 70
     b76:	0e 94 3b 04 	call	0x876	; 0x876 <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     b7a:	a3 e3       	ldi	r26, 0x33	; 51
     b7c:	b0 e0       	ldi	r27, 0x00	; 0
     b7e:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
     b82:	80 2d       	mov	r24, r0
     b84:	88 23       	and	r24, r24
     b86:	31 f4       	brne	.+12     	; 0xb94 <FUNCProgramAVR+0x1ac>
     b88:	81 ef       	ldi	r24, 0xF1	; 241
     b8a:	92 e0       	ldi	r25, 0x02	; 2
     b8c:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     b90:	03 e0       	ldi	r16, 0x03	; 3
     b92:	03 c0       	rjmp	.+6      	; 0xb9a <FUNCProgramAVR+0x1b2>
     b94:	82 e0       	ldi	r24, 0x02	; 2
     b96:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <PM_SendFuseLockBytes>
     b9a:	11 23       	and	r17, r17
     b9c:	79 f0       	breq	.+30     	; 0xbbc <FUNCProgramAVR+0x1d4>
     b9e:	15 30       	cpi	r17, 0x05	; 5
     ba0:	69 f0       	breq	.+26     	; 0xbbc <FUNCProgramAVR+0x1d4>
     ba2:	16 30       	cpi	r17, 0x06	; 6
     ba4:	19 f5       	brne	.+70     	; 0xbec <FUNCProgramAVR+0x204>
     ba6:	81 e0       	ldi	r24, 0x01	; 1
     ba8:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     bac:	81 e0       	ldi	r24, 0x01	; 1
     bae:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     bb2:	80 e0       	ldi	r24, 0x00	; 0
     bb4:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     bb8:	0e 94 8b 12 	call	0x2516	; 0x2516 <ISPCC_EnterChipProgrammingMode>
     bbc:	8c e4       	ldi	r24, 0x4C	; 76
     bbe:	0e 94 3b 04 	call	0x876	; 0x876 <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     bc2:	a4 e3       	ldi	r26, 0x34	; 52
     bc4:	b0 e0       	ldi	r27, 0x00	; 0
     bc6:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
     bca:	80 2d       	mov	r24, r0
     bcc:	88 23       	and	r24, r24
     bce:	59 f4       	brne	.+22     	; 0xbe6 <FUNCProgramAVR+0x1fe>
     bd0:	83 ee       	ldi	r24, 0xE3	; 227
     bd2:	92 e0       	ldi	r25, 0x02	; 2
     bd4:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     bd8:	62 ed       	ldi	r22, 0xD2	; 210
     bda:	72 e0       	ldi	r23, 0x02	; 2
     bdc:	ce 01       	movw	r24, r28
     bde:	01 96       	adiw	r24, 0x01	; 1
     be0:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <strcpy_P>
     be4:	0b c0       	rjmp	.+22     	; 0xbfc <FUNCProgramAVR+0x214>
     be6:	83 e0       	ldi	r24, 0x03	; 3
     be8:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <PM_SendFuseLockBytes>
     bec:	62 ed       	ldi	r22, 0xD2	; 210
     bee:	72 e0       	ldi	r23, 0x02	; 2
     bf0:	ce 01       	movw	r24, r28
     bf2:	01 96       	adiw	r24, 0x01	; 1
     bf4:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <strcpy_P>
     bf8:	00 23       	and	r16, r16
     bfa:	31 f0       	breq	.+12     	; 0xc08 <FUNCProgramAVR+0x220>
     bfc:	6b ec       	ldi	r22, 0xCB	; 203
     bfe:	72 e0       	ldi	r23, 0x02	; 2
     c00:	ce 01       	movw	r24, r28
     c02:	0d 96       	adiw	r24, 0x0d	; 13
     c04:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <strcpy_P>
     c08:	ce 01       	movw	r24, r28
     c0a:	01 96       	adiw	r24, 0x01	; 1
     c0c:	0e 94 7f 08 	call	0x10fe	; 0x10fe <LCD_puts>
     c10:	8a ef       	ldi	r24, 0xFA	; 250
     c12:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     c16:	88 ec       	ldi	r24, 0xC8	; 200
     c18:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     c1c:	04 c0       	rjmp	.+8      	; 0xc26 <FUNCProgramAVR+0x23e>
     c1e:	8b e2       	ldi	r24, 0x2B	; 43
     c20:	94 e0       	ldi	r25, 0x04	; 4
     c22:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     c26:	0e 94 43 0c 	call	0x1886	; 0x1886 <TOUT_SetupSleepTimer>
     c2a:	80 e8       	ldi	r24, 0x80	; 128
     c2c:	80 93 61 00 	sts	0x0061, r24
     c30:	83 e0       	ldi	r24, 0x03	; 3
     c32:	80 93 61 00 	sts	0x0061, r24
     c36:	81 e0       	ldi	r24, 0x01	; 1
     c38:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     c3c:	0e 94 e7 09 	call	0x13ce	; 0x13ce <USI_SPIOff>
     c40:	80 e0       	ldi	r24, 0x00	; 0
     c42:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
     c46:	80 91 64 00 	lds	r24, 0x0064
     c4a:	84 60       	ori	r24, 0x04	; 4
     c4c:	80 93 64 00 	sts	0x0064, r24
     c50:	81 b3       	in	r24, 0x11	; 17
     c52:	8f 7c       	andi	r24, 0xCF	; 207
     c54:	80 61       	ori	r24, 0x10	; 16
     c56:	81 bb       	out	0x11, r24	; 17
     c58:	63 96       	adiw	r28, 0x13	; 19
     c5a:	0f b6       	in	r0, 0x3f	; 63
     c5c:	f8 94       	cli
     c5e:	de bf       	out	0x3e, r29	; 62
     c60:	0f be       	out	0x3f, r0	; 63
     c62:	cd bf       	out	0x3d, r28	; 61
     c64:	df 91       	pop	r29
     c66:	cf 91       	pop	r28
     c68:	1f 91       	pop	r17
     c6a:	0f 91       	pop	r16
     c6c:	08 95       	ret

00000c6e <main>:
     c6e:	1f 93       	push	r17
     c70:	80 e8       	ldi	r24, 0x80	; 128
     c72:	80 bf       	out	0x30, r24	; 48
     c74:	85 e0       	ldi	r24, 0x05	; 5
     c76:	80 93 64 00 	sts	0x0064, r24
     c7a:	80 e3       	ldi	r24, 0x30	; 48
     c7c:	80 bb       	out	0x10, r24	; 16
     c7e:	87 e2       	ldi	r24, 0x27	; 39
     c80:	84 b9       	out	0x04, r24	; 4
     c82:	8f ed       	ldi	r24, 0xDF	; 223
     c84:	85 b9       	out	0x05, r24	; 5
     c86:	8c e0       	ldi	r24, 0x0C	; 12
     c88:	8e b9       	out	0x0e, r24	; 14
     c8a:	80 93 6b 00 	sts	0x006B, r24
     c8e:	80 ed       	ldi	r24, 0xD0	; 208
     c90:	80 93 6c 00 	sts	0x006C, r24
     c94:	80 ec       	ldi	r24, 0xC0	; 192
     c96:	8d bb       	out	0x1d, r24	; 29
     c98:	8c bb       	out	0x1c, r24	; 28
     c9a:	81 b3       	in	r24, 0x11	; 17
     c9c:	8f 7c       	andi	r24, 0xCF	; 207
     c9e:	80 63       	ori	r24, 0x30	; 48
     ca0:	81 bb       	out	0x11, r24	; 17
     ca2:	81 e0       	ldi	r24, 0x01	; 1
     ca4:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     ca8:	0e 94 72 08 	call	0x10e4	; 0x10e4 <LCD_Init>
     cac:	8f e0       	ldi	r24, 0x0F	; 15
     cae:	80 93 e7 00 	sts	0x00E7, r24
     cb2:	87 ea       	ldi	r24, 0xA7	; 167
     cb4:	90 e0       	ldi	r25, 0x00	; 0
     cb6:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     cba:	78 94       	sei
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     cbc:	ad e8       	ldi	r26, 0x8D	; 141
     cbe:	b0 e0       	ldi	r27, 0x00	; 0
     cc0:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
     cc4:	80 2d       	mov	r24, r0
     cc6:	8a 37       	cpi	r24, 0x7A	; 122
     cc8:	89 f0       	breq	.+34     	; 0xcec <main+0x7e>
     cca:	80 e0       	ldi	r24, 0x00	; 0
     ccc:	90 e0       	ldi	r25, 0x00	; 0
     cce:	2f ef       	ldi	r18, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     cd0:	dc 01       	movw	r26, r24
     cd2:	02 2e       	mov	r0, r18
     cd4:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
     cd8:	01 96       	adiw	r24, 0x01	; 1
     cda:	8e 38       	cpi	r24, 0x8E	; 142
     cdc:	91 05       	cpc	r25, r1
     cde:	c1 f7       	brne	.-16     	; 0xcd0 <main+0x62>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     ce0:	8a e7       	ldi	r24, 0x7A	; 122
     ce2:	ad e8       	ldi	r26, 0x8D	; 141
     ce4:	b0 e0       	ldi	r27, 0x00	; 0
     ce6:	08 2e       	mov	r0, r24
     ce8:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
     cec:	a9 e8       	ldi	r26, 0x89	; 137
     cee:	b0 e0       	ldi	r27, 0x00	; 0
     cf0:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
     cf4:	80 2d       	mov	r24, r0
     cf6:	8f 70       	andi	r24, 0x0F	; 15
     cf8:	80 93 e7 00 	sts	0x00E7, r24
     cfc:	80 e0       	ldi	r24, 0x00	; 0
     cfe:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
     d02:	0e 94 99 09 	call	0x1332	; 0x1332 <USART_Init>
     d06:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <OSCCAL_Calibrate>
     d0a:	0e 94 43 0c 	call	0x1886	; 0x1886 <TOUT_SetupSleepTimer>
     d0e:	81 b3       	in	r24, 0x11	; 17
     d10:	8f 7c       	andi	r24, 0xCF	; 207
     d12:	80 61       	ori	r24, 0x10	; 16
     d14:	81 bb       	out	0x11, r24	; 17
     d16:	80 e8       	ldi	r24, 0x80	; 128
     d18:	80 93 61 00 	sts	0x0061, r24
     d1c:	83 e0       	ldi	r24, 0x03	; 3
     d1e:	80 93 61 00 	sts	0x0061, r24
     d22:	81 e0       	ldi	r24, 0x01	; 1
     d24:	8e bb       	out	0x1e, r24	; 30
     d26:	10 e0       	ldi	r17, 0x00	; 0
     d28:	8e b3       	in	r24, 0x1e	; 30
     d2a:	88 23       	and	r24, r24
     d2c:	e9 f3       	breq	.-6      	; 0xd28 <main+0xba>
     d2e:	f6 9b       	sbis	0x1e, 6	; 30
     d30:	06 c0       	rjmp	.+12     	; 0xd3e <main+0xd0>
     d32:	11 23       	and	r17, r17
     d34:	11 f4       	brne	.+4      	; 0xd3a <main+0xcc>
     d36:	16 e0       	ldi	r17, 0x06	; 6
     d38:	1b c0       	rjmp	.+54     	; 0xd70 <main+0x102>
     d3a:	11 50       	subi	r17, 0x01	; 1
     d3c:	19 c0       	rjmp	.+50     	; 0xd70 <main+0x102>
     d3e:	f7 9b       	sbis	0x1e, 7	; 30
     d40:	06 c0       	rjmp	.+12     	; 0xd4e <main+0xe0>
     d42:	16 30       	cpi	r17, 0x06	; 6
     d44:	11 f4       	brne	.+4      	; 0xd4a <main+0xdc>
     d46:	10 e0       	ldi	r17, 0x00	; 0
     d48:	13 c0       	rjmp	.+38     	; 0xd70 <main+0x102>
     d4a:	1f 5f       	subi	r17, 0xFF	; 255
     d4c:	11 c0       	rjmp	.+34     	; 0xd70 <main+0x102>
     d4e:	f4 9b       	sbis	0x1e, 4	; 30
     d50:	0b c0       	rjmp	.+22     	; 0xd68 <main+0xfa>
     d52:	e1 2f       	mov	r30, r17
     d54:	ff 27       	eor	r31, r31
     d56:	ee 0f       	add	r30, r30
     d58:	ff 1f       	adc	r31, r31
     d5a:	ef 5e       	subi	r30, 0xEF	; 239
     d5c:	fe 4f       	sbci	r31, 0xFE	; 254
     d5e:	85 91       	lpm	r24, Z+
     d60:	94 91       	lpm	r25, Z
     d62:	fc 01       	movw	r30, r24
     d64:	09 95       	icall
     d66:	04 c0       	rjmp	.+8      	; 0xd70 <main+0x102>
     d68:	f3 9b       	sbis	0x1e, 3	; 30
     d6a:	02 c0       	rjmp	.+4      	; 0xd70 <main+0x102>
     d6c:	0e 94 04 03 	call	0x608	; 0x608 <FUNCShowAbout>
     d70:	e1 2f       	mov	r30, r17
     d72:	ff 27       	eor	r31, r31
     d74:	ee 0f       	add	r30, r30
     d76:	ff 1f       	adc	r31, r31
     d78:	ed 5f       	subi	r30, 0xFD	; 253
     d7a:	fe 4f       	sbci	r31, 0xFE	; 254
     d7c:	85 91       	lpm	r24, Z+
     d7e:	94 91       	lpm	r25, Z
     d80:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     d84:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     d88:	cf cf       	rjmp	.-98     	; 0xd28 <main+0xba>

00000d8a <FUNCClearMem>:
     d8a:	84 eb       	ldi	r24, 0xB4	; 180
     d8c:	92 e0       	ldi	r25, 0x02	; 2
     d8e:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     d92:	84 eb       	ldi	r24, 0xB4	; 180
     d94:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     d98:	8e ea       	ldi	r24, 0xAE	; 174
     d9a:	92 e0       	ldi	r25, 0x02	; 2
     d9c:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     da0:	8e b3       	in	r24, 0x1e	; 30
     da2:	88 23       	and	r24, r24
     da4:	e9 f3       	breq	.-6      	; 0xda0 <FUNCClearMem+0x16>
     da6:	f2 99       	sbic	0x1e, 2	; 30
     da8:	22 c0       	rjmp	.+68     	; 0xdee <FUNCClearMem+0x64>
     daa:	f3 9b       	sbis	0x1e, 3	; 30
     dac:	f9 cf       	rjmp	.-14     	; 0xda0 <FUNCClearMem+0x16>
     dae:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     db2:	87 ea       	ldi	r24, 0xA7	; 167
     db4:	90 e0       	ldi	r25, 0x00	; 0
     db6:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     dba:	81 b3       	in	r24, 0x11	; 17
     dbc:	8f 7c       	andi	r24, 0xCF	; 207
     dbe:	80 63       	ori	r24, 0x30	; 48
     dc0:	81 bb       	out	0x11, r24	; 17
     dc2:	80 e0       	ldi	r24, 0x00	; 0
     dc4:	90 e0       	ldi	r25, 0x00	; 0
     dc6:	2f ef       	ldi	r18, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     dc8:	dc 01       	movw	r26, r24
     dca:	02 2e       	mov	r0, r18
     dcc:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
     dd0:	01 96       	adiw	r24, 0x01	; 1
     dd2:	8e 38       	cpi	r24, 0x8E	; 142
     dd4:	91 05       	cpc	r25, r1
     dd6:	c1 f7       	brne	.-16     	; 0xdc8 <FUNCClearMem+0x3e>
     dd8:	81 b3       	in	r24, 0x11	; 17
     dda:	8f 7c       	andi	r24, 0xCF	; 207
     ddc:	80 61       	ori	r24, 0x10	; 16
     dde:	81 bb       	out	0x11, r24	; 17
     de0:	82 ea       	ldi	r24, 0xA2	; 162
     de2:	92 e0       	ldi	r25, 0x02	; 2
     de4:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     de8:	8a ef       	ldi	r24, 0xFA	; 250
     dea:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     dee:	08 95       	ret

00000df0 <FUNCSetContrast>:
     df0:	1f 93       	push	r17
     df2:	cf 93       	push	r28
     df4:	df 93       	push	r29
     df6:	cd b7       	in	r28, 0x3d	; 61
     df8:	de b7       	in	r29, 0x3e	; 62
     dfa:	26 97       	sbiw	r28, 0x06	; 6
     dfc:	0f b6       	in	r0, 0x3f	; 63
     dfe:	f8 94       	cli
     e00:	de bf       	out	0x3e, r29	; 62
     e02:	0f be       	out	0x3f, r0	; 63
     e04:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     e06:	a9 e8       	ldi	r26, 0x89	; 137
     e08:	b0 e0       	ldi	r27, 0x00	; 0
     e0a:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
     e0e:	80 2d       	mov	r24, r0
     e10:	18 2f       	mov	r17, r24
     e12:	1f 70       	andi	r17, 0x0F	; 15
     e14:	81 e0       	ldi	r24, 0x01	; 1
     e16:	8e bb       	out	0x1e, r24	; 30
     e18:	8e b3       	in	r24, 0x1e	; 30
     e1a:	88 23       	and	r24, r24
     e1c:	e9 f3       	breq	.-6      	; 0xe18 <FUNCSetContrast+0x28>
     e1e:	f6 9b       	sbis	0x1e, 6	; 30
     e20:	04 c0       	rjmp	.+8      	; 0xe2a <FUNCSetContrast+0x3a>
     e22:	1f 30       	cpi	r17, 0x0F	; 15
     e24:	50 f4       	brcc	.+20     	; 0xe3a <FUNCSetContrast+0x4a>
     e26:	1f 5f       	subi	r17, 0xFF	; 255
     e28:	08 c0       	rjmp	.+16     	; 0xe3a <FUNCSetContrast+0x4a>
     e2a:	f7 9b       	sbis	0x1e, 7	; 30
     e2c:	04 c0       	rjmp	.+8      	; 0xe36 <FUNCSetContrast+0x46>
     e2e:	12 30       	cpi	r17, 0x02	; 2
     e30:	20 f0       	brcs	.+8      	; 0xe3a <FUNCSetContrast+0x4a>
     e32:	11 50       	subi	r17, 0x01	; 1
     e34:	02 c0       	rjmp	.+4      	; 0xe3a <FUNCSetContrast+0x4a>
     e36:	f2 99       	sbic	0x1e, 2	; 30
     e38:	18 c0       	rjmp	.+48     	; 0xe6a <FUNCSetContrast+0x7a>
     e3a:	83 e4       	ldi	r24, 0x43	; 67
     e3c:	89 83       	std	Y+1, r24	; 0x01
     e3e:	84 e5       	ldi	r24, 0x54	; 84
     e40:	8a 83       	std	Y+2, r24	; 0x02
     e42:	80 e2       	ldi	r24, 0x20	; 32
     e44:	8b 83       	std	Y+3, r24	; 0x03
     e46:	be 01       	movw	r22, r28
     e48:	6c 5f       	subi	r22, 0xFC	; 252
     e4a:	7f 4f       	sbci	r23, 0xFF	; 255
     e4c:	81 2f       	mov	r24, r17
     e4e:	99 27       	eor	r25, r25
     e50:	0e 94 9c 02 	call	0x538	; 0x538 <MAIN_IntToStr>
     e54:	ce 01       	movw	r24, r28
     e56:	01 96       	adiw	r24, 0x01	; 1
     e58:	0e 94 7f 08 	call	0x10fe	; 0x10fe <LCD_puts>
     e5c:	81 2f       	mov	r24, r17
     e5e:	8f 70       	andi	r24, 0x0F	; 15
     e60:	80 93 e7 00 	sts	0x00E7, r24
     e64:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     e68:	d7 cf       	rjmp	.-82     	; 0xe18 <FUNCSetContrast+0x28>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     e6a:	a9 e8       	ldi	r26, 0x89	; 137
     e6c:	b0 e0       	ldi	r27, 0x00	; 0
     e6e:	01 2e       	mov	r0, r17
     e70:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
     e74:	26 96       	adiw	r28, 0x06	; 6
     e76:	0f b6       	in	r0, 0x3f	; 63
     e78:	f8 94       	cli
     e7a:	de bf       	out	0x3e, r29	; 62
     e7c:	0f be       	out	0x3f, r0	; 63
     e7e:	cd bf       	out	0x3d, r28	; 61
     e80:	df 91       	pop	r29
     e82:	cf 91       	pop	r28
     e84:	1f 91       	pop	r17
     e86:	08 95       	ret

00000e88 <FUNCSetISPSpeed>:
     e88:	1f 93       	push	r17
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     e8a:	a2 e0       	ldi	r26, 0x02	; 2
     e8c:	b0 e0       	ldi	r27, 0x00	; 0
     e8e:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
     e92:	80 2d       	mov	r24, r0
     e94:	18 2f       	mov	r17, r24
     e96:	84 30       	cpi	r24, 0x04	; 4
     e98:	08 f0       	brcs	.+2      	; 0xe9c <FUNCSetISPSpeed+0x14>
     e9a:	13 e0       	ldi	r17, 0x03	; 3
     e9c:	81 e0       	ldi	r24, 0x01	; 1
     e9e:	8e bb       	out	0x1e, r24	; 30
     ea0:	8e b3       	in	r24, 0x1e	; 30
     ea2:	88 23       	and	r24, r24
     ea4:	e9 f3       	breq	.-6      	; 0xea0 <FUNCSetISPSpeed+0x18>
     ea6:	f6 9b       	sbis	0x1e, 6	; 30
     ea8:	06 c0       	rjmp	.+12     	; 0xeb6 <FUNCSetISPSpeed+0x2e>
     eaa:	11 23       	and	r17, r17
     eac:	11 f4       	brne	.+4      	; 0xeb2 <FUNCSetISPSpeed+0x2a>
     eae:	13 e0       	ldi	r17, 0x03	; 3
     eb0:	0c c0       	rjmp	.+24     	; 0xeca <FUNCSetISPSpeed+0x42>
     eb2:	11 50       	subi	r17, 0x01	; 1
     eb4:	0a c0       	rjmp	.+20     	; 0xeca <FUNCSetISPSpeed+0x42>
     eb6:	f7 9b       	sbis	0x1e, 7	; 30
     eb8:	04 c0       	rjmp	.+8      	; 0xec2 <FUNCSetISPSpeed+0x3a>
     eba:	13 30       	cpi	r17, 0x03	; 3
     ebc:	29 f0       	breq	.+10     	; 0xec8 <FUNCSetISPSpeed+0x40>
     ebe:	1f 5f       	subi	r17, 0xFF	; 255
     ec0:	04 c0       	rjmp	.+8      	; 0xeca <FUNCSetISPSpeed+0x42>
     ec2:	f2 9b       	sbis	0x1e, 2	; 30
     ec4:	02 c0       	rjmp	.+4      	; 0xeca <FUNCSetISPSpeed+0x42>
     ec6:	0c c0       	rjmp	.+24     	; 0xee0 <FUNCSetISPSpeed+0x58>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     ec8:	10 e0       	ldi	r17, 0x00	; 0
     eca:	8a e0       	ldi	r24, 0x0A	; 10
     ecc:	18 9f       	mul	r17, r24
     ece:	c0 01       	movw	r24, r0
     ed0:	11 24       	eor	r1, r1
     ed2:	8a 5d       	subi	r24, 0xDA	; 218
     ed4:	9d 4f       	sbci	r25, 0xFD	; 253
     ed6:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     eda:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     ede:	e0 cf       	rjmp	.-64     	; 0xea0 <FUNCSetISPSpeed+0x18>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     ee0:	a2 e0       	ldi	r26, 0x02	; 2
     ee2:	b0 e0       	ldi	r27, 0x00	; 0
     ee4:	01 2e       	mov	r0, r17
     ee6:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
     eea:	1f 91       	pop	r17
     eec:	08 95       	ret

00000eee <FUNCSetResetMode>:
     eee:	1f 93       	push	r17
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     ef0:	ac e8       	ldi	r26, 0x8C	; 140
     ef2:	b0 e0       	ldi	r27, 0x00	; 0
     ef4:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
     ef8:	80 2d       	mov	r24, r0
     efa:	18 2f       	mov	r17, r24
     efc:	11 70       	andi	r17, 0x01	; 1
     efe:	81 e0       	ldi	r24, 0x01	; 1
     f00:	8e bb       	out	0x1e, r24	; 30
     f02:	8e b3       	in	r24, 0x1e	; 30
     f04:	88 23       	and	r24, r24
     f06:	e9 f3       	breq	.-6      	; 0xf02 <FUNCSetResetMode+0x14>
     f08:	f6 99       	sbic	0x1e, 6	; 30
     f0a:	02 c0       	rjmp	.+4      	; 0xf10 <FUNCSetResetMode+0x22>
     f0c:	f7 9b       	sbis	0x1e, 7	; 30
     f0e:	03 c0       	rjmp	.+6      	; 0xf16 <FUNCSetResetMode+0x28>
     f10:	81 e0       	ldi	r24, 0x01	; 1
     f12:	18 27       	eor	r17, r24
     f14:	02 c0       	rjmp	.+4      	; 0xf1a <FUNCSetResetMode+0x2c>
     f16:	f2 99       	sbic	0x1e, 2	; 30
     f18:	0b c0       	rjmp	.+22     	; 0xf30 <FUNCSetResetMode+0x42>
     f1a:	86 e0       	ldi	r24, 0x06	; 6
     f1c:	18 9f       	mul	r17, r24
     f1e:	c0 01       	movw	r24, r0
     f20:	11 24       	eor	r1, r1
     f22:	82 5b       	subi	r24, 0xB2	; 178
     f24:	9d 4f       	sbci	r25, 0xFD	; 253
     f26:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
     f2a:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     f2e:	e9 cf       	rjmp	.-46     	; 0xf02 <FUNCSetResetMode+0x14>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     f30:	ac e8       	ldi	r26, 0x8C	; 140
     f32:	b0 e0       	ldi	r27, 0x00	; 0
     f34:	01 2e       	mov	r0, r17
     f36:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
     f3a:	1f 91       	pop	r17
     f3c:	08 95       	ret

00000f3e <FUNCSetFirmMinorVer>:
     f3e:	1f 93       	push	r17
     f40:	cf 93       	push	r28
     f42:	df 93       	push	r29
     f44:	cd b7       	in	r28, 0x3d	; 61
     f46:	de b7       	in	r29, 0x3e	; 62
     f48:	25 97       	sbiw	r28, 0x05	; 5
     f4a:	0f b6       	in	r0, 0x3f	; 63
     f4c:	f8 94       	cli
     f4e:	de bf       	out	0x3e, r29	; 62
     f50:	0f be       	out	0x3f, r0	; 63
     f52:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     f54:	aa e8       	ldi	r26, 0x8A	; 138
     f56:	b0 e0       	ldi	r27, 0x00	; 0
     f58:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
     f5c:	80 2d       	mov	r24, r0
     f5e:	18 2f       	mov	r17, r24
     f60:	8a 30       	cpi	r24, 0x0A	; 10
     f62:	08 f0       	brcs	.+2      	; 0xf66 <FUNCSetFirmMinorVer+0x28>
     f64:	14 e0       	ldi	r17, 0x04	; 4
     f66:	6d e9       	ldi	r22, 0x9D	; 157
     f68:	72 e0       	ldi	r23, 0x02	; 2
     f6a:	ce 01       	movw	r24, r28
     f6c:	01 96       	adiw	r24, 0x01	; 1
     f6e:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <strcpy_P>
     f72:	81 e0       	ldi	r24, 0x01	; 1
     f74:	8e bb       	out	0x1e, r24	; 30
     f76:	8e b3       	in	r24, 0x1e	; 30
     f78:	88 23       	and	r24, r24
     f7a:	e9 f3       	breq	.-6      	; 0xf76 <FUNCSetFirmMinorVer+0x38>
     f7c:	f6 9b       	sbis	0x1e, 6	; 30
     f7e:	03 c0       	rjmp	.+6      	; 0xf86 <FUNCSetFirmMinorVer+0x48>
     f80:	19 30       	cpi	r17, 0x09	; 9
     f82:	08 f4       	brcc	.+2      	; 0xf86 <FUNCSetFirmMinorVer+0x48>
     f84:	1f 5f       	subi	r17, 0xFF	; 255
     f86:	f7 9b       	sbis	0x1e, 7	; 30
     f88:	04 c0       	rjmp	.+8      	; 0xf92 <FUNCSetFirmMinorVer+0x54>
     f8a:	11 23       	and	r17, r17
     f8c:	21 f0       	breq	.+8      	; 0xf96 <FUNCSetFirmMinorVer+0x58>
     f8e:	11 50       	subi	r17, 0x01	; 1
     f90:	02 c0       	rjmp	.+4      	; 0xf96 <FUNCSetFirmMinorVer+0x58>
     f92:	f2 99       	sbic	0x1e, 2	; 30
     f94:	0a c0       	rjmp	.+20     	; 0xfaa <FUNCSetFirmMinorVer+0x6c>
     f96:	10 5d       	subi	r17, 0xD0	; 208
     f98:	1c 83       	std	Y+4, r17	; 0x04
     f9a:	10 53       	subi	r17, 0x30	; 48
     f9c:	ce 01       	movw	r24, r28
     f9e:	01 96       	adiw	r24, 0x01	; 1
     fa0:	0e 94 7f 08 	call	0x10fe	; 0x10fe <LCD_puts>
     fa4:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     fa8:	e6 cf       	rjmp	.-52     	; 0xf76 <FUNCSetFirmMinorVer+0x38>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     faa:	aa e8       	ldi	r26, 0x8A	; 138
     fac:	b0 e0       	ldi	r27, 0x00	; 0
     fae:	01 2e       	mov	r0, r17
     fb0:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
     fb4:	25 96       	adiw	r28, 0x05	; 5
     fb6:	0f b6       	in	r0, 0x3f	; 63
     fb8:	f8 94       	cli
     fba:	de bf       	out	0x3e, r29	; 62
     fbc:	0f be       	out	0x3f, r0	; 63
     fbe:	cd bf       	out	0x3d, r28	; 61
     fc0:	df 91       	pop	r29
     fc2:	cf 91       	pop	r28
     fc4:	1f 91       	pop	r17
     fc6:	08 95       	ret

00000fc8 <OSCCAL_Calibrate>:

volatile uint16_t ActualCount = 0;

void OSCCAL_Calibrate(void)
{
     fc8:	10 92 05 01 	sts	0x0105, r1
     fcc:	10 92 04 01 	sts	0x0104, r1
	uint8_t SREG_Backup;
	uint8_t LoopCount = (0x7F / 2); // Maximum range is 128, and starts from the middle, so 64 is the max number of iterations required
	uint8_t PrevOSCALValues[4] = {0,0,0,0};
   
	// Reset ActualCount
	ActualCount = 0;
   
	// Make sure all clock division is turned off (8Mhz RC clock)
	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_BASECLOCKSPEED_8MHZ);
     fd0:	80 e8       	ldi	r24, 0x80	; 128
     fd2:	80 93 61 00 	sts	0x0061, r24
     fd6:	10 92 61 00 	sts	0x0061, r1

	// Inital OSCCAL of half its maximum
	OSCCAL = (0x7F / 2);
     fda:	8f e3       	ldi	r24, 0x3F	; 63
     fdc:	80 93 66 00 	sts	0x0066, r24

	// Save the SREG
	SREG_Backup = SREG;
     fe0:	7f b7       	in	r23, 0x3f	; 63
    
	// Disable all timer 1 interrupts
	TIMSK1 = 0;
     fe2:	10 92 6f 00 	sts	0x006F, r1
        
	// Set timer 2 to asyncronous mode (32.768KHz crystal)
	ASSR   = (1 << AS2);
     fe6:	88 e0       	ldi	r24, 0x08	; 8
     fe8:	80 93 b6 00 	sts	0x00B6, r24
        
	// Timer 2 overflow interrupt enable
	TIMSK2 = (1 << TOIE2);
     fec:	81 e0       	ldi	r24, 0x01	; 1
     fee:	80 93 70 00 	sts	0x0070, r24

	// Enable interrupts
	sei();
     ff2:	78 94       	sei

	// Start both counters with no prescaling
	TCCR1B = (1 << CS10);
     ff4:	80 93 81 00 	sts	0x0081, r24
	TCCR2A = (1 << CS20);
     ff8:	80 93 b0 00 	sts	0x00B0, r24
	 	 
	// Previous OSCCAL value of 0
	PrevOSCALValues[0] = 0;

	// Wait until timer 2's external 32.768KHz crystal is stable
	while (ASSR & ((1 << TCN2UB) | (1 << TCR2UB) | (1 << OCR2UB)));
     ffc:	80 91 b6 00 	lds	r24, 0x00B6
    1000:	99 27       	eor	r25, r25
    1002:	87 70       	andi	r24, 0x07	; 7
    1004:	90 70       	andi	r25, 0x00	; 0
    1006:	89 2b       	or	r24, r25
    1008:	c9 f7       	brne	.-14     	; 0xffc <OSCCAL_Calibrate+0x34>
    
	// Clear the timer values
	TCNT1  = 0;
    100a:	10 92 85 00 	sts	0x0085, r1
    100e:	10 92 84 00 	sts	0x0084, r1
	TCNT2  = 0;
    1012:	10 92 b2 00 	sts	0x00B2, r1
    1016:	3e e3       	ldi	r19, 0x3E	; 62
    1018:	60 e0       	ldi	r22, 0x00	; 0
    101a:	50 e0       	ldi	r21, 0x00	; 0
    101c:	20 e0       	ldi	r18, 0x00	; 0
    101e:	e9 e9       	ldi	r30, 0x99	; 153
    1020:	f9 ec       	ldi	r31, 0xC9	; 201
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1022:	cf 01       	movw	r24, r30
    1024:	01 97       	sbiw	r24, 0x01	; 1
    1026:	f1 f7       	brne	.-4      	; 0x1024 <OSCCAL_Calibrate+0x5c>
    
	while (LoopCount--)
	{
		// Let it take a few readings (28ms, approx 4 readings)
		_delay_ms(28);

		PrevOSCALValues[3] = PrevOSCALValues[2];
		PrevOSCALValues[2] = PrevOSCALValues[1];
		PrevOSCALValues[1] = PrevOSCALValues[0];
		PrevOSCALValues[0] = OSCCAL;
    1028:	40 91 66 00 	lds	r20, 0x0066
        
		if (ActualCount > OSCCAL_TARGETCOUNT)       // Clock is running too fast
    102c:	80 91 04 01 	lds	r24, 0x0104
    1030:	90 91 05 01 	lds	r25, 0x0105
    1034:	81 50       	subi	r24, 0x01	; 1
    1036:	91 4e       	sbci	r25, 0xE1	; 225
    1038:	20 f0       	brcs	.+8      	; 0x1042 <OSCCAL_Calibrate+0x7a>
			OSCCAL--;
    103a:	80 91 66 00 	lds	r24, 0x0066
    103e:	81 50       	subi	r24, 0x01	; 1
    1040:	0a c0       	rjmp	.+20     	; 0x1056 <OSCCAL_Calibrate+0x8e>
		else if (ActualCount < OSCCAL_TARGETCOUNT) // Clock is running too slow
    1042:	80 91 04 01 	lds	r24, 0x0104
    1046:	90 91 05 01 	lds	r25, 0x0105
    104a:	80 50       	subi	r24, 0x00	; 0
    104c:	91 4e       	sbci	r25, 0xE1	; 225
    104e:	28 f4       	brcc	.+10     	; 0x105a <OSCCAL_Calibrate+0x92>
			OSCCAL++;
    1050:	80 91 66 00 	lds	r24, 0x0066
    1054:	8f 5f       	subi	r24, 0xFF	; 255
    1056:	80 93 66 00 	sts	0x0066, r24
		
		// When the routine finds the closest value for the given target count,
		// it will cause the OSCCAL to hover around the closest two values.
		// If the current value is the same as several loops previous, exit the
		// routine as the best value has been found.
		if ((OSCCAL == PrevOSCALValues[1]) && (OSCCAL == PrevOSCALValues[3]))
    105a:	80 91 66 00 	lds	r24, 0x0066
    105e:	82 17       	cp	r24, r18
    1060:	21 f4       	brne	.+8      	; 0x106a <OSCCAL_Calibrate+0xa2>
    1062:	80 91 66 00 	lds	r24, 0x0066
    1066:	85 17       	cp	r24, r21
    1068:	39 f0       	breq	.+14     	; 0x1078 <OSCCAL_Calibrate+0xb0>
    106a:	31 50       	subi	r19, 0x01	; 1
    106c:	56 2f       	mov	r21, r22
    106e:	62 2f       	mov	r22, r18
    1070:	3f 3f       	cpi	r19, 0xFF	; 255
    1072:	11 f0       	breq	.+4      	; 0x1078 <OSCCAL_Calibrate+0xb0>
    1074:	24 2f       	mov	r18, r20
    1076:	d5 cf       	rjmp	.-86     	; 0x1022 <OSCCAL_Calibrate+0x5a>
		  break;
	}

	// Disable all timer interrupts
	TIMSK1 = 0;
    1078:	10 92 6f 00 	sts	0x006F, r1
	TIMSK2 = 0;
    107c:	10 92 70 00 	sts	0x0070, r1
    
	// Stop the timers
	TCCR1B = 0x00;
    1080:	10 92 81 00 	sts	0x0081, r1
	TCCR2A = 0x00;
    1084:	10 92 b0 00 	sts	0x00B0, r1

	// Turn off timer 2 asynchronous mode
	ASSR  &= ~(1 << AS2);
    1088:	80 91 b6 00 	lds	r24, 0x00B6
    108c:	87 7f       	andi	r24, 0xF7	; 247
    108e:	80 93 b6 00 	sts	0x00B6, r24

	// Restore SREG
	SREG = SREG_Backup;
    1092:	7f bf       	out	0x3f, r23	; 63
    1094:	08 95       	ret

00001096 <__vector_5>:
        
	return;
}

ISR(TIMER2_OVF_vect, ISR_BLOCK) // Occurs 32768/256 timers per second, or 128Hz
{
    1096:	1f 92       	push	r1
    1098:	0f 92       	push	r0
    109a:	0f b6       	in	r0, 0x3f	; 63
    109c:	0f 92       	push	r0
    109e:	11 24       	eor	r1, r1
    10a0:	8f 93       	push	r24
    10a2:	9f 93       	push	r25
    10a4:	af 93       	push	r26
    10a6:	bf 93       	push	r27
    10a8:	ef 93       	push	r30
    10aa:	ff 93       	push	r31
	// Stop timer 1 so it can be read
	TCCR1B = 0x00;
    10ac:	a1 e8       	ldi	r26, 0x81	; 129
    10ae:	b0 e0       	ldi	r27, 0x00	; 0
    10b0:	1c 92       	st	X, r1
    
	// Record timer 1's value
	ActualCount = TCNT1;
    10b2:	e4 e8       	ldi	r30, 0x84	; 132
    10b4:	f0 e0       	ldi	r31, 0x00	; 0
    10b6:	80 81       	ld	r24, Z
    10b8:	91 81       	ldd	r25, Z+1	; 0x01
    10ba:	90 93 05 01 	sts	0x0105, r25
    10be:	80 93 04 01 	sts	0x0104, r24
	     
	// Reset counters and restart timer 1
	TCNT1  = 0;
    10c2:	11 82       	std	Z+1, r1	; 0x01
    10c4:	10 82       	st	Z, r1
	TCNT2  = 0;
    10c6:	10 92 b2 00 	sts	0x00B2, r1
	TCCR1B = (1 << CS10);
    10ca:	81 e0       	ldi	r24, 0x01	; 1
    10cc:	8c 93       	st	X, r24
    10ce:	ff 91       	pop	r31
    10d0:	ef 91       	pop	r30
    10d2:	bf 91       	pop	r27
    10d4:	af 91       	pop	r26
    10d6:	9f 91       	pop	r25
    10d8:	8f 91       	pop	r24
    10da:	0f 90       	pop	r0
    10dc:	0f be       	out	0x3f, r0	; 63
    10de:	0f 90       	pop	r0
    10e0:	1f 90       	pop	r1
    10e2:	18 95       	reti

000010e4 <LCD_Init>:

// ======================================================================================

void LCD_Init(void)
{
    10e4:	8f e0       	ldi	r24, 0x0F	; 15
    10e6:	80 93 e7 00 	sts	0x00E7, r24
	// Set the initial contrast level to maximum:
	LCDCCR = 0x0F;

    // Select asynchronous clock source, enable all COM pins and enable all segment pins:
    LCDCRB  = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
    10ea:	87 eb       	ldi	r24, 0xB7	; 183
    10ec:	80 93 e5 00 	sts	0x00E5, r24

    // Set LCD prescaler to give a framerate of 32Hz:
    LCDFRR  = (7<<LCDCD0);    
    10f0:	87 e0       	ldi	r24, 0x07	; 7
    10f2:	80 93 e6 00 	sts	0x00E6, r24

	// Enable LCD and set low power waveform, enable start of frame interrupt:
    LCDCRA  = (1<<LCDEN) | (1<<LCDAB) | (1<<LCDIE);
    10f6:	88 ec       	ldi	r24, 0xC8	; 200
    10f8:	80 93 e4 00 	sts	0x00E4, r24
    10fc:	08 95       	ret

000010fe <LCD_puts>:
}

void LCD_puts_f(const uint8_t *FlashData)
{
	uint8_t StrBuff[LCD_TEXTBUFFER_SIZE];

	strcpy_P(StrBuff, FlashData);
	LCD_puts(StrBuff);
}

void LCD_puts(const uint8_t *Data)
{
    10fe:	fc 01       	movw	r30, r24
    1100:	ac e0       	ldi	r26, 0x0C	; 12
    1102:	b1 e0       	ldi	r27, 0x01	; 1
    1104:	38 2f       	mov	r19, r24
    1106:	4f ef       	ldi	r20, 0xFF	; 255
    1108:	2e 2f       	mov	r18, r30
    110a:	23 1b       	sub	r18, r19
	uint8_t LoadB;
	
	for (LoadB = 0; LoadB < 20; LoadB++)
	{
		uint8_t CByte = *(Data++);
    110c:	91 91       	ld	r25, Z+
	
		if ((CByte >= '*') && (CByte <= 'z') && (CByte != ' '))
    110e:	89 2f       	mov	r24, r25
    1110:	8a 52       	subi	r24, 0x2A	; 42
    1112:	81 35       	cpi	r24, 0x51	; 81
    1114:	10 f4       	brcc	.+4      	; 0x111a <LCD_puts+0x1c>
		  TextBuffer[LoadB] = (CByte - '*');
    1116:	8c 93       	st	X, r24
    1118:	03 c0       	rjmp	.+6      	; 0x1120 <LCD_puts+0x22>
		else if (CByte == 0x00)
    111a:	99 23       	and	r25, r25
    111c:	41 f0       	breq	.+16     	; 0x112e <LCD_puts+0x30>
		  break;
		else
		  TextBuffer[LoadB] = 0xFF;		
    111e:	4c 93       	st	X, r20
    1120:	2e 2f       	mov	r18, r30
    1122:	23 1b       	sub	r18, r19
    1124:	11 96       	adiw	r26, 0x01	; 1
    1126:	81 e0       	ldi	r24, 0x01	; 1
    1128:	a0 32       	cpi	r26, 0x20	; 32
    112a:	b8 07       	cpc	r27, r24
    112c:	69 f7       	brne	.-38     	; 0x1108 <LCD_puts+0xa>
	}

	ScrollMode  = ((LoadB > 6)? TRUE : FALSE);
    112e:	10 92 06 01 	sts	0x0106, r1
    1132:	27 30       	cpi	r18, 0x07	; 7
    1134:	18 f0       	brcs	.+6      	; 0x113c <LCD_puts+0x3e>
    1136:	81 e0       	ldi	r24, 0x01	; 1
    1138:	80 93 06 01 	sts	0x0106, r24
	ScrollCount = 0;
    113c:	10 92 08 01 	sts	0x0108, r1
    1140:	82 2f       	mov	r24, r18
    1142:	90 e0       	ldi	r25, 0x00	; 0
    1144:	3f ef       	ldi	r19, 0xFF	; 255

	for (uint8_t Nulls = 0; Nulls < 7; Nulls++)
		TextBuffer[LoadB++] = 0xFF;
    1146:	e8 2f       	mov	r30, r24
    1148:	ff 27       	eor	r31, r31
    114a:	e4 5f       	subi	r30, 0xF4	; 244
    114c:	fe 4f       	sbci	r31, 0xFE	; 254
    114e:	30 83       	st	Z, r19
    1150:	8f 5f       	subi	r24, 0xFF	; 255
    1152:	9f 5f       	subi	r25, 0xFF	; 255
    1154:	97 30       	cpi	r25, 0x07	; 7
    1156:	b9 f7       	brne	.-18     	; 0x1146 <LCD_puts+0x48>
    1158:	82 2f       	mov	r24, r18
    115a:	89 5f       	subi	r24, 0xF9	; 249
	
	TextBuffer[LoadB] = 0x00;
    115c:	e8 2f       	mov	r30, r24
    115e:	ff 27       	eor	r31, r31
    1160:	e4 5f       	subi	r30, 0xF4	; 244
    1162:	fe 4f       	sbci	r31, 0xFE	; 254
    1164:	10 82       	st	Z, r1
	StrStart   = 0;
    1166:	10 92 0a 01 	sts	0x010A, r1
	StrEnd     = LoadB;	
    116a:	80 93 0b 01 	sts	0x010B, r24
	DelayCount = LCD_DELAYCOUNT_DEFAULT;
    116e:	8a e0       	ldi	r24, 0x0A	; 10
    1170:	80 93 07 01 	sts	0x0107, r24

	UpdateLCD  = TRUE;
    1174:	81 e0       	ldi	r24, 0x01	; 1
    1176:	80 93 09 01 	sts	0x0109, r24
    117a:	08 95       	ret

0000117c <__vector_22>:
}

static inline void LCD_WriteChar(const uint8_t Byte, const uint8_t Digit)
{
	uint16_t SegData  = 0x00;
	uint8_t  *BuffPtr = (&SegBuffer[0] + (Digit >> 1));

	if (Byte != 0xFF)
	  SegData = pgm_read_word(&LCD_SegTable[Byte]);	

	for (uint8_t BNib = 0; BNib < 4; BNib++)
	{
		uint8_t Mask          = 0xF0;
		uint8_t MaskedSegData = (SegData & 0x0000F);
	
		if (Digit & 0x01)
		{
			Mask = 0x0F;
			MaskedSegData <<= 4;
		}
		
		*BuffPtr = ((*BuffPtr & Mask) | MaskedSegData);

		SegData >>= 4;
		BuffPtr  += 5;
	}
}

ISR(LCD_vect, ISR_NOBLOCK)
{
    117c:	78 94       	sei
    117e:	1f 92       	push	r1
    1180:	0f 92       	push	r0
    1182:	0f b6       	in	r0, 0x3f	; 63
    1184:	0f 92       	push	r0
    1186:	11 24       	eor	r1, r1
    1188:	ef 92       	push	r14
    118a:	ff 92       	push	r15
    118c:	0f 93       	push	r16
    118e:	1f 93       	push	r17
    1190:	2f 93       	push	r18
    1192:	3f 93       	push	r19
    1194:	4f 93       	push	r20
    1196:	5f 93       	push	r21
    1198:	6f 93       	push	r22
    119a:	7f 93       	push	r23
    119c:	8f 93       	push	r24
    119e:	9f 93       	push	r25
    11a0:	af 93       	push	r26
    11a2:	bf 93       	push	r27
    11a4:	ef 93       	push	r30
    11a6:	ff 93       	push	r31
	if (ScrollMode)
    11a8:	80 91 06 01 	lds	r24, 0x0106
    11ac:	88 23       	and	r24, r24
    11ae:	99 f0       	breq	.+38     	; 0x11d6 <__vector_22+0x5a>
	{
		if (DelayCount)
    11b0:	80 91 07 01 	lds	r24, 0x0107
    11b4:	88 23       	and	r24, r24
    11b6:	21 f0       	breq	.+8      	; 0x11c0 <__vector_22+0x44>
		{
			DelayCount--;
    11b8:	81 50       	subi	r24, 0x01	; 1
    11ba:	80 93 07 01 	sts	0x0107, r24
    11be:	0b c0       	rjmp	.+22     	; 0x11d6 <__vector_22+0x5a>
		}
		else
		{
			if (!(ScrollCount--))
    11c0:	80 91 08 01 	lds	r24, 0x0108
    11c4:	81 50       	subi	r24, 0x01	; 1
    11c6:	80 93 08 01 	sts	0x0108, r24
    11ca:	8f 3f       	cpi	r24, 0xFF	; 255
    11cc:	21 f4       	brne	.+8      	; 0x11d6 <__vector_22+0x5a>
			  UpdateLCD = TRUE;
    11ce:	81 e0       	ldi	r24, 0x01	; 1
    11d0:	80 93 09 01 	sts	0x0109, r24
    11d4:	05 c0       	rjmp	.+10     	; 0x11e0 <__vector_22+0x64>
		}
	}

	if (UpdateLCD)
    11d6:	80 91 09 01 	lds	r24, 0x0109
    11da:	88 23       	and	r24, r24
    11dc:	09 f4       	brne	.+2      	; 0x11e0 <__vector_22+0x64>
    11de:	55 c0       	rjmp	.+170    	; 0x128a <__vector_22+0x10e>
	{
		for (uint8_t Character = 0; Character < 6; Character++)
		{
			uint8_t Byte = (StrStart + Character);
    11e0:	30 91 0a 01 	lds	r19, 0x010A

			if (Byte >= StrEnd)
    11e4:	e0 90 0b 01 	lds	r14, 0x010B
    11e8:	f3 2e       	mov	r15, r19
    11ea:	fe 18       	sub	r15, r14
    11ec:	13 2f       	mov	r17, r19
    11ee:	60 e0       	ldi	r22, 0x00	; 0
    11f0:	70 e0       	ldi	r23, 0x00	; 0
    11f2:	86 2f       	mov	r24, r22
    11f4:	1e 15       	cp	r17, r14
    11f6:	10 f4       	brcc	.+4      	; 0x11fc <__vector_22+0x80>
    11f8:	e1 2f       	mov	r30, r17
    11fa:	01 c0       	rjmp	.+2      	; 0x11fe <__vector_22+0x82>
    11fc:	ef 2d       	mov	r30, r15
			  Byte -= StrEnd;
			
			LCD_WriteChar(TextBuffer[Byte], Character);
    11fe:	ff 27       	eor	r31, r31
    1200:	e4 5f       	subi	r30, 0xF4	; 244
    1202:	fe 4f       	sbci	r31, 0xFE	; 254
    1204:	e0 81       	ld	r30, Z
    1206:	ef 3f       	cpi	r30, 0xFF	; 255
    1208:	19 f4       	brne	.+6      	; 0x1210 <__vector_22+0x94>
    120a:	40 e0       	ldi	r20, 0x00	; 0
    120c:	50 e0       	ldi	r21, 0x00	; 0
    120e:	07 c0       	rjmp	.+14     	; 0x121e <__vector_22+0xa2>
    1210:	ff 27       	eor	r31, r31
    1212:	ee 0f       	add	r30, r30
    1214:	ff 1f       	adc	r31, r31
    1216:	e4 5d       	subi	r30, 0xD4	; 212
    1218:	fc 4f       	sbci	r31, 0xFC	; 252
    121a:	45 91       	lpm	r20, Z+
    121c:	54 91       	lpm	r21, Z
    121e:	86 95       	lsr	r24
    1220:	e8 2f       	mov	r30, r24
    1222:	ff 27       	eor	r31, r31
    1224:	e9 5d       	subi	r30, 0xD9	; 217
    1226:	fe 4f       	sbci	r31, 0xFE	; 254
    1228:	00 e0       	ldi	r16, 0x00	; 0
    122a:	db 01       	movw	r26, r22
    122c:	a1 70       	andi	r26, 0x01	; 1
    122e:	b0 70       	andi	r27, 0x00	; 0
    1230:	24 2f       	mov	r18, r20
    1232:	2f 70       	andi	r18, 0x0F	; 15
    1234:	10 97       	sbiw	r26, 0x00	; 0
    1236:	11 f4       	brne	.+4      	; 0x123c <__vector_22+0xc0>
    1238:	90 ef       	ldi	r25, 0xF0	; 240
    123a:	03 c0       	rjmp	.+6      	; 0x1242 <__vector_22+0xc6>
    123c:	22 95       	swap	r18
    123e:	20 7f       	andi	r18, 0xF0	; 240
    1240:	9f e0       	ldi	r25, 0x0F	; 15
    1242:	80 81       	ld	r24, Z
    1244:	98 23       	and	r25, r24
    1246:	92 2b       	or	r25, r18
    1248:	90 83       	st	Z, r25
    124a:	0f 5f       	subi	r16, 0xFF	; 255
    124c:	04 30       	cpi	r16, 0x04	; 4
    124e:	39 f0       	breq	.+14     	; 0x125e <__vector_22+0xe2>
    1250:	84 e0       	ldi	r24, 0x04	; 4
    1252:	56 95       	lsr	r21
    1254:	47 95       	ror	r20
    1256:	8a 95       	dec	r24
    1258:	e1 f7       	brne	.-8      	; 0x1252 <__vector_22+0xd6>
    125a:	35 96       	adiw	r30, 0x05	; 5
    125c:	e9 cf       	rjmp	.-46     	; 0x1230 <__vector_22+0xb4>
    125e:	6f 5f       	subi	r22, 0xFF	; 255
    1260:	7f 4f       	sbci	r23, 0xFF	; 255
    1262:	1f 5f       	subi	r17, 0xFF	; 255
    1264:	f3 94       	inc	r15
    1266:	66 30       	cpi	r22, 0x06	; 6
    1268:	71 05       	cpc	r23, r1
    126a:	09 f0       	breq	.+2      	; 0x126e <__vector_22+0xf2>
    126c:	c2 cf       	rjmp	.-124    	; 0x11f2 <__vector_22+0x76>
		}
		
		if (StrStart++ == StrEnd)
    126e:	3f 5f       	subi	r19, 0xFF	; 255
    1270:	30 93 0a 01 	sts	0x010A, r19
    1274:	31 50       	subi	r19, 0x01	; 1
    1276:	3e 15       	cp	r19, r14
    1278:	19 f4       	brne	.+6      	; 0x1280 <__vector_22+0x104>
		  StrStart = 1;
    127a:	81 e0       	ldi	r24, 0x01	; 1
    127c:	80 93 0a 01 	sts	0x010A, r24
		
		ScrollCount = LCD_SCROLLCOUNT_DEFAULT;
    1280:	83 e0       	ldi	r24, 0x03	; 3
    1282:	80 93 08 01 	sts	0x0108, r24
		UpdateLCD = FALSE;
    1286:	10 92 09 01 	sts	0x0109, r1
    128a:	a7 e2       	ldi	r26, 0x27	; 39
    128c:	b1 e0       	ldi	r27, 0x01	; 1
    128e:	ec ee       	ldi	r30, 0xEC	; 236
    1290:	f0 e0       	ldi	r31, 0x00	; 0
	}

	for (uint8_t LCDChar = 0; LCDChar < LCD_SEGBUFFER_SIZE; LCDChar++)
	  *(pLCDREG + LCDChar) = SegBuffer[LCDChar];
    1292:	8d 91       	ld	r24, X+
    1294:	81 93       	st	Z+, r24
    1296:	81 e0       	ldi	r24, 0x01	; 1
    1298:	e0 30       	cpi	r30, 0x00	; 0
    129a:	f8 07       	cpc	r31, r24
    129c:	d1 f7       	brne	.-12     	; 0x1292 <__vector_22+0x116>
    129e:	ff 91       	pop	r31
    12a0:	ef 91       	pop	r30
    12a2:	bf 91       	pop	r27
    12a4:	af 91       	pop	r26
    12a6:	9f 91       	pop	r25
    12a8:	8f 91       	pop	r24
    12aa:	7f 91       	pop	r23
    12ac:	6f 91       	pop	r22
    12ae:	5f 91       	pop	r21
    12b0:	4f 91       	pop	r20
    12b2:	3f 91       	pop	r19
    12b4:	2f 91       	pop	r18
    12b6:	1f 91       	pop	r17
    12b8:	0f 91       	pop	r16
    12ba:	ff 90       	pop	r15
    12bc:	ef 90       	pop	r14
    12be:	0f 90       	pop	r0
    12c0:	0f be       	out	0x3f, r0	; 63
    12c2:	0f 90       	pop	r0
    12c4:	1f 90       	pop	r1
    12c6:	18 95       	reti

000012c8 <LCD_puts_f>:
    12c8:	0f 93       	push	r16
    12ca:	1f 93       	push	r17
    12cc:	cf 93       	push	r28
    12ce:	df 93       	push	r29
    12d0:	cd b7       	in	r28, 0x3d	; 61
    12d2:	de b7       	in	r29, 0x3e	; 62
    12d4:	64 97       	sbiw	r28, 0x14	; 20
    12d6:	0f b6       	in	r0, 0x3f	; 63
    12d8:	f8 94       	cli
    12da:	de bf       	out	0x3e, r29	; 62
    12dc:	0f be       	out	0x3f, r0	; 63
    12de:	cd bf       	out	0x3d, r28	; 61
    12e0:	8e 01       	movw	r16, r28
    12e2:	0f 5f       	subi	r16, 0xFF	; 255
    12e4:	1f 4f       	sbci	r17, 0xFF	; 255
    12e6:	bc 01       	movw	r22, r24
    12e8:	c8 01       	movw	r24, r16
    12ea:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <strcpy_P>
    12ee:	c8 01       	movw	r24, r16
    12f0:	0e 94 7f 08 	call	0x10fe	; 0x10fe <LCD_puts>
    12f4:	64 96       	adiw	r28, 0x14	; 20
    12f6:	0f b6       	in	r0, 0x3f	; 63
    12f8:	f8 94       	cli
    12fa:	de bf       	out	0x3e, r29	; 62
    12fc:	0f be       	out	0x3f, r0	; 63
    12fe:	cd bf       	out	0x3d, r28	; 61
    1300:	df 91       	pop	r29
    1302:	cf 91       	pop	r28
    1304:	1f 91       	pop	r17
    1306:	0f 91       	pop	r16
    1308:	08 95       	ret

0000130a <USART_Tx>:
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_Tx(const char data)
{
    130a:	98 2f       	mov	r25, r24
    while (!(UCSRA & (1 << UDRE)));
    130c:	80 91 c0 00 	lds	r24, 0x00C0
    1310:	85 ff       	sbrs	r24, 5
    1312:	fc cf       	rjmp	.-8      	; 0x130c <USART_Tx+0x2>
    UDR = data;
    1314:	90 93 c6 00 	sts	0x00C6, r25
    1318:	08 95       	ret

0000131a <USART_Rx>:
}

/*****************************************************************************
*
*   Function name : Usart_Rx
*
*   Returns :       char: byte received
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART
*
*****************************************************************************/
char USART_Rx(void)
{
    131a:	80 91 88 01 	lds	r24, 0x0188
    131e:	88 23       	and	r24, r24
    1320:	21 f4       	brne	.+8      	; 0x132a <USART_Rx+0x10>
    while (!(BuffElements) && !(PacketTimeOut)) {};
    1322:	80 91 8c 01 	lds	r24, 0x018C
    1326:	88 23       	and	r24, r24
    1328:	c1 f3       	breq	.-16     	; 0x131a <USART_Rx>
    return BUFF_GetBuffByte();
    132a:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <BUFF_GetBuffByte>
}
    132e:	99 27       	eor	r25, r25
    1330:	08 95       	ret

00001332 <USART_Init>:
    1332:	10 92 c5 00 	sts	0x00C5, r1
    1336:	87 e0       	ldi	r24, 0x07	; 7
    1338:	80 93 c4 00 	sts	0x00C4, r24
    133c:	82 e0       	ldi	r24, 0x02	; 2
    133e:	80 93 c0 00 	sts	0x00C0, r24
    1342:	80 e8       	ldi	r24, 0x80	; 128
    1344:	80 93 c1 00 	sts	0x00C1, r24
    1348:	86 e0       	ldi	r24, 0x06	; 6
    134a:	80 93 c2 00 	sts	0x00C2, r24
    134e:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <BUFF_InitialiseBuffer>
    1352:	08 95       	ret

00001354 <SPI_SPIInit>:

// ======================================================================================

void SPI_SPIInit(void)
{
    1354:	e4 e6       	ldi	r30, 0x64	; 100
    1356:	f0 e0       	ldi	r31, 0x00	; 0
    1358:	80 81       	ld	r24, Z
    135a:	8b 7f       	andi	r24, 0xFB	; 251
    135c:	80 83       	st	Z, r24
	PRR &= ~(1 << PRSPI);              // Enable the SPI system by clearing the power save register SPI disable bit

	// Master, Sample falling edge (setup rising), Fosc/16 speed (7.3MHz/16 = 467KHz)
	SPCR = ((1 << SPE) | (1 << MSTR) | (1 << CPHA) | (1 << CPOL) | (1 << SPR0));
    135e:	8d e5       	ldi	r24, 0x5D	; 93
    1360:	8c bd       	out	0x2c, r24	; 44
    1362:	08 95       	ret

00001364 <SPI_SPITransmit>:
}

uint8_t SPI_SPITransmit(const uint8_t Data)
{
    1364:	8e bd       	out	0x2e, r24	; 46
	SPDR = Data;                       // Loading a byte into the register starts the transmission
	while (!(SPSR & (1 << SPIF)));    // Wait until transmission completed
    1366:	0d b4       	in	r0, 0x2d	; 45
    1368:	07 fe       	sbrs	r0, 7
    136a:	fd cf       	rjmp	.-6      	; 0x1366 <SPI_SPITransmit+0x2>
	return SPDR;
    136c:	8e b5       	in	r24, 0x2e	; 46
}
    136e:	99 27       	eor	r25, r25
    1370:	08 95       	ret

00001372 <SPI_SPITransmitWord>:

uint8_t SPI_SPITransmitWord(const uint16_t Data)
{
    1372:	9c 01       	movw	r18, r24
	SPI_SPITransmit((uint8_t)(Data >> 8));
    1374:	83 2f       	mov	r24, r19
    1376:	99 27       	eor	r25, r25
    1378:	8e bd       	out	0x2e, r24	; 46
    137a:	0d b4       	in	r0, 0x2d	; 45
    137c:	07 fe       	sbrs	r0, 7
    137e:	fd cf       	rjmp	.-6      	; 0x137a <SPI_SPITransmitWord+0x8>
    1380:	8e b5       	in	r24, 0x2e	; 46
    1382:	2e bd       	out	0x2e, r18	; 46
    1384:	0d b4       	in	r0, 0x2d	; 45
    1386:	07 fe       	sbrs	r0, 7
    1388:	fd cf       	rjmp	.-6      	; 0x1384 <SPI_SPITransmitWord+0x12>
    138a:	8e b5       	in	r24, 0x2e	; 46
	return SPI_SPITransmit((uint8_t)Data);
}
    138c:	99 27       	eor	r25, r25
    138e:	08 95       	ret

00001390 <__vector_17>:
 *  have to stop the timer tick.
 *  For all modes the USIDR contents are stored and flags are updated.
 */
ISR(USI_OVERFLOW_vect, ISR_BLOCK)
{
    1390:	1f 92       	push	r1
    1392:	0f 92       	push	r0
    1394:	0f b6       	in	r0, 0x3f	; 63
    1396:	0f 92       	push	r0
    1398:	11 24       	eor	r1, r1
    139a:	8f 93       	push	r24
    139c:	ef 93       	push	r30
    139e:	ff 93       	push	r31
	// Master must now disable the compare match interrupt
	// to prevent more USI counter clocks.
	TIMSK0 &= ~(1<<OCIE0A);
    13a0:	ee e6       	ldi	r30, 0x6E	; 110
    13a2:	f0 e0       	ldi	r31, 0x00	; 0
    13a4:	80 81       	ld	r24, Z
    13a6:	8d 7f       	andi	r24, 0xFD	; 253
    13a8:	80 83       	st	Z, r24
	
	// Update flags and clear USI counter
	USISR = (1<<USIOIF);
    13aa:	80 e4       	ldi	r24, 0x40	; 64
    13ac:	80 93 b9 00 	sts	0x00B9, r24
	TransferComplete = 1;
    13b0:	81 e0       	ldi	r24, 0x01	; 1
    13b2:	80 93 3c 01 	sts	0x013C, r24

	// Copy USIDR to buffer to prevent overwrite on next transfer.
	StoredUSIDR = USIDR;
    13b6:	80 91 ba 00 	lds	r24, 0x00BA
    13ba:	80 93 3b 01 	sts	0x013B, r24
    13be:	ff 91       	pop	r31
    13c0:	ef 91       	pop	r30
    13c2:	8f 91       	pop	r24
    13c4:	0f 90       	pop	r0
    13c6:	0f be       	out	0x3f, r0	; 63
    13c8:	0f 90       	pop	r0
    13ca:	1f 90       	pop	r1
    13cc:	18 95       	reti

000013ce <USI_SPIOff>:
}

/*! \brief  Initialize USI as SPI master.
 *
 *  This function sets up all pin directions and module configurations.
 *  Use this function initially or when changing from slave to master mode.
 *  Note that the stored USIDR value is cleared.
 *
 */
void USI_SPIInitMaster()
{
	// Configure port directions.
 	USI_DIR_REG |= (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN);  // Outputs.
	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN);                       // Inputs.
	USI_OUT_REG |= (1<<USI_DATAIN_PIN);                        // Pull-ups.
	USI_OUT_REG &= ~(1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN); // Pull-ups.
	
	// Configure USI to 3-wire master mode with overflow interrupt.
	USICR = USI_CONTROL_REG_FLAGS;

	// Set the compare and prescaler for the requested frequency:
	USI_SPISetSpeed();
	
	// Init driver status register.
	TransferComplete = 0;
	
	StoredUSIDR = 0;
}

void USI_SPIOff(void)
{
    13ce:	8d b1       	in	r24, 0x0d	; 13
    13d0:	8f 7a       	andi	r24, 0xAF	; 175
    13d2:	8d b9       	out	0x0d, r24	; 13
	USI_DIR_REG &= ~((1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN));                        // Inputs.
	USI_OUT_REG &= ~((1<<USI_DATAIN_PIN)  | (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN)); // Pull-ups.
    13d4:	8e b1       	in	r24, 0x0e	; 14
    13d6:	8f 78       	andi	r24, 0x8F	; 143
    13d8:	8e b9       	out	0x0e, r24	; 14
	DDRF  &= ~(1 << 6);
    13da:	86 98       	cbi	0x10, 6	; 16
	PORTF &= ~(1 << 6);
    13dc:	8e 98       	cbi	0x11, 6	; 17
	
	USI_STOPUSITIMER();
    13de:	14 bc       	out	0x24, r1	; 36
    13e0:	08 95       	ret

000013e2 <USI_SPITransmit>:
}

/*! \brief  Put one byte on bus.
 *
 *  Use this function like you would write to the SPDR register in the native SPI module.
 *  Calling this function in master mode starts a transfer, while in slave mode, a
 *  byte will be prepared for the next transfer initiated by the master device.
 *  If a transfer is in progress, this function will set the write collision flag
 *  and return without altering the data registers.
 *
 *  \returns  Value returned by slave.
 */
uint8_t USI_SPITransmit(uint8_t val)
{
    13e2:	10 92 3c 01 	sts	0x013C, r1
	// Reinit flags.
	TransferComplete = 0;

	// Put data in USI data register.
	USIDR = val;
    13e6:	80 93 ba 00 	sts	0x00BA, r24
	
	TIFR0  |= (1<<OCF0A);  // Clear compare match flag.
    13ea:	a9 9a       	sbi	0x15, 1	; 21
	TIMSK0 |= (1<<OCIE0A); // Enable compare match interrupt.
    13ec:	80 91 6e 00 	lds	r24, 0x006E
    13f0:	82 60       	ori	r24, 0x02	; 2
    13f2:	80 93 6e 00 	sts	0x006E, r24

	// Clear the timer 0 value
	TCNT0 = 0;
    13f6:	16 bc       	out	0x26, r1	; 38

	while (!(TransferComplete));
    13f8:	80 91 3c 01 	lds	r24, 0x013C
    13fc:	88 23       	and	r24, r24
    13fe:	e1 f3       	breq	.-8      	; 0x13f8 <USI_SPITransmit+0x16>

	return StoredUSIDR;
    1400:	80 91 3b 01 	lds	r24, 0x013B
}
    1404:	99 27       	eor	r25, r25
    1406:	08 95       	ret

00001408 <USI_SPITransmitWord>:

uint8_t USI_SPITransmitWord(const uint16_t val )
{
    1408:	0f 93       	push	r16
    140a:	1f 93       	push	r17
    140c:	8c 01       	movw	r16, r24
	USI_SPITransmit((uint8_t)(val >> 8));
    140e:	81 2f       	mov	r24, r17
    1410:	99 27       	eor	r25, r25
    1412:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
	return USI_SPITransmit((uint8_t)val);
    1416:	80 2f       	mov	r24, r16
    1418:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
}
    141c:	99 27       	eor	r25, r25
    141e:	1f 91       	pop	r17
    1420:	0f 91       	pop	r16
    1422:	08 95       	ret

00001424 <USI_SPISetSpeed>:

void USI_SPIToggleClock(void)
{
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);	
}

void USI_SPISetSpeed()
{
    1424:	42 e0       	ldi	r20, 0x02	; 2
    1426:	50 e0       	ldi	r21, 0x00	; 0
    1428:	29 e9       	ldi	r18, 0x99	; 153
    142a:	33 e0       	ldi	r19, 0x03	; 3
    142c:	f9 01       	movw	r30, r18
    142e:	31 97       	sbiw	r30, 0x01	; 1
	for (uint8_t MatchIndex = 0; MatchIndex < USI_PRESET_SPEEDS; MatchIndex++)
	{
		if ((pgm_read_byte(&USIPSValues[MatchIndex][0]) == eeprom_read_byte(&EEPROMVars.SCKDuration)) || (MatchIndex == (USI_PRESET_SPEEDS - 1)))
    1430:	84 91       	lpm	r24, Z
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1432:	da 01       	movw	r26, r20
    1434:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
    1438:	90 2d       	mov	r25, r0
    143a:	89 17       	cp	r24, r25
    143c:	21 f0       	breq	.+8      	; 0x1446 <USI_SPISetSpeed+0x22>
    143e:	83 e0       	ldi	r24, 0x03	; 3
    1440:	ee 39       	cpi	r30, 0x9E	; 158
    1442:	f8 07       	cpc	r31, r24
    1444:	31 f4       	brne	.+12     	; 0x1452 <USI_SPISetSpeed+0x2e>
		{
			// Init Output Compare Register.
			OCR0A = pgm_read_byte(&USIPSValues[MatchIndex][1]);
    1446:	f9 01       	movw	r30, r18
    1448:	84 91       	lpm	r24, Z
    144a:	87 bd       	out	0x27, r24	; 39

			// Enable 'Clear Timer on Compare match' and set prescaler, which starts the timer
			TCCR0A = ((1<<WGM01) | TC0_PS_1);
    144c:	89 e0       	ldi	r24, 0x09	; 9
    144e:	84 bd       	out	0x24, r24	; 36
    1450:	08 95       	ret
    1452:	32 96       	adiw	r30, 0x02	; 2
    1454:	2e 5f       	subi	r18, 0xFE	; 254
    1456:	3f 4f       	sbci	r19, 0xFF	; 255
    1458:	83 e0       	ldi	r24, 0x03	; 3
    145a:	e0 3a       	cpi	r30, 0xA0	; 160
    145c:	f8 07       	cpc	r31, r24
    145e:	41 f7       	brne	.-48     	; 0x1430 <USI_SPISetSpeed+0xc>
    1460:	08 95       	ret

00001462 <USI_SPIInitMaster>:
    1462:	8d b1       	in	r24, 0x0d	; 13
    1464:	80 65       	ori	r24, 0x50	; 80
    1466:	8d b9       	out	0x0d, r24	; 13
    1468:	6d 98       	cbi	0x0d, 5	; 13
    146a:	75 9a       	sbi	0x0e, 5	; 14
    146c:	76 98       	cbi	0x0e, 6	; 14
    146e:	8a e5       	ldi	r24, 0x5A	; 90
    1470:	80 93 b8 00 	sts	0x00B8, r24
    1474:	0e 94 12 0a 	call	0x1424	; 0x1424 <USI_SPISetSpeed>
    1478:	10 92 3c 01 	sts	0x013C, r1
    147c:	10 92 3b 01 	sts	0x013B, r1
    1480:	08 95       	ret

00001482 <USI_SPIToggleClock>:
    1482:	0f 93       	push	r16
    1484:	1f 93       	push	r17
    1486:	81 e0       	ldi	r24, 0x01	; 1
    1488:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    148c:	08 eb       	ldi	r16, 0xB8	; 184
    148e:	10 e0       	ldi	r17, 0x00	; 0
    1490:	f8 01       	movw	r30, r16
    1492:	80 81       	ld	r24, Z
    1494:	81 60       	ori	r24, 0x01	; 1
    1496:	80 83       	st	Z, r24
    1498:	81 e0       	ldi	r24, 0x01	; 1
    149a:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    149e:	f8 01       	movw	r30, r16
    14a0:	80 81       	ld	r24, Z
    14a2:	81 60       	ori	r24, 0x01	; 1
    14a4:	80 83       	st	Z, r24
    14a6:	81 e0       	ldi	r24, 0x01	; 1
    14a8:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    14ac:	1f 91       	pop	r17
    14ae:	0f 91       	pop	r16
    14b0:	08 95       	ret

000014b2 <DF_EnableDataflash>:
	DF_WaitWhileBusy();
}

void DF_EnableDataflash(const uint8_t Enabled)
{
    14b2:	90 91 47 01 	lds	r25, 0x0147
	if (Enabled == TRUE)
    14b6:	81 30       	cpi	r24, 0x01	; 1
    14b8:	31 f4       	brne	.+12     	; 0x14c6 <DF_EnableDataflash+0x14>
	{
		if (DataflashInfo.UseExernalDF == TRUE)
    14ba:	91 30       	cpi	r25, 0x01	; 1
    14bc:	11 f4       	brne	.+4      	; 0x14c2 <DF_EnableDataflash+0x10>
		  MAIN_ResetCSLine(MAIN_RESETCS_EXTDFACTIVE);
    14be:	82 e0       	ldi	r24, 0x02	; 2
    14c0:	05 c0       	rjmp	.+10     	; 0x14cc <DF_EnableDataflash+0x1a>
		else
		  PORTB &= ~(1 << 0);
    14c2:	28 98       	cbi	0x05, 0	; 5
    14c4:	08 95       	ret
	}
	else
	{
		if (DataflashInfo.UseExernalDF == TRUE)
    14c6:	91 30       	cpi	r25, 0x01	; 1
    14c8:	21 f4       	brne	.+8      	; 0x14d2 <DF_EnableDataflash+0x20>
		  MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);
    14ca:	81 e0       	ldi	r24, 0x01	; 1
    14cc:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
    14d0:	08 95       	ret
		else
		  PORTB |= (1 << 0);
    14d2:	28 9a       	sbi	0x05, 0	; 5
    14d4:	08 95       	ret

000014d6 <DF_ReadBufferByte>:
    14d6:	ef 92       	push	r14
    14d8:	ff 92       	push	r15
    14da:	0f 93       	push	r16
    14dc:	1f 93       	push	r17
    14de:	7c 01       	movw	r14, r24
    14e0:	00 91 00 01 	lds	r16, 0x0100
    14e4:	10 91 01 01 	lds	r17, 0x0101
    14e8:	80 e0       	ldi	r24, 0x00	; 0
    14ea:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    14ee:	81 e0       	ldi	r24, 0x01	; 1
    14f0:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    14f4:	84 e5       	ldi	r24, 0x54	; 84
    14f6:	f8 01       	movw	r30, r16
    14f8:	09 95       	icall
    14fa:	8f 2d       	mov	r24, r15
    14fc:	99 27       	eor	r25, r25
    14fe:	f8 01       	movw	r30, r16
    1500:	09 95       	icall
    1502:	8e 2d       	mov	r24, r14
    1504:	f8 01       	movw	r30, r16
    1506:	09 95       	icall
    1508:	80 e0       	ldi	r24, 0x00	; 0
    150a:	f8 01       	movw	r30, r16
    150c:	09 95       	icall
    150e:	80 e0       	ldi	r24, 0x00	; 0
    1510:	f8 01       	movw	r30, r16
    1512:	09 95       	icall
    1514:	99 27       	eor	r25, r25
    1516:	1f 91       	pop	r17
    1518:	0f 91       	pop	r16
    151a:	ff 90       	pop	r15
    151c:	ef 90       	pop	r14
    151e:	08 95       	ret

00001520 <DF_ContinuousReadEnable>:
    1520:	ef 92       	push	r14
    1522:	ff 92       	push	r15
    1524:	0f 93       	push	r16
    1526:	1f 93       	push	r17
    1528:	cf 93       	push	r28
    152a:	df 93       	push	r29
    152c:	8c 01       	movw	r16, r24
    152e:	7b 01       	movw	r14, r22
    1530:	c0 91 00 01 	lds	r28, 0x0100
    1534:	d0 91 01 01 	lds	r29, 0x0101
    1538:	80 e0       	ldi	r24, 0x00	; 0
    153a:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    153e:	81 e0       	ldi	r24, 0x01	; 1
    1540:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    1544:	88 e6       	ldi	r24, 0x68	; 104
    1546:	fe 01       	movw	r30, r28
    1548:	09 95       	icall
    154a:	8a b5       	in	r24, 0x2a	; 42
    154c:	98 01       	movw	r18, r16
    154e:	02 c0       	rjmp	.+4      	; 0x1554 <DF_ContinuousReadEnable+0x34>
    1550:	36 95       	lsr	r19
    1552:	27 95       	ror	r18
    1554:	8a 95       	dec	r24
    1556:	e2 f7       	brpl	.-8      	; 0x1550 <DF_ContinuousReadEnable+0x30>
    1558:	c9 01       	movw	r24, r18
    155a:	fe 01       	movw	r30, r28
    155c:	09 95       	icall
    155e:	8b b5       	in	r24, 0x2b	; 43
    1560:	02 c0       	rjmp	.+4      	; 0x1566 <DF_ContinuousReadEnable+0x46>
    1562:	00 0f       	add	r16, r16
    1564:	11 1f       	adc	r17, r17
    1566:	8a 95       	dec	r24
    1568:	e2 f7       	brpl	.-8      	; 0x1562 <DF_ContinuousReadEnable+0x42>
    156a:	8f 2d       	mov	r24, r15
    156c:	99 27       	eor	r25, r25
    156e:	80 0f       	add	r24, r16
    1570:	fe 01       	movw	r30, r28
    1572:	09 95       	icall
    1574:	8e 2d       	mov	r24, r14
    1576:	fe 01       	movw	r30, r28
    1578:	09 95       	icall
    157a:	00 e0       	ldi	r16, 0x00	; 0
    157c:	80 e0       	ldi	r24, 0x00	; 0
    157e:	fe 01       	movw	r30, r28
    1580:	09 95       	icall
    1582:	0f 5f       	subi	r16, 0xFF	; 255
    1584:	04 30       	cpi	r16, 0x04	; 4
    1586:	d1 f7       	brne	.-12     	; 0x157c <DF_ContinuousReadEnable+0x5c>
    1588:	df 91       	pop	r29
    158a:	cf 91       	pop	r28
    158c:	1f 91       	pop	r17
    158e:	0f 91       	pop	r16
    1590:	ff 90       	pop	r15
    1592:	ef 90       	pop	r14
    1594:	08 95       	ret

00001596 <DF_BufferWriteEnable>:
    1596:	ef 92       	push	r14
    1598:	ff 92       	push	r15
    159a:	0f 93       	push	r16
    159c:	1f 93       	push	r17
    159e:	7c 01       	movw	r14, r24
    15a0:	00 91 00 01 	lds	r16, 0x0100
    15a4:	10 91 01 01 	lds	r17, 0x0101
    15a8:	80 e0       	ldi	r24, 0x00	; 0
    15aa:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    15ae:	81 e0       	ldi	r24, 0x01	; 1
    15b0:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    15b4:	84 e8       	ldi	r24, 0x84	; 132
    15b6:	f8 01       	movw	r30, r16
    15b8:	09 95       	icall
    15ba:	80 e0       	ldi	r24, 0x00	; 0
    15bc:	f8 01       	movw	r30, r16
    15be:	09 95       	icall
    15c0:	8f 2d       	mov	r24, r15
    15c2:	99 27       	eor	r25, r25
    15c4:	f8 01       	movw	r30, r16
    15c6:	09 95       	icall
    15c8:	8e 2d       	mov	r24, r14
    15ca:	f8 01       	movw	r30, r16
    15cc:	09 95       	icall
    15ce:	1f 91       	pop	r17
    15d0:	0f 91       	pop	r16
    15d2:	ff 90       	pop	r15
    15d4:	ef 90       	pop	r14
    15d6:	08 95       	ret

000015d8 <DF_WaitWhileBusy>:
    15d8:	cf 93       	push	r28
    15da:	df 93       	push	r29
    15dc:	c0 91 00 01 	lds	r28, 0x0100
    15e0:	d0 91 01 01 	lds	r29, 0x0101
    15e4:	80 e0       	ldi	r24, 0x00	; 0
    15e6:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    15ea:	81 e0       	ldi	r24, 0x01	; 1
    15ec:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    15f0:	87 e5       	ldi	r24, 0x57	; 87
    15f2:	fe 01       	movw	r30, r28
    15f4:	09 95       	icall
    15f6:	80 e0       	ldi	r24, 0x00	; 0
    15f8:	fe 01       	movw	r30, r28
    15fa:	09 95       	icall
    15fc:	87 ff       	sbrs	r24, 7
    15fe:	fb cf       	rjmp	.-10     	; 0x15f6 <DF_WaitWhileBusy+0x1e>
    1600:	df 91       	pop	r29
    1602:	cf 91       	pop	r28
    1604:	08 95       	ret

00001606 <DF_EraseBlock>:
    1606:	ef 92       	push	r14
    1608:	ff 92       	push	r15
    160a:	0f 93       	push	r16
    160c:	1f 93       	push	r17
    160e:	7c 01       	movw	r14, r24
    1610:	00 91 00 01 	lds	r16, 0x0100
    1614:	10 91 01 01 	lds	r17, 0x0101
    1618:	80 e0       	ldi	r24, 0x00	; 0
    161a:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    161e:	81 e0       	ldi	r24, 0x01	; 1
    1620:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    1624:	80 e5       	ldi	r24, 0x50	; 80
    1626:	f8 01       	movw	r30, r16
    1628:	09 95       	icall
    162a:	8f 2d       	mov	r24, r15
    162c:	99 27       	eor	r25, r25
    162e:	f8 01       	movw	r30, r16
    1630:	09 95       	icall
    1632:	8e 2d       	mov	r24, r14
    1634:	f8 01       	movw	r30, r16
    1636:	09 95       	icall
    1638:	80 e0       	ldi	r24, 0x00	; 0
    163a:	f8 01       	movw	r30, r16
    163c:	09 95       	icall
    163e:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <DF_WaitWhileBusy>
    1642:	1f 91       	pop	r17
    1644:	0f 91       	pop	r16
    1646:	ff 90       	pop	r15
    1648:	ef 90       	pop	r14
    164a:	08 95       	ret

0000164c <DF_CopyFlashPageToBuffer>:
    164c:	ef 92       	push	r14
    164e:	ff 92       	push	r15
    1650:	0f 93       	push	r16
    1652:	1f 93       	push	r17
    1654:	8c 01       	movw	r16, r24
    1656:	e0 90 00 01 	lds	r14, 0x0100
    165a:	f0 90 01 01 	lds	r15, 0x0101
    165e:	80 e0       	ldi	r24, 0x00	; 0
    1660:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    1664:	81 e0       	ldi	r24, 0x01	; 1
    1666:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    166a:	83 e5       	ldi	r24, 0x53	; 83
    166c:	f7 01       	movw	r30, r14
    166e:	09 95       	icall
    1670:	8a b5       	in	r24, 0x2a	; 42
    1672:	98 01       	movw	r18, r16
    1674:	02 c0       	rjmp	.+4      	; 0x167a <DF_CopyFlashPageToBuffer+0x2e>
    1676:	36 95       	lsr	r19
    1678:	27 95       	ror	r18
    167a:	8a 95       	dec	r24
    167c:	e2 f7       	brpl	.-8      	; 0x1676 <DF_CopyFlashPageToBuffer+0x2a>
    167e:	c9 01       	movw	r24, r18
    1680:	f7 01       	movw	r30, r14
    1682:	09 95       	icall
    1684:	8b b5       	in	r24, 0x2b	; 43
    1686:	02 c0       	rjmp	.+4      	; 0x168c <DF_CopyFlashPageToBuffer+0x40>
    1688:	00 0f       	add	r16, r16
    168a:	11 1f       	adc	r17, r17
    168c:	8a 95       	dec	r24
    168e:	e2 f7       	brpl	.-8      	; 0x1688 <DF_CopyFlashPageToBuffer+0x3c>
    1690:	80 2f       	mov	r24, r16
    1692:	f7 01       	movw	r30, r14
    1694:	09 95       	icall
    1696:	80 e0       	ldi	r24, 0x00	; 0
    1698:	f7 01       	movw	r30, r14
    169a:	09 95       	icall
    169c:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <DF_WaitWhileBusy>
    16a0:	1f 91       	pop	r17
    16a2:	0f 91       	pop	r16
    16a4:	ff 90       	pop	r15
    16a6:	ef 90       	pop	r14
    16a8:	08 95       	ret

000016aa <DF_CopyBufferToFlashPage>:
    16aa:	ef 92       	push	r14
    16ac:	ff 92       	push	r15
    16ae:	0f 93       	push	r16
    16b0:	1f 93       	push	r17
    16b2:	8c 01       	movw	r16, r24
    16b4:	e0 90 00 01 	lds	r14, 0x0100
    16b8:	f0 90 01 01 	lds	r15, 0x0101
    16bc:	80 e0       	ldi	r24, 0x00	; 0
    16be:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    16c2:	81 e0       	ldi	r24, 0x01	; 1
    16c4:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    16c8:	83 e8       	ldi	r24, 0x83	; 131
    16ca:	f7 01       	movw	r30, r14
    16cc:	09 95       	icall
    16ce:	8a b5       	in	r24, 0x2a	; 42
    16d0:	98 01       	movw	r18, r16
    16d2:	02 c0       	rjmp	.+4      	; 0x16d8 <DF_CopyBufferToFlashPage+0x2e>
    16d4:	36 95       	lsr	r19
    16d6:	27 95       	ror	r18
    16d8:	8a 95       	dec	r24
    16da:	e2 f7       	brpl	.-8      	; 0x16d4 <DF_CopyBufferToFlashPage+0x2a>
    16dc:	c9 01       	movw	r24, r18
    16de:	f7 01       	movw	r30, r14
    16e0:	09 95       	icall
    16e2:	8b b5       	in	r24, 0x2b	; 43
    16e4:	02 c0       	rjmp	.+4      	; 0x16ea <DF_CopyBufferToFlashPage+0x40>
    16e6:	00 0f       	add	r16, r16
    16e8:	11 1f       	adc	r17, r17
    16ea:	8a 95       	dec	r24
    16ec:	e2 f7       	brpl	.-8      	; 0x16e6 <DF_CopyBufferToFlashPage+0x3c>
    16ee:	80 2f       	mov	r24, r16
    16f0:	f7 01       	movw	r30, r14
    16f2:	09 95       	icall
    16f4:	80 e0       	ldi	r24, 0x00	; 0
    16f6:	f7 01       	movw	r30, r14
    16f8:	09 95       	icall
    16fa:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <DF_WaitWhileBusy>
    16fe:	1f 91       	pop	r17
    1700:	0f 91       	pop	r16
    1702:	ff 90       	pop	r15
    1704:	ef 90       	pop	r14
    1706:	08 95       	ret

00001708 <DF_GetChipCharacteristics>:
    1708:	0f 93       	push	r16
    170a:	1f 93       	push	r17
    170c:	00 91 00 01 	lds	r16, 0x0100
    1710:	10 91 01 01 	lds	r17, 0x0101
    1714:	80 e0       	ldi	r24, 0x00	; 0
    1716:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    171a:	81 e0       	ldi	r24, 0x01	; 1
    171c:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    1720:	87 e5       	ldi	r24, 0x57	; 87
    1722:	f8 01       	movw	r30, r16
    1724:	09 95       	icall
    1726:	80 e0       	ldi	r24, 0x00	; 0
    1728:	f8 01       	movw	r30, r16
    172a:	09 95       	icall
    172c:	99 27       	eor	r25, r25
    172e:	88 73       	andi	r24, 0x38	; 56
    1730:	90 70       	andi	r25, 0x00	; 0
    1732:	63 e0       	ldi	r22, 0x03	; 3
    1734:	96 95       	lsr	r25
    1736:	87 95       	ror	r24
    1738:	6a 95       	dec	r22
    173a:	e1 f7       	brne	.-8      	; 0x1734 <DF_GetChipCharacteristics+0x2c>
    173c:	fc 01       	movw	r30, r24
    173e:	e0 56       	subi	r30, 0x60	; 96
    1740:	fc 4f       	sbci	r31, 0xFC	; 252
    1742:	e4 91       	lpm	r30, Z
    1744:	4e 2f       	mov	r20, r30
    1746:	55 27       	eor	r21, r21
    1748:	50 93 3e 01 	sts	0x013E, r21
    174c:	40 93 3d 01 	sts	0x013D, r20
    1750:	88 0f       	add	r24, r24
    1752:	99 1f       	adc	r25, r25
    1754:	fc 01       	movw	r30, r24
    1756:	e8 55       	subi	r30, 0x58	; 88
    1758:	fc 4f       	sbci	r31, 0xFC	; 252
    175a:	25 91       	lpm	r18, Z+
    175c:	34 91       	lpm	r19, Z
    175e:	30 93 40 01 	sts	0x0140, r19
    1762:	20 93 3f 01 	sts	0x013F, r18
    1766:	88 54       	subi	r24, 0x48	; 72
    1768:	9c 4f       	sbci	r25, 0xFC	; 252
    176a:	fc 01       	movw	r30, r24
    176c:	25 91       	lpm	r18, Z+
    176e:	34 91       	lpm	r19, Z
    1770:	30 93 42 01 	sts	0x0142, r19
    1774:	20 93 41 01 	sts	0x0141, r18
    1778:	80 e1       	ldi	r24, 0x10	; 16
    177a:	84 1b       	sub	r24, r20
    177c:	8a bd       	out	0x2a, r24	; 42
    177e:	48 50       	subi	r20, 0x08	; 8
    1780:	4b bd       	out	0x2b, r20	; 43
    1782:	1f 91       	pop	r17
    1784:	0f 91       	pop	r16
    1786:	08 95       	ret

00001788 <DF_CheckCorrectOnboardChip>:
    1788:	0e 94 84 0b 	call	0x1708	; 0x1708 <DF_GetChipCharacteristics>
    178c:	80 91 41 01 	lds	r24, 0x0141
    1790:	90 91 42 01 	lds	r25, 0x0142
    1794:	80 50       	subi	r24, 0x00	; 0
    1796:	98 40       	sbci	r25, 0x08	; 8
    1798:	19 f4       	brne	.+6      	; 0x17a0 <DF_CheckCorrectOnboardChip+0x18>
    179a:	81 e0       	ldi	r24, 0x01	; 1
    179c:	90 e0       	ldi	r25, 0x00	; 0
    179e:	08 95       	ret
    17a0:	80 91 64 00 	lds	r24, 0x0064
    17a4:	84 60       	ori	r24, 0x04	; 4
    17a6:	80 93 64 00 	sts	0x0064, r24
    17aa:	88 ec       	ldi	r24, 0xC8	; 200
    17ac:	93 e0       	ldi	r25, 0x03	; 3
    17ae:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
    17b2:	80 e0       	ldi	r24, 0x00	; 0
    17b4:	90 e0       	ldi	r25, 0x00	; 0
    17b6:	08 95       	ret

000017b8 <BUFF_InitialiseBuffer>:

// ======================================================================================

void BUFF_InitialiseBuffer(void)
{
    17b8:	10 92 89 01 	sts	0x0189, r1
	InPos  = 0;                            // Set up the IN counter to the start of the buffer
	OutPos = 0;                            // Set up the OUT counter to the start of the buffer
    17bc:	10 92 8a 01 	sts	0x018A, r1

	BuffElements = 0;                      // Reset the buffer elements counter
    17c0:	10 92 88 01 	sts	0x0188, r1
    17c4:	08 95       	ret

000017c6 <BUFF_GetBuffByte>:
}

uint8_t BUFF_GetBuffByte(void)
{
    17c6:	80 91 88 01 	lds	r24, 0x0188
    17ca:	88 23       	and	r24, r24
    17cc:	19 f4       	brne	.+6      	; 0x17d4 <BUFF_GetBuffByte+0xe>
	if (!(BuffElements))                   // No elements in the buffer
    17ce:	80 e0       	ldi	r24, 0x00	; 0
    17d0:	90 e0       	ldi	r25, 0x00	; 0
    17d2:	08 95       	ret
	  return 0;

	uint8_t RetrievedData = RingBuffer[OutPos++]; // Grab the stored byte into a temp variable
    17d4:	80 91 8a 01 	lds	r24, 0x018A
    17d8:	e8 2f       	mov	r30, r24
    17da:	ff 27       	eor	r31, r31
    17dc:	e8 5b       	subi	r30, 0xB8	; 184
    17de:	fe 4f       	sbci	r31, 0xFE	; 254
    17e0:	e0 81       	ld	r30, Z
    17e2:	8f 5f       	subi	r24, 0xFF	; 255
    17e4:	80 93 8a 01 	sts	0x018A, r24
	BuffElements--;                        // Decrement the total elements variable
    17e8:	80 91 88 01 	lds	r24, 0x0188
    17ec:	81 50       	subi	r24, 0x01	; 1
    17ee:	80 93 88 01 	sts	0x0188, r24
	
	if (OutPos == BUFF_BUFFLEN)
    17f2:	80 91 8a 01 	lds	r24, 0x018A
    17f6:	80 34       	cpi	r24, 0x40	; 64
    17f8:	11 f4       	brne	.+4      	; 0x17fe <BUFF_GetBuffByte+0x38>
	  OutPos = 0;                        // Wrap pointer if end of array reached
    17fa:	10 92 8a 01 	sts	0x018A, r1
		
	return RetrievedData;                 // Return the retrieved data
    17fe:	8e 2f       	mov	r24, r30
    1800:	99 27       	eor	r25, r25
}
    1802:	08 95       	ret

00001804 <__vector_13>:
    1804:	1f 92       	push	r1
    1806:	0f 92       	push	r0
    1808:	0f b6       	in	r0, 0x3f	; 63
    180a:	0f 92       	push	r0
    180c:	11 24       	eor	r1, r1
    180e:	2f 93       	push	r18
    1810:	3f 93       	push	r19
    1812:	4f 93       	push	r20
    1814:	5f 93       	push	r21
    1816:	6f 93       	push	r22
    1818:	7f 93       	push	r23
    181a:	8f 93       	push	r24
    181c:	9f 93       	push	r25
    181e:	af 93       	push	r26
    1820:	bf 93       	push	r27
    1822:	ef 93       	push	r30
    1824:	ff 93       	push	r31
    1826:	80 91 88 01 	lds	r24, 0x0188
    182a:	80 34       	cpi	r24, 0x40	; 64
    182c:	21 f4       	brne	.+8      	; 0x1836 <__vector_13+0x32>
    182e:	88 ed       	ldi	r24, 0xD8	; 216
    1830:	93 e0       	ldi	r25, 0x03	; 3
    1832:	0e 94 cc 04 	call	0x998	; 0x998 <MAIN_CrashProgram>
    1836:	80 91 89 01 	lds	r24, 0x0189
    183a:	e8 2f       	mov	r30, r24
    183c:	ff 27       	eor	r31, r31
    183e:	90 91 c6 00 	lds	r25, 0x00C6
    1842:	e8 5b       	subi	r30, 0xB8	; 184
    1844:	fe 4f       	sbci	r31, 0xFE	; 254
    1846:	90 83       	st	Z, r25
    1848:	8f 5f       	subi	r24, 0xFF	; 255
    184a:	80 93 89 01 	sts	0x0189, r24
    184e:	80 91 88 01 	lds	r24, 0x0188
    1852:	8f 5f       	subi	r24, 0xFF	; 255
    1854:	80 93 88 01 	sts	0x0188, r24
    1858:	80 91 89 01 	lds	r24, 0x0189
    185c:	80 34       	cpi	r24, 0x40	; 64
    185e:	11 f4       	brne	.+4      	; 0x1864 <__vector_13+0x60>
    1860:	10 92 89 01 	sts	0x0189, r1
    1864:	ff 91       	pop	r31
    1866:	ef 91       	pop	r30
    1868:	bf 91       	pop	r27
    186a:	af 91       	pop	r26
    186c:	9f 91       	pop	r25
    186e:	8f 91       	pop	r24
    1870:	7f 91       	pop	r23
    1872:	6f 91       	pop	r22
    1874:	5f 91       	pop	r21
    1876:	4f 91       	pop	r20
    1878:	3f 91       	pop	r19
    187a:	2f 91       	pop	r18
    187c:	0f 90       	pop	r0
    187e:	0f be       	out	0x3f, r0	; 63
    1880:	0f 90       	pop	r0
    1882:	1f 90       	pop	r1
    1884:	18 95       	reti

00001886 <TOUT_SetupSleepTimer>:

// ======================================================================================

void TOUT_SetupSleepTimer(void)
{
    1886:	ab e8       	ldi	r26, 0x8B	; 139
    1888:	b0 e0       	ldi	r27, 0x00	; 0
    188a:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
    188e:	80 2d       	mov	r24, r0
	uint8_t NewTicksIndex = eeprom_read_byte(&EEPROMVars.AutoSleepValIndex);
    1890:	48 2f       	mov	r20, r24

	if (NewTicksIndex == 0xFF) // Blank EEPROM protection
    1892:	8f 3f       	cpi	r24, 0xFF	; 255
    1894:	09 f4       	brne	.+2      	; 0x1898 <TOUT_SetupSleepTimer+0x12>
    1896:	44 e0       	ldi	r20, 0x04	; 4
	  NewTicksIndex = 4;

	TIMSK1 = (1 << TOIE1);
    1898:	51 e0       	ldi	r21, 0x01	; 1
    189a:	50 93 6f 00 	sts	0x006F, r21
	TicksBeforeAutoSleep = ((pgm_read_byte(&AutoSleepTOValues[NewTicksIndex]) << 1) * 5); // ((x << 1) * 5) == (x * 10)
    189e:	e4 2f       	mov	r30, r20
    18a0:	ff 27       	eor	r31, r31
    18a2:	ef 51       	subi	r30, 0x1F	; 31
    18a4:	fc 4f       	sbci	r31, 0xFC	; 252
    18a6:	e4 91       	lpm	r30, Z
    18a8:	8e 2f       	mov	r24, r30
    18aa:	99 27       	eor	r25, r25
    18ac:	9c 01       	movw	r18, r24
    18ae:	73 e0       	ldi	r23, 0x03	; 3
    18b0:	22 0f       	add	r18, r18
    18b2:	33 1f       	adc	r19, r19
    18b4:	7a 95       	dec	r23
    18b6:	e1 f7       	brne	.-8      	; 0x18b0 <TOUT_SetupSleepTimer+0x2a>
    18b8:	88 0f       	add	r24, r24
    18ba:	99 1f       	adc	r25, r25
    18bc:	28 0f       	add	r18, r24
    18be:	39 1f       	adc	r19, r25
    18c0:	30 93 90 01 	sts	0x0190, r19
    18c4:	20 93 8f 01 	sts	0x018F, r18

	TIMEOUT_SLEEP_TIMEOUT_RESET();
    18c8:	10 92 8e 01 	sts	0x018E, r1
    18cc:	10 92 8d 01 	sts	0x018D, r1
    18d0:	10 92 85 00 	sts	0x0085, r1
    18d4:	10 92 84 00 	sts	0x0084, r1
	
	if (NewTicksIndex)
    18d8:	44 23       	and	r20, r20
    18da:	19 f0       	breq	.+6      	; 0x18e2 <TOUT_SetupSleepTimer+0x5c>
	  TIMEOUT_SLEEP_TIMER_ON();
    18dc:	50 93 81 00 	sts	0x0081, r21
    18e0:	08 95       	ret
	else
	  TIMEOUT_SLEEP_TIMER_OFF();
    18e2:	10 92 81 00 	sts	0x0081, r1
    18e6:	08 95       	ret

000018e8 <__vector_9>:
    18e8:	78 94       	sei
    18ea:	1f 92       	push	r1
    18ec:	0f 92       	push	r0
    18ee:	0f b6       	in	r0, 0x3f	; 63
    18f0:	0f 92       	push	r0
    18f2:	11 24       	eor	r1, r1
    18f4:	2f 93       	push	r18
    18f6:	3f 93       	push	r19
    18f8:	4f 93       	push	r20
    18fa:	5f 93       	push	r21
    18fc:	6f 93       	push	r22
    18fe:	7f 93       	push	r23
    1900:	8f 93       	push	r24
    1902:	9f 93       	push	r25
    1904:	af 93       	push	r26
    1906:	bf 93       	push	r27
    1908:	ef 93       	push	r30
    190a:	ff 93       	push	r31
    190c:	80 91 8d 01 	lds	r24, 0x018D
    1910:	90 91 8e 01 	lds	r25, 0x018E
    1914:	20 91 8f 01 	lds	r18, 0x018F
    1918:	30 91 90 01 	lds	r19, 0x0190
    191c:	01 96       	adiw	r24, 0x01	; 1
    191e:	90 93 8e 01 	sts	0x018E, r25
    1922:	80 93 8d 01 	sts	0x018D, r24
    1926:	01 97       	sbiw	r24, 0x01	; 1
    1928:	82 17       	cp	r24, r18
    192a:	93 07       	cpc	r25, r19
    192c:	31 f4       	brne	.+12     	; 0x193a <__vector_9+0x52>
    192e:	10 92 81 00 	sts	0x0081, r1
    1932:	0e 94 da 02 	call	0x5b4	; 0x5b4 <FUNCSleepMode>
    1936:	0e 94 43 0c 	call	0x1886	; 0x1886 <TOUT_SetupSleepTimer>
    193a:	ff 91       	pop	r31
    193c:	ef 91       	pop	r30
    193e:	bf 91       	pop	r27
    1940:	af 91       	pop	r26
    1942:	9f 91       	pop	r25
    1944:	8f 91       	pop	r24
    1946:	7f 91       	pop	r23
    1948:	6f 91       	pop	r22
    194a:	5f 91       	pop	r21
    194c:	4f 91       	pop	r20
    194e:	3f 91       	pop	r19
    1950:	2f 91       	pop	r18
    1952:	0f 90       	pop	r0
    1954:	0f be       	out	0x3f, r0	; 63
    1956:	0f 90       	pop	r0
    1958:	1f 90       	pop	r1
    195a:	18 95       	reti

0000195c <__vector_4>:
    195c:	78 94       	sei
    195e:	1f 92       	push	r1
    1960:	0f 92       	push	r0
    1962:	0f b6       	in	r0, 0x3f	; 63
    1964:	0f 92       	push	r0
    1966:	11 24       	eor	r1, r1
    1968:	2f 93       	push	r18
    196a:	3f 93       	push	r19
    196c:	4f 93       	push	r20
    196e:	5f 93       	push	r21
    1970:	6f 93       	push	r22
    1972:	7f 93       	push	r23
    1974:	8f 93       	push	r24
    1976:	9f 93       	push	r25
    1978:	af 93       	push	r26
    197a:	bf 93       	push	r27
    197c:	ef 93       	push	r30
    197e:	ff 93       	push	r31
    1980:	80 91 8b 01 	lds	r24, 0x018B
    1984:	8f 5f       	subi	r24, 0xFF	; 255
    1986:	80 93 8b 01 	sts	0x018B, r24
    198a:	80 91 8b 01 	lds	r24, 0x018B
    198e:	87 39       	cpi	r24, 0x97	; 151
    1990:	29 f4       	brne	.+10     	; 0x199c <__vector_4+0x40>
    1992:	10 92 8b 01 	sts	0x018B, r1
    1996:	81 e0       	ldi	r24, 0x01	; 1
    1998:	80 93 8c 01 	sts	0x018C, r24
    199c:	80 91 c0 00 	lds	r24, 0x00C0
    19a0:	83 ff       	sbrs	r24, 3
    19a2:	03 c0       	rjmp	.+6      	; 0x19aa <__vector_4+0x4e>
    19a4:	80 ef       	ldi	r24, 0xF0	; 240
    19a6:	93 e0       	ldi	r25, 0x03	; 3
    19a8:	06 c0       	rjmp	.+12     	; 0x19b6 <__vector_4+0x5a>
    19aa:	80 91 c0 00 	lds	r24, 0x00C0
    19ae:	84 ff       	sbrs	r24, 4
    19b0:	04 c0       	rjmp	.+8      	; 0x19ba <__vector_4+0x5e>
    19b2:	86 ee       	ldi	r24, 0xE6	; 230
    19b4:	93 e0       	ldi	r25, 0x03	; 3
    19b6:	0e 94 cc 04 	call	0x998	; 0x998 <MAIN_CrashProgram>
    19ba:	ff 91       	pop	r31
    19bc:	ef 91       	pop	r30
    19be:	bf 91       	pop	r27
    19c0:	af 91       	pop	r26
    19c2:	9f 91       	pop	r25
    19c4:	8f 91       	pop	r24
    19c6:	7f 91       	pop	r23
    19c8:	6f 91       	pop	r22
    19ca:	5f 91       	pop	r21
    19cc:	4f 91       	pop	r20
    19ce:	3f 91       	pop	r19
    19d0:	2f 91       	pop	r18
    19d2:	0f 90       	pop	r0
    19d4:	0f be       	out	0x3f, r0	; 63
    19d6:	0f 90       	pop	r0
    19d8:	1f 90       	pop	r1
    19da:	18 95       	reti

000019dc <PD_SetupDFAddressCounters>:
	}
}

void PD_SetupDFAddressCounters(void)
{
    19dc:	ef 92       	push	r14
    19de:	ff 92       	push	r15
    19e0:	0f 93       	push	r16
    19e2:	1f 93       	push	r17
	uint32_t StartAddress = CurrAddress;
    19e4:	20 91 a9 02 	lds	r18, 0x02A9
    19e8:	30 91 aa 02 	lds	r19, 0x02AA
    19ec:	40 91 ab 02 	lds	r20, 0x02AB
    19f0:	50 91 ac 02 	lds	r21, 0x02AC

	DataflashInfo.CurrPageAddress = 0;
    19f4:	10 92 44 01 	sts	0x0144, r1
    19f8:	10 92 43 01 	sts	0x0143, r1

	while (StartAddress > DataflashInfo.PageSize)      // This loop is the equivalent of a DIV and a MOD
    19fc:	80 91 3f 01 	lds	r24, 0x013F
    1a00:	90 91 40 01 	lds	r25, 0x0140
    1a04:	aa 27       	eor	r26, r26
    1a06:	bb 27       	eor	r27, r27
    1a08:	60 e0       	ldi	r22, 0x00	; 0
    1a0a:	70 e0       	ldi	r23, 0x00	; 0
    1a0c:	ee 24       	eor	r14, r14
    1a0e:	ff 24       	eor	r15, r15
    1a10:	87 01       	movw	r16, r14
    1a12:	e8 1a       	sub	r14, r24
    1a14:	f9 0a       	sbc	r15, r25
    1a16:	0a 0b       	sbc	r16, r26
    1a18:	1b 0b       	sbc	r17, r27
    1a1a:	06 c0       	rjmp	.+12     	; 0x1a28 <PD_SetupDFAddressCounters+0x4c>
    1a1c:	2e 0d       	add	r18, r14
    1a1e:	3f 1d       	adc	r19, r15
    1a20:	40 1f       	adc	r20, r16
    1a22:	51 1f       	adc	r21, r17
    1a24:	6f 5f       	subi	r22, 0xFF	; 255
    1a26:	7f 4f       	sbci	r23, 0xFF	; 255
    1a28:	82 17       	cp	r24, r18
    1a2a:	93 07       	cpc	r25, r19
    1a2c:	a4 07       	cpc	r26, r20
    1a2e:	b5 07       	cpc	r27, r21
    1a30:	a8 f3       	brcs	.-22     	; 0x1a1c <PD_SetupDFAddressCounters+0x40>
    1a32:	70 93 44 01 	sts	0x0144, r23
    1a36:	60 93 43 01 	sts	0x0143, r22
	{
		StartAddress -= DataflashInfo.PageSize;         // Subtract one page's worth of bytes from the desired address
		DataflashInfo.CurrPageAddress++;
	}
	
	DataflashInfo.CurrBuffByte = (uint16_t)StartAddress; // The buffer byte is the remainder
    1a3a:	30 93 46 01 	sts	0x0146, r19
    1a3e:	20 93 45 01 	sts	0x0145, r18
    1a42:	1f 91       	pop	r17
    1a44:	0f 91       	pop	r16
    1a46:	ff 90       	pop	r15
    1a48:	ef 90       	pop	r14
    1a4a:	08 95       	ret

00001a4c <PD_StoreDataflashByte>:
}

void PD_StoreDataflashByte(const uint8_t Data)
{
    1a4c:	1f 93       	push	r17
    1a4e:	18 2f       	mov	r17, r24
	if (DataflashInfo.CurrBuffByte == DataflashInfo.PageSize)
    1a50:	20 91 45 01 	lds	r18, 0x0145
    1a54:	30 91 46 01 	lds	r19, 0x0146
    1a58:	80 91 3f 01 	lds	r24, 0x013F
    1a5c:	90 91 40 01 	lds	r25, 0x0140
    1a60:	28 17       	cp	r18, r24
    1a62:	39 07       	cpc	r19, r25
    1a64:	a1 f4       	brne	.+40     	; 0x1a8e <PD_StoreDataflashByte+0x42>
	{
		DF_CopyBufferToFlashPage(DataflashInfo.CurrPageAddress++);
    1a66:	80 91 43 01 	lds	r24, 0x0143
    1a6a:	90 91 44 01 	lds	r25, 0x0144
    1a6e:	01 96       	adiw	r24, 0x01	; 1
    1a70:	90 93 44 01 	sts	0x0144, r25
    1a74:	80 93 43 01 	sts	0x0143, r24
    1a78:	01 97       	sbiw	r24, 0x01	; 1
    1a7a:	0e 94 55 0b 	call	0x16aa	; 0x16aa <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    1a7e:	80 e0       	ldi	r24, 0x00	; 0
    1a80:	90 e0       	ldi	r25, 0x00	; 0
    1a82:	0e 94 cb 0a 	call	0x1596	; 0x1596 <DF_BufferWriteEnable>
		DataflashInfo.CurrBuffByte = 0;
    1a86:	10 92 46 01 	sts	0x0146, r1
    1a8a:	10 92 45 01 	sts	0x0145, r1
	}
	
	USI_SPITransmit(Data);                                 // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    1a8e:	81 2f       	mov	r24, r17
    1a90:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
	DataflashInfo.CurrBuffByte++;
    1a94:	80 91 45 01 	lds	r24, 0x0145
    1a98:	90 91 46 01 	lds	r25, 0x0146
    1a9c:	01 96       	adiw	r24, 0x01	; 1
    1a9e:	90 93 46 01 	sts	0x0146, r25
    1aa2:	80 93 45 01 	sts	0x0145, r24
    1aa6:	1f 91       	pop	r17
    1aa8:	08 95       	ret

00001aaa <PD_InterpretAVRISPPacket>:
    1aaa:	0f 93       	push	r16
    1aac:	1f 93       	push	r17
    1aae:	cf 93       	push	r28
    1ab0:	df 93       	push	r29
    1ab2:	80 91 91 01 	lds	r24, 0x0191
    1ab6:	86 31       	cpi	r24, 0x16	; 22
    1ab8:	09 f4       	brne	.+2      	; 0x1abc <PD_InterpretAVRISPPacket+0x12>
    1aba:	f1 c0       	rjmp	.+482    	; 0x1c9e <PD_InterpretAVRISPPacket+0x1f4>
    1abc:	87 31       	cpi	r24, 0x17	; 23
    1abe:	90 f4       	brcc	.+36     	; 0x1ae4 <PD_InterpretAVRISPPacket+0x3a>
    1ac0:	82 31       	cpi	r24, 0x12	; 18
    1ac2:	09 f4       	brne	.+2      	; 0x1ac6 <PD_InterpretAVRISPPacket+0x1c>
    1ac4:	65 c0       	rjmp	.+202    	; 0x1b90 <PD_InterpretAVRISPPacket+0xe6>
    1ac6:	83 31       	cpi	r24, 0x13	; 19
    1ac8:	30 f4       	brcc	.+12     	; 0x1ad6 <PD_InterpretAVRISPPacket+0x2c>
    1aca:	80 31       	cpi	r24, 0x10	; 16
    1acc:	01 f1       	breq	.+64     	; 0x1b0e <PD_InterpretAVRISPPacket+0x64>
    1ace:	81 31       	cpi	r24, 0x11	; 17
    1ad0:	09 f0       	breq	.+2      	; 0x1ad4 <PD_InterpretAVRISPPacket+0x2a>
    1ad2:	2f c1       	rjmp	.+606    	; 0x1d32 <PD_InterpretAVRISPPacket+0x288>
    1ad4:	41 c0       	rjmp	.+130    	; 0x1b58 <PD_InterpretAVRISPPacket+0xae>
    1ad6:	84 31       	cpi	r24, 0x14	; 20
    1ad8:	09 f4       	brne	.+2      	; 0x1adc <PD_InterpretAVRISPPacket+0x32>
    1ada:	8b c0       	rjmp	.+278    	; 0x1bf2 <PD_InterpretAVRISPPacket+0x148>
    1adc:	85 31       	cpi	r24, 0x15	; 21
    1ade:	08 f0       	brcs	.+2      	; 0x1ae2 <PD_InterpretAVRISPPacket+0x38>
    1ae0:	ab c0       	rjmp	.+342    	; 0x1c38 <PD_InterpretAVRISPPacket+0x18e>
    1ae2:	80 c0       	rjmp	.+256    	; 0x1be4 <PD_InterpretAVRISPPacket+0x13a>
    1ae4:	89 31       	cpi	r24, 0x19	; 25
    1ae6:	09 f4       	brne	.+2      	; 0x1aea <PD_InterpretAVRISPPacket+0x40>
    1ae8:	72 c0       	rjmp	.+228    	; 0x1bce <PD_InterpretAVRISPPacket+0x124>
    1aea:	8a 31       	cpi	r24, 0x1A	; 26
    1aec:	38 f4       	brcc	.+14     	; 0x1afc <PD_InterpretAVRISPPacket+0x52>
    1aee:	87 31       	cpi	r24, 0x17	; 23
    1af0:	09 f4       	brne	.+2      	; 0x1af4 <PD_InterpretAVRISPPacket+0x4a>
    1af2:	6d c0       	rjmp	.+218    	; 0x1bce <PD_InterpretAVRISPPacket+0x124>
    1af4:	88 31       	cpi	r24, 0x18	; 24
    1af6:	09 f0       	breq	.+2      	; 0x1afa <PD_InterpretAVRISPPacket+0x50>
    1af8:	1c c1       	rjmp	.+568    	; 0x1d32 <PD_InterpretAVRISPPacket+0x288>
    1afa:	5b c0       	rjmp	.+182    	; 0x1bb2 <PD_InterpretAVRISPPacket+0x108>
    1afc:	8b 31       	cpi	r24, 0x1B	; 27
    1afe:	f1 f1       	breq	.+124    	; 0x1b7c <PD_InterpretAVRISPPacket+0xd2>
    1b00:	8b 31       	cpi	r24, 0x1B	; 27
    1b02:	08 f4       	brcc	.+2      	; 0x1b06 <PD_InterpretAVRISPPacket+0x5c>
    1b04:	56 c0       	rjmp	.+172    	; 0x1bb2 <PD_InterpretAVRISPPacket+0x108>
    1b06:	8c 31       	cpi	r24, 0x1C	; 28
    1b08:	09 f0       	breq	.+2      	; 0x1b0c <PD_InterpretAVRISPPacket+0x62>
    1b0a:	13 c1       	rjmp	.+550    	; 0x1d32 <PD_InterpretAVRISPPacket+0x288>
    1b0c:	52 c0       	rjmp	.+164    	; 0x1bb2 <PD_InterpretAVRISPPacket+0x108>
    1b0e:	82 e0       	ldi	r24, 0x02	; 2
    1b10:	90 e0       	ldi	r25, 0x00	; 0
    1b12:	90 93 a7 02 	sts	0x02A7, r25
    1b16:	80 93 a6 02 	sts	0x02A6, r24
    1b1a:	81 e0       	ldi	r24, 0x01	; 1
    1b1c:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    1b20:	0e 94 84 0b 	call	0x1708	; 0x1708 <DF_GetChipCharacteristics>
    1b24:	80 91 3d 01 	lds	r24, 0x013D
    1b28:	90 91 3e 01 	lds	r25, 0x013E
    1b2c:	89 2b       	or	r24, r25
    1b2e:	59 f0       	breq	.+22     	; 0x1b46 <PD_InterpretAVRISPPacket+0x9c>
    1b30:	89 ef       	ldi	r24, 0xF9	; 249
    1b32:	93 e0       	ldi	r25, 0x03	; 3
    1b34:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
    1b38:	81 e0       	ldi	r24, 0x01	; 1
    1b3a:	80 93 a8 02 	sts	0x02A8, r24
    1b3e:	81 b3       	in	r24, 0x11	; 17
    1b40:	8f 7c       	andi	r24, 0xCF	; 207
    1b42:	80 62       	ori	r24, 0x20	; 32
    1b44:	17 c0       	rjmp	.+46     	; 0x1b74 <PD_InterpretAVRISPPacket+0xca>
    1b46:	88 ec       	ldi	r24, 0xC8	; 200
    1b48:	93 e0       	ldi	r25, 0x03	; 3
    1b4a:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
    1b4e:	80 e0       	ldi	r24, 0x00	; 0
    1b50:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    1b54:	80 ec       	ldi	r24, 0xC0	; 192
    1b56:	f4 c0       	rjmp	.+488    	; 0x1d40 <PD_InterpretAVRISPPacket+0x296>
    1b58:	82 e0       	ldi	r24, 0x02	; 2
    1b5a:	90 e0       	ldi	r25, 0x00	; 0
    1b5c:	90 93 a7 02 	sts	0x02A7, r25
    1b60:	80 93 a6 02 	sts	0x02A6, r24
    1b64:	10 92 a8 02 	sts	0x02A8, r1
    1b68:	80 e0       	ldi	r24, 0x00	; 0
    1b6a:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    1b6e:	81 b3       	in	r24, 0x11	; 17
    1b70:	8f 7c       	andi	r24, 0xCF	; 207
    1b72:	80 61       	ori	r24, 0x10	; 16
    1b74:	81 bb       	out	0x11, r24	; 17
    1b76:	10 92 92 01 	sts	0x0192, r1
    1b7a:	e4 c0       	rjmp	.+456    	; 0x1d44 <PD_InterpretAVRISPPacket+0x29a>
    1b7c:	84 e0       	ldi	r24, 0x04	; 4
    1b7e:	90 e0       	ldi	r25, 0x00	; 0
    1b80:	90 93 a7 02 	sts	0x02A7, r25
    1b84:	80 93 a6 02 	sts	0x02A6, r24
    1b88:	10 92 92 01 	sts	0x0192, r1
    1b8c:	82 e0       	ldi	r24, 0x02	; 2
    1b8e:	1a c0       	rjmp	.+52     	; 0x1bc4 <PD_InterpretAVRISPPacket+0x11a>
    1b90:	82 e0       	ldi	r24, 0x02	; 2
    1b92:	90 e0       	ldi	r25, 0x00	; 0
    1b94:	90 93 a7 02 	sts	0x02A7, r25
    1b98:	80 93 a6 02 	sts	0x02A6, r24
    1b9c:	10 92 92 01 	sts	0x0192, r1
    1ba0:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <V2P_SendPacket>
    1ba4:	87 ea       	ldi	r24, 0xA7	; 167
    1ba6:	90 e0       	ldi	r25, 0x00	; 0
    1ba8:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
    1bac:	c0 e0       	ldi	r28, 0x00	; 0
    1bae:	d0 e0       	ldi	r29, 0x00	; 0
    1bb0:	d0 c0       	rjmp	.+416    	; 0x1d52 <PD_InterpretAVRISPPacket+0x2a8>
    1bb2:	84 e0       	ldi	r24, 0x04	; 4
    1bb4:	90 e0       	ldi	r25, 0x00	; 0
    1bb6:	90 93 a7 02 	sts	0x02A7, r25
    1bba:	80 93 a6 02 	sts	0x02A6, r24
    1bbe:	10 92 92 01 	sts	0x0192, r1
    1bc2:	8f ef       	ldi	r24, 0xFF	; 255
    1bc4:	80 93 93 01 	sts	0x0193, r24
    1bc8:	10 92 94 01 	sts	0x0194, r1
    1bcc:	bb c0       	rjmp	.+374    	; 0x1d44 <PD_InterpretAVRISPPacket+0x29a>
    1bce:	83 e0       	ldi	r24, 0x03	; 3
    1bd0:	90 e0       	ldi	r25, 0x00	; 0
    1bd2:	90 93 a7 02 	sts	0x02A7, r25
    1bd6:	80 93 a6 02 	sts	0x02A6, r24
    1bda:	10 92 92 01 	sts	0x0192, r1
    1bde:	10 92 93 01 	sts	0x0193, r1
    1be2:	b0 c0       	rjmp	.+352    	; 0x1d44 <PD_InterpretAVRISPPacket+0x29a>
    1be4:	82 e0       	ldi	r24, 0x02	; 2
    1be6:	90 e0       	ldi	r25, 0x00	; 0
    1be8:	90 93 a7 02 	sts	0x02A7, r25
    1bec:	80 93 a6 02 	sts	0x02A6, r24
    1bf0:	c2 cf       	rjmp	.-124    	; 0x1b76 <PD_InterpretAVRISPPacket+0xcc>
    1bf2:	20 91 92 01 	lds	r18, 0x0192
    1bf6:	33 27       	eor	r19, r19
    1bf8:	32 2f       	mov	r19, r18
    1bfa:	22 27       	eor	r18, r18
    1bfc:	80 91 93 01 	lds	r24, 0x0193
    1c00:	99 27       	eor	r25, r25
    1c02:	28 2b       	or	r18, r24
    1c04:	39 2b       	or	r19, r25
    1c06:	f9 01       	movw	r30, r18
    1c08:	33 96       	adiw	r30, 0x03	; 3
    1c0a:	f0 93 a7 02 	sts	0x02A7, r31
    1c0e:	e0 93 a6 02 	sts	0x02A6, r30
    1c12:	81 e0       	ldi	r24, 0x01	; 1
    1c14:	90 e0       	ldi	r25, 0x00	; 0
    1c16:	a2 e9       	ldi	r26, 0x92	; 146
    1c18:	b1 e0       	ldi	r27, 0x01	; 1
    1c1a:	2f 5f       	subi	r18, 0xFF	; 255
    1c1c:	3f 4f       	sbci	r19, 0xFF	; 255
    1c1e:	4f ef       	ldi	r20, 0xFF	; 255
    1c20:	02 c0       	rjmp	.+4      	; 0x1c26 <PD_InterpretAVRISPPacket+0x17c>
    1c22:	4d 93       	st	X+, r20
    1c24:	01 96       	adiw	r24, 0x01	; 1
    1c26:	82 17       	cp	r24, r18
    1c28:	93 07       	cpc	r25, r19
    1c2a:	d8 f3       	brcs	.-10     	; 0x1c22 <PD_InterpretAVRISPPacket+0x178>
    1c2c:	10 92 92 01 	sts	0x0192, r1
    1c30:	e0 57       	subi	r30, 0x70	; 112
    1c32:	fe 4f       	sbci	r31, 0xFE	; 254
    1c34:	10 82       	st	Z, r1
    1c36:	86 c0       	rjmp	.+268    	; 0x1d44 <PD_InterpretAVRISPPacket+0x29a>
    1c38:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <PD_SetupDFAddressCounters>
    1c3c:	80 91 43 01 	lds	r24, 0x0143
    1c40:	90 91 44 01 	lds	r25, 0x0144
    1c44:	0e 94 26 0b 	call	0x164c	; 0x164c <DF_CopyFlashPageToBuffer>
    1c48:	80 91 45 01 	lds	r24, 0x0145
    1c4c:	90 91 46 01 	lds	r25, 0x0146
    1c50:	0e 94 cb 0a 	call	0x1596	; 0x1596 <DF_BufferWriteEnable>
    1c54:	80 91 92 01 	lds	r24, 0x0192
    1c58:	99 27       	eor	r25, r25
    1c5a:	d8 2f       	mov	r29, r24
    1c5c:	cc 27       	eor	r28, r28
    1c5e:	80 91 93 01 	lds	r24, 0x0193
    1c62:	99 27       	eor	r25, r25
    1c64:	c8 2b       	or	r28, r24
    1c66:	d9 2b       	or	r29, r25
    1c68:	01 e9       	ldi	r16, 0x91	; 145
    1c6a:	11 e0       	ldi	r17, 0x01	; 1
    1c6c:	11 c0       	rjmp	.+34     	; 0x1c90 <PD_InterpretAVRISPPacket+0x1e6>
    1c6e:	f8 01       	movw	r30, r16
    1c70:	82 85       	ldd	r24, Z+10	; 0x0a
    1c72:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <PD_StoreDataflashByte>
    1c76:	80 91 45 01 	lds	r24, 0x0145
    1c7a:	90 91 46 01 	lds	r25, 0x0146
    1c7e:	01 96       	adiw	r24, 0x01	; 1
    1c80:	90 93 46 01 	sts	0x0146, r25
    1c84:	80 93 45 01 	sts	0x0145, r24
    1c88:	0e 94 db 0e 	call	0x1db6	; 0x1db6 <V2P_IncrementCurrAddress>
    1c8c:	0f 5f       	subi	r16, 0xFF	; 255
    1c8e:	1f 4f       	sbci	r17, 0xFF	; 255
    1c90:	ce 01       	movw	r24, r28
    1c92:	8f 56       	subi	r24, 0x6F	; 111
    1c94:	9e 4f       	sbci	r25, 0xFE	; 254
    1c96:	08 17       	cp	r16, r24
    1c98:	19 07       	cpc	r17, r25
    1c9a:	49 f7       	brne	.-46     	; 0x1c6e <PD_InterpretAVRISPPacket+0x1c4>
    1c9c:	6c cf       	rjmp	.-296    	; 0x1b76 <PD_InterpretAVRISPPacket+0xcc>
    1c9e:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <PD_SetupDFAddressCounters>
    1ca2:	80 91 43 01 	lds	r24, 0x0143
    1ca6:	90 91 44 01 	lds	r25, 0x0144
    1caa:	0e 94 26 0b 	call	0x164c	; 0x164c <DF_CopyFlashPageToBuffer>
    1cae:	80 91 92 01 	lds	r24, 0x0192
    1cb2:	99 27       	eor	r25, r25
    1cb4:	d8 2f       	mov	r29, r24
    1cb6:	cc 27       	eor	r28, r28
    1cb8:	80 91 93 01 	lds	r24, 0x0193
    1cbc:	99 27       	eor	r25, r25
    1cbe:	c8 2b       	or	r28, r24
    1cc0:	d9 2b       	or	r29, r25
    1cc2:	01 e9       	ldi	r16, 0x91	; 145
    1cc4:	11 e0       	ldi	r17, 0x01	; 1
    1cc6:	25 c0       	rjmp	.+74     	; 0x1d12 <PD_InterpretAVRISPPacket+0x268>
    1cc8:	20 91 45 01 	lds	r18, 0x0145
    1ccc:	30 91 46 01 	lds	r19, 0x0146
    1cd0:	80 91 3f 01 	lds	r24, 0x013F
    1cd4:	90 91 40 01 	lds	r25, 0x0140
    1cd8:	28 17       	cp	r18, r24
    1cda:	39 07       	cpc	r19, r25
    1cdc:	41 f4       	brne	.+16     	; 0x1cee <PD_InterpretAVRISPPacket+0x244>
    1cde:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <PD_SetupDFAddressCounters>
    1ce2:	80 91 43 01 	lds	r24, 0x0143
    1ce6:	90 91 44 01 	lds	r25, 0x0144
    1cea:	0e 94 26 0b 	call	0x164c	; 0x164c <DF_CopyFlashPageToBuffer>
    1cee:	80 91 45 01 	lds	r24, 0x0145
    1cf2:	90 91 46 01 	lds	r25, 0x0146
    1cf6:	01 96       	adiw	r24, 0x01	; 1
    1cf8:	90 93 46 01 	sts	0x0146, r25
    1cfc:	80 93 45 01 	sts	0x0145, r24
    1d00:	01 97       	sbiw	r24, 0x01	; 1
    1d02:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <DF_ReadBufferByte>
    1d06:	f8 01       	movw	r30, r16
    1d08:	82 83       	std	Z+2, r24	; 0x02
    1d0a:	0e 94 db 0e 	call	0x1db6	; 0x1db6 <V2P_IncrementCurrAddress>
    1d0e:	0f 5f       	subi	r16, 0xFF	; 255
    1d10:	1f 4f       	sbci	r17, 0xFF	; 255
    1d12:	ce 01       	movw	r24, r28
    1d14:	8f 56       	subi	r24, 0x6F	; 111
    1d16:	9e 4f       	sbci	r25, 0xFE	; 254
    1d18:	08 17       	cp	r16, r24
    1d1a:	19 07       	cpc	r17, r25
    1d1c:	a9 f6       	brne	.-86     	; 0x1cc8 <PD_InterpretAVRISPPacket+0x21e>
    1d1e:	23 96       	adiw	r28, 0x03	; 3
    1d20:	d0 93 a7 02 	sts	0x02A7, r29
    1d24:	c0 93 a6 02 	sts	0x02A6, r28
    1d28:	10 92 92 01 	sts	0x0192, r1
    1d2c:	f8 01       	movw	r30, r16
    1d2e:	12 82       	std	Z+2, r1	; 0x02
    1d30:	09 c0       	rjmp	.+18     	; 0x1d44 <PD_InterpretAVRISPPacket+0x29a>
    1d32:	81 e0       	ldi	r24, 0x01	; 1
    1d34:	90 e0       	ldi	r25, 0x00	; 0
    1d36:	90 93 a7 02 	sts	0x02A7, r25
    1d3a:	80 93 a6 02 	sts	0x02A6, r24
    1d3e:	89 ec       	ldi	r24, 0xC9	; 201
    1d40:	80 93 92 01 	sts	0x0192, r24
    1d44:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <V2P_SendPacket>
    1d48:	14 c0       	rjmp	.+40     	; 0x1d72 <PD_InterpretAVRISPPacket+0x2c8>
    1d4a:	ce 01       	movw	r24, r28
    1d4c:	0e 94 03 0b 	call	0x1606	; 0x1606 <DF_EraseBlock>
    1d50:	21 96       	adiw	r28, 0x01	; 1
    1d52:	80 91 41 01 	lds	r24, 0x0141
    1d56:	90 91 42 01 	lds	r25, 0x0142
    1d5a:	23 e0       	ldi	r18, 0x03	; 3
    1d5c:	96 95       	lsr	r25
    1d5e:	87 95       	ror	r24
    1d60:	2a 95       	dec	r18
    1d62:	e1 f7       	brne	.-8      	; 0x1d5c <PD_InterpretAVRISPPacket+0x2b2>
    1d64:	c8 17       	cp	r28, r24
    1d66:	d9 07       	cpc	r29, r25
    1d68:	80 f3       	brcs	.-32     	; 0x1d4a <PD_InterpretAVRISPPacket+0x2a0>
    1d6a:	89 ef       	ldi	r24, 0xF9	; 249
    1d6c:	93 e0       	ldi	r25, 0x03	; 3
    1d6e:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
    1d72:	df 91       	pop	r29
    1d74:	cf 91       	pop	r28
    1d76:	1f 91       	pop	r17
    1d78:	0f 91       	pop	r16
    1d7a:	08 95       	ret

00001d7c <V2P_GetChecksum>:
	SequenceNum++;
}

uint8_t V2P_GetChecksum()
{
    1d7c:	90 91 a4 02 	lds	r25, 0x02A4
    1d80:	8b e1       	ldi	r24, 0x1B	; 27
    1d82:	98 27       	eor	r25, r24
	uint8_t CheckSumByte;
	
	/* Checksum for the V2 protocol is comprised of an XOR of all the packet 
      bytes, including the start, sequence number, size and token bytes.    */
	
	CheckSumByte  = AICB_MESSAGE_START;
	CheckSumByte ^= SequenceNum;
	CheckSumByte ^= (uint8_t)(MessageSize >> 8);
    1d84:	40 91 a6 02 	lds	r20, 0x02A6
    1d88:	50 91 a7 02 	lds	r21, 0x02A7
    1d8c:	94 27       	eor	r25, r20
	CheckSumByte ^= (uint8_t)(MessageSize & 0xFF);
    1d8e:	25 2f       	mov	r18, r21
    1d90:	33 27       	eor	r19, r19
    1d92:	8e e0       	ldi	r24, 0x0E	; 14
    1d94:	82 27       	eor	r24, r18
	CheckSumByte ^= AICB_TOKEN;
    1d96:	98 27       	eor	r25, r24
    1d98:	20 e0       	ldi	r18, 0x00	; 0
    1d9a:	30 e0       	ldi	r19, 0x00	; 0
    1d9c:	e1 e9       	ldi	r30, 0x91	; 145
    1d9e:	f1 e0       	ldi	r31, 0x01	; 1
    1da0:	04 c0       	rjmp	.+8      	; 0x1daa <V2P_GetChecksum+0x2e>
	
	for (uint16_t CByteIndex = 0; CByteIndex < MessageSize; CByteIndex++)
	   CheckSumByte ^= PacketBytes[CByteIndex];
    1da2:	81 91       	ld	r24, Z+
    1da4:	98 27       	eor	r25, r24
    1da6:	2f 5f       	subi	r18, 0xFF	; 255
    1da8:	3f 4f       	sbci	r19, 0xFF	; 255
    1daa:	24 17       	cp	r18, r20
    1dac:	35 07       	cpc	r19, r21
    1dae:	c9 f7       	brne	.-14     	; 0x1da2 <V2P_GetChecksum+0x26>

	return CheckSumByte;
}
    1db0:	89 2f       	mov	r24, r25
    1db2:	99 27       	eor	r25, r25
    1db4:	08 95       	ret

00001db6 <V2P_IncrementCurrAddress>:

void V2P_GetSetParamater(void)
{
	uint8_t Param_Name = PacketBytes[1];    // Save the parameter number

	MessageSize = 3;                        // Set the default response message size to 3 bytes     
	PacketBytes[1] = AICB_STATUS_CMD_OK;    // Set the default response to OK

	switch (Param_Name)                     // Switch based on the recieved parameter byte
	{
		case AICB_PARAM_BUILD_NUMBER_LOW:
			PacketBytes[2] = VERSION_MINOR;

			break;
		case AICB_PARAM_BUILD_NUMBER_HIGH:
			PacketBytes[2] = VERSION_MAJOR;

			break;
		case AICB_PARAM_HARDWARE_VERSION:
			PacketBytes[2] = V2P_HW_VERSION;

			break;
		case AICB_PARAM_SW_MAJOR:
			PacketBytes[2] = V2P_SW_VERSION_MAJOR;

			break;
		case AICB_PARAM_SW_MINOR:
			PacketBytes[2] = ((eeprom_read_byte(&EEPROMVars.FirmVerMinor) == 0xFF)? V2P_SW_VERSION_MINOR_DEFAULT : eeprom_read_byte(&EEPROMVars.FirmVerMinor));

			break;
		case AICB_PARAM_CONTROLLER_INIT:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = Param_ControllerInit;
			}
			else
			{
				MessageSize = 2;
				Param_ControllerInit = PacketBytes[2];
			}
			
			break;
		case AICB_PARAM_SCK_DURATION:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.SCKDuration);
			}
			else
			{
				MessageSize = 2;
				eeprom_write_byte(&EEPROMVars.SCKDuration, PacketBytes[2]);
				USI_SPISetSpeed();          // Re-Initialise the USI system with the new frequency
			}
					
			break;
		case AICB_PARAM_RESET_POLARITY:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.ResetPolarity);		
			}
			else
			{
				MessageSize = 2;
				eeprom_write_byte(&EEPROMVars.ResetPolarity, PacketBytes[2]);
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Change takes effect immediatly
			}
			
			break;
		case AICB_PARAM_OSC_PSCALE:
		case AICB_PARAM_OSC_CMATCH:
			/* Despite not supporting these parameters (STK500 only), the AVR Studio programmer
			   sends them along with the SCK duration. A OK must be returned or the sequence will fail
			   and the SCK duration byte will not be sent.                                             */
		
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			  PacketBytes[2] = 0;             // If the command is a read, return a 0 for both parameters
			else
			  MessageSize = 2;                // Otherwise just send back an OK if the command is a set		
			
			break;
		default:                             // Unrecognised parameter
			MessageSize = 2;
			PacketBytes[1] = AICB_STATUS_CMD_FAILED;			
	}
	
	V2P_SendPacket();
}

void V2P_IncrementCurrAddress(void)
{
    1db6:	80 91 a9 02 	lds	r24, 0x02A9
    1dba:	90 91 aa 02 	lds	r25, 0x02AA
    1dbe:	a0 91 ab 02 	lds	r26, 0x02AB
    1dc2:	b0 91 ac 02 	lds	r27, 0x02AC
    1dc6:	01 96       	adiw	r24, 0x01	; 1
    1dc8:	a1 1d       	adc	r26, r1
    1dca:	b1 1d       	adc	r27, r1
    1dcc:	80 93 a9 02 	sts	0x02A9, r24
    1dd0:	90 93 aa 02 	sts	0x02AA, r25
    1dd4:	a0 93 ab 02 	sts	0x02AB, r26
    1dd8:	b0 93 ac 02 	sts	0x02AC, r27
    1ddc:	08 95       	ret

00001dde <V2P_CheckForExtendedAddress>:
	// Incrementing a 32-bit unsigned variable takes a lot of code. Because much of the code is
	// not very time critical (much of it is waiting for the hardware), I've chosen to waste
	// a few extra cycles per increment and save a good 60 bytes or so of code space by putting
	// the increment inside a function.

	CurrAddress++;
}

void V2P_CheckForExtendedAddress(void)
{
    1dde:	80 91 a9 02 	lds	r24, 0x02A9
    1de2:	90 91 aa 02 	lds	r25, 0x02AA
    1de6:	a0 91 ab 02 	lds	r26, 0x02AB
    1dea:	b0 91 ac 02 	lds	r27, 0x02AC
    1dee:	b7 ff       	sbrs	r27, 7
    1df0:	1e c0       	rjmp	.+60     	; 0x1e2e <V2P_CheckForExtendedAddress+0x50>
	if (CurrAddress & V2P_LOAD_EXTENDED_ADDR_FLAG)     // MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
	{
		USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);   // Load extended address command
    1df2:	8d e4       	ldi	r24, 0x4D	; 77
    1df4:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1df8:	80 e0       	ldi	r24, 0x00	; 0
    1dfa:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
		USI_SPITransmit((CurrAddress & V2P_LOAD_EXTENDED_ADDR_MASK) >> V2P_LOAD_EXTENDED_ADDR_SHIFT);
    1dfe:	80 91 ab 02 	lds	r24, 0x02AB
    1e02:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1e06:	80 e0       	ldi	r24, 0x00	; 0
    1e08:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
		
		CurrAddress &= ~(V2P_LOAD_EXTENDED_ADDR_FLAG); // Clear the flag
    1e0c:	80 91 a9 02 	lds	r24, 0x02A9
    1e10:	90 91 aa 02 	lds	r25, 0x02AA
    1e14:	a0 91 ab 02 	lds	r26, 0x02AB
    1e18:	b0 91 ac 02 	lds	r27, 0x02AC
    1e1c:	bf 77       	andi	r27, 0x7F	; 127
    1e1e:	80 93 a9 02 	sts	0x02A9, r24
    1e22:	90 93 aa 02 	sts	0x02AA, r25
    1e26:	a0 93 ab 02 	sts	0x02AB, r26
    1e2a:	b0 93 ac 02 	sts	0x02AC, r27
    1e2e:	08 95       	ret

00001e30 <V2P_SendPacket>:
    1e30:	0f 93       	push	r16
    1e32:	1f 93       	push	r17
    1e34:	cf 93       	push	r28
    1e36:	df 93       	push	r29
    1e38:	8b e1       	ldi	r24, 0x1B	; 27
    1e3a:	0e 94 85 09 	call	0x130a	; 0x130a <USART_Tx>
    1e3e:	80 91 a4 02 	lds	r24, 0x02A4
    1e42:	0e 94 85 09 	call	0x130a	; 0x130a <USART_Tx>
    1e46:	80 91 a7 02 	lds	r24, 0x02A7
    1e4a:	0e 94 85 09 	call	0x130a	; 0x130a <USART_Tx>
    1e4e:	80 91 a6 02 	lds	r24, 0x02A6
    1e52:	0e 94 85 09 	call	0x130a	; 0x130a <USART_Tx>
    1e56:	8e e0       	ldi	r24, 0x0E	; 14
    1e58:	0e 94 85 09 	call	0x130a	; 0x130a <USART_Tx>
    1e5c:	c0 e0       	ldi	r28, 0x00	; 0
    1e5e:	d0 e0       	ldi	r29, 0x00	; 0
    1e60:	01 e9       	ldi	r16, 0x91	; 145
    1e62:	11 e0       	ldi	r17, 0x01	; 1
    1e64:	06 c0       	rjmp	.+12     	; 0x1e72 <V2P_SendPacket+0x42>
    1e66:	f8 01       	movw	r30, r16
    1e68:	81 91       	ld	r24, Z+
    1e6a:	8f 01       	movw	r16, r30
    1e6c:	0e 94 85 09 	call	0x130a	; 0x130a <USART_Tx>
    1e70:	21 96       	adiw	r28, 0x01	; 1
    1e72:	80 91 a6 02 	lds	r24, 0x02A6
    1e76:	90 91 a7 02 	lds	r25, 0x02A7
    1e7a:	c8 17       	cp	r28, r24
    1e7c:	d9 07       	cpc	r29, r25
    1e7e:	98 f3       	brcs	.-26     	; 0x1e66 <V2P_SendPacket+0x36>
    1e80:	0e 94 be 0e 	call	0x1d7c	; 0x1d7c <V2P_GetChecksum>
    1e84:	0e 94 85 09 	call	0x130a	; 0x130a <USART_Tx>
    1e88:	80 91 a4 02 	lds	r24, 0x02A4
    1e8c:	90 91 a5 02 	lds	r25, 0x02A5
    1e90:	01 96       	adiw	r24, 0x01	; 1
    1e92:	90 93 a5 02 	sts	0x02A5, r25
    1e96:	80 93 a4 02 	sts	0x02A4, r24
    1e9a:	df 91       	pop	r29
    1e9c:	cf 91       	pop	r28
    1e9e:	1f 91       	pop	r17
    1ea0:	0f 91       	pop	r16
    1ea2:	08 95       	ret

00001ea4 <V2P_GetSetParamater>:
    1ea4:	20 91 92 01 	lds	r18, 0x0192
    1ea8:	83 e0       	ldi	r24, 0x03	; 3
    1eaa:	90 e0       	ldi	r25, 0x00	; 0
    1eac:	90 93 a7 02 	sts	0x02A7, r25
    1eb0:	80 93 a6 02 	sts	0x02A6, r24
    1eb4:	10 92 92 01 	sts	0x0192, r1
    1eb8:	22 39       	cpi	r18, 0x92	; 146
    1eba:	21 f1       	breq	.+72     	; 0x1f04 <V2P_GetSetParamater+0x60>
    1ebc:	23 39       	cpi	r18, 0x93	; 147
    1ebe:	70 f4       	brcc	.+28     	; 0x1edc <V2P_GetSetParamater+0x38>
    1ec0:	21 38       	cpi	r18, 0x81	; 129
    1ec2:	d1 f0       	breq	.+52     	; 0x1ef8 <V2P_GetSetParamater+0x54>
    1ec4:	22 38       	cpi	r18, 0x82	; 130
    1ec6:	20 f4       	brcc	.+8      	; 0x1ed0 <V2P_GetSetParamater+0x2c>
    1ec8:	20 38       	cpi	r18, 0x80	; 128
    1eca:	09 f0       	breq	.+2      	; 0x1ece <V2P_GetSetParamater+0x2a>
    1ecc:	74 c0       	rjmp	.+232    	; 0x1fb6 <V2P_GetSetParamater+0x112>
    1ece:	22 c0       	rjmp	.+68     	; 0x1f14 <V2P_GetSetParamater+0x70>
    1ed0:	20 39       	cpi	r18, 0x90	; 144
    1ed2:	b1 f0       	breq	.+44     	; 0x1f00 <V2P_GetSetParamater+0x5c>
    1ed4:	21 39       	cpi	r18, 0x91	; 145
    1ed6:	09 f0       	breq	.+2      	; 0x1eda <V2P_GetSetParamater+0x36>
    1ed8:	6e c0       	rjmp	.+220    	; 0x1fb6 <V2P_GetSetParamater+0x112>
    1eda:	12 c0       	rjmp	.+36     	; 0x1f00 <V2P_GetSetParamater+0x5c>
    1edc:	28 39       	cpi	r18, 0x98	; 152
    1ede:	81 f1       	breq	.+96     	; 0x1f40 <V2P_GetSetParamater+0x9c>
    1ee0:	29 39       	cpi	r18, 0x99	; 153
    1ee2:	20 f4       	brcc	.+8      	; 0x1eec <V2P_GetSetParamater+0x48>
    1ee4:	26 39       	cpi	r18, 0x96	; 150
    1ee6:	08 f4       	brcc	.+2      	; 0x1eea <V2P_GetSetParamater+0x46>
    1ee8:	66 c0       	rjmp	.+204    	; 0x1fb6 <V2P_GetSetParamater+0x112>
    1eea:	57 c0       	rjmp	.+174    	; 0x1f9a <V2P_GetSetParamater+0xf6>
    1eec:	2e 39       	cpi	r18, 0x9E	; 158
    1eee:	e1 f1       	breq	.+120    	; 0x1f68 <V2P_GetSetParamater+0xc4>
    1ef0:	2f 39       	cpi	r18, 0x9F	; 159
    1ef2:	09 f0       	breq	.+2      	; 0x1ef6 <V2P_GetSetParamater+0x52>
    1ef4:	60 c0       	rjmp	.+192    	; 0x1fb6 <V2P_GetSetParamater+0x112>
    1ef6:	12 c0       	rjmp	.+36     	; 0x1f1c <V2P_GetSetParamater+0x78>
    1ef8:	81 e0       	ldi	r24, 0x01	; 1
    1efa:	80 93 93 01 	sts	0x0193, r24
    1efe:	64 c0       	rjmp	.+200    	; 0x1fc8 <V2P_GetSetParamater+0x124>
    1f00:	82 e0       	ldi	r24, 0x02	; 2
    1f02:	fb cf       	rjmp	.-10     	; 0x1efa <V2P_GetSetParamater+0x56>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1f04:	2a e8       	ldi	r18, 0x8A	; 138
    1f06:	30 e0       	ldi	r19, 0x00	; 0
    1f08:	d9 01       	movw	r26, r18
    1f0a:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
    1f0e:	80 2d       	mov	r24, r0
    1f10:	8f 3f       	cpi	r24, 0xFF	; 255
    1f12:	11 f4       	brne	.+4      	; 0x1f18 <V2P_GetSetParamater+0x74>
    1f14:	84 e0       	ldi	r24, 0x04	; 4
    1f16:	f1 cf       	rjmp	.-30     	; 0x1efa <V2P_GetSetParamater+0x56>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1f18:	d9 01       	movw	r26, r18
    1f1a:	2c c0       	rjmp	.+88     	; 0x1f74 <V2P_GetSetParamater+0xd0>
    1f1c:	80 91 91 01 	lds	r24, 0x0191
    1f20:	83 30       	cpi	r24, 0x03	; 3
    1f22:	19 f4       	brne	.+6      	; 0x1f2a <V2P_GetSetParamater+0x86>
    1f24:	80 91 ad 02 	lds	r24, 0x02AD
    1f28:	e8 cf       	rjmp	.-48     	; 0x1efa <V2P_GetSetParamater+0x56>
    1f2a:	82 e0       	ldi	r24, 0x02	; 2
    1f2c:	90 e0       	ldi	r25, 0x00	; 0
    1f2e:	90 93 a7 02 	sts	0x02A7, r25
    1f32:	80 93 a6 02 	sts	0x02A6, r24
    1f36:	80 91 93 01 	lds	r24, 0x0193
    1f3a:	80 93 ad 02 	sts	0x02AD, r24
    1f3e:	44 c0       	rjmp	.+136    	; 0x1fc8 <V2P_GetSetParamater+0x124>
    1f40:	80 91 91 01 	lds	r24, 0x0191
    1f44:	a2 e0       	ldi	r26, 0x02	; 2
    1f46:	b0 e0       	ldi	r27, 0x00	; 0
    1f48:	83 30       	cpi	r24, 0x03	; 3
    1f4a:	a1 f0       	breq	.+40     	; 0x1f74 <V2P_GetSetParamater+0xd0>
    1f4c:	82 e0       	ldi	r24, 0x02	; 2
    1f4e:	90 e0       	ldi	r25, 0x00	; 0
    1f50:	90 93 a7 02 	sts	0x02A7, r25
    1f54:	80 93 a6 02 	sts	0x02A6, r24

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    1f58:	80 91 93 01 	lds	r24, 0x0193
    1f5c:	08 2e       	mov	r0, r24
    1f5e:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
    1f62:	0e 94 12 0a 	call	0x1424	; 0x1424 <USI_SPISetSpeed>
    1f66:	30 c0       	rjmp	.+96     	; 0x1fc8 <V2P_GetSetParamater+0x124>
    1f68:	80 91 91 01 	lds	r24, 0x0191
    1f6c:	a1 e0       	ldi	r26, 0x01	; 1
    1f6e:	b0 e0       	ldi	r27, 0x00	; 0
    1f70:	83 30       	cpi	r24, 0x03	; 3
    1f72:	21 f4       	brne	.+8      	; 0x1f7c <V2P_GetSetParamater+0xd8>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1f74:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
    1f78:	80 2d       	mov	r24, r0
    1f7a:	bf cf       	rjmp	.-130    	; 0x1efa <V2P_GetSetParamater+0x56>
    1f7c:	82 e0       	ldi	r24, 0x02	; 2
    1f7e:	90 e0       	ldi	r25, 0x00	; 0
    1f80:	90 93 a7 02 	sts	0x02A7, r25
    1f84:	80 93 a6 02 	sts	0x02A6, r24

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    1f88:	80 91 93 01 	lds	r24, 0x0193
    1f8c:	08 2e       	mov	r0, r24
    1f8e:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
    1f92:	81 e0       	ldi	r24, 0x01	; 1
    1f94:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
    1f98:	17 c0       	rjmp	.+46     	; 0x1fc8 <V2P_GetSetParamater+0x124>
    1f9a:	80 91 91 01 	lds	r24, 0x0191
    1f9e:	83 30       	cpi	r24, 0x03	; 3
    1fa0:	19 f4       	brne	.+6      	; 0x1fa8 <V2P_GetSetParamater+0x104>
    1fa2:	10 92 93 01 	sts	0x0193, r1
    1fa6:	10 c0       	rjmp	.+32     	; 0x1fc8 <V2P_GetSetParamater+0x124>
    1fa8:	82 e0       	ldi	r24, 0x02	; 2
    1faa:	90 e0       	ldi	r25, 0x00	; 0
    1fac:	90 93 a7 02 	sts	0x02A7, r25
    1fb0:	80 93 a6 02 	sts	0x02A6, r24
    1fb4:	09 c0       	rjmp	.+18     	; 0x1fc8 <V2P_GetSetParamater+0x124>
    1fb6:	82 e0       	ldi	r24, 0x02	; 2
    1fb8:	90 e0       	ldi	r25, 0x00	; 0
    1fba:	90 93 a7 02 	sts	0x02A7, r25
    1fbe:	80 93 a6 02 	sts	0x02A6, r24
    1fc2:	80 ec       	ldi	r24, 0xC0	; 192
    1fc4:	80 93 92 01 	sts	0x0192, r24
    1fc8:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <V2P_SendPacket>
    1fcc:	08 95       	ret

00001fce <V2P_RunStateMachine>:
    1fce:	cf 92       	push	r12
    1fd0:	df 92       	push	r13
    1fd2:	ef 92       	push	r14
    1fd4:	ff 92       	push	r15
    1fd6:	0f 93       	push	r16
    1fd8:	1f 93       	push	r17
    1fda:	cf 93       	push	r28
    1fdc:	df 93       	push	r29
    1fde:	6c 01       	movw	r12, r24
    1fe0:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <BUFF_InitialiseBuffer>
    1fe4:	10 92 81 00 	sts	0x0081, r1
    1fe8:	10 92 a8 02 	sts	0x02A8, r1
    1fec:	10 92 a9 02 	sts	0x02A9, r1
    1ff0:	10 92 aa 02 	sts	0x02AA, r1
    1ff4:	10 92 ab 02 	sts	0x02AB, r1
    1ff8:	10 92 ac 02 	sts	0x02AC, r1
    1ffc:	10 e0       	ldi	r17, 0x00	; 0
    1ffe:	73 c0       	rjmp	.+230    	; 0x20e6 <V2P_RunStateMachine+0x118>
    2000:	12 e0       	ldi	r17, 0x02	; 2
    2002:	01 c0       	rjmp	.+2      	; 0x2006 <V2P_RunStateMachine+0x38>
    2004:	19 e0       	ldi	r17, 0x09	; 9
    2006:	80 91 8c 01 	lds	r24, 0x018C
    200a:	81 30       	cpi	r24, 0x01	; 1
    200c:	09 f4       	brne	.+2      	; 0x2010 <V2P_RunStateMachine+0x42>
    200e:	0e c1       	rjmp	.+540    	; 0x222c <V2P_RunStateMachine+0x25e>
    2010:	11 23       	and	r17, r17
    2012:	81 f1       	breq	.+96     	; 0x2074 <V2P_RunStateMachine+0xa6>
    2014:	10 92 8c 01 	sts	0x018C, r1
    2018:	10 92 8b 01 	sts	0x018B, r1
    201c:	10 92 b2 00 	sts	0x00B2, r1
    2020:	80 ef       	ldi	r24, 0xF0	; 240
    2022:	80 93 b3 00 	sts	0x00B3, r24
    2026:	82 e0       	ldi	r24, 0x02	; 2
    2028:	80 93 70 00 	sts	0x0070, r24
    202c:	8f e0       	ldi	r24, 0x0F	; 15
    202e:	80 93 b0 00 	sts	0x00B0, r24
    2032:	15 30       	cpi	r17, 0x05	; 5
    2034:	09 f4       	brne	.+2      	; 0x2038 <V2P_RunStateMachine+0x6a>
    2036:	5a c0       	rjmp	.+180    	; 0x20ec <V2P_RunStateMachine+0x11e>
    2038:	16 30       	cpi	r17, 0x06	; 6
    203a:	70 f4       	brcc	.+28     	; 0x2058 <V2P_RunStateMachine+0x8a>
    203c:	12 30       	cpi	r17, 0x02	; 2
    203e:	69 f1       	breq	.+90     	; 0x209a <V2P_RunStateMachine+0xcc>
    2040:	13 30       	cpi	r17, 0x03	; 3
    2042:	28 f4       	brcc	.+10     	; 0x204e <V2P_RunStateMachine+0x80>
    2044:	11 23       	and	r17, r17
    2046:	b1 f0       	breq	.+44     	; 0x2074 <V2P_RunStateMachine+0xa6>
    2048:	11 30       	cpi	r17, 0x01	; 1
    204a:	e9 f6       	brne	.-70     	; 0x2006 <V2P_RunStateMachine+0x38>
    204c:	20 c0       	rjmp	.+64     	; 0x208e <V2P_RunStateMachine+0xc0>
    204e:	13 30       	cpi	r17, 0x03	; 3
    2050:	69 f1       	breq	.+90     	; 0x20ac <V2P_RunStateMachine+0xde>
    2052:	14 30       	cpi	r17, 0x04	; 4
    2054:	c1 f6       	brne	.-80     	; 0x2006 <V2P_RunStateMachine+0x38>
    2056:	35 c0       	rjmp	.+106    	; 0x20c2 <V2P_RunStateMachine+0xf4>
    2058:	18 30       	cpi	r17, 0x08	; 8
    205a:	09 f4       	brne	.+2      	; 0x205e <V2P_RunStateMachine+0x90>
    205c:	f4 c0       	rjmp	.+488    	; 0x2246 <V2P_RunStateMachine+0x278>
    205e:	19 30       	cpi	r17, 0x09	; 9
    2060:	30 f4       	brcc	.+12     	; 0x206e <V2P_RunStateMachine+0xa0>
    2062:	16 30       	cpi	r17, 0x06	; 6
    2064:	09 f4       	brne	.+2      	; 0x2068 <V2P_RunStateMachine+0x9a>
    2066:	49 c0       	rjmp	.+146    	; 0x20fa <V2P_RunStateMachine+0x12c>
    2068:	17 30       	cpi	r17, 0x07	; 7
    206a:	69 f6       	brne	.-102    	; 0x2006 <V2P_RunStateMachine+0x38>
    206c:	57 c0       	rjmp	.+174    	; 0x211c <V2P_RunStateMachine+0x14e>
    206e:	1c 30       	cpi	r17, 0x0C	; 12
    2070:	50 f6       	brcc	.-108    	; 0x2006 <V2P_RunStateMachine+0x38>
    2072:	d6 c0       	rjmp	.+428    	; 0x2220 <V2P_RunStateMachine+0x252>
    2074:	80 91 88 01 	lds	r24, 0x0188
    2078:	81 11       	cpse	r24, r1
    207a:	81 e0       	ldi	r24, 0x01	; 1
    207c:	18 2f       	mov	r17, r24
    207e:	f2 9b       	sbis	0x1e, 2	; 30
    2080:	c2 cf       	rjmp	.-124    	; 0x2006 <V2P_RunStateMachine+0x38>
    2082:	80 91 a8 02 	lds	r24, 0x02A8
    2086:	88 23       	and	r24, r24
    2088:	09 f0       	breq	.+2      	; 0x208c <V2P_RunStateMachine+0xbe>
    208a:	bd cf       	rjmp	.-134    	; 0x2006 <V2P_RunStateMachine+0x38>
    208c:	e6 c0       	rjmp	.+460    	; 0x225a <V2P_RunStateMachine+0x28c>
    208e:	0e 94 8d 09 	call	0x131a	; 0x131a <USART_Rx>
    2092:	8b 31       	cpi	r24, 0x1B	; 27
    2094:	09 f0       	breq	.+2      	; 0x2098 <V2P_RunStateMachine+0xca>
    2096:	b6 cf       	rjmp	.-148    	; 0x2004 <V2P_RunStateMachine+0x36>
    2098:	b3 cf       	rjmp	.-154    	; 0x2000 <V2P_RunStateMachine+0x32>
    209a:	0e 94 8d 09 	call	0x131a	; 0x131a <USART_Rx>
    209e:	99 27       	eor	r25, r25
    20a0:	90 93 a5 02 	sts	0x02A5, r25
    20a4:	80 93 a4 02 	sts	0x02A4, r24
    20a8:	13 e0       	ldi	r17, 0x03	; 3
    20aa:	ad cf       	rjmp	.-166    	; 0x2006 <V2P_RunStateMachine+0x38>
    20ac:	0e 94 8d 09 	call	0x131a	; 0x131a <USART_Rx>
    20b0:	99 27       	eor	r25, r25
    20b2:	98 2f       	mov	r25, r24
    20b4:	88 27       	eor	r24, r24
    20b6:	90 93 a7 02 	sts	0x02A7, r25
    20ba:	80 93 a6 02 	sts	0x02A6, r24
    20be:	14 e0       	ldi	r17, 0x04	; 4
    20c0:	a2 cf       	rjmp	.-188    	; 0x2006 <V2P_RunStateMachine+0x38>
    20c2:	00 91 a6 02 	lds	r16, 0x02A6
    20c6:	10 91 a7 02 	lds	r17, 0x02A7
    20ca:	0e 94 8d 09 	call	0x131a	; 0x131a <USART_Rx>
    20ce:	99 27       	eor	r25, r25
    20d0:	80 2b       	or	r24, r16
    20d2:	91 2b       	or	r25, r17
    20d4:	90 93 a7 02 	sts	0x02A7, r25
    20d8:	80 93 a6 02 	sts	0x02A6, r24
    20dc:	83 51       	subi	r24, 0x13	; 19
    20de:	91 40       	sbci	r25, 0x01	; 1
    20e0:	08 f0       	brcs	.+2      	; 0x20e4 <V2P_RunStateMachine+0x116>
    20e2:	90 cf       	rjmp	.-224    	; 0x2004 <V2P_RunStateMachine+0x36>
    20e4:	15 e0       	ldi	r17, 0x05	; 5
    20e6:	c0 e0       	ldi	r28, 0x00	; 0
    20e8:	d0 e0       	ldi	r29, 0x00	; 0
    20ea:	8d cf       	rjmp	.-230    	; 0x2006 <V2P_RunStateMachine+0x38>
    20ec:	0e 94 8d 09 	call	0x131a	; 0x131a <USART_Rx>
    20f0:	8e 30       	cpi	r24, 0x0E	; 14
    20f2:	09 f0       	breq	.+2      	; 0x20f6 <V2P_RunStateMachine+0x128>
    20f4:	87 cf       	rjmp	.-242    	; 0x2004 <V2P_RunStateMachine+0x36>
    20f6:	16 e0       	ldi	r17, 0x06	; 6
    20f8:	86 cf       	rjmp	.-244    	; 0x2006 <V2P_RunStateMachine+0x38>
    20fa:	80 91 a6 02 	lds	r24, 0x02A6
    20fe:	90 91 a7 02 	lds	r25, 0x02A7
    2102:	c8 17       	cp	r28, r24
    2104:	d9 07       	cpc	r29, r25
    2106:	11 f4       	brne	.+4      	; 0x210c <V2P_RunStateMachine+0x13e>
    2108:	17 e0       	ldi	r17, 0x07	; 7
    210a:	7d cf       	rjmp	.-262    	; 0x2006 <V2P_RunStateMachine+0x38>
    210c:	0e 94 8d 09 	call	0x131a	; 0x131a <USART_Rx>
    2110:	fe 01       	movw	r30, r28
    2112:	ef 56       	subi	r30, 0x6F	; 111
    2114:	fe 4f       	sbci	r31, 0xFE	; 254
    2116:	80 83       	st	Z, r24
    2118:	21 96       	adiw	r28, 0x01	; 1
    211a:	75 cf       	rjmp	.-278    	; 0x2006 <V2P_RunStateMachine+0x38>
    211c:	80 91 8c 01 	lds	r24, 0x018C
    2120:	88 23       	and	r24, r24
    2122:	09 f0       	breq	.+2      	; 0x2126 <V2P_RunStateMachine+0x158>
    2124:	70 cf       	rjmp	.-288    	; 0x2006 <V2P_RunStateMachine+0x38>
    2126:	0e 94 be 0e 	call	0x1d7c	; 0x1d7c <V2P_GetChecksum>
    212a:	18 2f       	mov	r17, r24
    212c:	0e 94 8d 09 	call	0x131a	; 0x131a <USART_Rx>
    2130:	18 17       	cp	r17, r24
    2132:	11 f0       	breq	.+4      	; 0x2138 <V2P_RunStateMachine+0x16a>
    2134:	1b e0       	ldi	r17, 0x0B	; 11
    2136:	67 cf       	rjmp	.-306    	; 0x2006 <V2P_RunStateMachine+0x38>
    2138:	80 91 91 01 	lds	r24, 0x0191
    213c:	84 30       	cpi	r24, 0x04	; 4
    213e:	38 f4       	brcc	.+14     	; 0x214e <V2P_RunStateMachine+0x180>
    2140:	82 30       	cpi	r24, 0x02	; 2
    2142:	08 f0       	brcs	.+2      	; 0x2146 <V2P_RunStateMachine+0x178>
    2144:	66 c0       	rjmp	.+204    	; 0x2212 <V2P_RunStateMachine+0x244>
    2146:	81 30       	cpi	r24, 0x01	; 1
    2148:	09 f0       	breq	.+2      	; 0x214c <V2P_RunStateMachine+0x17e>
    214a:	66 c0       	rjmp	.+204    	; 0x2218 <V2P_RunStateMachine+0x24a>
    214c:	06 c0       	rjmp	.+12     	; 0x215a <V2P_RunStateMachine+0x18c>
    214e:	86 30       	cpi	r24, 0x06	; 6
    2150:	01 f1       	breq	.+64     	; 0x2192 <V2P_RunStateMachine+0x1c4>
    2152:	87 30       	cpi	r24, 0x07	; 7
    2154:	09 f0       	breq	.+2      	; 0x2158 <V2P_RunStateMachine+0x18a>
    2156:	60 c0       	rjmp	.+192    	; 0x2218 <V2P_RunStateMachine+0x24a>
    2158:	12 c0       	rjmp	.+36     	; 0x217e <V2P_RunStateMachine+0x1b0>
    215a:	8b e0       	ldi	r24, 0x0B	; 11
    215c:	90 e0       	ldi	r25, 0x00	; 0
    215e:	90 93 a7 02 	sts	0x02A7, r25
    2162:	80 93 a6 02 	sts	0x02A6, r24
    2166:	ea e0       	ldi	r30, 0x0A	; 10
    2168:	f4 e0       	ldi	r31, 0x04	; 4
    216a:	a1 e9       	ldi	r26, 0x91	; 145
    216c:	b1 e0       	ldi	r27, 0x01	; 1
    216e:	84 91       	lpm	r24, Z
    2170:	8d 93       	st	X+, r24
    2172:	31 96       	adiw	r30, 0x01	; 1
    2174:	81 e0       	ldi	r24, 0x01	; 1
    2176:	ac 39       	cpi	r26, 0x9C	; 156
    2178:	b8 07       	cpc	r27, r24
    217a:	c9 f7       	brne	.-14     	; 0x216e <V2P_RunStateMachine+0x1a0>
    217c:	47 c0       	rjmp	.+142    	; 0x220c <V2P_RunStateMachine+0x23e>
    217e:	82 e0       	ldi	r24, 0x02	; 2
    2180:	90 e0       	ldi	r25, 0x00	; 0
    2182:	90 93 a7 02 	sts	0x02A7, r25
    2186:	80 93 a6 02 	sts	0x02A6, r24
    218a:	80 ec       	ldi	r24, 0xC0	; 192
    218c:	80 93 92 01 	sts	0x0192, r24
    2190:	3d c0       	rjmp	.+122    	; 0x220c <V2P_RunStateMachine+0x23e>
    2192:	82 e0       	ldi	r24, 0x02	; 2
    2194:	90 e0       	ldi	r25, 0x00	; 0
    2196:	90 93 a7 02 	sts	0x02A7, r25
    219a:	80 93 a6 02 	sts	0x02A6, r24
    219e:	0e 94 ef 0e 	call	0x1dde	; 0x1dde <V2P_CheckForExtendedAddress>
    21a2:	e0 90 94 01 	lds	r14, 0x0194
    21a6:	ff 24       	eor	r15, r15
    21a8:	00 27       	eor	r16, r16
    21aa:	11 27       	eor	r17, r17
    21ac:	10 2f       	mov	r17, r16
    21ae:	0f 2d       	mov	r16, r15
    21b0:	fe 2c       	mov	r15, r14
    21b2:	ee 24       	eor	r14, r14
    21b4:	20 91 92 01 	lds	r18, 0x0192
    21b8:	33 27       	eor	r19, r19
    21ba:	44 27       	eor	r20, r20
    21bc:	55 27       	eor	r21, r21
    21be:	52 2f       	mov	r21, r18
    21c0:	44 27       	eor	r20, r20
    21c2:	33 27       	eor	r19, r19
    21c4:	22 27       	eor	r18, r18
    21c6:	80 91 93 01 	lds	r24, 0x0193
    21ca:	99 27       	eor	r25, r25
    21cc:	aa 27       	eor	r26, r26
    21ce:	bb 27       	eor	r27, r27
    21d0:	dc 01       	movw	r26, r24
    21d2:	99 27       	eor	r25, r25
    21d4:	88 27       	eor	r24, r24
    21d6:	28 2b       	or	r18, r24
    21d8:	39 2b       	or	r19, r25
    21da:	4a 2b       	or	r20, r26
    21dc:	5b 2b       	or	r21, r27
    21de:	80 91 95 01 	lds	r24, 0x0195
    21e2:	99 27       	eor	r25, r25
    21e4:	aa 27       	eor	r26, r26
    21e6:	bb 27       	eor	r27, r27
    21e8:	28 2b       	or	r18, r24
    21ea:	39 2b       	or	r19, r25
    21ec:	4a 2b       	or	r20, r26
    21ee:	5b 2b       	or	r21, r27
    21f0:	e2 2a       	or	r14, r18
    21f2:	f3 2a       	or	r15, r19
    21f4:	04 2b       	or	r16, r20
    21f6:	15 2b       	or	r17, r21
    21f8:	e0 92 a9 02 	sts	0x02A9, r14
    21fc:	f0 92 aa 02 	sts	0x02AA, r15
    2200:	00 93 ab 02 	sts	0x02AB, r16
    2204:	10 93 ac 02 	sts	0x02AC, r17
    2208:	10 92 92 01 	sts	0x0192, r1
    220c:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <V2P_SendPacket>
    2210:	05 c0       	rjmp	.+10     	; 0x221c <V2P_RunStateMachine+0x24e>
    2212:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <V2P_GetSetParamater>
    2216:	02 c0       	rjmp	.+4      	; 0x221c <V2P_RunStateMachine+0x24e>
    2218:	f6 01       	movw	r30, r12
    221a:	09 95       	icall
    221c:	18 e0       	ldi	r17, 0x08	; 8
    221e:	f3 ce       	rjmp	.-538    	; 0x2006 <V2P_RunStateMachine+0x38>
    2220:	1b 30       	cpi	r17, 0x0B	; 11
    2222:	11 f4       	brne	.+4      	; 0x2228 <V2P_RunStateMachine+0x25a>
    2224:	81 ec       	ldi	r24, 0xC1	; 193
    2226:	05 c0       	rjmp	.+10     	; 0x2232 <V2P_RunStateMachine+0x264>
    2228:	1a 30       	cpi	r17, 0x0A	; 10
    222a:	11 f4       	brne	.+4      	; 0x2230 <V2P_RunStateMachine+0x262>
    222c:	80 e8       	ldi	r24, 0x80	; 128
    222e:	01 c0       	rjmp	.+2      	; 0x2232 <V2P_RunStateMachine+0x264>
    2230:	80 ec       	ldi	r24, 0xC0	; 192
    2232:	80 93 92 01 	sts	0x0192, r24
    2236:	82 e0       	ldi	r24, 0x02	; 2
    2238:	90 e0       	ldi	r25, 0x00	; 0
    223a:	90 93 a7 02 	sts	0x02A7, r25
    223e:	80 93 a6 02 	sts	0x02A6, r24
    2242:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <V2P_SendPacket>
    2246:	10 92 8c 01 	sts	0x018C, r1
    224a:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <BUFF_InitialiseBuffer>
    224e:	10 92 b0 00 	sts	0x00B0, r1
    2252:	10 92 70 00 	sts	0x0070, r1
    2256:	10 e0       	ldi	r17, 0x00	; 0
    2258:	d6 ce       	rjmp	.-596    	; 0x2006 <V2P_RunStateMachine+0x38>
    225a:	80 e8       	ldi	r24, 0x80	; 128
    225c:	80 93 61 00 	sts	0x0061, r24
    2260:	83 e0       	ldi	r24, 0x03	; 3
    2262:	80 93 61 00 	sts	0x0061, r24
    2266:	10 92 c1 00 	sts	0x00C1, r1
    226a:	0e 94 43 0c 	call	0x1886	; 0x1886 <TOUT_SetupSleepTimer>
    226e:	df 91       	pop	r29
    2270:	cf 91       	pop	r28
    2272:	1f 91       	pop	r17
    2274:	0f 91       	pop	r16
    2276:	ff 90       	pop	r15
    2278:	ef 90       	pop	r14
    227a:	df 90       	pop	r13
    227c:	cf 90       	pop	r12
    227e:	08 95       	ret

00002280 <ISPCC_PollForProgComplete>:
	}
}

void ISPCC_PollForProgComplete(const uint8_t PollData, uint16_t PollAddr)
{
    2280:	1f 93       	push	r17
    2282:	cf 93       	push	r28
    2284:	df 93       	push	r29
    2286:	eb 01       	movw	r28, r22
	uint8_t PollType;
	uint8_t ProgCommand;

	if (PollData & ISPCC_PROG_MODE_PAGE)
    2288:	99 27       	eor	r25, r25
    228a:	80 ff       	sbrs	r24, 0
    228c:	08 c0       	rjmp	.+16     	; 0x229e <ISPCC_PollForProgComplete+0x1e>
	   PollType = ((PollData & ISPCC_PAGE_POLLTYPE_MASK) >> ISPCC_PAGE_POLLTYPE_MASKSHIFT);
    228e:	80 77       	andi	r24, 0x70	; 112
    2290:	90 70       	andi	r25, 0x00	; 0
    2292:	34 e0       	ldi	r19, 0x04	; 4
    2294:	95 95       	asr	r25
    2296:	87 95       	ror	r24
    2298:	3a 95       	dec	r19
    229a:	e1 f7       	brne	.-8      	; 0x2294 <ISPCC_PollForProgComplete+0x14>
    229c:	04 c0       	rjmp	.+8      	; 0x22a6 <ISPCC_PollForProgComplete+0x26>
	else
	   PollType = ((PollData & ISPCC_WORD_POLLTYPE_MASK) >> ISPCC_WORD_POLLTYPE_MASKSHIFT);	
    229e:	8e 70       	andi	r24, 0x0E	; 14
    22a0:	90 70       	andi	r25, 0x00	; 0
    22a2:	95 95       	asr	r25
    22a4:	87 95       	ror	r24

	switch (PollType & ISPCC_POLLTYPE_MASK)
    22a6:	99 27       	eor	r25, r25
    22a8:	87 70       	andi	r24, 0x07	; 7
    22aa:	90 70       	andi	r25, 0x00	; 0
    22ac:	82 30       	cpi	r24, 0x02	; 2
    22ae:	91 05       	cpc	r25, r1
    22b0:	19 f0       	breq	.+6      	; 0x22b8 <ISPCC_PollForProgComplete+0x38>
    22b2:	04 97       	sbiw	r24, 0x04	; 4
    22b4:	41 f5       	brne	.+80     	; 0x2306 <ISPCC_PollForProgComplete+0x86>
    22b6:	1c c0       	rjmp	.+56     	; 0x22f0 <ISPCC_PollForProgComplete+0x70>
	{
		case ISPCC_POLLTYPE_DATA:
			ProgCommand = PacketBytes[7];
    22b8:	10 91 98 01 	lds	r17, 0x0198
			
			if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP) // Flash uses word addresses
    22bc:	80 91 91 01 	lds	r24, 0x0191
    22c0:	83 31       	cpi	r24, 0x13	; 19
    22c2:	41 f4       	brne	.+16     	; 0x22d4 <ISPCC_PollForProgComplete+0x54>
			{
				ProgCommand  |= ((PollAddr & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ);
    22c4:	c0 ff       	sbrs	r28, 0
    22c6:	02 c0       	rjmp	.+4      	; 0x22cc <ISPCC_PollForProgComplete+0x4c>
    22c8:	88 e0       	ldi	r24, 0x08	; 8
    22ca:	01 c0       	rjmp	.+2      	; 0x22ce <ISPCC_PollForProgComplete+0x4e>
    22cc:	80 e0       	ldi	r24, 0x00	; 0
    22ce:	18 2b       	or	r17, r24
				PollAddr    >>= 1;
    22d0:	d6 95       	lsr	r29
    22d2:	c7 95       	ror	r28
			}

			do
			{
				USI_SPITransmit(ProgCommand);
    22d4:	81 2f       	mov	r24, r17
    22d6:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
				USI_SPITransmitWord(PollAddr);
    22da:	ce 01       	movw	r24, r28
    22dc:	0e 94 04 0a 	call	0x1408	; 0x1408 <USI_SPITransmitWord>
			}
			while (USI_SPITransmit(0x00) == PacketBytes[8]);
    22e0:	80 e0       	ldi	r24, 0x00	; 0
    22e2:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    22e6:	90 91 99 01 	lds	r25, 0x0199
    22ea:	89 17       	cp	r24, r25
    22ec:	81 f4       	brne	.+32     	; 0x230e <ISPCC_PollForProgComplete+0x8e>
    22ee:	f2 cf       	rjmp	.-28     	; 0x22d4 <ISPCC_PollForProgComplete+0x54>
						
			break;
		case ISPCC_POLLTYPE_READY:
			do
			   USI_SPITransmitWord(0xF000);
    22f0:	80 e0       	ldi	r24, 0x00	; 0
    22f2:	90 ef       	ldi	r25, 0xF0	; 240
    22f4:	0e 94 04 0a 	call	0x1408	; 0x1408 <USI_SPITransmitWord>
			while (USI_SPITransmitWord(0x0000) & ISPCC_POLL_BUSYFLAG);
    22f8:	80 e0       	ldi	r24, 0x00	; 0
    22fa:	90 e0       	ldi	r25, 0x00	; 0
    22fc:	0e 94 04 0a 	call	0x1408	; 0x1408 <USI_SPITransmitWord>
    2300:	80 ff       	sbrs	r24, 0
    2302:	05 c0       	rjmp	.+10     	; 0x230e <ISPCC_PollForProgComplete+0x8e>
    2304:	f5 cf       	rjmp	.-22     	; 0x22f0 <ISPCC_PollForProgComplete+0x70>

			break;
		default:                                      // Default is Wait polling
			MAIN_Delay1MS(PacketBytes[4]);	
    2306:	80 91 95 01 	lds	r24, 0x0195
    230a:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    230e:	df 91       	pop	r29
    2310:	cf 91       	pop	r28
    2312:	1f 91       	pop	r17
    2314:	08 95       	ret

00002316 <ISPCC_ProgramChip>:
    2316:	4f 92       	push	r4
    2318:	5f 92       	push	r5
    231a:	6f 92       	push	r6
    231c:	7f 92       	push	r7
    231e:	8f 92       	push	r8
    2320:	9f 92       	push	r9
    2322:	af 92       	push	r10
    2324:	bf 92       	push	r11
    2326:	cf 92       	push	r12
    2328:	df 92       	push	r13
    232a:	ef 92       	push	r14
    232c:	ff 92       	push	r15
    232e:	0f 93       	push	r16
    2330:	1f 93       	push	r17
    2332:	cf 93       	push	r28
    2334:	df 93       	push	r29
    2336:	b0 90 94 01 	lds	r11, 0x0194
    233a:	a0 90 96 01 	lds	r10, 0x0196
    233e:	40 90 a9 02 	lds	r4, 0x02A9
    2342:	50 90 aa 02 	lds	r5, 0x02AA
    2346:	60 90 ab 02 	lds	r6, 0x02AB
    234a:	70 90 ac 02 	lds	r7, 0x02AC
    234e:	80 91 92 01 	lds	r24, 0x0192
    2352:	99 27       	eor	r25, r25
    2354:	98 2e       	mov	r9, r24
    2356:	88 24       	eor	r8, r8
    2358:	80 91 93 01 	lds	r24, 0x0193
    235c:	99 27       	eor	r25, r25
    235e:	88 2a       	or	r8, r24
    2360:	99 2a       	or	r9, r25
    2362:	e0 90 91 01 	lds	r14, 0x0191
    2366:	b0 fc       	sbrc	r11, 0
    2368:	09 c0       	rjmp	.+18     	; 0x237c <ISPCC_ProgramChip+0x66>
    236a:	c0 e0       	ldi	r28, 0x00	; 0
    236c:	d0 e0       	ldi	r29, 0x00	; 0
    236e:	cc 24       	eor	r12, r12
    2370:	dd 24       	eor	r13, r13
    2372:	7b e9       	ldi	r23, 0x9B	; 155
    2374:	67 2e       	mov	r6, r23
    2376:	71 e0       	ldi	r23, 0x01	; 1
    2378:	77 2e       	mov	r7, r23
    237a:	ac c0       	rjmp	.+344    	; 0x24d4 <ISPCC_ProgramChip+0x1be>
    237c:	c0 e0       	ldi	r28, 0x00	; 0
    237e:	d0 e0       	ldi	r29, 0x00	; 0
    2380:	00 e0       	ldi	r16, 0x00	; 0
    2382:	10 e0       	ldi	r17, 0x00	; 0
    2384:	6b e9       	ldi	r22, 0x9B	; 155
    2386:	c6 2e       	mov	r12, r22
    2388:	61 e0       	ldi	r22, 0x01	; 1
    238a:	d6 2e       	mov	r13, r22
    238c:	41 c0       	rjmp	.+130    	; 0x2410 <ISPCC_ProgramChip+0xfa>
    238e:	f6 01       	movw	r30, r12
    2390:	f0 80       	ld	r15, Z
    2392:	f3 e1       	ldi	r31, 0x13	; 19
    2394:	ef 16       	cp	r14, r31
    2396:	39 f4       	brne	.+14     	; 0x23a6 <ISPCC_ProgramChip+0x90>
    2398:	00 ff       	sbrs	r16, 0
    239a:	02 c0       	rjmp	.+4      	; 0x23a0 <ISPCC_ProgramChip+0x8a>
    239c:	88 e0       	ldi	r24, 0x08	; 8
    239e:	01 c0       	rjmp	.+2      	; 0x23a2 <ISPCC_ProgramChip+0x8c>
    23a0:	80 e0       	ldi	r24, 0x00	; 0
    23a2:	8a 29       	or	r24, r10
    23a4:	01 c0       	rjmp	.+2      	; 0x23a8 <ISPCC_ProgramChip+0x92>
    23a6:	8a 2d       	mov	r24, r10
    23a8:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    23ac:	80 91 a9 02 	lds	r24, 0x02A9
    23b0:	90 91 aa 02 	lds	r25, 0x02AA
    23b4:	0e 94 04 0a 	call	0x1408	; 0x1408 <USI_SPITransmitWord>
    23b8:	8f 2d       	mov	r24, r15
    23ba:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    23be:	20 97       	sbiw	r28, 0x00	; 0
    23c0:	d9 f4       	brne	.+54     	; 0x23f8 <ISPCC_ProgramChip+0xe2>
    23c2:	80 91 99 01 	lds	r24, 0x0199
    23c6:	8f 15       	cp	r24, r15
    23c8:	b9 f0       	breq	.+46     	; 0x23f8 <ISPCC_ProgramChip+0xe2>
    23ca:	83 e1       	ldi	r24, 0x13	; 19
    23cc:	e8 16       	cp	r14, r24
    23ce:	49 f0       	breq	.+18     	; 0x23e2 <ISPCC_ProgramChip+0xcc>
    23d0:	e5 e1       	ldi	r30, 0x15	; 21
    23d2:	ee 16       	cp	r14, r30
    23d4:	89 f4       	brne	.+34     	; 0x23f8 <ISPCC_ProgramChip+0xe2>
    23d6:	80 91 9a 01 	lds	r24, 0x019A
    23da:	8f 15       	cp	r24, r15
    23dc:	09 f0       	breq	.+2      	; 0x23e0 <ISPCC_ProgramChip+0xca>
    23de:	7f c0       	rjmp	.+254    	; 0x24de <ISPCC_ProgramChip+0x1c8>
    23e0:	0b c0       	rjmp	.+22     	; 0x23f8 <ISPCC_ProgramChip+0xe2>
    23e2:	c0 91 a9 02 	lds	r28, 0x02A9
    23e6:	d0 91 aa 02 	lds	r29, 0x02AA
    23ea:	cc 0f       	add	r28, r28
    23ec:	dd 1f       	adc	r29, r29
    23ee:	c8 01       	movw	r24, r16
    23f0:	81 70       	andi	r24, 0x01	; 1
    23f2:	90 70       	andi	r25, 0x00	; 0
    23f4:	c8 0f       	add	r28, r24
    23f6:	d9 1f       	adc	r29, r25
    23f8:	00 fd       	sbrc	r16, 0
    23fa:	03 c0       	rjmp	.+6      	; 0x2402 <ISPCC_ProgramChip+0xec>
    23fc:	f5 e1       	ldi	r31, 0x15	; 21
    23fe:	ef 16       	cp	r14, r31
    2400:	11 f4       	brne	.+4      	; 0x2406 <ISPCC_ProgramChip+0xf0>
    2402:	0e 94 db 0e 	call	0x1db6	; 0x1db6 <V2P_IncrementCurrAddress>
    2406:	0f 5f       	subi	r16, 0xFF	; 255
    2408:	1f 4f       	sbci	r17, 0xFF	; 255
    240a:	08 94       	sec
    240c:	c1 1c       	adc	r12, r1
    240e:	d1 1c       	adc	r13, r1
    2410:	08 15       	cp	r16, r8
    2412:	19 05       	cpc	r17, r9
    2414:	09 f0       	breq	.+2      	; 0x2418 <ISPCC_ProgramChip+0x102>
    2416:	bb cf       	rjmp	.-138    	; 0x238e <ISPCC_ProgramChip+0x78>
    2418:	b7 fe       	sbrs	r11, 7
    241a:	6c c0       	rjmp	.+216    	; 0x24f4 <ISPCC_ProgramChip+0x1de>
    241c:	80 91 97 01 	lds	r24, 0x0197
    2420:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    2424:	c2 01       	movw	r24, r4
    2426:	0e 94 04 0a 	call	0x1408	; 0x1408 <USI_SPITransmitWord>
    242a:	80 e0       	ldi	r24, 0x00	; 0
    242c:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    2430:	20 97       	sbiw	r28, 0x00	; 0
    2432:	11 f0       	breq	.+4      	; 0x2438 <ISPCC_ProgramChip+0x122>
    2434:	8b 2d       	mov	r24, r11
    2436:	03 c0       	rjmp	.+6      	; 0x243e <ISPCC_ProgramChip+0x128>
    2438:	8b 2d       	mov	r24, r11
    243a:	8f 78       	andi	r24, 0x8F	; 143
    243c:	80 61       	ori	r24, 0x10	; 16
    243e:	be 01       	movw	r22, r28
    2440:	0e 94 40 11 	call	0x2280	; 0x2280 <ISPCC_PollForProgComplete>
    2444:	57 c0       	rjmp	.+174    	; 0x24f4 <ISPCC_ProgramChip+0x1de>
    2446:	f3 01       	movw	r30, r6
    2448:	10 81       	ld	r17, Z
    244a:	f3 e1       	ldi	r31, 0x13	; 19
    244c:	ef 16       	cp	r14, r31
    244e:	39 f4       	brne	.+14     	; 0x245e <ISPCC_ProgramChip+0x148>
    2450:	c0 fe       	sbrs	r12, 0
    2452:	02 c0       	rjmp	.+4      	; 0x2458 <ISPCC_ProgramChip+0x142>
    2454:	88 e0       	ldi	r24, 0x08	; 8
    2456:	01 c0       	rjmp	.+2      	; 0x245a <ISPCC_ProgramChip+0x144>
    2458:	80 e0       	ldi	r24, 0x00	; 0
    245a:	8a 29       	or	r24, r10
    245c:	01 c0       	rjmp	.+2      	; 0x2460 <ISPCC_ProgramChip+0x14a>
    245e:	8a 2d       	mov	r24, r10
    2460:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    2464:	80 91 a9 02 	lds	r24, 0x02A9
    2468:	90 91 aa 02 	lds	r25, 0x02AA
    246c:	0e 94 04 0a 	call	0x1408	; 0x1408 <USI_SPITransmitWord>
    2470:	81 2f       	mov	r24, r17
    2472:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    2476:	80 91 99 01 	lds	r24, 0x0199
    247a:	81 17       	cp	r24, r17
    247c:	b9 f0       	breq	.+46     	; 0x24ac <ISPCC_ProgramChip+0x196>
    247e:	83 e1       	ldi	r24, 0x13	; 19
    2480:	e8 16       	cp	r14, r24
    2482:	41 f0       	breq	.+16     	; 0x2494 <ISPCC_ProgramChip+0x17e>
    2484:	e5 e1       	ldi	r30, 0x15	; 21
    2486:	ee 16       	cp	r14, r30
    2488:	89 f4       	brne	.+34     	; 0x24ac <ISPCC_ProgramChip+0x196>
    248a:	80 91 9a 01 	lds	r24, 0x019A
    248e:	81 17       	cp	r24, r17
    2490:	59 f5       	brne	.+86     	; 0x24e8 <ISPCC_ProgramChip+0x1d2>
    2492:	0c c0       	rjmp	.+24     	; 0x24ac <ISPCC_ProgramChip+0x196>
    2494:	c0 91 a9 02 	lds	r28, 0x02A9
    2498:	d0 91 aa 02 	lds	r29, 0x02AA
    249c:	cc 0f       	add	r28, r28
    249e:	dd 1f       	adc	r29, r29
    24a0:	c6 01       	movw	r24, r12
    24a2:	81 70       	andi	r24, 0x01	; 1
    24a4:	90 70       	andi	r25, 0x00	; 0
    24a6:	c8 0f       	add	r28, r24
    24a8:	d9 1f       	adc	r29, r25
    24aa:	22 c0       	rjmp	.+68     	; 0x24f0 <ISPCC_ProgramChip+0x1da>
    24ac:	1b 2d       	mov	r17, r11
    24ae:	11 7f       	andi	r17, 0xF1	; 241
    24b0:	12 60       	ori	r17, 0x02	; 2
    24b2:	c0 fc       	sbrc	r12, 0
    24b4:	03 c0       	rjmp	.+6      	; 0x24bc <ISPCC_ProgramChip+0x1a6>
    24b6:	f5 e1       	ldi	r31, 0x15	; 21
    24b8:	ef 16       	cp	r14, r31
    24ba:	11 f4       	brne	.+4      	; 0x24c0 <ISPCC_ProgramChip+0x1aa>
    24bc:	0e 94 db 0e 	call	0x1db6	; 0x1db6 <V2P_IncrementCurrAddress>
    24c0:	be 01       	movw	r22, r28
    24c2:	81 2f       	mov	r24, r17
    24c4:	0e 94 40 11 	call	0x2280	; 0x2280 <ISPCC_PollForProgComplete>
    24c8:	08 94       	sec
    24ca:	c1 1c       	adc	r12, r1
    24cc:	d1 1c       	adc	r13, r1
    24ce:	08 94       	sec
    24d0:	61 1c       	adc	r6, r1
    24d2:	71 1c       	adc	r7, r1
    24d4:	c8 14       	cp	r12, r8
    24d6:	d9 04       	cpc	r13, r9
    24d8:	09 f0       	breq	.+2      	; 0x24dc <ISPCC_ProgramChip+0x1c6>
    24da:	b5 cf       	rjmp	.-150    	; 0x2446 <ISPCC_ProgramChip+0x130>
    24dc:	0b c0       	rjmp	.+22     	; 0x24f4 <ISPCC_ProgramChip+0x1de>
    24de:	c0 91 a9 02 	lds	r28, 0x02A9
    24e2:	d0 91 aa 02 	lds	r29, 0x02AA
    24e6:	88 cf       	rjmp	.-240    	; 0x23f8 <ISPCC_ProgramChip+0xe2>
    24e8:	c0 91 a9 02 	lds	r28, 0x02A9
    24ec:	d0 91 aa 02 	lds	r29, 0x02AA
    24f0:	1b 2d       	mov	r17, r11
    24f2:	df cf       	rjmp	.-66     	; 0x24b2 <ISPCC_ProgramChip+0x19c>
    24f4:	df 91       	pop	r29
    24f6:	cf 91       	pop	r28
    24f8:	1f 91       	pop	r17
    24fa:	0f 91       	pop	r16
    24fc:	ff 90       	pop	r15
    24fe:	ef 90       	pop	r14
    2500:	df 90       	pop	r13
    2502:	cf 90       	pop	r12
    2504:	bf 90       	pop	r11
    2506:	af 90       	pop	r10
    2508:	9f 90       	pop	r9
    250a:	8f 90       	pop	r8
    250c:	7f 90       	pop	r7
    250e:	6f 90       	pop	r6
    2510:	5f 90       	pop	r5
    2512:	4f 90       	pop	r4
    2514:	08 95       	ret

00002516 <ISPCC_EnterChipProgrammingMode>:
    2516:	ff 92       	push	r15
    2518:	0f 93       	push	r16
    251a:	1f 93       	push	r17
    251c:	00 91 96 01 	lds	r16, 0x0196
    2520:	10 91 95 01 	lds	r17, 0x0195
    2524:	81 b3       	in	r24, 0x11	; 17
    2526:	8f 7c       	andi	r24, 0xCF	; 207
    2528:	80 63       	ori	r24, 0x30	; 48
    252a:	81 bb       	out	0x11, r24	; 17
    252c:	80 91 93 01 	lds	r24, 0x0193
    2530:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2534:	81 2f       	mov	r24, r17
    2536:	81 50       	subi	r24, 0x01	; 1
    2538:	84 36       	cpi	r24, 0x64	; 100
    253a:	08 f4       	brcc	.+2      	; 0x253e <ISPCC_EnterChipProgrammingMode+0x28>
    253c:	40 c0       	rjmp	.+128    	; 0x25be <ISPCC_EnterChipProgrammingMode+0xa8>
    253e:	18 e1       	ldi	r17, 0x18	; 24
    2540:	3e c0       	rjmp	.+124    	; 0x25be <ISPCC_EnterChipProgrammingMode+0xa8>
    2542:	80 91 99 01 	lds	r24, 0x0199
    2546:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    254a:	80 2f       	mov	r24, r16
    254c:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2550:	80 91 9a 01 	lds	r24, 0x019A
    2554:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    2558:	80 2f       	mov	r24, r16
    255a:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    255e:	80 91 9b 01 	lds	r24, 0x019B
    2562:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    2566:	f8 2e       	mov	r15, r24
    2568:	80 2f       	mov	r24, r16
    256a:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    256e:	80 91 98 01 	lds	r24, 0x0198
    2572:	83 30       	cpi	r24, 0x03	; 3
    2574:	29 f4       	brne	.+10     	; 0x2580 <ISPCC_EnterChipProgrammingMode+0x6a>
    2576:	80 91 9c 01 	lds	r24, 0x019C
    257a:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    257e:	05 c0       	rjmp	.+10     	; 0x258a <ISPCC_EnterChipProgrammingMode+0x74>
    2580:	80 91 9c 01 	lds	r24, 0x019C
    2584:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    2588:	f8 2e       	mov	r15, r24
    258a:	80 91 98 01 	lds	r24, 0x0198
    258e:	88 23       	and	r24, r24
    2590:	21 f0       	breq	.+8      	; 0x259a <ISPCC_EnterChipProgrammingMode+0x84>
    2592:	80 91 97 01 	lds	r24, 0x0197
    2596:	f8 16       	cp	r15, r24
    2598:	69 f4       	brne	.+26     	; 0x25b4 <ISPCC_EnterChipProgrammingMode+0x9e>
    259a:	80 2f       	mov	r24, r16
    259c:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    25a0:	81 e0       	ldi	r24, 0x01	; 1
    25a2:	80 93 a8 02 	sts	0x02A8, r24
    25a6:	81 b3       	in	r24, 0x11	; 17
    25a8:	8f 7c       	andi	r24, 0xCF	; 207
    25aa:	80 62       	ori	r24, 0x20	; 32
    25ac:	81 bb       	out	0x11, r24	; 17
    25ae:	10 92 92 01 	sts	0x0192, r1
    25b2:	0e c0       	rjmp	.+28     	; 0x25d0 <ISPCC_EnterChipProgrammingMode+0xba>
    25b4:	80 2f       	mov	r24, r16
    25b6:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    25ba:	0e 94 41 0a 	call	0x1482	; 0x1482 <USI_SPIToggleClock>
    25be:	11 50       	subi	r17, 0x01	; 1
    25c0:	00 f6       	brcc	.-128    	; 0x2542 <ISPCC_EnterChipProgrammingMode+0x2c>
    25c2:	81 b3       	in	r24, 0x11	; 17
    25c4:	8f 7c       	andi	r24, 0xCF	; 207
    25c6:	80 61       	ori	r24, 0x10	; 16
    25c8:	81 bb       	out	0x11, r24	; 17
    25ca:	80 ec       	ldi	r24, 0xC0	; 192
    25cc:	80 93 92 01 	sts	0x0192, r24
    25d0:	1f 91       	pop	r17
    25d2:	0f 91       	pop	r16
    25d4:	ff 90       	pop	r15
    25d6:	08 95       	ret

000025d8 <AICI_InterpretPacket>:

// ======================================================================================

void AICI_InterpretPacket(void)
{
    25d8:	df 92       	push	r13
    25da:	ef 92       	push	r14
    25dc:	ff 92       	push	r15
    25de:	0f 93       	push	r16
    25e0:	1f 93       	push	r17
    25e2:	cf 93       	push	r28
    25e4:	df 93       	push	r29
	switch (PacketBytes[0])
    25e6:	80 91 91 01 	lds	r24, 0x0191
    25ea:	86 31       	cpi	r24, 0x16	; 22
    25ec:	09 f4       	brne	.+2      	; 0x25f0 <AICI_InterpretPacket+0x18>
    25ee:	e5 c0       	rjmp	.+458    	; 0x27ba <AICI_InterpretPacket+0x1e2>
    25f0:	87 31       	cpi	r24, 0x17	; 23
    25f2:	78 f4       	brcc	.+30     	; 0x2612 <AICI_InterpretPacket+0x3a>
    25f4:	82 31       	cpi	r24, 0x12	; 18
    25f6:	09 f4       	brne	.+2      	; 0x25fa <AICI_InterpretPacket+0x22>
    25f8:	52 c0       	rjmp	.+164    	; 0x269e <AICI_InterpretPacket+0xc6>
    25fa:	83 31       	cpi	r24, 0x13	; 19
    25fc:	30 f4       	brcc	.+12     	; 0x260a <AICI_InterpretPacket+0x32>
    25fe:	80 31       	cpi	r24, 0x10	; 16
    2600:	d9 f0       	breq	.+54     	; 0x2638 <AICI_InterpretPacket+0x60>
    2602:	81 31       	cpi	r24, 0x11	; 17
    2604:	09 f0       	breq	.+2      	; 0x2608 <AICI_InterpretPacket+0x30>
    2606:	2c c1       	rjmp	.+600    	; 0x2860 <AICI_InterpretPacket+0x288>
    2608:	30 c0       	rjmp	.+96     	; 0x266a <AICI_InterpretPacket+0x92>
    260a:	84 31       	cpi	r24, 0x14	; 20
    260c:	09 f0       	breq	.+2      	; 0x2610 <AICI_InterpretPacket+0x38>
    260e:	1d c1       	rjmp	.+570    	; 0x284a <AICI_InterpretPacket+0x272>
    2610:	d4 c0       	rjmp	.+424    	; 0x27ba <AICI_InterpretPacket+0x1e2>
    2612:	89 31       	cpi	r24, 0x19	; 25
    2614:	09 f4       	brne	.+2      	; 0x2618 <AICI_InterpretPacket+0x40>
    2616:	bd c0       	rjmp	.+378    	; 0x2792 <AICI_InterpretPacket+0x1ba>
    2618:	8a 31       	cpi	r24, 0x1A	; 26
    261a:	38 f4       	brcc	.+14     	; 0x262a <AICI_InterpretPacket+0x52>
    261c:	87 31       	cpi	r24, 0x17	; 23
    261e:	09 f4       	brne	.+2      	; 0x2622 <AICI_InterpretPacket+0x4a>
    2620:	b8 c0       	rjmp	.+368    	; 0x2792 <AICI_InterpretPacket+0x1ba>
    2622:	88 31       	cpi	r24, 0x18	; 24
    2624:	09 f0       	breq	.+2      	; 0x2628 <AICI_InterpretPacket+0x50>
    2626:	1c c1       	rjmp	.+568    	; 0x2860 <AICI_InterpretPacket+0x288>
    2628:	95 c0       	rjmp	.+298    	; 0x2754 <AICI_InterpretPacket+0x17c>
    262a:	8d 31       	cpi	r24, 0x1D	; 29
    262c:	08 f4       	brcc	.+2      	; 0x2630 <AICI_InterpretPacket+0x58>
    262e:	92 c0       	rjmp	.+292    	; 0x2754 <AICI_InterpretPacket+0x17c>
    2630:	8d 31       	cpi	r24, 0x1D	; 29
    2632:	09 f0       	breq	.+2      	; 0x2636 <AICI_InterpretPacket+0x5e>
    2634:	15 c1       	rjmp	.+554    	; 0x2860 <AICI_InterpretPacket+0x288>
    2636:	56 c0       	rjmp	.+172    	; 0x26e4 <AICI_InterpretPacket+0x10c>
	{
		case AICB_CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
    2638:	82 e0       	ldi	r24, 0x02	; 2
    263a:	90 e0       	ldi	r25, 0x00	; 0
    263c:	90 93 a7 02 	sts	0x02A7, r25
    2640:	80 93 a6 02 	sts	0x02A6, r24
			
			USI_SPIInitMaster();
    2644:	0e 94 31 0a 	call	0x1462	; 0x1462 <USI_SPIInitMaster>

			MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);  // Pull the slave AVR's RESET line to active
    2648:	80 e0       	ldi	r24, 0x00	; 0
    264a:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
			ISPCC_EnterChipProgrammingMode();       // Run the Enter Programming Mode routine
    264e:	0e 94 8b 12 	call	0x2516	; 0x2516 <ISPCC_EnterChipProgrammingMode>

			if (InProgrammingMode)
    2652:	80 91 a8 02 	lds	r24, 0x02A8
    2656:	88 23       	and	r24, r24
    2658:	19 f0       	breq	.+6      	; 0x2660 <AICI_InterpretPacket+0x88>
			   LCD_puts_f(AVRISPModeMessage);
    265a:	86 e3       	ldi	r24, 0x36	; 54
    265c:	94 e0       	ldi	r25, 0x04	; 4
    265e:	02 c0       	rjmp	.+4      	; 0x2664 <AICI_InterpretPacket+0x8c>
			else
			   LCD_puts_f(SyncErrorMessage);
    2660:	8b e2       	ldi	r24, 0x2B	; 43
    2662:	94 e0       	ldi	r25, 0x04	; 4
    2664:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
    2668:	04 c1       	rjmp	.+520    	; 0x2872 <AICI_InterpretPacket+0x29a>
			
			break;
		case AICB_CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;
    266a:	82 e0       	ldi	r24, 0x02	; 2
    266c:	90 e0       	ldi	r25, 0x00	; 0
    266e:	90 93 a7 02 	sts	0x02A7, r25
    2672:	80 93 a6 02 	sts	0x02A6, r24

			MAIN_Delay1MS(PacketBytes[1]);           // Wait for the "PreDelay" amount specified in the packet
    2676:	80 91 92 01 	lds	r24, 0x0192
    267a:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Non programming mode = green status led
    267e:	81 b3       	in	r24, 0x11	; 17
    2680:	8f 7c       	andi	r24, 0xCF	; 207
    2682:	80 61       	ori	r24, 0x10	; 16
    2684:	81 bb       	out	0x11, r24	; 17
			InProgrammingMode = FALSE;
    2686:	10 92 a8 02 	sts	0x02A8, r1
			MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run
    268a:	81 e0       	ldi	r24, 0x01	; 1
    268c:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
			MAIN_Delay1MS(PacketBytes[2]);           // Wait for the "PostDelay" amount specified in the packet
    2690:	80 91 93 01 	lds	r24, 0x0193
    2694:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
			
			USI_SPIOff();
    2698:	0e 94 e7 09 	call	0x13ce	; 0x13ce <USI_SPIOff>
    269c:	de c0       	rjmp	.+444    	; 0x285a <AICI_InterpretPacket+0x282>

			PacketBytes[1] = AICB_STATUS_CMD_OK;     // Return OK

			break;
		case AICB_CMD_CHIP_ERASE_ISP:
			MessageSize = 2;
    269e:	82 e0       	ldi	r24, 0x02	; 2
    26a0:	90 e0       	ldi	r25, 0x00	; 0
    26a2:	90 93 a7 02 	sts	0x02A7, r25
    26a6:	80 93 a6 02 	sts	0x02A6, r24
    26aa:	c4 e9       	ldi	r28, 0x94	; 148
    26ac:	d1 e0       	ldi	r29, 0x01	; 1
			
			for (uint8_t PacketB = 3; PacketB <= 6; PacketB++) // Send the erase commands to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    26ae:	89 91       	ld	r24, Y+
    26b0:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    26b4:	81 e0       	ldi	r24, 0x01	; 1
    26b6:	c8 39       	cpi	r28, 0x98	; 152
    26b8:	d8 07       	cpc	r29, r24
    26ba:	c9 f7       	brne	.-14     	; 0x26ae <AICI_InterpretPacket+0xd6>

			if (PacketBytes[2])                       // Poll mode, value of 1 indicates a busy flag wait
    26bc:	80 91 93 01 	lds	r24, 0x0193
    26c0:	88 23       	and	r24, r24
    26c2:	59 f0       	breq	.+22     	; 0x26da <AICI_InterpretPacket+0x102>
			{
				do
					USI_SPITransmitWord(0xF000);
    26c4:	80 e0       	ldi	r24, 0x00	; 0
    26c6:	90 ef       	ldi	r25, 0xF0	; 240
    26c8:	0e 94 04 0a 	call	0x1408	; 0x1408 <USI_SPITransmitWord>
				while (USI_SPITransmitWord(0x0000) & 0x01);
    26cc:	80 e0       	ldi	r24, 0x00	; 0
    26ce:	90 e0       	ldi	r25, 0x00	; 0
    26d0:	0e 94 04 0a 	call	0x1408	; 0x1408 <USI_SPITransmitWord>
    26d4:	80 ff       	sbrs	r24, 0
    26d6:	c1 c0       	rjmp	.+386    	; 0x285a <AICI_InterpretPacket+0x282>
    26d8:	f5 cf       	rjmp	.-22     	; 0x26c4 <AICI_InterpretPacket+0xec>
			}
			else                                      // Poll mode flag of 0 indicates a predefined delay
			{
				MAIN_Delay1MS(PacketBytes[1]);         // Wait the specified interval to ensure erase complete
    26da:	80 91 92 01 	lds	r24, 0x0192
    26de:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    26e2:	bb c0       	rjmp	.+374    	; 0x285a <AICI_InterpretPacket+0x282>
			}
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Always return OK
			
			break;
		case AICB_CMD_SPI_MULTI:
				MessageSize = (3 + PacketBytes[2]);    // Number of recieved bytes, plus two OKs and the command byte
    26e4:	f0 90 93 01 	lds	r15, 0x0193
    26e8:	8f 2d       	mov	r24, r15
    26ea:	99 27       	eor	r25, r25
    26ec:	03 96       	adiw	r24, 0x03	; 3
    26ee:	90 93 a7 02 	sts	0x02A7, r25
    26f2:	80 93 a6 02 	sts	0x02A6, r24
		
				uint8_t TxBytes      = PacketBytes[1]; // \. The packet data is overwritten during the transfer. Because
    26f6:	d0 90 92 01 	lds	r13, 0x0192
				uint8_t RxStartByte  = PacketBytes[2]; // |  of this each data byte must be stored into temp variables
				uint8_t RxBytes      = PacketBytes[3]; // /  so that their contents are not lost.
    26fa:	e0 90 94 01 	lds	r14, 0x0194
    26fe:	11 e0       	ldi	r17, 0x01	; 1
    2700:	01 e0       	ldi	r16, 0x01	; 1
    2702:	12 c0       	rjmp	.+36     	; 0x2728 <AICI_InterpretPacket+0x150>
				uint8_t RxByteNum    = 1;
				uint8_t TxByteNum    = 1;
				uint8_t RecievedByte = 0;

				while (TxByteNum++ < TxBytes)          // Still bytes to transfer
    2704:	0f 5f       	subi	r16, 0xFF	; 255
				{
					RecievedByte = USI_SPITransmit(PacketBytes[3 + TxByteNum]); // Transmit the byte, store the answer
    2706:	e0 2f       	mov	r30, r16
    2708:	ff 27       	eor	r31, r31
    270a:	ef 56       	subi	r30, 0x6F	; 111
    270c:	fe 4f       	sbci	r31, 0xFE	; 254
    270e:	83 81       	ldd	r24, Z+3	; 0x03
    2710:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>

					if ((TxByteNum >= RxStartByte) && (RxByteNum < RxBytes))
    2714:	0f 15       	cp	r16, r15
    2716:	40 f0       	brcs	.+16     	; 0x2728 <AICI_InterpretPacket+0x150>
    2718:	1e 15       	cp	r17, r14
    271a:	30 f4       	brcc	.+12     	; 0x2728 <AICI_InterpretPacket+0x150>
					   PacketBytes[2 + RxByteNum++] = RecievedByte;
    271c:	e1 2f       	mov	r30, r17
    271e:	ff 27       	eor	r31, r31
    2720:	ef 56       	subi	r30, 0x6F	; 111
    2722:	fe 4f       	sbci	r31, 0xFE	; 254
    2724:	82 83       	std	Z+2, r24	; 0x02
    2726:	1f 5f       	subi	r17, 0xFF	; 255
    2728:	0d 15       	cp	r16, r13
    272a:	60 f3       	brcs	.-40     	; 0x2704 <AICI_InterpretPacket+0x12c>
    272c:	06 c0       	rjmp	.+12     	; 0x273a <AICI_InterpretPacket+0x162>
				}

				while (RxByteNum++ < RxBytes)                         // Still more bytes to recieve
				   PacketBytes[2 + RxByteNum] = USI_SPITransmit(0x00); // its answer to be recorded (or more bytes than sent need responses), send dummy bytes to fetch the response(s)
    272e:	80 e0       	ldi	r24, 0x00	; 0
    2730:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    2734:	cf 56       	subi	r28, 0x6F	; 111
    2736:	de 4f       	sbci	r29, 0xFE	; 254
    2738:	8a 83       	std	Y+2, r24	; 0x02
    273a:	1f 5f       	subi	r17, 0xFF	; 255
    273c:	81 2f       	mov	r24, r17
    273e:	81 50       	subi	r24, 0x01	; 1
    2740:	c1 2f       	mov	r28, r17
    2742:	dd 27       	eor	r29, r29
    2744:	8e 15       	cp	r24, r14
    2746:	98 f3       	brcs	.-26     	; 0x272e <AICI_InterpretPacket+0x156>

				PacketBytes[1]             = AICB_STATUS_CMD_OK; // Data should be encompassed
    2748:	10 92 92 01 	sts	0x0192, r1
				PacketBytes[3 + RxByteNum] = AICB_STATUS_CMD_OK; //  by STATS_CMD_OKs
    274c:	cf 56       	subi	r28, 0x6F	; 111
    274e:	de 4f       	sbci	r29, 0xFE	; 254
    2750:	1b 82       	std	Y+3, r1	; 0x03
    2752:	8f c0       	rjmp	.+286    	; 0x2872 <AICI_InterpretPacket+0x29a>

				break;
		case AICB_CMD_READ_SIGNATURE_ISP:
		case AICB_CMD_READ_FUSE_ISP:
		case AICB_CMD_READ_LOCK_ISP:
		case AICB_CMD_READ_OSCCAL_ISP:
			MessageSize = 4;
    2754:	84 e0       	ldi	r24, 0x04	; 4
    2756:	90 e0       	ldi	r25, 0x00	; 0
    2758:	90 93 a7 02 	sts	0x02A7, r25
    275c:	80 93 a6 02 	sts	0x02A6, r24
    2760:	c1 e0       	ldi	r28, 0x01	; 1
    2762:	d0 e0       	ldi	r29, 0x00	; 0
    2764:	03 e9       	ldi	r16, 0x93	; 147
    2766:	11 e0       	ldi	r17, 0x01	; 1
	
			for (uint8_t ByteNum = 1; ByteNum <= 4; ByteNum++)
			{
				uint8_t Response = USI_SPITransmit(PacketBytes[1 + ByteNum]); // Transmit the four signature request bytes
    2768:	f8 01       	movw	r30, r16
    276a:	81 91       	ld	r24, Z+
    276c:	8f 01       	movw	r16, r30
    276e:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    2772:	98 2f       	mov	r25, r24

				if (ByteNum == PacketBytes[1])         // If the current byte is the requested signature byte, save the reponse in the packet
    2774:	80 91 92 01 	lds	r24, 0x0192
    2778:	8c 17       	cp	r24, r28
    277a:	11 f4       	brne	.+4      	; 0x2780 <AICI_InterpretPacket+0x1a8>
					PacketBytes[2] = Response;
    277c:	90 93 93 01 	sts	0x0193, r25
    2780:	21 96       	adiw	r28, 0x01	; 1
    2782:	c5 30       	cpi	r28, 0x05	; 5
    2784:	d1 05       	cpc	r29, r1
    2786:	81 f7       	brne	.-32     	; 0x2768 <AICI_InterpretPacket+0x190>
			}

			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Data byte is encased in CMD_OKs
    2788:	10 92 92 01 	sts	0x0192, r1
			PacketBytes[3] = AICB_STATUS_CMD_OK;       // Data byte is encased in CMD_OKs
    278c:	10 92 94 01 	sts	0x0194, r1
    2790:	70 c0       	rjmp	.+224    	; 0x2872 <AICI_InterpretPacket+0x29a>

			break;
		case AICB_CMD_PROGRAM_FUSE_ISP:
		case AICB_CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;
    2792:	83 e0       	ldi	r24, 0x03	; 3
    2794:	90 e0       	ldi	r25, 0x00	; 0
    2796:	90 93 a7 02 	sts	0x02A7, r25
    279a:	80 93 a6 02 	sts	0x02A6, r24
    279e:	c2 e9       	ldi	r28, 0x92	; 146
    27a0:	d1 e0       	ldi	r29, 0x01	; 1
			
			for (uint8_t PacketB = 1; PacketB <= 4; PacketB++) // Send the lock-byte values to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    27a2:	89 91       	ld	r24, Y+
    27a4:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    27a8:	f1 e0       	ldi	r31, 0x01	; 1
    27aa:	c6 39       	cpi	r28, 0x96	; 150
    27ac:	df 07       	cpc	r29, r31
    27ae:	c9 f7       	brne	.-14     	; 0x27a2 <AICI_InterpretPacket+0x1ca>

			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Two CMD_OKs are always returned
    27b0:	10 92 92 01 	sts	0x0192, r1
			PacketBytes[2] = AICB_STATUS_CMD_OK;       // Two CMD_OKs are always returned
    27b4:	10 92 93 01 	sts	0x0193, r1
    27b8:	5c c0       	rjmp	.+184    	; 0x2872 <AICI_InterpretPacket+0x29a>

			break;
		case AICB_CMD_READ_FLASH_ISP:
		case AICB_CMD_READ_EEPROM_ISP:
			MessageSize = 0;                           // Here to prevent compiler from complaining if a var dec appears straight after a case

			uint8_t  ReadCommand = PacketBytes[3];
    27ba:	d0 90 94 01 	lds	r13, 0x0194
			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8) // Load in the number of bytes that is to
			                     | PacketBytes[2];                 // be read into a temp variable (MSB first)
    27be:	80 91 92 01 	lds	r24, 0x0192
    27c2:	99 27       	eor	r25, r25
    27c4:	d8 2f       	mov	r29, r24
    27c6:	cc 27       	eor	r28, r28
    27c8:	80 91 93 01 	lds	r24, 0x0193
    27cc:	99 27       	eor	r25, r25
    27ce:	c8 2b       	or	r28, r24
    27d0:	d9 2b       	or	r29, r25

			MessageSize = BytesToRead + 3;
    27d2:	23 96       	adiw	r28, 0x03	; 3
    27d4:	d0 93 a7 02 	sts	0x02A7, r29
    27d8:	c0 93 a6 02 	sts	0x02A6, r28
    27dc:	23 97       	sbiw	r28, 0x03	; 3
    27de:	00 e0       	ldi	r16, 0x00	; 0
    27e0:	10 e0       	ldi	r17, 0x00	; 0
    27e2:	83 e9       	ldi	r24, 0x93	; 147
    27e4:	e8 2e       	mov	r14, r24
    27e6:	81 e0       	ldi	r24, 0x01	; 1
    27e8:	f8 2e       	mov	r15, r24
    27ea:	26 c0       	rjmp	.+76     	; 0x2838 <AICI_InterpretPacket+0x260>

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
				if (PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)  // Flash read mode - word addresses so MSB/LSB masking nessesary
    27ec:	80 91 91 01 	lds	r24, 0x0191
    27f0:	84 31       	cpi	r24, 0x14	; 20
    27f2:	39 f4       	brne	.+14     	; 0x2802 <AICI_InterpretPacket+0x22a>
				{
					USI_SPITransmit(ReadCommand | ((ReadByte & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ));
    27f4:	00 ff       	sbrs	r16, 0
    27f6:	02 c0       	rjmp	.+4      	; 0x27fc <AICI_InterpretPacket+0x224>
    27f8:	88 e0       	ldi	r24, 0x08	; 8
    27fa:	01 c0       	rjmp	.+2      	; 0x27fe <AICI_InterpretPacket+0x226>
    27fc:	80 e0       	ldi	r24, 0x00	; 0
    27fe:	8d 29       	or	r24, r13
    2800:	01 c0       	rjmp	.+2      	; 0x2804 <AICI_InterpretPacket+0x22c>
				}
				else                                       // EEPROM read mode, address is in bytes and so no masking nessesary
				{
					USI_SPITransmit(ReadCommand);
    2802:	8d 2d       	mov	r24, r13
    2804:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
				}
				
				USI_SPITransmitWord(CurrAddress);          // Transmit the current address to the slave AVR
    2808:	80 91 a9 02 	lds	r24, 0x02A9
    280c:	90 91 aa 02 	lds	r25, 0x02AA
    2810:	0e 94 04 0a 	call	0x1408	; 0x1408 <USI_SPITransmitWord>

				PacketBytes[2 + ReadByte] = USI_SPITransmit(0x00); // Read in the byte stored at the requested location
    2814:	80 e0       	ldi	r24, 0x00	; 0
    2816:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    281a:	f7 01       	movw	r30, r14
    281c:	80 83       	st	Z, r24

				if ((ReadByte & 0x01) || (PacketBytes[0] == AICB_CMD_READ_EEPROM_ISP)) // Flash addresses are given in words; only increment on the odd byte if reading the flash.
    281e:	00 fd       	sbrc	r16, 0
    2820:	04 c0       	rjmp	.+8      	; 0x282a <AICI_InterpretPacket+0x252>
    2822:	80 91 91 01 	lds	r24, 0x0191
    2826:	86 31       	cpi	r24, 0x16	; 22
    2828:	11 f4       	brne	.+4      	; 0x282e <AICI_InterpretPacket+0x256>
				{
					V2P_IncrementCurrAddress();             // Increment the address counter
    282a:	0e 94 db 0e 	call	0x1db6	; 0x1db6 <V2P_IncrementCurrAddress>
    282e:	0f 5f       	subi	r16, 0xFF	; 255
    2830:	1f 4f       	sbci	r17, 0xFF	; 255
    2832:	08 94       	sec
    2834:	e1 1c       	adc	r14, r1
    2836:	f1 1c       	adc	r15, r1
    2838:	0c 17       	cp	r16, r28
    283a:	1d 07       	cpc	r17, r29
    283c:	b9 f6       	brne	.-82     	; 0x27ec <AICI_InterpretPacket+0x214>
				}
				else
				{
					if ((CurrAddress & 0x00FF0000) & !(CurrAddress & 0x0000FFFF))
					{
						CurrAddress |= (1UL << 31);        // Set MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
						V2P_CheckForExtendedAddress();
					}
				}
			}
			
			PacketBytes[1]               = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    283e:	10 92 92 01 	sts	0x0192, r1
			PacketBytes[2 + BytesToRead] = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    2842:	cf 56       	subi	r28, 0x6F	; 111
    2844:	de 4f       	sbci	r29, 0xFE	; 254
    2846:	1a 82       	std	Y+2, r1	; 0x02
    2848:	14 c0       	rjmp	.+40     	; 0x2872 <AICI_InterpretPacket+0x29a>

			break;
		case AICB_CMD_PROGRAM_FLASH_ISP:
		case AICB_CMD_PROGRAM_EEPROM_ISP:
			ISPCC_ProgramChip();                         // Program the bytes into the chip
    284a:	0e 94 8b 11 	call	0x2316	; 0x2316 <ISPCC_ProgramChip>
			
			MessageSize = 2;
    284e:	82 e0       	ldi	r24, 0x02	; 2
    2850:	90 e0       	ldi	r25, 0x00	; 0
    2852:	90 93 a7 02 	sts	0x02A7, r25
    2856:	80 93 a6 02 	sts	0x02A6, r24

			PacketBytes[1] = AICB_STATUS_CMD_OK;
    285a:	10 92 92 01 	sts	0x0192, r1
    285e:	09 c0       	rjmp	.+18     	; 0x2872 <AICI_InterpretPacket+0x29a>
			
			break;
		default:                                        // Unknown command, return error
			MessageSize = 1;
    2860:	81 e0       	ldi	r24, 0x01	; 1
    2862:	90 e0       	ldi	r25, 0x00	; 0
    2864:	90 93 a7 02 	sts	0x02A7, r25
    2868:	80 93 a6 02 	sts	0x02A6, r24
			
			PacketBytes[1] = AICB_STATUS_CMD_UNKNOWN;
    286c:	89 ec       	ldi	r24, 0xC9	; 201
    286e:	80 93 92 01 	sts	0x0192, r24
	}

	V2P_SendPacket();                                    // Send the response packet
    2872:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <V2P_SendPacket>
    2876:	df 91       	pop	r29
    2878:	cf 91       	pop	r28
    287a:	1f 91       	pop	r17
    287c:	0f 91       	pop	r16
    287e:	ff 90       	pop	r15
    2880:	ef 90       	pop	r14
    2882:	df 90       	pop	r13
    2884:	08 95       	ret

00002886 <PM_SetupDFAddressCounters>:
	  return ProgDataSize;
}

void PM_SetupDFAddressCounters(const uint8_t Type)
{
    2886:	80 93 02 01 	sts	0x0102, r24
	uint32_t StartAddress;
	
	MemoryType  = Type;
	GPageLength = 0;
    288a:	10 92 b0 02 	sts	0x02B0, r1
    288e:	10 92 af 02 	sts	0x02AF, r1
    2892:	20 91 a9 02 	lds	r18, 0x02A9
    2896:	30 91 aa 02 	lds	r19, 0x02AA
    289a:	40 91 ab 02 	lds	r20, 0x02AB
    289e:	50 91 ac 02 	lds	r21, 0x02AC

	if (Type == TYPE_FLASH)                                             // Type 1 = Flash
    28a2:	81 30       	cpi	r24, 0x01	; 1
    28a4:	39 f4       	brne	.+14     	; 0x28b4 <PM_SetupDFAddressCounters+0x2e>
	  StartAddress = (CurrAddress << 1);                                // Convert flash word address to byte address
    28a6:	da 01       	movw	r26, r20
    28a8:	c9 01       	movw	r24, r18
    28aa:	88 0f       	add	r24, r24
    28ac:	99 1f       	adc	r25, r25
    28ae:	aa 1f       	adc	r26, r26
    28b0:	bb 1f       	adc	r27, r27
    28b2:	06 c0       	rjmp	.+12     	; 0x28c0 <PM_SetupDFAddressCounters+0x3a>
	else
	  StartAddress = CurrAddress + PM_EEPROM_OFFSET;                    // EEPROM uses byte addresses, and starts at the 257th kilobyte in Dataflash
    28b4:	da 01       	movw	r26, r20
    28b6:	c9 01       	movw	r24, r18
    28b8:	80 50       	subi	r24, 0x00	; 0
    28ba:	9c 4f       	sbci	r25, 0xFC	; 252
    28bc:	ab 4f       	sbci	r26, 0xFB	; 251
    28be:	bf 4f       	sbci	r27, 0xFF	; 255
	
	DataflashInfo.CurrPageAddress = 0;
    28c0:	10 92 44 01 	sts	0x0144, r1
    28c4:	10 92 43 01 	sts	0x0143, r1
    28c8:	20 e0       	ldi	r18, 0x00	; 0
    28ca:	30 e0       	ldi	r19, 0x00	; 0
    28cc:	06 c0       	rjmp	.+12     	; 0x28da <PM_SetupDFAddressCounters+0x54>

	while (StartAddress >= DF_INTERNALDF_BUFFBYTES)                     // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DF_INTERNALDF_BUFFBYTES;                        // Subtract one page's worth of bytes from the desired address
    28ce:	88 50       	subi	r24, 0x08	; 8
    28d0:	91 40       	sbci	r25, 0x01	; 1
    28d2:	a0 40       	sbci	r26, 0x00	; 0
    28d4:	b0 40       	sbci	r27, 0x00	; 0
    28d6:	2f 5f       	subi	r18, 0xFF	; 255
    28d8:	3f 4f       	sbci	r19, 0xFF	; 255
    28da:	88 30       	cpi	r24, 0x08	; 8
    28dc:	41 e0       	ldi	r20, 0x01	; 1
    28de:	94 07       	cpc	r25, r20
    28e0:	40 e0       	ldi	r20, 0x00	; 0
    28e2:	a4 07       	cpc	r26, r20
    28e4:	40 e0       	ldi	r20, 0x00	; 0
    28e6:	b4 07       	cpc	r27, r20
    28e8:	90 f7       	brcc	.-28     	; 0x28ce <PM_SetupDFAddressCounters+0x48>
    28ea:	30 93 44 01 	sts	0x0144, r19
    28ee:	20 93 43 01 	sts	0x0143, r18
		DataflashInfo.CurrPageAddress++;
	}
	
	DataflashInfo.CurrBuffByte = (uint16_t)StartAddress;                // The buffer byte is the remainder
    28f2:	90 93 46 01 	sts	0x0146, r25
    28f6:	80 93 45 01 	sts	0x0145, r24
    28fa:	08 95       	ret

000028fc <PM_CheckEndOfFuseLockData>:
}

void PM_StoreProgramByte(const uint8_t Data)
{
	if (DataflashInfo.CurrBuffByte == DF_INTERNALDF_BUFFBYTES)          // Finished current dataflash buffer page; write it to dataflash and get ready for the next one
	{
		DF_CopyBufferToFlashPage(DataflashInfo.CurrPageAddress++);
		DF_BufferWriteEnable(0);
		DataflashInfo.CurrBuffByte = 0;
	}
	
	SPI_SPITransmit(Data);                                              // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
	DataflashInfo.CurrBuffByte++;
	GPageLength++;
}

void PM_InterpretAVRISPPacket(void)
{
	uint8_t* EEPROMAddress;

	switch (PacketBytes[0])
	{
		case AICB_CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
						
			for (uint8_t PacketB = 0; PacketB <= 11; PacketB++)         // Save the enter programming mode command bytes
			  eeprom_write_byte(&EEPROMVars.EnterProgMode[PacketB], PacketBytes[PacketB]);
			
			InProgrammingMode = TRUE;                                   // Set the flag, prevent the user from exiting the V2P state machine			
			CurrentMode = PM_NO_SETUP;                                  // Clear the current mode variable

			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = AICB_STATUS_CMD_OK;

			break;			
		case AICB_CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;

			PM_CheckEndOfFuseLockData();                                // Check for remaining bytes to be stored and general cleanup
			
			InProgrammingMode = FALSE;                                  // Clear the flag, allow the user to exit the V2P state machine

			DF_EnableDataflash(FALSE);

			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
			PacketBytes[1] = AICB_STATUS_CMD_OK;

			break;
		case AICB_CMD_READ_SIGNATURE_ISP:
			MessageSize = 4;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x01;                                      // Signature bytes all return "01" in storage mode
			PacketBytes[3] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_CHIP_ERASE_ISP:
			MessageSize = 2;

			for (uint8_t PacketB = 1; PacketB < 7; PacketB++)           // Save the erase chip command bytes to EEPROM
			  eeprom_write_byte(&EEPROMVars.EraseChip[PacketB], PacketBytes[PacketB]);

			for (uint8_t Byte = 0; Byte < 4; Byte++)                    // Clear the program and EEPROM size counters
			{
				eeprom_write_byte(&EEPROMVars.DataSize[Byte], 0x00);
				eeprom_write_byte(&EEPROMVars.EEPROMSize[Byte], 0x00);
			}
						
			eeprom_write_byte(&EEPROMVars.EraseCmdStored, TRUE);
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;
			
			break;
		case AICB_CMD_READ_OSCCAL_ISP:
			MessageSize = 4;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x00;                                      // Return 0x00 for the OSCCAL byte
			PacketBytes[3] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_PROGRAM_FUSE_ISP:
		case AICB_CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;

			if (CurrentMode != PM_LOCKFUSEBITS_WRITE)                   // First lock or fuse byte being written, set the EEPROM pointer
			{
				CurrentMode   = PM_LOCKFUSEBITS_WRITE;
				DataflashInfo.CurrBuffByte  = 0;                        // CurrBuffByte is used to store the total fuse/lock bytes written
			}

			if (PacketBytes[0] == AICB_CMD_PROGRAM_FUSE_ISP)
			{
				EEPROMAddress = (uint8_t*)(&EEPROMVars.FuseBytes + (DataflashInfo.CurrBuffByte << 2));
				MemoryType    = TYPE_FUSE;
			}
			else
			{
				EEPROMAddress = (uint8_t*)(&EEPROMVars.LockBytes + (DataflashInfo.CurrBuffByte << 2));
				MemoryType    = TYPE_LOCK;
			}				
			
			if (DataflashInfo.CurrBuffByte < PM_MAX_FUSELOCKBITS)
			{
				for (uint8_t FLByte = 1; FLByte < 5; FLByte++)
				{
					eeprom_write_byte(EEPROMAddress, PacketBytes[FLByte]);
					EEPROMAddress++;
				}

				DataflashInfo.CurrBuffByte++;                           // Increment the total fuse/lock bytes written counter
			}
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;                        // Two CMD_OKs are always returned
			PacketBytes[2] = AICB_STATUS_CMD_OK;                        // Two CMD_OKs are always returned

			break;
		case AICB_CMD_READ_FUSE_ISP:
		case AICB_CMD_READ_LOCK_ISP:
			MessageSize = 4;
	
			if (CurrentMode != PM_LOCKFUSEBITS_READ)                    // First lock or fuse byte being read, set the EEPROM pointer
			{
				PM_CheckEndOfFuseLockData();                            // Check for remaining bytes to be stored and general cleanup
				
				DataflashInfo.CurrBuffByte = 0;
				CurrentMode  = PM_LOCKFUSEBITS_READ;
			}
			
			if (DataflashInfo.CurrBuffByte > eeprom_read_byte((PacketBytes[0] == AICB_CMD_READ_FUSE_ISP)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes))  // Trying to read more fuse/lock bytes than are stored in memory
			{
				PacketBytes[2] = 0xFF;                                  // Return 0xFF for the fuse/lock byte
			}
			else
			{
				PacketBytes[2] = eeprom_read_byte((uint8_t*)(((PacketBytes[0] == AICB_CMD_READ_FUSE_ISP)? &EEPROMVars.FuseBytes : &EEPROMVars.LockBytes) // Starting location
									                         + (DataflashInfo.CurrBuffByte << 2) + (PacketBytes[1] - 1)));                               // The start position of the actual fuse/lock byte to read (4 bytes each));
			}

			DataflashInfo.CurrBuffByte++;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs
			PacketBytes[3] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_PROGRAM_FLASH_ISP:
		case AICB_CMD_PROGRAM_EEPROM_ISP:
			MessageSize = 2;

			if (CurrentMode != PM_DATAFLASH_WRITE)                      // First programming packet
			{
				if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP)       // Flash programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram; // Set the eeprom address to the Program command bytes location
					PM_SetupDFAddressCounters(TYPE_FLASH);
				}
				else                                                    // EEPROM programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;  // Set the eeprom address to the EEPROM command bytes location
					PM_SetupDFAddressCounters(TYPE_EEPROM);
				}
				
				DF_BufferWriteEnable(DataflashInfo.CurrBuffByte);
				CurrentMode = PM_DATAFLASH_WRITE;
				
				for (uint8_t B = 1; B < 10; B++)                        // Save the command bytes
				{
					eeprom_write_byte(EEPROMAddress, PacketBytes[B]);
					EEPROMAddress++;
				}
			}

			uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
			                      | PacketBytes[2];

			for (uint16_t CurrByte = 0; CurrByte < BytesToWrite; CurrByte++)
			  PM_StoreProgramByte(PacketBytes[10 + CurrByte]);

			if (!(GPageLength & PM_PAGELENGTH_FOUNDBIT) && (PacketBytes[3] & ISPCC_PROG_MODE_PAGEDONE) && GPageLength)
			{
				eeprom_write_word(((MemoryType == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength), GPageLength);
		
				GPageLength |= PM_PAGELENGTH_FOUNDBIT;                  // Bit 15 is used to indicate if the length has been found
			}

			PacketBytes[1] = AICB_STATUS_CMD_OK;
		
			break;
		case AICB_CMD_READ_FLASH_ISP:
		case AICB_CMD_READ_EEPROM_ISP:	
			if (CurrentMode != PM_DATAFLASH_READ)
			{
				PM_CheckEndOfFuseLockData();                            // Check for remaining bytes to be stored and general cleanup
				
				PM_SetupDFAddressCounters((PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);
				DF_ContinuousReadEnable(DataflashInfo.CurrPageAddress, DataflashInfo.CurrBuffByte);
				
				CurrentMode = PM_DATAFLASH_READ;
				CurrAddress = 0;
			}

			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8)      // \. Load in the number of bytes that is to
			                     | PacketBytes[2];                      // /  be read into a temp variable (MSB first)
						
			uint16_t BytesInMem  = PM_GetStoredDataSize((PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
			   PacketBytes[2 + ReadByte] = ((CurrAddress < BytesInMem)? SPI_SPITransmit(0x00) : 0xFF); // Read in the next dataflash byte if present
			   V2P_IncrementCurrAddress();
			}
			
			MessageSize = BytesToRead + 3;

			PacketBytes[1]               = AICB_STATUS_CMD_OK;          // Return data should be encompassed in STATUS_CMD_OKs
			PacketBytes[2 + BytesToRead] = AICB_STATUS_CMD_OK;          // Return data should be encompassed in STATUS_CMD_OKs
		
			break;
		default:
			MessageSize = 1;
			
			PacketBytes[1] = AICB_STATUS_CMD_UNKNOWN;
	}

	V2P_SendPacket();                                                   // Send the response packet
}

void PM_CheckEndOfFuseLockData(void)
{
    28fc:	cf 93       	push	r28
    28fe:	df 93       	push	r29
    2900:	cd b7       	in	r28, 0x3d	; 61
    2902:	de b7       	in	r29, 0x3e	; 62
    2904:	24 97       	sbiw	r28, 0x04	; 4
    2906:	0f b6       	in	r0, 0x3f	; 63
    2908:	f8 94       	cli
    290a:	de bf       	out	0x3e, r29	; 62
    290c:	0f be       	out	0x3f, r0	; 63
    290e:	cd bf       	out	0x3d, r28	; 61
	if (CurrentMode == PM_DATAFLASH_WRITE)
    2910:	80 91 ae 02 	lds	r24, 0x02AE
    2914:	81 30       	cpi	r24, 0x01	; 1
    2916:	09 f0       	breq	.+2      	; 0x291a <PM_CheckEndOfFuseLockData+0x1e>
    2918:	40 c0       	rjmp	.+128    	; 0x299a <PM_CheckEndOfFuseLockData+0x9e>
	{
		if (DataflashInfo.CurrBuffByte)                                 // Data in the dataflash buffer, pending to be written
    291a:	80 91 45 01 	lds	r24, 0x0145
    291e:	90 91 46 01 	lds	r25, 0x0146
    2922:	89 2b       	or	r24, r25
    2924:	31 f0       	breq	.+12     	; 0x2932 <PM_CheckEndOfFuseLockData+0x36>
		  DF_CopyBufferToFlashPage(DataflashInfo.CurrPageAddress);      // Save the remaining buffer bytes
    2926:	80 91 43 01 	lds	r24, 0x0143
    292a:	90 91 44 01 	lds	r25, 0x0144
    292e:	0e 94 55 0b 	call	0x16aa	; 0x16aa <DF_CopyBufferToFlashPage>

		uint32_t DataSize = ((DataflashInfo.CurrPageAddress * DF_INTERNALDF_BUFFBYTES) + DataflashInfo.CurrBuffByte);
    2932:	20 91 43 01 	lds	r18, 0x0143
    2936:	30 91 44 01 	lds	r19, 0x0144
    293a:	88 e0       	ldi	r24, 0x08	; 8
    293c:	91 e0       	ldi	r25, 0x01	; 1
    293e:	ac 01       	movw	r20, r24
    2940:	24 9f       	mul	r18, r20
    2942:	c0 01       	movw	r24, r0
    2944:	25 9f       	mul	r18, r21
    2946:	90 0d       	add	r25, r0
    2948:	34 9f       	mul	r19, r20
    294a:	90 0d       	add	r25, r0
    294c:	11 24       	eor	r1, r1
    294e:	20 91 45 01 	lds	r18, 0x0145
    2952:	30 91 46 01 	lds	r19, 0x0146
    2956:	82 0f       	add	r24, r18
    2958:	93 1f       	adc	r25, r19
    295a:	9c 01       	movw	r18, r24
    295c:	44 27       	eor	r20, r20
    295e:	55 27       	eor	r21, r21
    2960:	29 83       	std	Y+1, r18	; 0x01
    2962:	3a 83       	std	Y+2, r19	; 0x02
    2964:	4b 83       	std	Y+3, r20	; 0x03
    2966:	5c 83       	std	Y+4, r21	; 0x04

		if (MemoryType == TYPE_FLASH)
    2968:	80 91 02 01 	lds	r24, 0x0102
    296c:	fe 01       	movw	r30, r28
    296e:	31 96       	adiw	r30, 0x01	; 1
    2970:	81 30       	cpi	r24, 0x01	; 1
    2972:	21 f4       	brne	.+8      	; 0x297c <PM_CheckEndOfFuseLockData+0x80>
            {
              uint8_t len;
              len = (uint8_t) n;

              asm volatile (
    2974:	84 e0       	ldi	r24, 0x04	; 4
    2976:	af e1       	ldi	r26, 0x1F	; 31
    2978:	b0 e0       	ldi	r27, 0x00	; 0
    297a:	0b c0       	rjmp	.+22     	; 0x2992 <PM_CheckEndOfFuseLockData+0x96>
		{
			eeprom_write_block((const void*)&DataSize, (void*)&EEPROMVars.DataSize, sizeof(uint32_t));
		}
		else
		{
			DataSize -= PM_EEPROM_OFFSET;                               // Remove DataFlash EEPROM start offset
    297c:	20 50       	subi	r18, 0x00	; 0
    297e:	34 40       	sbci	r19, 0x04	; 4
    2980:	44 40       	sbci	r20, 0x04	; 4
    2982:	50 40       	sbci	r21, 0x00	; 0
    2984:	29 83       	std	Y+1, r18	; 0x01
    2986:	3a 83       	std	Y+2, r19	; 0x02
    2988:	4b 83       	std	Y+3, r20	; 0x03
    298a:	5c 83       	std	Y+4, r21	; 0x04
            {
              uint8_t len;
              len = (uint8_t) n;

              asm volatile (
    298c:	84 e0       	ldi	r24, 0x04	; 4
    298e:	a3 e2       	ldi	r26, 0x23	; 35
    2990:	b0 e0       	ldi	r27, 0x00	; 0
    2992:	18 2e       	mov	r1, r24
    2994:	0e 94 b3 1a 	call	0x3566	; 0x3566 <__eeprom_write_block_1F2021>
    2998:	12 c0       	rjmp	.+36     	; 0x29be <PM_CheckEndOfFuseLockData+0xc2>
			eeprom_write_block((const void*)&DataSize, (void*)&EEPROMVars.EEPROMSize, sizeof(uint32_t));
		}
	}
	else if (CurrentMode == PM_LOCKFUSEBITS_WRITE)
    299a:	83 30       	cpi	r24, 0x03	; 3
    299c:	81 f4       	brne	.+32     	; 0x29be <PM_CheckEndOfFuseLockData+0xc2>
	{
		// CurrBuffByte stores the total number of fuse/lock bytes written in this case:
		eeprom_write_byte(((MemoryType == TYPE_FUSE)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes), DataflashInfo.CurrBuffByte);
    299e:	20 91 45 01 	lds	r18, 0x0145
    29a2:	30 91 46 01 	lds	r19, 0x0146
    29a6:	80 91 02 01 	lds	r24, 0x0102
    29aa:	82 30       	cpi	r24, 0x02	; 2
    29ac:	19 f4       	brne	.+6      	; 0x29b4 <PM_CheckEndOfFuseLockData+0xb8>
    29ae:	a3 e3       	ldi	r26, 0x33	; 51
    29b0:	b0 e0       	ldi	r27, 0x00	; 0
    29b2:	02 c0       	rjmp	.+4      	; 0x29b8 <PM_CheckEndOfFuseLockData+0xbc>
    29b4:	a4 e3       	ldi	r26, 0x34	; 52
    29b6:	b0 e0       	ldi	r27, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    29b8:	02 2e       	mov	r0, r18
    29ba:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
    29be:	24 96       	adiw	r28, 0x04	; 4
    29c0:	0f b6       	in	r0, 0x3f	; 63
    29c2:	f8 94       	cli
    29c4:	de bf       	out	0x3e, r29	; 62
    29c6:	0f be       	out	0x3f, r0	; 63
    29c8:	cd bf       	out	0x3d, r28	; 61
    29ca:	df 91       	pop	r29
    29cc:	cf 91       	pop	r28
    29ce:	08 95       	ret

000029d0 <PM_GetStoredDataSize>:
    29d0:	cf 93       	push	r28
    29d2:	df 93       	push	r29
    29d4:	cd b7       	in	r28, 0x3d	; 61
    29d6:	de b7       	in	r29, 0x3e	; 62
    29d8:	24 97       	sbiw	r28, 0x04	; 4
    29da:	0f b6       	in	r0, 0x3f	; 63
    29dc:	f8 94       	cli
    29de:	de bf       	out	0x3e, r29	; 62
    29e0:	0f be       	out	0x3f, r0	; 63
    29e2:	cd bf       	out	0x3d, r28	; 61
    29e4:	81 30       	cpi	r24, 0x01	; 1
    29e6:	19 f4       	brne	.+6      	; 0x29ee <PM_GetStoredDataSize+0x1e>
    29e8:	af e1       	ldi	r26, 0x1F	; 31
    29ea:	b0 e0       	ldi	r27, 0x00	; 0
    29ec:	02 c0       	rjmp	.+4      	; 0x29f2 <PM_GetStoredDataSize+0x22>
    29ee:	a3 e2       	ldi	r26, 0x23	; 35
    29f0:	b0 e0       	ldi	r27, 0x00	; 0
              /* Needed in order to truncate to 8 bit.  */
              uint8_t len;
              len = (uint8_t) n; 

              asm volatile (
    29f2:	84 e0       	ldi	r24, 0x04	; 4
    29f4:	fe 01       	movw	r30, r28
    29f6:	31 96       	adiw	r30, 0x01	; 1
    29f8:	18 2e       	mov	r1, r24
    29fa:	0e 94 98 1a 	call	0x3530	; 0x3530 <__eeprom_read_block_1F2021>
    29fe:	69 81       	ldd	r22, Y+1	; 0x01
    2a00:	7a 81       	ldd	r23, Y+2	; 0x02
    2a02:	8b 81       	ldd	r24, Y+3	; 0x03
    2a04:	9c 81       	ldd	r25, Y+4	; 0x04
    2a06:	6f 3f       	cpi	r22, 0xFF	; 255
    2a08:	2f ef       	ldi	r18, 0xFF	; 255
    2a0a:	72 07       	cpc	r23, r18
    2a0c:	2f ef       	ldi	r18, 0xFF	; 255
    2a0e:	82 07       	cpc	r24, r18
    2a10:	2f ef       	ldi	r18, 0xFF	; 255
    2a12:	92 07       	cpc	r25, r18
    2a14:	21 f4       	brne	.+8      	; 0x2a1e <PM_GetStoredDataSize+0x4e>
    2a16:	60 e0       	ldi	r22, 0x00	; 0
    2a18:	70 e0       	ldi	r23, 0x00	; 0
    2a1a:	80 e0       	ldi	r24, 0x00	; 0
    2a1c:	90 e0       	ldi	r25, 0x00	; 0
    2a1e:	24 96       	adiw	r28, 0x04	; 4
    2a20:	0f b6       	in	r0, 0x3f	; 63
    2a22:	f8 94       	cli
    2a24:	de bf       	out	0x3e, r29	; 62
    2a26:	0f be       	out	0x3f, r0	; 63
    2a28:	cd bf       	out	0x3d, r28	; 61
    2a2a:	df 91       	pop	r29
    2a2c:	cf 91       	pop	r28
    2a2e:	08 95       	ret

00002a30 <PM_StoreProgramByte>:
    2a30:	1f 93       	push	r17
    2a32:	18 2f       	mov	r17, r24
    2a34:	80 91 45 01 	lds	r24, 0x0145
    2a38:	90 91 46 01 	lds	r25, 0x0146
    2a3c:	88 50       	subi	r24, 0x08	; 8
    2a3e:	91 40       	sbci	r25, 0x01	; 1
    2a40:	a1 f4       	brne	.+40     	; 0x2a6a <PM_StoreProgramByte+0x3a>
    2a42:	80 91 43 01 	lds	r24, 0x0143
    2a46:	90 91 44 01 	lds	r25, 0x0144
    2a4a:	01 96       	adiw	r24, 0x01	; 1
    2a4c:	90 93 44 01 	sts	0x0144, r25
    2a50:	80 93 43 01 	sts	0x0143, r24
    2a54:	01 97       	sbiw	r24, 0x01	; 1
    2a56:	0e 94 55 0b 	call	0x16aa	; 0x16aa <DF_CopyBufferToFlashPage>
    2a5a:	80 e0       	ldi	r24, 0x00	; 0
    2a5c:	90 e0       	ldi	r25, 0x00	; 0
    2a5e:	0e 94 cb 0a 	call	0x1596	; 0x1596 <DF_BufferWriteEnable>
    2a62:	10 92 46 01 	sts	0x0146, r1
    2a66:	10 92 45 01 	sts	0x0145, r1
    2a6a:	81 2f       	mov	r24, r17
    2a6c:	0e 94 b2 09 	call	0x1364	; 0x1364 <SPI_SPITransmit>
    2a70:	80 91 45 01 	lds	r24, 0x0145
    2a74:	90 91 46 01 	lds	r25, 0x0146
    2a78:	01 96       	adiw	r24, 0x01	; 1
    2a7a:	90 93 46 01 	sts	0x0146, r25
    2a7e:	80 93 45 01 	sts	0x0145, r24
    2a82:	80 91 af 02 	lds	r24, 0x02AF
    2a86:	90 91 b0 02 	lds	r25, 0x02B0
    2a8a:	01 96       	adiw	r24, 0x01	; 1
    2a8c:	90 93 b0 02 	sts	0x02B0, r25
    2a90:	80 93 af 02 	sts	0x02AF, r24
    2a94:	1f 91       	pop	r17
    2a96:	08 95       	ret

00002a98 <PM_SendFuseLockBytes>:
	}
}

void PM_SendFuseLockBytes(const uint8_t Type)
{
    2a98:	ef 92       	push	r14
    2a9a:	ff 92       	push	r15
    2a9c:	0f 93       	push	r16
    2a9e:	1f 93       	push	r17
    2aa0:	cf 93       	push	r28
    2aa2:	df 93       	push	r29
	uint8_t  TotalBytes;
	uint8_t* EEPROMAddress;

	if (Type == TYPE_FUSE)
    2aa4:	82 30       	cpi	r24, 0x02	; 2
    2aa6:	59 f4       	brne	.+22     	; 0x2abe <PM_SendFuseLockBytes+0x26>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2aa8:	43 e3       	ldi	r20, 0x33	; 51
    2aaa:	50 e0       	ldi	r21, 0x00	; 0
    2aac:	da 01       	movw	r26, r20
    2aae:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
    2ab2:	80 2d       	mov	r24, r0
	{
		TotalBytes    = eeprom_read_byte(&EEPROMVars.TotalFuseBytes);
    2ab4:	18 2f       	mov	r17, r24
    2ab6:	62 e0       	ldi	r22, 0x02	; 2
    2ab8:	e6 2e       	mov	r14, r22
    2aba:	f1 2c       	mov	r15, r1
    2abc:	0a c0       	rjmp	.+20     	; 0x2ad2 <PM_SendFuseLockBytes+0x3a>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2abe:	44 e3       	ldi	r20, 0x34	; 52
    2ac0:	50 e0       	ldi	r21, 0x00	; 0
    2ac2:	da 01       	movw	r26, r20
    2ac4:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
    2ac8:	80 2d       	mov	r24, r0
		EEPROMAddress = EEPROMVars.FuseBytes;
	}
	else
	{
		TotalBytes    = eeprom_read_byte(&EEPROMVars.TotalLockBytes);
    2aca:	18 2f       	mov	r17, r24
    2acc:	39 e2       	ldi	r19, 0x29	; 41
    2ace:	e3 2e       	mov	r14, r19
    2ad0:	f1 2c       	mov	r15, r1
    2ad2:	e4 0e       	add	r14, r20
    2ad4:	f5 1e       	adc	r15, r21
    2ad6:	15 c0       	rjmp	.+42     	; 0x2b02 <PM_SendFuseLockBytes+0x6a>
    2ad8:	e7 01       	movw	r28, r14
    2ada:	00 e0       	ldi	r16, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2adc:	de 01       	movw	r26, r28
    2ade:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
    2ae2:	80 2d       	mov	r24, r0
		EEPROMAddress = EEPROMVars.LockBytes;	
	}

	while (TotalBytes--)                                                // Write each of the fuse/lock bytes stored in memory to the slave AVR
	{
		for (uint8_t CommandByte = 0; CommandByte < 4; CommandByte++)   // Write each individual command byte
		{
			USI_SPITransmit(eeprom_read_byte(EEPROMAddress));
    2ae4:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
			EEPROMAddress++;
    2ae8:	21 96       	adiw	r28, 0x01	; 1
    2aea:	0f 5f       	subi	r16, 0xFF	; 255
    2aec:	04 30       	cpi	r16, 0x04	; 4
    2aee:	b1 f7       	brne	.-20     	; 0x2adc <PM_SendFuseLockBytes+0x44>
    2af0:	84 e0       	ldi	r24, 0x04	; 4
    2af2:	90 e0       	ldi	r25, 0x00	; 0
    2af4:	e8 0e       	add	r14, r24
    2af6:	f9 1e       	adc	r15, r25
		}
		
		// Add some delay before programming next byte, if there is one:
		if (TotalBytes)
    2af8:	11 23       	and	r17, r17
    2afa:	19 f0       	breq	.+6      	; 0x2b02 <PM_SendFuseLockBytes+0x6a>
		  MAIN_Delay10MS(5);
    2afc:	85 e0       	ldi	r24, 0x05	; 5
    2afe:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
    2b02:	11 50       	subi	r17, 0x01	; 1
    2b04:	48 f7       	brcc	.-46     	; 0x2ad8 <PM_SendFuseLockBytes+0x40>
    2b06:	df 91       	pop	r29
    2b08:	cf 91       	pop	r28
    2b0a:	1f 91       	pop	r17
    2b0c:	0f 91       	pop	r16
    2b0e:	ff 90       	pop	r15
    2b10:	ef 90       	pop	r14
    2b12:	08 95       	ret

00002b14 <PM_SendEraseCommand>:
	}
}

void PM_SendEraseCommand(void)
{			
    2b14:	cf 93       	push	r28
    2b16:	df 93       	push	r29
    2b18:	cb e1       	ldi	r28, 0x1B	; 27
    2b1a:	d0 e0       	ldi	r29, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2b1c:	de 01       	movw	r26, r28
    2b1e:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
    2b22:	80 2d       	mov	r24, r0
	for (uint8_t B = 3; B < 7 ; B++)                                    // Read out the erase chip command bytes
	  USI_SPITransmit(eeprom_read_byte(&EEPROMVars.EraseChip[B]));      // Send the erase chip commands
    2b24:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
    2b28:	21 96       	adiw	r28, 0x01	; 1
    2b2a:	80 e0       	ldi	r24, 0x00	; 0
    2b2c:	cf 31       	cpi	r28, 0x1F	; 31
    2b2e:	d8 07       	cpc	r29, r24
    2b30:	a9 f7       	brne	.-22     	; 0x2b1c <PM_SendEraseCommand+0x8>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2b32:	25 97       	sbiw	r28, 0x05	; 5
    2b34:	de 01       	movw	r26, r28
    2b36:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
    2b3a:	80 2d       	mov	r24, r0
    2b3c:	25 96       	adiw	r28, 0x05	; 5
			
	if (eeprom_read_byte(&EEPROMVars.EraseChip[2]))                     // Value of 1 indicates a busy flag test
    2b3e:	88 23       	and	r24, r24
    2b40:	59 f0       	breq	.+22     	; 0x2b58 <PM_SendEraseCommand+0x44>
	{
		do
		  USI_SPITransmitWord(0xF000);
    2b42:	80 e0       	ldi	r24, 0x00	; 0
    2b44:	90 ef       	ldi	r25, 0xF0	; 240
    2b46:	0e 94 04 0a 	call	0x1408	; 0x1408 <USI_SPITransmitWord>
		while (USI_SPITransmitWord(0x0000) & 0x01);
    2b4a:	80 e0       	ldi	r24, 0x00	; 0
    2b4c:	90 e0       	ldi	r25, 0x00	; 0
    2b4e:	0e 94 04 0a 	call	0x1408	; 0x1408 <USI_SPITransmitWord>
    2b52:	80 ff       	sbrs	r24, 0
    2b54:	08 c0       	rjmp	.+16     	; 0x2b66 <PM_SendEraseCommand+0x52>
    2b56:	f5 cf       	rjmp	.-22     	; 0x2b42 <PM_SendEraseCommand+0x2e>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2b58:	26 97       	sbiw	r28, 0x06	; 6
    2b5a:	de 01       	movw	r26, r28
    2b5c:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
    2b60:	80 2d       	mov	r24, r0
	}
	else                                                                // Cleared flag means use a predefined delay
	{		
		MAIN_Delay1MS(eeprom_read_byte(&EEPROMVars.EraseChip[1]));      // Wait the erase delay
    2b62:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2b66:	df 91       	pop	r29
    2b68:	cf 91       	pop	r28
    2b6a:	08 95       	ret

00002b6c <PM_CreateProgrammingPackets>:
	}
}

void PM_CreateProgrammingPackets(const uint8_t Type)
{			
    2b6c:	3f 92       	push	r3
    2b6e:	4f 92       	push	r4
    2b70:	5f 92       	push	r5
    2b72:	6f 92       	push	r6
    2b74:	7f 92       	push	r7
    2b76:	8f 92       	push	r8
    2b78:	9f 92       	push	r9
    2b7a:	af 92       	push	r10
    2b7c:	bf 92       	push	r11
    2b7e:	cf 92       	push	r12
    2b80:	df 92       	push	r13
    2b82:	ef 92       	push	r14
    2b84:	ff 92       	push	r15
    2b86:	0f 93       	push	r16
    2b88:	1f 93       	push	r17
    2b8a:	cf 93       	push	r28
    2b8c:	df 93       	push	r29
    2b8e:	18 2f       	mov	r17, r24
	uint32_t BytesRead       = 0;
	uint32_t BytesToRead     = PM_GetStoredDataSize(Type);              // Get the byte size of the stored program
    2b90:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <PM_GetStoredDataSize>
    2b94:	2b 01       	movw	r4, r22
    2b96:	3c 01       	movw	r6, r24
	uint16_t BytesPerProgram;
	uint16_t PageLength      = eeprom_read_word((Type == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength);
    2b98:	11 30       	cpi	r17, 0x01	; 1
    2b9a:	09 f0       	breq	.+2      	; 0x2b9e <PM_CreateProgrammingPackets+0x32>
    2b9c:	e6 c0       	rjmp	.+460    	; 0x2d6a <PM_CreateProgrammingPackets+0x1fe>
eeprom_read_word (const uint16_t *addr)
{
  uint16_t result;

  asm ( 
    2b9e:	a5 e8       	ldi	r26, 0x85	; 133
    2ba0:	b0 e0       	ldi	r27, 0x00	; 0
    2ba2:	0e 94 9d 1a 	call	0x353a	; 0x353a <__eeprom_read_word_1F2021>
    2ba6:	4f 01       	movw	r8, r30
	uint8_t  ContinuedPage   = FALSE;
	uint8_t* EEPROMAddress;

	CurrAddress = 0;
    2ba8:	10 92 a9 02 	sts	0x02A9, r1
    2bac:	10 92 aa 02 	sts	0x02AA, r1
    2bb0:	10 92 ab 02 	sts	0x02AB, r1
    2bb4:	10 92 ac 02 	sts	0x02AC, r1

	if (Type == TYPE_FLASH)
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram;             // Set the EEPROM pointer to the write flash command bytes location
		DF_ContinuousReadEnable(0, 0);
    2bb8:	60 e0       	ldi	r22, 0x00	; 0
    2bba:	70 e0       	ldi	r23, 0x00	; 0
    2bbc:	80 e0       	ldi	r24, 0x00	; 0
    2bbe:	90 e0       	ldi	r25, 0x00	; 0
    2bc0:	0e 94 90 0a 	call	0x1520	; 0x1520 <DF_ContinuousReadEnable>
		PacketBytes[0] = AICB_CMD_PROGRAM_FLASH_ISP;
    2bc4:	83 e1       	ldi	r24, 0x13	; 19
    2bc6:	80 93 91 01 	sts	0x0191, r24
    2bca:	03 e0       	ldi	r16, 0x03	; 3
    2bcc:	10 e0       	ldi	r17, 0x00	; 0
	}
	else
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;              // Set the EEPROM pointer to the write EEPROM command bytes location
		DF_ContinuousReadEnable(PM_EEPROM_OFFSET / DF_INTERNALDF_BUFFBYTES, PM_EEPROM_OFFSET % DF_INTERNALDF_BUFFBYTES); // Start read from the EEPROM offset location
		PacketBytes[0] = AICB_CMD_PROGRAM_EEPROM_ISP;
	}

	// DEBUG:
	USART_ENABLE(1,0);
    2bce:	87 ea       	ldi	r24, 0xA7	; 167
    2bd0:	90 e0       	ldi	r25, 0x00	; 0
    2bd2:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_puts_f>
    2bd6:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <OSCCAL_Calibrate>
    2bda:	80 91 c1 00 	lds	r24, 0x00C1
    2bde:	80 78       	andi	r24, 0x80	; 128
    2be0:	88 60       	ori	r24, 0x08	; 8
    2be2:	80 93 c1 00 	sts	0x00C1, r24
    2be6:	c1 e9       	ldi	r28, 0x91	; 145
    2be8:	d1 e0       	ldi	r29, 0x01	; 1

	for (uint8_t B = 0; B < 9 ; B++)                                    // Load in the write data command bytes
	{
		EEPROMAddress++;                                                // Increment the EEPROM location counter
    2bea:	0f 5f       	subi	r16, 0xFF	; 255
    2bec:	1f 4f       	sbci	r17, 0xFF	; 255
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2bee:	d8 01       	movw	r26, r16
    2bf0:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
    2bf4:	80 2d       	mov	r24, r0
		PacketBytes[B] = eeprom_read_byte(EEPROMAddress);               // Synthesise a write packet header
    2bf6:	99 27       	eor	r25, r25
    2bf8:	89 93       	st	Y+, r24

		USART_Tx(PacketBytes[B]);
    2bfa:	0e 94 85 09 	call	0x130a	; 0x130a <USART_Tx>
    2bfe:	f1 e0       	ldi	r31, 0x01	; 1
    2c00:	ca 39       	cpi	r28, 0x9A	; 154
    2c02:	df 07       	cpc	r29, r31
    2c04:	91 f7       	brne	.-28     	; 0x2bea <PM_CreateProgrammingPackets+0x7e>
	}
	
	BytesPerProgram = ((uint16_t)PacketBytes[1] << 8)
    2c06:	80 91 92 01 	lds	r24, 0x0192
    2c0a:	99 27       	eor	r25, r25
    2c0c:	d8 2f       	mov	r29, r24
    2c0e:	cc 27       	eor	r28, r28
    2c10:	80 91 93 01 	lds	r24, 0x0193
    2c14:	99 27       	eor	r25, r25
    2c16:	c8 2b       	or	r28, r24
    2c18:	d9 2b       	or	r29, r25
    2c1a:	aa 24       	eor	r10, r10
    2c1c:	bb 24       	eor	r11, r11
    2c1e:	65 01       	movw	r12, r10
    2c20:	33 24       	eor	r3, r3
    2c22:	9c c0       	rjmp	.+312    	; 0x2d5c <PM_CreateProgrammingPackets+0x1f0>
	                | PacketBytes[2];

	while (BytesRead < BytesToRead)
	{
		if (PacketBytes[3] & ISPCC_PROG_MODE_PAGE)
    2c24:	80 91 94 01 	lds	r24, 0x0194
    2c28:	80 ff       	sbrs	r24, 0
    2c2a:	4b c0       	rjmp	.+150    	; 0x2cc2 <PM_CreateProgrammingPackets+0x156>
		{
			if (PageLength > 160)                                       // Max 160 bytes at a time
    2c2c:	91 ea       	ldi	r25, 0xA1	; 161
    2c2e:	89 16       	cp	r8, r25
    2c30:	91 04       	cpc	r9, r1
    2c32:	18 f4       	brcc	.+6      	; 0x2c3a <PM_CreateProgrammingPackets+0xce>
    2c34:	01 e9       	ldi	r16, 0x91	; 145
    2c36:	11 e0       	ldi	r17, 0x01	; 1
    2c38:	2f c0       	rjmp	.+94     	; 0x2c98 <PM_CreateProgrammingPackets+0x12c>
			{
				if (!(ContinuedPage))                                   // Start of a new page, program in the first 150 bytes
    2c3a:	33 20       	and	r3, r3
    2c3c:	41 f4       	brne	.+16     	; 0x2c4e <PM_CreateProgrammingPackets+0xe2>
				{
					BytesPerProgram = 160;
					PacketBytes[3] &= ~ISPCC_PROG_MODE_PAGEDONE;		
    2c3e:	8f 77       	andi	r24, 0x7F	; 127
    2c40:	80 93 94 01 	sts	0x0194, r24
    2c44:	c0 ea       	ldi	r28, 0xA0	; 160
    2c46:	d0 e0       	ldi	r29, 0x00	; 0
    2c48:	11 e0       	ldi	r17, 0x01	; 1
    2c4a:	31 2e       	mov	r3, r17
    2c4c:	07 c0       	rjmp	.+14     	; 0x2c5c <PM_CreateProgrammingPackets+0xf0>
					ContinuedPage   = TRUE;
				}
				else                                                    // Middle of a page, program in the remainder
				{
					BytesPerProgram = PageLength - 160;
    2c4e:	e4 01       	movw	r28, r8
    2c50:	c0 5a       	subi	r28, 0xA0	; 160
    2c52:	d0 40       	sbci	r29, 0x00	; 0
					PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
    2c54:	80 68       	ori	r24, 0x80	; 128
    2c56:	80 93 94 01 	sts	0x0194, r24
    2c5a:	33 24       	eor	r3, r3
    2c5c:	01 e9       	ldi	r16, 0x91	; 145
    2c5e:	11 e0       	ldi	r17, 0x01	; 1
    2c60:	07 c0       	rjmp	.+14     	; 0x2c70 <PM_CreateProgrammingPackets+0x104>
					ContinuedPage   = FALSE;
				}
				
				for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
				  PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);    // Load in the page				
    2c62:	80 e0       	ldi	r24, 0x00	; 0
    2c64:	0e 94 b2 09 	call	0x1364	; 0x1364 <SPI_SPITransmit>
    2c68:	f8 01       	movw	r30, r16
    2c6a:	82 87       	std	Z+10, r24	; 0x0a
    2c6c:	0f 5f       	subi	r16, 0xFF	; 255
    2c6e:	1f 4f       	sbci	r17, 0xFF	; 255
    2c70:	ce 01       	movw	r24, r28
    2c72:	8f 56       	subi	r24, 0x6F	; 111
    2c74:	9e 4f       	sbci	r25, 0xFE	; 254
    2c76:	08 17       	cp	r16, r24
    2c78:	19 07       	cpc	r17, r25
    2c7a:	99 f7       	brne	.-26     	; 0x2c62 <PM_CreateProgrammingPackets+0xf6>

				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);
    2c7c:	8d 2f       	mov	r24, r29
    2c7e:	99 27       	eor	r25, r25
    2c80:	80 93 92 01 	sts	0x0192, r24
				PacketBytes[2] = (uint8_t)(BytesPerProgram);
    2c84:	c0 93 93 01 	sts	0x0193, r28
    2c88:	41 c0       	rjmp	.+130    	; 0x2d0c <PM_CreateProgrammingPackets+0x1a0>

				BytesRead += BytesPerProgram;                           // Increment the counter
			}
			else
			{
				for (uint16_t LoadB = 0; LoadB < PageLength; LoadB++)
				  PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);    // Load in the page
    2c8a:	80 e0       	ldi	r24, 0x00	; 0
    2c8c:	0e 94 b2 09 	call	0x1364	; 0x1364 <SPI_SPITransmit>
    2c90:	f8 01       	movw	r30, r16
    2c92:	82 87       	std	Z+10, r24	; 0x0a
    2c94:	0f 5f       	subi	r16, 0xFF	; 255
    2c96:	1f 4f       	sbci	r17, 0xFF	; 255
    2c98:	c4 01       	movw	r24, r8
    2c9a:	8f 56       	subi	r24, 0x6F	; 111
    2c9c:	9e 4f       	sbci	r25, 0xFE	; 254
    2c9e:	08 17       	cp	r16, r24
    2ca0:	19 07       	cpc	r17, r25
    2ca2:	99 f7       	brne	.-26     	; 0x2c8a <PM_CreateProgrammingPackets+0x11e>
			
				PacketBytes[1]  = (uint8_t)(PageLength >> 8);
    2ca4:	89 2d       	mov	r24, r9
    2ca6:	99 27       	eor	r25, r25
    2ca8:	80 93 92 01 	sts	0x0192, r24
				PacketBytes[2]  = (uint8_t)(PageLength);
    2cac:	80 92 93 01 	sts	0x0193, r8
				PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
    2cb0:	80 91 94 01 	lds	r24, 0x0194
    2cb4:	80 68       	ori	r24, 0x80	; 128
    2cb6:	80 93 94 01 	sts	0x0194, r24

				BytesRead += PageLength;                                // Increment the counter
    2cba:	c4 01       	movw	r24, r8
    2cbc:	aa 27       	eor	r26, r26
    2cbe:	bb 27       	eor	r27, r27
    2cc0:	28 c0       	rjmp	.+80     	; 0x2d12 <PM_CreateProgrammingPackets+0x1a6>
			}
		}
		else
		{
			if ((BytesRead + BytesPerProgram) > BytesToRead)            // Less than a whole BytesPerProgram left of data to write
    2cc2:	ce 01       	movw	r24, r28
    2cc4:	aa 27       	eor	r26, r26
    2cc6:	bb 27       	eor	r27, r27
    2cc8:	8a 0d       	add	r24, r10
    2cca:	9b 1d       	adc	r25, r11
    2ccc:	ac 1d       	adc	r26, r12
    2cce:	bd 1d       	adc	r27, r13
    2cd0:	48 16       	cp	r4, r24
    2cd2:	59 06       	cpc	r5, r25
    2cd4:	6a 06       	cpc	r6, r26
    2cd6:	7b 06       	cpc	r7, r27
    2cd8:	48 f4       	brcc	.+18     	; 0x2cec <PM_CreateProgrammingPackets+0x180>
			{
				BytesPerProgram = BytesToRead - BytesRead;              // Next lot of bytes will be the remaining data length
    2cda:	e2 01       	movw	r28, r4
    2cdc:	ca 19       	sub	r28, r10
    2cde:	db 09       	sbc	r29, r11
				PacketBytes[1]  = (uint8_t)(BytesPerProgram >> 8);       // \. Save the new length
    2ce0:	8d 2f       	mov	r24, r29
    2ce2:	99 27       	eor	r25, r25
    2ce4:	80 93 92 01 	sts	0x0192, r24
				PacketBytes[2]  = (uint8_t)(BytesPerProgram);            // /  into the data packet
    2ce8:	c0 93 93 01 	sts	0x0193, r28
    2cec:	01 e9       	ldi	r16, 0x91	; 145
    2cee:	11 e0       	ldi	r17, 0x01	; 1
    2cf0:	07 c0       	rjmp	.+14     	; 0x2d00 <PM_CreateProgrammingPackets+0x194>
			}

			for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
			  PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);          // Load in the page
    2cf2:	80 e0       	ldi	r24, 0x00	; 0
    2cf4:	0e 94 b2 09 	call	0x1364	; 0x1364 <SPI_SPITransmit>
    2cf8:	f8 01       	movw	r30, r16
    2cfa:	82 87       	std	Z+10, r24	; 0x0a
    2cfc:	0f 5f       	subi	r16, 0xFF	; 255
    2cfe:	1f 4f       	sbci	r17, 0xFF	; 255
    2d00:	ce 01       	movw	r24, r28
    2d02:	8f 56       	subi	r24, 0x6F	; 111
    2d04:	9e 4f       	sbci	r25, 0xFE	; 254
    2d06:	08 17       	cp	r16, r24
    2d08:	19 07       	cpc	r17, r25
    2d0a:	99 f7       	brne	.-26     	; 0x2cf2 <PM_CreateProgrammingPackets+0x186>
		
			BytesRead += BytesPerProgram;                               // Increment the counter
    2d0c:	ce 01       	movw	r24, r28
    2d0e:	aa 27       	eor	r26, r26
    2d10:	bb 27       	eor	r27, r27
    2d12:	a8 0e       	add	r10, r24
    2d14:	b9 1e       	adc	r11, r25
    2d16:	ca 1e       	adc	r12, r26
    2d18:	db 1e       	adc	r13, r27
		}
	
		if (!(BytesRead & 0xFFFF) && (BytesRead & 0x00FF0000))          // Extended address required
    2d1a:	a1 14       	cp	r10, r1
    2d1c:	b1 04       	cpc	r11, r1
    2d1e:	e1 f4       	brne	.+56     	; 0x2d58 <PM_CreateProgrammingPackets+0x1ec>
    2d20:	e1 2c       	mov	r14, r1
    2d22:	f1 2c       	mov	r15, r1
    2d24:	ef ef       	ldi	r30, 0xFF	; 255
    2d26:	0e 2f       	mov	r16, r30
    2d28:	11 2d       	mov	r17, r1
    2d2a:	ea 20       	and	r14, r10
    2d2c:	fb 20       	and	r15, r11
    2d2e:	0c 21       	and	r16, r12
    2d30:	1d 21       	and	r17, r13
    2d32:	e1 14       	cp	r14, r1
    2d34:	f1 04       	cpc	r15, r1
    2d36:	01 05       	cpc	r16, r1
    2d38:	11 05       	cpc	r17, r1
    2d3a:	71 f0       	breq	.+28     	; 0x2d58 <PM_CreateProgrammingPackets+0x1ec>
		{
			USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);                // Load extended address command
    2d3c:	8d e4       	ldi	r24, 0x4D	; 77
    2d3e:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
			USI_SPITransmit(0x00);
    2d42:	80 e0       	ldi	r24, 0x00	; 0
    2d44:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
			USI_SPITransmit((BytesRead & 0x00FF0000) >> 16);            // The 3rd byte of the long holds the extended address
    2d48:	c8 01       	movw	r24, r16
    2d4a:	aa 27       	eor	r26, r26
    2d4c:	bb 27       	eor	r27, r27
    2d4e:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
			USI_SPITransmit(0x00);
    2d52:	80 e0       	ldi	r24, 0x00	; 0
    2d54:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <USI_SPITransmit>
		}

		ISPCC_ProgramChip();                                            // Start the program cycle
    2d58:	0e 94 8b 11 	call	0x2316	; 0x2316 <ISPCC_ProgramChip>
    2d5c:	a4 14       	cp	r10, r4
    2d5e:	b5 04       	cpc	r11, r5
    2d60:	c6 04       	cpc	r12, r6
    2d62:	d7 04       	cpc	r13, r7
    2d64:	08 f4       	brcc	.+2      	; 0x2d68 <PM_CreateProgrammingPackets+0x1fc>
    2d66:	5e cf       	rjmp	.-324    	; 0x2c24 <PM_CreateProgrammingPackets+0xb8>
    2d68:	19 c0       	rjmp	.+50     	; 0x2d9c <PM_CreateProgrammingPackets+0x230>
eeprom_read_word (const uint16_t *addr)
{
  uint16_t result;

  asm ( 
    2d6a:	a7 e8       	ldi	r26, 0x87	; 135
    2d6c:	b0 e0       	ldi	r27, 0x00	; 0
    2d6e:	0e 94 9d 1a 	call	0x353a	; 0x353a <__eeprom_read_word_1F2021>
    2d72:	4f 01       	movw	r8, r30
    2d74:	10 92 a9 02 	sts	0x02A9, r1
    2d78:	10 92 aa 02 	sts	0x02AA, r1
    2d7c:	10 92 ab 02 	sts	0x02AB, r1
    2d80:	10 92 ac 02 	sts	0x02AC, r1
    2d84:	60 ee       	ldi	r22, 0xE0	; 224
    2d86:	70 e0       	ldi	r23, 0x00	; 0
    2d88:	84 ee       	ldi	r24, 0xE4	; 228
    2d8a:	93 e0       	ldi	r25, 0x03	; 3
    2d8c:	0e 94 90 0a 	call	0x1520	; 0x1520 <DF_ContinuousReadEnable>
    2d90:	85 e1       	ldi	r24, 0x15	; 21
    2d92:	80 93 91 01 	sts	0x0191, r24
    2d96:	0d e0       	ldi	r16, 0x0D	; 13
    2d98:	10 e0       	ldi	r17, 0x00	; 0
    2d9a:	19 cf       	rjmp	.-462    	; 0x2bce <PM_CreateProgrammingPackets+0x62>
    2d9c:	df 91       	pop	r29
    2d9e:	cf 91       	pop	r28
    2da0:	1f 91       	pop	r17
    2da2:	0f 91       	pop	r16
    2da4:	ff 90       	pop	r15
    2da6:	ef 90       	pop	r14
    2da8:	df 90       	pop	r13
    2daa:	cf 90       	pop	r12
    2dac:	bf 90       	pop	r11
    2dae:	af 90       	pop	r10
    2db0:	9f 90       	pop	r9
    2db2:	8f 90       	pop	r8
    2db4:	7f 90       	pop	r7
    2db6:	6f 90       	pop	r6
    2db8:	5f 90       	pop	r5
    2dba:	4f 90       	pop	r4
    2dbc:	3f 90       	pop	r3
    2dbe:	08 95       	ret

00002dc0 <PM_ShowStoredItemSizes>:
	}
}

void PM_ShowStoredItemSizes(void)
{
    2dc0:	1f 93       	push	r17
    2dc2:	cf 93       	push	r28
    2dc4:	df 93       	push	r29
    2dc6:	cd b7       	in	r28, 0x3d	; 61
    2dc8:	de b7       	in	r29, 0x3e	; 62
    2dca:	2e 97       	sbiw	r28, 0x0e	; 14
    2dcc:	0f b6       	in	r0, 0x3f	; 63
    2dce:	f8 94       	cli
    2dd0:	de bf       	out	0x3e, r29	; 62
    2dd2:	0f be       	out	0x3f, r0	; 63
    2dd4:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[14];
	uint8_t ItemInfoIndex = 0;
	uint8_t TempB;
	
	JoyStatus = 1;
    2dd6:	81 e0       	ldi	r24, 0x01	; 1
    2dd8:	8e bb       	out	0x1e, r24	; 30
    2dda:	10 e0       	ldi	r17, 0x00	; 0
	
	for (;;)
	{
		if (JoyStatus)
    2ddc:	8e b3       	in	r24, 0x1e	; 30
    2dde:	88 23       	and	r24, r24
    2de0:	e9 f3       	breq	.-6      	; 0x2ddc <PM_ShowStoredItemSizes+0x1c>
		{
			if (JoyStatus & JOY_UP)
    2de2:	f6 9b       	sbis	0x1e, 6	; 30
    2de4:	04 c0       	rjmp	.+8      	; 0x2dee <PM_ShowStoredItemSizes+0x2e>
			  (ItemInfoIndex == 0)? ItemInfoIndex = 3 : ItemInfoIndex--;
    2de6:	11 23       	and	r17, r17
    2de8:	81 f1       	breq	.+96     	; 0x2e4a <PM_ShowStoredItemSizes+0x8a>
    2dea:	11 50       	subi	r17, 0x01	; 1
    2dec:	0a c0       	rjmp	.+20     	; 0x2e02 <PM_ShowStoredItemSizes+0x42>
			else if (JoyStatus & JOY_DOWN)
    2dee:	f7 9b       	sbis	0x1e, 7	; 30
    2df0:	06 c0       	rjmp	.+12     	; 0x2dfe <PM_ShowStoredItemSizes+0x3e>
			  (ItemInfoIndex == 3)? ItemInfoIndex = 0 : ItemInfoIndex++;
    2df2:	13 30       	cpi	r17, 0x03	; 3
    2df4:	11 f4       	brne	.+4      	; 0x2dfa <PM_ShowStoredItemSizes+0x3a>
    2df6:	10 e0       	ldi	r17, 0x00	; 0
    2df8:	0d c0       	rjmp	.+26     	; 0x2e14 <PM_ShowStoredItemSizes+0x54>
    2dfa:	1f 5f       	subi	r17, 0xFF	; 255
    2dfc:	02 c0       	rjmp	.+4      	; 0x2e02 <PM_ShowStoredItemSizes+0x42>
			else if (JoyStatus & JOY_LEFT)
    2dfe:	f2 99       	sbic	0x1e, 2	; 30
    2e00:	49 c0       	rjmp	.+146    	; 0x2e94 <PM_ShowStoredItemSizes+0xd4>
			  return;
		
			switch (ItemInfoIndex)
    2e02:	11 30       	cpi	r17, 0x01	; 1
    2e04:	79 f0       	breq	.+30     	; 0x2e24 <PM_ShowStoredItemSizes+0x64>
    2e06:	11 30       	cpi	r17, 0x01	; 1
    2e08:	28 f0       	brcs	.+10     	; 0x2e14 <PM_ShowStoredItemSizes+0x54>
    2e0a:	12 30       	cpi	r17, 0x02	; 2
    2e0c:	a9 f0       	breq	.+42     	; 0x2e38 <PM_ShowStoredItemSizes+0x78>
    2e0e:	13 30       	cpi	r17, 0x03	; 3
    2e10:	d1 f5       	brne	.+116    	; 0x2e86 <PM_ShowStoredItemSizes+0xc6>
    2e12:	1c c0       	rjmp	.+56     	; 0x2e4c <PM_ShowStoredItemSizes+0x8c>
			{
				case 0:
					strcpy_P(Buffer, PSTR("DATA-"));
    2e14:	68 e5       	ldi	r22, 0x58	; 88
    2e16:	74 e0       	ldi	r23, 0x04	; 4
    2e18:	ce 01       	movw	r24, r28
    2e1a:	01 96       	adiw	r24, 0x01	; 1
    2e1c:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_FLASH), &Buffer[5], 10);
    2e20:	81 e0       	ldi	r24, 0x01	; 1
    2e22:	07 c0       	rjmp	.+14     	; 0x2e32 <PM_ShowStoredItemSizes+0x72>
					break;
				case 1:
					strcpy_P(Buffer, PSTR("EPRM-"));
    2e24:	62 e5       	ldi	r22, 0x52	; 82
    2e26:	74 e0       	ldi	r23, 0x04	; 4
    2e28:	ce 01       	movw	r24, r28
    2e2a:	01 96       	adiw	r24, 0x01	; 1
    2e2c:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_EEPROM), &Buffer[5], 10);
    2e30:	80 e0       	ldi	r24, 0x00	; 0
    2e32:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <PM_GetStoredDataSize>
    2e36:	20 c0       	rjmp	.+64     	; 0x2e78 <PM_ShowStoredItemSizes+0xb8>
					break;
				case 2:
					strcpy_P(Buffer, PSTR("FUSE-"));
    2e38:	6c e4       	ldi	r22, 0x4C	; 76
    2e3a:	74 e0       	ldi	r23, 0x04	; 4
    2e3c:	ce 01       	movw	r24, r28
    2e3e:	01 96       	adiw	r24, 0x01	; 1
    2e40:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <strcpy_P>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2e44:	a3 e3       	ldi	r26, 0x33	; 51
    2e46:	b0 e0       	ldi	r27, 0x00	; 0
    2e48:	09 c0       	rjmp	.+18     	; 0x2e5c <PM_ShowStoredItemSizes+0x9c>
					TempB = eeprom_read_byte(&EEPROMVars.TotalFuseBytes);
					ultoa(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5], 10);
					break;
    2e4a:	13 e0       	ldi	r17, 0x03	; 3
				case 3:
					strcpy_P(Buffer, PSTR("LOCK-"));
    2e4c:	66 e4       	ldi	r22, 0x46	; 70
    2e4e:	74 e0       	ldi	r23, 0x04	; 4
    2e50:	ce 01       	movw	r24, r28
    2e52:	01 96       	adiw	r24, 0x01	; 1
    2e54:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <strcpy_P>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2e58:	a4 e3       	ldi	r26, 0x34	; 52
    2e5a:	b0 e0       	ldi	r27, 0x00	; 0
    2e5c:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
    2e60:	80 2d       	mov	r24, r0
					TempB = eeprom_read_byte(&EEPROMVars.TotalLockBytes);
					ultoa(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5], 10);
    2e62:	8f 3f       	cpi	r24, 0xFF	; 255
    2e64:	29 f4       	brne	.+10     	; 0x2e70 <PM_ShowStoredItemSizes+0xb0>
    2e66:	60 e0       	ldi	r22, 0x00	; 0
    2e68:	70 e0       	ldi	r23, 0x00	; 0
    2e6a:	80 e0       	ldi	r24, 0x00	; 0
    2e6c:	90 e0       	ldi	r25, 0x00	; 0
    2e6e:	04 c0       	rjmp	.+8      	; 0x2e78 <PM_ShowStoredItemSizes+0xb8>
    2e70:	68 2f       	mov	r22, r24
    2e72:	77 27       	eor	r23, r23
    2e74:	88 27       	eor	r24, r24
    2e76:	99 27       	eor	r25, r25
    2e78:	2a e0       	ldi	r18, 0x0A	; 10
    2e7a:	30 e0       	ldi	r19, 0x00	; 0
    2e7c:	ae 01       	movw	r20, r28
    2e7e:	4a 5f       	subi	r20, 0xFA	; 250
    2e80:	5f 4f       	sbci	r21, 0xFF	; 255
    2e82:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <ultoa>
			}
	
			LCD_puts(Buffer);
    2e86:	ce 01       	movw	r24, r28
    2e88:	01 96       	adiw	r24, 0x01	; 1
    2e8a:	0e 94 7f 08 	call	0x10fe	; 0x10fe <LCD_puts>

			MAIN_WaitForJoyRelease();
    2e8e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
    2e92:	a4 cf       	rjmp	.-184    	; 0x2ddc <PM_ShowStoredItemSizes+0x1c>
    2e94:	2e 96       	adiw	r28, 0x0e	; 14
    2e96:	0f b6       	in	r0, 0x3f	; 63
    2e98:	f8 94       	cli
    2e9a:	de bf       	out	0x3e, r29	; 62
    2e9c:	0f be       	out	0x3f, r0	; 63
    2e9e:	cd bf       	out	0x3d, r28	; 61
    2ea0:	df 91       	pop	r29
    2ea2:	cf 91       	pop	r28
    2ea4:	1f 91       	pop	r17
    2ea6:	08 95       	ret

00002ea8 <PM_InterpretAVRISPPacket>:
    2ea8:	ef 92       	push	r14
    2eaa:	ff 92       	push	r15
    2eac:	0f 93       	push	r16
    2eae:	1f 93       	push	r17
    2eb0:	cf 93       	push	r28
    2eb2:	df 93       	push	r29
    2eb4:	20 91 91 01 	lds	r18, 0x0191
    2eb8:	26 31       	cpi	r18, 0x16	; 22
    2eba:	09 f4       	brne	.+2      	; 0x2ebe <PM_InterpretAVRISPPacket+0x16>
    2ebc:	ae c1       	rjmp	.+860    	; 0x321a <PM_InterpretAVRISPPacket+0x372>
    2ebe:	27 31       	cpi	r18, 0x17	; 23
    2ec0:	78 f4       	brcc	.+30     	; 0x2ee0 <PM_InterpretAVRISPPacket+0x38>
    2ec2:	22 31       	cpi	r18, 0x12	; 18
    2ec4:	09 f4       	brne	.+2      	; 0x2ec8 <PM_InterpretAVRISPPacket+0x20>
    2ec6:	5f c0       	rjmp	.+190    	; 0x2f86 <PM_InterpretAVRISPPacket+0xde>
    2ec8:	23 31       	cpi	r18, 0x13	; 19
    2eca:	30 f4       	brcc	.+12     	; 0x2ed8 <PM_InterpretAVRISPPacket+0x30>
    2ecc:	20 31       	cpi	r18, 0x10	; 16
    2ece:	e9 f0       	breq	.+58     	; 0x2f0a <PM_InterpretAVRISPPacket+0x62>
    2ed0:	21 31       	cpi	r18, 0x11	; 17
    2ed2:	09 f0       	breq	.+2      	; 0x2ed6 <PM_InterpretAVRISPPacket+0x2e>
    2ed4:	08 c2       	rjmp	.+1040   	; 0x32e6 <PM_InterpretAVRISPPacket+0x43e>
    2ed6:	37 c0       	rjmp	.+110    	; 0x2f46 <PM_InterpretAVRISPPacket+0x9e>
    2ed8:	24 31       	cpi	r18, 0x14	; 20
    2eda:	09 f0       	breq	.+2      	; 0x2ede <PM_InterpretAVRISPPacket+0x36>
    2edc:	35 c1       	rjmp	.+618    	; 0x3148 <PM_InterpretAVRISPPacket+0x2a0>
    2ede:	9d c1       	rjmp	.+826    	; 0x321a <PM_InterpretAVRISPPacket+0x372>
    2ee0:	29 31       	cpi	r18, 0x19	; 25
    2ee2:	09 f4       	brne	.+2      	; 0x2ee6 <PM_InterpretAVRISPPacket+0x3e>
    2ee4:	8c c0       	rjmp	.+280    	; 0x2ffe <PM_InterpretAVRISPPacket+0x156>
    2ee6:	2a 31       	cpi	r18, 0x1A	; 26
    2ee8:	38 f4       	brcc	.+14     	; 0x2ef8 <PM_InterpretAVRISPPacket+0x50>
    2eea:	27 31       	cpi	r18, 0x17	; 23
    2eec:	09 f4       	brne	.+2      	; 0x2ef0 <PM_InterpretAVRISPPacket+0x48>
    2eee:	87 c0       	rjmp	.+270    	; 0x2ffe <PM_InterpretAVRISPPacket+0x156>
    2ef0:	28 31       	cpi	r18, 0x18	; 24
    2ef2:	09 f0       	breq	.+2      	; 0x2ef6 <PM_InterpretAVRISPPacket+0x4e>
    2ef4:	f8 c1       	rjmp	.+1008   	; 0x32e6 <PM_InterpretAVRISPPacket+0x43e>
    2ef6:	d6 c0       	rjmp	.+428    	; 0x30a4 <PM_InterpretAVRISPPacket+0x1fc>
    2ef8:	2b 31       	cpi	r18, 0x1B	; 27
    2efa:	c9 f1       	breq	.+114    	; 0x2f6e <PM_InterpretAVRISPPacket+0xc6>
    2efc:	2b 31       	cpi	r18, 0x1B	; 27
    2efe:	08 f4       	brcc	.+2      	; 0x2f02 <PM_InterpretAVRISPPacket+0x5a>
    2f00:	d1 c0       	rjmp	.+418    	; 0x30a4 <PM_InterpretAVRISPPacket+0x1fc>
    2f02:	2c 31       	cpi	r18, 0x1C	; 28
    2f04:	09 f0       	breq	.+2      	; 0x2f08 <PM_InterpretAVRISPPacket+0x60>
    2f06:	ef c1       	rjmp	.+990    	; 0x32e6 <PM_InterpretAVRISPPacket+0x43e>
    2f08:	6d c0       	rjmp	.+218    	; 0x2fe4 <PM_InterpretAVRISPPacket+0x13c>
    2f0a:	82 e0       	ldi	r24, 0x02	; 2
    2f0c:	90 e0       	ldi	r25, 0x00	; 0
    2f0e:	90 93 a7 02 	sts	0x02A7, r25
    2f12:	80 93 a6 02 	sts	0x02A6, r24
    2f16:	e1 e9       	ldi	r30, 0x91	; 145
    2f18:	f1 e0       	ldi	r31, 0x01	; 1
    2f1a:	27 e2       	ldi	r18, 0x27	; 39
    2f1c:	30 e0       	ldi	r19, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2f1e:	81 91       	ld	r24, Z+
    2f20:	d9 01       	movw	r26, r18
    2f22:	08 2e       	mov	r0, r24
    2f24:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
    2f28:	2f 5f       	subi	r18, 0xFF	; 255
    2f2a:	3f 4f       	sbci	r19, 0xFF	; 255
    2f2c:	81 e0       	ldi	r24, 0x01	; 1
    2f2e:	ed 39       	cpi	r30, 0x9D	; 157
    2f30:	f8 07       	cpc	r31, r24
    2f32:	a9 f7       	brne	.-22     	; 0x2f1e <PM_InterpretAVRISPPacket+0x76>
    2f34:	81 e0       	ldi	r24, 0x01	; 1
    2f36:	80 93 a8 02 	sts	0x02A8, r24
    2f3a:	10 92 ae 02 	sts	0x02AE, r1
    2f3e:	81 b3       	in	r24, 0x11	; 17
    2f40:	8f 7c       	andi	r24, 0xCF	; 207
    2f42:	80 62       	ori	r24, 0x20	; 32
    2f44:	10 c0       	rjmp	.+32     	; 0x2f66 <PM_InterpretAVRISPPacket+0xbe>
    2f46:	82 e0       	ldi	r24, 0x02	; 2
    2f48:	90 e0       	ldi	r25, 0x00	; 0
    2f4a:	90 93 a7 02 	sts	0x02A7, r25
    2f4e:	80 93 a6 02 	sts	0x02A6, r24
    2f52:	0e 94 7e 14 	call	0x28fc	; 0x28fc <PM_CheckEndOfFuseLockData>
    2f56:	10 92 a8 02 	sts	0x02A8, r1
    2f5a:	80 e0       	ldi	r24, 0x00	; 0
    2f5c:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    2f60:	81 b3       	in	r24, 0x11	; 17
    2f62:	8f 7c       	andi	r24, 0xCF	; 207
    2f64:	80 61       	ori	r24, 0x10	; 16
    2f66:	81 bb       	out	0x11, r24	; 17
    2f68:	10 92 92 01 	sts	0x0192, r1
    2f6c:	c5 c1       	rjmp	.+906    	; 0x32f8 <PM_InterpretAVRISPPacket+0x450>
    2f6e:	84 e0       	ldi	r24, 0x04	; 4
    2f70:	90 e0       	ldi	r25, 0x00	; 0
    2f72:	90 93 a7 02 	sts	0x02A7, r25
    2f76:	80 93 a6 02 	sts	0x02A6, r24
    2f7a:	10 92 92 01 	sts	0x0192, r1
    2f7e:	81 e0       	ldi	r24, 0x01	; 1
    2f80:	80 93 93 01 	sts	0x0193, r24
    2f84:	39 c0       	rjmp	.+114    	; 0x2ff8 <PM_InterpretAVRISPPacket+0x150>
    2f86:	82 e0       	ldi	r24, 0x02	; 2
    2f88:	90 e0       	ldi	r25, 0x00	; 0
    2f8a:	90 93 a7 02 	sts	0x02A7, r25
    2f8e:	80 93 a6 02 	sts	0x02A6, r24
    2f92:	e2 e9       	ldi	r30, 0x92	; 146
    2f94:	f1 e0       	ldi	r31, 0x01	; 1
    2f96:	29 e1       	ldi	r18, 0x19	; 25
    2f98:	30 e0       	ldi	r19, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2f9a:	81 91       	ld	r24, Z+
    2f9c:	d9 01       	movw	r26, r18
    2f9e:	08 2e       	mov	r0, r24
    2fa0:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
    2fa4:	2f 5f       	subi	r18, 0xFF	; 255
    2fa6:	3f 4f       	sbci	r19, 0xFF	; 255
    2fa8:	91 e0       	ldi	r25, 0x01	; 1
    2faa:	e8 39       	cpi	r30, 0x98	; 152
    2fac:	f9 07       	cpc	r31, r25
    2fae:	a9 f7       	brne	.-22     	; 0x2f9a <PM_InterpretAVRISPPacket+0xf2>
    2fb0:	2f e1       	ldi	r18, 0x1F	; 31
    2fb2:	30 e0       	ldi	r19, 0x00	; 0
    2fb4:	80 e0       	ldi	r24, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2fb6:	d9 01       	movw	r26, r18
    2fb8:	08 2e       	mov	r0, r24
    2fba:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
    2fbe:	d9 01       	movw	r26, r18
    2fc0:	14 96       	adiw	r26, 0x04	; 4
    2fc2:	08 2e       	mov	r0, r24
    2fc4:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
    2fc8:	2f 5f       	subi	r18, 0xFF	; 255
    2fca:	3f 4f       	sbci	r19, 0xFF	; 255
    2fcc:	e0 e0       	ldi	r30, 0x00	; 0
    2fce:	23 32       	cpi	r18, 0x23	; 35
    2fd0:	3e 07       	cpc	r19, r30
    2fd2:	89 f7       	brne	.-30     	; 0x2fb6 <PM_InterpretAVRISPPacket+0x10e>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2fd4:	81 e0       	ldi	r24, 0x01	; 1
    2fd6:	2c 50       	subi	r18, 0x0C	; 12
    2fd8:	30 40       	sbci	r19, 0x00	; 0
    2fda:	d9 01       	movw	r26, r18
    2fdc:	08 2e       	mov	r0, r24
    2fde:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
    2fe2:	c2 cf       	rjmp	.-124    	; 0x2f68 <PM_InterpretAVRISPPacket+0xc0>
    2fe4:	84 e0       	ldi	r24, 0x04	; 4
    2fe6:	90 e0       	ldi	r25, 0x00	; 0
    2fe8:	90 93 a7 02 	sts	0x02A7, r25
    2fec:	80 93 a6 02 	sts	0x02A6, r24
    2ff0:	10 92 92 01 	sts	0x0192, r1
    2ff4:	10 92 93 01 	sts	0x0193, r1
    2ff8:	10 92 94 01 	sts	0x0194, r1
    2ffc:	7d c1       	rjmp	.+762    	; 0x32f8 <PM_InterpretAVRISPPacket+0x450>
    2ffe:	83 e0       	ldi	r24, 0x03	; 3
    3000:	90 e0       	ldi	r25, 0x00	; 0
    3002:	90 93 a7 02 	sts	0x02A7, r25
    3006:	80 93 a6 02 	sts	0x02A6, r24
    300a:	80 91 ae 02 	lds	r24, 0x02AE
    300e:	83 30       	cpi	r24, 0x03	; 3
    3010:	39 f0       	breq	.+14     	; 0x3020 <PM_InterpretAVRISPPacket+0x178>
    3012:	83 e0       	ldi	r24, 0x03	; 3
    3014:	80 93 ae 02 	sts	0x02AE, r24
    3018:	10 92 46 01 	sts	0x0146, r1
    301c:	10 92 45 01 	sts	0x0145, r1
    3020:	40 91 45 01 	lds	r20, 0x0145
    3024:	50 91 46 01 	lds	r21, 0x0146
    3028:	27 31       	cpi	r18, 0x17	; 23
    302a:	69 f4       	brne	.+26     	; 0x3046 <PM_InterpretAVRISPPacket+0x19e>
    302c:	80 ea       	ldi	r24, 0xA0	; 160
    302e:	90 e0       	ldi	r25, 0x00	; 0
    3030:	48 9f       	mul	r20, r24
    3032:	90 01       	movw	r18, r0
    3034:	49 9f       	mul	r20, r25
    3036:	30 0d       	add	r19, r0
    3038:	58 9f       	mul	r21, r24
    303a:	30 0d       	add	r19, r0
    303c:	11 24       	eor	r1, r1
    303e:	2b 5c       	subi	r18, 0xCB	; 203
    3040:	3f 4f       	sbci	r19, 0xFF	; 255
    3042:	82 e0       	ldi	r24, 0x02	; 2
    3044:	0c c0       	rjmp	.+24     	; 0x305e <PM_InterpretAVRISPPacket+0x1b6>
    3046:	80 ea       	ldi	r24, 0xA0	; 160
    3048:	90 e0       	ldi	r25, 0x00	; 0
    304a:	48 9f       	mul	r20, r24
    304c:	90 01       	movw	r18, r0
    304e:	49 9f       	mul	r20, r25
    3050:	30 0d       	add	r19, r0
    3052:	58 9f       	mul	r21, r24
    3054:	30 0d       	add	r19, r0
    3056:	11 24       	eor	r1, r1
    3058:	23 5a       	subi	r18, 0xA3	; 163
    305a:	3f 4f       	sbci	r19, 0xFF	; 255
    305c:	83 e0       	ldi	r24, 0x03	; 3
    305e:	80 93 02 01 	sts	0x0102, r24
    3062:	80 91 45 01 	lds	r24, 0x0145
    3066:	90 91 46 01 	lds	r25, 0x0146
    306a:	0a 97       	sbiw	r24, 0x0a	; 10
    306c:	b0 f4       	brcc	.+44     	; 0x309a <PM_InterpretAVRISPPacket+0x1f2>
    306e:	e2 e9       	ldi	r30, 0x92	; 146
    3070:	f1 e0       	ldi	r31, 0x01	; 1

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    3072:	81 91       	ld	r24, Z+
    3074:	d9 01       	movw	r26, r18
    3076:	08 2e       	mov	r0, r24
    3078:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
    307c:	2f 5f       	subi	r18, 0xFF	; 255
    307e:	3f 4f       	sbci	r19, 0xFF	; 255
    3080:	81 e0       	ldi	r24, 0x01	; 1
    3082:	e6 39       	cpi	r30, 0x96	; 150
    3084:	f8 07       	cpc	r31, r24
    3086:	a9 f7       	brne	.-22     	; 0x3072 <PM_InterpretAVRISPPacket+0x1ca>
    3088:	80 91 45 01 	lds	r24, 0x0145
    308c:	90 91 46 01 	lds	r25, 0x0146
    3090:	01 96       	adiw	r24, 0x01	; 1
    3092:	90 93 46 01 	sts	0x0146, r25
    3096:	80 93 45 01 	sts	0x0145, r24
    309a:	10 92 92 01 	sts	0x0192, r1
    309e:	10 92 93 01 	sts	0x0193, r1
    30a2:	2a c1       	rjmp	.+596    	; 0x32f8 <PM_InterpretAVRISPPacket+0x450>
    30a4:	84 e0       	ldi	r24, 0x04	; 4
    30a6:	90 e0       	ldi	r25, 0x00	; 0
    30a8:	90 93 a7 02 	sts	0x02A7, r25
    30ac:	80 93 a6 02 	sts	0x02A6, r24
    30b0:	80 91 ae 02 	lds	r24, 0x02AE
    30b4:	84 30       	cpi	r24, 0x04	; 4
    30b6:	49 f0       	breq	.+18     	; 0x30ca <PM_InterpretAVRISPPacket+0x222>
    30b8:	0e 94 7e 14 	call	0x28fc	; 0x28fc <PM_CheckEndOfFuseLockData>
    30bc:	10 92 46 01 	sts	0x0146, r1
    30c0:	10 92 45 01 	sts	0x0145, r1
    30c4:	84 e0       	ldi	r24, 0x04	; 4
    30c6:	80 93 ae 02 	sts	0x02AE, r24
    30ca:	40 91 45 01 	lds	r20, 0x0145
    30ce:	50 91 46 01 	lds	r21, 0x0146
    30d2:	20 91 91 01 	lds	r18, 0x0191
    30d6:	28 31       	cpi	r18, 0x18	; 24
    30d8:	19 f0       	breq	.+6      	; 0x30e0 <PM_InterpretAVRISPPacket+0x238>
    30da:	a4 e3       	ldi	r26, 0x34	; 52
    30dc:	b0 e0       	ldi	r27, 0x00	; 0
    30de:	02 c0       	rjmp	.+4      	; 0x30e4 <PM_InterpretAVRISPPacket+0x23c>
    30e0:	a3 e3       	ldi	r26, 0x33	; 51
    30e2:	b0 e0       	ldi	r27, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    30e4:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
    30e8:	80 2d       	mov	r24, r0
    30ea:	99 27       	eor	r25, r25
    30ec:	84 17       	cp	r24, r20
    30ee:	95 07       	cpc	r25, r21
    30f0:	10 f4       	brcc	.+4      	; 0x30f6 <PM_InterpretAVRISPPacket+0x24e>
    30f2:	8f ef       	ldi	r24, 0xFF	; 255
    30f4:	1e c0       	rjmp	.+60     	; 0x3132 <PM_InterpretAVRISPPacket+0x28a>
    30f6:	28 31       	cpi	r18, 0x18	; 24
    30f8:	19 f4       	brne	.+6      	; 0x3100 <PM_InterpretAVRISPPacket+0x258>
    30fa:	25 e3       	ldi	r18, 0x35	; 53
    30fc:	30 e0       	ldi	r19, 0x00	; 0
    30fe:	02 c0       	rjmp	.+4      	; 0x3104 <PM_InterpretAVRISPPacket+0x25c>
    3100:	2d e5       	ldi	r18, 0x5D	; 93
    3102:	30 e0       	ldi	r19, 0x00	; 0
    3104:	80 ea       	ldi	r24, 0xA0	; 160
    3106:	90 e0       	ldi	r25, 0x00	; 0
    3108:	48 9f       	mul	r20, r24
    310a:	d0 01       	movw	r26, r0
    310c:	49 9f       	mul	r20, r25
    310e:	b0 0d       	add	r27, r0
    3110:	58 9f       	mul	r21, r24
    3112:	b0 0d       	add	r27, r0
    3114:	11 24       	eor	r1, r1
    3116:	a2 0f       	add	r26, r18
    3118:	b3 1f       	adc	r27, r19
    311a:	80 91 92 01 	lds	r24, 0x0192
    311e:	28 e2       	ldi	r18, 0x28	; 40
    3120:	82 9f       	mul	r24, r18
    3122:	c0 01       	movw	r24, r0
    3124:	11 24       	eor	r1, r1
    3126:	a8 0f       	add	r26, r24
    3128:	b9 1f       	adc	r27, r25
    312a:	98 97       	sbiw	r26, 0x28	; 40
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    312c:	0e 94 90 1a 	call	0x3520	; 0x3520 <__eeprom_read_byte_1F2021>
    3130:	80 2d       	mov	r24, r0
    3132:	80 93 93 01 	sts	0x0193, r24
    3136:	4f 5f       	subi	r20, 0xFF	; 255
    3138:	5f 4f       	sbci	r21, 0xFF	; 255
    313a:	50 93 46 01 	sts	0x0146, r21
    313e:	40 93 45 01 	sts	0x0145, r20
    3142:	10 92 92 01 	sts	0x0192, r1
    3146:	58 cf       	rjmp	.-336    	; 0x2ff8 <PM_InterpretAVRISPPacket+0x150>
    3148:	82 e0       	ldi	r24, 0x02	; 2
    314a:	90 e0       	ldi	r25, 0x00	; 0
    314c:	90 93 a7 02 	sts	0x02A7, r25
    3150:	80 93 a6 02 	sts	0x02A6, r24
    3154:	80 91 ae 02 	lds	r24, 0x02AE
    3158:	81 30       	cpi	r24, 0x01	; 1
    315a:	11 f1       	breq	.+68     	; 0x31a0 <PM_InterpretAVRISPPacket+0x2f8>
    315c:	23 31       	cpi	r18, 0x13	; 19
    315e:	31 f4       	brne	.+12     	; 0x316c <PM_InterpretAVRISPPacket+0x2c4>
    3160:	81 e0       	ldi	r24, 0x01	; 1
    3162:	0e 94 43 14 	call	0x2886	; 0x2886 <PM_SetupDFAddressCounters>
    3166:	c3 e0       	ldi	r28, 0x03	; 3
    3168:	d0 e0       	ldi	r29, 0x00	; 0
    316a:	05 c0       	rjmp	.+10     	; 0x3176 <PM_InterpretAVRISPPacket+0x2ce>
    316c:	80 e0       	ldi	r24, 0x00	; 0
    316e:	0e 94 43 14 	call	0x2886	; 0x2886 <PM_SetupDFAddressCounters>
    3172:	cd e0       	ldi	r28, 0x0D	; 13
    3174:	d0 e0       	ldi	r29, 0x00	; 0
    3176:	80 91 45 01 	lds	r24, 0x0145
    317a:	90 91 46 01 	lds	r25, 0x0146
    317e:	0e 94 cb 0a 	call	0x1596	; 0x1596 <DF_BufferWriteEnable>
    3182:	81 e0       	ldi	r24, 0x01	; 1
    3184:	80 93 ae 02 	sts	0x02AE, r24
    3188:	e2 e9       	ldi	r30, 0x92	; 146
    318a:	f1 e0       	ldi	r31, 0x01	; 1

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    318c:	81 91       	ld	r24, Z+
    318e:	de 01       	movw	r26, r28
    3190:	08 2e       	mov	r0, r24
    3192:	0e 94 a2 1a 	call	0x3544	; 0x3544 <__eeprom_write_byte_1F2021>
    3196:	21 96       	adiw	r28, 0x01	; 1
    3198:	91 e0       	ldi	r25, 0x01	; 1
    319a:	eb 39       	cpi	r30, 0x9B	; 155
    319c:	f9 07       	cpc	r31, r25
    319e:	b1 f7       	brne	.-20     	; 0x318c <PM_InterpretAVRISPPacket+0x2e4>
    31a0:	80 91 92 01 	lds	r24, 0x0192
    31a4:	99 27       	eor	r25, r25
    31a6:	d8 2f       	mov	r29, r24
    31a8:	cc 27       	eor	r28, r28
    31aa:	80 91 93 01 	lds	r24, 0x0193
    31ae:	99 27       	eor	r25, r25
    31b0:	c8 2b       	or	r28, r24
    31b2:	d9 2b       	or	r29, r25
    31b4:	01 e9       	ldi	r16, 0x91	; 145
    31b6:	11 e0       	ldi	r17, 0x01	; 1
    31b8:	06 c0       	rjmp	.+12     	; 0x31c6 <PM_InterpretAVRISPPacket+0x31e>
    31ba:	f8 01       	movw	r30, r16
    31bc:	82 85       	ldd	r24, Z+10	; 0x0a
    31be:	0e 94 18 15 	call	0x2a30	; 0x2a30 <PM_StoreProgramByte>
    31c2:	0f 5f       	subi	r16, 0xFF	; 255
    31c4:	1f 4f       	sbci	r17, 0xFF	; 255
    31c6:	ce 01       	movw	r24, r28
    31c8:	8f 56       	subi	r24, 0x6F	; 111
    31ca:	9e 4f       	sbci	r25, 0xFE	; 254
    31cc:	08 17       	cp	r16, r24
    31ce:	19 07       	cpc	r17, r25
    31d0:	a1 f7       	brne	.-24     	; 0x31ba <PM_InterpretAVRISPPacket+0x312>
    31d2:	20 91 af 02 	lds	r18, 0x02AF
    31d6:	30 91 b0 02 	lds	r19, 0x02B0
    31da:	37 fd       	sbrc	r19, 7
    31dc:	c5 ce       	rjmp	.-630    	; 0x2f68 <PM_InterpretAVRISPPacket+0xc0>
    31de:	80 91 94 01 	lds	r24, 0x0194
    31e2:	87 ff       	sbrs	r24, 7
    31e4:	c1 ce       	rjmp	.-638    	; 0x2f68 <PM_InterpretAVRISPPacket+0xc0>
    31e6:	21 15       	cp	r18, r1
    31e8:	31 05       	cpc	r19, r1
    31ea:	09 f4       	brne	.+2      	; 0x31ee <PM_InterpretAVRISPPacket+0x346>
    31ec:	bd ce       	rjmp	.-646    	; 0x2f68 <PM_InterpretAVRISPPacket+0xc0>
    31ee:	80 91 02 01 	lds	r24, 0x0102
    31f2:	81 30       	cpi	r24, 0x01	; 1
    31f4:	19 f4       	brne	.+6      	; 0x31fc <PM_InterpretAVRISPPacket+0x354>
    31f6:	a5 e8       	ldi	r26, 0x85	; 133
    31f8:	b0 e0       	ldi	r27, 0x00	; 0
    31fa:	02 c0       	rjmp	.+4      	; 0x3200 <PM_InterpretAVRISPPacket+0x358>
    31fc:	a7 e8       	ldi	r26, 0x87	; 135
    31fe:	b0 e0       	ldi	r27, 0x00	; 0

void 
eeprom_write_word (uint16_t *addr,uint16_t value)
{
  asm volatile (
    3200:	09 01       	movw	r0, r18
    3202:	0e 94 ae 1a 	call	0x355c	; 0x355c <__eeprom_write_word_1F2021>
    3206:	80 91 af 02 	lds	r24, 0x02AF
    320a:	90 91 b0 02 	lds	r25, 0x02B0
    320e:	90 68       	ori	r25, 0x80	; 128
    3210:	90 93 b0 02 	sts	0x02B0, r25
    3214:	80 93 af 02 	sts	0x02AF, r24
    3218:	a7 ce       	rjmp	.-690    	; 0x2f68 <PM_InterpretAVRISPPacket+0xc0>
    321a:	80 91 ae 02 	lds	r24, 0x02AE
    321e:	82 30       	cpi	r24, 0x02	; 2
    3220:	01 f1       	breq	.+64     	; 0x3262 <PM_InterpretAVRISPPacket+0x3ba>
    3222:	0e 94 7e 14 	call	0x28fc	; 0x28fc <PM_CheckEndOfFuseLockData>
    3226:	90 e0       	ldi	r25, 0x00	; 0
    3228:	80 91 91 01 	lds	r24, 0x0191
    322c:	84 31       	cpi	r24, 0x14	; 20
    322e:	09 f4       	brne	.+2      	; 0x3232 <PM_InterpretAVRISPPacket+0x38a>
    3230:	91 e0       	ldi	r25, 0x01	; 1
    3232:	89 2f       	mov	r24, r25
    3234:	0e 94 43 14 	call	0x2886	; 0x2886 <PM_SetupDFAddressCounters>
    3238:	60 91 45 01 	lds	r22, 0x0145
    323c:	70 91 46 01 	lds	r23, 0x0146
    3240:	80 91 43 01 	lds	r24, 0x0143
    3244:	90 91 44 01 	lds	r25, 0x0144
    3248:	0e 94 90 0a 	call	0x1520	; 0x1520 <DF_ContinuousReadEnable>
    324c:	82 e0       	ldi	r24, 0x02	; 2
    324e:	80 93 ae 02 	sts	0x02AE, r24
    3252:	10 92 a9 02 	sts	0x02A9, r1
    3256:	10 92 aa 02 	sts	0x02AA, r1
    325a:	10 92 ab 02 	sts	0x02AB, r1
    325e:	10 92 ac 02 	sts	0x02AC, r1
    3262:	80 91 92 01 	lds	r24, 0x0192
    3266:	99 27       	eor	r25, r25
    3268:	d8 2f       	mov	r29, r24
    326a:	cc 27       	eor	r28, r28
    326c:	80 91 93 01 	lds	r24, 0x0193
    3270:	99 27       	eor	r25, r25
    3272:	c8 2b       	or	r28, r24
    3274:	d9 2b       	or	r29, r25
    3276:	90 e0       	ldi	r25, 0x00	; 0
    3278:	80 91 91 01 	lds	r24, 0x0191
    327c:	84 31       	cpi	r24, 0x14	; 20
    327e:	09 f4       	brne	.+2      	; 0x3282 <PM_InterpretAVRISPPacket+0x3da>
    3280:	91 e0       	ldi	r25, 0x01	; 1
    3282:	89 2f       	mov	r24, r25
    3284:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <PM_GetStoredDataSize>
    3288:	7b 01       	movw	r14, r22
    328a:	01 e9       	ldi	r16, 0x91	; 145
    328c:	11 e0       	ldi	r17, 0x01	; 1
    328e:	1b c0       	rjmp	.+54     	; 0x32c6 <PM_InterpretAVRISPPacket+0x41e>
    3290:	97 01       	movw	r18, r14
    3292:	44 27       	eor	r20, r20
    3294:	55 27       	eor	r21, r21
    3296:	80 91 a9 02 	lds	r24, 0x02A9
    329a:	90 91 aa 02 	lds	r25, 0x02AA
    329e:	a0 91 ab 02 	lds	r26, 0x02AB
    32a2:	b0 91 ac 02 	lds	r27, 0x02AC
    32a6:	82 17       	cp	r24, r18
    32a8:	93 07       	cpc	r25, r19
    32aa:	a4 07       	cpc	r26, r20
    32ac:	b5 07       	cpc	r27, r21
    32ae:	10 f0       	brcs	.+4      	; 0x32b4 <PM_InterpretAVRISPPacket+0x40c>
    32b0:	8f ef       	ldi	r24, 0xFF	; 255
    32b2:	03 c0       	rjmp	.+6      	; 0x32ba <PM_InterpretAVRISPPacket+0x412>
    32b4:	80 e0       	ldi	r24, 0x00	; 0
    32b6:	0e 94 b2 09 	call	0x1364	; 0x1364 <SPI_SPITransmit>
    32ba:	f8 01       	movw	r30, r16
    32bc:	82 83       	std	Z+2, r24	; 0x02
    32be:	0e 94 db 0e 	call	0x1db6	; 0x1db6 <V2P_IncrementCurrAddress>
    32c2:	0f 5f       	subi	r16, 0xFF	; 255
    32c4:	1f 4f       	sbci	r17, 0xFF	; 255
    32c6:	ce 01       	movw	r24, r28
    32c8:	8f 56       	subi	r24, 0x6F	; 111
    32ca:	9e 4f       	sbci	r25, 0xFE	; 254
    32cc:	08 17       	cp	r16, r24
    32ce:	19 07       	cpc	r17, r25
    32d0:	f9 f6       	brne	.-66     	; 0x3290 <PM_InterpretAVRISPPacket+0x3e8>
    32d2:	23 96       	adiw	r28, 0x03	; 3
    32d4:	d0 93 a7 02 	sts	0x02A7, r29
    32d8:	c0 93 a6 02 	sts	0x02A6, r28
    32dc:	10 92 92 01 	sts	0x0192, r1
    32e0:	f8 01       	movw	r30, r16
    32e2:	12 82       	std	Z+2, r1	; 0x02
    32e4:	09 c0       	rjmp	.+18     	; 0x32f8 <PM_InterpretAVRISPPacket+0x450>
    32e6:	81 e0       	ldi	r24, 0x01	; 1
    32e8:	90 e0       	ldi	r25, 0x00	; 0
    32ea:	90 93 a7 02 	sts	0x02A7, r25
    32ee:	80 93 a6 02 	sts	0x02A6, r24
    32f2:	89 ec       	ldi	r24, 0xC9	; 201
    32f4:	80 93 92 01 	sts	0x0192, r24
    32f8:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <V2P_SendPacket>
    32fc:	df 91       	pop	r29
    32fe:	cf 91       	pop	r28
    3300:	1f 91       	pop	r17
    3302:	0f 91       	pop	r16
    3304:	ff 90       	pop	r15
    3306:	ef 90       	pop	r14
    3308:	08 95       	ret

0000330a <TM_FindNextTag>:
	DF_EnableDataflash(FALSE);
}

void TM_FindNextTag(void)
{
    330a:	cf 92       	push	r12
    330c:	df 92       	push	r13
    330e:	ef 92       	push	r14
    3310:	ff 92       	push	r15
    3312:	0f 93       	push	r16
    3314:	1f 93       	push	r17
    3316:	cf 93       	push	r28
    3318:	df 93       	push	r29
    331a:	cd b7       	in	r28, 0x3d	; 61
    331c:	de b7       	in	r29, 0x3e	; 62
    331e:	69 97       	sbiw	r28, 0x19	; 25
    3320:	0f b6       	in	r0, 0x3f	; 63
    3322:	f8 94       	cli
    3324:	de bf       	out	0x3e, r29	; 62
    3326:	0f be       	out	0x3f, r0	; 63
    3328:	cd bf       	out	0x3d, r28	; 61
	uint8_t  Buffer[21];
	uint8_t  HeadBuff[4]      = BT_TAGHEADER;
    332a:	80 e4       	ldi	r24, 0x40	; 64
    332c:	89 83       	std	Y+1, r24	; 0x01
    332e:	88 e2       	ldi	r24, 0x28	; 40
    3330:	8a 83       	std	Y+2, r24	; 0x02
    3332:	83 e2       	ldi	r24, 0x23	; 35
    3334:	8b 83       	std	Y+3, r24	; 0x03
    3336:	89 e2       	ldi	r24, 0x29	; 41
    3338:	8c 83       	std	Y+4, r24	; 0x04
	uint32_t ProgDataSize     = PM_GetStoredDataSize(TYPE_FLASH);
    333a:	81 e0       	ldi	r24, 0x01	; 1
    333c:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <PM_GetStoredDataSize>
    3340:	6b 01       	movw	r12, r22
    3342:	7c 01       	movw	r14, r24
	uint8_t  TotalOkHeadBytes = 0;
	uint8_t  TagByte;
	uint8_t  BytesRead;
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);    // Orange = busy
    3344:	81 b3       	in	r24, 0x11	; 17
    3346:	8f 7c       	andi	r24, 0xCF	; 207
    3348:	80 63       	ori	r24, 0x30	; 48
    334a:	81 bb       	out	0x11, r24	; 17

	while (DFPos < ProgDataSize)
	{
		BytesRead = 1;
		
		TagByte = SPI_SPITransmit(0x00);       // Get next byte from dataflash
		if (TagByte == HeadBuff[TotalOkHeadBytes++])
		{
			if (TotalOkHeadBytes == 4)
			{
				uint8_t HB;
			
				for (HB = 0; HB < 20; HB++)
				{
					TagByte = SPI_SPITransmit(0x00);
					Buffer[HB] = TagByte;
					
					if (TagByte == 0x00)
					  break;
				}
				
				Buffer[20] = '\0';             // Make sure string is null-terminated

				TagExists = TRUE;
				BytesRead = (HB + 2);

				LCD_puts(Buffer);
				MAIN_SETSTATUSLED(MAIN_STATLED_GREEN); // Green = ready
				return;
			}
		}
		else
		{
			TotalOkHeadBytes = ((TagByte == HeadBuff[0])? 1 : 0);
    334c:	09 81       	ldd	r16, Y+1	; 0x01
    334e:	10 e0       	ldi	r17, 0x00	; 0
    3350:	42 c0       	rjmp	.+132    	; 0x33d6 <TM_FindNextTag+0xcc>
    3352:	80 e0       	ldi	r24, 0x00	; 0
    3354:	0e 94 b2 09 	call	0x1364	; 0x1364 <SPI_SPITransmit>
    3358:	98 2f       	mov	r25, r24
    335a:	fe 01       	movw	r30, r28
    335c:	e1 0f       	add	r30, r17
    335e:	f1 1d       	adc	r31, r1
    3360:	81 81       	ldd	r24, Z+1	; 0x01
    3362:	98 17       	cp	r25, r24
    3364:	09 f5       	brne	.+66     	; 0x33a8 <TM_FindNextTag+0x9e>
    3366:	1f 5f       	subi	r17, 0xFF	; 255
    3368:	14 30       	cpi	r17, 0x04	; 4
    336a:	11 f5       	brne	.+68     	; 0x33b0 <TM_FindNextTag+0xa6>
    336c:	8e 01       	movw	r16, r28
    336e:	0b 5f       	subi	r16, 0xFB	; 251
    3370:	1f 4f       	sbci	r17, 0xFF	; 255
    3372:	80 e0       	ldi	r24, 0x00	; 0
    3374:	0e 94 b2 09 	call	0x1364	; 0x1364 <SPI_SPITransmit>
    3378:	f8 01       	movw	r30, r16
    337a:	80 83       	st	Z, r24
    337c:	88 23       	and	r24, r24
    337e:	39 f0       	breq	.+14     	; 0x338e <TM_FindNextTag+0x84>
    3380:	0f 5f       	subi	r16, 0xFF	; 255
    3382:	1f 4f       	sbci	r17, 0xFF	; 255
    3384:	ce 01       	movw	r24, r28
    3386:	49 96       	adiw	r24, 0x19	; 25
    3388:	08 17       	cp	r16, r24
    338a:	19 07       	cpc	r17, r25
    338c:	91 f7       	brne	.-28     	; 0x3372 <TM_FindNextTag+0x68>
    338e:	19 8e       	std	Y+25, r1	; 0x19
    3390:	81 e0       	ldi	r24, 0x01	; 1
    3392:	80 93 b1 02 	sts	0x02B1, r24
    3396:	ce 01       	movw	r24, r28
    3398:	05 96       	adiw	r24, 0x05	; 5
    339a:	0e 94 7f 08 	call	0x10fe	; 0x10fe <LCD_puts>
    339e:	81 b3       	in	r24, 0x11	; 17
    33a0:	8f 7c       	andi	r24, 0xCF	; 207
    33a2:	80 61       	ori	r24, 0x10	; 16
    33a4:	81 bb       	out	0x11, r24	; 17
    33a6:	42 c0       	rjmp	.+132    	; 0x342c <TM_FindNextTag+0x122>
    33a8:	10 e0       	ldi	r17, 0x00	; 0
    33aa:	90 17       	cp	r25, r16
    33ac:	09 f4       	brne	.+2      	; 0x33b0 <TM_FindNextTag+0xa6>
    33ae:	11 e0       	ldi	r17, 0x01	; 1
		}

		DFPos += BytesRead;
    33b0:	80 91 b2 02 	lds	r24, 0x02B2
    33b4:	90 91 b3 02 	lds	r25, 0x02B3
    33b8:	a0 91 b4 02 	lds	r26, 0x02B4
    33bc:	b0 91 b5 02 	lds	r27, 0x02B5
    33c0:	01 96       	adiw	r24, 0x01	; 1
    33c2:	a1 1d       	adc	r26, r1
    33c4:	b1 1d       	adc	r27, r1
    33c6:	80 93 b2 02 	sts	0x02B2, r24
    33ca:	90 93 b3 02 	sts	0x02B3, r25
    33ce:	a0 93 b4 02 	sts	0x02B4, r26
    33d2:	b0 93 b5 02 	sts	0x02B5, r27
    33d6:	80 91 b2 02 	lds	r24, 0x02B2
    33da:	90 91 b3 02 	lds	r25, 0x02B3
    33de:	a0 91 b4 02 	lds	r26, 0x02B4
    33e2:	b0 91 b5 02 	lds	r27, 0x02B5
    33e6:	8c 15       	cp	r24, r12
    33e8:	9d 05       	cpc	r25, r13
    33ea:	ae 05       	cpc	r26, r14
    33ec:	bf 05       	cpc	r27, r15
    33ee:	08 f4       	brcc	.+2      	; 0x33f2 <TM_FindNextTag+0xe8>
    33f0:	b0 cf       	rjmp	.-160    	; 0x3352 <TM_FindNextTag+0x48>
	}
	
	DF_ContinuousReadEnable(0, 0);
    33f2:	60 e0       	ldi	r22, 0x00	; 0
    33f4:	70 e0       	ldi	r23, 0x00	; 0
    33f6:	80 e0       	ldi	r24, 0x00	; 0
    33f8:	90 e0       	ldi	r25, 0x00	; 0
    33fa:	0e 94 90 0a 	call	0x1520	; 0x1520 <DF_ContinuousReadEnable>
	DFPos = 0;
    33fe:	10 92 b2 02 	sts	0x02B2, r1
    3402:	10 92 b3 02 	sts	0x02B3, r1
    3406:	10 92 b4 02 	sts	0x02B4, r1
    340a:	10 92 b5 02 	sts	0x02B5, r1
	
	if (TagExists == FALSE)
    340e:	80 91 b1 02 	lds	r24, 0x02B1
    3412:	88 23       	and	r24, r24
    3414:	49 f4       	brne	.+18     	; 0x3428 <TM_FindNextTag+0x11e>
	{
		MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);  // Green = ready
    3416:	81 b3       	in	r24, 0x11	; 17
    3418:	8f 7c       	andi	r24, 0xCF	; 207
    341a:	80 61       	ori	r24, 0x10	; 16
    341c:	81 bb       	out	0x11, r24	; 17
		MAIN_ShowError(PSTR("NO TAGS"));
    341e:	8e e5       	ldi	r24, 0x5E	; 94
    3420:	94 e0       	ldi	r25, 0x04	; 4
    3422:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
    3426:	02 c0       	rjmp	.+4      	; 0x342c <TM_FindNextTag+0x122>
	}
	else
	{
		/* The following line _is_ recursion, but the function will only ever call itself
		   a maximum of one time. The function will call itself upon skipping from the last
		   tag stored in the program data to the first; to guard against infinite recursion
		   if no tags are present, the system will error out if the TagExists flag is empty
		   after a full data read. Once a tag has been read and displayed onto the LCD, the
           function returns to the main tag handling routine.                               */
		TM_FindNextTag();
    3428:	0e 94 85 19 	call	0x330a	; 0x330a <TM_FindNextTag>
    342c:	69 96       	adiw	r28, 0x19	; 25
    342e:	0f b6       	in	r0, 0x3f	; 63
    3430:	f8 94       	cli
    3432:	de bf       	out	0x3e, r29	; 62
    3434:	0f be       	out	0x3f, r0	; 63
    3436:	cd bf       	out	0x3d, r28	; 61
    3438:	df 91       	pop	r29
    343a:	cf 91       	pop	r28
    343c:	1f 91       	pop	r17
    343e:	0f 91       	pop	r16
    3440:	ff 90       	pop	r15
    3442:	ef 90       	pop	r14
    3444:	df 90       	pop	r13
    3446:	cf 90       	pop	r12
    3448:	08 95       	ret

0000344a <TM_ShowTags>:
    344a:	60 e0       	ldi	r22, 0x00	; 0
    344c:	70 e0       	ldi	r23, 0x00	; 0
    344e:	80 e0       	ldi	r24, 0x00	; 0
    3450:	90 e0       	ldi	r25, 0x00	; 0
    3452:	0e 94 90 0a 	call	0x1520	; 0x1520 <DF_ContinuousReadEnable>
    3456:	10 92 b1 02 	sts	0x02B1, r1
    345a:	10 92 b2 02 	sts	0x02B2, r1
    345e:	10 92 b3 02 	sts	0x02B3, r1
    3462:	10 92 b4 02 	sts	0x02B4, r1
    3466:	10 92 b5 02 	sts	0x02B5, r1
    346a:	0e 94 85 19 	call	0x330a	; 0x330a <TM_FindNextTag>
    346e:	80 91 b1 02 	lds	r24, 0x02B1
    3472:	88 23       	and	r24, r24
    3474:	71 f0       	breq	.+28     	; 0x3492 <TM_ShowTags+0x48>
    3476:	8e b3       	in	r24, 0x1e	; 30
    3478:	88 23       	and	r24, r24
    347a:	e9 f3       	breq	.-6      	; 0x3476 <TM_ShowTags+0x2c>
    347c:	f7 9b       	sbis	0x1e, 7	; 30
    347e:	03 c0       	rjmp	.+6      	; 0x3486 <TM_ShowTags+0x3c>
    3480:	0e 94 85 19 	call	0x330a	; 0x330a <TM_FindNextTag>
    3484:	02 c0       	rjmp	.+4      	; 0x348a <TM_ShowTags+0x40>
    3486:	f2 99       	sbic	0x1e, 2	; 30
    3488:	03 c0       	rjmp	.+6      	; 0x3490 <TM_ShowTags+0x46>
    348a:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
    348e:	f3 cf       	rjmp	.-26     	; 0x3476 <TM_ShowTags+0x2c>
    3490:	80 e0       	ldi	r24, 0x00	; 0
    3492:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <DF_EnableDataflash>
    3496:	08 95       	ret

00003498 <__vector_2>:
.global PCINT0_vect             ; Pin change 0 (joystick)
.global PCINT1_vect             ; Pin change 1 (joystick)

PCINT0_vect:
  jmp PCINT1_vect
    3498:	0c 94 bb 02 	jmp	0x576	; 0x576 <__vector_3>

0000349c <__vector_10>:

.global TIMER0_COMP_vect             ; Timer 0 compare

TIMER0_COMP_vect:
  push r24
    349c:	8f 93       	push	r24
  ldi r24, (USI_CONTROL_REG_FLAGS | (1<<USITC))
    349e:	8b e5       	ldi	r24, 0x5B	; 91
  sts _SFR_MEM_ADDR(USICR), r24
    34a0:	80 93 b8 00 	sts	0x00B8, r24
  pop r24
    34a4:	8f 91       	pop	r24
  reti
    34a6:	18 95       	reti

000034a8 <strcpy_P>:
    34a8:	fb 01       	movw	r30, r22
    34aa:	dc 01       	movw	r26, r24
    34ac:	05 90       	lpm	r0, Z+
    34ae:	0d 92       	st	X+, r0
    34b0:	00 20       	and	r0, r0
    34b2:	e1 f7       	brne	.-8      	; 0x34ac <strcpy_P+0x4>
    34b4:	08 95       	ret

000034b6 <ultoa>:
    34b6:	fa 01       	movw	r30, r20
    34b8:	cf 93       	push	r28
    34ba:	ff 93       	push	r31
    34bc:	ef 93       	push	r30
    34be:	22 30       	cpi	r18, 0x02	; 2
    34c0:	cc f0       	brlt	.+50     	; 0x34f4 <ultoa+0x3e>
    34c2:	25 32       	cpi	r18, 0x25	; 37
    34c4:	bc f4       	brge	.+46     	; 0x34f4 <ultoa+0x3e>
    34c6:	c2 2f       	mov	r28, r18
    34c8:	2c 2f       	mov	r18, r28
    34ca:	33 27       	eor	r19, r19
    34cc:	44 27       	eor	r20, r20
    34ce:	55 27       	eor	r21, r21
    34d0:	ff 93       	push	r31
    34d2:	ef 93       	push	r30
    34d4:	0e 94 b8 1a 	call	0x3570	; 0x3570 <__udivmodsi4>
    34d8:	ef 91       	pop	r30
    34da:	ff 91       	pop	r31
    34dc:	60 5d       	subi	r22, 0xD0	; 208
    34de:	6a 33       	cpi	r22, 0x3A	; 58
    34e0:	0c f0       	brlt	.+2      	; 0x34e4 <ultoa+0x2e>
    34e2:	69 5d       	subi	r22, 0xD9	; 217
    34e4:	61 93       	st	Z+, r22
    34e6:	b9 01       	movw	r22, r18
    34e8:	ca 01       	movw	r24, r20
    34ea:	60 50       	subi	r22, 0x00	; 0
    34ec:	70 40       	sbci	r23, 0x00	; 0
    34ee:	80 40       	sbci	r24, 0x00	; 0
    34f0:	90 40       	sbci	r25, 0x00	; 0
    34f2:	51 f7       	brne	.-44     	; 0x34c8 <ultoa+0x12>
    34f4:	10 82       	st	Z, r1
    34f6:	8f 91       	pop	r24
    34f8:	9f 91       	pop	r25
    34fa:	cf 91       	pop	r28
    34fc:	0c 94 80 1a 	jmp	0x3500	; 0x3500 <strrev>

00003500 <strrev>:
    3500:	dc 01       	movw	r26, r24
    3502:	fc 01       	movw	r30, r24
    3504:	01 90       	ld	r0, Z+
    3506:	00 20       	and	r0, r0
    3508:	e9 f7       	brne	.-6      	; 0x3504 <strrev+0x4>
    350a:	32 97       	sbiw	r30, 0x02	; 2
    350c:	ae 17       	cp	r26, r30
    350e:	bf 07       	cpc	r27, r31
    3510:	30 f4       	brcc	.+12     	; 0x351e <strrev+0x1e>
    3512:	7c 91       	ld	r23, X
    3514:	60 81       	ld	r22, Z
    3516:	70 83       	st	Z, r23
    3518:	31 97       	sbiw	r30, 0x01	; 1
    351a:	6d 93       	st	X+, r22
    351c:	f7 cf       	rjmp	.-18     	; 0x350c <strrev+0xc>
    351e:	08 95       	ret

00003520 <__eeprom_read_byte_1F2021>:
    3520:	f9 99       	sbic	0x1f, 1	; 31
    3522:	fe cf       	rjmp	.-4      	; 0x3520 <__eeprom_read_byte_1F2021>
    3524:	b2 bd       	out	0x22, r27	; 34
    3526:	a1 bd       	out	0x21, r26	; 33
    3528:	f8 9a       	sbi	0x1f, 0	; 31
    352a:	11 96       	adiw	r26, 0x01	; 1
    352c:	00 b4       	in	r0, 0x20	; 32
    352e:	08 95       	ret

00003530 <__eeprom_read_block_1F2021>:
    3530:	f7 df       	rcall	.-18     	; 0x3520 <__eeprom_read_byte_1F2021>
    3532:	01 92       	st	Z+, r0
    3534:	1a 94       	dec	r1
    3536:	e1 f7       	brne	.-8      	; 0x3530 <__eeprom_read_block_1F2021>
    3538:	08 95       	ret

0000353a <__eeprom_read_word_1F2021>:
    353a:	f2 df       	rcall	.-28     	; 0x3520 <__eeprom_read_byte_1F2021>
    353c:	e0 2d       	mov	r30, r0
    353e:	f0 df       	rcall	.-32     	; 0x3520 <__eeprom_read_byte_1F2021>
    3540:	f0 2d       	mov	r31, r0
    3542:	08 95       	ret

00003544 <__eeprom_write_byte_1F2021>:
    3544:	f9 99       	sbic	0x1f, 1	; 31
    3546:	fe cf       	rjmp	.-4      	; 0x3544 <__eeprom_write_byte_1F2021>
    3548:	b2 bd       	out	0x22, r27	; 34
    354a:	a1 bd       	out	0x21, r26	; 33
    354c:	00 bc       	out	0x20, r0	; 32
    354e:	11 96       	adiw	r26, 0x01	; 1
    3550:	0f b6       	in	r0, 0x3f	; 63
    3552:	f8 94       	cli
    3554:	fa 9a       	sbi	0x1f, 2	; 31
    3556:	f9 9a       	sbi	0x1f, 1	; 31
    3558:	0f be       	out	0x3f, r0	; 63
    355a:	08 95       	ret

0000355c <__eeprom_write_word_1F2021>:
    355c:	f3 df       	rcall	.-26     	; 0x3544 <__eeprom_write_byte_1F2021>
    355e:	01 2c       	mov	r0, r1
    3560:	f1 df       	rcall	.-30     	; 0x3544 <__eeprom_write_byte_1F2021>
    3562:	11 24       	eor	r1, r1
    3564:	08 95       	ret

00003566 <__eeprom_write_block_1F2021>:
    3566:	01 90       	ld	r0, Z+
    3568:	ed df       	rcall	.-38     	; 0x3544 <__eeprom_write_byte_1F2021>
    356a:	1a 94       	dec	r1
    356c:	e1 f7       	brne	.-8      	; 0x3566 <__eeprom_write_block_1F2021>
    356e:	08 95       	ret

00003570 <__udivmodsi4>:
    3570:	a1 e2       	ldi	r26, 0x21	; 33
    3572:	1a 2e       	mov	r1, r26
    3574:	aa 1b       	sub	r26, r26
    3576:	bb 1b       	sub	r27, r27
    3578:	fd 01       	movw	r30, r26
    357a:	0d c0       	rjmp	.+26     	; 0x3596 <__udivmodsi4_ep>

0000357c <__udivmodsi4_loop>:
    357c:	aa 1f       	adc	r26, r26
    357e:	bb 1f       	adc	r27, r27
    3580:	ee 1f       	adc	r30, r30
    3582:	ff 1f       	adc	r31, r31
    3584:	a2 17       	cp	r26, r18
    3586:	b3 07       	cpc	r27, r19
    3588:	e4 07       	cpc	r30, r20
    358a:	f5 07       	cpc	r31, r21
    358c:	20 f0       	brcs	.+8      	; 0x3596 <__udivmodsi4_ep>
    358e:	a2 1b       	sub	r26, r18
    3590:	b3 0b       	sbc	r27, r19
    3592:	e4 0b       	sbc	r30, r20
    3594:	f5 0b       	sbc	r31, r21

00003596 <__udivmodsi4_ep>:
    3596:	66 1f       	adc	r22, r22
    3598:	77 1f       	adc	r23, r23
    359a:	88 1f       	adc	r24, r24
    359c:	99 1f       	adc	r25, r25
    359e:	1a 94       	dec	r1
    35a0:	69 f7       	brne	.-38     	; 0x357c <__udivmodsi4_loop>
    35a2:	60 95       	com	r22
    35a4:	70 95       	com	r23
    35a6:	80 95       	com	r24
    35a8:	90 95       	com	r25
    35aa:	9b 01       	movw	r18, r22
    35ac:	ac 01       	movw	r20, r24
    35ae:	bd 01       	movw	r22, r26
    35b0:	cf 01       	movw	r24, r30
    35b2:	08 95       	ret

000035b4 <_exit>:
    35b4:	ff cf       	rjmp	.-2      	; 0x35b4 <_exit>
