
ButtLoad.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  000034de  00003592  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000034de  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b4  00800104  00800104  00003596  2**0
                  ALLOC
  3 .eeprom       0000008a  00810000  00810000  00003596  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00000084  00000000  00000000  00003620  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00000078  00000000  00000000  000036a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 0000012c  00000000  00000000  0000371c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 00000d5f  00000000  00000000  00003848  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   000042df  00000000  00000000  000045a7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00001261  00000000  00000000  00008886  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0000330f  00000000  00000000  00009ae7  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000004e0  00000000  00000000  0000cdf6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00001154  00000000  00000000  0000d2d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000114a  00000000  00000000  0000e42a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000060  00000000  00000000  0000f574  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 1e 02 	jmp	0x43c	; 0x43c <__ctors_end>
       4:	0c 94 3b 02 	jmp	0x476	; 0x476 <__bad_interrupt>
       8:	0c 94 e0 19 	jmp	0x33c0	; 0x33c0 <__vector_2>
       c:	0c 94 91 02 	jmp	0x522	; 0x522 <__vector_3>
      10:	0c 94 ec 0b 	jmp	0x17d8	; 0x17d8 <__vector_4>
      14:	0c 94 e1 07 	jmp	0xfc2	; 0xfc2 <__vector_5>
      18:	0c 94 3b 02 	jmp	0x476	; 0x476 <__bad_interrupt>
      1c:	0c 94 3b 02 	jmp	0x476	; 0x476 <__bad_interrupt>
      20:	0c 94 3b 02 	jmp	0x476	; 0x476 <__bad_interrupt>
      24:	0c 94 48 0c 	jmp	0x1890	; 0x1890 <__vector_9>
      28:	0c 94 e2 19 	jmp	0x33c4	; 0x33c4 <__vector_10>
      2c:	0c 94 3b 02 	jmp	0x476	; 0x476 <__bad_interrupt>
      30:	0c 94 3b 02 	jmp	0x476	; 0x476 <__bad_interrupt>
      34:	0c 94 a2 0b 	jmp	0x1744	; 0x1744 <__vector_13>
      38:	0c 94 3b 02 	jmp	0x476	; 0x476 <__bad_interrupt>
      3c:	0c 94 3b 02 	jmp	0x476	; 0x476 <__bad_interrupt>
      40:	0c 94 3b 02 	jmp	0x476	; 0x476 <__bad_interrupt>
      44:	0c 94 68 09 	jmp	0x12d0	; 0x12d0 <__vector_17>
      48:	0c 94 3b 02 	jmp	0x476	; 0x476 <__bad_interrupt>
      4c:	0c 94 3b 02 	jmp	0x476	; 0x476 <__bad_interrupt>
      50:	0c 94 3b 02 	jmp	0x476	; 0x476 <__bad_interrupt>
      54:	0c 94 3b 02 	jmp	0x476	; 0x476 <__bad_interrupt>
      58:	0c 94 84 08 	jmp	0x1108	; 0x1108 <__vector_22>

0000005c <BUTTTAG_Title>:
      5c:	40 28 23 29 42 55 54 54 4c 4f 41 44 20 41 56 52     @(#)BUTTLOAD AVR
      6c:	49 53 50 00                                         ISP.

00000070 <BUTTTAG_Version>:
      70:	40 28 23 29 56 31 2d 34 00                          @(#)V1-4.

00000079 <BUTTTAG_Author>:
      79:	40 28 23 29 42 59 20 44 45 41 4e 20 43 41 4d 45     @(#)BY DEAN CAME
      89:	52 41 00                                            RA.

0000008c <BUTTTAG_Copyright>:
      8c:	40 28 23 29 3c 43 3e 20 32 30 30 36 20 2d 20 47     @(#)<C> 2006 - G
      9c:	50 4c 00                                            PL.

0000009f <AboutTextPtrs>:
      9f:	60 00 74 00 7d 00 90 00                             `.t.}...

000000a7 <WaitText>:
      a7:	2a 57 41 49 54 2a 00                                *WAIT*.

000000ae <Func_ISPPRGM>:
      ae:	41 56 52 49 53 50 20 4d 4f 44 45 00                 AVRISP MODE.

000000ba <Func_STOREPRGM>:
      ba:	53 54 4f 52 45 20 50 52 47 4d 00                    STORE PRGM.

000000c5 <Func_PRGMAVR>:
      c5:	50 52 4f 47 52 41 4d 20 41 56 52 00                 PROGRAM AVR.

000000d1 <Func_PRGMDATAFLASH>:
      d1:	44 41 54 41 46 4c 41 53 48 20 50 52 47 4d 00        DATAFLASH PRGM.

000000e0 <Func_PRGMSTOREINFO>:
      e0:	44 41 54 41 53 54 4f 52 45 20 49 4e 46 4f 00        DATASTORE INFO.

000000ef <Func_SETTINGS>:
      ef:	53 45 54 54 49 4e 47 53 00                          SETTINGS.

000000f8 <Func_SLEEP>:
      f8:	53 4c 45 45 50 20 4d 4f 44 45 00                    SLEEP MODE.

00000103 <MainFunctionNames>:
     103:	ae 00 ba 00 c5 00 d1 00 e0 00 ef 00 f8 00           ..............

00000111 <MainFunctionPtrs>:
     111:	67 04 35 04 b1 04 80 04 b8 03 fb 02 b0 02           g.5...........

0000011f <SFunc_SETCONTRAST>:
     11f:	53 45 54 20 43 4f 4e 54 52 41 53 54 00              SET CONTRAST.

0000012c <SFunc_SETSPISPEED>:
     12c:	53 45 54 20 53 50 49 20 53 50 45 45 44 00           SET SPI SPEED.

0000013a <SFunc_SETFIRMMINOR>:
     13a:	53 45 54 20 46 49 52 4d 20 56 45 52 53 49 4f 4e     SET FIRM VERSION
	...

0000014b <SFunc_SETAUTOSLEEPTO>:
     14b:	53 45 54 20 53 4c 45 45 50 20 54 49 4d 45 4f 55     SET SLEEP TIMEOU
     15b:	54 00                                               T.

0000015d <SFunc_CLEARMEM>:
     15d:	43 4c 45 41 52 20 4d 45 4d 4f 52 59 00              CLEAR MEMORY.

0000016a <SFunc_GOBOOTLOADER>:
     16a:	4a 55 4d 50 20 54 4f 20 42 4f 4f 54 4c 4f 41 44     JUMP TO BOOTLOAD
     17a:	45 52 00                                            ER.

0000017d <SettingFunctionNames>:
     17d:	1f 01 2c 01 3a 01 4b 01 5d 01 6a 01                 ..,.:.K.].j.

00000189 <SettingFunctionPtrs>:
     189:	be 06 0a 07 3d 07 30 03 93 06 c3 02                 ....=.0.....

00000195 <PRG_A>:
     195:	50 52 4f 47 52 41 4d 20 41 4c 4c 00                 PROGRAM ALL.

000001a1 <PRG_D>:
     1a1:	44 41 54 41 20 4f 4e 4c 59 00                       DATA ONLY.

000001ab <PRG_E>:
     1ab:	45 45 50 52 4f 4d 20 4f 4e 4c 59 00                 EEPROM ONLY.

000001b7 <PRG_DE>:
     1b7:	44 41 54 41 20 41 4e 44 20 45 45 50 52 4f 4d 00     DATA AND EEPROM.

000001c7 <PRG_F>:
     1c7:	46 55 53 45 20 42 59 54 45 53 20 4f 4e 4c 59 00     FUSE BYTES ONLY.

000001d7 <PRG_L>:
     1d7:	4c 4f 43 4b 20 42 59 54 45 53 20 4f 4e 4c 59 00     LOCK BYTES ONLY.

000001e7 <PRG_FL>:
     1e7:	46 55 53 45 20 41 4e 44 20 4c 4f 43 4b 20 42 59     FUSE AND LOCK BY
     1f7:	54 45 53 00                                         TES.

000001fb <PRG_C>:
     1fb:	45 52 41 53 45 20 4f 4e 4c 59 00                    ERASE ONLY.

00000206 <ProgOptions>:
     206:	95 01 a1 01 ab 01 b7 01 c7 01 d7 01 e7 01 fb 01     ................

00000216 <USISpeeds>:
     216:	20 35 37 31 35 33 20 48 5a 00 20 38 36 37 33 38      57153 HZ. 86738
     226:	20 48 5a 00 31 31 33 34 32 37 20 48 5a 00 32 31      HZ.113427 HZ.21
     236:	30 36 35 31 20 48 5a 00                             0651 HZ.

0000023e <SIFONames>:
     23e:	53 54 4f 52 41 47 45 20 53 49 5a 45 53 00 00 56     STORAGE SIZES..V
     24e:	49 45 57 20 44 41 54 41 20 54 41 47 53 00           IEW DATA TAGS.

0000025c <__c.2439>:
     25c:	2a 4a 54 41 47 20 4f 4e 2a 00                       *JTAG ON*.

00000266 <__c.2408>:
     266:	4e 4f 20 53 54 4f 52 45 44 20 50 52 47 4d 00        NO STORED PRGM.

00000275 <__c.2362>:
     275:	4f 46 46 00                                         OFF.

00000279 <__c.2360>:
     279:	20 20 20 20 53 45 43 00                                 SEC.

00000281 <__c.2339>:
     281:	56 32 2d 20 00                                      V2- .

00000286 <__c.2276>:
     286:	4d 45 4d 20 43 4c 45 41 52 45 44 00                 MEM CLEARED.

00000292 <__c.2268>:
     292:	3c 4e 20 59 3e 00                                   <N Y>.

00000298 <__c.2266>:
     298:	43 4f 4e 46 49 52 4d 00                             CONFIRM.

000002a0 <__c.2249>:
     2a0:	2a 53 54 4f 52 41 47 45 20 4d 4f 44 45 2a 00        *STORAGE MODE*.

000002af <__c.2182>:
     2af:	46 41 49 4c 45 44 00                                FAILED.

000002b6 <__c.2180>:
     2b6:	50 52 4f 47 52 41 4d 4d 49 4e 47 20 44 4f 4e 45     PROGRAMMING DONE
	...

000002c7 <__c.2178>:
     2c7:	4e 4f 20 4c 4f 43 4b 20 42 59 54 45 53 00           NO LOCK BYTES.

000002d5 <__c.2176>:
     2d5:	4e 4f 20 46 55 53 45 20 42 59 54 45 53 00           NO FUSE BYTES.

000002e3 <__c.2174>:
     2e3:	4e 4f 20 45 45 50 52 4f 4d 00                       NO EEPROM.

000002ed <__c.2172>:
     2ed:	4e 4f 20 44 41 54 41 00                             NO DATA.

000002f5 <__c.2170>:
     2f5:	4e 4f 20 45 52 41 53 45 20 43 4d 44 00              NO ERASE CMD.

00000302 <__c.2065>:
     302:	42 41 44 49 53 52 00                                BADISR.

00000309 <__c.2024>:
     309:	50 52 47 3e 20 20 00                                PRG>  .

00000310 <LCD_SegTable>:
     310:	a8 ea 80 2a 00 40 00 0a 51 0a 08 40 59 55 18 01     ...*.@..Q..@YU..
     320:	11 1e 11 1b 50 0b 41 1b 41 1f 11 01 51 1f 51 1b     ....P.A.A...Q.Q.
     330:	00 00 00 00 08 80 00 1a 20 40 00 00 00 00 51 0f     ........ @....Q.
     340:	91 39 41 14 91 31 41 1e 41 0e 41 1d 50 0f 80 20     .9A..1A.A.A.P.. 
     350:	10 15 48 86 40 14 78 05 70 85 51 15 51 0e 51 95     ..H.@.x.p.Q.Q.Q.
     360:	51 8e 21 90 81 20 50 15 48 44 50 c5 28 c0 28 20     Q.!.. P.HDP.(.( 
     370:	09 50 41 14 20 80 11 11 00 00 00 10                 .PA. .......

0000037c <USIPSValues>:
     37c:	03 80 02 54 01 40 00 22                             ...T.@."

00000384 <DF_PageBits>:
     384:	09 09 09 09 09 0a 0a 0b                             ........

0000038c <DF_PageSize>:
     38c:	08 01 08 01 08 01 08 01 08 01 10 02 10 02 20 04     .............. .

0000039c <DF_Pages>:
     39c:	00 01 00 02 00 04 00 08 00 10 00 10 00 20 00 20     ............. . 

000003ac <DataFlashError>:
     3ac:	44 41 54 41 46 4c 41 53 48 20 45 52 52 4f 52 00     DATAFLASH ERROR.

000003bc <__c.1863>:
     3bc:	42 55 46 46 20 4f 56 45 52 46 4c 4f 57 00           BUFF OVERFLOW.

000003ca <AutoSleepTOValues>:
     3ca:	00 0f 1e 3c 78                                      ...<x

000003cf <DataFlashProgMode>:
     3cf:	2a 44 41 54 41 46 4c 41 53 48 20 4d 4f 44 45 2a     *DATAFLASH MODE*
	...

000003e0 <SignonResponse>:
     3e0:	01 00 08 41 56 52 49 53 50 5f 32                    ...AVRISP_2

000003eb <ButtLoadData>:
     3eb:	40 28 23 29 2a 53 43 52 45 57 20 52 45 54 52 4f     @(#)*SCREW RETRO
     3fb:	44 41 4e 00 2a                                      DAN.*

00000400 <SyncErrorMessage>:
     400:	53 59 4e 43 20 45 52 52 4f 52 00                    SYNC ERROR.

0000040b <AVRISPModeMessage>:
     40b:	2a 41 54 41 56 52 49 53 50 20 4d 4f 44 45 2a 00     *ATAVRISP MODE*.

0000041b <__c.2140>:
     41b:	4c 4f 43 4b 2d 00                                   LOCK-.

00000421 <__c.2137>:
     421:	46 55 53 45 2d 00                                   FUSE-.

00000427 <__c.2134>:
     427:	45 50 52 4d 2d 00                                   EPRM-.

0000042d <__c.2130>:
     42d:	44 41 54 41 2d 00                                   DATA-.

00000433 <__c.1885>:
     433:	4e 4f 20 54 41 47 53 00 00                          NO TAGS..

0000043c <__ctors_end>:
     43c:	11 24       	eor	r1, r1
     43e:	1f be       	out	0x3f, r1	; 63
     440:	cf ef       	ldi	r28, 0xFF	; 255
     442:	d4 e0       	ldi	r29, 0x04	; 4
     444:	de bf       	out	0x3e, r29	; 62
     446:	cd bf       	out	0x3d, r28	; 61

00000448 <__do_copy_data>:
     448:	11 e0       	ldi	r17, 0x01	; 1
     44a:	a0 e0       	ldi	r26, 0x00	; 0
     44c:	b1 e0       	ldi	r27, 0x01	; 1
     44e:	ee ed       	ldi	r30, 0xDE	; 222
     450:	f4 e3       	ldi	r31, 0x34	; 52
     452:	02 c0       	rjmp	.+4      	; 0x458 <.do_copy_data_start>

00000454 <.do_copy_data_loop>:
     454:	05 90       	lpm	r0, Z+
     456:	0d 92       	st	X+, r0

00000458 <.do_copy_data_start>:
     458:	a4 30       	cpi	r26, 0x04	; 4
     45a:	b1 07       	cpc	r27, r17
     45c:	d9 f7       	brne	.-10     	; 0x454 <.do_copy_data_loop>

0000045e <__do_clear_bss>:
     45e:	12 e0       	ldi	r17, 0x02	; 2
     460:	a4 e0       	ldi	r26, 0x04	; 4
     462:	b1 e0       	ldi	r27, 0x01	; 1
     464:	01 c0       	rjmp	.+2      	; 0x468 <.do_clear_bss_start>

00000466 <.do_clear_bss_loop>:
     466:	1d 92       	st	X+, r1

00000468 <.do_clear_bss_start>:
     468:	a8 3b       	cpi	r26, 0xB8	; 184
     46a:	b1 07       	cpc	r27, r17
     46c:	e1 f7       	brne	.-8      	; 0x466 <.do_clear_bss_loop>
     46e:	0e 94 06 06 	call	0xc0c	; 0xc0c <main>
     472:	0c 94 6e 1a 	jmp	0x34dc	; 0x34dc <_exit>

00000476 <__bad_interrupt>:
     476:	0c 94 0a 04 	jmp	0x814	; 0x814 <__vector_default>

0000047a <MAIN_Delay10MS>:

// ======================================================================================

void MAIN_Delay10MS(uint8_t loops)
{
     47a:	28 2f       	mov	r18, r24
     47c:	e0 e0       	ldi	r30, 0x00	; 0
     47e:	f8 e4       	ldi	r31, 0x48	; 72
     480:	03 c0       	rjmp	.+6      	; 0x488 <MAIN_Delay10MS+0xe>
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     482:	cf 01       	movw	r24, r30
     484:	01 97       	sbiw	r24, 0x01	; 1
     486:	f1 f7       	brne	.-4      	; 0x484 <MAIN_Delay10MS+0xa>
  /* Prevents the use of floating point libraries. Delaying in groups of
     10ms increases accuracy by reducing the time overhead for each loop
     interation of the while.                                            */

	while (loops--)
     488:	21 50       	subi	r18, 0x01	; 1
     48a:	d8 f7       	brcc	.-10     	; 0x482 <MAIN_Delay10MS+0x8>
     48c:	08 95       	ret

0000048e <MAIN_Delay1MS>:
	  _delay_ms(10);
}

void MAIN_Delay1MS(uint8_t loops)
{
     48e:	28 2f       	mov	r18, r24
     490:	e3 e3       	ldi	r30, 0x33	; 51
     492:	f7 e0       	ldi	r31, 0x07	; 7
     494:	03 c0       	rjmp	.+6      	; 0x49c <MAIN_Delay1MS+0xe>
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     496:	cf 01       	movw	r24, r30
     498:	01 97       	sbiw	r24, 0x01	; 1
     49a:	f1 f7       	brne	.-4      	; 0x498 <MAIN_Delay1MS+0xa>
  /* Prevents the use of floating point libraries. Less accurate than the
     Delay10MS routine, but nessesary for many commands. The overhead required
     to call the routine is substantially less than the overhead required to
     calculate the float at compile time, so this actually saves execution time. */

	while (loops--)
     49c:	21 50       	subi	r18, 0x01	; 1
     49e:	d8 f7       	brcc	.-10     	; 0x496 <MAIN_Delay1MS+0x8>
     4a0:	08 95       	ret

000004a2 <MAIN_ResetCSLine>:
	  _delay_ms(1);
}

void MAIN_ResetCSLine(const uint8_t ActiveInactive)
{
     4a2:	81 30       	cpi	r24, 0x01	; 1
     4a4:	91 f0       	breq	.+36     	; 0x4ca <MAIN_ResetCSLine+0x28>
	/* ActiveInactive controls the /Reset line to an AVR device or external dataflash
	/CS line. If the reset polarity parameter is a 0 then interfacing with AT89
	devices which has an active high reset. Pins are tristated when inactive.         */
	
	switch (ActiveInactive)
     4a6:	81 30       	cpi	r24, 0x01	; 1
     4a8:	18 f0       	brcs	.+6      	; 0x4b0 <MAIN_ResetCSLine+0xe>
     4aa:	82 30       	cpi	r24, 0x02	; 2
     4ac:	81 f4       	brne	.+32     	; 0x4ce <MAIN_ResetCSLine+0x2c>
     4ae:	0a c0       	rjmp	.+20     	; 0x4c4 <MAIN_ResetCSLine+0x22>
	{
		case MAIN_RESETCS_ACTIVE:      // The target RESET line may be either active high or low.
			DDRF |= (1 << 6);
     4b0:	86 9a       	sbi	0x10, 6	; 16
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     4b2:	a1 e0       	ldi	r26, 0x01	; 1
     4b4:	b0 e0       	ldi	r27, 0x00	; 0
     4b6:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
     4ba:	80 2d       	mov	r24, r0
		
			if (!(eeprom_read_byte(&EEPROMVars.ResetPolarity))) // Translate to correct logic level for target device type
     4bc:	88 23       	and	r24, r24
     4be:	19 f4       	brne	.+6      	; 0x4c6 <MAIN_ResetCSLine+0x24>
			  PORTF |=  (1 << 6);
     4c0:	8e 9a       	sbi	0x11, 6	; 17
     4c2:	08 95       	ret
			else
			  PORTF &= ~(1 << 6);
		
			break;
		case MAIN_RESETCS_EXTDFACTIVE: // Dataflashes are always active low.
			DDRF  |=  (1 << 6);
     4c4:	86 9a       	sbi	0x10, 6	; 16
			PORTF &= ~(1 << 6);
     4c6:	8e 98       	cbi	0x11, 6	; 17
     4c8:	08 95       	ret
			
			break;
		case MAIN_RESETCS_INACTIVE:    // Both modes tristate the pins when inactive.
			DDRF  &= ~(1 << 6);
     4ca:	86 98       	cbi	0x10, 6	; 16
			PORTF &= ~(1 << 6);
     4cc:	8e 98       	cbi	0x11, 6	; 17
     4ce:	08 95       	ret

000004d0 <MAIN_WaitForJoyRelease>:
	}
}

void MAIN_WaitForJoyRelease(void)
{
     4d0:	8e b3       	in	r24, 0x1e	; 30
     4d2:	88 23       	and	r24, r24
     4d4:	e9 f7       	brne	.-6      	; 0x4d0 <MAIN_WaitForJoyRelease>
	while (1)
	{
		while (JoyStatus) {};                   // Wait until joystick released

		MAIN_Delay10MS(1);
     4d6:	81 e0       	ldi	r24, 0x01	; 1
     4d8:	0e 94 3d 02 	call	0x47a	; 0x47a <MAIN_Delay10MS>

		if (!(JoyStatus))                       // Joystick still released (not bouncing), return
     4dc:	8e b3       	in	r24, 0x1e	; 30
     4de:	88 23       	and	r24, r24
     4e0:	b9 f7       	brne	.-18     	; 0x4d0 <MAIN_WaitForJoyRelease>
     4e2:	08 95       	ret

000004e4 <MAIN_IntToStr>:
		  return;
	}
}

void MAIN_IntToStr(uint16_t IntV, uint8_t* Buff)
{
     4e4:	cf 93       	push	r28
     4e6:	df 93       	push	r29
     4e8:	fb 01       	movw	r30, r22
     4ea:	20 e0       	ldi	r18, 0x00	; 0
     4ec:	03 c0       	rjmp	.+6      	; 0x4f4 <MAIN_IntToStr+0x10>
	// Shows leading zeros, unlike itoa.

	uint8_t Temp = 0;
	
	while (IntV >= 100)
	{
		Temp++;
     4ee:	2f 5f       	subi	r18, 0xFF	; 255
		IntV -= 100;
     4f0:	84 56       	subi	r24, 0x64	; 100
     4f2:	90 40       	sbci	r25, 0x00	; 0
     4f4:	84 36       	cpi	r24, 0x64	; 100
     4f6:	91 05       	cpc	r25, r1
     4f8:	d0 f7       	brcc	.-12     	; 0x4ee <MAIN_IntToStr+0xa>
	}

	*(Buff++) = '0' + Temp;
     4fa:	20 5d       	subi	r18, 0xD0	; 208
     4fc:	21 93       	st	Z+, r18
     4fe:	df 01       	movw	r26, r30
     500:	20 e0       	ldi	r18, 0x00	; 0
     502:	02 c0       	rjmp	.+4      	; 0x508 <__stack+0x9>
	
	Temp = 0;
	
	while (IntV >= 10)
	{
		Temp++;
     504:	2f 5f       	subi	r18, 0xFF	; 255
		IntV -= 10;
     506:	0a 97       	sbiw	r24, 0x0a	; 10
     508:	8a 30       	cpi	r24, 0x0A	; 10
     50a:	91 05       	cpc	r25, r1
     50c:	d8 f7       	brcc	.-10     	; 0x504 <__stack+0x5>
	}
		
	*(Buff++) = '0' + Temp;
     50e:	20 5d       	subi	r18, 0xD0	; 208
     510:	fd 01       	movw	r30, r26
     512:	21 93       	st	Z+, r18
	*(Buff++) = '0' + IntV;
     514:	80 5d       	subi	r24, 0xD0	; 208
     516:	ed 01       	movw	r28, r26
     518:	89 83       	std	Y+1, r24	; 0x01
	*(Buff)   = '\0';
     51a:	11 82       	std	Z+1, r1	; 0x01
     51c:	df 91       	pop	r29
     51e:	cf 91       	pop	r28
     520:	08 95       	ret

00000522 <__vector_3>:
}

void MAIN_ShowProgType(const uint8_t Letter)
{
	uint8_t ProgTypeBuffer[7];

	strcpy_P(ProgTypeBuffer, PSTR("PRG>  "));
	ProgTypeBuffer[5] = Letter;
	
	LCD_puts(ProgTypeBuffer);
}

void MAIN_ShowError(const uint8_t *pFlashStr)
{
	uint8_t ErrorBuff[LCD_TEXTBUFFER_SIZE];   // New buffer, LCD text buffer size
	
	ErrorBuff[0] = 'E';
	ErrorBuff[1] = '>';

	strcpy_P(&ErrorBuff[2], pFlashStr);       // WARNING: If error text is larger than (TEXTBUFFER_SIZE - 2),
	                                          // this will overflow the buffer and probably crash the micro!
	LCD_puts(ErrorBuff);
	
	MAIN_WaitForJoyRelease();
	while (!(JoyStatus & JOY_PRESS)) {};
	MAIN_WaitForJoyRelease();
}

// ======================================================================================

ISR(PCINT1_vect, ISR_NOBLOCK)                 // Joystick routine; PCINT0_vect is bound to this also via JoystickInterrupt.S
{
     522:	78 94       	sei
     524:	1f 92       	push	r1
     526:	0f 92       	push	r0
     528:	0f b6       	in	r0, 0x3f	; 63
     52a:	0f 92       	push	r0
     52c:	11 24       	eor	r1, r1
     52e:	8f 93       	push	r24
     530:	9f 93       	push	r25
	JoyStatus = (~PINB & JOY_BMASK)
     532:	83 b1       	in	r24, 0x03	; 3
     534:	9c b1       	in	r25, 0x0c	; 12
     536:	80 95       	com	r24
     538:	80 7d       	andi	r24, 0xD0	; 208
     53a:	90 95       	com	r25
     53c:	9c 70       	andi	r25, 0x0C	; 12
     53e:	89 2b       	or	r24, r25
     540:	8e bb       	out	0x1e, r24	; 30
	          | (~PINE & JOY_EMASK);
			  
	TIMEOUT_SLEEP_TIMEOUT_RESET();
     542:	10 92 48 01 	sts	0x0148, r1
     546:	10 92 47 01 	sts	0x0147, r1
     54a:	10 92 85 00 	sts	0x0085, r1
     54e:	10 92 84 00 	sts	0x0084, r1
     552:	9f 91       	pop	r25
     554:	8f 91       	pop	r24
     556:	0f 90       	pop	r0
     558:	0f be       	out	0x3f, r0	; 63
     55a:	0f 90       	pop	r0
     55c:	1f 90       	pop	r1
     55e:	18 95       	reti

00000560 <FUNCSleepMode>:
}

ISR(BADISR_vect, ISR_NAKED)                   // Bad ISR routine; should never be called, here for safety
{
	MAIN_ShowError(PSTR("BADISR"));
	while (1) {};
}

// ======================================================================================

void FUNCChangeSettings(void)
{
	uint8_t CurrSFunc = 0;
	
	JoyStatus = 1;

	while (1)
	{
		if (JoyStatus)                         // Joystick is in the non-center position
		{
			if (JoyStatus & JOY_UP)            // Previous function
			  (CurrSFunc == 0)? CurrSFunc = ARRAY_UPPERBOUND(SettingFunctionPtrs) : CurrSFunc--;
			else if (JoyStatus & JOY_DOWN)     // Next function
			  (CurrSFunc == ARRAY_UPPERBOUND(SettingFunctionPtrs))? CurrSFunc = 0 : CurrSFunc++;
			else if (JoyStatus & JOY_PRESS)    // Select current function
			  ((FuncPtr)pgm_read_word(&SettingFunctionPtrs[CurrSFunc]))(); // Run associated function
			else if (JoyStatus & JOY_LEFT)
			  return;
		
			// Show current function onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&SettingFunctionNames[CurrSFunc]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCShowAbout(void)
{
	uint8_t InfoNum = 0;
	
	JoyStatus = 1;
			
	while (1)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			  (InfoNum == 0)? InfoNum = ARRAY_UPPERBOUND(AboutTextPtrs) : InfoNum--;
			else if (JoyStatus & JOY_DOWN)
			  (InfoNum == ARRAY_UPPERBOUND(AboutTextPtrs))? InfoNum = 0 : InfoNum++;
			else if (JoyStatus & JOY_LEFT)
			  return;

			LCD_puts_f((uint8_t*)pgm_read_word(&AboutTextPtrs[InfoNum]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCAVRISPMode(void)
{
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(AVRISPModeMessage);
	
	InterpretPacketRoutine = (FuncPtr)AICI_InterpretPacket;
	V2P_RunStateMachine();
}

void FUNCProgramDataflash(void)
{
	USI_SPIInitMaster(eeprom_read_byte(&EEPROMVars.SCKDuration));
	UseExernalDF = TRUE;
	DFSPIRoutinePointer = USI_SPITransmit;
	
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(DataFlashProgMode);

	InterpretPacketRoutine = (FuncPtr)PD_InterpretAVRISPPacket;
	V2P_RunStateMachine();
	   
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
}

void FUNCProgramAVR(void)
{
	uint8_t  DoneFailMessageBuff[19];
	uint8_t  Fault    = ISPCC_NO_FAULT;
	uint8_t  ProgMode = 0;

	SPI_SPIInit();
	UseExernalDF = FALSE;
	DFSPIRoutinePointer = SPI_SPITransmit;
	
	if (!(DF_CheckCorrectOnboardChip()))
	  return;

	MAIN_WaitForJoyRelease();
	
	JoyStatus = 1;                              // Use an invalid joystick value to force the program to write the
	                                            // name of the default command onto the LCD
	while (1)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_LEFT)
			  return;
			else if (JoyStatus & JOY_PRESS)
			  break;
			else if (JoyStatus & JOY_UP)
			  (ProgMode == 0)? ProgMode = ARRAY_UPPERBOUND(ProgOptions) : ProgMode--;
			else if (JoyStatus & JOY_DOWN)
			  (ProgMode == ARRAY_UPPERBOUND(ProgOptions))? ProgMode = 0 : ProgMode++;

			LCD_puts_f((uint8_t*)pgm_read_word(&ProgOptions[ProgMode])); // Show current function onto the LCD

			MAIN_WaitForJoyRelease();
		}
	}

	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_CLOCKSPEED_8MHZ);
	LCD_puts_f(WaitText);

	USI_SPIInitMaster(eeprom_read_byte(&EEPROMVars.SCKDuration));
	MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE); // Capture the RESET line of the slave AVR
			
	for (uint8_t PacketB = 0; PacketB <= 11; PacketB++) // Read the enter programming mode command bytes
	  PacketBytes[PacketB] = eeprom_read_byte(&EEPROMVars.EnterProgMode[PacketB]);
	
	ISPCC_EnterChipProgrammingMode();    // Try to sync with the slave AVR

	CurrAddress = 0;

	if (PacketBytes[1] == AICB_STATUS_CMD_OK) // ISPCC_EnterChipProgrammingMode alters the PacketBytes buffer rather than returning a value
	{						
		if (!(ProgMode) || (ProgMode == 7) || (ProgMode == 1) || (ProgMode == 3)) // All, erase chip, flash and eeprom, or program flash mode
		{
			MAIN_ShowProgType('C');
			
			if (!(eeprom_read_byte(&EEPROMVars.EraseCmdStored) == TRUE))
			{
				Fault = ISPCC_FAULT_NOERASE;
				MAIN_ShowError(PSTR("NO ERASE CMD"));
			}
			else
			{
				PM_SendEraseCommand();
			}
		}

		if ((!(ProgMode) || (ProgMode == 1) || (ProgMode == 3)) && (Fault == ISPCC_NO_FAULT)) // All, flash and EEPROM, or program flash mode
		{
			MAIN_ShowProgType('D');

			if (!(PM_GetStoredDataSize(TYPE_FLASH))) // Check to make sure a program is present in memory
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
				MAIN_ShowError(PSTR("NO DATA"));
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_FLASH);
			}
		}
	
		if (!(ProgMode) || (ProgMode == 2) || (ProgMode == 3)) // All, flash and EEPROM, or program EEPROM mode
		{
			MAIN_ShowProgType('E');
				
			if (!(PM_GetStoredDataSize(TYPE_EEPROM))) // Check to make sure EEPROM data is present in memory
			{
				Fault = ISPCC_FAULT_NODATATYPE;
				MAIN_ShowError(PSTR("NO EEPROM"));
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_EEPROM);
			}
		}

		if (!(ProgMode) || (ProgMode == 4) || (ProgMode == 6)) // All, fuse and lock bytes, or program fuse bytes mode
		{
			MAIN_ShowProgType('F');
			
			if (!(eeprom_read_byte(&EEPROMVars.TotalFuseBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
				MAIN_ShowError(PSTR("NO FUSE BYTES"));
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_FUSE);
			}
		}

		if (!(ProgMode) || (ProgMode == 5) || (ProgMode == 6)) // All, fuse and lock bytes, or program lock bytes mode
		{
			if (ProgMode == 6)                    // If fusebytes have already been written, we need to reenter programming mode to latch them
			{
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line of the slave AVR
				MAIN_Delay10MS(1);
				MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);   // Capture the RESET line of the slave AVR
				ISPCC_EnterChipProgrammingMode(); // Try to sync with the slave AVR
			}

			MAIN_ShowProgType('L');
		
			if (!(eeprom_read_byte(&EEPROMVars.TotalLockBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;
				MAIN_ShowError(PSTR("NO LOCK BYTES"));
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_LOCK);
			}
		}

		strcpy_P(DoneFailMessageBuff, PSTR("PROGRAMMING DONE"));

		if (Fault != ISPCC_NO_FAULT)         // Takes less code to just overwrite part of the string on fail
		  strcpy_P(&DoneFailMessageBuff[12], PSTR("FAILED"));

		LCD_puts(DoneFailMessageBuff);

		MAIN_Delay10MS(255);
		MAIN_Delay10MS(100);
	}
	else
	{
		MAIN_ShowError(SyncErrorMessage);
	}
	
	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_CLOCKSPEED_1MHZ);
	MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run	
	USI_SPIOff();
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Green = ready
}

void FUNCStoreProgram(void)
{
	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
	SPI_SPIInit();
	UseExernalDF = FALSE;
	DF_EnableDataflash(TRUE);

	if (!(DF_CheckCorrectOnboardChip()))
	  return;
			
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(PSTR("*STORAGE MODE*"));

	InterpretPacketRoutine = (FuncPtr)PM_InterpretAVRISPPacket;
	V2P_RunStateMachine();
	
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
}

void FUNCClearMem(void)
{
	LCD_puts_f(PSTR("CONFIRM"));
	MAIN_Delay10MS(180);

	LCD_puts_f(PSTR("<N Y>"));

	while (1)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_LEFT)
			  return;
			else if (JoyStatus & JOY_RIGHT)
			  break;
		}
	}

	MAIN_WaitForJoyRelease();

	LCD_puts_f(WaitText);

	for (uint16_t EAddr = 0; EAddr < sizeof(EEPROMVars); EAddr++)
	  eeprom_write_byte((uint8_t*)EAddr, 0xFF);

	LCD_puts_f(PSTR("MEM CLEARED"));
	MAIN_Delay10MS(255);
}

void FUNCSetContrast(void)
{
	uint8_t Buffer[6];
	uint8_t Contrast = (eeprom_read_byte(&EEPROMVars.LCDContrast) & 0x0F); // Ranges from 0-15 so mask retuns 15 on blank EEPROM (0xFF)
	
	JoyStatus = 1;                          // Invalid value to force the LCD to update
	
	while (1)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				if (Contrast < 15)
				  Contrast++;
			}
			else if (JoyStatus & JOY_DOWN)
			{
				if (Contrast > 1)          // Zero is non-visible, so 1 is the minimum
				  Contrast--;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.LCDContrast, Contrast);
				return;
			}
					
			Buffer[0] = 'C';
			Buffer[1] = 'T';
			Buffer[2] = ' ';

			MAIN_IntToStr((uint16_t)Contrast, &Buffer[3]);
			LCD_puts(Buffer);

			LCD_CONTRAST_LEVEL(Contrast);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCSetISPSpeed(void)
{
	uint8_t CurrSpeed = eeprom_read_byte(&EEPROMVars.SCKDuration);

	if (CurrSpeed > ARRAY_UPPERBOUND(USISpeeds)) CurrSpeed = ARRAY_UPPERBOUND(USISpeeds); // Protection against blank EEPROM

	JoyStatus = 1;                         // Invalid value to force the LCD to update

	while (1)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				(CurrSpeed == 0)? CurrSpeed = ARRAY_UPPERBOUND(USISpeeds) : CurrSpeed--;
			}
			else if (JoyStatus & JOY_DOWN)
			{
				(CurrSpeed == ARRAY_UPPERBOUND(USISpeeds))? CurrSpeed = 0 : CurrSpeed++;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.SCKDuration, CurrSpeed);
				return;
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f(USISpeeds[CurrSpeed]);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCSetFirmMinorVer(void)
{
	uint8_t VerBuffer[5];
	uint8_t VerMinor = eeprom_read_byte(&EEPROMVars.FirmVerMinor);

	if (VerMinor > 9)
	  VerMinor = V2P_SW_VERSION_MINOR_DEFAULT;
	
	strcpy_P(VerBuffer, PSTR("V2- "));

	JoyStatus = 1;                        // Invalid value to force the LCD to update

	while (1)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				if (VerMinor < 9)
				  VerMinor++;
			}
			if (JoyStatus & JOY_DOWN)
			{
				if (VerMinor)
				  VerMinor--;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.FirmVerMinor, VerMinor);
				return;
			}
			
			VerBuffer[3] = ('0' + VerMinor);
			LCD_puts(VerBuffer);

			MAIN_WaitForJoyRelease();
		}
	}	
}

void FUNCSetAutoSleepTimeOut(void)
{
	uint8_t SleepTxtBuffer[8];
	uint8_t SleepVal = eeprom_read_byte(&EEPROMVars.AutoSleepValIndex);

	if (SleepVal > 4)
	  SleepVal = 4;

	strcpy_P(SleepTxtBuffer, PSTR("    SEC"));
	
	JoyStatus = 1;                        // Invalid value to force the LCD to update

	while (1)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				(SleepVal == 0)? SleepVal = ARRAY_UPPERBOUND(AutoSleepTOValues) : SleepVal--;
			}
			if (JoyStatus & JOY_DOWN)
			{
				(SleepVal == ARRAY_UPPERBOUND(AutoSleepTOValues))? SleepVal = 0 : SleepVal++;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.AutoSleepValIndex, SleepVal);
				TOUT_SetupSleepTimer();
				return;
			}

			if (!(SleepVal))
			{
				LCD_puts_f(PSTR("OFF"));
			}
			else
			{
				MAIN_IntToStr(pgm_read_byte(&AutoSleepTOValues[SleepVal]), &SleepTxtBuffer[0]);
				SleepTxtBuffer[3] = ' '; // Remove the auto-string termination from the buffer
				LCD_puts(SleepTxtBuffer);
			}

			MAIN_WaitForJoyRelease();
		}
	}	
}

void FUNCSleepMode(void)
{
     560:	85 e0       	ldi	r24, 0x05	; 5
     562:	83 bf       	out	0x33, r24	; 51
	SMCR    = ((1 << SM1) | (1 << SE));    // Power down sleep mode
	LCDCRA &= ~(1 << LCDEN); 
     564:	80 91 e4 00 	lds	r24, 0x00E4
     568:	8f 77       	andi	r24, 0x7F	; 127
     56a:	80 93 e4 00 	sts	0x00E4, r24
     56e:	01 c0       	rjmp	.+2      	; 0x572 <FUNCSleepMode+0x12>
	
	while (!(JoyStatus & JOY_UP))         // Joystick interrupt wakes the micro
	  SLEEP();
     570:	88 95       	sleep
     572:	f6 9b       	sbis	0x1e, 6	; 30
     574:	fd cf       	rjmp	.-6      	; 0x570 <FUNCSleepMode+0x10>
	   
	LCDCRA |= (1 << LCDEN);
     576:	80 91 e4 00 	lds	r24, 0x00E4
     57a:	80 68       	ori	r24, 0x80	; 128
     57c:	80 93 e4 00 	sts	0x00E4, r24
	
	MAIN_WaitForJoyRelease();
     580:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
     584:	08 95       	ret

00000586 <FUNCGoBootloader>:
}

void FUNCStorageInfo(void)
{
	uint8_t SelectedItem = 0;

	MAIN_WaitForJoyRelease();

	JoyStatus = 1;                        // Invalid value to force the LCD to update

	while (1)
	{
		if (JoyStatus)
		{
			if (JoyStatus & (JOY_UP | JOY_DOWN))
			{
				SelectedItem ^= 1;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				return;
			}
			else if (JoyStatus & JOY_PRESS)
			{
				if (SelectedItem == 1)    // View storage tags
				{
					DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
					SPI_SPIInit();
					UseExernalDF = FALSE;
					DF_EnableDataflash(TRUE);

					if (DF_CheckCorrectOnboardChip())
					{
						TM_ShowTags();
						SPI_SPIOFF();
					}
					else if (!(PM_GetStoredDataSize(TYPE_FLASH)))
					{
						DF_EnableDataflash(FALSE);
						SPI_SPIOFF();

						MAIN_ShowError(PSTR("NO STORED PRGM"));
					}	
				}
				else                      // View stored data sizes
				{
					PM_ShowStoredItemSizes();
				}
			}
			
			LCD_puts_f(SIFONames[SelectedItem]);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCGoBootloader(void)
{
     586:	85 b7       	in	r24, 0x35	; 53
     588:	8f 77       	andi	r24, 0x7F	; 127
	uint8_t MD = (MCUCR & ~(1 << JTD));   // Forces compiler to use IN, AND plus two OUTs rather than two lots of IN/AND/OUTs
	MCUCR = MD;                           // Turn on JTAG via code
     58a:	85 bf       	out	0x35, r24	; 53
	MCUCR = MD;                           // Set bit twice as specified in datasheet        
     58c:	85 bf       	out	0x35, r24	; 53

	TIMEOUT_SLEEP_TIMER_OFF();
     58e:	10 92 81 00 	sts	0x0081, r1
	
	LCD_puts_f(PSTR("*JTAG ON*"));
     592:	8c e5       	ldi	r24, 0x5C	; 92
     594:	92 e0       	ldi	r25, 0x02	; 2
     596:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
	
	MAIN_WaitForJoyRelease();
     59a:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
	
	WDTCR = ((1<<WDCE) | (1<<WDE));       // Enable Watchdog Timer to give reset after minimum timeout
     59e:	88 e1       	ldi	r24, 0x18	; 24
     5a0:	80 93 60 00 	sts	0x0060, r24
     5a4:	ff cf       	rjmp	.-2      	; 0x5a4 <FUNCGoBootloader+0x1e>

000005a6 <FUNCShowAbout>:
     5a6:	1f 93       	push	r17
     5a8:	81 e0       	ldi	r24, 0x01	; 1
     5aa:	8e bb       	out	0x1e, r24	; 30
     5ac:	10 e0       	ldi	r17, 0x00	; 0
     5ae:	8e b3       	in	r24, 0x1e	; 30
     5b0:	88 23       	and	r24, r24
     5b2:	e9 f3       	breq	.-6      	; 0x5ae <FUNCShowAbout+0x8>
     5b4:	f6 9b       	sbis	0x1e, 6	; 30
     5b6:	06 c0       	rjmp	.+12     	; 0x5c4 <FUNCShowAbout+0x1e>
     5b8:	11 23       	and	r17, r17
     5ba:	11 f4       	brne	.+4      	; 0x5c0 <FUNCShowAbout+0x1a>
     5bc:	13 e0       	ldi	r17, 0x03	; 3
     5be:	0c c0       	rjmp	.+24     	; 0x5d8 <FUNCShowAbout+0x32>
     5c0:	11 50       	subi	r17, 0x01	; 1
     5c2:	0a c0       	rjmp	.+20     	; 0x5d8 <FUNCShowAbout+0x32>
     5c4:	f7 9b       	sbis	0x1e, 7	; 30
     5c6:	06 c0       	rjmp	.+12     	; 0x5d4 <FUNCShowAbout+0x2e>
     5c8:	13 30       	cpi	r17, 0x03	; 3
     5ca:	11 f4       	brne	.+4      	; 0x5d0 <FUNCShowAbout+0x2a>
     5cc:	10 e0       	ldi	r17, 0x00	; 0
     5ce:	04 c0       	rjmp	.+8      	; 0x5d8 <FUNCShowAbout+0x32>
     5d0:	1f 5f       	subi	r17, 0xFF	; 255
     5d2:	02 c0       	rjmp	.+4      	; 0x5d8 <FUNCShowAbout+0x32>
     5d4:	f2 99       	sbic	0x1e, 2	; 30
     5d6:	0d c0       	rjmp	.+26     	; 0x5f2 <FUNCShowAbout+0x4c>
     5d8:	e1 2f       	mov	r30, r17
     5da:	ff 27       	eor	r31, r31
     5dc:	ee 0f       	add	r30, r30
     5de:	ff 1f       	adc	r31, r31
     5e0:	e1 56       	subi	r30, 0x61	; 97
     5e2:	ff 4f       	sbci	r31, 0xFF	; 255
     5e4:	85 91       	lpm	r24, Z+
     5e6:	94 91       	lpm	r25, Z
     5e8:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     5ec:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
     5f0:	de cf       	rjmp	.-68     	; 0x5ae <FUNCShowAbout+0x8>
     5f2:	1f 91       	pop	r17
     5f4:	08 95       	ret

000005f6 <FUNCChangeSettings>:
     5f6:	1f 93       	push	r17
     5f8:	81 e0       	ldi	r24, 0x01	; 1
     5fa:	8e bb       	out	0x1e, r24	; 30
     5fc:	10 e0       	ldi	r17, 0x00	; 0
     5fe:	8e b3       	in	r24, 0x1e	; 30
     600:	88 23       	and	r24, r24
     602:	e9 f3       	breq	.-6      	; 0x5fe <FUNCChangeSettings+0x8>
     604:	f6 9b       	sbis	0x1e, 6	; 30
     606:	06 c0       	rjmp	.+12     	; 0x614 <FUNCChangeSettings+0x1e>
     608:	11 23       	and	r17, r17
     60a:	11 f4       	brne	.+4      	; 0x610 <FUNCChangeSettings+0x1a>
     60c:	15 e0       	ldi	r17, 0x05	; 5
     60e:	19 c0       	rjmp	.+50     	; 0x642 <FUNCChangeSettings+0x4c>
     610:	11 50       	subi	r17, 0x01	; 1
     612:	17 c0       	rjmp	.+46     	; 0x642 <FUNCChangeSettings+0x4c>
     614:	f7 9b       	sbis	0x1e, 7	; 30
     616:	06 c0       	rjmp	.+12     	; 0x624 <FUNCChangeSettings+0x2e>
     618:	15 30       	cpi	r17, 0x05	; 5
     61a:	11 f4       	brne	.+4      	; 0x620 <FUNCChangeSettings+0x2a>
     61c:	10 e0       	ldi	r17, 0x00	; 0
     61e:	11 c0       	rjmp	.+34     	; 0x642 <FUNCChangeSettings+0x4c>
     620:	1f 5f       	subi	r17, 0xFF	; 255
     622:	0f c0       	rjmp	.+30     	; 0x642 <FUNCChangeSettings+0x4c>
     624:	f4 9b       	sbis	0x1e, 4	; 30
     626:	0b c0       	rjmp	.+22     	; 0x63e <FUNCChangeSettings+0x48>
     628:	e1 2f       	mov	r30, r17
     62a:	ff 27       	eor	r31, r31
     62c:	ee 0f       	add	r30, r30
     62e:	ff 1f       	adc	r31, r31
     630:	e7 57       	subi	r30, 0x77	; 119
     632:	fe 4f       	sbci	r31, 0xFE	; 254
     634:	85 91       	lpm	r24, Z+
     636:	94 91       	lpm	r25, Z
     638:	fc 01       	movw	r30, r24
     63a:	09 95       	icall
     63c:	02 c0       	rjmp	.+4      	; 0x642 <FUNCChangeSettings+0x4c>
     63e:	f2 99       	sbic	0x1e, 2	; 30
     640:	0d c0       	rjmp	.+26     	; 0x65c <FUNCChangeSettings+0x66>
     642:	e1 2f       	mov	r30, r17
     644:	ff 27       	eor	r31, r31
     646:	ee 0f       	add	r30, r30
     648:	ff 1f       	adc	r31, r31
     64a:	e3 58       	subi	r30, 0x83	; 131
     64c:	fe 4f       	sbci	r31, 0xFE	; 254
     64e:	85 91       	lpm	r24, Z+
     650:	94 91       	lpm	r25, Z
     652:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     656:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
     65a:	d1 cf       	rjmp	.-94     	; 0x5fe <FUNCChangeSettings+0x8>
     65c:	1f 91       	pop	r17
     65e:	08 95       	ret

00000660 <FUNCSetAutoSleepTimeOut>:
     660:	ef 92       	push	r14
     662:	ff 92       	push	r15
     664:	0f 93       	push	r16
     666:	cf 93       	push	r28
     668:	df 93       	push	r29
     66a:	cd b7       	in	r28, 0x3d	; 61
     66c:	de b7       	in	r29, 0x3e	; 62
     66e:	28 97       	sbiw	r28, 0x08	; 8
     670:	0f b6       	in	r0, 0x3f	; 63
     672:	f8 94       	cli
     674:	de bf       	out	0x3e, r29	; 62
     676:	0f be       	out	0x3f, r0	; 63
     678:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     67a:	a8 e8       	ldi	r26, 0x88	; 136
     67c:	b0 e0       	ldi	r27, 0x00	; 0
     67e:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
     682:	80 2d       	mov	r24, r0
     684:	08 2f       	mov	r16, r24
     686:	85 30       	cpi	r24, 0x05	; 5
     688:	08 f0       	brcs	.+2      	; 0x68c <FUNCSetAutoSleepTimeOut+0x2c>
     68a:	04 e0       	ldi	r16, 0x04	; 4
     68c:	69 e7       	ldi	r22, 0x79	; 121
     68e:	72 e0       	ldi	r23, 0x02	; 2
     690:	ce 01       	movw	r24, r28
     692:	01 96       	adiw	r24, 0x01	; 1
     694:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <strcpy_P>
     698:	81 e0       	ldi	r24, 0x01	; 1
     69a:	8e bb       	out	0x1e, r24	; 30
     69c:	8e b3       	in	r24, 0x1e	; 30
     69e:	88 23       	and	r24, r24
     6a0:	e9 f3       	breq	.-6      	; 0x69c <FUNCSetAutoSleepTimeOut+0x3c>
     6a2:	f6 9b       	sbis	0x1e, 6	; 30
     6a4:	05 c0       	rjmp	.+10     	; 0x6b0 <FUNCSetAutoSleepTimeOut+0x50>
     6a6:	00 23       	and	r16, r16
     6a8:	11 f4       	brne	.+4      	; 0x6ae <FUNCSetAutoSleepTimeOut+0x4e>
     6aa:	04 e0       	ldi	r16, 0x04	; 4
     6ac:	01 c0       	rjmp	.+2      	; 0x6b0 <FUNCSetAutoSleepTimeOut+0x50>
     6ae:	01 50       	subi	r16, 0x01	; 1
     6b0:	f7 9b       	sbis	0x1e, 7	; 30
     6b2:	06 c0       	rjmp	.+12     	; 0x6c0 <FUNCSetAutoSleepTimeOut+0x60>
     6b4:	04 30       	cpi	r16, 0x04	; 4
     6b6:	11 f4       	brne	.+4      	; 0x6bc <FUNCSetAutoSleepTimeOut+0x5c>
     6b8:	00 e0       	ldi	r16, 0x00	; 0
     6ba:	06 c0       	rjmp	.+12     	; 0x6c8 <FUNCSetAutoSleepTimeOut+0x68>
     6bc:	0f 5f       	subi	r16, 0xFF	; 255
     6be:	02 c0       	rjmp	.+4      	; 0x6c4 <FUNCSetAutoSleepTimeOut+0x64>
     6c0:	f2 99       	sbic	0x1e, 2	; 30
     6c2:	1d c0       	rjmp	.+58     	; 0x6fe <FUNCSetAutoSleepTimeOut+0x9e>
     6c4:	00 23       	and	r16, r16
     6c6:	29 f4       	brne	.+10     	; 0x6d2 <FUNCSetAutoSleepTimeOut+0x72>
     6c8:	85 e7       	ldi	r24, 0x75	; 117
     6ca:	92 e0       	ldi	r25, 0x02	; 2
     6cc:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     6d0:	13 c0       	rjmp	.+38     	; 0x6f8 <FUNCSetAutoSleepTimeOut+0x98>
     6d2:	e0 2f       	mov	r30, r16
     6d4:	ff 27       	eor	r31, r31
     6d6:	e6 53       	subi	r30, 0x36	; 54
     6d8:	fc 4f       	sbci	r31, 0xFC	; 252
     6da:	e4 91       	lpm	r30, Z
     6dc:	7e 01       	movw	r14, r28
     6de:	08 94       	sec
     6e0:	e1 1c       	adc	r14, r1
     6e2:	f1 1c       	adc	r15, r1
     6e4:	b7 01       	movw	r22, r14
     6e6:	8e 2f       	mov	r24, r30
     6e8:	99 27       	eor	r25, r25
     6ea:	0e 94 72 02 	call	0x4e4	; 0x4e4 <MAIN_IntToStr>
     6ee:	80 e2       	ldi	r24, 0x20	; 32
     6f0:	8c 83       	std	Y+4, r24	; 0x04
     6f2:	c7 01       	movw	r24, r14
     6f4:	0e 94 15 08 	call	0x102a	; 0x102a <LCD_puts>
     6f8:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
     6fc:	cf cf       	rjmp	.-98     	; 0x69c <FUNCSetAutoSleepTimeOut+0x3c>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     6fe:	a8 e8       	ldi	r26, 0x88	; 136
     700:	b0 e0       	ldi	r27, 0x00	; 0
     702:	00 2e       	mov	r0, r16
     704:	0e 94 36 1a 	call	0x346c	; 0x346c <__eeprom_write_byte_1F2021>
     708:	0e 94 07 0c 	call	0x180e	; 0x180e <TOUT_SetupSleepTimer>
     70c:	28 96       	adiw	r28, 0x08	; 8
     70e:	0f b6       	in	r0, 0x3f	; 63
     710:	f8 94       	cli
     712:	de bf       	out	0x3e, r29	; 62
     714:	0f be       	out	0x3f, r0	; 63
     716:	cd bf       	out	0x3d, r28	; 61
     718:	df 91       	pop	r29
     71a:	cf 91       	pop	r28
     71c:	0f 91       	pop	r16
     71e:	ff 90       	pop	r15
     720:	ef 90       	pop	r14
     722:	08 95       	ret

00000724 <MAIN_ShowError>:
     724:	cf 93       	push	r28
     726:	df 93       	push	r29
     728:	cd b7       	in	r28, 0x3d	; 61
     72a:	de b7       	in	r29, 0x3e	; 62
     72c:	64 97       	sbiw	r28, 0x14	; 20
     72e:	0f b6       	in	r0, 0x3f	; 63
     730:	f8 94       	cli
     732:	de bf       	out	0x3e, r29	; 62
     734:	0f be       	out	0x3f, r0	; 63
     736:	cd bf       	out	0x3d, r28	; 61
     738:	25 e4       	ldi	r18, 0x45	; 69
     73a:	29 83       	std	Y+1, r18	; 0x01
     73c:	2e e3       	ldi	r18, 0x3E	; 62
     73e:	2a 83       	std	Y+2, r18	; 0x02
     740:	bc 01       	movw	r22, r24
     742:	ce 01       	movw	r24, r28
     744:	03 96       	adiw	r24, 0x03	; 3
     746:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <strcpy_P>
     74a:	ce 01       	movw	r24, r28
     74c:	01 96       	adiw	r24, 0x01	; 1
     74e:	0e 94 15 08 	call	0x102a	; 0x102a <LCD_puts>
     752:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
     756:	f4 9b       	sbis	0x1e, 4	; 30
     758:	fe cf       	rjmp	.-4      	; 0x756 <MAIN_ShowError+0x32>
     75a:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
     75e:	64 96       	adiw	r28, 0x14	; 20
     760:	0f b6       	in	r0, 0x3f	; 63
     762:	f8 94       	cli
     764:	de bf       	out	0x3e, r29	; 62
     766:	0f be       	out	0x3f, r0	; 63
     768:	cd bf       	out	0x3d, r28	; 61
     76a:	df 91       	pop	r29
     76c:	cf 91       	pop	r28
     76e:	08 95       	ret

00000770 <FUNCStorageInfo>:
     770:	1f 93       	push	r17
     772:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
     776:	81 e0       	ldi	r24, 0x01	; 1
     778:	8e bb       	out	0x1e, r24	; 30
     77a:	10 e0       	ldi	r17, 0x00	; 0
     77c:	8e b3       	in	r24, 0x1e	; 30
     77e:	88 23       	and	r24, r24
     780:	e9 f3       	breq	.-6      	; 0x77c <FUNCStorageInfo+0xc>
     782:	8e b3       	in	r24, 0x1e	; 30
     784:	80 7c       	andi	r24, 0xC0	; 192
     786:	19 f0       	breq	.+6      	; 0x78e <FUNCStorageInfo+0x1e>
     788:	81 e0       	ldi	r24, 0x01	; 1
     78a:	18 27       	eor	r17, r24
     78c:	36 c0       	rjmp	.+108    	; 0x7fa <FUNCStorageInfo+0x8a>
     78e:	f2 99       	sbic	0x1e, 2	; 30
     790:	3f c0       	rjmp	.+126    	; 0x810 <FUNCStorageInfo+0xa0>
     792:	f4 9b       	sbis	0x1e, 4	; 30
     794:	32 c0       	rjmp	.+100    	; 0x7fa <FUNCStorageInfo+0x8a>
     796:	11 30       	cpi	r17, 0x01	; 1
     798:	71 f5       	brne	.+92     	; 0x7f6 <FUNCStorageInfo+0x86>
     79a:	82 e5       	ldi	r24, 0x52	; 82
     79c:	99 e0       	ldi	r25, 0x09	; 9
     79e:	90 93 01 01 	sts	0x0101, r25
     7a2:	80 93 00 01 	sts	0x0100, r24
     7a6:	0e 94 48 09 	call	0x1290	; 0x1290 <SPI_SPIInit>
     7aa:	10 92 3f 01 	sts	0x013F, r1
     7ae:	81 e0       	ldi	r24, 0x01	; 1
     7b0:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
     7b4:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <DF_CheckCorrectOnboardChip>
     7b8:	88 23       	and	r24, r24
     7ba:	41 f0       	breq	.+16     	; 0x7cc <FUNCStorageInfo+0x5c>
     7bc:	0e 94 b9 19 	call	0x3372	; 0x3372 <TM_ShowTags>
     7c0:	80 91 64 00 	lds	r24, 0x0064
     7c4:	84 60       	ori	r24, 0x04	; 4
     7c6:	80 93 64 00 	sts	0x0064, r24
     7ca:	17 c0       	rjmp	.+46     	; 0x7fa <FUNCStorageInfo+0x8a>
     7cc:	81 e0       	ldi	r24, 0x01	; 1
     7ce:	0e 94 85 14 	call	0x290a	; 0x290a <PM_GetStoredDataSize>
     7d2:	61 15       	cp	r22, r1
     7d4:	71 05       	cpc	r23, r1
     7d6:	81 05       	cpc	r24, r1
     7d8:	91 05       	cpc	r25, r1
     7da:	79 f4       	brne	.+30     	; 0x7fa <FUNCStorageInfo+0x8a>
     7dc:	80 e0       	ldi	r24, 0x00	; 0
     7de:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
     7e2:	80 91 64 00 	lds	r24, 0x0064
     7e6:	84 60       	ori	r24, 0x04	; 4
     7e8:	80 93 64 00 	sts	0x0064, r24
     7ec:	86 e6       	ldi	r24, 0x66	; 102
     7ee:	92 e0       	ldi	r25, 0x02	; 2
     7f0:	0e 94 92 03 	call	0x724	; 0x724 <MAIN_ShowError>
     7f4:	02 c0       	rjmp	.+4      	; 0x7fa <FUNCStorageInfo+0x8a>
     7f6:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <PM_ShowStoredItemSizes>
     7fa:	8f e0       	ldi	r24, 0x0F	; 15
     7fc:	18 9f       	mul	r17, r24
     7fe:	c0 01       	movw	r24, r0
     800:	11 24       	eor	r1, r1
     802:	82 5c       	subi	r24, 0xC2	; 194
     804:	9d 4f       	sbci	r25, 0xFD	; 253
     806:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     80a:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
     80e:	b6 cf       	rjmp	.-148    	; 0x77c <FUNCStorageInfo+0xc>
     810:	1f 91       	pop	r17
     812:	08 95       	ret

00000814 <__vector_default>:
     814:	82 e0       	ldi	r24, 0x02	; 2
     816:	93 e0       	ldi	r25, 0x03	; 3
     818:	0e 94 92 03 	call	0x724	; 0x724 <MAIN_ShowError>
     81c:	ff cf       	rjmp	.-2      	; 0x81c <__vector_default+0x8>

0000081e <MAIN_ShowProgType>:
     81e:	ff 92       	push	r15
     820:	0f 93       	push	r16
     822:	1f 93       	push	r17
     824:	cf 93       	push	r28
     826:	df 93       	push	r29
     828:	cd b7       	in	r28, 0x3d	; 61
     82a:	de b7       	in	r29, 0x3e	; 62
     82c:	27 97       	sbiw	r28, 0x07	; 7
     82e:	0f b6       	in	r0, 0x3f	; 63
     830:	f8 94       	cli
     832:	de bf       	out	0x3e, r29	; 62
     834:	0f be       	out	0x3f, r0	; 63
     836:	cd bf       	out	0x3d, r28	; 61
     838:	f8 2e       	mov	r15, r24
     83a:	8e 01       	movw	r16, r28
     83c:	0f 5f       	subi	r16, 0xFF	; 255
     83e:	1f 4f       	sbci	r17, 0xFF	; 255
     840:	69 e0       	ldi	r22, 0x09	; 9
     842:	73 e0       	ldi	r23, 0x03	; 3
     844:	c8 01       	movw	r24, r16
     846:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <strcpy_P>
     84a:	fe 82       	std	Y+6, r15	; 0x06
     84c:	c8 01       	movw	r24, r16
     84e:	0e 94 15 08 	call	0x102a	; 0x102a <LCD_puts>
     852:	27 96       	adiw	r28, 0x07	; 7
     854:	0f b6       	in	r0, 0x3f	; 63
     856:	f8 94       	cli
     858:	de bf       	out	0x3e, r29	; 62
     85a:	0f be       	out	0x3f, r0	; 63
     85c:	cd bf       	out	0x3d, r28	; 61
     85e:	df 91       	pop	r29
     860:	cf 91       	pop	r28
     862:	1f 91       	pop	r17
     864:	0f 91       	pop	r16
     866:	ff 90       	pop	r15
     868:	08 95       	ret

0000086a <FUNCStoreProgram>:
     86a:	82 e5       	ldi	r24, 0x52	; 82
     86c:	99 e0       	ldi	r25, 0x09	; 9
     86e:	90 93 01 01 	sts	0x0101, r25
     872:	80 93 00 01 	sts	0x0100, r24
     876:	0e 94 48 09 	call	0x1290	; 0x1290 <SPI_SPIInit>
     87a:	10 92 3f 01 	sts	0x013F, r1
     87e:	81 e0       	ldi	r24, 0x01	; 1
     880:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
     884:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <DF_CheckCorrectOnboardChip>
     888:	88 23       	and	r24, r24
     88a:	01 f1       	breq	.+64     	; 0x8cc <FUNCStoreProgram+0x62>
     88c:	87 ea       	ldi	r24, 0xA7	; 167
     88e:	90 e0       	ldi	r25, 0x00	; 0
     890:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     894:	0e 94 82 07 	call	0xf04	; 0xf04 <OSCCAL_Calibrate>
     898:	80 91 c1 00 	lds	r24, 0x00C1
     89c:	80 78       	andi	r24, 0x80	; 128
     89e:	88 61       	ori	r24, 0x18	; 24
     8a0:	80 93 c1 00 	sts	0x00C1, r24
     8a4:	80 ea       	ldi	r24, 0xA0	; 160
     8a6:	92 e0       	ldi	r25, 0x02	; 2
     8a8:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     8ac:	87 ee       	ldi	r24, 0xE7	; 231
     8ae:	96 e1       	ldi	r25, 0x16	; 22
     8b0:	90 93 03 01 	sts	0x0103, r25
     8b4:	80 93 02 01 	sts	0x0102, r24
     8b8:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <V2P_RunStateMachine>
     8bc:	80 e0       	ldi	r24, 0x00	; 0
     8be:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
     8c2:	80 91 64 00 	lds	r24, 0x0064
     8c6:	84 60       	ori	r24, 0x04	; 4
     8c8:	80 93 64 00 	sts	0x0064, r24
     8cc:	08 95       	ret

000008ce <FUNCAVRISPMode>:
     8ce:	87 ea       	ldi	r24, 0xA7	; 167
     8d0:	90 e0       	ldi	r25, 0x00	; 0
     8d2:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     8d6:	0e 94 82 07 	call	0xf04	; 0xf04 <OSCCAL_Calibrate>
     8da:	e1 ec       	ldi	r30, 0xC1	; 193
     8dc:	f0 e0       	ldi	r31, 0x00	; 0
     8de:	80 81       	ld	r24, Z
     8e0:	80 78       	andi	r24, 0x80	; 128
     8e2:	88 61       	ori	r24, 0x18	; 24
     8e4:	80 83       	st	Z, r24
     8e6:	8b e0       	ldi	r24, 0x0B	; 11
     8e8:	94 e0       	ldi	r25, 0x04	; 4
     8ea:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     8ee:	84 e8       	ldi	r24, 0x84	; 132
     8f0:	92 e1       	ldi	r25, 0x12	; 18
     8f2:	90 93 03 01 	sts	0x0103, r25
     8f6:	80 93 02 01 	sts	0x0102, r24
     8fa:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <V2P_RunStateMachine>
     8fe:	08 95       	ret

00000900 <FUNCProgramDataflash>:
     900:	a2 e0       	ldi	r26, 0x02	; 2
     902:	b0 e0       	ldi	r27, 0x00	; 0
     904:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
     908:	80 2d       	mov	r24, r0
     90a:	0e 94 cc 09 	call	0x1398	; 0x1398 <USI_SPIInitMaster>
     90e:	81 e0       	ldi	r24, 0x01	; 1
     910:	80 93 3f 01 	sts	0x013F, r24
     914:	81 e9       	ldi	r24, 0x91	; 145
     916:	99 e0       	ldi	r25, 0x09	; 9
     918:	90 93 01 01 	sts	0x0101, r25
     91c:	80 93 00 01 	sts	0x0100, r24
     920:	87 ea       	ldi	r24, 0xA7	; 167
     922:	90 e0       	ldi	r25, 0x00	; 0
     924:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     928:	0e 94 82 07 	call	0xf04	; 0xf04 <OSCCAL_Calibrate>
     92c:	e1 ec       	ldi	r30, 0xC1	; 193
     92e:	f0 e0       	ldi	r31, 0x00	; 0
     930:	80 81       	ld	r24, Z
     932:	80 78       	andi	r24, 0x80	; 128
     934:	88 61       	ori	r24, 0x18	; 24
     936:	80 83       	st	Z, r24
     938:	8f ec       	ldi	r24, 0xCF	; 207
     93a:	93 e0       	ldi	r25, 0x03	; 3
     93c:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     940:	89 ee       	ldi	r24, 0xE9	; 233
     942:	9c e0       	ldi	r25, 0x0C	; 12
     944:	90 93 03 01 	sts	0x0103, r25
     948:	80 93 02 01 	sts	0x0102, r24
     94c:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <V2P_RunStateMachine>
     950:	80 e0       	ldi	r24, 0x00	; 0
     952:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
     956:	e4 e6       	ldi	r30, 0x64	; 100
     958:	f0 e0       	ldi	r31, 0x00	; 0
     95a:	80 81       	ld	r24, Z
     95c:	84 60       	ori	r24, 0x04	; 4
     95e:	80 83       	st	Z, r24
     960:	08 95       	ret

00000962 <FUNCProgramAVR>:
     962:	ff 92       	push	r15
     964:	0f 93       	push	r16
     966:	1f 93       	push	r17
     968:	cf 93       	push	r28
     96a:	df 93       	push	r29
     96c:	cd b7       	in	r28, 0x3d	; 61
     96e:	de b7       	in	r29, 0x3e	; 62
     970:	63 97       	sbiw	r28, 0x13	; 19
     972:	0f b6       	in	r0, 0x3f	; 63
     974:	f8 94       	cli
     976:	de bf       	out	0x3e, r29	; 62
     978:	0f be       	out	0x3f, r0	; 63
     97a:	cd bf       	out	0x3d, r28	; 61
     97c:	0e 94 48 09 	call	0x1290	; 0x1290 <SPI_SPIInit>
     980:	10 92 3f 01 	sts	0x013F, r1
     984:	82 e5       	ldi	r24, 0x52	; 82
     986:	99 e0       	ldi	r25, 0x09	; 9
     988:	90 93 01 01 	sts	0x0101, r25
     98c:	80 93 00 01 	sts	0x0100, r24
     990:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <DF_CheckCorrectOnboardChip>
     994:	88 23       	and	r24, r24
     996:	09 f4       	brne	.+2      	; 0x99a <FUNCProgramAVR+0x38>
     998:	2d c1       	rjmp	.+602    	; 0xbf4 <FUNCProgramAVR+0x292>
     99a:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
     99e:	81 e0       	ldi	r24, 0x01	; 1
     9a0:	8e bb       	out	0x1e, r24	; 30
     9a2:	ff 24       	eor	r15, r15
     9a4:	8e b3       	in	r24, 0x1e	; 30
     9a6:	88 23       	and	r24, r24
     9a8:	e9 f3       	breq	.-6      	; 0x9a4 <FUNCProgramAVR+0x42>
     9aa:	f2 99       	sbic	0x1e, 2	; 30
     9ac:	23 c1       	rjmp	.+582    	; 0xbf4 <FUNCProgramAVR+0x292>
     9ae:	f4 99       	sbic	0x1e, 4	; 30
     9b0:	1e c0       	rjmp	.+60     	; 0x9ee <FUNCProgramAVR+0x8c>
     9b2:	f6 9b       	sbis	0x1e, 6	; 30
     9b4:	07 c0       	rjmp	.+14     	; 0x9c4 <FUNCProgramAVR+0x62>
     9b6:	ff 20       	and	r15, r15
     9b8:	19 f4       	brne	.+6      	; 0x9c0 <FUNCProgramAVR+0x5e>
     9ba:	47 e0       	ldi	r20, 0x07	; 7
     9bc:	f4 2e       	mov	r15, r20
     9be:	0a c0       	rjmp	.+20     	; 0x9d4 <FUNCProgramAVR+0x72>
     9c0:	fa 94       	dec	r15
     9c2:	08 c0       	rjmp	.+16     	; 0x9d4 <FUNCProgramAVR+0x72>
     9c4:	f7 9b       	sbis	0x1e, 7	; 30
     9c6:	06 c0       	rjmp	.+12     	; 0x9d4 <FUNCProgramAVR+0x72>
     9c8:	87 e0       	ldi	r24, 0x07	; 7
     9ca:	f8 16       	cp	r15, r24
     9cc:	11 f4       	brne	.+4      	; 0x9d2 <FUNCProgramAVR+0x70>
     9ce:	ff 24       	eor	r15, r15
     9d0:	01 c0       	rjmp	.+2      	; 0x9d4 <FUNCProgramAVR+0x72>
     9d2:	f3 94       	inc	r15
     9d4:	ef 2d       	mov	r30, r15
     9d6:	ff 27       	eor	r31, r31
     9d8:	ee 0f       	add	r30, r30
     9da:	ff 1f       	adc	r31, r31
     9dc:	ea 5f       	subi	r30, 0xFA	; 250
     9de:	fd 4f       	sbci	r31, 0xFD	; 253
     9e0:	85 91       	lpm	r24, Z+
     9e2:	94 91       	lpm	r25, Z
     9e4:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     9e8:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
     9ec:	db cf       	rjmp	.-74     	; 0x9a4 <FUNCProgramAVR+0x42>
     9ee:	80 e8       	ldi	r24, 0x80	; 128
     9f0:	80 93 61 00 	sts	0x0061, r24
     9f4:	10 92 61 00 	sts	0x0061, r1
     9f8:	87 ea       	ldi	r24, 0xA7	; 167
     9fa:	90 e0       	ldi	r25, 0x00	; 0
     9fc:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     a00:	02 e0       	ldi	r16, 0x02	; 2
     a02:	10 e0       	ldi	r17, 0x00	; 0
     a04:	d8 01       	movw	r26, r16
     a06:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
     a0a:	80 2d       	mov	r24, r0
     a0c:	0e 94 cc 09 	call	0x1398	; 0x1398 <USI_SPIInitMaster>
     a10:	80 e0       	ldi	r24, 0x00	; 0
     a12:	0e 94 51 02 	call	0x4a2	; 0x4a2 <MAIN_ResetCSLine>
     a16:	98 01       	movw	r18, r16
     a18:	2e 5d       	subi	r18, 0xDE	; 222
     a1a:	3f 4f       	sbci	r19, 0xFF	; 255
     a1c:	eb e4       	ldi	r30, 0x4B	; 75
     a1e:	f1 e0       	ldi	r31, 0x01	; 1
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     a20:	d9 01       	movw	r26, r18
     a22:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
     a26:	80 2d       	mov	r24, r0
     a28:	81 93       	st	Z+, r24
     a2a:	2f 5f       	subi	r18, 0xFF	; 255
     a2c:	3f 4f       	sbci	r19, 0xFF	; 255
     a2e:	80 e0       	ldi	r24, 0x00	; 0
     a30:	20 33       	cpi	r18, 0x30	; 48
     a32:	38 07       	cpc	r19, r24
     a34:	a9 f7       	brne	.-22     	; 0xa20 <FUNCProgramAVR+0xbe>
     a36:	0e 94 23 12 	call	0x2446	; 0x2446 <ISPCC_EnterChipProgrammingMode>
     a3a:	10 92 63 02 	sts	0x0263, r1
     a3e:	10 92 64 02 	sts	0x0264, r1
     a42:	10 92 65 02 	sts	0x0265, r1
     a46:	10 92 66 02 	sts	0x0266, r1
     a4a:	80 91 4c 01 	lds	r24, 0x014C
     a4e:	88 23       	and	r24, r24
     a50:	09 f0       	breq	.+2      	; 0xa54 <FUNCProgramAVR+0xf2>
     a52:	b5 c0       	rjmp	.+362    	; 0xbbe <FUNCProgramAVR+0x25c>
     a54:	ff 20       	and	r15, r15
     a56:	49 f0       	breq	.+18     	; 0xa6a <FUNCProgramAVR+0x108>
     a58:	87 e0       	ldi	r24, 0x07	; 7
     a5a:	f8 16       	cp	r15, r24
     a5c:	31 f0       	breq	.+12     	; 0xa6a <FUNCProgramAVR+0x108>
     a5e:	81 e0       	ldi	r24, 0x01	; 1
     a60:	f8 16       	cp	r15, r24
     a62:	19 f0       	breq	.+6      	; 0xa6a <FUNCProgramAVR+0x108>
     a64:	83 e0       	ldi	r24, 0x03	; 3
     a66:	f8 16       	cp	r15, r24
     a68:	91 f4       	brne	.+36     	; 0xa8e <FUNCProgramAVR+0x12c>
     a6a:	83 e4       	ldi	r24, 0x43	; 67
     a6c:	0e 94 0f 04 	call	0x81e	; 0x81e <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     a70:	a5 e1       	ldi	r26, 0x15	; 21
     a72:	b0 e0       	ldi	r27, 0x00	; 0
     a74:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
     a78:	80 2d       	mov	r24, r0
     a7a:	81 30       	cpi	r24, 0x01	; 1
     a7c:	31 f0       	breq	.+12     	; 0xa8a <FUNCProgramAVR+0x128>
     a7e:	85 ef       	ldi	r24, 0xF5	; 245
     a80:	92 e0       	ldi	r25, 0x02	; 2
     a82:	0e 94 92 03 	call	0x724	; 0x724 <MAIN_ShowError>
     a86:	02 e0       	ldi	r16, 0x02	; 2
     a88:	03 c0       	rjmp	.+6      	; 0xa90 <FUNCProgramAVR+0x12e>
     a8a:	0e 94 2c 15 	call	0x2a58	; 0x2a58 <PM_SendEraseCommand>
     a8e:	00 e0       	ldi	r16, 0x00	; 0
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	8f 15       	cp	r24, r15
     a94:	18 f4       	brcc	.+6      	; 0xa9c <FUNCProgramAVR+0x13a>
     a96:	83 e0       	ldi	r24, 0x03	; 3
     a98:	f8 16       	cp	r15, r24
     a9a:	c1 f4       	brne	.+48     	; 0xacc <FUNCProgramAVR+0x16a>
     a9c:	00 23       	and	r16, r16
     a9e:	a1 f4       	brne	.+40     	; 0xac8 <FUNCProgramAVR+0x166>
     aa0:	84 e4       	ldi	r24, 0x44	; 68
     aa2:	0e 94 0f 04 	call	0x81e	; 0x81e <MAIN_ShowProgType>
     aa6:	81 e0       	ldi	r24, 0x01	; 1
     aa8:	0e 94 85 14 	call	0x290a	; 0x290a <PM_GetStoredDataSize>
     aac:	61 15       	cp	r22, r1
     aae:	71 05       	cpc	r23, r1
     ab0:	81 05       	cpc	r24, r1
     ab2:	91 05       	cpc	r25, r1
     ab4:	31 f4       	brne	.+12     	; 0xac2 <FUNCProgramAVR+0x160>
     ab6:	8d ee       	ldi	r24, 0xED	; 237
     ab8:	92 e0       	ldi	r25, 0x02	; 2
     aba:	0e 94 92 03 	call	0x724	; 0x724 <MAIN_ShowError>
     abe:	03 e0       	ldi	r16, 0x03	; 3
     ac0:	03 c0       	rjmp	.+6      	; 0xac8 <FUNCProgramAVR+0x166>
     ac2:	81 e0       	ldi	r24, 0x01	; 1
     ac4:	0e 94 58 15 	call	0x2ab0	; 0x2ab0 <PM_CreateProgrammingPackets>
     ac8:	ff 20       	and	r15, r15
     aca:	31 f0       	breq	.+12     	; 0xad8 <FUNCProgramAVR+0x176>
     acc:	82 e0       	ldi	r24, 0x02	; 2
     ace:	f8 16       	cp	r15, r24
     ad0:	19 f0       	breq	.+6      	; 0xad8 <FUNCProgramAVR+0x176>
     ad2:	83 e0       	ldi	r24, 0x03	; 3
     ad4:	f8 16       	cp	r15, r24
     ad6:	b1 f4       	brne	.+44     	; 0xb04 <FUNCProgramAVR+0x1a2>
     ad8:	85 e4       	ldi	r24, 0x45	; 69
     ada:	0e 94 0f 04 	call	0x81e	; 0x81e <MAIN_ShowProgType>
     ade:	80 e0       	ldi	r24, 0x00	; 0
     ae0:	0e 94 85 14 	call	0x290a	; 0x290a <PM_GetStoredDataSize>
     ae4:	61 15       	cp	r22, r1
     ae6:	71 05       	cpc	r23, r1
     ae8:	81 05       	cpc	r24, r1
     aea:	91 05       	cpc	r25, r1
     aec:	31 f4       	brne	.+12     	; 0xafa <FUNCProgramAVR+0x198>
     aee:	83 ee       	ldi	r24, 0xE3	; 227
     af0:	92 e0       	ldi	r25, 0x02	; 2
     af2:	0e 94 92 03 	call	0x724	; 0x724 <MAIN_ShowError>
     af6:	03 e0       	ldi	r16, 0x03	; 3
     af8:	03 c0       	rjmp	.+6      	; 0xb00 <FUNCProgramAVR+0x19e>
     afa:	80 e0       	ldi	r24, 0x00	; 0
     afc:	0e 94 58 15 	call	0x2ab0	; 0x2ab0 <PM_CreateProgrammingPackets>
     b00:	ff 20       	and	r15, r15
     b02:	31 f0       	breq	.+12     	; 0xb10 <FUNCProgramAVR+0x1ae>
     b04:	84 e0       	ldi	r24, 0x04	; 4
     b06:	f8 16       	cp	r15, r24
     b08:	19 f0       	breq	.+6      	; 0xb10 <FUNCProgramAVR+0x1ae>
     b0a:	86 e0       	ldi	r24, 0x06	; 6
     b0c:	f8 16       	cp	r15, r24
     b0e:	a9 f4       	brne	.+42     	; 0xb3a <FUNCProgramAVR+0x1d8>
     b10:	86 e4       	ldi	r24, 0x46	; 70
     b12:	0e 94 0f 04 	call	0x81e	; 0x81e <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     b16:	a0 e3       	ldi	r26, 0x30	; 48
     b18:	b0 e0       	ldi	r27, 0x00	; 0
     b1a:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
     b1e:	80 2d       	mov	r24, r0
     b20:	88 23       	and	r24, r24
     b22:	31 f4       	brne	.+12     	; 0xb30 <FUNCProgramAVR+0x1ce>
     b24:	85 ed       	ldi	r24, 0xD5	; 213
     b26:	92 e0       	ldi	r25, 0x02	; 2
     b28:	0e 94 92 03 	call	0x724	; 0x724 <MAIN_ShowError>
     b2c:	03 e0       	ldi	r16, 0x03	; 3
     b2e:	03 c0       	rjmp	.+6      	; 0xb36 <FUNCProgramAVR+0x1d4>
     b30:	82 e0       	ldi	r24, 0x02	; 2
     b32:	0e 94 ee 14 	call	0x29dc	; 0x29dc <PM_SendFuseLockBytes>
     b36:	ff 20       	and	r15, r15
     b38:	89 f0       	breq	.+34     	; 0xb5c <FUNCProgramAVR+0x1fa>
     b3a:	85 e0       	ldi	r24, 0x05	; 5
     b3c:	f8 16       	cp	r15, r24
     b3e:	71 f0       	breq	.+28     	; 0xb5c <FUNCProgramAVR+0x1fa>
     b40:	86 e0       	ldi	r24, 0x06	; 6
     b42:	f8 16       	cp	r15, r24
     b44:	19 f5       	brne	.+70     	; 0xb8c <FUNCProgramAVR+0x22a>
     b46:	81 e0       	ldi	r24, 0x01	; 1
     b48:	0e 94 51 02 	call	0x4a2	; 0x4a2 <MAIN_ResetCSLine>
     b4c:	81 e0       	ldi	r24, 0x01	; 1
     b4e:	0e 94 3d 02 	call	0x47a	; 0x47a <MAIN_Delay10MS>
     b52:	80 e0       	ldi	r24, 0x00	; 0
     b54:	0e 94 51 02 	call	0x4a2	; 0x4a2 <MAIN_ResetCSLine>
     b58:	0e 94 23 12 	call	0x2446	; 0x2446 <ISPCC_EnterChipProgrammingMode>
     b5c:	8c e4       	ldi	r24, 0x4C	; 76
     b5e:	0e 94 0f 04 	call	0x81e	; 0x81e <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     b62:	a1 e3       	ldi	r26, 0x31	; 49
     b64:	b0 e0       	ldi	r27, 0x00	; 0
     b66:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
     b6a:	80 2d       	mov	r24, r0
     b6c:	88 23       	and	r24, r24
     b6e:	59 f4       	brne	.+22     	; 0xb86 <FUNCProgramAVR+0x224>
     b70:	87 ec       	ldi	r24, 0xC7	; 199
     b72:	92 e0       	ldi	r25, 0x02	; 2
     b74:	0e 94 92 03 	call	0x724	; 0x724 <MAIN_ShowError>
     b78:	66 eb       	ldi	r22, 0xB6	; 182
     b7a:	72 e0       	ldi	r23, 0x02	; 2
     b7c:	ce 01       	movw	r24, r28
     b7e:	01 96       	adiw	r24, 0x01	; 1
     b80:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <strcpy_P>
     b84:	0b c0       	rjmp	.+22     	; 0xb9c <FUNCProgramAVR+0x23a>
     b86:	83 e0       	ldi	r24, 0x03	; 3
     b88:	0e 94 ee 14 	call	0x29dc	; 0x29dc <PM_SendFuseLockBytes>
     b8c:	66 eb       	ldi	r22, 0xB6	; 182
     b8e:	72 e0       	ldi	r23, 0x02	; 2
     b90:	ce 01       	movw	r24, r28
     b92:	01 96       	adiw	r24, 0x01	; 1
     b94:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <strcpy_P>
     b98:	00 23       	and	r16, r16
     b9a:	31 f0       	breq	.+12     	; 0xba8 <FUNCProgramAVR+0x246>
     b9c:	6f ea       	ldi	r22, 0xAF	; 175
     b9e:	72 e0       	ldi	r23, 0x02	; 2
     ba0:	ce 01       	movw	r24, r28
     ba2:	0d 96       	adiw	r24, 0x0d	; 13
     ba4:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <strcpy_P>
     ba8:	ce 01       	movw	r24, r28
     baa:	01 96       	adiw	r24, 0x01	; 1
     bac:	0e 94 15 08 	call	0x102a	; 0x102a <LCD_puts>
     bb0:	8f ef       	ldi	r24, 0xFF	; 255
     bb2:	0e 94 3d 02 	call	0x47a	; 0x47a <MAIN_Delay10MS>
     bb6:	84 e6       	ldi	r24, 0x64	; 100
     bb8:	0e 94 3d 02 	call	0x47a	; 0x47a <MAIN_Delay10MS>
     bbc:	04 c0       	rjmp	.+8      	; 0xbc6 <FUNCProgramAVR+0x264>
     bbe:	80 e0       	ldi	r24, 0x00	; 0
     bc0:	94 e0       	ldi	r25, 0x04	; 4
     bc2:	0e 94 92 03 	call	0x724	; 0x724 <MAIN_ShowError>
     bc6:	80 e8       	ldi	r24, 0x80	; 128
     bc8:	80 93 61 00 	sts	0x0061, r24
     bcc:	83 e0       	ldi	r24, 0x03	; 3
     bce:	80 93 61 00 	sts	0x0061, r24
     bd2:	81 e0       	ldi	r24, 0x01	; 1
     bd4:	0e 94 51 02 	call	0x4a2	; 0x4a2 <MAIN_ResetCSLine>
     bd8:	0e 94 87 09 	call	0x130e	; 0x130e <USI_SPIOff>
     bdc:	80 e0       	ldi	r24, 0x00	; 0
     bde:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
     be2:	80 91 64 00 	lds	r24, 0x0064
     be6:	84 60       	ori	r24, 0x04	; 4
     be8:	80 93 64 00 	sts	0x0064, r24
     bec:	81 b3       	in	r24, 0x11	; 17
     bee:	8f 7c       	andi	r24, 0xCF	; 207
     bf0:	80 61       	ori	r24, 0x10	; 16
     bf2:	81 bb       	out	0x11, r24	; 17
     bf4:	63 96       	adiw	r28, 0x13	; 19
     bf6:	0f b6       	in	r0, 0x3f	; 63
     bf8:	f8 94       	cli
     bfa:	de bf       	out	0x3e, r29	; 62
     bfc:	0f be       	out	0x3f, r0	; 63
     bfe:	cd bf       	out	0x3d, r28	; 61
     c00:	df 91       	pop	r29
     c02:	cf 91       	pop	r28
     c04:	1f 91       	pop	r17
     c06:	0f 91       	pop	r16
     c08:	ff 90       	pop	r15
     c0a:	08 95       	ret

00000c0c <main>:
     c0c:	1f 93       	push	r17
     c0e:	80 e8       	ldi	r24, 0x80	; 128
     c10:	85 bf       	out	0x35, r24	; 53
     c12:	85 bf       	out	0x35, r24	; 53
     c14:	80 bf       	out	0x30, r24	; 48
     c16:	85 e0       	ldi	r24, 0x05	; 5
     c18:	80 93 64 00 	sts	0x0064, r24
     c1c:	80 e3       	ldi	r24, 0x30	; 48
     c1e:	80 bb       	out	0x10, r24	; 16
     c20:	87 e2       	ldi	r24, 0x27	; 39
     c22:	84 b9       	out	0x04, r24	; 4
     c24:	8f ed       	ldi	r24, 0xDF	; 223
     c26:	85 b9       	out	0x05, r24	; 5
     c28:	8c e0       	ldi	r24, 0x0C	; 12
     c2a:	8e b9       	out	0x0e, r24	; 14
     c2c:	80 93 6b 00 	sts	0x006B, r24
     c30:	80 ed       	ldi	r24, 0xD0	; 208
     c32:	80 93 6c 00 	sts	0x006C, r24
     c36:	80 ec       	ldi	r24, 0xC0	; 192
     c38:	8d bb       	out	0x1d, r24	; 29
     c3a:	8c bb       	out	0x1c, r24	; 28
     c3c:	81 b3       	in	r24, 0x11	; 17
     c3e:	8f 7c       	andi	r24, 0xCF	; 207
     c40:	80 63       	ori	r24, 0x30	; 48
     c42:	81 bb       	out	0x11, r24	; 17
     c44:	0e 94 08 08 	call	0x1010	; 0x1010 <LCD_Init>
     c48:	8f e0       	ldi	r24, 0x0F	; 15
     c4a:	80 93 e7 00 	sts	0x00E7, r24
     c4e:	87 ea       	ldi	r24, 0xA7	; 167
     c50:	90 e0       	ldi	r25, 0x00	; 0
     c52:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     c56:	78 94       	sei
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     c58:	a9 e8       	ldi	r26, 0x89	; 137
     c5a:	b0 e0       	ldi	r27, 0x00	; 0
     c5c:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
     c60:	80 2d       	mov	r24, r0
     c62:	8a 37       	cpi	r24, 0x7A	; 122
     c64:	89 f0       	breq	.+34     	; 0xc88 <main+0x7c>
     c66:	80 e0       	ldi	r24, 0x00	; 0
     c68:	90 e0       	ldi	r25, 0x00	; 0
     c6a:	2f ef       	ldi	r18, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     c6c:	dc 01       	movw	r26, r24
     c6e:	02 2e       	mov	r0, r18
     c70:	0e 94 36 1a 	call	0x346c	; 0x346c <__eeprom_write_byte_1F2021>
     c74:	01 96       	adiw	r24, 0x01	; 1
     c76:	8a 38       	cpi	r24, 0x8A	; 138
     c78:	91 05       	cpc	r25, r1
     c7a:	c1 f7       	brne	.-16     	; 0xc6c <main+0x60>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     c7c:	8a e7       	ldi	r24, 0x7A	; 122
     c7e:	a9 e8       	ldi	r26, 0x89	; 137
     c80:	b0 e0       	ldi	r27, 0x00	; 0
     c82:	08 2e       	mov	r0, r24
     c84:	0e 94 36 1a 	call	0x346c	; 0x346c <__eeprom_write_byte_1F2021>
     c88:	a6 e8       	ldi	r26, 0x86	; 134
     c8a:	b0 e0       	ldi	r27, 0x00	; 0
     c8c:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
     c90:	80 2d       	mov	r24, r0
     c92:	8f 70       	andi	r24, 0x0F	; 15
     c94:	80 93 e7 00 	sts	0x00E7, r24
     c98:	80 e0       	ldi	r24, 0x00	; 0
     c9a:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
     c9e:	0e 94 37 09 	call	0x126e	; 0x126e <USART_Init>
     ca2:	0e 94 82 07 	call	0xf04	; 0xf04 <OSCCAL_Calibrate>
     ca6:	0e 94 07 0c 	call	0x180e	; 0x180e <TOUT_SetupSleepTimer>
     caa:	81 b3       	in	r24, 0x11	; 17
     cac:	8f 7c       	andi	r24, 0xCF	; 207
     cae:	80 61       	ori	r24, 0x10	; 16
     cb0:	81 bb       	out	0x11, r24	; 17
     cb2:	81 e0       	ldi	r24, 0x01	; 1
     cb4:	8e bb       	out	0x1e, r24	; 30
     cb6:	80 e8       	ldi	r24, 0x80	; 128
     cb8:	80 93 61 00 	sts	0x0061, r24
     cbc:	83 e0       	ldi	r24, 0x03	; 3
     cbe:	80 93 61 00 	sts	0x0061, r24
     cc2:	10 e0       	ldi	r17, 0x00	; 0
     cc4:	8e b3       	in	r24, 0x1e	; 30
     cc6:	88 23       	and	r24, r24
     cc8:	e9 f3       	breq	.-6      	; 0xcc4 <main+0xb8>
     cca:	f6 9b       	sbis	0x1e, 6	; 30
     ccc:	06 c0       	rjmp	.+12     	; 0xcda <main+0xce>
     cce:	11 23       	and	r17, r17
     cd0:	11 f4       	brne	.+4      	; 0xcd6 <main+0xca>
     cd2:	16 e0       	ldi	r17, 0x06	; 6
     cd4:	1b c0       	rjmp	.+54     	; 0xd0c <main+0x100>
     cd6:	11 50       	subi	r17, 0x01	; 1
     cd8:	19 c0       	rjmp	.+50     	; 0xd0c <main+0x100>
     cda:	f7 9b       	sbis	0x1e, 7	; 30
     cdc:	06 c0       	rjmp	.+12     	; 0xcea <main+0xde>
     cde:	16 30       	cpi	r17, 0x06	; 6
     ce0:	11 f4       	brne	.+4      	; 0xce6 <main+0xda>
     ce2:	10 e0       	ldi	r17, 0x00	; 0
     ce4:	13 c0       	rjmp	.+38     	; 0xd0c <main+0x100>
     ce6:	1f 5f       	subi	r17, 0xFF	; 255
     ce8:	11 c0       	rjmp	.+34     	; 0xd0c <main+0x100>
     cea:	f4 9b       	sbis	0x1e, 4	; 30
     cec:	0b c0       	rjmp	.+22     	; 0xd04 <main+0xf8>
     cee:	e1 2f       	mov	r30, r17
     cf0:	ff 27       	eor	r31, r31
     cf2:	ee 0f       	add	r30, r30
     cf4:	ff 1f       	adc	r31, r31
     cf6:	ef 5e       	subi	r30, 0xEF	; 239
     cf8:	fe 4f       	sbci	r31, 0xFE	; 254
     cfa:	85 91       	lpm	r24, Z+
     cfc:	94 91       	lpm	r25, Z
     cfe:	fc 01       	movw	r30, r24
     d00:	09 95       	icall
     d02:	04 c0       	rjmp	.+8      	; 0xd0c <main+0x100>
     d04:	f3 9b       	sbis	0x1e, 3	; 30
     d06:	02 c0       	rjmp	.+4      	; 0xd0c <main+0x100>
     d08:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <FUNCShowAbout>
     d0c:	e1 2f       	mov	r30, r17
     d0e:	ff 27       	eor	r31, r31
     d10:	ee 0f       	add	r30, r30
     d12:	ff 1f       	adc	r31, r31
     d14:	ed 5f       	subi	r30, 0xFD	; 253
     d16:	fe 4f       	sbci	r31, 0xFE	; 254
     d18:	85 91       	lpm	r24, Z+
     d1a:	94 91       	lpm	r25, Z
     d1c:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     d20:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
     d24:	cf cf       	rjmp	.-98     	; 0xcc4 <main+0xb8>

00000d26 <FUNCClearMem>:
     d26:	88 e9       	ldi	r24, 0x98	; 152
     d28:	92 e0       	ldi	r25, 0x02	; 2
     d2a:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     d2e:	84 eb       	ldi	r24, 0xB4	; 180
     d30:	0e 94 3d 02 	call	0x47a	; 0x47a <MAIN_Delay10MS>
     d34:	82 e9       	ldi	r24, 0x92	; 146
     d36:	92 e0       	ldi	r25, 0x02	; 2
     d38:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     d3c:	8e b3       	in	r24, 0x1e	; 30
     d3e:	88 23       	and	r24, r24
     d40:	e9 f3       	breq	.-6      	; 0xd3c <FUNCClearMem+0x16>
     d42:	f2 99       	sbic	0x1e, 2	; 30
     d44:	1a c0       	rjmp	.+52     	; 0xd7a <FUNCClearMem+0x54>
     d46:	f3 9b       	sbis	0x1e, 3	; 30
     d48:	f9 cf       	rjmp	.-14     	; 0xd3c <FUNCClearMem+0x16>
     d4a:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
     d4e:	87 ea       	ldi	r24, 0xA7	; 167
     d50:	90 e0       	ldi	r25, 0x00	; 0
     d52:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     d56:	80 e0       	ldi	r24, 0x00	; 0
     d58:	90 e0       	ldi	r25, 0x00	; 0
     d5a:	2f ef       	ldi	r18, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     d5c:	dc 01       	movw	r26, r24
     d5e:	02 2e       	mov	r0, r18
     d60:	0e 94 36 1a 	call	0x346c	; 0x346c <__eeprom_write_byte_1F2021>
     d64:	01 96       	adiw	r24, 0x01	; 1
     d66:	8a 38       	cpi	r24, 0x8A	; 138
     d68:	91 05       	cpc	r25, r1
     d6a:	c1 f7       	brne	.-16     	; 0xd5c <FUNCClearMem+0x36>
     d6c:	86 e8       	ldi	r24, 0x86	; 134
     d6e:	92 e0       	ldi	r25, 0x02	; 2
     d70:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     d74:	8f ef       	ldi	r24, 0xFF	; 255
     d76:	0e 94 3d 02 	call	0x47a	; 0x47a <MAIN_Delay10MS>
     d7a:	08 95       	ret

00000d7c <FUNCSetContrast>:
     d7c:	1f 93       	push	r17
     d7e:	cf 93       	push	r28
     d80:	df 93       	push	r29
     d82:	cd b7       	in	r28, 0x3d	; 61
     d84:	de b7       	in	r29, 0x3e	; 62
     d86:	26 97       	sbiw	r28, 0x06	; 6
     d88:	0f b6       	in	r0, 0x3f	; 63
     d8a:	f8 94       	cli
     d8c:	de bf       	out	0x3e, r29	; 62
     d8e:	0f be       	out	0x3f, r0	; 63
     d90:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     d92:	a6 e8       	ldi	r26, 0x86	; 134
     d94:	b0 e0       	ldi	r27, 0x00	; 0
     d96:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
     d9a:	80 2d       	mov	r24, r0
     d9c:	18 2f       	mov	r17, r24
     d9e:	1f 70       	andi	r17, 0x0F	; 15
     da0:	81 e0       	ldi	r24, 0x01	; 1
     da2:	8e bb       	out	0x1e, r24	; 30
     da4:	8e b3       	in	r24, 0x1e	; 30
     da6:	88 23       	and	r24, r24
     da8:	e9 f3       	breq	.-6      	; 0xda4 <FUNCSetContrast+0x28>
     daa:	f6 9b       	sbis	0x1e, 6	; 30
     dac:	04 c0       	rjmp	.+8      	; 0xdb6 <FUNCSetContrast+0x3a>
     dae:	1f 30       	cpi	r17, 0x0F	; 15
     db0:	50 f4       	brcc	.+20     	; 0xdc6 <FUNCSetContrast+0x4a>
     db2:	1f 5f       	subi	r17, 0xFF	; 255
     db4:	08 c0       	rjmp	.+16     	; 0xdc6 <FUNCSetContrast+0x4a>
     db6:	f7 9b       	sbis	0x1e, 7	; 30
     db8:	04 c0       	rjmp	.+8      	; 0xdc2 <FUNCSetContrast+0x46>
     dba:	12 30       	cpi	r17, 0x02	; 2
     dbc:	20 f0       	brcs	.+8      	; 0xdc6 <FUNCSetContrast+0x4a>
     dbe:	11 50       	subi	r17, 0x01	; 1
     dc0:	02 c0       	rjmp	.+4      	; 0xdc6 <FUNCSetContrast+0x4a>
     dc2:	f2 99       	sbic	0x1e, 2	; 30
     dc4:	18 c0       	rjmp	.+48     	; 0xdf6 <FUNCSetContrast+0x7a>
     dc6:	83 e4       	ldi	r24, 0x43	; 67
     dc8:	89 83       	std	Y+1, r24	; 0x01
     dca:	84 e5       	ldi	r24, 0x54	; 84
     dcc:	8a 83       	std	Y+2, r24	; 0x02
     dce:	80 e2       	ldi	r24, 0x20	; 32
     dd0:	8b 83       	std	Y+3, r24	; 0x03
     dd2:	be 01       	movw	r22, r28
     dd4:	6c 5f       	subi	r22, 0xFC	; 252
     dd6:	7f 4f       	sbci	r23, 0xFF	; 255
     dd8:	81 2f       	mov	r24, r17
     dda:	99 27       	eor	r25, r25
     ddc:	0e 94 72 02 	call	0x4e4	; 0x4e4 <MAIN_IntToStr>
     de0:	ce 01       	movw	r24, r28
     de2:	01 96       	adiw	r24, 0x01	; 1
     de4:	0e 94 15 08 	call	0x102a	; 0x102a <LCD_puts>
     de8:	81 2f       	mov	r24, r17
     dea:	8f 70       	andi	r24, 0x0F	; 15
     dec:	80 93 e7 00 	sts	0x00E7, r24
     df0:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
     df4:	d7 cf       	rjmp	.-82     	; 0xda4 <FUNCSetContrast+0x28>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     df6:	a6 e8       	ldi	r26, 0x86	; 134
     df8:	b0 e0       	ldi	r27, 0x00	; 0
     dfa:	01 2e       	mov	r0, r17
     dfc:	0e 94 36 1a 	call	0x346c	; 0x346c <__eeprom_write_byte_1F2021>
     e00:	26 96       	adiw	r28, 0x06	; 6
     e02:	0f b6       	in	r0, 0x3f	; 63
     e04:	f8 94       	cli
     e06:	de bf       	out	0x3e, r29	; 62
     e08:	0f be       	out	0x3f, r0	; 63
     e0a:	cd bf       	out	0x3d, r28	; 61
     e0c:	df 91       	pop	r29
     e0e:	cf 91       	pop	r28
     e10:	1f 91       	pop	r17
     e12:	08 95       	ret

00000e14 <FUNCSetISPSpeed>:
     e14:	1f 93       	push	r17
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     e16:	a2 e0       	ldi	r26, 0x02	; 2
     e18:	b0 e0       	ldi	r27, 0x00	; 0
     e1a:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
     e1e:	80 2d       	mov	r24, r0
     e20:	18 2f       	mov	r17, r24
     e22:	84 30       	cpi	r24, 0x04	; 4
     e24:	08 f0       	brcs	.+2      	; 0xe28 <FUNCSetISPSpeed+0x14>
     e26:	13 e0       	ldi	r17, 0x03	; 3
     e28:	81 e0       	ldi	r24, 0x01	; 1
     e2a:	8e bb       	out	0x1e, r24	; 30
     e2c:	8e b3       	in	r24, 0x1e	; 30
     e2e:	88 23       	and	r24, r24
     e30:	e9 f3       	breq	.-6      	; 0xe2c <FUNCSetISPSpeed+0x18>
     e32:	f6 9b       	sbis	0x1e, 6	; 30
     e34:	06 c0       	rjmp	.+12     	; 0xe42 <FUNCSetISPSpeed+0x2e>
     e36:	11 23       	and	r17, r17
     e38:	11 f4       	brne	.+4      	; 0xe3e <FUNCSetISPSpeed+0x2a>
     e3a:	13 e0       	ldi	r17, 0x03	; 3
     e3c:	0c c0       	rjmp	.+24     	; 0xe56 <FUNCSetISPSpeed+0x42>
     e3e:	11 50       	subi	r17, 0x01	; 1
     e40:	0a c0       	rjmp	.+20     	; 0xe56 <FUNCSetISPSpeed+0x42>
     e42:	f7 9b       	sbis	0x1e, 7	; 30
     e44:	04 c0       	rjmp	.+8      	; 0xe4e <FUNCSetISPSpeed+0x3a>
     e46:	13 30       	cpi	r17, 0x03	; 3
     e48:	29 f0       	breq	.+10     	; 0xe54 <FUNCSetISPSpeed+0x40>
     e4a:	1f 5f       	subi	r17, 0xFF	; 255
     e4c:	04 c0       	rjmp	.+8      	; 0xe56 <FUNCSetISPSpeed+0x42>
     e4e:	f2 9b       	sbis	0x1e, 2	; 30
     e50:	02 c0       	rjmp	.+4      	; 0xe56 <FUNCSetISPSpeed+0x42>
     e52:	0c c0       	rjmp	.+24     	; 0xe6c <FUNCSetISPSpeed+0x58>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     e54:	10 e0       	ldi	r17, 0x00	; 0
     e56:	8a e0       	ldi	r24, 0x0A	; 10
     e58:	18 9f       	mul	r17, r24
     e5a:	c0 01       	movw	r24, r0
     e5c:	11 24       	eor	r1, r1
     e5e:	8a 5e       	subi	r24, 0xEA	; 234
     e60:	9d 4f       	sbci	r25, 0xFD	; 253
     e62:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
     e66:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
     e6a:	e0 cf       	rjmp	.-64     	; 0xe2c <FUNCSetISPSpeed+0x18>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     e6c:	a2 e0       	ldi	r26, 0x02	; 2
     e6e:	b0 e0       	ldi	r27, 0x00	; 0
     e70:	01 2e       	mov	r0, r17
     e72:	0e 94 36 1a 	call	0x346c	; 0x346c <__eeprom_write_byte_1F2021>
     e76:	1f 91       	pop	r17
     e78:	08 95       	ret

00000e7a <FUNCSetFirmMinorVer>:
     e7a:	1f 93       	push	r17
     e7c:	cf 93       	push	r28
     e7e:	df 93       	push	r29
     e80:	cd b7       	in	r28, 0x3d	; 61
     e82:	de b7       	in	r29, 0x3e	; 62
     e84:	25 97       	sbiw	r28, 0x05	; 5
     e86:	0f b6       	in	r0, 0x3f	; 63
     e88:	f8 94       	cli
     e8a:	de bf       	out	0x3e, r29	; 62
     e8c:	0f be       	out	0x3f, r0	; 63
     e8e:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     e90:	a7 e8       	ldi	r26, 0x87	; 135
     e92:	b0 e0       	ldi	r27, 0x00	; 0
     e94:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
     e98:	80 2d       	mov	r24, r0
     e9a:	18 2f       	mov	r17, r24
     e9c:	8a 30       	cpi	r24, 0x0A	; 10
     e9e:	08 f0       	brcs	.+2      	; 0xea2 <FUNCSetFirmMinorVer+0x28>
     ea0:	14 e0       	ldi	r17, 0x04	; 4
     ea2:	61 e8       	ldi	r22, 0x81	; 129
     ea4:	72 e0       	ldi	r23, 0x02	; 2
     ea6:	ce 01       	movw	r24, r28
     ea8:	01 96       	adiw	r24, 0x01	; 1
     eaa:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <strcpy_P>
     eae:	81 e0       	ldi	r24, 0x01	; 1
     eb0:	8e bb       	out	0x1e, r24	; 30
     eb2:	8e b3       	in	r24, 0x1e	; 30
     eb4:	88 23       	and	r24, r24
     eb6:	e9 f3       	breq	.-6      	; 0xeb2 <FUNCSetFirmMinorVer+0x38>
     eb8:	f6 9b       	sbis	0x1e, 6	; 30
     eba:	03 c0       	rjmp	.+6      	; 0xec2 <FUNCSetFirmMinorVer+0x48>
     ebc:	19 30       	cpi	r17, 0x09	; 9
     ebe:	08 f4       	brcc	.+2      	; 0xec2 <FUNCSetFirmMinorVer+0x48>
     ec0:	1f 5f       	subi	r17, 0xFF	; 255
     ec2:	f7 9b       	sbis	0x1e, 7	; 30
     ec4:	04 c0       	rjmp	.+8      	; 0xece <FUNCSetFirmMinorVer+0x54>
     ec6:	11 23       	and	r17, r17
     ec8:	21 f0       	breq	.+8      	; 0xed2 <FUNCSetFirmMinorVer+0x58>
     eca:	11 50       	subi	r17, 0x01	; 1
     ecc:	02 c0       	rjmp	.+4      	; 0xed2 <FUNCSetFirmMinorVer+0x58>
     ece:	f2 99       	sbic	0x1e, 2	; 30
     ed0:	0a c0       	rjmp	.+20     	; 0xee6 <FUNCSetFirmMinorVer+0x6c>
     ed2:	10 5d       	subi	r17, 0xD0	; 208
     ed4:	1c 83       	std	Y+4, r17	; 0x04
     ed6:	10 53       	subi	r17, 0x30	; 48
     ed8:	ce 01       	movw	r24, r28
     eda:	01 96       	adiw	r24, 0x01	; 1
     edc:	0e 94 15 08 	call	0x102a	; 0x102a <LCD_puts>
     ee0:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
     ee4:	e6 cf       	rjmp	.-52     	; 0xeb2 <FUNCSetFirmMinorVer+0x38>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     ee6:	a7 e8       	ldi	r26, 0x87	; 135
     ee8:	b0 e0       	ldi	r27, 0x00	; 0
     eea:	01 2e       	mov	r0, r17
     eec:	0e 94 36 1a 	call	0x346c	; 0x346c <__eeprom_write_byte_1F2021>
     ef0:	25 96       	adiw	r28, 0x05	; 5
     ef2:	0f b6       	in	r0, 0x3f	; 63
     ef4:	f8 94       	cli
     ef6:	de bf       	out	0x3e, r29	; 62
     ef8:	0f be       	out	0x3f, r0	; 63
     efa:	cd bf       	out	0x3d, r28	; 61
     efc:	df 91       	pop	r29
     efe:	cf 91       	pop	r28
     f00:	1f 91       	pop	r17
     f02:	08 95       	ret

00000f04 <OSCCAL_Calibrate>:

volatile uint16_t ActualCount = 0;

void OSCCAL_Calibrate(void)
{
     f04:	10 92 05 01 	sts	0x0105, r1
     f08:	10 92 04 01 	sts	0x0104, r1
	uint8_t SREG_Backup;
	uint8_t LoopCount = (0x7F / 2); // Maximum range is 128, and starts from the middle, so 64 is the max number of iterations required
	uint8_t PrevOSCALValues[2];
   
	// Reset ActualCount
	ActualCount = 0;
   
	// Make sure all clock division is turned off (8Mhz RC clock)
	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_CLOCKSPEED_8MHZ);
     f0c:	80 e8       	ldi	r24, 0x80	; 128
     f0e:	80 93 61 00 	sts	0x0061, r24
     f12:	10 92 61 00 	sts	0x0061, r1

	// Inital OSCCAL of half its maximum
	OSCCAL = (0x7F / 2);
     f16:	8f e3       	ldi	r24, 0x3F	; 63
     f18:	80 93 66 00 	sts	0x0066, r24

	// Save the SREG
	SREG_Backup = SREG;
     f1c:	5f b7       	in	r21, 0x3f	; 63
    
	// Disable all timer 1 interrupts
	TIMSK1 = 0;
     f1e:	10 92 6f 00 	sts	0x006F, r1
        
	// Set timer 2 to asyncronous mode (32.768KHz crystal)
	ASSR   = (1 << AS2);
     f22:	88 e0       	ldi	r24, 0x08	; 8
     f24:	80 93 b6 00 	sts	0x00B6, r24
        
	// Timer 2 overflow interrupt enable
	TIMSK2 = (1 << TOIE2);
     f28:	81 e0       	ldi	r24, 0x01	; 1
     f2a:	80 93 70 00 	sts	0x0070, r24

	// Enable interrupts
	sei();
     f2e:	78 94       	sei

	// Start both counters with no prescaling
	TCCR1B = (1 << CS10);
     f30:	80 93 81 00 	sts	0x0081, r24
	TCCR2A = (1 << CS20);
     f34:	80 93 b0 00 	sts	0x00B0, r24
	 	 
	// Previous OSCCAL value of 0
	PrevOSCALValues[0] = 0;

	// Wait until timer 2's external 32.768KHz crystal is stable
	while (ASSR & ((1 << TCN2UB) | (1 << TCR2UB) | (1 << OCR2UB)));
     f38:	80 91 b6 00 	lds	r24, 0x00B6
     f3c:	99 27       	eor	r25, r25
     f3e:	87 70       	andi	r24, 0x07	; 7
     f40:	90 70       	andi	r25, 0x00	; 0
     f42:	89 2b       	or	r24, r25
     f44:	c9 f7       	brne	.-14     	; 0xf38 <OSCCAL_Calibrate+0x34>
    
	// Clear the timer values
	TCNT1  = 0;
     f46:	10 92 85 00 	sts	0x0085, r1
     f4a:	10 92 84 00 	sts	0x0084, r1
	TCNT2  = 0;
     f4e:	10 92 b2 00 	sts	0x00B2, r1
     f52:	2e e3       	ldi	r18, 0x3E	; 62
     f54:	40 e0       	ldi	r20, 0x00	; 0
     f56:	ec ec       	ldi	r30, 0xCC	; 204
     f58:	f4 e6       	ldi	r31, 0x64	; 100
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     f5a:	cf 01       	movw	r24, r30
     f5c:	01 97       	sbiw	r24, 0x01	; 1
     f5e:	f1 f7       	brne	.-4      	; 0xf5c <OSCCAL_Calibrate+0x58>
    
	while (LoopCount--)
	{
		// Let it take a few readings (14ms, approx 2 readings)
		_delay_ms(14);

		PrevOSCALValues[1] = PrevOSCALValues[0];
		PrevOSCALValues[0] = OSCCAL;
     f60:	30 91 66 00 	lds	r19, 0x0066
        
		if (ActualCount > OSCCAL_TARGETCOUNT)       // Clock is running too fast
     f64:	80 91 04 01 	lds	r24, 0x0104
     f68:	90 91 05 01 	lds	r25, 0x0105
     f6c:	81 50       	subi	r24, 0x01	; 1
     f6e:	91 4e       	sbci	r25, 0xE1	; 225
     f70:	20 f0       	brcs	.+8      	; 0xf7a <OSCCAL_Calibrate+0x76>
			OSCCAL--;
     f72:	80 91 66 00 	lds	r24, 0x0066
     f76:	81 50       	subi	r24, 0x01	; 1
     f78:	0a c0       	rjmp	.+20     	; 0xf8e <OSCCAL_Calibrate+0x8a>
		else if (ActualCount < OSCCAL_TARGETCOUNT) // Clock is running too slow
     f7a:	80 91 04 01 	lds	r24, 0x0104
     f7e:	90 91 05 01 	lds	r25, 0x0105
     f82:	80 50       	subi	r24, 0x00	; 0
     f84:	91 4e       	sbci	r25, 0xE1	; 225
     f86:	28 f4       	brcc	.+10     	; 0xf92 <OSCCAL_Calibrate+0x8e>
			OSCCAL++;
     f88:	80 91 66 00 	lds	r24, 0x0066
     f8c:	8f 5f       	subi	r24, 0xFF	; 255
     f8e:	80 93 66 00 	sts	0x0066, r24
		
		// When the routine finds the closest value for the given target count,
		// it will cause the OSCCAL to hover around the closest two values.
		// If the current value is the same as two loops previous, exit the
		// routine as the best value has been found.
		if (OSCCAL == PrevOSCALValues[1])
     f92:	80 91 66 00 	lds	r24, 0x0066
     f96:	84 17       	cp	r24, r20
     f98:	29 f0       	breq	.+10     	; 0xfa4 <OSCCAL_Calibrate+0xa0>
     f9a:	21 50       	subi	r18, 0x01	; 1
     f9c:	2f 3f       	cpi	r18, 0xFF	; 255
     f9e:	11 f0       	breq	.+4      	; 0xfa4 <OSCCAL_Calibrate+0xa0>
     fa0:	43 2f       	mov	r20, r19
     fa2:	db cf       	rjmp	.-74     	; 0xf5a <OSCCAL_Calibrate+0x56>
		  break;
	}

	// Disable all timer interrupts
	TIMSK1 = 0;
     fa4:	10 92 6f 00 	sts	0x006F, r1
	TIMSK2 = 0;
     fa8:	10 92 70 00 	sts	0x0070, r1
    
	// Stop the timers
	TCCR1B = 0x00;
     fac:	10 92 81 00 	sts	0x0081, r1
	TCCR2A = 0x00;
     fb0:	10 92 b0 00 	sts	0x00B0, r1

	// Turn off timer 2 asynchronous mode
	ASSR  &= ~(1 << AS2);
     fb4:	80 91 b6 00 	lds	r24, 0x00B6
     fb8:	87 7f       	andi	r24, 0xF7	; 247
     fba:	80 93 b6 00 	sts	0x00B6, r24

	// Restore SREG
	SREG = SREG_Backup;
     fbe:	5f bf       	out	0x3f, r21	; 63
     fc0:	08 95       	ret

00000fc2 <__vector_5>:
        
	return;
}

ISR(TIMER2_OVF_vect, ISR_BLOCK) // Occurs 32768/256 timers per second, or 128Hz
{
     fc2:	1f 92       	push	r1
     fc4:	0f 92       	push	r0
     fc6:	0f b6       	in	r0, 0x3f	; 63
     fc8:	0f 92       	push	r0
     fca:	11 24       	eor	r1, r1
     fcc:	8f 93       	push	r24
     fce:	9f 93       	push	r25
     fd0:	af 93       	push	r26
     fd2:	bf 93       	push	r27
     fd4:	ef 93       	push	r30
     fd6:	ff 93       	push	r31
	// Stop timer 1 so it can be read
	TCCR1B = 0x00;
     fd8:	a1 e8       	ldi	r26, 0x81	; 129
     fda:	b0 e0       	ldi	r27, 0x00	; 0
     fdc:	1c 92       	st	X, r1
    
	// Record timer 1's value
	ActualCount = TCNT1;
     fde:	e4 e8       	ldi	r30, 0x84	; 132
     fe0:	f0 e0       	ldi	r31, 0x00	; 0
     fe2:	80 81       	ld	r24, Z
     fe4:	91 81       	ldd	r25, Z+1	; 0x01
     fe6:	90 93 05 01 	sts	0x0105, r25
     fea:	80 93 04 01 	sts	0x0104, r24
	     
	// Reset counters and restart timer 1
	TCNT1  = 0;
     fee:	11 82       	std	Z+1, r1	; 0x01
     ff0:	10 82       	st	Z, r1
	TCNT2  = 0;
     ff2:	10 92 b2 00 	sts	0x00B2, r1
	TCCR1B = (1 << CS10);
     ff6:	81 e0       	ldi	r24, 0x01	; 1
     ff8:	8c 93       	st	X, r24
     ffa:	ff 91       	pop	r31
     ffc:	ef 91       	pop	r30
     ffe:	bf 91       	pop	r27
    1000:	af 91       	pop	r26
    1002:	9f 91       	pop	r25
    1004:	8f 91       	pop	r24
    1006:	0f 90       	pop	r0
    1008:	0f be       	out	0x3f, r0	; 63
    100a:	0f 90       	pop	r0
    100c:	1f 90       	pop	r1
    100e:	18 95       	reti

00001010 <LCD_Init>:

// ======================================================================================

void LCD_Init(void)
{
    1010:	8f e0       	ldi	r24, 0x0F	; 15
    1012:	80 93 e7 00 	sts	0x00E7, r24
	// Set the initial contrast level to maximum:
	LCDCCR = 0x0F;

    // Select asynchronous clock source, enable all COM pins and enable all segment pins:
    LCDCRB  = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
    1016:	87 eb       	ldi	r24, 0xB7	; 183
    1018:	80 93 e5 00 	sts	0x00E5, r24

    // Set LCD prescaler to give a framerate of 32Hz:
    LCDFRR  = (7<<LCDCD0);    
    101c:	87 e0       	ldi	r24, 0x07	; 7
    101e:	80 93 e6 00 	sts	0x00E6, r24

	// Enable LCD and set low power waveform, enable start of frame interrupt:
    LCDCRA  = (1<<LCDEN) | (1<<LCDAB) | (1<<LCDIE);
    1022:	88 ec       	ldi	r24, 0xC8	; 200
    1024:	80 93 e4 00 	sts	0x00E4, r24
    1028:	08 95       	ret

0000102a <LCD_puts>:
}

void LCD_puts_f(const uint8_t *FlashData)
{
	uint8_t StrBuff[LCD_TEXTBUFFER_SIZE];

	strcpy_P(StrBuff, FlashData);
	LCD_puts(StrBuff);
}

void LCD_puts(const uint8_t *Data)
{
    102a:	fc 01       	movw	r30, r24
    102c:	ac e0       	ldi	r26, 0x0C	; 12
    102e:	b1 e0       	ldi	r27, 0x01	; 1
    1030:	38 2f       	mov	r19, r24
    1032:	4f ef       	ldi	r20, 0xFF	; 255
    1034:	2e 2f       	mov	r18, r30
    1036:	23 1b       	sub	r18, r19
	uint8_t LoadB;
	
	for (LoadB = 0; LoadB < 20; LoadB++)
	{
		uint8_t CByte = *(Data++);
    1038:	91 91       	ld	r25, Z+
	
		if ((CByte >= '*') && (CByte <= 'z') && (CByte != ' '))
    103a:	89 2f       	mov	r24, r25
    103c:	8a 52       	subi	r24, 0x2A	; 42
    103e:	81 35       	cpi	r24, 0x51	; 81
    1040:	10 f4       	brcc	.+4      	; 0x1046 <LCD_puts+0x1c>
		  TextBuffer[LoadB] = (CByte - '*');
    1042:	8c 93       	st	X, r24
    1044:	03 c0       	rjmp	.+6      	; 0x104c <LCD_puts+0x22>
		else if (CByte == 0x00)
    1046:	99 23       	and	r25, r25
    1048:	41 f0       	breq	.+16     	; 0x105a <LCD_puts+0x30>
		  break;
		else
		  TextBuffer[LoadB] = 0xFF;		
    104a:	4c 93       	st	X, r20
    104c:	2e 2f       	mov	r18, r30
    104e:	23 1b       	sub	r18, r19
    1050:	11 96       	adiw	r26, 0x01	; 1
    1052:	81 e0       	ldi	r24, 0x01	; 1
    1054:	a0 32       	cpi	r26, 0x20	; 32
    1056:	b8 07       	cpc	r27, r24
    1058:	69 f7       	brne	.-38     	; 0x1034 <LCD_puts+0xa>
	}

	ScrollMode  = ((LoadB > 6)? TRUE : FALSE);
    105a:	10 92 06 01 	sts	0x0106, r1
    105e:	27 30       	cpi	r18, 0x07	; 7
    1060:	18 f0       	brcs	.+6      	; 0x1068 <LCD_puts+0x3e>
    1062:	81 e0       	ldi	r24, 0x01	; 1
    1064:	80 93 06 01 	sts	0x0106, r24
	ScrollCount = 0;
    1068:	10 92 08 01 	sts	0x0108, r1
    106c:	82 2f       	mov	r24, r18
    106e:	90 e0       	ldi	r25, 0x00	; 0
    1070:	3f ef       	ldi	r19, 0xFF	; 255

	for (uint8_t Nulls = 0; Nulls < 7; Nulls++)
		TextBuffer[LoadB++] = 0xFF;
    1072:	e8 2f       	mov	r30, r24
    1074:	ff 27       	eor	r31, r31
    1076:	e4 5f       	subi	r30, 0xF4	; 244
    1078:	fe 4f       	sbci	r31, 0xFE	; 254
    107a:	30 83       	st	Z, r19
    107c:	8f 5f       	subi	r24, 0xFF	; 255
    107e:	9f 5f       	subi	r25, 0xFF	; 255
    1080:	97 30       	cpi	r25, 0x07	; 7
    1082:	b9 f7       	brne	.-18     	; 0x1072 <LCD_puts+0x48>
    1084:	82 2f       	mov	r24, r18
    1086:	89 5f       	subi	r24, 0xF9	; 249
	
	TextBuffer[LoadB] = 0x00;
    1088:	e8 2f       	mov	r30, r24
    108a:	ff 27       	eor	r31, r31
    108c:	e4 5f       	subi	r30, 0xF4	; 244
    108e:	fe 4f       	sbci	r31, 0xFE	; 254
    1090:	10 82       	st	Z, r1
	StrStart   = 0;
    1092:	10 92 0a 01 	sts	0x010A, r1
	StrEnd     = LoadB;	
    1096:	80 93 0b 01 	sts	0x010B, r24
	DelayCount = LCD_DELAYCOUNT_DEFAULT;
    109a:	8a e0       	ldi	r24, 0x0A	; 10
    109c:	80 93 07 01 	sts	0x0107, r24

	UpdateLCD  = TRUE;
    10a0:	81 e0       	ldi	r24, 0x01	; 1
    10a2:	80 93 09 01 	sts	0x0109, r24
    10a6:	08 95       	ret

000010a8 <LCD_WriteChar>:
}

void LCD_WriteChar(const uint8_t Byte, const uint8_t Digit)
{
    10a8:	8f 3f       	cpi	r24, 0xFF	; 255
    10aa:	19 f4       	brne	.+6      	; 0x10b2 <LCD_WriteChar+0xa>
	uint16_t SegData  = 0x00;
	uint8_t  *BuffPtr = (&SegBuffer[0] + (Digit >> 1));

	if (Byte != 0xFF)
    10ac:	40 e0       	ldi	r20, 0x00	; 0
    10ae:	50 e0       	ldi	r21, 0x00	; 0
    10b0:	08 c0       	rjmp	.+16     	; 0x10c2 <LCD_WriteChar+0x1a>
	  SegData = pgm_read_word(&LCD_SegTable[Byte]);	
    10b2:	e8 2f       	mov	r30, r24
    10b4:	ff 27       	eor	r31, r31
    10b6:	ee 0f       	add	r30, r30
    10b8:	ff 1f       	adc	r31, r31
    10ba:	e0 5f       	subi	r30, 0xF0	; 240
    10bc:	fc 4f       	sbci	r31, 0xFC	; 252
    10be:	45 91       	lpm	r20, Z+
    10c0:	54 91       	lpm	r21, Z
    10c2:	86 2f       	mov	r24, r22
    10c4:	86 95       	lsr	r24
    10c6:	e8 2f       	mov	r30, r24
    10c8:	ff 27       	eor	r31, r31
    10ca:	e9 5d       	subi	r30, 0xD9	; 217
    10cc:	fe 4f       	sbci	r31, 0xFE	; 254
    10ce:	30 e0       	ldi	r19, 0x00	; 0
    10d0:	77 27       	eor	r23, r23
    10d2:	61 70       	andi	r22, 0x01	; 1
    10d4:	70 70       	andi	r23, 0x00	; 0

	for (uint8_t BNib = 0; BNib < 4; BNib++)
	{
		uint8_t Mask          = 0xF0;
		uint8_t MaskedSegData = (SegData & 0x0000F);
    10d6:	24 2f       	mov	r18, r20
    10d8:	2f 70       	andi	r18, 0x0F	; 15
	
		if (Digit & 0x01)
    10da:	61 15       	cp	r22, r1
    10dc:	71 05       	cpc	r23, r1
    10de:	11 f4       	brne	.+4      	; 0x10e4 <LCD_WriteChar+0x3c>
    10e0:	90 ef       	ldi	r25, 0xF0	; 240
    10e2:	03 c0       	rjmp	.+6      	; 0x10ea <LCD_WriteChar+0x42>
		{
			Mask = 0x0F;
			MaskedSegData <<= 4;
    10e4:	22 95       	swap	r18
    10e6:	20 7f       	andi	r18, 0xF0	; 240
    10e8:	9f e0       	ldi	r25, 0x0F	; 15
		}
		
		*BuffPtr = ((*BuffPtr & Mask) | MaskedSegData);
    10ea:	80 81       	ld	r24, Z
    10ec:	98 23       	and	r25, r24
    10ee:	92 2b       	or	r25, r18
    10f0:	90 83       	st	Z, r25
    10f2:	3f 5f       	subi	r19, 0xFF	; 255
    10f4:	34 30       	cpi	r19, 0x04	; 4
    10f6:	39 f0       	breq	.+14     	; 0x1106 <LCD_WriteChar+0x5e>

		SegData >>= 4;
    10f8:	84 e0       	ldi	r24, 0x04	; 4
    10fa:	56 95       	lsr	r21
    10fc:	47 95       	ror	r20
    10fe:	8a 95       	dec	r24
    1100:	e1 f7       	brne	.-8      	; 0x10fa <LCD_WriteChar+0x52>
		BuffPtr  += 5;
    1102:	35 96       	adiw	r30, 0x05	; 5
    1104:	e8 cf       	rjmp	.-48     	; 0x10d6 <LCD_WriteChar+0x2e>
    1106:	08 95       	ret

00001108 <__vector_22>:
	}
}

ISR(LCD_vect, ISR_NOBLOCK)
{
    1108:	78 94       	sei
    110a:	1f 92       	push	r1
    110c:	0f 92       	push	r0
    110e:	0f b6       	in	r0, 0x3f	; 63
    1110:	0f 92       	push	r0
    1112:	11 24       	eor	r1, r1
    1114:	cf 92       	push	r12
    1116:	df 92       	push	r13
    1118:	ff 92       	push	r15
    111a:	0f 93       	push	r16
    111c:	1f 93       	push	r17
    111e:	2f 93       	push	r18
    1120:	3f 93       	push	r19
    1122:	4f 93       	push	r20
    1124:	5f 93       	push	r21
    1126:	6f 93       	push	r22
    1128:	7f 93       	push	r23
    112a:	8f 93       	push	r24
    112c:	9f 93       	push	r25
    112e:	af 93       	push	r26
    1130:	bf 93       	push	r27
    1132:	cf 93       	push	r28
    1134:	df 93       	push	r29
    1136:	ef 93       	push	r30
    1138:	ff 93       	push	r31
	if (ScrollMode)
    113a:	80 91 06 01 	lds	r24, 0x0106
    113e:	88 23       	and	r24, r24
    1140:	99 f0       	breq	.+38     	; 0x1168 <__vector_22+0x60>
	{
		if (DelayCount)
    1142:	80 91 07 01 	lds	r24, 0x0107
    1146:	88 23       	and	r24, r24
    1148:	21 f0       	breq	.+8      	; 0x1152 <__vector_22+0x4a>
		{
			DelayCount--;
    114a:	81 50       	subi	r24, 0x01	; 1
    114c:	80 93 07 01 	sts	0x0107, r24
    1150:	0b c0       	rjmp	.+22     	; 0x1168 <__vector_22+0x60>
		}
		else
		{
			if (!(ScrollCount--))
    1152:	80 91 08 01 	lds	r24, 0x0108
    1156:	81 50       	subi	r24, 0x01	; 1
    1158:	80 93 08 01 	sts	0x0108, r24
    115c:	8f 3f       	cpi	r24, 0xFF	; 255
    115e:	21 f4       	brne	.+8      	; 0x1168 <__vector_22+0x60>
			  UpdateLCD = TRUE;
    1160:	81 e0       	ldi	r24, 0x01	; 1
    1162:	80 93 09 01 	sts	0x0109, r24
    1166:	04 c0       	rjmp	.+8      	; 0x1170 <__vector_22+0x68>
		}
	}

	if (UpdateLCD)
    1168:	80 91 09 01 	lds	r24, 0x0109
    116c:	88 23       	and	r24, r24
    116e:	41 f1       	breq	.+80     	; 0x11c0 <__vector_22+0xb8>
	{
		for (uint8_t Character = 0; Character < 6; Character++)
		{
			uint8_t Byte = (StrStart + Character);
    1170:	10 91 0a 01 	lds	r17, 0x010A

			if (Byte >= StrEnd)
    1174:	f0 90 0b 01 	lds	r15, 0x010B
			  Byte = TextBuffer[Byte - StrEnd];
    1178:	cf 2c       	mov	r12, r15
    117a:	dd 24       	eor	r13, r13
    117c:	01 2f       	mov	r16, r17
    117e:	c0 e0       	ldi	r28, 0x00	; 0
    1180:	d0 e0       	ldi	r29, 0x00	; 0
    1182:	6c 2f       	mov	r22, r28
    1184:	e0 2f       	mov	r30, r16
    1186:	ff 27       	eor	r31, r31
    1188:	0f 15       	cp	r16, r15
    118a:	10 f0       	brcs	.+4      	; 0x1190 <__vector_22+0x88>
    118c:	ec 19       	sub	r30, r12
    118e:	fd 09       	sbc	r31, r13
			else
			  Byte = TextBuffer[Byte];
    1190:	e4 5f       	subi	r30, 0xF4	; 244
    1192:	fe 4f       	sbci	r31, 0xFE	; 254
    1194:	80 81       	ld	r24, Z
			
			LCD_WriteChar(Byte, Character);
    1196:	0e 94 54 08 	call	0x10a8	; 0x10a8 <LCD_WriteChar>
    119a:	21 96       	adiw	r28, 0x01	; 1
    119c:	0f 5f       	subi	r16, 0xFF	; 255
    119e:	c6 30       	cpi	r28, 0x06	; 6
    11a0:	d1 05       	cpc	r29, r1
    11a2:	79 f7       	brne	.-34     	; 0x1182 <__vector_22+0x7a>
		}
		
		if (StrStart++ == StrEnd)
    11a4:	1f 5f       	subi	r17, 0xFF	; 255
    11a6:	10 93 0a 01 	sts	0x010A, r17
    11aa:	11 50       	subi	r17, 0x01	; 1
    11ac:	1f 15       	cp	r17, r15
    11ae:	19 f4       	brne	.+6      	; 0x11b6 <__vector_22+0xae>
		  StrStart = 1;
    11b0:	81 e0       	ldi	r24, 0x01	; 1
    11b2:	80 93 0a 01 	sts	0x010A, r24
		
		ScrollCount = LCD_SCROLLCOUNT_DEFAULT;
    11b6:	83 e0       	ldi	r24, 0x03	; 3
    11b8:	80 93 08 01 	sts	0x0108, r24
		UpdateLCD = FALSE;
    11bc:	10 92 09 01 	sts	0x0109, r1
    11c0:	a7 e2       	ldi	r26, 0x27	; 39
    11c2:	b1 e0       	ldi	r27, 0x01	; 1
    11c4:	ec ee       	ldi	r30, 0xEC	; 236
    11c6:	f0 e0       	ldi	r31, 0x00	; 0
	}

	for (uint8_t LCDChar = 0; LCDChar < LCD_SEGBUFFER_SIZE; LCDChar++)
	  *(pLCDREG + LCDChar) = SegBuffer[LCDChar];
    11c8:	8d 91       	ld	r24, X+
    11ca:	81 93       	st	Z+, r24
    11cc:	81 e0       	ldi	r24, 0x01	; 1
    11ce:	e0 30       	cpi	r30, 0x00	; 0
    11d0:	f8 07       	cpc	r31, r24
    11d2:	d1 f7       	brne	.-12     	; 0x11c8 <__vector_22+0xc0>
    11d4:	ff 91       	pop	r31
    11d6:	ef 91       	pop	r30
    11d8:	df 91       	pop	r29
    11da:	cf 91       	pop	r28
    11dc:	bf 91       	pop	r27
    11de:	af 91       	pop	r26
    11e0:	9f 91       	pop	r25
    11e2:	8f 91       	pop	r24
    11e4:	7f 91       	pop	r23
    11e6:	6f 91       	pop	r22
    11e8:	5f 91       	pop	r21
    11ea:	4f 91       	pop	r20
    11ec:	3f 91       	pop	r19
    11ee:	2f 91       	pop	r18
    11f0:	1f 91       	pop	r17
    11f2:	0f 91       	pop	r16
    11f4:	ff 90       	pop	r15
    11f6:	df 90       	pop	r13
    11f8:	cf 90       	pop	r12
    11fa:	0f 90       	pop	r0
    11fc:	0f be       	out	0x3f, r0	; 63
    11fe:	0f 90       	pop	r0
    1200:	1f 90       	pop	r1
    1202:	18 95       	reti

00001204 <LCD_puts_f>:
    1204:	0f 93       	push	r16
    1206:	1f 93       	push	r17
    1208:	cf 93       	push	r28
    120a:	df 93       	push	r29
    120c:	cd b7       	in	r28, 0x3d	; 61
    120e:	de b7       	in	r29, 0x3e	; 62
    1210:	64 97       	sbiw	r28, 0x14	; 20
    1212:	0f b6       	in	r0, 0x3f	; 63
    1214:	f8 94       	cli
    1216:	de bf       	out	0x3e, r29	; 62
    1218:	0f be       	out	0x3f, r0	; 63
    121a:	cd bf       	out	0x3d, r28	; 61
    121c:	8e 01       	movw	r16, r28
    121e:	0f 5f       	subi	r16, 0xFF	; 255
    1220:	1f 4f       	sbci	r17, 0xFF	; 255
    1222:	bc 01       	movw	r22, r24
    1224:	c8 01       	movw	r24, r16
    1226:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <strcpy_P>
    122a:	c8 01       	movw	r24, r16
    122c:	0e 94 15 08 	call	0x102a	; 0x102a <LCD_puts>
    1230:	64 96       	adiw	r28, 0x14	; 20
    1232:	0f b6       	in	r0, 0x3f	; 63
    1234:	f8 94       	cli
    1236:	de bf       	out	0x3e, r29	; 62
    1238:	0f be       	out	0x3f, r0	; 63
    123a:	cd bf       	out	0x3d, r28	; 61
    123c:	df 91       	pop	r29
    123e:	cf 91       	pop	r28
    1240:	1f 91       	pop	r17
    1242:	0f 91       	pop	r16
    1244:	08 95       	ret

00001246 <USART_Tx>:
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_Tx(const char data)
{
    1246:	98 2f       	mov	r25, r24
    while (!(UCSRA & (1 << UDRE)));
    1248:	80 91 c0 00 	lds	r24, 0x00C0
    124c:	85 ff       	sbrs	r24, 5
    124e:	fc cf       	rjmp	.-8      	; 0x1248 <USART_Tx+0x2>
    UDR = data;
    1250:	90 93 c6 00 	sts	0x00C6, r25
    1254:	08 95       	ret

00001256 <USART_Rx>:
}

/*****************************************************************************
*
*   Function name : Usart_Rx
*
*   Returns :       char: byte received
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART
*
*****************************************************************************/
char USART_Rx(void)
{
    1256:	80 91 b7 02 	lds	r24, 0x02B7
    125a:	88 23       	and	r24, r24
    125c:	21 f4       	brne	.+8      	; 0x1266 <USART_Rx+0x10>
    while (!(BuffElements) && !(PacketTimeOut)) {};
    125e:	80 91 46 01 	lds	r24, 0x0146
    1262:	88 23       	and	r24, r24
    1264:	c1 f3       	breq	.-16     	; 0x1256 <USART_Rx>
    return BUFF_GetBuffByte();
    1266:	0e 94 81 0b 	call	0x1702	; 0x1702 <BUFF_GetBuffByte>
}
    126a:	99 27       	eor	r25, r25
    126c:	08 95       	ret

0000126e <USART_Init>:
    126e:	10 92 c5 00 	sts	0x00C5, r1
    1272:	87 e0       	ldi	r24, 0x07	; 7
    1274:	80 93 c4 00 	sts	0x00C4, r24
    1278:	82 e0       	ldi	r24, 0x02	; 2
    127a:	80 93 c0 00 	sts	0x00C0, r24
    127e:	80 e8       	ldi	r24, 0x80	; 128
    1280:	80 93 c1 00 	sts	0x00C1, r24
    1284:	86 e0       	ldi	r24, 0x06	; 6
    1286:	80 93 c2 00 	sts	0x00C2, r24
    128a:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <BUFF_InitialiseBuffer>
    128e:	08 95       	ret

00001290 <SPI_SPIInit>:

// ======================================================================================

void SPI_SPIInit(void)
{
    1290:	e4 e6       	ldi	r30, 0x64	; 100
    1292:	f0 e0       	ldi	r31, 0x00	; 0
    1294:	80 81       	ld	r24, Z
    1296:	8b 7f       	andi	r24, 0xFB	; 251
    1298:	80 83       	st	Z, r24
	PRR &= ~(1 << PRSPI);              // Enable the SPI system by clearing the power save register SPI disable bit

	// Master, Sample falling edge (setup rising), Fosc/2 speed (8Mhz/2 = 4MHz)
	SPSR = (1 << SPI2X);
    129a:	81 e0       	ldi	r24, 0x01	; 1
    129c:	8d bd       	out	0x2d, r24	; 45
	SPCR = ((1 << SPE) | (1 << MSTR) | (1 << CPHA) | (1 << CPOL));
    129e:	8c e5       	ldi	r24, 0x5C	; 92
    12a0:	8c bd       	out	0x2c, r24	; 44
    12a2:	08 95       	ret

000012a4 <SPI_SPITransmit>:
}

uint8_t SPI_SPITransmit(const uint8_t Data)
{
    12a4:	8e bd       	out	0x2e, r24	; 46
	SPDR = Data;                       // Loading a byte into the register starts the transmission
	while (!(SPSR & (1 << SPIF)));    // Wait until transmission completed
    12a6:	0d b4       	in	r0, 0x2d	; 45
    12a8:	07 fe       	sbrs	r0, 7
    12aa:	fd cf       	rjmp	.-6      	; 0x12a6 <SPI_SPITransmit+0x2>
	return SPDR;
    12ac:	8e b5       	in	r24, 0x2e	; 46
}
    12ae:	99 27       	eor	r25, r25
    12b0:	08 95       	ret

000012b2 <SPI_SPITransmitWord>:

uint8_t SPI_SPITransmitWord(const uint16_t Data)
{
    12b2:	9c 01       	movw	r18, r24
	SPI_SPITransmit((uint8_t)(Data >> 8));
    12b4:	83 2f       	mov	r24, r19
    12b6:	99 27       	eor	r25, r25
    12b8:	8e bd       	out	0x2e, r24	; 46
    12ba:	0d b4       	in	r0, 0x2d	; 45
    12bc:	07 fe       	sbrs	r0, 7
    12be:	fd cf       	rjmp	.-6      	; 0x12ba <SPI_SPITransmitWord+0x8>
    12c0:	8e b5       	in	r24, 0x2e	; 46
    12c2:	2e bd       	out	0x2e, r18	; 46
    12c4:	0d b4       	in	r0, 0x2d	; 45
    12c6:	07 fe       	sbrs	r0, 7
    12c8:	fd cf       	rjmp	.-6      	; 0x12c4 <SPI_SPITransmitWord+0x12>
    12ca:	8e b5       	in	r24, 0x2e	; 46
	return SPI_SPITransmit((uint8_t)Data);
}
    12cc:	99 27       	eor	r25, r25
    12ce:	08 95       	ret

000012d0 <__vector_17>:
 *  have to stop the timer tick.
 *  For all modes the USIDR contents are stored and flags are updated.
 */
ISR(USI_OVERFLOW_vect, ISR_BLOCK)
{
    12d0:	1f 92       	push	r1
    12d2:	0f 92       	push	r0
    12d4:	0f b6       	in	r0, 0x3f	; 63
    12d6:	0f 92       	push	r0
    12d8:	11 24       	eor	r1, r1
    12da:	8f 93       	push	r24
    12dc:	ef 93       	push	r30
    12de:	ff 93       	push	r31
	// Master must now disable the compare match interrupt
	// to prevent more USI counter clocks.
	TIMSK0 &= ~(1<<OCIE0A);
    12e0:	ee e6       	ldi	r30, 0x6E	; 110
    12e2:	f0 e0       	ldi	r31, 0x00	; 0
    12e4:	80 81       	ld	r24, Z
    12e6:	8d 7f       	andi	r24, 0xFD	; 253
    12e8:	80 83       	st	Z, r24
	
	// Update flags and clear USI counter
	USISR = (1<<USIOIF);
    12ea:	80 e4       	ldi	r24, 0x40	; 64
    12ec:	80 93 b9 00 	sts	0x00B9, r24
	TransferComplete = 1;
    12f0:	81 e0       	ldi	r24, 0x01	; 1
    12f2:	80 93 71 02 	sts	0x0271, r24

	// Copy USIDR to buffer to prevent overwrite on next transfer.
	storedUSIDR = USIDR;
    12f6:	80 91 ba 00 	lds	r24, 0x00BA
    12fa:	80 93 72 02 	sts	0x0272, r24
    12fe:	ff 91       	pop	r31
    1300:	ef 91       	pop	r30
    1302:	8f 91       	pop	r24
    1304:	0f 90       	pop	r0
    1306:	0f be       	out	0x3f, r0	; 63
    1308:	0f 90       	pop	r0
    130a:	1f 90       	pop	r1
    130c:	18 95       	reti

0000130e <USI_SPIOff>:
}



/*! \brief  Initialize USI as SPI master.
 *
 *  This function sets up all pin directions and module configurations.
 *  Use this function initially or when changing from slave to master mode.
 *  Note that the stored USIDR value is cleared.
 *
 */
void USI_SPIInitMaster(const uint8_t Freq)
{
	// Configure port directions.
 	USI_DIR_REG |= (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN);  // Outputs.
	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN);                       // Inputs.
	USI_OUT_REG |= (1<<USI_DATAIN_PIN);                        // Pull-ups.
	USI_OUT_REG &= ~(1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN); // Pull-ups.
	
	// Configure USI to 3-wire master mode with overflow interrupt.
	USICR = USI_CONTROL_REG_FLAGS;

	// Set the compare and prescaler for the requested frequency:
	USI_SPISetSpeed(Freq);
	
	// Init driver status register.
	TransferComplete = 0;
	
	storedUSIDR = 0;
}

void USI_SPIOff(void)
{
    130e:	8d b1       	in	r24, 0x0d	; 13
    1310:	8f 7a       	andi	r24, 0xAF	; 175
    1312:	8d b9       	out	0x0d, r24	; 13
	USI_DIR_REG &= ~((1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN));                        // Inputs.
	USI_OUT_REG &= ~((1<<USI_DATAIN_PIN)  | (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN)); // Pull-ups.
    1314:	8e b1       	in	r24, 0x0e	; 14
    1316:	8f 78       	andi	r24, 0x8F	; 143
    1318:	8e b9       	out	0x0e, r24	; 14
	DDRF  &= ~(1 << 6);
    131a:	86 98       	cbi	0x10, 6	; 16
	PORTF &= ~(1 << 6);
    131c:	8e 98       	cbi	0x11, 6	; 17
	
	USI_STOPUSITIMER();
    131e:	14 bc       	out	0x24, r1	; 36
    1320:	08 95       	ret

00001322 <USI_SPITransmit>:
}

/*! \brief  Put one byte on bus.
 *
 *  Use this function like you would write to the SPDR register in the native SPI module.
 *  Calling this function in master mode starts a transfer, while in slave mode, a
 *  byte will be prepared for the next transfer initiated by the master device.
 *  If a transfer is in progress, this function will set the write collision flag
 *  and return without altering the data registers.
 *
 *  \returns  Value returned by slave.
 */
uint8_t USI_SPITransmit(uint8_t val)
{
    1322:	10 92 71 02 	sts	0x0271, r1
	// Reinit flags.
	TransferComplete = 0;

	// Put data in USI data register.
	USIDR = val;
    1326:	80 93 ba 00 	sts	0x00BA, r24
	
	TIFR0  |= (1<<OCF0A);  // Clear compare match flag.
    132a:	a9 9a       	sbi	0x15, 1	; 21
	TIMSK0 |= (1<<OCIE0A); // Enable compare match interrupt.
    132c:	80 91 6e 00 	lds	r24, 0x006E
    1330:	82 60       	ori	r24, 0x02	; 2
    1332:	80 93 6e 00 	sts	0x006E, r24

	// Clear the timer 0 value
	TCNT0 = 0;
    1336:	16 bc       	out	0x26, r1	; 38

	while (!(TransferComplete));
    1338:	80 91 71 02 	lds	r24, 0x0271
    133c:	88 23       	and	r24, r24
    133e:	e1 f3       	breq	.-8      	; 0x1338 <USI_SPITransmit+0x16>

	return storedUSIDR;
    1340:	80 91 72 02 	lds	r24, 0x0272
}
    1344:	99 27       	eor	r25, r25
    1346:	08 95       	ret

00001348 <USI_SPITransmitWord>:

uint8_t USI_SPITransmitWord(const uint16_t val )
{
    1348:	0f 93       	push	r16
    134a:	1f 93       	push	r17
    134c:	8c 01       	movw	r16, r24
	USI_SPITransmit((uint8_t)(val >> 8));
    134e:	81 2f       	mov	r24, r17
    1350:	99 27       	eor	r25, r25
    1352:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
	return USI_SPITransmit((uint8_t)val);
    1356:	80 2f       	mov	r24, r16
    1358:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
}
    135c:	99 27       	eor	r25, r25
    135e:	1f 91       	pop	r17
    1360:	0f 91       	pop	r16
    1362:	08 95       	ret

00001364 <USI_SPISetSpeed>:

void USI_SPIToggleClock(void)
{
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);	
}

void USI_SPISetSpeed(const uint8_t Freq)
{
    1364:	98 2f       	mov	r25, r24
    1366:	2d e7       	ldi	r18, 0x7D	; 125
    1368:	33 e0       	ldi	r19, 0x03	; 3
    136a:	f9 01       	movw	r30, r18
    136c:	31 97       	sbiw	r30, 0x01	; 1
	for (uint8_t MatchIndex = 0; MatchIndex < USI_PRESET_SPEEDS; MatchIndex++)
	{
		if ((pgm_read_byte(&USIPSValues[MatchIndex][0]) == Freq) || (MatchIndex == (USI_PRESET_SPEEDS - 1)))
    136e:	84 91       	lpm	r24, Z
    1370:	89 17       	cp	r24, r25
    1372:	21 f0       	breq	.+8      	; 0x137c <USI_SPISetSpeed+0x18>
    1374:	83 e0       	ldi	r24, 0x03	; 3
    1376:	e2 38       	cpi	r30, 0x82	; 130
    1378:	f8 07       	cpc	r31, r24
    137a:	31 f4       	brne	.+12     	; 0x1388 <USI_SPISetSpeed+0x24>
		{
			// Init Output Compare Register.
			OCR0A = pgm_read_byte(&USIPSValues[MatchIndex][1]);
    137c:	f9 01       	movw	r30, r18
    137e:	84 91       	lpm	r24, Z
    1380:	87 bd       	out	0x27, r24	; 39

			// Enable 'Clear Timer on Compare match' and set prescaler, which starts the timer
			TCCR0A = ((1<<WGM01) | TC0_PS_1);
    1382:	89 e0       	ldi	r24, 0x09	; 9
    1384:	84 bd       	out	0x24, r24	; 36
    1386:	08 95       	ret
    1388:	32 96       	adiw	r30, 0x02	; 2
    138a:	2e 5f       	subi	r18, 0xFE	; 254
    138c:	3f 4f       	sbci	r19, 0xFF	; 255
    138e:	83 e0       	ldi	r24, 0x03	; 3
    1390:	e4 38       	cpi	r30, 0x84	; 132
    1392:	f8 07       	cpc	r31, r24
    1394:	61 f7       	brne	.-40     	; 0x136e <USI_SPISetSpeed+0xa>
    1396:	08 95       	ret

00001398 <USI_SPIInitMaster>:
    1398:	9d b1       	in	r25, 0x0d	; 13
    139a:	90 65       	ori	r25, 0x50	; 80
    139c:	9d b9       	out	0x0d, r25	; 13
    139e:	6d 98       	cbi	0x0d, 5	; 13
    13a0:	75 9a       	sbi	0x0e, 5	; 14
    13a2:	76 98       	cbi	0x0e, 6	; 14
    13a4:	9a e5       	ldi	r25, 0x5A	; 90
    13a6:	90 93 b8 00 	sts	0x00B8, r25
    13aa:	0e 94 b2 09 	call	0x1364	; 0x1364 <USI_SPISetSpeed>
    13ae:	10 92 71 02 	sts	0x0271, r1
    13b2:	10 92 72 02 	sts	0x0272, r1
    13b6:	08 95       	ret

000013b8 <USI_SPIToggleClock>:
    13b8:	0f 93       	push	r16
    13ba:	1f 93       	push	r17
    13bc:	81 e0       	ldi	r24, 0x01	; 1
    13be:	0e 94 47 02 	call	0x48e	; 0x48e <MAIN_Delay1MS>
    13c2:	08 eb       	ldi	r16, 0xB8	; 184
    13c4:	10 e0       	ldi	r17, 0x00	; 0
    13c6:	f8 01       	movw	r30, r16
    13c8:	80 81       	ld	r24, Z
    13ca:	81 60       	ori	r24, 0x01	; 1
    13cc:	80 83       	st	Z, r24
    13ce:	81 e0       	ldi	r24, 0x01	; 1
    13d0:	0e 94 47 02 	call	0x48e	; 0x48e <MAIN_Delay1MS>
    13d4:	f8 01       	movw	r30, r16
    13d6:	80 81       	ld	r24, Z
    13d8:	81 60       	ori	r24, 0x01	; 1
    13da:	80 83       	st	Z, r24
    13dc:	81 e0       	ldi	r24, 0x01	; 1
    13de:	0e 94 47 02 	call	0x48e	; 0x48e <MAIN_Delay1MS>
    13e2:	1f 91       	pop	r17
    13e4:	0f 91       	pop	r16
    13e6:	08 95       	ret

000013e8 <DF_EnableDataflash>:
	DF_WaitWhileBusy();
}

void DF_EnableDataflash(const uint8_t Enabled)
{
    13e8:	90 91 3f 01 	lds	r25, 0x013F
	if (Enabled == TRUE)
    13ec:	81 30       	cpi	r24, 0x01	; 1
    13ee:	31 f4       	brne	.+12     	; 0x13fc <DF_EnableDataflash+0x14>
	{
		if (UseExernalDF == TRUE)
    13f0:	91 30       	cpi	r25, 0x01	; 1
    13f2:	11 f4       	brne	.+4      	; 0x13f8 <DF_EnableDataflash+0x10>
		  MAIN_ResetCSLine(MAIN_RESETCS_EXTDFACTIVE);
    13f4:	82 e0       	ldi	r24, 0x02	; 2
    13f6:	05 c0       	rjmp	.+10     	; 0x1402 <DF_EnableDataflash+0x1a>
		else
		  PORTB &= ~(1 << 0);
    13f8:	28 98       	cbi	0x05, 0	; 5
    13fa:	08 95       	ret
	}
	else
	{
		if (UseExernalDF == TRUE)
    13fc:	91 30       	cpi	r25, 0x01	; 1
    13fe:	21 f4       	brne	.+8      	; 0x1408 <DF_EnableDataflash+0x20>
		  MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);
    1400:	81 e0       	ldi	r24, 0x01	; 1
    1402:	0e 94 51 02 	call	0x4a2	; 0x4a2 <MAIN_ResetCSLine>
    1406:	08 95       	ret
		else
		  PORTB |= (1 << 0);
    1408:	28 9a       	sbi	0x05, 0	; 5
    140a:	08 95       	ret

0000140c <DF_ReadBufferByte>:
    140c:	ef 92       	push	r14
    140e:	ff 92       	push	r15
    1410:	0f 93       	push	r16
    1412:	1f 93       	push	r17
    1414:	7c 01       	movw	r14, r24
    1416:	00 91 00 01 	lds	r16, 0x0100
    141a:	10 91 01 01 	lds	r17, 0x0101
    141e:	80 e0       	ldi	r24, 0x00	; 0
    1420:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    1424:	81 e0       	ldi	r24, 0x01	; 1
    1426:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    142a:	84 e5       	ldi	r24, 0x54	; 84
    142c:	f8 01       	movw	r30, r16
    142e:	09 95       	icall
    1430:	8f 2d       	mov	r24, r15
    1432:	99 27       	eor	r25, r25
    1434:	f8 01       	movw	r30, r16
    1436:	09 95       	icall
    1438:	8e 2d       	mov	r24, r14
    143a:	f8 01       	movw	r30, r16
    143c:	09 95       	icall
    143e:	80 e0       	ldi	r24, 0x00	; 0
    1440:	f8 01       	movw	r30, r16
    1442:	09 95       	icall
    1444:	80 e0       	ldi	r24, 0x00	; 0
    1446:	f8 01       	movw	r30, r16
    1448:	09 95       	icall
    144a:	99 27       	eor	r25, r25
    144c:	1f 91       	pop	r17
    144e:	0f 91       	pop	r16
    1450:	ff 90       	pop	r15
    1452:	ef 90       	pop	r14
    1454:	08 95       	ret

00001456 <DF_ContinuousReadEnable>:
    1456:	ef 92       	push	r14
    1458:	ff 92       	push	r15
    145a:	0f 93       	push	r16
    145c:	1f 93       	push	r17
    145e:	cf 93       	push	r28
    1460:	df 93       	push	r29
    1462:	8c 01       	movw	r16, r24
    1464:	7b 01       	movw	r14, r22
    1466:	c0 91 00 01 	lds	r28, 0x0100
    146a:	d0 91 01 01 	lds	r29, 0x0101
    146e:	80 e0       	ldi	r24, 0x00	; 0
    1470:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    1474:	81 e0       	ldi	r24, 0x01	; 1
    1476:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    147a:	88 e6       	ldi	r24, 0x68	; 104
    147c:	fe 01       	movw	r30, r28
    147e:	09 95       	icall
    1480:	8a b5       	in	r24, 0x2a	; 42
    1482:	98 01       	movw	r18, r16
    1484:	02 c0       	rjmp	.+4      	; 0x148a <DF_ContinuousReadEnable+0x34>
    1486:	36 95       	lsr	r19
    1488:	27 95       	ror	r18
    148a:	8a 95       	dec	r24
    148c:	e2 f7       	brpl	.-8      	; 0x1486 <DF_ContinuousReadEnable+0x30>
    148e:	c9 01       	movw	r24, r18
    1490:	fe 01       	movw	r30, r28
    1492:	09 95       	icall
    1494:	8b b5       	in	r24, 0x2b	; 43
    1496:	02 c0       	rjmp	.+4      	; 0x149c <DF_ContinuousReadEnable+0x46>
    1498:	00 0f       	add	r16, r16
    149a:	11 1f       	adc	r17, r17
    149c:	8a 95       	dec	r24
    149e:	e2 f7       	brpl	.-8      	; 0x1498 <DF_ContinuousReadEnable+0x42>
    14a0:	8f 2d       	mov	r24, r15
    14a2:	99 27       	eor	r25, r25
    14a4:	80 0f       	add	r24, r16
    14a6:	fe 01       	movw	r30, r28
    14a8:	09 95       	icall
    14aa:	8e 2d       	mov	r24, r14
    14ac:	fe 01       	movw	r30, r28
    14ae:	09 95       	icall
    14b0:	00 e0       	ldi	r16, 0x00	; 0
    14b2:	80 e0       	ldi	r24, 0x00	; 0
    14b4:	fe 01       	movw	r30, r28
    14b6:	09 95       	icall
    14b8:	0f 5f       	subi	r16, 0xFF	; 255
    14ba:	04 30       	cpi	r16, 0x04	; 4
    14bc:	d1 f7       	brne	.-12     	; 0x14b2 <DF_ContinuousReadEnable+0x5c>
    14be:	df 91       	pop	r29
    14c0:	cf 91       	pop	r28
    14c2:	1f 91       	pop	r17
    14c4:	0f 91       	pop	r16
    14c6:	ff 90       	pop	r15
    14c8:	ef 90       	pop	r14
    14ca:	08 95       	ret

000014cc <DF_BufferWriteEnable>:
    14cc:	ef 92       	push	r14
    14ce:	ff 92       	push	r15
    14d0:	0f 93       	push	r16
    14d2:	1f 93       	push	r17
    14d4:	7c 01       	movw	r14, r24
    14d6:	00 91 00 01 	lds	r16, 0x0100
    14da:	10 91 01 01 	lds	r17, 0x0101
    14de:	80 e0       	ldi	r24, 0x00	; 0
    14e0:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    14e4:	81 e0       	ldi	r24, 0x01	; 1
    14e6:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    14ea:	84 e8       	ldi	r24, 0x84	; 132
    14ec:	f8 01       	movw	r30, r16
    14ee:	09 95       	icall
    14f0:	80 e0       	ldi	r24, 0x00	; 0
    14f2:	f8 01       	movw	r30, r16
    14f4:	09 95       	icall
    14f6:	8f 2d       	mov	r24, r15
    14f8:	99 27       	eor	r25, r25
    14fa:	f8 01       	movw	r30, r16
    14fc:	09 95       	icall
    14fe:	8e 2d       	mov	r24, r14
    1500:	f8 01       	movw	r30, r16
    1502:	09 95       	icall
    1504:	1f 91       	pop	r17
    1506:	0f 91       	pop	r16
    1508:	ff 90       	pop	r15
    150a:	ef 90       	pop	r14
    150c:	08 95       	ret

0000150e <DF_WaitWhileBusy>:
    150e:	cf 93       	push	r28
    1510:	df 93       	push	r29
    1512:	c0 91 00 01 	lds	r28, 0x0100
    1516:	d0 91 01 01 	lds	r29, 0x0101
    151a:	80 e0       	ldi	r24, 0x00	; 0
    151c:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    1520:	81 e0       	ldi	r24, 0x01	; 1
    1522:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    1526:	87 e5       	ldi	r24, 0x57	; 87
    1528:	fe 01       	movw	r30, r28
    152a:	09 95       	icall
    152c:	80 e0       	ldi	r24, 0x00	; 0
    152e:	fe 01       	movw	r30, r28
    1530:	09 95       	icall
    1532:	87 ff       	sbrs	r24, 7
    1534:	fb cf       	rjmp	.-10     	; 0x152c <DF_WaitWhileBusy+0x1e>
    1536:	df 91       	pop	r29
    1538:	cf 91       	pop	r28
    153a:	08 95       	ret

0000153c <DF_EraseBlock>:
    153c:	ef 92       	push	r14
    153e:	ff 92       	push	r15
    1540:	0f 93       	push	r16
    1542:	1f 93       	push	r17
    1544:	7c 01       	movw	r14, r24
    1546:	00 91 00 01 	lds	r16, 0x0100
    154a:	10 91 01 01 	lds	r17, 0x0101
    154e:	80 e0       	ldi	r24, 0x00	; 0
    1550:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    1554:	81 e0       	ldi	r24, 0x01	; 1
    1556:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    155a:	80 e5       	ldi	r24, 0x50	; 80
    155c:	f8 01       	movw	r30, r16
    155e:	09 95       	icall
    1560:	8f 2d       	mov	r24, r15
    1562:	99 27       	eor	r25, r25
    1564:	f8 01       	movw	r30, r16
    1566:	09 95       	icall
    1568:	8e 2d       	mov	r24, r14
    156a:	f8 01       	movw	r30, r16
    156c:	09 95       	icall
    156e:	80 e0       	ldi	r24, 0x00	; 0
    1570:	f8 01       	movw	r30, r16
    1572:	09 95       	icall
    1574:	0e 94 87 0a 	call	0x150e	; 0x150e <DF_WaitWhileBusy>
    1578:	1f 91       	pop	r17
    157a:	0f 91       	pop	r16
    157c:	ff 90       	pop	r15
    157e:	ef 90       	pop	r14
    1580:	08 95       	ret

00001582 <DF_CopyFlashPageToBuffer>:
    1582:	ef 92       	push	r14
    1584:	ff 92       	push	r15
    1586:	0f 93       	push	r16
    1588:	1f 93       	push	r17
    158a:	8c 01       	movw	r16, r24
    158c:	e0 90 00 01 	lds	r14, 0x0100
    1590:	f0 90 01 01 	lds	r15, 0x0101
    1594:	80 e0       	ldi	r24, 0x00	; 0
    1596:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    159a:	81 e0       	ldi	r24, 0x01	; 1
    159c:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    15a0:	83 e5       	ldi	r24, 0x53	; 83
    15a2:	f7 01       	movw	r30, r14
    15a4:	09 95       	icall
    15a6:	8a b5       	in	r24, 0x2a	; 42
    15a8:	98 01       	movw	r18, r16
    15aa:	02 c0       	rjmp	.+4      	; 0x15b0 <DF_CopyFlashPageToBuffer+0x2e>
    15ac:	36 95       	lsr	r19
    15ae:	27 95       	ror	r18
    15b0:	8a 95       	dec	r24
    15b2:	e2 f7       	brpl	.-8      	; 0x15ac <DF_CopyFlashPageToBuffer+0x2a>
    15b4:	c9 01       	movw	r24, r18
    15b6:	f7 01       	movw	r30, r14
    15b8:	09 95       	icall
    15ba:	8b b5       	in	r24, 0x2b	; 43
    15bc:	02 c0       	rjmp	.+4      	; 0x15c2 <DF_CopyFlashPageToBuffer+0x40>
    15be:	00 0f       	add	r16, r16
    15c0:	11 1f       	adc	r17, r17
    15c2:	8a 95       	dec	r24
    15c4:	e2 f7       	brpl	.-8      	; 0x15be <DF_CopyFlashPageToBuffer+0x3c>
    15c6:	80 2f       	mov	r24, r16
    15c8:	f7 01       	movw	r30, r14
    15ca:	09 95       	icall
    15cc:	80 e0       	ldi	r24, 0x00	; 0
    15ce:	f7 01       	movw	r30, r14
    15d0:	09 95       	icall
    15d2:	0e 94 87 0a 	call	0x150e	; 0x150e <DF_WaitWhileBusy>
    15d6:	1f 91       	pop	r17
    15d8:	0f 91       	pop	r16
    15da:	ff 90       	pop	r15
    15dc:	ef 90       	pop	r14
    15de:	08 95       	ret

000015e0 <DF_CopyBufferToFlashPage>:
    15e0:	ef 92       	push	r14
    15e2:	ff 92       	push	r15
    15e4:	0f 93       	push	r16
    15e6:	1f 93       	push	r17
    15e8:	8c 01       	movw	r16, r24
    15ea:	e0 90 00 01 	lds	r14, 0x0100
    15ee:	f0 90 01 01 	lds	r15, 0x0101
    15f2:	80 e0       	ldi	r24, 0x00	; 0
    15f4:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    15f8:	81 e0       	ldi	r24, 0x01	; 1
    15fa:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    15fe:	83 e8       	ldi	r24, 0x83	; 131
    1600:	f7 01       	movw	r30, r14
    1602:	09 95       	icall
    1604:	8a b5       	in	r24, 0x2a	; 42
    1606:	98 01       	movw	r18, r16
    1608:	02 c0       	rjmp	.+4      	; 0x160e <DF_CopyBufferToFlashPage+0x2e>
    160a:	36 95       	lsr	r19
    160c:	27 95       	ror	r18
    160e:	8a 95       	dec	r24
    1610:	e2 f7       	brpl	.-8      	; 0x160a <DF_CopyBufferToFlashPage+0x2a>
    1612:	c9 01       	movw	r24, r18
    1614:	f7 01       	movw	r30, r14
    1616:	09 95       	icall
    1618:	8b b5       	in	r24, 0x2b	; 43
    161a:	02 c0       	rjmp	.+4      	; 0x1620 <DF_CopyBufferToFlashPage+0x40>
    161c:	00 0f       	add	r16, r16
    161e:	11 1f       	adc	r17, r17
    1620:	8a 95       	dec	r24
    1622:	e2 f7       	brpl	.-8      	; 0x161c <DF_CopyBufferToFlashPage+0x3c>
    1624:	80 2f       	mov	r24, r16
    1626:	f7 01       	movw	r30, r14
    1628:	09 95       	icall
    162a:	80 e0       	ldi	r24, 0x00	; 0
    162c:	f7 01       	movw	r30, r14
    162e:	09 95       	icall
    1630:	0e 94 87 0a 	call	0x150e	; 0x150e <DF_WaitWhileBusy>
    1634:	1f 91       	pop	r17
    1636:	0f 91       	pop	r16
    1638:	ff 90       	pop	r15
    163a:	ef 90       	pop	r14
    163c:	08 95       	ret

0000163e <DF_GetChipCharacteristics>:
    163e:	0f 93       	push	r16
    1640:	1f 93       	push	r17
    1642:	00 91 00 01 	lds	r16, 0x0100
    1646:	10 91 01 01 	lds	r17, 0x0101
    164a:	80 e0       	ldi	r24, 0x00	; 0
    164c:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    1650:	81 e0       	ldi	r24, 0x01	; 1
    1652:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    1656:	87 e5       	ldi	r24, 0x57	; 87
    1658:	f8 01       	movw	r30, r16
    165a:	09 95       	icall
    165c:	80 e0       	ldi	r24, 0x00	; 0
    165e:	f8 01       	movw	r30, r16
    1660:	09 95       	icall
    1662:	99 27       	eor	r25, r25
    1664:	88 73       	andi	r24, 0x38	; 56
    1666:	90 70       	andi	r25, 0x00	; 0
    1668:	63 e0       	ldi	r22, 0x03	; 3
    166a:	96 95       	lsr	r25
    166c:	87 95       	ror	r24
    166e:	6a 95       	dec	r22
    1670:	e1 f7       	brne	.-8      	; 0x166a <DF_GetChipCharacteristics+0x2c>
    1672:	ac 01       	movw	r20, r24
    1674:	4c 57       	subi	r20, 0x7C	; 124
    1676:	5c 4f       	sbci	r21, 0xFC	; 252
    1678:	fa 01       	movw	r30, r20
    167a:	44 91       	lpm	r20, Z
    167c:	40 93 40 01 	sts	0x0140, r20
    1680:	88 0f       	add	r24, r24
    1682:	99 1f       	adc	r25, r25
    1684:	fc 01       	movw	r30, r24
    1686:	e4 57       	subi	r30, 0x74	; 116
    1688:	fc 4f       	sbci	r31, 0xFC	; 252
    168a:	25 91       	lpm	r18, Z+
    168c:	34 91       	lpm	r19, Z
    168e:	30 93 42 01 	sts	0x0142, r19
    1692:	20 93 41 01 	sts	0x0141, r18
    1696:	84 56       	subi	r24, 0x64	; 100
    1698:	9c 4f       	sbci	r25, 0xFC	; 252
    169a:	fc 01       	movw	r30, r24
    169c:	25 91       	lpm	r18, Z+
    169e:	34 91       	lpm	r19, Z
    16a0:	30 93 44 01 	sts	0x0144, r19
    16a4:	20 93 43 01 	sts	0x0143, r18
    16a8:	80 e1       	ldi	r24, 0x10	; 16
    16aa:	84 1b       	sub	r24, r20
    16ac:	8a bd       	out	0x2a, r24	; 42
    16ae:	48 50       	subi	r20, 0x08	; 8
    16b0:	4b bd       	out	0x2b, r20	; 43
    16b2:	1f 91       	pop	r17
    16b4:	0f 91       	pop	r16
    16b6:	08 95       	ret

000016b8 <DF_CheckCorrectOnboardChip>:
    16b8:	0e 94 1f 0b 	call	0x163e	; 0x163e <DF_GetChipCharacteristics>
    16bc:	80 91 43 01 	lds	r24, 0x0143
    16c0:	90 91 44 01 	lds	r25, 0x0144
    16c4:	80 50       	subi	r24, 0x00	; 0
    16c6:	98 40       	sbci	r25, 0x08	; 8
    16c8:	19 f4       	brne	.+6      	; 0x16d0 <DF_CheckCorrectOnboardChip+0x18>
    16ca:	81 e0       	ldi	r24, 0x01	; 1
    16cc:	90 e0       	ldi	r25, 0x00	; 0
    16ce:	08 95       	ret
    16d0:	80 91 64 00 	lds	r24, 0x0064
    16d4:	84 60       	ori	r24, 0x04	; 4
    16d6:	80 93 64 00 	sts	0x0064, r24
    16da:	8c ea       	ldi	r24, 0xAC	; 172
    16dc:	93 e0       	ldi	r25, 0x03	; 3
    16de:	0e 94 92 03 	call	0x724	; 0x724 <MAIN_ShowError>
    16e2:	80 e0       	ldi	r24, 0x00	; 0
    16e4:	90 e0       	ldi	r25, 0x00	; 0
    16e6:	08 95       	ret

000016e8 <BUFF_InitialiseBuffer>:

// ======================================================================================

void BUFF_InitialiseBuffer(void)
{
    16e8:	83 e7       	ldi	r24, 0x73	; 115
    16ea:	92 e0       	ldi	r25, 0x02	; 2
    16ec:	90 93 b4 02 	sts	0x02B4, r25
    16f0:	80 93 b3 02 	sts	0x02B3, r24
	StoreLoc    = (BuffType*)&RingBuffer[0]; // Set up the IN pointer to the start of the buffer
	RetrieveLoc = (BuffType*)&RingBuffer[0]; // Set up the OUT pointer to the start of the buffer
    16f4:	90 93 b6 02 	sts	0x02B6, r25
    16f8:	80 93 b5 02 	sts	0x02B5, r24

	BuffElements = 0;                      // Reset the buffer elements counter
    16fc:	10 92 b7 02 	sts	0x02B7, r1
    1700:	08 95       	ret

00001702 <BUFF_GetBuffByte>:
}

BuffType BUFF_GetBuffByte(void)
{
    1702:	80 91 b7 02 	lds	r24, 0x02B7
    1706:	88 23       	and	r24, r24
    1708:	19 f4       	brne	.+6      	; 0x1710 <BUFF_GetBuffByte+0xe>
	if (!(BuffElements))                   // No elements in the buffer
    170a:	80 e0       	ldi	r24, 0x00	; 0
    170c:	90 e0       	ldi	r25, 0x00	; 0
    170e:	08 95       	ret
		return 0;

	BuffType RetrievedData = *RetrieveLoc; // Grab the stored byte into a temp variable
    1710:	e0 91 b5 02 	lds	r30, 0x02B5
    1714:	f0 91 b6 02 	lds	r31, 0x02B6
    1718:	21 91       	ld	r18, Z+

	RetrieveLoc++;                         // Increment the OUT pointer to the next element if flag set
    171a:	f0 93 b6 02 	sts	0x02B6, r31
    171e:	e0 93 b5 02 	sts	0x02B5, r30
	BuffElements--;                        // Decrement the total elements variable
    1722:	80 91 b7 02 	lds	r24, 0x02B7
    1726:	81 50       	subi	r24, 0x01	; 1
    1728:	80 93 b7 02 	sts	0x02B7, r24
	
	if (RetrieveLoc == (BuffType*)&RingBuffer[BUFF_BUFFLEN])
    172c:	e3 5b       	subi	r30, 0xB3	; 179
    172e:	f2 40       	sbci	r31, 0x02	; 2
    1730:	31 f4       	brne	.+12     	; 0x173e <BUFF_GetBuffByte+0x3c>
		RetrieveLoc = (BuffType*)&RingBuffer[0]; // Wrap pointer if end of array reached
    1732:	83 e7       	ldi	r24, 0x73	; 115
    1734:	92 e0       	ldi	r25, 0x02	; 2
    1736:	90 93 b6 02 	sts	0x02B6, r25
    173a:	80 93 b5 02 	sts	0x02B5, r24
		
	return RetrievedData;                 // Return the retrieved data
    173e:	82 2f       	mov	r24, r18
    1740:	99 27       	eor	r25, r25
}
    1742:	08 95       	ret

00001744 <__vector_13>:
    1744:	1f 92       	push	r1
    1746:	0f 92       	push	r0
    1748:	0f b6       	in	r0, 0x3f	; 63
    174a:	0f 92       	push	r0
    174c:	11 24       	eor	r1, r1
    174e:	2f 93       	push	r18
    1750:	3f 93       	push	r19
    1752:	4f 93       	push	r20
    1754:	5f 93       	push	r21
    1756:	6f 93       	push	r22
    1758:	7f 93       	push	r23
    175a:	8f 93       	push	r24
    175c:	9f 93       	push	r25
    175e:	af 93       	push	r26
    1760:	bf 93       	push	r27
    1762:	ef 93       	push	r30
    1764:	ff 93       	push	r31
    1766:	80 91 b7 02 	lds	r24, 0x02B7
    176a:	80 34       	cpi	r24, 0x40	; 64
    176c:	29 f4       	brne	.+10     	; 0x1778 <__vector_13+0x34>
    176e:	8c eb       	ldi	r24, 0xBC	; 188
    1770:	93 e0       	ldi	r25, 0x03	; 3
    1772:	0e 94 92 03 	call	0x724	; 0x724 <MAIN_ShowError>
    1776:	1f c0       	rjmp	.+62     	; 0x17b6 <__vector_13+0x72>
    1778:	e0 91 b3 02 	lds	r30, 0x02B3
    177c:	f0 91 b4 02 	lds	r31, 0x02B4
    1780:	80 91 c6 00 	lds	r24, 0x00C6
    1784:	80 83       	st	Z, r24
    1786:	20 91 b3 02 	lds	r18, 0x02B3
    178a:	30 91 b4 02 	lds	r19, 0x02B4
    178e:	2f 5f       	subi	r18, 0xFF	; 255
    1790:	3f 4f       	sbci	r19, 0xFF	; 255
    1792:	30 93 b4 02 	sts	0x02B4, r19
    1796:	20 93 b3 02 	sts	0x02B3, r18
    179a:	80 91 b7 02 	lds	r24, 0x02B7
    179e:	8f 5f       	subi	r24, 0xFF	; 255
    17a0:	80 93 b7 02 	sts	0x02B7, r24
    17a4:	23 5b       	subi	r18, 0xB3	; 179
    17a6:	32 40       	sbci	r19, 0x02	; 2
    17a8:	31 f4       	brne	.+12     	; 0x17b6 <__vector_13+0x72>
    17aa:	83 e7       	ldi	r24, 0x73	; 115
    17ac:	92 e0       	ldi	r25, 0x02	; 2
    17ae:	90 93 b4 02 	sts	0x02B4, r25
    17b2:	80 93 b3 02 	sts	0x02B3, r24
    17b6:	ff 91       	pop	r31
    17b8:	ef 91       	pop	r30
    17ba:	bf 91       	pop	r27
    17bc:	af 91       	pop	r26
    17be:	9f 91       	pop	r25
    17c0:	8f 91       	pop	r24
    17c2:	7f 91       	pop	r23
    17c4:	6f 91       	pop	r22
    17c6:	5f 91       	pop	r21
    17c8:	4f 91       	pop	r20
    17ca:	3f 91       	pop	r19
    17cc:	2f 91       	pop	r18
    17ce:	0f 90       	pop	r0
    17d0:	0f be       	out	0x3f, r0	; 63
    17d2:	0f 90       	pop	r0
    17d4:	1f 90       	pop	r1
    17d6:	18 95       	reti

000017d8 <__vector_4>:
// ======================================================================================

// Packet Timeout = ((F_CPU / 1024) / (240 * TIMEOUT_TICKSBEFORETIMEOUT)) per second
ISR(TIMER2_COMP_vect, ISR_NOBLOCK)
{
    17d8:	78 94       	sei
    17da:	1f 92       	push	r1
    17dc:	0f 92       	push	r0
    17de:	0f b6       	in	r0, 0x3f	; 63
    17e0:	0f 92       	push	r0
    17e2:	11 24       	eor	r1, r1
    17e4:	8f 93       	push	r24
	if (PacketTimeOutTicks++ == TIMEOUT_PACKET_TIMEOUTTICKS)
    17e6:	80 91 45 01 	lds	r24, 0x0145
    17ea:	8f 5f       	subi	r24, 0xFF	; 255
    17ec:	80 93 45 01 	sts	0x0145, r24
    17f0:	80 91 45 01 	lds	r24, 0x0145
    17f4:	87 39       	cpi	r24, 0x97	; 151
    17f6:	29 f4       	brne	.+10     	; 0x1802 <__vector_4+0x2a>
	{
		PacketTimeOutTicks   = 0;
    17f8:	10 92 45 01 	sts	0x0145, r1
		PacketTimeOut        = TRUE;
    17fc:	81 e0       	ldi	r24, 0x01	; 1
    17fe:	80 93 46 01 	sts	0x0146, r24
    1802:	8f 91       	pop	r24
    1804:	0f 90       	pop	r0
    1806:	0f be       	out	0x3f, r0	; 63
    1808:	0f 90       	pop	r0
    180a:	1f 90       	pop	r1
    180c:	18 95       	reti

0000180e <TOUT_SetupSleepTimer>:
	}
}

// Autosleep Timeout = (TicksBeforeAutoSleep / 10) secs between timeouts
ISR(TIMER1_OVF_vect, ISR_NOBLOCK)
{
	if (SleepTimeOutTicks++ == TicksBeforeAutoSleep)
	{
		TIMEOUT_SLEEP_TIMER_OFF();
		FUNCSleepMode();
		TOUT_SetupSleepTimer();
	}
}

// ======================================================================================

void TOUT_SetupSleepTimer(void)
{
    180e:	a8 e8       	ldi	r26, 0x88	; 136
    1810:	b0 e0       	ldi	r27, 0x00	; 0
    1812:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
    1816:	80 2d       	mov	r24, r0
	uint8_t NewTicksIndex = eeprom_read_byte(&EEPROMVars.AutoSleepValIndex);
    1818:	28 2f       	mov	r18, r24
    181a:	33 27       	eor	r19, r19
    181c:	e2 2f       	mov	r30, r18

	if (NewTicksIndex == 0xFF) // Blank EEPROM protection
    181e:	2f 3f       	cpi	r18, 0xFF	; 255
    1820:	01 f1       	breq	.+64     	; 0x1862 <TOUT_SetupSleepTimer+0x54>
	  NewTicksIndex = 4;

	TIMSK1 = (1 << TOIE1);
    1822:	81 e0       	ldi	r24, 0x01	; 1
    1824:	80 93 6f 00 	sts	0x006F, r24
	TicksBeforeAutoSleep = (pgm_read_byte(&AutoSleepTOValues[NewTicksIndex]) * 10);
    1828:	ff 27       	eor	r31, r31
    182a:	e6 53       	subi	r30, 0x36	; 54
    182c:	fc 4f       	sbci	r31, 0xFC	; 252
    182e:	e4 91       	lpm	r30, Z
    1830:	8a e0       	ldi	r24, 0x0A	; 10
    1832:	e8 9f       	mul	r30, r24
    1834:	c0 01       	movw	r24, r0
    1836:	11 24       	eor	r1, r1
    1838:	90 93 4a 01 	sts	0x014A, r25
    183c:	80 93 49 01 	sts	0x0149, r24

	TIMEOUT_SLEEP_TIMEOUT_RESET();
    1840:	10 92 48 01 	sts	0x0148, r1
    1844:	10 92 47 01 	sts	0x0147, r1
    1848:	10 92 85 00 	sts	0x0085, r1
    184c:	10 92 84 00 	sts	0x0084, r1
	
	if (NewTicksIndex)
    1850:	22 23       	and	r18, r18
    1852:	21 f0       	breq	.+8      	; 0x185c <TOUT_SetupSleepTimer+0x4e>
	  TIMEOUT_SLEEP_TIMER_ON();
    1854:	81 e0       	ldi	r24, 0x01	; 1
    1856:	80 93 81 00 	sts	0x0081, r24
    185a:	08 95       	ret
	else
	  TIMEOUT_SLEEP_TIMER_OFF();
    185c:	10 92 81 00 	sts	0x0081, r1
    1860:	08 95       	ret
    1862:	81 e0       	ldi	r24, 0x01	; 1
    1864:	80 93 6f 00 	sts	0x006F, r24
    1868:	ee ec       	ldi	r30, 0xCE	; 206
    186a:	f3 e0       	ldi	r31, 0x03	; 3
    186c:	e4 91       	lpm	r30, Z
    186e:	8a e0       	ldi	r24, 0x0A	; 10
    1870:	e8 9f       	mul	r30, r24
    1872:	c0 01       	movw	r24, r0
    1874:	11 24       	eor	r1, r1
    1876:	90 93 4a 01 	sts	0x014A, r25
    187a:	80 93 49 01 	sts	0x0149, r24
    187e:	10 92 48 01 	sts	0x0148, r1
    1882:	10 92 47 01 	sts	0x0147, r1
    1886:	10 92 85 00 	sts	0x0085, r1
    188a:	10 92 84 00 	sts	0x0084, r1
    188e:	e2 cf       	rjmp	.-60     	; 0x1854 <TOUT_SetupSleepTimer+0x46>

00001890 <__vector_9>:
    1890:	78 94       	sei
    1892:	1f 92       	push	r1
    1894:	0f 92       	push	r0
    1896:	0f b6       	in	r0, 0x3f	; 63
    1898:	0f 92       	push	r0
    189a:	11 24       	eor	r1, r1
    189c:	2f 93       	push	r18
    189e:	3f 93       	push	r19
    18a0:	4f 93       	push	r20
    18a2:	5f 93       	push	r21
    18a4:	6f 93       	push	r22
    18a6:	7f 93       	push	r23
    18a8:	8f 93       	push	r24
    18aa:	9f 93       	push	r25
    18ac:	af 93       	push	r26
    18ae:	bf 93       	push	r27
    18b0:	ef 93       	push	r30
    18b2:	ff 93       	push	r31
    18b4:	80 91 47 01 	lds	r24, 0x0147
    18b8:	90 91 48 01 	lds	r25, 0x0148
    18bc:	20 91 49 01 	lds	r18, 0x0149
    18c0:	30 91 4a 01 	lds	r19, 0x014A
    18c4:	01 96       	adiw	r24, 0x01	; 1
    18c6:	90 93 48 01 	sts	0x0148, r25
    18ca:	80 93 47 01 	sts	0x0147, r24
    18ce:	01 97       	sbiw	r24, 0x01	; 1
    18d0:	82 17       	cp	r24, r18
    18d2:	93 07       	cpc	r25, r19
    18d4:	31 f4       	brne	.+12     	; 0x18e2 <__vector_9+0x52>
    18d6:	10 92 81 00 	sts	0x0081, r1
    18da:	0e 94 b0 02 	call	0x560	; 0x560 <FUNCSleepMode>
    18de:	0e 94 07 0c 	call	0x180e	; 0x180e <TOUT_SetupSleepTimer>
    18e2:	ff 91       	pop	r31
    18e4:	ef 91       	pop	r30
    18e6:	bf 91       	pop	r27
    18e8:	af 91       	pop	r26
    18ea:	9f 91       	pop	r25
    18ec:	8f 91       	pop	r24
    18ee:	7f 91       	pop	r23
    18f0:	6f 91       	pop	r22
    18f2:	5f 91       	pop	r21
    18f4:	4f 91       	pop	r20
    18f6:	3f 91       	pop	r19
    18f8:	2f 91       	pop	r18
    18fa:	0f 90       	pop	r0
    18fc:	0f be       	out	0x3f, r0	; 63
    18fe:	0f 90       	pop	r0
    1900:	1f 90       	pop	r1
    1902:	18 95       	reti

00001904 <PD_SetupDFAddressCounters>:
	}
}

void PD_SetupDFAddressCounters(void)
{
    1904:	ef 92       	push	r14
    1906:	ff 92       	push	r15
    1908:	0f 93       	push	r16
    190a:	1f 93       	push	r17
	uint32_t StartAddress = CurrAddress;
    190c:	20 91 63 02 	lds	r18, 0x0263
    1910:	30 91 64 02 	lds	r19, 0x0264
    1914:	40 91 65 02 	lds	r20, 0x0265
    1918:	50 91 66 02 	lds	r21, 0x0266

	CurrPageAddress = 0;
    191c:	10 92 3c 01 	sts	0x013C, r1
    1920:	10 92 3b 01 	sts	0x013B, r1

	while (StartAddress > DataflashInfo.PageSize)      // This loop is the equivalent of a DIV and a MOD
    1924:	80 91 41 01 	lds	r24, 0x0141
    1928:	90 91 42 01 	lds	r25, 0x0142
    192c:	aa 27       	eor	r26, r26
    192e:	bb 27       	eor	r27, r27
    1930:	60 e0       	ldi	r22, 0x00	; 0
    1932:	70 e0       	ldi	r23, 0x00	; 0
    1934:	ee 24       	eor	r14, r14
    1936:	ff 24       	eor	r15, r15
    1938:	87 01       	movw	r16, r14
    193a:	e8 1a       	sub	r14, r24
    193c:	f9 0a       	sbc	r15, r25
    193e:	0a 0b       	sbc	r16, r26
    1940:	1b 0b       	sbc	r17, r27
    1942:	06 c0       	rjmp	.+12     	; 0x1950 <PD_SetupDFAddressCounters+0x4c>
    1944:	2e 0d       	add	r18, r14
    1946:	3f 1d       	adc	r19, r15
    1948:	40 1f       	adc	r20, r16
    194a:	51 1f       	adc	r21, r17
    194c:	6f 5f       	subi	r22, 0xFF	; 255
    194e:	7f 4f       	sbci	r23, 0xFF	; 255
    1950:	82 17       	cp	r24, r18
    1952:	93 07       	cpc	r25, r19
    1954:	a4 07       	cpc	r26, r20
    1956:	b5 07       	cpc	r27, r21
    1958:	a8 f3       	brcs	.-22     	; 0x1944 <PD_SetupDFAddressCounters+0x40>
    195a:	70 93 3c 01 	sts	0x013C, r23
    195e:	60 93 3b 01 	sts	0x013B, r22
	{
		StartAddress -= DataflashInfo.PageSize;         // Subtract one page's worth of bytes from the desired address
		CurrPageAddress++;
	}
	
	CurrBuffByte = (uint16_t)StartAddress;              // The buffer byte is the remainder
    1962:	30 93 3e 01 	sts	0x013E, r19
    1966:	20 93 3d 01 	sts	0x013D, r18
    196a:	1f 91       	pop	r17
    196c:	0f 91       	pop	r16
    196e:	ff 90       	pop	r15
    1970:	ef 90       	pop	r14
    1972:	08 95       	ret

00001974 <PD_StoreDataflashByte>:
}

void PD_StoreDataflashByte(const uint8_t Data)
{
    1974:	1f 93       	push	r17
    1976:	18 2f       	mov	r17, r24
	if (CurrBuffByte == DataflashInfo.PageSize)
    1978:	20 91 3d 01 	lds	r18, 0x013D
    197c:	30 91 3e 01 	lds	r19, 0x013E
    1980:	80 91 41 01 	lds	r24, 0x0141
    1984:	90 91 42 01 	lds	r25, 0x0142
    1988:	28 17       	cp	r18, r24
    198a:	39 07       	cpc	r19, r25
    198c:	a1 f4       	brne	.+40     	; 0x19b6 <PD_StoreDataflashByte+0x42>
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
    198e:	80 91 3b 01 	lds	r24, 0x013B
    1992:	90 91 3c 01 	lds	r25, 0x013C
    1996:	01 96       	adiw	r24, 0x01	; 1
    1998:	90 93 3c 01 	sts	0x013C, r25
    199c:	80 93 3b 01 	sts	0x013B, r24
    19a0:	01 97       	sbiw	r24, 0x01	; 1
    19a2:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    19a6:	80 e0       	ldi	r24, 0x00	; 0
    19a8:	90 e0       	ldi	r25, 0x00	; 0
    19aa:	0e 94 66 0a 	call	0x14cc	; 0x14cc <DF_BufferWriteEnable>
		CurrBuffByte = 0;
    19ae:	10 92 3e 01 	sts	0x013E, r1
    19b2:	10 92 3d 01 	sts	0x013D, r1
	}
	
	USI_SPITransmit(Data);                                 // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    19b6:	81 2f       	mov	r24, r17
    19b8:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
	CurrBuffByte++;
    19bc:	80 91 3d 01 	lds	r24, 0x013D
    19c0:	90 91 3e 01 	lds	r25, 0x013E
    19c4:	01 96       	adiw	r24, 0x01	; 1
    19c6:	90 93 3e 01 	sts	0x013E, r25
    19ca:	80 93 3d 01 	sts	0x013D, r24
    19ce:	1f 91       	pop	r17
    19d0:	08 95       	ret

000019d2 <PD_InterpretAVRISPPacket>:
    19d2:	0f 93       	push	r16
    19d4:	1f 93       	push	r17
    19d6:	cf 93       	push	r28
    19d8:	df 93       	push	r29
    19da:	80 91 4b 01 	lds	r24, 0x014B
    19de:	86 31       	cpi	r24, 0x16	; 22
    19e0:	09 f4       	brne	.+2      	; 0x19e4 <PD_InterpretAVRISPPacket+0x12>
    19e2:	ef c0       	rjmp	.+478    	; 0x1bc2 <PD_InterpretAVRISPPacket+0x1f0>
    19e4:	87 31       	cpi	r24, 0x17	; 23
    19e6:	90 f4       	brcc	.+36     	; 0x1a0c <PD_InterpretAVRISPPacket+0x3a>
    19e8:	82 31       	cpi	r24, 0x12	; 18
    19ea:	09 f4       	brne	.+2      	; 0x19ee <PD_InterpretAVRISPPacket+0x1c>
    19ec:	63 c0       	rjmp	.+198    	; 0x1ab4 <PD_InterpretAVRISPPacket+0xe2>
    19ee:	83 31       	cpi	r24, 0x13	; 19
    19f0:	30 f4       	brcc	.+12     	; 0x19fe <PD_InterpretAVRISPPacket+0x2c>
    19f2:	80 31       	cpi	r24, 0x10	; 16
    19f4:	01 f1       	breq	.+64     	; 0x1a36 <PD_InterpretAVRISPPacket+0x64>
    19f6:	81 31       	cpi	r24, 0x11	; 17
    19f8:	09 f0       	breq	.+2      	; 0x19fc <PD_InterpretAVRISPPacket+0x2a>
    19fa:	2d c1       	rjmp	.+602    	; 0x1c56 <PD_InterpretAVRISPPacket+0x284>
    19fc:	3f c0       	rjmp	.+126    	; 0x1a7c <PD_InterpretAVRISPPacket+0xaa>
    19fe:	84 31       	cpi	r24, 0x14	; 20
    1a00:	09 f4       	brne	.+2      	; 0x1a04 <PD_InterpretAVRISPPacket+0x32>
    1a02:	89 c0       	rjmp	.+274    	; 0x1b16 <PD_InterpretAVRISPPacket+0x144>
    1a04:	85 31       	cpi	r24, 0x15	; 21
    1a06:	08 f0       	brcs	.+2      	; 0x1a0a <PD_InterpretAVRISPPacket+0x38>
    1a08:	a9 c0       	rjmp	.+338    	; 0x1b5c <PD_InterpretAVRISPPacket+0x18a>
    1a0a:	7e c0       	rjmp	.+252    	; 0x1b08 <PD_InterpretAVRISPPacket+0x136>
    1a0c:	89 31       	cpi	r24, 0x19	; 25
    1a0e:	09 f4       	brne	.+2      	; 0x1a12 <PD_InterpretAVRISPPacket+0x40>
    1a10:	70 c0       	rjmp	.+224    	; 0x1af2 <PD_InterpretAVRISPPacket+0x120>
    1a12:	8a 31       	cpi	r24, 0x1A	; 26
    1a14:	38 f4       	brcc	.+14     	; 0x1a24 <PD_InterpretAVRISPPacket+0x52>
    1a16:	87 31       	cpi	r24, 0x17	; 23
    1a18:	09 f4       	brne	.+2      	; 0x1a1c <PD_InterpretAVRISPPacket+0x4a>
    1a1a:	6b c0       	rjmp	.+214    	; 0x1af2 <PD_InterpretAVRISPPacket+0x120>
    1a1c:	88 31       	cpi	r24, 0x18	; 24
    1a1e:	09 f0       	breq	.+2      	; 0x1a22 <PD_InterpretAVRISPPacket+0x50>
    1a20:	1a c1       	rjmp	.+564    	; 0x1c56 <PD_InterpretAVRISPPacket+0x284>
    1a22:	59 c0       	rjmp	.+178    	; 0x1ad6 <PD_InterpretAVRISPPacket+0x104>
    1a24:	8b 31       	cpi	r24, 0x1B	; 27
    1a26:	e1 f1       	breq	.+120    	; 0x1aa0 <PD_InterpretAVRISPPacket+0xce>
    1a28:	8b 31       	cpi	r24, 0x1B	; 27
    1a2a:	08 f4       	brcc	.+2      	; 0x1a2e <PD_InterpretAVRISPPacket+0x5c>
    1a2c:	54 c0       	rjmp	.+168    	; 0x1ad6 <PD_InterpretAVRISPPacket+0x104>
    1a2e:	8c 31       	cpi	r24, 0x1C	; 28
    1a30:	09 f0       	breq	.+2      	; 0x1a34 <PD_InterpretAVRISPPacket+0x62>
    1a32:	11 c1       	rjmp	.+546    	; 0x1c56 <PD_InterpretAVRISPPacket+0x284>
    1a34:	50 c0       	rjmp	.+160    	; 0x1ad6 <PD_InterpretAVRISPPacket+0x104>
    1a36:	82 e0       	ldi	r24, 0x02	; 2
    1a38:	90 e0       	ldi	r25, 0x00	; 0
    1a3a:	90 93 61 02 	sts	0x0261, r25
    1a3e:	80 93 60 02 	sts	0x0260, r24
    1a42:	81 e0       	ldi	r24, 0x01	; 1
    1a44:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    1a48:	0e 94 1f 0b 	call	0x163e	; 0x163e <DF_GetChipCharacteristics>
    1a4c:	80 91 40 01 	lds	r24, 0x0140
    1a50:	88 23       	and	r24, r24
    1a52:	59 f0       	breq	.+22     	; 0x1a6a <PD_InterpretAVRISPPacket+0x98>
    1a54:	8f ec       	ldi	r24, 0xCF	; 207
    1a56:	93 e0       	ldi	r25, 0x03	; 3
    1a58:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
    1a5c:	81 e0       	ldi	r24, 0x01	; 1
    1a5e:	80 93 62 02 	sts	0x0262, r24
    1a62:	81 b3       	in	r24, 0x11	; 17
    1a64:	8f 7c       	andi	r24, 0xCF	; 207
    1a66:	80 62       	ori	r24, 0x20	; 32
    1a68:	17 c0       	rjmp	.+46     	; 0x1a98 <PD_InterpretAVRISPPacket+0xc6>
    1a6a:	8c ea       	ldi	r24, 0xAC	; 172
    1a6c:	93 e0       	ldi	r25, 0x03	; 3
    1a6e:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
    1a72:	80 e0       	ldi	r24, 0x00	; 0
    1a74:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    1a78:	80 ec       	ldi	r24, 0xC0	; 192
    1a7a:	f4 c0       	rjmp	.+488    	; 0x1c64 <PD_InterpretAVRISPPacket+0x292>
    1a7c:	82 e0       	ldi	r24, 0x02	; 2
    1a7e:	90 e0       	ldi	r25, 0x00	; 0
    1a80:	90 93 61 02 	sts	0x0261, r25
    1a84:	80 93 60 02 	sts	0x0260, r24
    1a88:	10 92 62 02 	sts	0x0262, r1
    1a8c:	80 e0       	ldi	r24, 0x00	; 0
    1a8e:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    1a92:	81 b3       	in	r24, 0x11	; 17
    1a94:	8f 7c       	andi	r24, 0xCF	; 207
    1a96:	80 61       	ori	r24, 0x10	; 16
    1a98:	81 bb       	out	0x11, r24	; 17
    1a9a:	10 92 4c 01 	sts	0x014C, r1
    1a9e:	e4 c0       	rjmp	.+456    	; 0x1c68 <PD_InterpretAVRISPPacket+0x296>
    1aa0:	84 e0       	ldi	r24, 0x04	; 4
    1aa2:	90 e0       	ldi	r25, 0x00	; 0
    1aa4:	90 93 61 02 	sts	0x0261, r25
    1aa8:	80 93 60 02 	sts	0x0260, r24
    1aac:	10 92 4c 01 	sts	0x014C, r1
    1ab0:	82 e0       	ldi	r24, 0x02	; 2
    1ab2:	1a c0       	rjmp	.+52     	; 0x1ae8 <PD_InterpretAVRISPPacket+0x116>
    1ab4:	82 e0       	ldi	r24, 0x02	; 2
    1ab6:	90 e0       	ldi	r25, 0x00	; 0
    1ab8:	90 93 61 02 	sts	0x0261, r25
    1abc:	80 93 60 02 	sts	0x0260, r24
    1ac0:	10 92 4c 01 	sts	0x014C, r1
    1ac4:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <V2P_SendPacket>
    1ac8:	87 ea       	ldi	r24, 0xA7	; 167
    1aca:	90 e0       	ldi	r25, 0x00	; 0
    1acc:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
    1ad0:	c0 e0       	ldi	r28, 0x00	; 0
    1ad2:	d0 e0       	ldi	r29, 0x00	; 0
    1ad4:	d0 c0       	rjmp	.+416    	; 0x1c76 <PD_InterpretAVRISPPacket+0x2a4>
    1ad6:	84 e0       	ldi	r24, 0x04	; 4
    1ad8:	90 e0       	ldi	r25, 0x00	; 0
    1ada:	90 93 61 02 	sts	0x0261, r25
    1ade:	80 93 60 02 	sts	0x0260, r24
    1ae2:	10 92 4c 01 	sts	0x014C, r1
    1ae6:	8f ef       	ldi	r24, 0xFF	; 255
    1ae8:	80 93 4d 01 	sts	0x014D, r24
    1aec:	10 92 4e 01 	sts	0x014E, r1
    1af0:	bb c0       	rjmp	.+374    	; 0x1c68 <PD_InterpretAVRISPPacket+0x296>
    1af2:	83 e0       	ldi	r24, 0x03	; 3
    1af4:	90 e0       	ldi	r25, 0x00	; 0
    1af6:	90 93 61 02 	sts	0x0261, r25
    1afa:	80 93 60 02 	sts	0x0260, r24
    1afe:	10 92 4c 01 	sts	0x014C, r1
    1b02:	10 92 4d 01 	sts	0x014D, r1
    1b06:	b0 c0       	rjmp	.+352    	; 0x1c68 <PD_InterpretAVRISPPacket+0x296>
    1b08:	82 e0       	ldi	r24, 0x02	; 2
    1b0a:	90 e0       	ldi	r25, 0x00	; 0
    1b0c:	90 93 61 02 	sts	0x0261, r25
    1b10:	80 93 60 02 	sts	0x0260, r24
    1b14:	c2 cf       	rjmp	.-124    	; 0x1a9a <PD_InterpretAVRISPPacket+0xc8>
    1b16:	20 91 4c 01 	lds	r18, 0x014C
    1b1a:	33 27       	eor	r19, r19
    1b1c:	32 2f       	mov	r19, r18
    1b1e:	22 27       	eor	r18, r18
    1b20:	80 91 4d 01 	lds	r24, 0x014D
    1b24:	99 27       	eor	r25, r25
    1b26:	28 2b       	or	r18, r24
    1b28:	39 2b       	or	r19, r25
    1b2a:	f9 01       	movw	r30, r18
    1b2c:	33 96       	adiw	r30, 0x03	; 3
    1b2e:	f0 93 61 02 	sts	0x0261, r31
    1b32:	e0 93 60 02 	sts	0x0260, r30
    1b36:	81 e0       	ldi	r24, 0x01	; 1
    1b38:	90 e0       	ldi	r25, 0x00	; 0
    1b3a:	ac e4       	ldi	r26, 0x4C	; 76
    1b3c:	b1 e0       	ldi	r27, 0x01	; 1
    1b3e:	2f 5f       	subi	r18, 0xFF	; 255
    1b40:	3f 4f       	sbci	r19, 0xFF	; 255
    1b42:	4f ef       	ldi	r20, 0xFF	; 255
    1b44:	02 c0       	rjmp	.+4      	; 0x1b4a <PD_InterpretAVRISPPacket+0x178>
    1b46:	4d 93       	st	X+, r20
    1b48:	01 96       	adiw	r24, 0x01	; 1
    1b4a:	82 17       	cp	r24, r18
    1b4c:	93 07       	cpc	r25, r19
    1b4e:	d8 f3       	brcs	.-10     	; 0x1b46 <PD_InterpretAVRISPPacket+0x174>
    1b50:	10 92 4c 01 	sts	0x014C, r1
    1b54:	e6 5b       	subi	r30, 0xB6	; 182
    1b56:	fe 4f       	sbci	r31, 0xFE	; 254
    1b58:	10 82       	st	Z, r1
    1b5a:	86 c0       	rjmp	.+268    	; 0x1c68 <PD_InterpretAVRISPPacket+0x296>
    1b5c:	0e 94 82 0c 	call	0x1904	; 0x1904 <PD_SetupDFAddressCounters>
    1b60:	80 91 3b 01 	lds	r24, 0x013B
    1b64:	90 91 3c 01 	lds	r25, 0x013C
    1b68:	0e 94 c1 0a 	call	0x1582	; 0x1582 <DF_CopyFlashPageToBuffer>
    1b6c:	80 91 3d 01 	lds	r24, 0x013D
    1b70:	90 91 3e 01 	lds	r25, 0x013E
    1b74:	0e 94 66 0a 	call	0x14cc	; 0x14cc <DF_BufferWriteEnable>
    1b78:	80 91 4c 01 	lds	r24, 0x014C
    1b7c:	99 27       	eor	r25, r25
    1b7e:	d8 2f       	mov	r29, r24
    1b80:	cc 27       	eor	r28, r28
    1b82:	80 91 4d 01 	lds	r24, 0x014D
    1b86:	99 27       	eor	r25, r25
    1b88:	c8 2b       	or	r28, r24
    1b8a:	d9 2b       	or	r29, r25
    1b8c:	0b e4       	ldi	r16, 0x4B	; 75
    1b8e:	11 e0       	ldi	r17, 0x01	; 1
    1b90:	11 c0       	rjmp	.+34     	; 0x1bb4 <PD_InterpretAVRISPPacket+0x1e2>
    1b92:	f8 01       	movw	r30, r16
    1b94:	82 85       	ldd	r24, Z+10	; 0x0a
    1b96:	0e 94 ba 0c 	call	0x1974	; 0x1974 <PD_StoreDataflashByte>
    1b9a:	80 91 3d 01 	lds	r24, 0x013D
    1b9e:	90 91 3e 01 	lds	r25, 0x013E
    1ba2:	01 96       	adiw	r24, 0x01	; 1
    1ba4:	90 93 3e 01 	sts	0x013E, r25
    1ba8:	80 93 3d 01 	sts	0x013D, r24
    1bac:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <V2P_IncrementCurrAddress>
    1bb0:	0f 5f       	subi	r16, 0xFF	; 255
    1bb2:	1f 4f       	sbci	r17, 0xFF	; 255
    1bb4:	ce 01       	movw	r24, r28
    1bb6:	85 5b       	subi	r24, 0xB5	; 181
    1bb8:	9e 4f       	sbci	r25, 0xFE	; 254
    1bba:	08 17       	cp	r16, r24
    1bbc:	19 07       	cpc	r17, r25
    1bbe:	49 f7       	brne	.-46     	; 0x1b92 <PD_InterpretAVRISPPacket+0x1c0>
    1bc0:	6c cf       	rjmp	.-296    	; 0x1a9a <PD_InterpretAVRISPPacket+0xc8>
    1bc2:	0e 94 82 0c 	call	0x1904	; 0x1904 <PD_SetupDFAddressCounters>
    1bc6:	80 91 3b 01 	lds	r24, 0x013B
    1bca:	90 91 3c 01 	lds	r25, 0x013C
    1bce:	0e 94 c1 0a 	call	0x1582	; 0x1582 <DF_CopyFlashPageToBuffer>
    1bd2:	80 91 4c 01 	lds	r24, 0x014C
    1bd6:	99 27       	eor	r25, r25
    1bd8:	d8 2f       	mov	r29, r24
    1bda:	cc 27       	eor	r28, r28
    1bdc:	80 91 4d 01 	lds	r24, 0x014D
    1be0:	99 27       	eor	r25, r25
    1be2:	c8 2b       	or	r28, r24
    1be4:	d9 2b       	or	r29, r25
    1be6:	0b e4       	ldi	r16, 0x4B	; 75
    1be8:	11 e0       	ldi	r17, 0x01	; 1
    1bea:	25 c0       	rjmp	.+74     	; 0x1c36 <PD_InterpretAVRISPPacket+0x264>
    1bec:	20 91 3d 01 	lds	r18, 0x013D
    1bf0:	30 91 3e 01 	lds	r19, 0x013E
    1bf4:	80 91 41 01 	lds	r24, 0x0141
    1bf8:	90 91 42 01 	lds	r25, 0x0142
    1bfc:	28 17       	cp	r18, r24
    1bfe:	39 07       	cpc	r19, r25
    1c00:	41 f4       	brne	.+16     	; 0x1c12 <PD_InterpretAVRISPPacket+0x240>
    1c02:	0e 94 82 0c 	call	0x1904	; 0x1904 <PD_SetupDFAddressCounters>
    1c06:	80 91 3b 01 	lds	r24, 0x013B
    1c0a:	90 91 3c 01 	lds	r25, 0x013C
    1c0e:	0e 94 c1 0a 	call	0x1582	; 0x1582 <DF_CopyFlashPageToBuffer>
    1c12:	80 91 3d 01 	lds	r24, 0x013D
    1c16:	90 91 3e 01 	lds	r25, 0x013E
    1c1a:	01 96       	adiw	r24, 0x01	; 1
    1c1c:	90 93 3e 01 	sts	0x013E, r25
    1c20:	80 93 3d 01 	sts	0x013D, r24
    1c24:	01 97       	sbiw	r24, 0x01	; 1
    1c26:	0e 94 06 0a 	call	0x140c	; 0x140c <DF_ReadBufferByte>
    1c2a:	f8 01       	movw	r30, r16
    1c2c:	82 83       	std	Z+2, r24	; 0x02
    1c2e:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <V2P_IncrementCurrAddress>
    1c32:	0f 5f       	subi	r16, 0xFF	; 255
    1c34:	1f 4f       	sbci	r17, 0xFF	; 255
    1c36:	ce 01       	movw	r24, r28
    1c38:	85 5b       	subi	r24, 0xB5	; 181
    1c3a:	9e 4f       	sbci	r25, 0xFE	; 254
    1c3c:	08 17       	cp	r16, r24
    1c3e:	19 07       	cpc	r17, r25
    1c40:	a9 f6       	brne	.-86     	; 0x1bec <PD_InterpretAVRISPPacket+0x21a>
    1c42:	23 96       	adiw	r28, 0x03	; 3
    1c44:	d0 93 61 02 	sts	0x0261, r29
    1c48:	c0 93 60 02 	sts	0x0260, r28
    1c4c:	10 92 4c 01 	sts	0x014C, r1
    1c50:	f8 01       	movw	r30, r16
    1c52:	12 82       	std	Z+2, r1	; 0x02
    1c54:	09 c0       	rjmp	.+18     	; 0x1c68 <PD_InterpretAVRISPPacket+0x296>
    1c56:	81 e0       	ldi	r24, 0x01	; 1
    1c58:	90 e0       	ldi	r25, 0x00	; 0
    1c5a:	90 93 61 02 	sts	0x0261, r25
    1c5e:	80 93 60 02 	sts	0x0260, r24
    1c62:	89 ec       	ldi	r24, 0xC9	; 201
    1c64:	80 93 4c 01 	sts	0x014C, r24
    1c68:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <V2P_SendPacket>
    1c6c:	14 c0       	rjmp	.+40     	; 0x1c96 <PD_InterpretAVRISPPacket+0x2c4>
    1c6e:	ce 01       	movw	r24, r28
    1c70:	0e 94 9e 0a 	call	0x153c	; 0x153c <DF_EraseBlock>
    1c74:	21 96       	adiw	r28, 0x01	; 1
    1c76:	80 91 43 01 	lds	r24, 0x0143
    1c7a:	90 91 44 01 	lds	r25, 0x0144
    1c7e:	23 e0       	ldi	r18, 0x03	; 3
    1c80:	96 95       	lsr	r25
    1c82:	87 95       	ror	r24
    1c84:	2a 95       	dec	r18
    1c86:	e1 f7       	brne	.-8      	; 0x1c80 <PD_InterpretAVRISPPacket+0x2ae>
    1c88:	c8 17       	cp	r28, r24
    1c8a:	d9 07       	cpc	r29, r25
    1c8c:	80 f3       	brcs	.-32     	; 0x1c6e <PD_InterpretAVRISPPacket+0x29c>
    1c8e:	8f ec       	ldi	r24, 0xCF	; 207
    1c90:	93 e0       	ldi	r25, 0x03	; 3
    1c92:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
    1c96:	df 91       	pop	r29
    1c98:	cf 91       	pop	r28
    1c9a:	1f 91       	pop	r17
    1c9c:	0f 91       	pop	r16
    1c9e:	08 95       	ret

00001ca0 <V2P_GetChecksum>:
	SequenceNum++;
}

uint8_t V2P_GetChecksum()
{
    1ca0:	90 91 5e 02 	lds	r25, 0x025E
    1ca4:	8b e1       	ldi	r24, 0x1B	; 27
    1ca6:	98 27       	eor	r25, r24
	uint8_t CheckSumByte;
	
	/* Checksum for the V2 protocol is comprised of an XOR of all the packet 
      bytes, including the start, sequence number, size and token bytes.    */
	
	CheckSumByte  = AICB_MESSAGE_START;
	CheckSumByte ^= SequenceNum;
	CheckSumByte ^= (uint8_t)(MessageSize >> 8);
    1ca8:	40 91 60 02 	lds	r20, 0x0260
    1cac:	50 91 61 02 	lds	r21, 0x0261
    1cb0:	94 27       	eor	r25, r20
	CheckSumByte ^= (uint8_t)(MessageSize);
    1cb2:	25 2f       	mov	r18, r21
    1cb4:	33 27       	eor	r19, r19
    1cb6:	8e e0       	ldi	r24, 0x0E	; 14
    1cb8:	82 27       	eor	r24, r18
	CheckSumByte ^= AICB_TOKEN;
    1cba:	98 27       	eor	r25, r24
    1cbc:	20 e0       	ldi	r18, 0x00	; 0
    1cbe:	30 e0       	ldi	r19, 0x00	; 0
    1cc0:	eb e4       	ldi	r30, 0x4B	; 75
    1cc2:	f1 e0       	ldi	r31, 0x01	; 1
    1cc4:	04 c0       	rjmp	.+8      	; 0x1cce <V2P_GetChecksum+0x2e>
	
	for (uint16_t CByteIndex = 0; CByteIndex < MessageSize; CByteIndex++)
	   CheckSumByte ^= PacketBytes[CByteIndex];
    1cc6:	81 91       	ld	r24, Z+
    1cc8:	98 27       	eor	r25, r24
    1cca:	2f 5f       	subi	r18, 0xFF	; 255
    1ccc:	3f 4f       	sbci	r19, 0xFF	; 255
    1cce:	24 17       	cp	r18, r20
    1cd0:	35 07       	cpc	r19, r21
    1cd2:	c9 f7       	brne	.-14     	; 0x1cc6 <V2P_GetChecksum+0x26>

	return CheckSumByte;
}
    1cd4:	89 2f       	mov	r24, r25
    1cd6:	99 27       	eor	r25, r25
    1cd8:	08 95       	ret

00001cda <V2P_IncrementCurrAddress>:

void V2P_GetSetParamater(void)
{
	uint8_t Param_Name = PacketBytes[1];    // Save the parameter number

	MessageSize = 3;                        // Set the default response message size to 3 bytes     
	PacketBytes[1] = AICB_STATUS_CMD_OK;    // Set the default response to OK

	switch (Param_Name)                    // Switch based on the recieved parameter byte
	{
		case AICB_PARAM_BUILD_NUMBER_LOW:
			PacketBytes[2] = VERSION_MINOR;

			break;
		case AICB_PARAM_BUILD_NUMBER_HIGH:
			PacketBytes[2] = VERSION_MAJOR;

			break;
		case AICB_PARAM_HARDWARE_VERSION:
			PacketBytes[2] = V2P_HW_VERSION;

			break;
		case AICB_PARAM_SW_MAJOR:
			PacketBytes[2] = V2P_SW_VERSION_MAJOR;

			break;
		case AICB_PARAM_SW_MINOR:
			PacketBytes[2] = ((eeprom_read_byte(&EEPROMVars.FirmVerMinor) == 0xFF)? V2P_SW_VERSION_MINOR_DEFAULT : eeprom_read_byte(&EEPROMVars.FirmVerMinor));

			break;
		case AICB_PARAM_CONTROLLER_INIT:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = Param_ControllerInit;
			}
			else
			{
				MessageSize = 2;
				Param_ControllerInit = PacketBytes[2];
			}
			
			break;
		case AICB_PARAM_SCK_DURATION:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.SCKDuration);
			}
			else
			{
				MessageSize = 2;
				eeprom_write_byte(&EEPROMVars.SCKDuration, PacketBytes[2]);
				USI_SPISetSpeed(PacketBytes[2]); // Re-Initialise the USI system with the new frequency
			}
					
			break;
		case AICB_PARAM_RESET_POLARITY:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.ResetPolarity);		
			}
			else
			{
				MessageSize = 2;
				eeprom_write_byte(&EEPROMVars.ResetPolarity, PacketBytes[2]);
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Change takes effect immediatly
			}
			
			break;
		case AICB_PARAM_OSC_PSCALE:
		case AICB_PARAM_OSC_CMATCH:
			/* Despite not supporting these parameters (STK500 only), the AVR Studio programmer
			   sends them along with the SCK duration. A OK must be returned or the sequence will fail
			   and the SCK duration byte will not be sent.                                             */
		
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			  PacketBytes[2] = 0;             // If the command is a read, return a 0 for both parameters
			else
			  MessageSize = 2;                // Otherwise just send back an OK if the command is a set		
			
			break;
		default:                             // Unrecognised parameter
			MessageSize = 2;
			PacketBytes[1] = AICB_STATUS_CMD_FAILED;			
	}
	
	V2P_SendPacket();
}

void V2P_IncrementCurrAddress(void)
{
    1cda:	80 91 63 02 	lds	r24, 0x0263
    1cde:	90 91 64 02 	lds	r25, 0x0264
    1ce2:	a0 91 65 02 	lds	r26, 0x0265
    1ce6:	b0 91 66 02 	lds	r27, 0x0266
    1cea:	01 96       	adiw	r24, 0x01	; 1
    1cec:	a1 1d       	adc	r26, r1
    1cee:	b1 1d       	adc	r27, r1
    1cf0:	80 93 63 02 	sts	0x0263, r24
    1cf4:	90 93 64 02 	sts	0x0264, r25
    1cf8:	a0 93 65 02 	sts	0x0265, r26
    1cfc:	b0 93 66 02 	sts	0x0266, r27
    1d00:	08 95       	ret

00001d02 <V2P_CheckForExtendedAddress>:
	// Incrementing a 32-bit unsigned variable takes a lot of code. Because much of the code is
	// not very time critical (much of it is waiting for the hardware), i've chosen to waste
	// a few extra cycles per increment and save a good 60 bytes or so of code space by putting
	// the incrmement inside a function.

	CurrAddress++;
}

void V2P_CheckForExtendedAddress(void)
{
    1d02:	80 91 63 02 	lds	r24, 0x0263
    1d06:	90 91 64 02 	lds	r25, 0x0264
    1d0a:	a0 91 65 02 	lds	r26, 0x0265
    1d0e:	b0 91 66 02 	lds	r27, 0x0266
    1d12:	b7 ff       	sbrs	r27, 7
    1d14:	1e c0       	rjmp	.+60     	; 0x1d52 <V2P_CheckForExtendedAddress+0x50>
	if (CurrAddress & V2P_LOAD_EXTENDED_ADDR_FLAG)     // MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
	{
		USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);   // Load extended address command
    1d16:	8d e4       	ldi	r24, 0x4D	; 77
    1d18:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1d1c:	80 e0       	ldi	r24, 0x00	; 0
    1d1e:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
		USI_SPITransmit((CurrAddress & V2P_LOAD_EXTENDED_ADDR_MASK) >> V2P_LOAD_EXTENDED_ADDR_SHIFT);
    1d22:	80 91 65 02 	lds	r24, 0x0265
    1d26:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1d2a:	80 e0       	ldi	r24, 0x00	; 0
    1d2c:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
		
		CurrAddress &= ~(V2P_LOAD_EXTENDED_ADDR_FLAG); // Clear the flag
    1d30:	80 91 63 02 	lds	r24, 0x0263
    1d34:	90 91 64 02 	lds	r25, 0x0264
    1d38:	a0 91 65 02 	lds	r26, 0x0265
    1d3c:	b0 91 66 02 	lds	r27, 0x0266
    1d40:	bf 77       	andi	r27, 0x7F	; 127
    1d42:	80 93 63 02 	sts	0x0263, r24
    1d46:	90 93 64 02 	sts	0x0264, r25
    1d4a:	a0 93 65 02 	sts	0x0265, r26
    1d4e:	b0 93 66 02 	sts	0x0266, r27
    1d52:	08 95       	ret

00001d54 <V2P_SendPacket>:
    1d54:	0f 93       	push	r16
    1d56:	1f 93       	push	r17
    1d58:	cf 93       	push	r28
    1d5a:	df 93       	push	r29
    1d5c:	8b e1       	ldi	r24, 0x1B	; 27
    1d5e:	0e 94 23 09 	call	0x1246	; 0x1246 <USART_Tx>
    1d62:	80 91 5e 02 	lds	r24, 0x025E
    1d66:	0e 94 23 09 	call	0x1246	; 0x1246 <USART_Tx>
    1d6a:	80 91 61 02 	lds	r24, 0x0261
    1d6e:	0e 94 23 09 	call	0x1246	; 0x1246 <USART_Tx>
    1d72:	80 91 60 02 	lds	r24, 0x0260
    1d76:	0e 94 23 09 	call	0x1246	; 0x1246 <USART_Tx>
    1d7a:	8e e0       	ldi	r24, 0x0E	; 14
    1d7c:	0e 94 23 09 	call	0x1246	; 0x1246 <USART_Tx>
    1d80:	c0 e0       	ldi	r28, 0x00	; 0
    1d82:	d0 e0       	ldi	r29, 0x00	; 0
    1d84:	0b e4       	ldi	r16, 0x4B	; 75
    1d86:	11 e0       	ldi	r17, 0x01	; 1
    1d88:	06 c0       	rjmp	.+12     	; 0x1d96 <V2P_SendPacket+0x42>
    1d8a:	f8 01       	movw	r30, r16
    1d8c:	81 91       	ld	r24, Z+
    1d8e:	8f 01       	movw	r16, r30
    1d90:	0e 94 23 09 	call	0x1246	; 0x1246 <USART_Tx>
    1d94:	21 96       	adiw	r28, 0x01	; 1
    1d96:	80 91 60 02 	lds	r24, 0x0260
    1d9a:	90 91 61 02 	lds	r25, 0x0261
    1d9e:	c8 17       	cp	r28, r24
    1da0:	d9 07       	cpc	r29, r25
    1da2:	98 f3       	brcs	.-26     	; 0x1d8a <V2P_SendPacket+0x36>
    1da4:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <V2P_GetChecksum>
    1da8:	0e 94 23 09 	call	0x1246	; 0x1246 <USART_Tx>
    1dac:	80 91 5e 02 	lds	r24, 0x025E
    1db0:	90 91 5f 02 	lds	r25, 0x025F
    1db4:	01 96       	adiw	r24, 0x01	; 1
    1db6:	90 93 5f 02 	sts	0x025F, r25
    1dba:	80 93 5e 02 	sts	0x025E, r24
    1dbe:	df 91       	pop	r29
    1dc0:	cf 91       	pop	r28
    1dc2:	1f 91       	pop	r17
    1dc4:	0f 91       	pop	r16
    1dc6:	08 95       	ret

00001dc8 <V2P_GetSetParamater>:
    1dc8:	20 91 4c 01 	lds	r18, 0x014C
    1dcc:	83 e0       	ldi	r24, 0x03	; 3
    1dce:	90 e0       	ldi	r25, 0x00	; 0
    1dd0:	90 93 61 02 	sts	0x0261, r25
    1dd4:	80 93 60 02 	sts	0x0260, r24
    1dd8:	10 92 4c 01 	sts	0x014C, r1
    1ddc:	22 39       	cpi	r18, 0x92	; 146
    1dde:	29 f1       	breq	.+74     	; 0x1e2a <V2P_GetSetParamater+0x62>
    1de0:	23 39       	cpi	r18, 0x93	; 147
    1de2:	70 f4       	brcc	.+28     	; 0x1e00 <V2P_GetSetParamater+0x38>
    1de4:	21 38       	cpi	r18, 0x81	; 129
    1de6:	d9 f0       	breq	.+54     	; 0x1e1e <V2P_GetSetParamater+0x56>
    1de8:	22 38       	cpi	r18, 0x82	; 130
    1dea:	20 f4       	brcc	.+8      	; 0x1df4 <V2P_GetSetParamater+0x2c>
    1dec:	20 38       	cpi	r18, 0x80	; 128
    1dee:	09 f0       	breq	.+2      	; 0x1df2 <V2P_GetSetParamater+0x2a>
    1df0:	77 c0       	rjmp	.+238    	; 0x1ee0 <V2P_GetSetParamater+0x118>
    1df2:	23 c0       	rjmp	.+70     	; 0x1e3a <V2P_GetSetParamater+0x72>
    1df4:	20 39       	cpi	r18, 0x90	; 144
    1df6:	b9 f0       	breq	.+46     	; 0x1e26 <V2P_GetSetParamater+0x5e>
    1df8:	21 39       	cpi	r18, 0x91	; 145
    1dfa:	09 f0       	breq	.+2      	; 0x1dfe <V2P_GetSetParamater+0x36>
    1dfc:	71 c0       	rjmp	.+226    	; 0x1ee0 <V2P_GetSetParamater+0x118>
    1dfe:	13 c0       	rjmp	.+38     	; 0x1e26 <V2P_GetSetParamater+0x5e>
    1e00:	28 39       	cpi	r18, 0x98	; 152
    1e02:	89 f1       	breq	.+98     	; 0x1e66 <V2P_GetSetParamater+0x9e>
    1e04:	29 39       	cpi	r18, 0x99	; 153
    1e06:	20 f4       	brcc	.+8      	; 0x1e10 <V2P_GetSetParamater+0x48>
    1e08:	26 39       	cpi	r18, 0x96	; 150
    1e0a:	08 f4       	brcc	.+2      	; 0x1e0e <V2P_GetSetParamater+0x46>
    1e0c:	69 c0       	rjmp	.+210    	; 0x1ee0 <V2P_GetSetParamater+0x118>
    1e0e:	5a c0       	rjmp	.+180    	; 0x1ec4 <V2P_GetSetParamater+0xfc>
    1e10:	2e 39       	cpi	r18, 0x9E	; 158
    1e12:	09 f4       	brne	.+2      	; 0x1e16 <V2P_GetSetParamater+0x4e>
    1e14:	3e c0       	rjmp	.+124    	; 0x1e92 <V2P_GetSetParamater+0xca>
    1e16:	2f 39       	cpi	r18, 0x9F	; 159
    1e18:	09 f0       	breq	.+2      	; 0x1e1c <V2P_GetSetParamater+0x54>
    1e1a:	62 c0       	rjmp	.+196    	; 0x1ee0 <V2P_GetSetParamater+0x118>
    1e1c:	12 c0       	rjmp	.+36     	; 0x1e42 <V2P_GetSetParamater+0x7a>
    1e1e:	81 e0       	ldi	r24, 0x01	; 1
    1e20:	80 93 4d 01 	sts	0x014D, r24
    1e24:	66 c0       	rjmp	.+204    	; 0x1ef2 <V2P_GetSetParamater+0x12a>
    1e26:	82 e0       	ldi	r24, 0x02	; 2
    1e28:	fb cf       	rjmp	.-10     	; 0x1e20 <V2P_GetSetParamater+0x58>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1e2a:	27 e8       	ldi	r18, 0x87	; 135
    1e2c:	30 e0       	ldi	r19, 0x00	; 0
    1e2e:	d9 01       	movw	r26, r18
    1e30:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
    1e34:	80 2d       	mov	r24, r0
    1e36:	8f 3f       	cpi	r24, 0xFF	; 255
    1e38:	11 f4       	brne	.+4      	; 0x1e3e <V2P_GetSetParamater+0x76>
    1e3a:	84 e0       	ldi	r24, 0x04	; 4
    1e3c:	f1 cf       	rjmp	.-30     	; 0x1e20 <V2P_GetSetParamater+0x58>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1e3e:	d9 01       	movw	r26, r18
    1e40:	2e c0       	rjmp	.+92     	; 0x1e9e <V2P_GetSetParamater+0xd6>
    1e42:	80 91 4b 01 	lds	r24, 0x014B
    1e46:	83 30       	cpi	r24, 0x03	; 3
    1e48:	19 f4       	brne	.+6      	; 0x1e50 <V2P_GetSetParamater+0x88>
    1e4a:	80 91 67 02 	lds	r24, 0x0267
    1e4e:	e8 cf       	rjmp	.-48     	; 0x1e20 <V2P_GetSetParamater+0x58>
    1e50:	82 e0       	ldi	r24, 0x02	; 2
    1e52:	90 e0       	ldi	r25, 0x00	; 0
    1e54:	90 93 61 02 	sts	0x0261, r25
    1e58:	80 93 60 02 	sts	0x0260, r24
    1e5c:	80 91 4d 01 	lds	r24, 0x014D
    1e60:	80 93 67 02 	sts	0x0267, r24
    1e64:	46 c0       	rjmp	.+140    	; 0x1ef2 <V2P_GetSetParamater+0x12a>
    1e66:	80 91 4b 01 	lds	r24, 0x014B
    1e6a:	a2 e0       	ldi	r26, 0x02	; 2
    1e6c:	b0 e0       	ldi	r27, 0x00	; 0
    1e6e:	83 30       	cpi	r24, 0x03	; 3
    1e70:	b1 f0       	breq	.+44     	; 0x1e9e <V2P_GetSetParamater+0xd6>
    1e72:	82 e0       	ldi	r24, 0x02	; 2
    1e74:	90 e0       	ldi	r25, 0x00	; 0
    1e76:	90 93 61 02 	sts	0x0261, r25
    1e7a:	80 93 60 02 	sts	0x0260, r24

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    1e7e:	80 91 4d 01 	lds	r24, 0x014D
    1e82:	08 2e       	mov	r0, r24
    1e84:	0e 94 36 1a 	call	0x346c	; 0x346c <__eeprom_write_byte_1F2021>
    1e88:	80 91 4d 01 	lds	r24, 0x014D
    1e8c:	0e 94 b2 09 	call	0x1364	; 0x1364 <USI_SPISetSpeed>
    1e90:	30 c0       	rjmp	.+96     	; 0x1ef2 <V2P_GetSetParamater+0x12a>
    1e92:	80 91 4b 01 	lds	r24, 0x014B
    1e96:	a1 e0       	ldi	r26, 0x01	; 1
    1e98:	b0 e0       	ldi	r27, 0x00	; 0
    1e9a:	83 30       	cpi	r24, 0x03	; 3
    1e9c:	21 f4       	brne	.+8      	; 0x1ea6 <V2P_GetSetParamater+0xde>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1e9e:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
    1ea2:	80 2d       	mov	r24, r0
    1ea4:	bd cf       	rjmp	.-134    	; 0x1e20 <V2P_GetSetParamater+0x58>
    1ea6:	82 e0       	ldi	r24, 0x02	; 2
    1ea8:	90 e0       	ldi	r25, 0x00	; 0
    1eaa:	90 93 61 02 	sts	0x0261, r25
    1eae:	80 93 60 02 	sts	0x0260, r24

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    1eb2:	80 91 4d 01 	lds	r24, 0x014D
    1eb6:	08 2e       	mov	r0, r24
    1eb8:	0e 94 36 1a 	call	0x346c	; 0x346c <__eeprom_write_byte_1F2021>
    1ebc:	81 e0       	ldi	r24, 0x01	; 1
    1ebe:	0e 94 51 02 	call	0x4a2	; 0x4a2 <MAIN_ResetCSLine>
    1ec2:	17 c0       	rjmp	.+46     	; 0x1ef2 <V2P_GetSetParamater+0x12a>
    1ec4:	80 91 4b 01 	lds	r24, 0x014B
    1ec8:	83 30       	cpi	r24, 0x03	; 3
    1eca:	19 f4       	brne	.+6      	; 0x1ed2 <V2P_GetSetParamater+0x10a>
    1ecc:	10 92 4d 01 	sts	0x014D, r1
    1ed0:	10 c0       	rjmp	.+32     	; 0x1ef2 <V2P_GetSetParamater+0x12a>
    1ed2:	82 e0       	ldi	r24, 0x02	; 2
    1ed4:	90 e0       	ldi	r25, 0x00	; 0
    1ed6:	90 93 61 02 	sts	0x0261, r25
    1eda:	80 93 60 02 	sts	0x0260, r24
    1ede:	09 c0       	rjmp	.+18     	; 0x1ef2 <V2P_GetSetParamater+0x12a>
    1ee0:	82 e0       	ldi	r24, 0x02	; 2
    1ee2:	90 e0       	ldi	r25, 0x00	; 0
    1ee4:	90 93 61 02 	sts	0x0261, r25
    1ee8:	80 93 60 02 	sts	0x0260, r24
    1eec:	80 ec       	ldi	r24, 0xC0	; 192
    1eee:	80 93 4c 01 	sts	0x014C, r24
    1ef2:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <V2P_SendPacket>
    1ef6:	08 95       	ret

00001ef8 <V2P_RunStateMachine>:
    1ef8:	ef 92       	push	r14
    1efa:	ff 92       	push	r15
    1efc:	0f 93       	push	r16
    1efe:	1f 93       	push	r17
    1f00:	cf 93       	push	r28
    1f02:	df 93       	push	r29
    1f04:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <BUFF_InitialiseBuffer>
    1f08:	10 92 81 00 	sts	0x0081, r1
    1f0c:	10 92 62 02 	sts	0x0262, r1
    1f10:	10 92 63 02 	sts	0x0263, r1
    1f14:	10 92 64 02 	sts	0x0264, r1
    1f18:	10 92 65 02 	sts	0x0265, r1
    1f1c:	10 92 66 02 	sts	0x0266, r1
    1f20:	c0 e0       	ldi	r28, 0x00	; 0
    1f22:	d0 e0       	ldi	r29, 0x00	; 0
    1f24:	4d c0       	rjmp	.+154    	; 0x1fc0 <V2P_RunStateMachine+0xc8>
    1f26:	12 e0       	ldi	r17, 0x02	; 2
    1f28:	01 c0       	rjmp	.+2      	; 0x1f2c <V2P_RunStateMachine+0x34>
    1f2a:	19 e0       	ldi	r17, 0x09	; 9
    1f2c:	80 91 46 01 	lds	r24, 0x0146
    1f30:	81 30       	cpi	r24, 0x01	; 1
    1f32:	b1 f1       	breq	.+108    	; 0x1fa0 <V2P_RunStateMachine+0xa8>
    1f34:	11 23       	and	r17, r17
    1f36:	09 f4       	brne	.+2      	; 0x1f3a <V2P_RunStateMachine+0x42>
    1f38:	45 c0       	rjmp	.+138    	; 0x1fc4 <V2P_RunStateMachine+0xcc>
    1f3a:	10 92 46 01 	sts	0x0146, r1
    1f3e:	10 92 45 01 	sts	0x0145, r1
    1f42:	10 92 b2 00 	sts	0x00B2, r1
    1f46:	80 ef       	ldi	r24, 0xF0	; 240
    1f48:	80 93 b3 00 	sts	0x00B3, r24
    1f4c:	82 e0       	ldi	r24, 0x02	; 2
    1f4e:	80 93 70 00 	sts	0x0070, r24
    1f52:	8f e0       	ldi	r24, 0x0F	; 15
    1f54:	80 93 b0 00 	sts	0x00B0, r24
    1f58:	15 30       	cpi	r17, 0x05	; 5
    1f5a:	09 f4       	brne	.+2      	; 0x1f5e <V2P_RunStateMachine+0x66>
    1f5c:	6f c0       	rjmp	.+222    	; 0x203c <V2P_RunStateMachine+0x144>
    1f5e:	16 30       	cpi	r17, 0x06	; 6
    1f60:	80 f4       	brcc	.+32     	; 0x1f82 <V2P_RunStateMachine+0x8a>
    1f62:	12 30       	cpi	r17, 0x02	; 2
    1f64:	09 f4       	brne	.+2      	; 0x1f68 <V2P_RunStateMachine+0x70>
    1f66:	41 c0       	rjmp	.+130    	; 0x1fea <V2P_RunStateMachine+0xf2>
    1f68:	13 30       	cpi	r17, 0x03	; 3
    1f6a:	28 f4       	brcc	.+10     	; 0x1f76 <V2P_RunStateMachine+0x7e>
    1f6c:	11 23       	and	r17, r17
    1f6e:	51 f1       	breq	.+84     	; 0x1fc4 <V2P_RunStateMachine+0xcc>
    1f70:	11 30       	cpi	r17, 0x01	; 1
    1f72:	e1 f6       	brne	.-72     	; 0x1f2c <V2P_RunStateMachine+0x34>
    1f74:	34 c0       	rjmp	.+104    	; 0x1fde <V2P_RunStateMachine+0xe6>
    1f76:	13 30       	cpi	r17, 0x03	; 3
    1f78:	09 f4       	brne	.+2      	; 0x1f7c <V2P_RunStateMachine+0x84>
    1f7a:	40 c0       	rjmp	.+128    	; 0x1ffc <V2P_RunStateMachine+0x104>
    1f7c:	14 30       	cpi	r17, 0x04	; 4
    1f7e:	b1 f6       	brne	.-84     	; 0x1f2c <V2P_RunStateMachine+0x34>
    1f80:	48 c0       	rjmp	.+144    	; 0x2012 <V2P_RunStateMachine+0x11a>
    1f82:	18 30       	cpi	r17, 0x08	; 8
    1f84:	a9 f0       	breq	.+42     	; 0x1fb0 <V2P_RunStateMachine+0xb8>
    1f86:	19 30       	cpi	r17, 0x09	; 9
    1f88:	30 f4       	brcc	.+12     	; 0x1f96 <V2P_RunStateMachine+0x9e>
    1f8a:	16 30       	cpi	r17, 0x06	; 6
    1f8c:	09 f4       	brne	.+2      	; 0x1f90 <V2P_RunStateMachine+0x98>
    1f8e:	5d c0       	rjmp	.+186    	; 0x204a <V2P_RunStateMachine+0x152>
    1f90:	17 30       	cpi	r17, 0x07	; 7
    1f92:	61 f6       	brne	.-104    	; 0x1f2c <V2P_RunStateMachine+0x34>
    1f94:	6b c0       	rjmp	.+214    	; 0x206c <V2P_RunStateMachine+0x174>
    1f96:	19 30       	cpi	r17, 0x09	; 9
    1f98:	09 f4       	brne	.+2      	; 0x1f9c <V2P_RunStateMachine+0xa4>
    1f9a:	98 c0       	rjmp	.+304    	; 0x20cc <V2P_RunStateMachine+0x1d4>
    1f9c:	1a 30       	cpi	r17, 0x0A	; 10
    1f9e:	31 f6       	brne	.-116    	; 0x1f2c <V2P_RunStateMachine+0x34>
    1fa0:	82 e0       	ldi	r24, 0x02	; 2
    1fa2:	90 e0       	ldi	r25, 0x00	; 0
    1fa4:	90 93 61 02 	sts	0x0261, r25
    1fa8:	80 93 60 02 	sts	0x0260, r24
    1fac:	80 e8       	ldi	r24, 0x80	; 128
    1fae:	e4 c0       	rjmp	.+456    	; 0x2178 <V2P_RunStateMachine+0x280>
    1fb0:	10 92 46 01 	sts	0x0146, r1
    1fb4:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <BUFF_InitialiseBuffer>
    1fb8:	10 92 b0 00 	sts	0x00B0, r1
    1fbc:	10 92 70 00 	sts	0x0070, r1
    1fc0:	10 e0       	ldi	r17, 0x00	; 0
    1fc2:	b4 cf       	rjmp	.-152    	; 0x1f2c <V2P_RunStateMachine+0x34>
    1fc4:	80 91 b7 02 	lds	r24, 0x02B7
    1fc8:	81 11       	cpse	r24, r1
    1fca:	81 e0       	ldi	r24, 0x01	; 1
    1fcc:	18 2f       	mov	r17, r24
    1fce:	f2 9b       	sbis	0x1e, 2	; 30
    1fd0:	ad cf       	rjmp	.-166    	; 0x1f2c <V2P_RunStateMachine+0x34>
    1fd2:	80 91 62 02 	lds	r24, 0x0262
    1fd6:	88 23       	and	r24, r24
    1fd8:	09 f0       	breq	.+2      	; 0x1fdc <V2P_RunStateMachine+0xe4>
    1fda:	a8 cf       	rjmp	.-176    	; 0x1f2c <V2P_RunStateMachine+0x34>
    1fdc:	d3 c0       	rjmp	.+422    	; 0x2184 <V2P_RunStateMachine+0x28c>
    1fde:	0e 94 2b 09 	call	0x1256	; 0x1256 <USART_Rx>
    1fe2:	8b 31       	cpi	r24, 0x1B	; 27
    1fe4:	09 f0       	breq	.+2      	; 0x1fe8 <V2P_RunStateMachine+0xf0>
    1fe6:	a1 cf       	rjmp	.-190    	; 0x1f2a <V2P_RunStateMachine+0x32>
    1fe8:	9e cf       	rjmp	.-196    	; 0x1f26 <V2P_RunStateMachine+0x2e>
    1fea:	0e 94 2b 09 	call	0x1256	; 0x1256 <USART_Rx>
    1fee:	99 27       	eor	r25, r25
    1ff0:	90 93 5f 02 	sts	0x025F, r25
    1ff4:	80 93 5e 02 	sts	0x025E, r24
    1ff8:	13 e0       	ldi	r17, 0x03	; 3
    1ffa:	98 cf       	rjmp	.-208    	; 0x1f2c <V2P_RunStateMachine+0x34>
    1ffc:	0e 94 2b 09 	call	0x1256	; 0x1256 <USART_Rx>
    2000:	99 27       	eor	r25, r25
    2002:	98 2f       	mov	r25, r24
    2004:	88 27       	eor	r24, r24
    2006:	90 93 61 02 	sts	0x0261, r25
    200a:	80 93 60 02 	sts	0x0260, r24
    200e:	14 e0       	ldi	r17, 0x04	; 4
    2010:	8d cf       	rjmp	.-230    	; 0x1f2c <V2P_RunStateMachine+0x34>
    2012:	00 91 60 02 	lds	r16, 0x0260
    2016:	10 91 61 02 	lds	r17, 0x0261
    201a:	0e 94 2b 09 	call	0x1256	; 0x1256 <USART_Rx>
    201e:	99 27       	eor	r25, r25
    2020:	80 2b       	or	r24, r16
    2022:	91 2b       	or	r25, r17
    2024:	90 93 61 02 	sts	0x0261, r25
    2028:	80 93 60 02 	sts	0x0260, r24
    202c:	83 51       	subi	r24, 0x13	; 19
    202e:	91 40       	sbci	r25, 0x01	; 1
    2030:	08 f0       	brcs	.+2      	; 0x2034 <V2P_RunStateMachine+0x13c>
    2032:	7b cf       	rjmp	.-266    	; 0x1f2a <V2P_RunStateMachine+0x32>
    2034:	c0 e0       	ldi	r28, 0x00	; 0
    2036:	d0 e0       	ldi	r29, 0x00	; 0
    2038:	15 e0       	ldi	r17, 0x05	; 5
    203a:	78 cf       	rjmp	.-272    	; 0x1f2c <V2P_RunStateMachine+0x34>
    203c:	0e 94 2b 09 	call	0x1256	; 0x1256 <USART_Rx>
    2040:	8e 30       	cpi	r24, 0x0E	; 14
    2042:	09 f0       	breq	.+2      	; 0x2046 <V2P_RunStateMachine+0x14e>
    2044:	72 cf       	rjmp	.-284    	; 0x1f2a <V2P_RunStateMachine+0x32>
    2046:	16 e0       	ldi	r17, 0x06	; 6
    2048:	71 cf       	rjmp	.-286    	; 0x1f2c <V2P_RunStateMachine+0x34>
    204a:	80 91 60 02 	lds	r24, 0x0260
    204e:	90 91 61 02 	lds	r25, 0x0261
    2052:	c8 17       	cp	r28, r24
    2054:	d9 07       	cpc	r29, r25
    2056:	11 f4       	brne	.+4      	; 0x205c <V2P_RunStateMachine+0x164>
    2058:	17 e0       	ldi	r17, 0x07	; 7
    205a:	68 cf       	rjmp	.-304    	; 0x1f2c <V2P_RunStateMachine+0x34>
    205c:	0e 94 2b 09 	call	0x1256	; 0x1256 <USART_Rx>
    2060:	fe 01       	movw	r30, r28
    2062:	e5 5b       	subi	r30, 0xB5	; 181
    2064:	fe 4f       	sbci	r31, 0xFE	; 254
    2066:	80 83       	st	Z, r24
    2068:	21 96       	adiw	r28, 0x01	; 1
    206a:	60 cf       	rjmp	.-320    	; 0x1f2c <V2P_RunStateMachine+0x34>
    206c:	80 91 46 01 	lds	r24, 0x0146
    2070:	88 23       	and	r24, r24
    2072:	09 f0       	breq	.+2      	; 0x2076 <V2P_RunStateMachine+0x17e>
    2074:	5b cf       	rjmp	.-330    	; 0x1f2c <V2P_RunStateMachine+0x34>
    2076:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <V2P_GetChecksum>
    207a:	18 2f       	mov	r17, r24
    207c:	0e 94 2b 09 	call	0x1256	; 0x1256 <USART_Rx>
    2080:	18 17       	cp	r17, r24
    2082:	09 f0       	breq	.+2      	; 0x2086 <V2P_RunStateMachine+0x18e>
    2084:	72 c0       	rjmp	.+228    	; 0x216a <V2P_RunStateMachine+0x272>
    2086:	80 91 4b 01 	lds	r24, 0x014B
    208a:	84 30       	cpi	r24, 0x04	; 4
    208c:	38 f4       	brcc	.+14     	; 0x209c <V2P_RunStateMachine+0x1a4>
    208e:	82 30       	cpi	r24, 0x02	; 2
    2090:	08 f0       	brcs	.+2      	; 0x2094 <V2P_RunStateMachine+0x19c>
    2092:	62 c0       	rjmp	.+196    	; 0x2158 <V2P_RunStateMachine+0x260>
    2094:	81 30       	cpi	r24, 0x01	; 1
    2096:	09 f0       	breq	.+2      	; 0x209a <V2P_RunStateMachine+0x1a2>
    2098:	62 c0       	rjmp	.+196    	; 0x215e <V2P_RunStateMachine+0x266>
    209a:	06 c0       	rjmp	.+12     	; 0x20a8 <V2P_RunStateMachine+0x1b0>
    209c:	86 30       	cpi	r24, 0x06	; 6
    209e:	f1 f0       	breq	.+60     	; 0x20dc <V2P_RunStateMachine+0x1e4>
    20a0:	87 30       	cpi	r24, 0x07	; 7
    20a2:	09 f0       	breq	.+2      	; 0x20a6 <V2P_RunStateMachine+0x1ae>
    20a4:	5c c0       	rjmp	.+184    	; 0x215e <V2P_RunStateMachine+0x266>
    20a6:	12 c0       	rjmp	.+36     	; 0x20cc <V2P_RunStateMachine+0x1d4>
    20a8:	8b e0       	ldi	r24, 0x0B	; 11
    20aa:	90 e0       	ldi	r25, 0x00	; 0
    20ac:	90 93 61 02 	sts	0x0261, r25
    20b0:	80 93 60 02 	sts	0x0260, r24
    20b4:	e0 ee       	ldi	r30, 0xE0	; 224
    20b6:	f3 e0       	ldi	r31, 0x03	; 3
    20b8:	ab e4       	ldi	r26, 0x4B	; 75
    20ba:	b1 e0       	ldi	r27, 0x01	; 1
    20bc:	84 91       	lpm	r24, Z
    20be:	8d 93       	st	X+, r24
    20c0:	31 96       	adiw	r30, 0x01	; 1
    20c2:	81 e0       	ldi	r24, 0x01	; 1
    20c4:	a6 35       	cpi	r26, 0x56	; 86
    20c6:	b8 07       	cpc	r27, r24
    20c8:	c9 f7       	brne	.-14     	; 0x20bc <V2P_RunStateMachine+0x1c4>
    20ca:	58 c0       	rjmp	.+176    	; 0x217c <V2P_RunStateMachine+0x284>
    20cc:	82 e0       	ldi	r24, 0x02	; 2
    20ce:	90 e0       	ldi	r25, 0x00	; 0
    20d0:	90 93 61 02 	sts	0x0261, r25
    20d4:	80 93 60 02 	sts	0x0260, r24
    20d8:	80 ec       	ldi	r24, 0xC0	; 192
    20da:	4e c0       	rjmp	.+156    	; 0x2178 <V2P_RunStateMachine+0x280>
    20dc:	82 e0       	ldi	r24, 0x02	; 2
    20de:	90 e0       	ldi	r25, 0x00	; 0
    20e0:	90 93 61 02 	sts	0x0261, r25
    20e4:	80 93 60 02 	sts	0x0260, r24
    20e8:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <V2P_CheckForExtendedAddress>
    20ec:	e0 90 4e 01 	lds	r14, 0x014E
    20f0:	ff 24       	eor	r15, r15
    20f2:	00 27       	eor	r16, r16
    20f4:	11 27       	eor	r17, r17
    20f6:	10 2f       	mov	r17, r16
    20f8:	0f 2d       	mov	r16, r15
    20fa:	fe 2c       	mov	r15, r14
    20fc:	ee 24       	eor	r14, r14
    20fe:	20 91 4c 01 	lds	r18, 0x014C
    2102:	33 27       	eor	r19, r19
    2104:	44 27       	eor	r20, r20
    2106:	55 27       	eor	r21, r21
    2108:	52 2f       	mov	r21, r18
    210a:	44 27       	eor	r20, r20
    210c:	33 27       	eor	r19, r19
    210e:	22 27       	eor	r18, r18
    2110:	80 91 4d 01 	lds	r24, 0x014D
    2114:	99 27       	eor	r25, r25
    2116:	aa 27       	eor	r26, r26
    2118:	bb 27       	eor	r27, r27
    211a:	dc 01       	movw	r26, r24
    211c:	99 27       	eor	r25, r25
    211e:	88 27       	eor	r24, r24
    2120:	28 2b       	or	r18, r24
    2122:	39 2b       	or	r19, r25
    2124:	4a 2b       	or	r20, r26
    2126:	5b 2b       	or	r21, r27
    2128:	80 91 4f 01 	lds	r24, 0x014F
    212c:	99 27       	eor	r25, r25
    212e:	aa 27       	eor	r26, r26
    2130:	bb 27       	eor	r27, r27
    2132:	28 2b       	or	r18, r24
    2134:	39 2b       	or	r19, r25
    2136:	4a 2b       	or	r20, r26
    2138:	5b 2b       	or	r21, r27
    213a:	e2 2a       	or	r14, r18
    213c:	f3 2a       	or	r15, r19
    213e:	04 2b       	or	r16, r20
    2140:	15 2b       	or	r17, r21
    2142:	e0 92 63 02 	sts	0x0263, r14
    2146:	f0 92 64 02 	sts	0x0264, r15
    214a:	00 93 65 02 	sts	0x0265, r16
    214e:	10 93 66 02 	sts	0x0266, r17
    2152:	10 92 4c 01 	sts	0x014C, r1
    2156:	12 c0       	rjmp	.+36     	; 0x217c <V2P_RunStateMachine+0x284>
    2158:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <V2P_GetSetParamater>
    215c:	11 c0       	rjmp	.+34     	; 0x2180 <V2P_RunStateMachine+0x288>
    215e:	e0 91 02 01 	lds	r30, 0x0102
    2162:	f0 91 03 01 	lds	r31, 0x0103
    2166:	09 95       	icall
    2168:	0b c0       	rjmp	.+22     	; 0x2180 <V2P_RunStateMachine+0x288>
    216a:	82 e0       	ldi	r24, 0x02	; 2
    216c:	90 e0       	ldi	r25, 0x00	; 0
    216e:	90 93 61 02 	sts	0x0261, r25
    2172:	80 93 60 02 	sts	0x0260, r24
    2176:	81 ec       	ldi	r24, 0xC1	; 193
    2178:	80 93 4c 01 	sts	0x014C, r24
    217c:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <V2P_SendPacket>
    2180:	18 e0       	ldi	r17, 0x08	; 8
    2182:	d4 ce       	rjmp	.-600    	; 0x1f2c <V2P_RunStateMachine+0x34>
    2184:	80 e8       	ldi	r24, 0x80	; 128
    2186:	80 93 61 00 	sts	0x0061, r24
    218a:	83 e0       	ldi	r24, 0x03	; 3
    218c:	80 93 61 00 	sts	0x0061, r24
    2190:	80 91 c1 00 	lds	r24, 0x00C1
    2194:	80 78       	andi	r24, 0x80	; 128
    2196:	80 93 c1 00 	sts	0x00C1, r24
    219a:	0e 94 07 0c 	call	0x180e	; 0x180e <TOUT_SetupSleepTimer>
    219e:	df 91       	pop	r29
    21a0:	cf 91       	pop	r28
    21a2:	1f 91       	pop	r17
    21a4:	0f 91       	pop	r16
    21a6:	ff 90       	pop	r15
    21a8:	ef 90       	pop	r14
    21aa:	08 95       	ret

000021ac <ISPCC_PollForProgComplete>:
	}
}

void ISPCC_PollForProgComplete(const uint8_t PollData, uint16_t PollAddr)
{
    21ac:	1f 93       	push	r17
    21ae:	cf 93       	push	r28
    21b0:	df 93       	push	r29
    21b2:	eb 01       	movw	r28, r22
	uint8_t PollType;
	uint8_t ProgCommand;

	if (PollData & ISPCC_PROG_MODE_PAGE)
    21b4:	99 27       	eor	r25, r25
    21b6:	80 ff       	sbrs	r24, 0
    21b8:	08 c0       	rjmp	.+16     	; 0x21ca <ISPCC_PollForProgComplete+0x1e>
	   PollType = ((PollData & ISPCC_PAGE_POLLTYPE_MASK) >> ISPCC_PAGE_POLLTYPE_MASKSHIFT);
    21ba:	80 77       	andi	r24, 0x70	; 112
    21bc:	90 70       	andi	r25, 0x00	; 0
    21be:	34 e0       	ldi	r19, 0x04	; 4
    21c0:	95 95       	asr	r25
    21c2:	87 95       	ror	r24
    21c4:	3a 95       	dec	r19
    21c6:	e1 f7       	brne	.-8      	; 0x21c0 <ISPCC_PollForProgComplete+0x14>
    21c8:	04 c0       	rjmp	.+8      	; 0x21d2 <ISPCC_PollForProgComplete+0x26>
	else
	   PollType = ((PollData & ISPCC_WORD_POLLTYPE_MASK) >> ISPCC_WORD_POLLTYPE_MASKSHIFT);	
    21ca:	8e 70       	andi	r24, 0x0E	; 14
    21cc:	90 70       	andi	r25, 0x00	; 0
    21ce:	95 95       	asr	r25
    21d0:	87 95       	ror	r24

	switch (PollType & ISPCC_POLLTYPE_MASK)
    21d2:	99 27       	eor	r25, r25
    21d4:	87 70       	andi	r24, 0x07	; 7
    21d6:	90 70       	andi	r25, 0x00	; 0
    21d8:	82 30       	cpi	r24, 0x02	; 2
    21da:	91 05       	cpc	r25, r1
    21dc:	19 f0       	breq	.+6      	; 0x21e4 <ISPCC_PollForProgComplete+0x38>
    21de:	04 97       	sbiw	r24, 0x04	; 4
    21e0:	41 f5       	brne	.+80     	; 0x2232 <ISPCC_PollForProgComplete+0x86>
    21e2:	1c c0       	rjmp	.+56     	; 0x221c <ISPCC_PollForProgComplete+0x70>
	{
		case ISPCC_POLLTYPE_DATA:
			ProgCommand = PacketBytes[7];
    21e4:	10 91 52 01 	lds	r17, 0x0152
			
			if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP) // Flash uses word addresses
    21e8:	80 91 4b 01 	lds	r24, 0x014B
    21ec:	83 31       	cpi	r24, 0x13	; 19
    21ee:	41 f4       	brne	.+16     	; 0x2200 <ISPCC_PollForProgComplete+0x54>
			{
				ProgCommand  |= ((PollAddr & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ);
    21f0:	c0 ff       	sbrs	r28, 0
    21f2:	02 c0       	rjmp	.+4      	; 0x21f8 <ISPCC_PollForProgComplete+0x4c>
    21f4:	88 e0       	ldi	r24, 0x08	; 8
    21f6:	01 c0       	rjmp	.+2      	; 0x21fa <ISPCC_PollForProgComplete+0x4e>
    21f8:	80 e0       	ldi	r24, 0x00	; 0
    21fa:	18 2b       	or	r17, r24
				PollAddr    >>= 1;
    21fc:	d6 95       	lsr	r29
    21fe:	c7 95       	ror	r28
			}

			do
			{
				USI_SPITransmit(ProgCommand);
    2200:	81 2f       	mov	r24, r17
    2202:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
				USI_SPITransmitWord(PollAddr);
    2206:	ce 01       	movw	r24, r28
    2208:	0e 94 a4 09 	call	0x1348	; 0x1348 <USI_SPITransmitWord>
			}
			while (USI_SPITransmit(0x00) == PacketBytes[8]);
    220c:	80 e0       	ldi	r24, 0x00	; 0
    220e:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    2212:	90 91 53 01 	lds	r25, 0x0153
    2216:	89 17       	cp	r24, r25
    2218:	81 f4       	brne	.+32     	; 0x223a <ISPCC_PollForProgComplete+0x8e>
    221a:	f2 cf       	rjmp	.-28     	; 0x2200 <ISPCC_PollForProgComplete+0x54>
						
			break;
		case ISPCC_POLLTYPE_READY:
			do
			   USI_SPITransmitWord(0xF000);
    221c:	80 e0       	ldi	r24, 0x00	; 0
    221e:	90 ef       	ldi	r25, 0xF0	; 240
    2220:	0e 94 a4 09 	call	0x1348	; 0x1348 <USI_SPITransmitWord>
			while (USI_SPITransmitWord(0x0000) & ISPCC_POLL_BUSYFLAG);
    2224:	80 e0       	ldi	r24, 0x00	; 0
    2226:	90 e0       	ldi	r25, 0x00	; 0
    2228:	0e 94 a4 09 	call	0x1348	; 0x1348 <USI_SPITransmitWord>
    222c:	80 ff       	sbrs	r24, 0
    222e:	05 c0       	rjmp	.+10     	; 0x223a <ISPCC_PollForProgComplete+0x8e>
    2230:	f5 cf       	rjmp	.-22     	; 0x221c <ISPCC_PollForProgComplete+0x70>

			break;
		default:                                      // Default is Wait polling
			MAIN_Delay1MS(PacketBytes[4]);	
    2232:	80 91 4f 01 	lds	r24, 0x014F
    2236:	0e 94 47 02 	call	0x48e	; 0x48e <MAIN_Delay1MS>
    223a:	df 91       	pop	r29
    223c:	cf 91       	pop	r28
    223e:	1f 91       	pop	r17
    2240:	08 95       	ret

00002242 <ISPCC_ProgramChip>:
    2242:	4f 92       	push	r4
    2244:	5f 92       	push	r5
    2246:	6f 92       	push	r6
    2248:	7f 92       	push	r7
    224a:	8f 92       	push	r8
    224c:	9f 92       	push	r9
    224e:	af 92       	push	r10
    2250:	bf 92       	push	r11
    2252:	cf 92       	push	r12
    2254:	df 92       	push	r13
    2256:	ef 92       	push	r14
    2258:	ff 92       	push	r15
    225a:	0f 93       	push	r16
    225c:	1f 93       	push	r17
    225e:	cf 93       	push	r28
    2260:	df 93       	push	r29
    2262:	d0 90 4e 01 	lds	r13, 0x014E
    2266:	c0 90 50 01 	lds	r12, 0x0150
    226a:	40 90 63 02 	lds	r4, 0x0263
    226e:	50 90 64 02 	lds	r5, 0x0264
    2272:	60 90 65 02 	lds	r6, 0x0265
    2276:	70 90 66 02 	lds	r7, 0x0266
    227a:	80 91 4c 01 	lds	r24, 0x014C
    227e:	99 27       	eor	r25, r25
    2280:	b8 2e       	mov	r11, r24
    2282:	aa 24       	eor	r10, r10
    2284:	80 91 4d 01 	lds	r24, 0x014D
    2288:	99 27       	eor	r25, r25
    228a:	a8 2a       	or	r10, r24
    228c:	b9 2a       	or	r11, r25
    228e:	d0 fc       	sbrc	r13, 0
    2290:	09 c0       	rjmp	.+18     	; 0x22a4 <ISPCC_ProgramChip+0x62>
    2292:	c0 e0       	ldi	r28, 0x00	; 0
    2294:	d0 e0       	ldi	r29, 0x00	; 0
    2296:	ee 24       	eor	r14, r14
    2298:	ff 24       	eor	r15, r15
    229a:	75 e5       	ldi	r23, 0x55	; 85
    229c:	87 2e       	mov	r8, r23
    229e:	71 e0       	ldi	r23, 0x01	; 1
    22a0:	97 2e       	mov	r9, r23
    22a2:	b0 c0       	rjmp	.+352    	; 0x2404 <ISPCC_ProgramChip+0x1c2>
    22a4:	c0 e0       	ldi	r28, 0x00	; 0
    22a6:	d0 e0       	ldi	r29, 0x00	; 0
    22a8:	00 e0       	ldi	r16, 0x00	; 0
    22aa:	10 e0       	ldi	r17, 0x00	; 0
    22ac:	65 e5       	ldi	r22, 0x55	; 85
    22ae:	86 2e       	mov	r8, r22
    22b0:	61 e0       	ldi	r22, 0x01	; 1
    22b2:	96 2e       	mov	r9, r22
    22b4:	43 c0       	rjmp	.+134    	; 0x233c <ISPCC_ProgramChip+0xfa>
    22b6:	f4 01       	movw	r30, r8
    22b8:	f0 80       	ld	r15, Z
    22ba:	80 91 4b 01 	lds	r24, 0x014B
    22be:	83 31       	cpi	r24, 0x13	; 19
    22c0:	39 f4       	brne	.+14     	; 0x22d0 <ISPCC_ProgramChip+0x8e>
    22c2:	00 ff       	sbrs	r16, 0
    22c4:	02 c0       	rjmp	.+4      	; 0x22ca <ISPCC_ProgramChip+0x88>
    22c6:	88 e0       	ldi	r24, 0x08	; 8
    22c8:	01 c0       	rjmp	.+2      	; 0x22cc <ISPCC_ProgramChip+0x8a>
    22ca:	80 e0       	ldi	r24, 0x00	; 0
    22cc:	8c 29       	or	r24, r12
    22ce:	01 c0       	rjmp	.+2      	; 0x22d2 <ISPCC_ProgramChip+0x90>
    22d0:	8c 2d       	mov	r24, r12
    22d2:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    22d6:	80 91 63 02 	lds	r24, 0x0263
    22da:	90 91 64 02 	lds	r25, 0x0264
    22de:	0e 94 a4 09 	call	0x1348	; 0x1348 <USI_SPITransmitWord>
    22e2:	8f 2d       	mov	r24, r15
    22e4:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    22e8:	20 97       	sbiw	r28, 0x00	; 0
    22ea:	d9 f4       	brne	.+54     	; 0x2322 <ISPCC_ProgramChip+0xe0>
    22ec:	80 91 53 01 	lds	r24, 0x0153
    22f0:	8f 15       	cp	r24, r15
    22f2:	b9 f0       	breq	.+46     	; 0x2322 <ISPCC_ProgramChip+0xe0>
    22f4:	80 91 4b 01 	lds	r24, 0x014B
    22f8:	83 31       	cpi	r24, 0x13	; 19
    22fa:	41 f0       	breq	.+16     	; 0x230c <ISPCC_ProgramChip+0xca>
    22fc:	85 31       	cpi	r24, 0x15	; 21
    22fe:	89 f4       	brne	.+34     	; 0x2322 <ISPCC_ProgramChip+0xe0>
    2300:	80 91 54 01 	lds	r24, 0x0154
    2304:	8f 15       	cp	r24, r15
    2306:	09 f0       	breq	.+2      	; 0x230a <ISPCC_ProgramChip+0xc8>
    2308:	82 c0       	rjmp	.+260    	; 0x240e <ISPCC_ProgramChip+0x1cc>
    230a:	0b c0       	rjmp	.+22     	; 0x2322 <ISPCC_ProgramChip+0xe0>
    230c:	c0 91 63 02 	lds	r28, 0x0263
    2310:	d0 91 64 02 	lds	r29, 0x0264
    2314:	cc 0f       	add	r28, r28
    2316:	dd 1f       	adc	r29, r29
    2318:	c8 01       	movw	r24, r16
    231a:	81 70       	andi	r24, 0x01	; 1
    231c:	90 70       	andi	r25, 0x00	; 0
    231e:	c8 0f       	add	r28, r24
    2320:	d9 1f       	adc	r29, r25
    2322:	00 fd       	sbrc	r16, 0
    2324:	04 c0       	rjmp	.+8      	; 0x232e <ISPCC_ProgramChip+0xec>
    2326:	80 91 4b 01 	lds	r24, 0x014B
    232a:	85 31       	cpi	r24, 0x15	; 21
    232c:	11 f4       	brne	.+4      	; 0x2332 <ISPCC_ProgramChip+0xf0>
    232e:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <V2P_IncrementCurrAddress>
    2332:	0f 5f       	subi	r16, 0xFF	; 255
    2334:	1f 4f       	sbci	r17, 0xFF	; 255
    2336:	08 94       	sec
    2338:	81 1c       	adc	r8, r1
    233a:	91 1c       	adc	r9, r1
    233c:	0a 15       	cp	r16, r10
    233e:	1b 05       	cpc	r17, r11
    2340:	09 f0       	breq	.+2      	; 0x2344 <ISPCC_ProgramChip+0x102>
    2342:	b9 cf       	rjmp	.-142    	; 0x22b6 <ISPCC_ProgramChip+0x74>
    2344:	d7 fe       	sbrs	r13, 7
    2346:	6e c0       	rjmp	.+220    	; 0x2424 <ISPCC_ProgramChip+0x1e2>
    2348:	80 91 51 01 	lds	r24, 0x0151
    234c:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    2350:	c2 01       	movw	r24, r4
    2352:	0e 94 a4 09 	call	0x1348	; 0x1348 <USI_SPITransmitWord>
    2356:	80 e0       	ldi	r24, 0x00	; 0
    2358:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    235c:	20 97       	sbiw	r28, 0x00	; 0
    235e:	11 f0       	breq	.+4      	; 0x2364 <ISPCC_ProgramChip+0x122>
    2360:	8d 2d       	mov	r24, r13
    2362:	03 c0       	rjmp	.+6      	; 0x236a <ISPCC_ProgramChip+0x128>
    2364:	8d 2d       	mov	r24, r13
    2366:	8f 78       	andi	r24, 0x8F	; 143
    2368:	80 61       	ori	r24, 0x10	; 16
    236a:	be 01       	movw	r22, r28
    236c:	0e 94 d6 10 	call	0x21ac	; 0x21ac <ISPCC_PollForProgComplete>
    2370:	59 c0       	rjmp	.+178    	; 0x2424 <ISPCC_ProgramChip+0x1e2>
    2372:	f4 01       	movw	r30, r8
    2374:	10 81       	ld	r17, Z
    2376:	80 91 4b 01 	lds	r24, 0x014B
    237a:	83 31       	cpi	r24, 0x13	; 19
    237c:	39 f4       	brne	.+14     	; 0x238c <ISPCC_ProgramChip+0x14a>
    237e:	e0 fe       	sbrs	r14, 0
    2380:	02 c0       	rjmp	.+4      	; 0x2386 <ISPCC_ProgramChip+0x144>
    2382:	88 e0       	ldi	r24, 0x08	; 8
    2384:	01 c0       	rjmp	.+2      	; 0x2388 <ISPCC_ProgramChip+0x146>
    2386:	80 e0       	ldi	r24, 0x00	; 0
    2388:	8c 29       	or	r24, r12
    238a:	01 c0       	rjmp	.+2      	; 0x238e <ISPCC_ProgramChip+0x14c>
    238c:	8c 2d       	mov	r24, r12
    238e:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    2392:	80 91 63 02 	lds	r24, 0x0263
    2396:	90 91 64 02 	lds	r25, 0x0264
    239a:	0e 94 a4 09 	call	0x1348	; 0x1348 <USI_SPITransmitWord>
    239e:	81 2f       	mov	r24, r17
    23a0:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    23a4:	80 91 53 01 	lds	r24, 0x0153
    23a8:	81 17       	cp	r24, r17
    23aa:	b9 f0       	breq	.+46     	; 0x23da <ISPCC_ProgramChip+0x198>
    23ac:	80 91 4b 01 	lds	r24, 0x014B
    23b0:	83 31       	cpi	r24, 0x13	; 19
    23b2:	39 f0       	breq	.+14     	; 0x23c2 <ISPCC_ProgramChip+0x180>
    23b4:	85 31       	cpi	r24, 0x15	; 21
    23b6:	89 f4       	brne	.+34     	; 0x23da <ISPCC_ProgramChip+0x198>
    23b8:	80 91 54 01 	lds	r24, 0x0154
    23bc:	81 17       	cp	r24, r17
    23be:	61 f5       	brne	.+88     	; 0x2418 <ISPCC_ProgramChip+0x1d6>
    23c0:	0c c0       	rjmp	.+24     	; 0x23da <ISPCC_ProgramChip+0x198>
    23c2:	c0 91 63 02 	lds	r28, 0x0263
    23c6:	d0 91 64 02 	lds	r29, 0x0264
    23ca:	cc 0f       	add	r28, r28
    23cc:	dd 1f       	adc	r29, r29
    23ce:	c7 01       	movw	r24, r14
    23d0:	81 70       	andi	r24, 0x01	; 1
    23d2:	90 70       	andi	r25, 0x00	; 0
    23d4:	c8 0f       	add	r28, r24
    23d6:	d9 1f       	adc	r29, r25
    23d8:	23 c0       	rjmp	.+70     	; 0x2420 <ISPCC_ProgramChip+0x1de>
    23da:	1d 2d       	mov	r17, r13
    23dc:	11 7f       	andi	r17, 0xF1	; 241
    23de:	12 60       	ori	r17, 0x02	; 2
    23e0:	e0 fc       	sbrc	r14, 0
    23e2:	04 c0       	rjmp	.+8      	; 0x23ec <ISPCC_ProgramChip+0x1aa>
    23e4:	80 91 4b 01 	lds	r24, 0x014B
    23e8:	85 31       	cpi	r24, 0x15	; 21
    23ea:	11 f4       	brne	.+4      	; 0x23f0 <ISPCC_ProgramChip+0x1ae>
    23ec:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <V2P_IncrementCurrAddress>
    23f0:	be 01       	movw	r22, r28
    23f2:	81 2f       	mov	r24, r17
    23f4:	0e 94 d6 10 	call	0x21ac	; 0x21ac <ISPCC_PollForProgComplete>
    23f8:	08 94       	sec
    23fa:	e1 1c       	adc	r14, r1
    23fc:	f1 1c       	adc	r15, r1
    23fe:	08 94       	sec
    2400:	81 1c       	adc	r8, r1
    2402:	91 1c       	adc	r9, r1
    2404:	ea 14       	cp	r14, r10
    2406:	fb 04       	cpc	r15, r11
    2408:	09 f0       	breq	.+2      	; 0x240c <ISPCC_ProgramChip+0x1ca>
    240a:	b3 cf       	rjmp	.-154    	; 0x2372 <ISPCC_ProgramChip+0x130>
    240c:	0b c0       	rjmp	.+22     	; 0x2424 <ISPCC_ProgramChip+0x1e2>
    240e:	c0 91 63 02 	lds	r28, 0x0263
    2412:	d0 91 64 02 	lds	r29, 0x0264
    2416:	85 cf       	rjmp	.-246    	; 0x2322 <ISPCC_ProgramChip+0xe0>
    2418:	c0 91 63 02 	lds	r28, 0x0263
    241c:	d0 91 64 02 	lds	r29, 0x0264
    2420:	1d 2d       	mov	r17, r13
    2422:	de cf       	rjmp	.-68     	; 0x23e0 <ISPCC_ProgramChip+0x19e>
    2424:	df 91       	pop	r29
    2426:	cf 91       	pop	r28
    2428:	1f 91       	pop	r17
    242a:	0f 91       	pop	r16
    242c:	ff 90       	pop	r15
    242e:	ef 90       	pop	r14
    2430:	df 90       	pop	r13
    2432:	cf 90       	pop	r12
    2434:	bf 90       	pop	r11
    2436:	af 90       	pop	r10
    2438:	9f 90       	pop	r9
    243a:	8f 90       	pop	r8
    243c:	7f 90       	pop	r7
    243e:	6f 90       	pop	r6
    2440:	5f 90       	pop	r5
    2442:	4f 90       	pop	r4
    2444:	08 95       	ret

00002446 <ISPCC_EnterChipProgrammingMode>:
    2446:	ff 92       	push	r15
    2448:	0f 93       	push	r16
    244a:	1f 93       	push	r17
    244c:	00 91 50 01 	lds	r16, 0x0150
    2450:	10 91 4f 01 	lds	r17, 0x014F
    2454:	81 b3       	in	r24, 0x11	; 17
    2456:	8f 7c       	andi	r24, 0xCF	; 207
    2458:	80 63       	ori	r24, 0x30	; 48
    245a:	81 bb       	out	0x11, r24	; 17
    245c:	80 91 4d 01 	lds	r24, 0x014D
    2460:	0e 94 47 02 	call	0x48e	; 0x48e <MAIN_Delay1MS>
    2464:	81 2f       	mov	r24, r17
    2466:	81 50       	subi	r24, 0x01	; 1
    2468:	84 36       	cpi	r24, 0x64	; 100
    246a:	08 f4       	brcc	.+2      	; 0x246e <ISPCC_EnterChipProgrammingMode+0x28>
    246c:	40 c0       	rjmp	.+128    	; 0x24ee <ISPCC_EnterChipProgrammingMode+0xa8>
    246e:	18 e1       	ldi	r17, 0x18	; 24
    2470:	3e c0       	rjmp	.+124    	; 0x24ee <ISPCC_EnterChipProgrammingMode+0xa8>
    2472:	80 91 53 01 	lds	r24, 0x0153
    2476:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    247a:	80 2f       	mov	r24, r16
    247c:	0e 94 47 02 	call	0x48e	; 0x48e <MAIN_Delay1MS>
    2480:	80 91 54 01 	lds	r24, 0x0154
    2484:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    2488:	80 2f       	mov	r24, r16
    248a:	0e 94 47 02 	call	0x48e	; 0x48e <MAIN_Delay1MS>
    248e:	80 91 55 01 	lds	r24, 0x0155
    2492:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    2496:	f8 2e       	mov	r15, r24
    2498:	80 2f       	mov	r24, r16
    249a:	0e 94 47 02 	call	0x48e	; 0x48e <MAIN_Delay1MS>
    249e:	80 91 52 01 	lds	r24, 0x0152
    24a2:	83 30       	cpi	r24, 0x03	; 3
    24a4:	29 f4       	brne	.+10     	; 0x24b0 <ISPCC_EnterChipProgrammingMode+0x6a>
    24a6:	80 91 56 01 	lds	r24, 0x0156
    24aa:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    24ae:	05 c0       	rjmp	.+10     	; 0x24ba <ISPCC_EnterChipProgrammingMode+0x74>
    24b0:	80 91 56 01 	lds	r24, 0x0156
    24b4:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    24b8:	f8 2e       	mov	r15, r24
    24ba:	80 91 52 01 	lds	r24, 0x0152
    24be:	88 23       	and	r24, r24
    24c0:	21 f0       	breq	.+8      	; 0x24ca <ISPCC_EnterChipProgrammingMode+0x84>
    24c2:	80 91 51 01 	lds	r24, 0x0151
    24c6:	f8 16       	cp	r15, r24
    24c8:	69 f4       	brne	.+26     	; 0x24e4 <ISPCC_EnterChipProgrammingMode+0x9e>
    24ca:	80 2f       	mov	r24, r16
    24cc:	0e 94 47 02 	call	0x48e	; 0x48e <MAIN_Delay1MS>
    24d0:	81 e0       	ldi	r24, 0x01	; 1
    24d2:	80 93 62 02 	sts	0x0262, r24
    24d6:	81 b3       	in	r24, 0x11	; 17
    24d8:	8f 7c       	andi	r24, 0xCF	; 207
    24da:	80 62       	ori	r24, 0x20	; 32
    24dc:	81 bb       	out	0x11, r24	; 17
    24de:	10 92 4c 01 	sts	0x014C, r1
    24e2:	0e c0       	rjmp	.+28     	; 0x2500 <ISPCC_EnterChipProgrammingMode+0xba>
    24e4:	80 2f       	mov	r24, r16
    24e6:	0e 94 47 02 	call	0x48e	; 0x48e <MAIN_Delay1MS>
    24ea:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <USI_SPIToggleClock>
    24ee:	11 50       	subi	r17, 0x01	; 1
    24f0:	00 f6       	brcc	.-128    	; 0x2472 <ISPCC_EnterChipProgrammingMode+0x2c>
    24f2:	81 b3       	in	r24, 0x11	; 17
    24f4:	8f 7c       	andi	r24, 0xCF	; 207
    24f6:	80 61       	ori	r24, 0x10	; 16
    24f8:	81 bb       	out	0x11, r24	; 17
    24fa:	80 ec       	ldi	r24, 0xC0	; 192
    24fc:	80 93 4c 01 	sts	0x014C, r24
    2500:	1f 91       	pop	r17
    2502:	0f 91       	pop	r16
    2504:	ff 90       	pop	r15
    2506:	08 95       	ret

00002508 <AICI_InterpretPacket>:

// ======================================================================================

void AICI_InterpretPacket(void)
{
    2508:	df 92       	push	r13
    250a:	ef 92       	push	r14
    250c:	ff 92       	push	r15
    250e:	0f 93       	push	r16
    2510:	1f 93       	push	r17
    2512:	cf 93       	push	r28
    2514:	df 93       	push	r29
	switch (PacketBytes[0])
    2516:	80 91 4b 01 	lds	r24, 0x014B
    251a:	86 31       	cpi	r24, 0x16	; 22
    251c:	09 f4       	brne	.+2      	; 0x2520 <AICI_InterpretPacket+0x18>
    251e:	ea c0       	rjmp	.+468    	; 0x26f4 <AICI_InterpretPacket+0x1ec>
    2520:	87 31       	cpi	r24, 0x17	; 23
    2522:	78 f4       	brcc	.+30     	; 0x2542 <AICI_InterpretPacket+0x3a>
    2524:	82 31       	cpi	r24, 0x12	; 18
    2526:	09 f4       	brne	.+2      	; 0x252a <AICI_InterpretPacket+0x22>
    2528:	57 c0       	rjmp	.+174    	; 0x25d8 <AICI_InterpretPacket+0xd0>
    252a:	83 31       	cpi	r24, 0x13	; 19
    252c:	30 f4       	brcc	.+12     	; 0x253a <AICI_InterpretPacket+0x32>
    252e:	80 31       	cpi	r24, 0x10	; 16
    2530:	d9 f0       	breq	.+54     	; 0x2568 <AICI_InterpretPacket+0x60>
    2532:	81 31       	cpi	r24, 0x11	; 17
    2534:	09 f0       	breq	.+2      	; 0x2538 <AICI_InterpretPacket+0x30>
    2536:	31 c1       	rjmp	.+610    	; 0x279a <AICI_InterpretPacket+0x292>
    2538:	35 c0       	rjmp	.+106    	; 0x25a4 <AICI_InterpretPacket+0x9c>
    253a:	84 31       	cpi	r24, 0x14	; 20
    253c:	09 f0       	breq	.+2      	; 0x2540 <AICI_InterpretPacket+0x38>
    253e:	22 c1       	rjmp	.+580    	; 0x2784 <AICI_InterpretPacket+0x27c>
    2540:	d9 c0       	rjmp	.+434    	; 0x26f4 <AICI_InterpretPacket+0x1ec>
    2542:	89 31       	cpi	r24, 0x19	; 25
    2544:	09 f4       	brne	.+2      	; 0x2548 <AICI_InterpretPacket+0x40>
    2546:	c2 c0       	rjmp	.+388    	; 0x26cc <AICI_InterpretPacket+0x1c4>
    2548:	8a 31       	cpi	r24, 0x1A	; 26
    254a:	38 f4       	brcc	.+14     	; 0x255a <AICI_InterpretPacket+0x52>
    254c:	87 31       	cpi	r24, 0x17	; 23
    254e:	09 f4       	brne	.+2      	; 0x2552 <AICI_InterpretPacket+0x4a>
    2550:	bd c0       	rjmp	.+378    	; 0x26cc <AICI_InterpretPacket+0x1c4>
    2552:	88 31       	cpi	r24, 0x18	; 24
    2554:	09 f0       	breq	.+2      	; 0x2558 <AICI_InterpretPacket+0x50>
    2556:	21 c1       	rjmp	.+578    	; 0x279a <AICI_InterpretPacket+0x292>
    2558:	9a c0       	rjmp	.+308    	; 0x268e <AICI_InterpretPacket+0x186>
    255a:	8d 31       	cpi	r24, 0x1D	; 29
    255c:	08 f4       	brcc	.+2      	; 0x2560 <AICI_InterpretPacket+0x58>
    255e:	97 c0       	rjmp	.+302    	; 0x268e <AICI_InterpretPacket+0x186>
    2560:	8d 31       	cpi	r24, 0x1D	; 29
    2562:	09 f0       	breq	.+2      	; 0x2566 <AICI_InterpretPacket+0x5e>
    2564:	1a c1       	rjmp	.+564    	; 0x279a <AICI_InterpretPacket+0x292>
    2566:	5b c0       	rjmp	.+182    	; 0x261e <AICI_InterpretPacket+0x116>
	{
		case AICB_CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
    2568:	82 e0       	ldi	r24, 0x02	; 2
    256a:	90 e0       	ldi	r25, 0x00	; 0
    256c:	90 93 61 02 	sts	0x0261, r25
    2570:	80 93 60 02 	sts	0x0260, r24
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2574:	a2 e0       	ldi	r26, 0x02	; 2
    2576:	b0 e0       	ldi	r27, 0x00	; 0
    2578:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
    257c:	80 2d       	mov	r24, r0
			
			USI_SPIInitMaster(eeprom_read_byte(&EEPROMVars.SCKDuration));
    257e:	0e 94 cc 09 	call	0x1398	; 0x1398 <USI_SPIInitMaster>

			MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);  // Pull the slave AVR's RESET line to active
    2582:	80 e0       	ldi	r24, 0x00	; 0
    2584:	0e 94 51 02 	call	0x4a2	; 0x4a2 <MAIN_ResetCSLine>
			ISPCC_EnterChipProgrammingMode();       // Run the Enter Programming Mode routine
    2588:	0e 94 23 12 	call	0x2446	; 0x2446 <ISPCC_EnterChipProgrammingMode>

			if (InProgrammingMode)
    258c:	80 91 62 02 	lds	r24, 0x0262
    2590:	88 23       	and	r24, r24
    2592:	19 f0       	breq	.+6      	; 0x259a <AICI_InterpretPacket+0x92>
			   LCD_puts_f(AVRISPModeMessage);
    2594:	8b e0       	ldi	r24, 0x0B	; 11
    2596:	94 e0       	ldi	r25, 0x04	; 4
    2598:	02 c0       	rjmp	.+4      	; 0x259e <AICI_InterpretPacket+0x96>
			else
			   LCD_puts_f(SyncErrorMessage);
    259a:	80 e0       	ldi	r24, 0x00	; 0
    259c:	94 e0       	ldi	r25, 0x04	; 4
    259e:	0e 94 02 09 	call	0x1204	; 0x1204 <LCD_puts_f>
    25a2:	04 c1       	rjmp	.+520    	; 0x27ac <AICI_InterpretPacket+0x2a4>
			
			break;
		case AICB_CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;
    25a4:	82 e0       	ldi	r24, 0x02	; 2
    25a6:	90 e0       	ldi	r25, 0x00	; 0
    25a8:	90 93 61 02 	sts	0x0261, r25
    25ac:	80 93 60 02 	sts	0x0260, r24

			MAIN_Delay1MS(PacketBytes[1]);           // Wait for the "PreDelay" amount specified in the packet
    25b0:	80 91 4c 01 	lds	r24, 0x014C
    25b4:	0e 94 47 02 	call	0x48e	; 0x48e <MAIN_Delay1MS>
			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Non programming mode = green status led
    25b8:	81 b3       	in	r24, 0x11	; 17
    25ba:	8f 7c       	andi	r24, 0xCF	; 207
    25bc:	80 61       	ori	r24, 0x10	; 16
    25be:	81 bb       	out	0x11, r24	; 17
			InProgrammingMode = FALSE;
    25c0:	10 92 62 02 	sts	0x0262, r1
			MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run
    25c4:	81 e0       	ldi	r24, 0x01	; 1
    25c6:	0e 94 51 02 	call	0x4a2	; 0x4a2 <MAIN_ResetCSLine>
			MAIN_Delay1MS(PacketBytes[2]);           // Wait for the "PostDelay" amount specified in the packet
    25ca:	80 91 4d 01 	lds	r24, 0x014D
    25ce:	0e 94 47 02 	call	0x48e	; 0x48e <MAIN_Delay1MS>
			
			USI_SPIOff();
    25d2:	0e 94 87 09 	call	0x130e	; 0x130e <USI_SPIOff>
    25d6:	de c0       	rjmp	.+444    	; 0x2794 <AICI_InterpretPacket+0x28c>

			PacketBytes[1] = AICB_STATUS_CMD_OK;     // Return OK

			break;
		case AICB_CMD_CHIP_ERASE_ISP:
			MessageSize = 2;
    25d8:	82 e0       	ldi	r24, 0x02	; 2
    25da:	90 e0       	ldi	r25, 0x00	; 0
    25dc:	90 93 61 02 	sts	0x0261, r25
    25e0:	80 93 60 02 	sts	0x0260, r24
    25e4:	ce e4       	ldi	r28, 0x4E	; 78
    25e6:	d1 e0       	ldi	r29, 0x01	; 1
			
			for (uint8_t PacketB = 3; PacketB <= 6; PacketB++) // Send the erase commands to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    25e8:	89 91       	ld	r24, Y+
    25ea:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    25ee:	81 e0       	ldi	r24, 0x01	; 1
    25f0:	c2 35       	cpi	r28, 0x52	; 82
    25f2:	d8 07       	cpc	r29, r24
    25f4:	c9 f7       	brne	.-14     	; 0x25e8 <AICI_InterpretPacket+0xe0>

			if (PacketBytes[2])                       // Poll mode, value of 1 indicates a busy flag wait
    25f6:	80 91 4d 01 	lds	r24, 0x014D
    25fa:	88 23       	and	r24, r24
    25fc:	59 f0       	breq	.+22     	; 0x2614 <AICI_InterpretPacket+0x10c>
			{
				do
					USI_SPITransmitWord(0xF000);
    25fe:	80 e0       	ldi	r24, 0x00	; 0
    2600:	90 ef       	ldi	r25, 0xF0	; 240
    2602:	0e 94 a4 09 	call	0x1348	; 0x1348 <USI_SPITransmitWord>
				while (USI_SPITransmitWord(0x0000) & 0x01);
    2606:	80 e0       	ldi	r24, 0x00	; 0
    2608:	90 e0       	ldi	r25, 0x00	; 0
    260a:	0e 94 a4 09 	call	0x1348	; 0x1348 <USI_SPITransmitWord>
    260e:	80 ff       	sbrs	r24, 0
    2610:	c1 c0       	rjmp	.+386    	; 0x2794 <AICI_InterpretPacket+0x28c>
    2612:	f5 cf       	rjmp	.-22     	; 0x25fe <AICI_InterpretPacket+0xf6>
			}
			else                                      // Poll mode flag of 0 indicates a predefined delay
			{
				MAIN_Delay1MS(PacketBytes[1]);         // Wait the specified interval to ensure erase complete
    2614:	80 91 4c 01 	lds	r24, 0x014C
    2618:	0e 94 47 02 	call	0x48e	; 0x48e <MAIN_Delay1MS>
    261c:	bb c0       	rjmp	.+374    	; 0x2794 <AICI_InterpretPacket+0x28c>
			}
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Always return OK
			
			break;
		case AICB_CMD_SPI_MULTI:
				MessageSize = (3 + PacketBytes[2]);    // Number of recieved bytes, plus two OKs and the command byte
    261e:	f0 90 4d 01 	lds	r15, 0x014D
    2622:	8f 2d       	mov	r24, r15
    2624:	99 27       	eor	r25, r25
    2626:	03 96       	adiw	r24, 0x03	; 3
    2628:	90 93 61 02 	sts	0x0261, r25
    262c:	80 93 60 02 	sts	0x0260, r24
		
				uint8_t TxBytes      = PacketBytes[1]; // \. The packet data is overwritten during the transfer. Because
    2630:	d0 90 4c 01 	lds	r13, 0x014C
				uint8_t RxStartByte  = PacketBytes[2]; // |  of this each data byte must be stored into temp variables
				uint8_t RxBytes      = PacketBytes[3]; // /  so that their contents are not lost.
    2634:	e0 90 4e 01 	lds	r14, 0x014E
    2638:	11 e0       	ldi	r17, 0x01	; 1
    263a:	01 e0       	ldi	r16, 0x01	; 1
    263c:	12 c0       	rjmp	.+36     	; 0x2662 <AICI_InterpretPacket+0x15a>
				uint8_t RxByteNum    = 1;
				uint8_t TxByteNum    = 1;
				uint8_t RecievedByte = 0;

				while (TxByteNum++ < TxBytes)          // Still bytes to transfer
    263e:	0f 5f       	subi	r16, 0xFF	; 255
				{
					RecievedByte = USI_SPITransmit(PacketBytes[3 + TxByteNum]); // Transmit the byte, store the answer
    2640:	e0 2f       	mov	r30, r16
    2642:	ff 27       	eor	r31, r31
    2644:	e5 5b       	subi	r30, 0xB5	; 181
    2646:	fe 4f       	sbci	r31, 0xFE	; 254
    2648:	83 81       	ldd	r24, Z+3	; 0x03
    264a:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>

					if ((TxByteNum >= RxStartByte) && (RxByteNum < RxBytes))
    264e:	0f 15       	cp	r16, r15
    2650:	40 f0       	brcs	.+16     	; 0x2662 <AICI_InterpretPacket+0x15a>
    2652:	1e 15       	cp	r17, r14
    2654:	30 f4       	brcc	.+12     	; 0x2662 <AICI_InterpretPacket+0x15a>
					   PacketBytes[2 + RxByteNum++] = RecievedByte;
    2656:	e1 2f       	mov	r30, r17
    2658:	ff 27       	eor	r31, r31
    265a:	e5 5b       	subi	r30, 0xB5	; 181
    265c:	fe 4f       	sbci	r31, 0xFE	; 254
    265e:	82 83       	std	Z+2, r24	; 0x02
    2660:	1f 5f       	subi	r17, 0xFF	; 255
    2662:	0d 15       	cp	r16, r13
    2664:	60 f3       	brcs	.-40     	; 0x263e <AICI_InterpretPacket+0x136>
    2666:	06 c0       	rjmp	.+12     	; 0x2674 <AICI_InterpretPacket+0x16c>
				}

				while (RxByteNum++ < RxBytes)                         // Still more bytes to recieve
				   PacketBytes[2 + RxByteNum] = USI_SPITransmit(0x00); // its answer to be recorded (or more bytes than sent need responses), send dummy bytes to fetch the response(s)
    2668:	80 e0       	ldi	r24, 0x00	; 0
    266a:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    266e:	c5 5b       	subi	r28, 0xB5	; 181
    2670:	de 4f       	sbci	r29, 0xFE	; 254
    2672:	8a 83       	std	Y+2, r24	; 0x02
    2674:	1f 5f       	subi	r17, 0xFF	; 255
    2676:	81 2f       	mov	r24, r17
    2678:	81 50       	subi	r24, 0x01	; 1
    267a:	c1 2f       	mov	r28, r17
    267c:	dd 27       	eor	r29, r29
    267e:	8e 15       	cp	r24, r14
    2680:	98 f3       	brcs	.-26     	; 0x2668 <AICI_InterpretPacket+0x160>

				PacketBytes[1]             = AICB_STATUS_CMD_OK; // Data should be encompassed
    2682:	10 92 4c 01 	sts	0x014C, r1
				PacketBytes[3 + RxByteNum] = AICB_STATUS_CMD_OK; //  by STATS_CMD_OKs
    2686:	c5 5b       	subi	r28, 0xB5	; 181
    2688:	de 4f       	sbci	r29, 0xFE	; 254
    268a:	1b 82       	std	Y+3, r1	; 0x03
    268c:	8f c0       	rjmp	.+286    	; 0x27ac <AICI_InterpretPacket+0x2a4>

				break;
		case AICB_CMD_READ_SIGNATURE_ISP:
		case AICB_CMD_READ_FUSE_ISP:
		case AICB_CMD_READ_LOCK_ISP:
		case AICB_CMD_READ_OSCCAL_ISP:
			MessageSize = 4;
    268e:	84 e0       	ldi	r24, 0x04	; 4
    2690:	90 e0       	ldi	r25, 0x00	; 0
    2692:	90 93 61 02 	sts	0x0261, r25
    2696:	80 93 60 02 	sts	0x0260, r24
    269a:	c1 e0       	ldi	r28, 0x01	; 1
    269c:	d0 e0       	ldi	r29, 0x00	; 0
    269e:	0d e4       	ldi	r16, 0x4D	; 77
    26a0:	11 e0       	ldi	r17, 0x01	; 1
	
			for (uint8_t ByteNum = 1; ByteNum <= 4; ByteNum++)
			{
				uint8_t Response = USI_SPITransmit(PacketBytes[1 + ByteNum]); // Transmit the four signature request bytes
    26a2:	f8 01       	movw	r30, r16
    26a4:	81 91       	ld	r24, Z+
    26a6:	8f 01       	movw	r16, r30
    26a8:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    26ac:	98 2f       	mov	r25, r24

				if (ByteNum == PacketBytes[1])         // If the current byte is the requested signature byte, save the reponse in the packet
    26ae:	80 91 4c 01 	lds	r24, 0x014C
    26b2:	8c 17       	cp	r24, r28
    26b4:	11 f4       	brne	.+4      	; 0x26ba <AICI_InterpretPacket+0x1b2>
					PacketBytes[2] = Response;
    26b6:	90 93 4d 01 	sts	0x014D, r25
    26ba:	21 96       	adiw	r28, 0x01	; 1
    26bc:	c5 30       	cpi	r28, 0x05	; 5
    26be:	d1 05       	cpc	r29, r1
    26c0:	81 f7       	brne	.-32     	; 0x26a2 <AICI_InterpretPacket+0x19a>
			}

			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Data byte is encased in CMD_OKs
    26c2:	10 92 4c 01 	sts	0x014C, r1
			PacketBytes[3] = AICB_STATUS_CMD_OK;       // Data byte is encased in CMD_OKs
    26c6:	10 92 4e 01 	sts	0x014E, r1
    26ca:	70 c0       	rjmp	.+224    	; 0x27ac <AICI_InterpretPacket+0x2a4>

			break;
		case AICB_CMD_PROGRAM_FUSE_ISP:
		case AICB_CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;
    26cc:	83 e0       	ldi	r24, 0x03	; 3
    26ce:	90 e0       	ldi	r25, 0x00	; 0
    26d0:	90 93 61 02 	sts	0x0261, r25
    26d4:	80 93 60 02 	sts	0x0260, r24
    26d8:	cc e4       	ldi	r28, 0x4C	; 76
    26da:	d1 e0       	ldi	r29, 0x01	; 1
			
			for (uint8_t PacketB = 1; PacketB <= 4; PacketB++) // Send the lock-byte values to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    26dc:	89 91       	ld	r24, Y+
    26de:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    26e2:	f1 e0       	ldi	r31, 0x01	; 1
    26e4:	c0 35       	cpi	r28, 0x50	; 80
    26e6:	df 07       	cpc	r29, r31
    26e8:	c9 f7       	brne	.-14     	; 0x26dc <AICI_InterpretPacket+0x1d4>

			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Two CMD_OKs are always returned
    26ea:	10 92 4c 01 	sts	0x014C, r1
			PacketBytes[2] = AICB_STATUS_CMD_OK;       // Two CMD_OKs are always returned
    26ee:	10 92 4d 01 	sts	0x014D, r1
    26f2:	5c c0       	rjmp	.+184    	; 0x27ac <AICI_InterpretPacket+0x2a4>

			break;
		case AICB_CMD_READ_FLASH_ISP:
		case AICB_CMD_READ_EEPROM_ISP:
			MessageSize = 0;                           // Here to prevent compiler from complaining if a var dec appears straight after a case

			uint8_t  ReadCommand = PacketBytes[3];
    26f4:	d0 90 4e 01 	lds	r13, 0x014E
			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8) // Load in the number of bytes that is to
			                     | PacketBytes[2];                 // be read into a temp variable (MSB first)
    26f8:	80 91 4c 01 	lds	r24, 0x014C
    26fc:	99 27       	eor	r25, r25
    26fe:	d8 2f       	mov	r29, r24
    2700:	cc 27       	eor	r28, r28
    2702:	80 91 4d 01 	lds	r24, 0x014D
    2706:	99 27       	eor	r25, r25
    2708:	c8 2b       	or	r28, r24
    270a:	d9 2b       	or	r29, r25

			MessageSize = BytesToRead + 3;
    270c:	23 96       	adiw	r28, 0x03	; 3
    270e:	d0 93 61 02 	sts	0x0261, r29
    2712:	c0 93 60 02 	sts	0x0260, r28
    2716:	23 97       	sbiw	r28, 0x03	; 3
    2718:	00 e0       	ldi	r16, 0x00	; 0
    271a:	10 e0       	ldi	r17, 0x00	; 0
    271c:	8d e4       	ldi	r24, 0x4D	; 77
    271e:	e8 2e       	mov	r14, r24
    2720:	81 e0       	ldi	r24, 0x01	; 1
    2722:	f8 2e       	mov	r15, r24
    2724:	26 c0       	rjmp	.+76     	; 0x2772 <AICI_InterpretPacket+0x26a>

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
				if (PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)  // Flash read mode - word addresses so MSB/LSB masking nessesary
    2726:	80 91 4b 01 	lds	r24, 0x014B
    272a:	84 31       	cpi	r24, 0x14	; 20
    272c:	39 f4       	brne	.+14     	; 0x273c <AICI_InterpretPacket+0x234>
				{
					USI_SPITransmit(ReadCommand | ((ReadByte & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ));
    272e:	00 ff       	sbrs	r16, 0
    2730:	02 c0       	rjmp	.+4      	; 0x2736 <AICI_InterpretPacket+0x22e>
    2732:	88 e0       	ldi	r24, 0x08	; 8
    2734:	01 c0       	rjmp	.+2      	; 0x2738 <AICI_InterpretPacket+0x230>
    2736:	80 e0       	ldi	r24, 0x00	; 0
    2738:	8d 29       	or	r24, r13
    273a:	01 c0       	rjmp	.+2      	; 0x273e <AICI_InterpretPacket+0x236>
				}
				else                                       // EEPROM read mode, address is in bytes and so no masking nessesary
				{
					USI_SPITransmit(ReadCommand);
    273c:	8d 2d       	mov	r24, r13
    273e:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
				}
				
				USI_SPITransmitWord(CurrAddress);          // Transmit the current address to the slave AVR
    2742:	80 91 63 02 	lds	r24, 0x0263
    2746:	90 91 64 02 	lds	r25, 0x0264
    274a:	0e 94 a4 09 	call	0x1348	; 0x1348 <USI_SPITransmitWord>

				PacketBytes[2 + ReadByte] = USI_SPITransmit(0x00); // Read in the byte stored at the requested location
    274e:	80 e0       	ldi	r24, 0x00	; 0
    2750:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    2754:	f7 01       	movw	r30, r14
    2756:	80 83       	st	Z, r24

				if ((ReadByte & 0x01) || (PacketBytes[0] == AICB_CMD_READ_EEPROM_ISP)) // Flash addresses are given in words; only increment on the odd byte if reading the flash.
    2758:	00 fd       	sbrc	r16, 0
    275a:	04 c0       	rjmp	.+8      	; 0x2764 <AICI_InterpretPacket+0x25c>
    275c:	80 91 4b 01 	lds	r24, 0x014B
    2760:	86 31       	cpi	r24, 0x16	; 22
    2762:	11 f4       	brne	.+4      	; 0x2768 <AICI_InterpretPacket+0x260>
				{
					V2P_IncrementCurrAddress();             // Increment the address counter
    2764:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <V2P_IncrementCurrAddress>
    2768:	0f 5f       	subi	r16, 0xFF	; 255
    276a:	1f 4f       	sbci	r17, 0xFF	; 255
    276c:	08 94       	sec
    276e:	e1 1c       	adc	r14, r1
    2770:	f1 1c       	adc	r15, r1
    2772:	0c 17       	cp	r16, r28
    2774:	1d 07       	cpc	r17, r29
    2776:	b9 f6       	brne	.-82     	; 0x2726 <AICI_InterpretPacket+0x21e>
				}
				else
				{
					if ((CurrAddress & 0x00FF0000) & !(CurrAddress & 0x0000FFFF))
					{
						CurrAddress |= (1UL << 31);        // Set MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
						V2P_CheckForExtendedAddress();
					}
				}
			}
			
			PacketBytes[1]               = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    2778:	10 92 4c 01 	sts	0x014C, r1
			PacketBytes[2 + BytesToRead] = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    277c:	c5 5b       	subi	r28, 0xB5	; 181
    277e:	de 4f       	sbci	r29, 0xFE	; 254
    2780:	1a 82       	std	Y+2, r1	; 0x02
    2782:	14 c0       	rjmp	.+40     	; 0x27ac <AICI_InterpretPacket+0x2a4>

			break;
		case AICB_CMD_PROGRAM_FLASH_ISP:
		case AICB_CMD_PROGRAM_EEPROM_ISP:
			ISPCC_ProgramChip();                          // Program the bytes into the chip
    2784:	0e 94 21 11 	call	0x2242	; 0x2242 <ISPCC_ProgramChip>
			
			MessageSize = 2;
    2788:	82 e0       	ldi	r24, 0x02	; 2
    278a:	90 e0       	ldi	r25, 0x00	; 0
    278c:	90 93 61 02 	sts	0x0261, r25
    2790:	80 93 60 02 	sts	0x0260, r24

			PacketBytes[1] = AICB_STATUS_CMD_OK;
    2794:	10 92 4c 01 	sts	0x014C, r1
    2798:	09 c0       	rjmp	.+18     	; 0x27ac <AICI_InterpretPacket+0x2a4>
			
			break;
		default:                                        // Unknown command, return error
			MessageSize = 1;
    279a:	81 e0       	ldi	r24, 0x01	; 1
    279c:	90 e0       	ldi	r25, 0x00	; 0
    279e:	90 93 61 02 	sts	0x0261, r25
    27a2:	80 93 60 02 	sts	0x0260, r24
			
			PacketBytes[1] = AICB_STATUS_CMD_UNKNOWN;
    27a6:	89 ec       	ldi	r24, 0xC9	; 201
    27a8:	80 93 4c 01 	sts	0x014C, r24
	}

	V2P_SendPacket();                                   // Send the response packet
    27ac:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <V2P_SendPacket>
    27b0:	df 91       	pop	r29
    27b2:	cf 91       	pop	r28
    27b4:	1f 91       	pop	r17
    27b6:	0f 91       	pop	r16
    27b8:	ff 90       	pop	r15
    27ba:	ef 90       	pop	r14
    27bc:	df 90       	pop	r13
    27be:	08 95       	ret

000027c0 <PM_SetupDFAddressCounters>:
	return ProgDataSize;
}

void PM_SetupDFAddressCounters(const uint8_t Type)
{
    27c0:	80 93 68 02 	sts	0x0268, r24
	uint32_t StartAddress;
	
	MemoryType  = Type;
	GPageLength = 0;
    27c4:	10 92 6b 02 	sts	0x026B, r1
    27c8:	10 92 6a 02 	sts	0x026A, r1
    27cc:	20 91 63 02 	lds	r18, 0x0263
    27d0:	30 91 64 02 	lds	r19, 0x0264
    27d4:	40 91 65 02 	lds	r20, 0x0265
    27d8:	50 91 66 02 	lds	r21, 0x0266

	if (Type == TYPE_FLASH)                                              // Type 1 = Flash
    27dc:	81 30       	cpi	r24, 0x01	; 1
    27de:	39 f4       	brne	.+14     	; 0x27ee <PM_SetupDFAddressCounters+0x2e>
	  StartAddress = (CurrAddress << 1);                               // Convert flash word address to byte address
    27e0:	da 01       	movw	r26, r20
    27e2:	c9 01       	movw	r24, r18
    27e4:	88 0f       	add	r24, r24
    27e6:	99 1f       	adc	r25, r25
    27e8:	aa 1f       	adc	r26, r26
    27ea:	bb 1f       	adc	r27, r27
    27ec:	06 c0       	rjmp	.+12     	; 0x27fa <PM_SetupDFAddressCounters+0x3a>
	else
	  StartAddress = CurrAddress + PM_EEPROM_OFFSET;                   // EEPROM uses byte addresses, and starts at the 257th kilobyte in Dataflash
    27ee:	da 01       	movw	r26, r20
    27f0:	c9 01       	movw	r24, r18
    27f2:	80 50       	subi	r24, 0x00	; 0
    27f4:	9c 4f       	sbci	r25, 0xFC	; 252
    27f6:	ab 4f       	sbci	r26, 0xFB	; 251
    27f8:	bf 4f       	sbci	r27, 0xFF	; 255
	
	CurrPageAddress = 0;
    27fa:	10 92 3c 01 	sts	0x013C, r1
    27fe:	10 92 3b 01 	sts	0x013B, r1
    2802:	20 e0       	ldi	r18, 0x00	; 0
    2804:	30 e0       	ldi	r19, 0x00	; 0
    2806:	06 c0       	rjmp	.+12     	; 0x2814 <PM_SetupDFAddressCounters+0x54>

	while (StartAddress >= DF_INTERNALDF_BUFFBYTES)                      // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DF_INTERNALDF_BUFFBYTES;                         // Subtract one page's worth of bytes from the desired address
    2808:	88 50       	subi	r24, 0x08	; 8
    280a:	91 40       	sbci	r25, 0x01	; 1
    280c:	a0 40       	sbci	r26, 0x00	; 0
    280e:	b0 40       	sbci	r27, 0x00	; 0
    2810:	2f 5f       	subi	r18, 0xFF	; 255
    2812:	3f 4f       	sbci	r19, 0xFF	; 255
    2814:	88 30       	cpi	r24, 0x08	; 8
    2816:	41 e0       	ldi	r20, 0x01	; 1
    2818:	94 07       	cpc	r25, r20
    281a:	40 e0       	ldi	r20, 0x00	; 0
    281c:	a4 07       	cpc	r26, r20
    281e:	40 e0       	ldi	r20, 0x00	; 0
    2820:	b4 07       	cpc	r27, r20
    2822:	90 f7       	brcc	.-28     	; 0x2808 <PM_SetupDFAddressCounters+0x48>
    2824:	30 93 3c 01 	sts	0x013C, r19
    2828:	20 93 3b 01 	sts	0x013B, r18
		CurrPageAddress++;
	}
	
	CurrBuffByte = (uint16_t)StartAddress;                               // The buffer byte is the remainder
    282c:	90 93 3e 01 	sts	0x013E, r25
    2830:	80 93 3d 01 	sts	0x013D, r24
    2834:	08 95       	ret

00002836 <PM_CheckEndOfFuseLockData>:
}

void PM_StoreProgramByte(const uint8_t Data)
{
	if (CurrBuffByte == DF_INTERNALDF_BUFFBYTES)
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
		DF_BufferWriteEnable(0);
		CurrBuffByte = 0;
	}
	
	SPI_SPITransmit(Data);                                               // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
	CurrBuffByte++;
	GPageLength++;
}

void PM_InterpretAVRISPPacket(void)
{
	uint8_t* EEPROMAddress;

	switch (PacketBytes[0])
	{
		case AICB_CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
						
			for (uint8_t PacketB = 0; PacketB <= 11; PacketB++)          // Save the enter programming mode command bytes
			  eeprom_write_byte(&EEPROMVars.EnterProgMode[PacketB], PacketBytes[PacketB]);
			
			InProgrammingMode = TRUE;                                    // Set the flag, prevent the user from exiting the V2P state machine			
			CurrentMode = PM_NO_SETUP;                                   // Clear the current mode variable

			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = AICB_STATUS_CMD_OK;

			break;			
		case AICB_CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;

			PM_CheckEndOfFuseLockData();                                 // Check for remaining bytes to be stored and general cleanup
			
			InProgrammingMode = FALSE;                                   // Clear the flag, allow the user to exit the V2P state machine

			DF_EnableDataflash(FALSE);

			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
			PacketBytes[1] = AICB_STATUS_CMD_OK;

			break;
		case AICB_CMD_READ_SIGNATURE_ISP:
			MessageSize = 4;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                          // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x01;                                        // Signature bytes all return "01" in storage mode
			PacketBytes[3] = AICB_STATUS_CMD_OK;                          // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_CHIP_ERASE_ISP:
			MessageSize = 2;

			for (uint8_t PacketB = 1; PacketB <= 6; PacketB++)          // Save the erase chip command bytes to EEPROM
			  eeprom_write_byte(&EEPROMVars.EraseChip[PacketB], PacketBytes[PacketB]);

			for (uint8_t Byte = 0; Byte < 8; Byte++)                    // Clear the program and EEPROM size counters
			{
				eeprom_write_byte(&EEPROMVars.DataSize[Byte], 0x00);
				eeprom_write_byte(&EEPROMVars.EEPROMSize[Byte], 0x00);
			}
						
			eeprom_write_byte(&EEPROMVars.EraseCmdStored, TRUE);
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;
			
			break;
		case AICB_CMD_READ_OSCCAL_ISP:
			MessageSize = 4;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x00;                                      // Return 0x00 for the OSCCAL byte
			PacketBytes[3] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_READ_FUSE_ISP:
		case AICB_CMD_READ_LOCK_ISP:
			MessageSize = 4;
	
			if (CurrentMode != PM_LOCKFUSEBITS_READ)                    // First lock or fuse byte being read, set the EEPROM pointer
			{
				PM_CheckEndOfFuseLockData();                            // Check for remaining bytes to be stored and general cleanup
				
				CurrBuffByte = 0;
				CurrentMode  = PM_LOCKFUSEBITS_READ;
			}
			
			if (CurrBuffByte > eeprom_read_byte((PacketBytes[0] == AICB_CMD_READ_FUSE_ISP)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes))  // Trying to read more fuse/lock bytes than are stored in memory
			{
				PacketBytes[2] = 0xFF;                                 // Return 0xFF for the fuse/lock byte
			}
			else
			{
				PacketBytes[2] = eeprom_read_byte((uint8_t*)(((PacketBytes[0] == AICB_CMD_READ_FUSE_ISP)? &EEPROMVars.FuseBytes : &EEPROMVars.LockBytes) // Starting location
									                         + (CurrBuffByte << 2) + (PacketBytes[1] - 1)));                                             // The start position of the actual fuse/lock byte to read (4 bytes each));
			}

			PacketBytes[1] = AICB_STATUS_CMD_OK;                       // Data byte is encased in CMD_OKs
			PacketBytes[3] = AICB_STATUS_CMD_OK;                       // Data byte is encased in CMD_OKs

			CurrBuffByte++;

			break;
		case AICB_CMD_PROGRAM_FUSE_ISP:
		case AICB_CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;

			if (CurrentMode != PM_LOCKFUSEBITS_WRITE)                  // First lock or fuse byte being written, set the EEPROM pointer
			{
				CurrentMode   = PM_LOCKFUSEBITS_WRITE;
				CurrBuffByte  = 0;                                     // CurrBuffByte is used to store the total fuse/lock bytes written
			}

			if (PacketBytes[0] == AICB_CMD_PROGRAM_FUSE_ISP)
			{
				EEPROMAddress = (uint8_t*)(&EEPROMVars.FuseBytes + (CurrBuffByte << 2));
				MemoryType    = TYPE_FUSE;
			}
			else
			{
				EEPROMAddress = (uint8_t*)(&EEPROMVars.LockBytes + (CurrBuffByte << 2));
				MemoryType    = TYPE_LOCK;
			}				
			
			if (CurrBuffByte < PM_MAX_FUSELOCKBITS)
			{
				for (uint8_t FLByte = 1; FLByte <= 4; FLByte++)
				{
					eeprom_write_byte(EEPROMAddress, PacketBytes[FLByte]);
					EEPROMAddress++;
				}

				CurrBuffByte++;                                        // Increment the total fuse/lock bytes written counter
			}
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;                       // Two CMD_OKs are always returned
			PacketBytes[2] = AICB_STATUS_CMD_OK;                       // Two CMD_OKs are always returned

			break;
		case AICB_CMD_PROGRAM_FLASH_ISP:
		case AICB_CMD_PROGRAM_EEPROM_ISP:
			MessageSize = 2;

			if (CurrentMode != PM_DATAFLASH_WRITE)                      // First programming packet
			{
				if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP)       // Flash programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram; // Set the eeprom address to the Program command bytes location
					PM_SetupDFAddressCounters(TYPE_FLASH);
				}
				else                                                   // EEPROM programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;  // Set the eeprom address to the EEPROM command bytes location
					PM_SetupDFAddressCounters(TYPE_EEPROM);
				}
				
				DF_BufferWriteEnable(CurrBuffByte);
				CurrentMode = PM_DATAFLASH_WRITE;
				
				for (uint8_t B = 1; B <= 9; B++)                       // Save the command bytes
				  eeprom_write_byte(EEPROMAddress, PacketBytes[B]);
			}

			uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
			                      | PacketBytes[2];

			for (uint16_t CurrByte = 0; CurrByte < BytesToWrite; CurrByte++)
				PM_StoreProgramByte(PacketBytes[10 + CurrByte]);

			if (!(GPageLength & PM_PAGELENGTH_FOUNDBIT) && (PacketBytes[3] & ISPCC_PROG_MODE_PAGEDONE) && GPageLength)
			{
				eeprom_write_word(((MemoryType == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength), GPageLength);
		
				GPageLength |= PM_PAGELENGTH_FOUNDBIT;                 // Bit 15 is used to indicate if the length has been found
			}

			PacketBytes[1] = AICB_STATUS_CMD_OK;
		
			break;
		case AICB_CMD_READ_FLASH_ISP:
		case AICB_CMD_READ_EEPROM_ISP:	
			if (CurrentMode != PM_DATAFLASH_READ)
			{
				PM_CheckEndOfFuseLockData();                           // Check for remaining bytes to be stored and general cleanup
				
				PM_SetupDFAddressCounters((PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);
				DF_ContinuousReadEnable(CurrPageAddress, CurrBuffByte);
				
				CurrentMode = PM_DATAFLASH_READ;
				CurrAddress = 0;
			}

			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8)    // \. Load in the number of bytes that is to
			                     | PacketBytes[2];                    // /  be read into a temp variable (MSB first)
						
			uint16_t BytesInMem  = PM_GetStoredDataSize((PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
			   PacketBytes[2 + ReadByte] = ((CurrAddress < BytesInMem)? SPI_SPITransmit(0x00) : 0xFF); // Read in the next dataflash byte if present
			   V2P_IncrementCurrAddress();
			}
			
			MessageSize = BytesToRead + 3;

			PacketBytes[1]               = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
			PacketBytes[2 + BytesToRead] = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
		
			break;
		default:
			MessageSize = 1;
			
			PacketBytes[1] = AICB_STATUS_CMD_UNKNOWN;
	}

	V2P_SendPacket();                                   // Send the response packet
}

void PM_CheckEndOfFuseLockData(void)
{
    2836:	cf 93       	push	r28
    2838:	df 93       	push	r29
    283a:	cd b7       	in	r28, 0x3d	; 61
    283c:	de b7       	in	r29, 0x3e	; 62
    283e:	24 97       	sbiw	r28, 0x04	; 4
    2840:	0f b6       	in	r0, 0x3f	; 63
    2842:	f8 94       	cli
    2844:	de bf       	out	0x3e, r29	; 62
    2846:	0f be       	out	0x3f, r0	; 63
    2848:	cd bf       	out	0x3d, r28	; 61
	if (CurrentMode == PM_DATAFLASH_WRITE)
    284a:	80 91 69 02 	lds	r24, 0x0269
    284e:	81 30       	cpi	r24, 0x01	; 1
    2850:	09 f0       	breq	.+2      	; 0x2854 <PM_CheckEndOfFuseLockData+0x1e>
    2852:	40 c0       	rjmp	.+128    	; 0x28d4 <PM_CheckEndOfFuseLockData+0x9e>
	{
		if (CurrBuffByte)                               // Data in the dataflash buffer, pending to be written
    2854:	80 91 3d 01 	lds	r24, 0x013D
    2858:	90 91 3e 01 	lds	r25, 0x013E
    285c:	89 2b       	or	r24, r25
    285e:	31 f0       	breq	.+12     	; 0x286c <PM_CheckEndOfFuseLockData+0x36>
		  DF_CopyBufferToFlashPage(CurrPageAddress);    // Save the remaining buffer bytes
    2860:	80 91 3b 01 	lds	r24, 0x013B
    2864:	90 91 3c 01 	lds	r25, 0x013C
    2868:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <DF_CopyBufferToFlashPage>

		uint32_t DataSize = ((CurrPageAddress * DF_INTERNALDF_BUFFBYTES) + CurrBuffByte);
    286c:	20 91 3b 01 	lds	r18, 0x013B
    2870:	30 91 3c 01 	lds	r19, 0x013C
    2874:	88 e0       	ldi	r24, 0x08	; 8
    2876:	91 e0       	ldi	r25, 0x01	; 1
    2878:	ac 01       	movw	r20, r24
    287a:	24 9f       	mul	r18, r20
    287c:	c0 01       	movw	r24, r0
    287e:	25 9f       	mul	r18, r21
    2880:	90 0d       	add	r25, r0
    2882:	34 9f       	mul	r19, r20
    2884:	90 0d       	add	r25, r0
    2886:	11 24       	eor	r1, r1
    2888:	20 91 3d 01 	lds	r18, 0x013D
    288c:	30 91 3e 01 	lds	r19, 0x013E
    2890:	82 0f       	add	r24, r18
    2892:	93 1f       	adc	r25, r19
    2894:	9c 01       	movw	r18, r24
    2896:	44 27       	eor	r20, r20
    2898:	55 27       	eor	r21, r21
    289a:	29 83       	std	Y+1, r18	; 0x01
    289c:	3a 83       	std	Y+2, r19	; 0x02
    289e:	4b 83       	std	Y+3, r20	; 0x03
    28a0:	5c 83       	std	Y+4, r21	; 0x04

		if (MemoryType == TYPE_FLASH)
    28a2:	80 91 68 02 	lds	r24, 0x0268
    28a6:	fe 01       	movw	r30, r28
    28a8:	31 96       	adiw	r30, 0x01	; 1
    28aa:	81 30       	cpi	r24, 0x01	; 1
    28ac:	21 f4       	brne	.+8      	; 0x28b6 <PM_CheckEndOfFuseLockData+0x80>
            {
              uint8_t len;
              len = (uint8_t) n;

              asm volatile (
    28ae:	84 e0       	ldi	r24, 0x04	; 4
    28b0:	ac e1       	ldi	r26, 0x1C	; 28
    28b2:	b0 e0       	ldi	r27, 0x00	; 0
    28b4:	0b c0       	rjmp	.+22     	; 0x28cc <PM_CheckEndOfFuseLockData+0x96>
		{
			eeprom_write_block((const void*)&DataSize, (void*)&EEPROMVars.DataSize, sizeof(uint32_t));
		}
		else
		{
			DataSize -= PM_EEPROM_OFFSET;                // Remove DataFlash EEPROM start offset
    28b6:	20 50       	subi	r18, 0x00	; 0
    28b8:	34 40       	sbci	r19, 0x04	; 4
    28ba:	44 40       	sbci	r20, 0x04	; 4
    28bc:	50 40       	sbci	r21, 0x00	; 0
    28be:	29 83       	std	Y+1, r18	; 0x01
    28c0:	3a 83       	std	Y+2, r19	; 0x02
    28c2:	4b 83       	std	Y+3, r20	; 0x03
    28c4:	5c 83       	std	Y+4, r21	; 0x04
            {
              uint8_t len;
              len = (uint8_t) n;

              asm volatile (
    28c6:	84 e0       	ldi	r24, 0x04	; 4
    28c8:	a0 e2       	ldi	r26, 0x20	; 32
    28ca:	b0 e0       	ldi	r27, 0x00	; 0
    28cc:	18 2e       	mov	r1, r24
    28ce:	0e 94 47 1a 	call	0x348e	; 0x348e <__eeprom_write_block_1F2021>
    28d2:	12 c0       	rjmp	.+36     	; 0x28f8 <PM_CheckEndOfFuseLockData+0xc2>
			eeprom_write_block((const void*)&DataSize, (void*)&EEPROMVars.EEPROMSize, sizeof(uint32_t));
		}
	}
	else if (CurrentMode == PM_LOCKFUSEBITS_WRITE)
    28d4:	83 30       	cpi	r24, 0x03	; 3
    28d6:	81 f4       	brne	.+32     	; 0x28f8 <PM_CheckEndOfFuseLockData+0xc2>
	{
		// CurrBuffByte stores the total number of fuse/lock bytes written in this case:
		eeprom_write_byte(((MemoryType == TYPE_FUSE)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes), CurrBuffByte);
    28d8:	20 91 3d 01 	lds	r18, 0x013D
    28dc:	30 91 3e 01 	lds	r19, 0x013E
    28e0:	80 91 68 02 	lds	r24, 0x0268
    28e4:	82 30       	cpi	r24, 0x02	; 2
    28e6:	19 f4       	brne	.+6      	; 0x28ee <PM_CheckEndOfFuseLockData+0xb8>
    28e8:	a0 e3       	ldi	r26, 0x30	; 48
    28ea:	b0 e0       	ldi	r27, 0x00	; 0
    28ec:	02 c0       	rjmp	.+4      	; 0x28f2 <PM_CheckEndOfFuseLockData+0xbc>
    28ee:	a1 e3       	ldi	r26, 0x31	; 49
    28f0:	b0 e0       	ldi	r27, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    28f2:	02 2e       	mov	r0, r18
    28f4:	0e 94 36 1a 	call	0x346c	; 0x346c <__eeprom_write_byte_1F2021>
    28f8:	24 96       	adiw	r28, 0x04	; 4
    28fa:	0f b6       	in	r0, 0x3f	; 63
    28fc:	f8 94       	cli
    28fe:	de bf       	out	0x3e, r29	; 62
    2900:	0f be       	out	0x3f, r0	; 63
    2902:	cd bf       	out	0x3d, r28	; 61
    2904:	df 91       	pop	r29
    2906:	cf 91       	pop	r28
    2908:	08 95       	ret

0000290a <PM_GetStoredDataSize>:
    290a:	cf 93       	push	r28
    290c:	df 93       	push	r29
    290e:	cd b7       	in	r28, 0x3d	; 61
    2910:	de b7       	in	r29, 0x3e	; 62
    2912:	24 97       	sbiw	r28, 0x04	; 4
    2914:	0f b6       	in	r0, 0x3f	; 63
    2916:	f8 94       	cli
    2918:	de bf       	out	0x3e, r29	; 62
    291a:	0f be       	out	0x3f, r0	; 63
    291c:	cd bf       	out	0x3d, r28	; 61
    291e:	81 30       	cpi	r24, 0x01	; 1
    2920:	19 f4       	brne	.+6      	; 0x2928 <PM_GetStoredDataSize+0x1e>
    2922:	ac e1       	ldi	r26, 0x1C	; 28
    2924:	b0 e0       	ldi	r27, 0x00	; 0
    2926:	02 c0       	rjmp	.+4      	; 0x292c <PM_GetStoredDataSize+0x22>
    2928:	a0 e2       	ldi	r26, 0x20	; 32
    292a:	b0 e0       	ldi	r27, 0x00	; 0
    292c:	19 82       	std	Y+1, r1	; 0x01
    292e:	1a 82       	std	Y+2, r1	; 0x02
    2930:	1b 82       	std	Y+3, r1	; 0x03
    2932:	1c 82       	std	Y+4, r1	; 0x04
              /* Needed in order to truncate to 8 bit.  */
              uint8_t len;
              len = (uint8_t) n; 

              asm volatile (
    2934:	84 e0       	ldi	r24, 0x04	; 4
    2936:	fe 01       	movw	r30, r28
    2938:	31 96       	adiw	r30, 0x01	; 1
    293a:	18 2e       	mov	r1, r24
    293c:	0e 94 2c 1a 	call	0x3458	; 0x3458 <__eeprom_read_block_1F2021>
    2940:	89 81       	ldd	r24, Y+1	; 0x01
    2942:	9a 81       	ldd	r25, Y+2	; 0x02
    2944:	ab 81       	ldd	r26, Y+3	; 0x03
    2946:	bc 81       	ldd	r27, Y+4	; 0x04
    2948:	8f 5f       	subi	r24, 0xFF	; 255
    294a:	9f 4f       	sbci	r25, 0xFF	; 255
    294c:	af 4f       	sbci	r26, 0xFF	; 255
    294e:	bf 4f       	sbci	r27, 0xFF	; 255
    2950:	21 f4       	brne	.+8      	; 0x295a <PM_GetStoredDataSize+0x50>
    2952:	19 82       	std	Y+1, r1	; 0x01
    2954:	1a 82       	std	Y+2, r1	; 0x02
    2956:	1b 82       	std	Y+3, r1	; 0x03
    2958:	1c 82       	std	Y+4, r1	; 0x04
    295a:	69 81       	ldd	r22, Y+1	; 0x01
    295c:	7a 81       	ldd	r23, Y+2	; 0x02
    295e:	8b 81       	ldd	r24, Y+3	; 0x03
    2960:	9c 81       	ldd	r25, Y+4	; 0x04
    2962:	24 96       	adiw	r28, 0x04	; 4
    2964:	0f b6       	in	r0, 0x3f	; 63
    2966:	f8 94       	cli
    2968:	de bf       	out	0x3e, r29	; 62
    296a:	0f be       	out	0x3f, r0	; 63
    296c:	cd bf       	out	0x3d, r28	; 61
    296e:	df 91       	pop	r29
    2970:	cf 91       	pop	r28
    2972:	08 95       	ret

00002974 <PM_StoreProgramByte>:
    2974:	1f 93       	push	r17
    2976:	18 2f       	mov	r17, r24
    2978:	80 91 3d 01 	lds	r24, 0x013D
    297c:	90 91 3e 01 	lds	r25, 0x013E
    2980:	88 50       	subi	r24, 0x08	; 8
    2982:	91 40       	sbci	r25, 0x01	; 1
    2984:	a1 f4       	brne	.+40     	; 0x29ae <PM_StoreProgramByte+0x3a>
    2986:	80 91 3b 01 	lds	r24, 0x013B
    298a:	90 91 3c 01 	lds	r25, 0x013C
    298e:	01 96       	adiw	r24, 0x01	; 1
    2990:	90 93 3c 01 	sts	0x013C, r25
    2994:	80 93 3b 01 	sts	0x013B, r24
    2998:	01 97       	sbiw	r24, 0x01	; 1
    299a:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <DF_CopyBufferToFlashPage>
    299e:	80 e0       	ldi	r24, 0x00	; 0
    29a0:	90 e0       	ldi	r25, 0x00	; 0
    29a2:	0e 94 66 0a 	call	0x14cc	; 0x14cc <DF_BufferWriteEnable>
    29a6:	10 92 3e 01 	sts	0x013E, r1
    29aa:	10 92 3d 01 	sts	0x013D, r1
    29ae:	81 2f       	mov	r24, r17
    29b0:	0e 94 52 09 	call	0x12a4	; 0x12a4 <SPI_SPITransmit>
    29b4:	80 91 3d 01 	lds	r24, 0x013D
    29b8:	90 91 3e 01 	lds	r25, 0x013E
    29bc:	01 96       	adiw	r24, 0x01	; 1
    29be:	90 93 3e 01 	sts	0x013E, r25
    29c2:	80 93 3d 01 	sts	0x013D, r24
    29c6:	80 91 6a 02 	lds	r24, 0x026A
    29ca:	90 91 6b 02 	lds	r25, 0x026B
    29ce:	01 96       	adiw	r24, 0x01	; 1
    29d0:	90 93 6b 02 	sts	0x026B, r25
    29d4:	80 93 6a 02 	sts	0x026A, r24
    29d8:	1f 91       	pop	r17
    29da:	08 95       	ret

000029dc <PM_SendFuseLockBytes>:
	}
}

void PM_SendFuseLockBytes(const uint8_t Type)
{
    29dc:	ef 92       	push	r14
    29de:	ff 92       	push	r15
    29e0:	0f 93       	push	r16
    29e2:	1f 93       	push	r17
    29e4:	cf 93       	push	r28
    29e6:	df 93       	push	r29
	uint8_t* EEPROMAddress;
	uint8_t  TotalBytes;

	if (Type == TYPE_FUSE)
    29e8:	82 30       	cpi	r24, 0x02	; 2
    29ea:	59 f4       	brne	.+22     	; 0x2a02 <PM_SendFuseLockBytes+0x26>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    29ec:	40 e3       	ldi	r20, 0x30	; 48
    29ee:	50 e0       	ldi	r21, 0x00	; 0
    29f0:	da 01       	movw	r26, r20
    29f2:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
    29f6:	80 2d       	mov	r24, r0
	{
		TotalBytes    = eeprom_read_byte(&EEPROMVars.TotalFuseBytes);
    29f8:	18 2f       	mov	r17, r24
    29fa:	62 e0       	ldi	r22, 0x02	; 2
    29fc:	e6 2e       	mov	r14, r22
    29fe:	f1 2c       	mov	r15, r1
    2a00:	0a c0       	rjmp	.+20     	; 0x2a16 <PM_SendFuseLockBytes+0x3a>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2a02:	41 e3       	ldi	r20, 0x31	; 49
    2a04:	50 e0       	ldi	r21, 0x00	; 0
    2a06:	da 01       	movw	r26, r20
    2a08:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
    2a0c:	80 2d       	mov	r24, r0
		EEPROMAddress = EEPROMVars.FuseBytes;
	}
	else
	{
		TotalBytes    = eeprom_read_byte(&EEPROMVars.TotalLockBytes);
    2a0e:	18 2f       	mov	r17, r24
    2a10:	39 e2       	ldi	r19, 0x29	; 41
    2a12:	e3 2e       	mov	r14, r19
    2a14:	f1 2c       	mov	r15, r1
    2a16:	e4 0e       	add	r14, r20
    2a18:	f5 1e       	adc	r15, r21
    2a1a:	15 c0       	rjmp	.+42     	; 0x2a46 <PM_SendFuseLockBytes+0x6a>
    2a1c:	e7 01       	movw	r28, r14
    2a1e:	00 e0       	ldi	r16, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2a20:	de 01       	movw	r26, r28
    2a22:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
    2a26:	80 2d       	mov	r24, r0
		EEPROMAddress = EEPROMVars.LockBytes;	
	}

	while (TotalBytes--)                              // Write each of the fuse/lock bytes stored in memory to the slave AVR
	{
		for (uint8_t CommandByte = 0; CommandByte < 4; CommandByte++)      // Write each individual command byte
		{
			USI_SPITransmit(eeprom_read_byte(EEPROMAddress));
    2a28:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
			EEPROMAddress++;
    2a2c:	21 96       	adiw	r28, 0x01	; 1
    2a2e:	0f 5f       	subi	r16, 0xFF	; 255
    2a30:	04 30       	cpi	r16, 0x04	; 4
    2a32:	b1 f7       	brne	.-20     	; 0x2a20 <PM_SendFuseLockBytes+0x44>
    2a34:	84 e0       	ldi	r24, 0x04	; 4
    2a36:	90 e0       	ldi	r25, 0x00	; 0
    2a38:	e8 0e       	add	r14, r24
    2a3a:	f9 1e       	adc	r15, r25
		}
		
		// Add some delay before programming next byte, if there is one:
		if (TotalBytes)
    2a3c:	11 23       	and	r17, r17
    2a3e:	19 f0       	breq	.+6      	; 0x2a46 <PM_SendFuseLockBytes+0x6a>
		  MAIN_Delay10MS(5);
    2a40:	85 e0       	ldi	r24, 0x05	; 5
    2a42:	0e 94 3d 02 	call	0x47a	; 0x47a <MAIN_Delay10MS>
    2a46:	11 50       	subi	r17, 0x01	; 1
    2a48:	48 f7       	brcc	.-46     	; 0x2a1c <PM_SendFuseLockBytes+0x40>
    2a4a:	df 91       	pop	r29
    2a4c:	cf 91       	pop	r28
    2a4e:	1f 91       	pop	r17
    2a50:	0f 91       	pop	r16
    2a52:	ff 90       	pop	r15
    2a54:	ef 90       	pop	r14
    2a56:	08 95       	ret

00002a58 <PM_SendEraseCommand>:
	}
}

void PM_SendEraseCommand(void)
{			
    2a58:	cf 93       	push	r28
    2a5a:	df 93       	push	r29
    2a5c:	c8 e1       	ldi	r28, 0x18	; 24
    2a5e:	d0 e0       	ldi	r29, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2a60:	de 01       	movw	r26, r28
    2a62:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
    2a66:	80 2d       	mov	r24, r0
	for (uint8_t B = 2; B < 6 ; B++)                  // Read out the erase chip command bytes
	  USI_SPITransmit(eeprom_read_byte(&EEPROMVars.EraseChip[B])); // Send the erase chip commands
    2a68:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
    2a6c:	21 96       	adiw	r28, 0x01	; 1
    2a6e:	80 e0       	ldi	r24, 0x00	; 0
    2a70:	cc 31       	cpi	r28, 0x1C	; 28
    2a72:	d8 07       	cpc	r29, r24
    2a74:	a9 f7       	brne	.-22     	; 0x2a60 <PM_SendEraseCommand+0x8>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2a76:	25 97       	sbiw	r28, 0x05	; 5
    2a78:	de 01       	movw	r26, r28
    2a7a:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
    2a7e:	80 2d       	mov	r24, r0
    2a80:	25 96       	adiw	r28, 0x05	; 5
			
	if (eeprom_read_byte(&EEPROMVars.EraseChip[1]))   // Value of 1 indicates a busy flag test
    2a82:	88 23       	and	r24, r24
    2a84:	59 f0       	breq	.+22     	; 0x2a9c <PM_SendEraseCommand+0x44>
	{
		do
			USI_SPITransmitWord(0xF000);
    2a86:	80 e0       	ldi	r24, 0x00	; 0
    2a88:	90 ef       	ldi	r25, 0xF0	; 240
    2a8a:	0e 94 a4 09 	call	0x1348	; 0x1348 <USI_SPITransmitWord>
		while (USI_SPITransmitWord(0x0000) & 0x01);
    2a8e:	80 e0       	ldi	r24, 0x00	; 0
    2a90:	90 e0       	ldi	r25, 0x00	; 0
    2a92:	0e 94 a4 09 	call	0x1348	; 0x1348 <USI_SPITransmitWord>
    2a96:	80 ff       	sbrs	r24, 0
    2a98:	08 c0       	rjmp	.+16     	; 0x2aaa <PM_SendEraseCommand+0x52>
    2a9a:	f5 cf       	rjmp	.-22     	; 0x2a86 <PM_SendEraseCommand+0x2e>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2a9c:	26 97       	sbiw	r28, 0x06	; 6
    2a9e:	de 01       	movw	r26, r28
    2aa0:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
    2aa4:	80 2d       	mov	r24, r0
	}
	else                                              // Cleared flag means use a predefined delay
	{		
		MAIN_Delay1MS(eeprom_read_byte(&EEPROMVars.EraseChip[0])); // Wait the erase delay
    2aa6:	0e 94 47 02 	call	0x48e	; 0x48e <MAIN_Delay1MS>
    2aaa:	df 91       	pop	r29
    2aac:	cf 91       	pop	r28
    2aae:	08 95       	ret

00002ab0 <PM_CreateProgrammingPackets>:
	}
}

void PM_CreateProgrammingPackets(const uint8_t Type)
{			
    2ab0:	3f 92       	push	r3
    2ab2:	4f 92       	push	r4
    2ab4:	5f 92       	push	r5
    2ab6:	6f 92       	push	r6
    2ab8:	7f 92       	push	r7
    2aba:	8f 92       	push	r8
    2abc:	9f 92       	push	r9
    2abe:	af 92       	push	r10
    2ac0:	bf 92       	push	r11
    2ac2:	cf 92       	push	r12
    2ac4:	df 92       	push	r13
    2ac6:	ef 92       	push	r14
    2ac8:	ff 92       	push	r15
    2aca:	0f 93       	push	r16
    2acc:	1f 93       	push	r17
    2ace:	cf 93       	push	r28
    2ad0:	df 93       	push	r29
    2ad2:	18 2f       	mov	r17, r24
	uint32_t BytesRead       = 0;
	uint32_t BytesToRead     = PM_GetStoredDataSize(Type);      // Get the byte size of the stored program
    2ad4:	0e 94 85 14 	call	0x290a	; 0x290a <PM_GetStoredDataSize>
    2ad8:	2b 01       	movw	r4, r22
    2ada:	3c 01       	movw	r6, r24
	uint16_t BytesPerProgram;
	uint16_t PageLength;
	uint8_t* EEPROMAddress;
	uint8_t  ContinuedPage   = FALSE;

	PageLength  = eeprom_read_word((Type == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength);
    2adc:	11 30       	cpi	r17, 0x01	; 1
    2ade:	09 f0       	breq	.+2      	; 0x2ae2 <PM_CreateProgrammingPackets+0x32>
    2ae0:	d7 c0       	rjmp	.+430    	; 0x2c90 <PM_CreateProgrammingPackets+0x1e0>
eeprom_read_word (const uint16_t *addr)
{
  uint16_t result;

  asm ( 
    2ae2:	a2 e8       	ldi	r26, 0x82	; 130
    2ae4:	b0 e0       	ldi	r27, 0x00	; 0
    2ae6:	0e 94 31 1a 	call	0x3462	; 0x3462 <__eeprom_read_word_1F2021>
    2aea:	4f 01       	movw	r8, r30
	CurrAddress = 0;
    2aec:	10 92 63 02 	sts	0x0263, r1
    2af0:	10 92 64 02 	sts	0x0264, r1
    2af4:	10 92 65 02 	sts	0x0265, r1
    2af8:	10 92 66 02 	sts	0x0266, r1

	if (Type == TYPE_FLASH)
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram;       // Set the EEPROM pointer to the write flash command bytes location
		DF_ContinuousReadEnable(0, 0);
    2afc:	60 e0       	ldi	r22, 0x00	; 0
    2afe:	70 e0       	ldi	r23, 0x00	; 0
    2b00:	80 e0       	ldi	r24, 0x00	; 0
    2b02:	90 e0       	ldi	r25, 0x00	; 0
    2b04:	0e 94 2b 0a 	call	0x1456	; 0x1456 <DF_ContinuousReadEnable>
		PacketBytes[0] = AICB_CMD_PROGRAM_FLASH_ISP;
    2b08:	83 e1       	ldi	r24, 0x13	; 19
    2b0a:	80 93 4b 01 	sts	0x014B, r24
    2b0e:	23 e0       	ldi	r18, 0x03	; 3
    2b10:	30 e0       	ldi	r19, 0x00	; 0
    2b12:	ec e4       	ldi	r30, 0x4C	; 76
    2b14:	f1 e0       	ldi	r31, 0x01	; 1
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2b16:	d9 01       	movw	r26, r18
    2b18:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
    2b1c:	80 2d       	mov	r24, r0
	}
	else
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;        // Set the EEPROM pointer to the write EEPROM command bytes location
		DF_ContinuousReadEnable(PM_EEPROM_OFFSET / DF_INTERNALDF_BUFFBYTES, PM_EEPROM_OFFSET % DF_INTERNALDF_BUFFBYTES); // Start read from the EEPROM offset location
		PacketBytes[0] = AICB_CMD_PROGRAM_EEPROM_ISP;
	}

	for (uint8_t B = 1; B <= 9 ; B++)                 // Load in the write data command bytes
	{
		PacketBytes[B] = eeprom_read_byte(EEPROMAddress); // Synthesise a write packet header
    2b1e:	81 93       	st	Z+, r24
		EEPROMAddress++;                               // Increment the EEPROM location counter
    2b20:	2f 5f       	subi	r18, 0xFF	; 255
    2b22:	3f 4f       	sbci	r19, 0xFF	; 255
    2b24:	81 e0       	ldi	r24, 0x01	; 1
    2b26:	e5 35       	cpi	r30, 0x55	; 85
    2b28:	f8 07       	cpc	r31, r24
    2b2a:	a9 f7       	brne	.-22     	; 0x2b16 <PM_CreateProgrammingPackets+0x66>
	}
	
	BytesPerProgram = ((uint16_t)PacketBytes[1] << 8)
    2b2c:	80 91 4c 01 	lds	r24, 0x014C
    2b30:	99 27       	eor	r25, r25
    2b32:	d8 2f       	mov	r29, r24
    2b34:	cc 27       	eor	r28, r28
    2b36:	80 91 4d 01 	lds	r24, 0x014D
    2b3a:	99 27       	eor	r25, r25
    2b3c:	c8 2b       	or	r28, r24
    2b3e:	d9 2b       	or	r29, r25
    2b40:	aa 24       	eor	r10, r10
    2b42:	bb 24       	eor	r11, r11
    2b44:	65 01       	movw	r12, r10
    2b46:	33 24       	eor	r3, r3
    2b48:	9c c0       	rjmp	.+312    	; 0x2c82 <PM_CreateProgrammingPackets+0x1d2>
	                | PacketBytes[2];

	while (BytesRead < BytesToRead)
	{
		if (PacketBytes[3] & ISPCC_PROG_MODE_PAGE)
    2b4a:	80 91 4e 01 	lds	r24, 0x014E
    2b4e:	80 ff       	sbrs	r24, 0
    2b50:	4b c0       	rjmp	.+150    	; 0x2be8 <PM_CreateProgrammingPackets+0x138>
		{
			if (PageLength > 160) // Max 160 bytes at a time
    2b52:	91 ea       	ldi	r25, 0xA1	; 161
    2b54:	89 16       	cp	r8, r25
    2b56:	91 04       	cpc	r9, r1
    2b58:	18 f4       	brcc	.+6      	; 0x2b60 <PM_CreateProgrammingPackets+0xb0>
    2b5a:	0b e4       	ldi	r16, 0x4B	; 75
    2b5c:	11 e0       	ldi	r17, 0x01	; 1
    2b5e:	2f c0       	rjmp	.+94     	; 0x2bbe <PM_CreateProgrammingPackets+0x10e>
			{
				if (!(ContinuedPage))                      // Start of a new page, program in the first 150 bytes
    2b60:	33 20       	and	r3, r3
    2b62:	41 f4       	brne	.+16     	; 0x2b74 <PM_CreateProgrammingPackets+0xc4>
				{
					BytesPerProgram = 160;
					PacketBytes[3] &= ~ISPCC_PROG_MODE_PAGEDONE;		
    2b64:	8f 77       	andi	r24, 0x7F	; 127
    2b66:	80 93 4e 01 	sts	0x014E, r24
    2b6a:	c0 ea       	ldi	r28, 0xA0	; 160
    2b6c:	d0 e0       	ldi	r29, 0x00	; 0
    2b6e:	11 e0       	ldi	r17, 0x01	; 1
    2b70:	31 2e       	mov	r3, r17
    2b72:	07 c0       	rjmp	.+14     	; 0x2b82 <PM_CreateProgrammingPackets+0xd2>
					ContinuedPage = TRUE;
				}
				else                                       // Middle of a page, program in the remainder
				{
					BytesPerProgram = PageLength - 160;
    2b74:	e4 01       	movw	r28, r8
    2b76:	c0 5a       	subi	r28, 0xA0	; 160
    2b78:	d0 40       	sbci	r29, 0x00	; 0
					PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
    2b7a:	80 68       	ori	r24, 0x80	; 128
    2b7c:	80 93 4e 01 	sts	0x014E, r24
    2b80:	33 24       	eor	r3, r3
    2b82:	0b e4       	ldi	r16, 0x4B	; 75
    2b84:	11 e0       	ldi	r17, 0x01	; 1
    2b86:	07 c0       	rjmp	.+14     	; 0x2b96 <PM_CreateProgrammingPackets+0xe6>
					ContinuedPage = FALSE;
				}
				
				for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page				
    2b88:	80 e0       	ldi	r24, 0x00	; 0
    2b8a:	0e 94 52 09 	call	0x12a4	; 0x12a4 <SPI_SPITransmit>
    2b8e:	f8 01       	movw	r30, r16
    2b90:	82 87       	std	Z+10, r24	; 0x0a
    2b92:	0f 5f       	subi	r16, 0xFF	; 255
    2b94:	1f 4f       	sbci	r17, 0xFF	; 255
    2b96:	ce 01       	movw	r24, r28
    2b98:	85 5b       	subi	r24, 0xB5	; 181
    2b9a:	9e 4f       	sbci	r25, 0xFE	; 254
    2b9c:	08 17       	cp	r16, r24
    2b9e:	19 07       	cpc	r17, r25
    2ba0:	99 f7       	brne	.-26     	; 0x2b88 <PM_CreateProgrammingPackets+0xd8>

				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);
    2ba2:	8d 2f       	mov	r24, r29
    2ba4:	99 27       	eor	r25, r25
    2ba6:	80 93 4c 01 	sts	0x014C, r24
				PacketBytes[2] = (uint8_t)(BytesPerProgram);
    2baa:	c0 93 4d 01 	sts	0x014D, r28
    2bae:	41 c0       	rjmp	.+130    	; 0x2c32 <PM_CreateProgrammingPackets+0x182>

				BytesRead += BytesPerProgram;                         // Increment the counter
			}
			else
			{
				for (uint16_t LoadB = 0; LoadB < PageLength; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page
    2bb0:	80 e0       	ldi	r24, 0x00	; 0
    2bb2:	0e 94 52 09 	call	0x12a4	; 0x12a4 <SPI_SPITransmit>
    2bb6:	f8 01       	movw	r30, r16
    2bb8:	82 87       	std	Z+10, r24	; 0x0a
    2bba:	0f 5f       	subi	r16, 0xFF	; 255
    2bbc:	1f 4f       	sbci	r17, 0xFF	; 255
    2bbe:	c4 01       	movw	r24, r8
    2bc0:	85 5b       	subi	r24, 0xB5	; 181
    2bc2:	9e 4f       	sbci	r25, 0xFE	; 254
    2bc4:	08 17       	cp	r16, r24
    2bc6:	19 07       	cpc	r17, r25
    2bc8:	99 f7       	brne	.-26     	; 0x2bb0 <PM_CreateProgrammingPackets+0x100>
			
				PacketBytes[1]  = (uint8_t)(PageLength >> 8);
    2bca:	89 2d       	mov	r24, r9
    2bcc:	99 27       	eor	r25, r25
    2bce:	80 93 4c 01 	sts	0x014C, r24
				PacketBytes[2]  = (uint8_t)(PageLength);
    2bd2:	80 92 4d 01 	sts	0x014D, r8
				PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
    2bd6:	80 91 4e 01 	lds	r24, 0x014E
    2bda:	80 68       	ori	r24, 0x80	; 128
    2bdc:	80 93 4e 01 	sts	0x014E, r24

				BytesRead += PageLength;                            // Increment the counter
    2be0:	c4 01       	movw	r24, r8
    2be2:	aa 27       	eor	r26, r26
    2be4:	bb 27       	eor	r27, r27
    2be6:	28 c0       	rjmp	.+80     	; 0x2c38 <PM_CreateProgrammingPackets+0x188>
			}
		}
		else
		{
			if ((BytesRead + BytesPerProgram) > BytesToRead)        // Less than a whole BytesPerProgram left of data to write
    2be8:	ce 01       	movw	r24, r28
    2bea:	aa 27       	eor	r26, r26
    2bec:	bb 27       	eor	r27, r27
    2bee:	8a 0d       	add	r24, r10
    2bf0:	9b 1d       	adc	r25, r11
    2bf2:	ac 1d       	adc	r26, r12
    2bf4:	bd 1d       	adc	r27, r13
    2bf6:	48 16       	cp	r4, r24
    2bf8:	59 06       	cpc	r5, r25
    2bfa:	6a 06       	cpc	r6, r26
    2bfc:	7b 06       	cpc	r7, r27
    2bfe:	48 f4       	brcc	.+18     	; 0x2c12 <PM_CreateProgrammingPackets+0x162>
			{
				BytesPerProgram = BytesToRead - BytesRead;          // Next lot of bytes will be the remaining data length
    2c00:	e2 01       	movw	r28, r4
    2c02:	ca 19       	sub	r28, r10
    2c04:	db 09       	sbc	r29, r11
				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);   // \. Save the new length
    2c06:	8d 2f       	mov	r24, r29
    2c08:	99 27       	eor	r25, r25
    2c0a:	80 93 4c 01 	sts	0x014C, r24
				PacketBytes[2] = (uint8_t)(BytesPerProgram);        // /  into the data packet
    2c0e:	c0 93 4d 01 	sts	0x014D, r28
    2c12:	0b e4       	ldi	r16, 0x4B	; 75
    2c14:	11 e0       	ldi	r17, 0x01	; 1
    2c16:	07 c0       	rjmp	.+14     	; 0x2c26 <PM_CreateProgrammingPackets+0x176>
			}

			for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
				PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);    // Load in the page
    2c18:	80 e0       	ldi	r24, 0x00	; 0
    2c1a:	0e 94 52 09 	call	0x12a4	; 0x12a4 <SPI_SPITransmit>
    2c1e:	f8 01       	movw	r30, r16
    2c20:	82 87       	std	Z+10, r24	; 0x0a
    2c22:	0f 5f       	subi	r16, 0xFF	; 255
    2c24:	1f 4f       	sbci	r17, 0xFF	; 255
    2c26:	ce 01       	movw	r24, r28
    2c28:	85 5b       	subi	r24, 0xB5	; 181
    2c2a:	9e 4f       	sbci	r25, 0xFE	; 254
    2c2c:	08 17       	cp	r16, r24
    2c2e:	19 07       	cpc	r17, r25
    2c30:	99 f7       	brne	.-26     	; 0x2c18 <PM_CreateProgrammingPackets+0x168>
			
			BytesRead += BytesPerProgram;                           // Increment the counter
    2c32:	ce 01       	movw	r24, r28
    2c34:	aa 27       	eor	r26, r26
    2c36:	bb 27       	eor	r27, r27
    2c38:	a8 0e       	add	r10, r24
    2c3a:	b9 1e       	adc	r11, r25
    2c3c:	ca 1e       	adc	r12, r26
    2c3e:	db 1e       	adc	r13, r27
		}
	
		if (!(BytesRead & 0xFFFF) && (BytesRead & 0x00FF0000))      // Extended address required
    2c40:	a1 14       	cp	r10, r1
    2c42:	b1 04       	cpc	r11, r1
    2c44:	e1 f4       	brne	.+56     	; 0x2c7e <PM_CreateProgrammingPackets+0x1ce>
    2c46:	e1 2c       	mov	r14, r1
    2c48:	f1 2c       	mov	r15, r1
    2c4a:	ef ef       	ldi	r30, 0xFF	; 255
    2c4c:	0e 2f       	mov	r16, r30
    2c4e:	11 2d       	mov	r17, r1
    2c50:	ea 20       	and	r14, r10
    2c52:	fb 20       	and	r15, r11
    2c54:	0c 21       	and	r16, r12
    2c56:	1d 21       	and	r17, r13
    2c58:	e1 14       	cp	r14, r1
    2c5a:	f1 04       	cpc	r15, r1
    2c5c:	01 05       	cpc	r16, r1
    2c5e:	11 05       	cpc	r17, r1
    2c60:	71 f0       	breq	.+28     	; 0x2c7e <PM_CreateProgrammingPackets+0x1ce>
		{
			USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);            // Load extended address command
    2c62:	8d e4       	ldi	r24, 0x4D	; 77
    2c64:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
			USI_SPITransmit(0x00);
    2c68:	80 e0       	ldi	r24, 0x00	; 0
    2c6a:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
			USI_SPITransmit((BytesRead & 0x00FF0000) >> 16);        // The 3rd byte of the long holds the extended address
    2c6e:	c8 01       	movw	r24, r16
    2c70:	aa 27       	eor	r26, r26
    2c72:	bb 27       	eor	r27, r27
    2c74:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
			USI_SPITransmit(0x00);
    2c78:	80 e0       	ldi	r24, 0x00	; 0
    2c7a:	0e 94 91 09 	call	0x1322	; 0x1322 <USI_SPITransmit>
		}

		ISPCC_ProgramChip();                                        // Start the program cycle
    2c7e:	0e 94 21 11 	call	0x2242	; 0x2242 <ISPCC_ProgramChip>
    2c82:	a4 14       	cp	r10, r4
    2c84:	b5 04       	cpc	r11, r5
    2c86:	c6 04       	cpc	r12, r6
    2c88:	d7 04       	cpc	r13, r7
    2c8a:	08 f4       	brcc	.+2      	; 0x2c8e <PM_CreateProgrammingPackets+0x1de>
    2c8c:	5e cf       	rjmp	.-324    	; 0x2b4a <PM_CreateProgrammingPackets+0x9a>
    2c8e:	19 c0       	rjmp	.+50     	; 0x2cc2 <PM_CreateProgrammingPackets+0x212>
eeprom_read_word (const uint16_t *addr)
{
  uint16_t result;

  asm ( 
    2c90:	a4 e8       	ldi	r26, 0x84	; 132
    2c92:	b0 e0       	ldi	r27, 0x00	; 0
    2c94:	0e 94 31 1a 	call	0x3462	; 0x3462 <__eeprom_read_word_1F2021>
    2c98:	4f 01       	movw	r8, r30
    2c9a:	10 92 63 02 	sts	0x0263, r1
    2c9e:	10 92 64 02 	sts	0x0264, r1
    2ca2:	10 92 65 02 	sts	0x0265, r1
    2ca6:	10 92 66 02 	sts	0x0266, r1
    2caa:	60 ee       	ldi	r22, 0xE0	; 224
    2cac:	70 e0       	ldi	r23, 0x00	; 0
    2cae:	84 ee       	ldi	r24, 0xE4	; 228
    2cb0:	93 e0       	ldi	r25, 0x03	; 3
    2cb2:	0e 94 2b 0a 	call	0x1456	; 0x1456 <DF_ContinuousReadEnable>
    2cb6:	85 e1       	ldi	r24, 0x15	; 21
    2cb8:	80 93 4b 01 	sts	0x014B, r24
    2cbc:	2c e0       	ldi	r18, 0x0C	; 12
    2cbe:	30 e0       	ldi	r19, 0x00	; 0
    2cc0:	28 cf       	rjmp	.-432    	; 0x2b12 <PM_CreateProgrammingPackets+0x62>
    2cc2:	df 91       	pop	r29
    2cc4:	cf 91       	pop	r28
    2cc6:	1f 91       	pop	r17
    2cc8:	0f 91       	pop	r16
    2cca:	ff 90       	pop	r15
    2ccc:	ef 90       	pop	r14
    2cce:	df 90       	pop	r13
    2cd0:	cf 90       	pop	r12
    2cd2:	bf 90       	pop	r11
    2cd4:	af 90       	pop	r10
    2cd6:	9f 90       	pop	r9
    2cd8:	8f 90       	pop	r8
    2cda:	7f 90       	pop	r7
    2cdc:	6f 90       	pop	r6
    2cde:	5f 90       	pop	r5
    2ce0:	4f 90       	pop	r4
    2ce2:	3f 90       	pop	r3
    2ce4:	08 95       	ret

00002ce6 <PM_ShowStoredItemSizes>:
	}
}

void PM_ShowStoredItemSizes(void)
{
    2ce6:	1f 93       	push	r17
    2ce8:	cf 93       	push	r28
    2cea:	df 93       	push	r29
    2cec:	cd b7       	in	r28, 0x3d	; 61
    2cee:	de b7       	in	r29, 0x3e	; 62
    2cf0:	2e 97       	sbiw	r28, 0x0e	; 14
    2cf2:	0f b6       	in	r0, 0x3f	; 63
    2cf4:	f8 94       	cli
    2cf6:	de bf       	out	0x3e, r29	; 62
    2cf8:	0f be       	out	0x3f, r0	; 63
    2cfa:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[14];
	uint8_t ItemInfoIndex = 0;
	uint8_t TempB;
	
	JoyStatus = 1;
    2cfc:	81 e0       	ldi	r24, 0x01	; 1
    2cfe:	8e bb       	out	0x1e, r24	; 30
    2d00:	10 e0       	ldi	r17, 0x00	; 0
	
	while (1)
	{
		if (JoyStatus)                           // Joystick is in the non-center position
    2d02:	8e b3       	in	r24, 0x1e	; 30
    2d04:	88 23       	and	r24, r24
    2d06:	e9 f3       	breq	.-6      	; 0x2d02 <PM_ShowStoredItemSizes+0x1c>
		{
			if (JoyStatus & JOY_UP)              // Previous item
    2d08:	f6 9b       	sbis	0x1e, 6	; 30
    2d0a:	04 c0       	rjmp	.+8      	; 0x2d14 <PM_ShowStoredItemSizes+0x2e>
				(ItemInfoIndex == 0)? ItemInfoIndex = 3 : ItemInfoIndex--;
    2d0c:	11 23       	and	r17, r17
    2d0e:	b9 f1       	breq	.+110    	; 0x2d7e <PM_ShowStoredItemSizes+0x98>
    2d10:	11 50       	subi	r17, 0x01	; 1
    2d12:	0a c0       	rjmp	.+20     	; 0x2d28 <PM_ShowStoredItemSizes+0x42>
			else if (JoyStatus & JOY_DOWN)      // Next item
    2d14:	f7 9b       	sbis	0x1e, 7	; 30
    2d16:	06 c0       	rjmp	.+12     	; 0x2d24 <PM_ShowStoredItemSizes+0x3e>
				(ItemInfoIndex == 3)? ItemInfoIndex = 0 : ItemInfoIndex++;
    2d18:	13 30       	cpi	r17, 0x03	; 3
    2d1a:	11 f4       	brne	.+4      	; 0x2d20 <PM_ShowStoredItemSizes+0x3a>
    2d1c:	10 e0       	ldi	r17, 0x00	; 0
    2d1e:	0d c0       	rjmp	.+26     	; 0x2d3a <PM_ShowStoredItemSizes+0x54>
    2d20:	1f 5f       	subi	r17, 0xFF	; 255
    2d22:	02 c0       	rjmp	.+4      	; 0x2d28 <PM_ShowStoredItemSizes+0x42>
			else if (JoyStatus & JOY_LEFT)
    2d24:	f2 99       	sbic	0x1e, 2	; 30
    2d26:	49 c0       	rjmp	.+146    	; 0x2dba <PM_ShowStoredItemSizes+0xd4>
				return;
		
			switch (ItemInfoIndex)
    2d28:	11 30       	cpi	r17, 0x01	; 1
    2d2a:	79 f0       	breq	.+30     	; 0x2d4a <PM_ShowStoredItemSizes+0x64>
    2d2c:	11 30       	cpi	r17, 0x01	; 1
    2d2e:	28 f0       	brcs	.+10     	; 0x2d3a <PM_ShowStoredItemSizes+0x54>
    2d30:	12 30       	cpi	r17, 0x02	; 2
    2d32:	e1 f0       	breq	.+56     	; 0x2d6c <PM_ShowStoredItemSizes+0x86>
    2d34:	13 30       	cpi	r17, 0x03	; 3
    2d36:	d1 f5       	brne	.+116    	; 0x2dac <PM_ShowStoredItemSizes+0xc6>
    2d38:	23 c0       	rjmp	.+70     	; 0x2d80 <PM_ShowStoredItemSizes+0x9a>
			{
				case 0:
					strcpy_P(Buffer, PSTR("DATA-"));
    2d3a:	6d e2       	ldi	r22, 0x2D	; 45
    2d3c:	74 e0       	ldi	r23, 0x04	; 4
    2d3e:	ce 01       	movw	r24, r28
    2d40:	01 96       	adiw	r24, 0x01	; 1
    2d42:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_FLASH), &Buffer[5], 10);
    2d46:	81 e0       	ldi	r24, 0x01	; 1
    2d48:	07 c0       	rjmp	.+14     	; 0x2d58 <PM_ShowStoredItemSizes+0x72>
					break;
				case 1:
					strcpy_P(Buffer, PSTR("EPRM-"));
    2d4a:	67 e2       	ldi	r22, 0x27	; 39
    2d4c:	74 e0       	ldi	r23, 0x04	; 4
    2d4e:	ce 01       	movw	r24, r28
    2d50:	01 96       	adiw	r24, 0x01	; 1
    2d52:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_EEPROM), &Buffer[5], 10);
    2d56:	80 e0       	ldi	r24, 0x00	; 0
    2d58:	0e 94 85 14 	call	0x290a	; 0x290a <PM_GetStoredDataSize>
    2d5c:	2a e0       	ldi	r18, 0x0A	; 10
    2d5e:	30 e0       	ldi	r19, 0x00	; 0
    2d60:	ae 01       	movw	r20, r28
    2d62:	4a 5f       	subi	r20, 0xFA	; 250
    2d64:	5f 4f       	sbci	r21, 0xFF	; 255
    2d66:	0e 94 ef 19 	call	0x33de	; 0x33de <ultoa>
    2d6a:	20 c0       	rjmp	.+64     	; 0x2dac <PM_ShowStoredItemSizes+0xc6>
					break;
				case 2:
					strcpy_P(Buffer, PSTR("FUSE-"));
    2d6c:	61 e2       	ldi	r22, 0x21	; 33
    2d6e:	74 e0       	ldi	r23, 0x04	; 4
    2d70:	ce 01       	movw	r24, r28
    2d72:	01 96       	adiw	r24, 0x01	; 1
    2d74:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <strcpy_P>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2d78:	a0 e3       	ldi	r26, 0x30	; 48
    2d7a:	b0 e0       	ldi	r27, 0x00	; 0
    2d7c:	09 c0       	rjmp	.+18     	; 0x2d90 <PM_ShowStoredItemSizes+0xaa>
					TempB = eeprom_read_byte(&EEPROMVars.TotalFuseBytes);
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);
					break;
    2d7e:	13 e0       	ldi	r17, 0x03	; 3
				case 3:
					strcpy_P(Buffer, PSTR("LOCK-"));
    2d80:	6b e1       	ldi	r22, 0x1B	; 27
    2d82:	74 e0       	ldi	r23, 0x04	; 4
    2d84:	ce 01       	movw	r24, r28
    2d86:	01 96       	adiw	r24, 0x01	; 1
    2d88:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <strcpy_P>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2d8c:	a1 e3       	ldi	r26, 0x31	; 49
    2d8e:	b0 e0       	ldi	r27, 0x00	; 0
    2d90:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
    2d94:	80 2d       	mov	r24, r0
					TempB = eeprom_read_byte(&EEPROMVars.TotalLockBytes);
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);		
    2d96:	8f 3f       	cpi	r24, 0xFF	; 255
    2d98:	19 f4       	brne	.+6      	; 0x2da0 <PM_ShowStoredItemSizes+0xba>
    2d9a:	80 e0       	ldi	r24, 0x00	; 0
    2d9c:	90 e0       	ldi	r25, 0x00	; 0
    2d9e:	01 c0       	rjmp	.+2      	; 0x2da2 <PM_ShowStoredItemSizes+0xbc>
    2da0:	99 27       	eor	r25, r25
    2da2:	be 01       	movw	r22, r28
    2da4:	6a 5f       	subi	r22, 0xFA	; 250
    2da6:	7f 4f       	sbci	r23, 0xFF	; 255
    2da8:	0e 94 72 02 	call	0x4e4	; 0x4e4 <MAIN_IntToStr>
			}
	
			LCD_puts(Buffer);
    2dac:	ce 01       	movw	r24, r28
    2dae:	01 96       	adiw	r24, 0x01	; 1
    2db0:	0e 94 15 08 	call	0x102a	; 0x102a <LCD_puts>

			MAIN_WaitForJoyRelease();
    2db4:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
    2db8:	a4 cf       	rjmp	.-184    	; 0x2d02 <PM_ShowStoredItemSizes+0x1c>
    2dba:	2e 96       	adiw	r28, 0x0e	; 14
    2dbc:	0f b6       	in	r0, 0x3f	; 63
    2dbe:	f8 94       	cli
    2dc0:	de bf       	out	0x3e, r29	; 62
    2dc2:	0f be       	out	0x3f, r0	; 63
    2dc4:	cd bf       	out	0x3d, r28	; 61
    2dc6:	df 91       	pop	r29
    2dc8:	cf 91       	pop	r28
    2dca:	1f 91       	pop	r17
    2dcc:	08 95       	ret

00002dce <PM_InterpretAVRISPPacket>:
    2dce:	ef 92       	push	r14
    2dd0:	ff 92       	push	r15
    2dd2:	0f 93       	push	r16
    2dd4:	1f 93       	push	r17
    2dd6:	cf 93       	push	r28
    2dd8:	df 93       	push	r29
    2dda:	20 91 4b 01 	lds	r18, 0x014B
    2dde:	26 31       	cpi	r18, 0x16	; 22
    2de0:	09 f4       	brne	.+2      	; 0x2de4 <PM_InterpretAVRISPPacket+0x16>
    2de2:	af c1       	rjmp	.+862    	; 0x3142 <PM_InterpretAVRISPPacket+0x374>
    2de4:	27 31       	cpi	r18, 0x17	; 23
    2de6:	78 f4       	brcc	.+30     	; 0x2e06 <PM_InterpretAVRISPPacket+0x38>
    2de8:	22 31       	cpi	r18, 0x12	; 18
    2dea:	09 f4       	brne	.+2      	; 0x2dee <PM_InterpretAVRISPPacket+0x20>
    2dec:	5f c0       	rjmp	.+190    	; 0x2eac <PM_InterpretAVRISPPacket+0xde>
    2dee:	23 31       	cpi	r18, 0x13	; 19
    2df0:	30 f4       	brcc	.+12     	; 0x2dfe <PM_InterpretAVRISPPacket+0x30>
    2df2:	20 31       	cpi	r18, 0x10	; 16
    2df4:	e9 f0       	breq	.+58     	; 0x2e30 <PM_InterpretAVRISPPacket+0x62>
    2df6:	21 31       	cpi	r18, 0x11	; 17
    2df8:	09 f0       	breq	.+2      	; 0x2dfc <PM_InterpretAVRISPPacket+0x2e>
    2dfa:	09 c2       	rjmp	.+1042   	; 0x320e <PM_InterpretAVRISPPacket+0x440>
    2dfc:	37 c0       	rjmp	.+110    	; 0x2e6c <PM_InterpretAVRISPPacket+0x9e>
    2dfe:	24 31       	cpi	r18, 0x14	; 20
    2e00:	09 f0       	breq	.+2      	; 0x2e04 <PM_InterpretAVRISPPacket+0x36>
    2e02:	37 c1       	rjmp	.+622    	; 0x3072 <PM_InterpretAVRISPPacket+0x2a4>
    2e04:	9e c1       	rjmp	.+828    	; 0x3142 <PM_InterpretAVRISPPacket+0x374>
    2e06:	29 31       	cpi	r18, 0x19	; 25
    2e08:	09 f4       	brne	.+2      	; 0x2e0c <PM_InterpretAVRISPPacket+0x3e>
    2e0a:	e0 c0       	rjmp	.+448    	; 0x2fcc <PM_InterpretAVRISPPacket+0x1fe>
    2e0c:	2a 31       	cpi	r18, 0x1A	; 26
    2e0e:	38 f4       	brcc	.+14     	; 0x2e1e <PM_InterpretAVRISPPacket+0x50>
    2e10:	27 31       	cpi	r18, 0x17	; 23
    2e12:	09 f4       	brne	.+2      	; 0x2e16 <PM_InterpretAVRISPPacket+0x48>
    2e14:	db c0       	rjmp	.+438    	; 0x2fcc <PM_InterpretAVRISPPacket+0x1fe>
    2e16:	28 31       	cpi	r18, 0x18	; 24
    2e18:	09 f0       	breq	.+2      	; 0x2e1c <PM_InterpretAVRISPPacket+0x4e>
    2e1a:	f9 c1       	rjmp	.+1010   	; 0x320e <PM_InterpretAVRISPPacket+0x440>
    2e1c:	83 c0       	rjmp	.+262    	; 0x2f24 <PM_InterpretAVRISPPacket+0x156>
    2e1e:	2b 31       	cpi	r18, 0x1B	; 27
    2e20:	c9 f1       	breq	.+114    	; 0x2e94 <PM_InterpretAVRISPPacket+0xc6>
    2e22:	2b 31       	cpi	r18, 0x1B	; 27
    2e24:	08 f4       	brcc	.+2      	; 0x2e28 <PM_InterpretAVRISPPacket+0x5a>
    2e26:	7e c0       	rjmp	.+252    	; 0x2f24 <PM_InterpretAVRISPPacket+0x156>
    2e28:	2c 31       	cpi	r18, 0x1C	; 28
    2e2a:	09 f0       	breq	.+2      	; 0x2e2e <PM_InterpretAVRISPPacket+0x60>
    2e2c:	f0 c1       	rjmp	.+992    	; 0x320e <PM_InterpretAVRISPPacket+0x440>
    2e2e:	6d c0       	rjmp	.+218    	; 0x2f0a <PM_InterpretAVRISPPacket+0x13c>
    2e30:	82 e0       	ldi	r24, 0x02	; 2
    2e32:	90 e0       	ldi	r25, 0x00	; 0
    2e34:	90 93 61 02 	sts	0x0261, r25
    2e38:	80 93 60 02 	sts	0x0260, r24
    2e3c:	eb e4       	ldi	r30, 0x4B	; 75
    2e3e:	f1 e0       	ldi	r31, 0x01	; 1
    2e40:	24 e2       	ldi	r18, 0x24	; 36
    2e42:	30 e0       	ldi	r19, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2e44:	81 91       	ld	r24, Z+
    2e46:	d9 01       	movw	r26, r18
    2e48:	08 2e       	mov	r0, r24
    2e4a:	0e 94 36 1a 	call	0x346c	; 0x346c <__eeprom_write_byte_1F2021>
    2e4e:	2f 5f       	subi	r18, 0xFF	; 255
    2e50:	3f 4f       	sbci	r19, 0xFF	; 255
    2e52:	81 e0       	ldi	r24, 0x01	; 1
    2e54:	e7 35       	cpi	r30, 0x57	; 87
    2e56:	f8 07       	cpc	r31, r24
    2e58:	a9 f7       	brne	.-22     	; 0x2e44 <PM_InterpretAVRISPPacket+0x76>
    2e5a:	81 e0       	ldi	r24, 0x01	; 1
    2e5c:	80 93 62 02 	sts	0x0262, r24
    2e60:	10 92 69 02 	sts	0x0269, r1
    2e64:	81 b3       	in	r24, 0x11	; 17
    2e66:	8f 7c       	andi	r24, 0xCF	; 207
    2e68:	80 62       	ori	r24, 0x20	; 32
    2e6a:	10 c0       	rjmp	.+32     	; 0x2e8c <PM_InterpretAVRISPPacket+0xbe>
    2e6c:	82 e0       	ldi	r24, 0x02	; 2
    2e6e:	90 e0       	ldi	r25, 0x00	; 0
    2e70:	90 93 61 02 	sts	0x0261, r25
    2e74:	80 93 60 02 	sts	0x0260, r24
    2e78:	0e 94 1b 14 	call	0x2836	; 0x2836 <PM_CheckEndOfFuseLockData>
    2e7c:	10 92 62 02 	sts	0x0262, r1
    2e80:	80 e0       	ldi	r24, 0x00	; 0
    2e82:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    2e86:	81 b3       	in	r24, 0x11	; 17
    2e88:	8f 7c       	andi	r24, 0xCF	; 207
    2e8a:	80 61       	ori	r24, 0x10	; 16
    2e8c:	81 bb       	out	0x11, r24	; 17
    2e8e:	10 92 4c 01 	sts	0x014C, r1
    2e92:	c6 c1       	rjmp	.+908    	; 0x3220 <PM_InterpretAVRISPPacket+0x452>
    2e94:	84 e0       	ldi	r24, 0x04	; 4
    2e96:	90 e0       	ldi	r25, 0x00	; 0
    2e98:	90 93 61 02 	sts	0x0261, r25
    2e9c:	80 93 60 02 	sts	0x0260, r24
    2ea0:	10 92 4c 01 	sts	0x014C, r1
    2ea4:	81 e0       	ldi	r24, 0x01	; 1
    2ea6:	80 93 4d 01 	sts	0x014D, r24
    2eaa:	39 c0       	rjmp	.+114    	; 0x2f1e <PM_InterpretAVRISPPacket+0x150>
    2eac:	82 e0       	ldi	r24, 0x02	; 2
    2eae:	90 e0       	ldi	r25, 0x00	; 0
    2eb0:	90 93 61 02 	sts	0x0261, r25
    2eb4:	80 93 60 02 	sts	0x0260, r24
    2eb8:	ec e4       	ldi	r30, 0x4C	; 76
    2eba:	f1 e0       	ldi	r31, 0x01	; 1
    2ebc:	27 e1       	ldi	r18, 0x17	; 23
    2ebe:	30 e0       	ldi	r19, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2ec0:	81 91       	ld	r24, Z+
    2ec2:	d9 01       	movw	r26, r18
    2ec4:	08 2e       	mov	r0, r24
    2ec6:	0e 94 36 1a 	call	0x346c	; 0x346c <__eeprom_write_byte_1F2021>
    2eca:	2f 5f       	subi	r18, 0xFF	; 255
    2ecc:	3f 4f       	sbci	r19, 0xFF	; 255
    2ece:	91 e0       	ldi	r25, 0x01	; 1
    2ed0:	e2 35       	cpi	r30, 0x52	; 82
    2ed2:	f9 07       	cpc	r31, r25
    2ed4:	a9 f7       	brne	.-22     	; 0x2ec0 <PM_InterpretAVRISPPacket+0xf2>
    2ed6:	2c e1       	ldi	r18, 0x1C	; 28
    2ed8:	30 e0       	ldi	r19, 0x00	; 0
    2eda:	80 e0       	ldi	r24, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2edc:	d9 01       	movw	r26, r18
    2ede:	08 2e       	mov	r0, r24
    2ee0:	0e 94 36 1a 	call	0x346c	; 0x346c <__eeprom_write_byte_1F2021>
    2ee4:	d9 01       	movw	r26, r18
    2ee6:	14 96       	adiw	r26, 0x04	; 4
    2ee8:	08 2e       	mov	r0, r24
    2eea:	0e 94 36 1a 	call	0x346c	; 0x346c <__eeprom_write_byte_1F2021>
    2eee:	2f 5f       	subi	r18, 0xFF	; 255
    2ef0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ef2:	e0 e0       	ldi	r30, 0x00	; 0
    2ef4:	24 32       	cpi	r18, 0x24	; 36
    2ef6:	3e 07       	cpc	r19, r30
    2ef8:	89 f7       	brne	.-30     	; 0x2edc <PM_InterpretAVRISPPacket+0x10e>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2efa:	81 e0       	ldi	r24, 0x01	; 1
    2efc:	2f 50       	subi	r18, 0x0F	; 15
    2efe:	30 40       	sbci	r19, 0x00	; 0
    2f00:	d9 01       	movw	r26, r18
    2f02:	08 2e       	mov	r0, r24
    2f04:	0e 94 36 1a 	call	0x346c	; 0x346c <__eeprom_write_byte_1F2021>
    2f08:	c2 cf       	rjmp	.-124    	; 0x2e8e <PM_InterpretAVRISPPacket+0xc0>
    2f0a:	84 e0       	ldi	r24, 0x04	; 4
    2f0c:	90 e0       	ldi	r25, 0x00	; 0
    2f0e:	90 93 61 02 	sts	0x0261, r25
    2f12:	80 93 60 02 	sts	0x0260, r24
    2f16:	10 92 4c 01 	sts	0x014C, r1
    2f1a:	10 92 4d 01 	sts	0x014D, r1
    2f1e:	10 92 4e 01 	sts	0x014E, r1
    2f22:	7e c1       	rjmp	.+764    	; 0x3220 <PM_InterpretAVRISPPacket+0x452>
    2f24:	84 e0       	ldi	r24, 0x04	; 4
    2f26:	90 e0       	ldi	r25, 0x00	; 0
    2f28:	90 93 61 02 	sts	0x0261, r25
    2f2c:	80 93 60 02 	sts	0x0260, r24
    2f30:	80 91 69 02 	lds	r24, 0x0269
    2f34:	84 30       	cpi	r24, 0x04	; 4
    2f36:	49 f0       	breq	.+18     	; 0x2f4a <PM_InterpretAVRISPPacket+0x17c>
    2f38:	0e 94 1b 14 	call	0x2836	; 0x2836 <PM_CheckEndOfFuseLockData>
    2f3c:	10 92 3e 01 	sts	0x013E, r1
    2f40:	10 92 3d 01 	sts	0x013D, r1
    2f44:	84 e0       	ldi	r24, 0x04	; 4
    2f46:	80 93 69 02 	sts	0x0269, r24
    2f4a:	40 91 3d 01 	lds	r20, 0x013D
    2f4e:	50 91 3e 01 	lds	r21, 0x013E
    2f52:	20 91 4b 01 	lds	r18, 0x014B
    2f56:	28 31       	cpi	r18, 0x18	; 24
    2f58:	19 f0       	breq	.+6      	; 0x2f60 <PM_InterpretAVRISPPacket+0x192>
    2f5a:	a1 e3       	ldi	r26, 0x31	; 49
    2f5c:	b0 e0       	ldi	r27, 0x00	; 0
    2f5e:	02 c0       	rjmp	.+4      	; 0x2f64 <PM_InterpretAVRISPPacket+0x196>
    2f60:	a0 e3       	ldi	r26, 0x30	; 48
    2f62:	b0 e0       	ldi	r27, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2f64:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
    2f68:	80 2d       	mov	r24, r0
    2f6a:	99 27       	eor	r25, r25
    2f6c:	84 17       	cp	r24, r20
    2f6e:	95 07       	cpc	r25, r21
    2f70:	10 f4       	brcc	.+4      	; 0x2f76 <PM_InterpretAVRISPPacket+0x1a8>
    2f72:	8f ef       	ldi	r24, 0xFF	; 255
    2f74:	1e c0       	rjmp	.+60     	; 0x2fb2 <PM_InterpretAVRISPPacket+0x1e4>
    2f76:	28 31       	cpi	r18, 0x18	; 24
    2f78:	19 f4       	brne	.+6      	; 0x2f80 <PM_InterpretAVRISPPacket+0x1b2>
    2f7a:	22 e3       	ldi	r18, 0x32	; 50
    2f7c:	30 e0       	ldi	r19, 0x00	; 0
    2f7e:	02 c0       	rjmp	.+4      	; 0x2f84 <PM_InterpretAVRISPPacket+0x1b6>
    2f80:	2a e5       	ldi	r18, 0x5A	; 90
    2f82:	30 e0       	ldi	r19, 0x00	; 0
    2f84:	80 ea       	ldi	r24, 0xA0	; 160
    2f86:	90 e0       	ldi	r25, 0x00	; 0
    2f88:	48 9f       	mul	r20, r24
    2f8a:	d0 01       	movw	r26, r0
    2f8c:	49 9f       	mul	r20, r25
    2f8e:	b0 0d       	add	r27, r0
    2f90:	58 9f       	mul	r21, r24
    2f92:	b0 0d       	add	r27, r0
    2f94:	11 24       	eor	r1, r1
    2f96:	a2 0f       	add	r26, r18
    2f98:	b3 1f       	adc	r27, r19
    2f9a:	80 91 4c 01 	lds	r24, 0x014C
    2f9e:	28 e2       	ldi	r18, 0x28	; 40
    2fa0:	82 9f       	mul	r24, r18
    2fa2:	c0 01       	movw	r24, r0
    2fa4:	11 24       	eor	r1, r1
    2fa6:	a8 0f       	add	r26, r24
    2fa8:	b9 1f       	adc	r27, r25
    2faa:	98 97       	sbiw	r26, 0x28	; 40
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2fac:	0e 94 24 1a 	call	0x3448	; 0x3448 <__eeprom_read_byte_1F2021>
    2fb0:	80 2d       	mov	r24, r0
    2fb2:	80 93 4d 01 	sts	0x014D, r24
    2fb6:	10 92 4c 01 	sts	0x014C, r1
    2fba:	10 92 4e 01 	sts	0x014E, r1
    2fbe:	4f 5f       	subi	r20, 0xFF	; 255
    2fc0:	5f 4f       	sbci	r21, 0xFF	; 255
    2fc2:	50 93 3e 01 	sts	0x013E, r21
    2fc6:	40 93 3d 01 	sts	0x013D, r20
    2fca:	2a c1       	rjmp	.+596    	; 0x3220 <PM_InterpretAVRISPPacket+0x452>
    2fcc:	83 e0       	ldi	r24, 0x03	; 3
    2fce:	90 e0       	ldi	r25, 0x00	; 0
    2fd0:	90 93 61 02 	sts	0x0261, r25
    2fd4:	80 93 60 02 	sts	0x0260, r24
    2fd8:	80 91 69 02 	lds	r24, 0x0269
    2fdc:	83 30       	cpi	r24, 0x03	; 3
    2fde:	39 f0       	breq	.+14     	; 0x2fee <PM_InterpretAVRISPPacket+0x220>
    2fe0:	83 e0       	ldi	r24, 0x03	; 3
    2fe2:	80 93 69 02 	sts	0x0269, r24
    2fe6:	10 92 3e 01 	sts	0x013E, r1
    2fea:	10 92 3d 01 	sts	0x013D, r1
    2fee:	40 91 3d 01 	lds	r20, 0x013D
    2ff2:	50 91 3e 01 	lds	r21, 0x013E
    2ff6:	27 31       	cpi	r18, 0x17	; 23
    2ff8:	69 f4       	brne	.+26     	; 0x3014 <PM_InterpretAVRISPPacket+0x246>
    2ffa:	80 ea       	ldi	r24, 0xA0	; 160
    2ffc:	90 e0       	ldi	r25, 0x00	; 0
    2ffe:	48 9f       	mul	r20, r24
    3000:	90 01       	movw	r18, r0
    3002:	49 9f       	mul	r20, r25
    3004:	30 0d       	add	r19, r0
    3006:	58 9f       	mul	r21, r24
    3008:	30 0d       	add	r19, r0
    300a:	11 24       	eor	r1, r1
    300c:	2e 5c       	subi	r18, 0xCE	; 206
    300e:	3f 4f       	sbci	r19, 0xFF	; 255
    3010:	82 e0       	ldi	r24, 0x02	; 2
    3012:	0c c0       	rjmp	.+24     	; 0x302c <PM_InterpretAVRISPPacket+0x25e>
    3014:	80 ea       	ldi	r24, 0xA0	; 160
    3016:	90 e0       	ldi	r25, 0x00	; 0
    3018:	48 9f       	mul	r20, r24
    301a:	90 01       	movw	r18, r0
    301c:	49 9f       	mul	r20, r25
    301e:	30 0d       	add	r19, r0
    3020:	58 9f       	mul	r21, r24
    3022:	30 0d       	add	r19, r0
    3024:	11 24       	eor	r1, r1
    3026:	26 5a       	subi	r18, 0xA6	; 166
    3028:	3f 4f       	sbci	r19, 0xFF	; 255
    302a:	83 e0       	ldi	r24, 0x03	; 3
    302c:	80 93 68 02 	sts	0x0268, r24
    3030:	80 91 3d 01 	lds	r24, 0x013D
    3034:	90 91 3e 01 	lds	r25, 0x013E
    3038:	0a 97       	sbiw	r24, 0x0a	; 10
    303a:	b0 f4       	brcc	.+44     	; 0x3068 <PM_InterpretAVRISPPacket+0x29a>
    303c:	ec e4       	ldi	r30, 0x4C	; 76
    303e:	f1 e0       	ldi	r31, 0x01	; 1

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    3040:	81 91       	ld	r24, Z+
    3042:	d9 01       	movw	r26, r18
    3044:	08 2e       	mov	r0, r24
    3046:	0e 94 36 1a 	call	0x346c	; 0x346c <__eeprom_write_byte_1F2021>
    304a:	2f 5f       	subi	r18, 0xFF	; 255
    304c:	3f 4f       	sbci	r19, 0xFF	; 255
    304e:	81 e0       	ldi	r24, 0x01	; 1
    3050:	e0 35       	cpi	r30, 0x50	; 80
    3052:	f8 07       	cpc	r31, r24
    3054:	a9 f7       	brne	.-22     	; 0x3040 <PM_InterpretAVRISPPacket+0x272>
    3056:	80 91 3d 01 	lds	r24, 0x013D
    305a:	90 91 3e 01 	lds	r25, 0x013E
    305e:	01 96       	adiw	r24, 0x01	; 1
    3060:	90 93 3e 01 	sts	0x013E, r25
    3064:	80 93 3d 01 	sts	0x013D, r24
    3068:	10 92 4c 01 	sts	0x014C, r1
    306c:	10 92 4d 01 	sts	0x014D, r1
    3070:	d7 c0       	rjmp	.+430    	; 0x3220 <PM_InterpretAVRISPPacket+0x452>
    3072:	82 e0       	ldi	r24, 0x02	; 2
    3074:	90 e0       	ldi	r25, 0x00	; 0
    3076:	90 93 61 02 	sts	0x0261, r25
    307a:	80 93 60 02 	sts	0x0260, r24
    307e:	80 91 69 02 	lds	r24, 0x0269
    3082:	81 30       	cpi	r24, 0x01	; 1
    3084:	09 f1       	breq	.+66     	; 0x30c8 <PM_InterpretAVRISPPacket+0x2fa>
    3086:	23 31       	cpi	r18, 0x13	; 19
    3088:	31 f4       	brne	.+12     	; 0x3096 <PM_InterpretAVRISPPacket+0x2c8>
    308a:	81 e0       	ldi	r24, 0x01	; 1
    308c:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <PM_SetupDFAddressCounters>
    3090:	c3 e0       	ldi	r28, 0x03	; 3
    3092:	d0 e0       	ldi	r29, 0x00	; 0
    3094:	05 c0       	rjmp	.+10     	; 0x30a0 <PM_InterpretAVRISPPacket+0x2d2>
    3096:	80 e0       	ldi	r24, 0x00	; 0
    3098:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <PM_SetupDFAddressCounters>
    309c:	cc e0       	ldi	r28, 0x0C	; 12
    309e:	d0 e0       	ldi	r29, 0x00	; 0
    30a0:	80 91 3d 01 	lds	r24, 0x013D
    30a4:	90 91 3e 01 	lds	r25, 0x013E
    30a8:	0e 94 66 0a 	call	0x14cc	; 0x14cc <DF_BufferWriteEnable>
    30ac:	81 e0       	ldi	r24, 0x01	; 1
    30ae:	80 93 69 02 	sts	0x0269, r24
    30b2:	ec e4       	ldi	r30, 0x4C	; 76
    30b4:	f1 e0       	ldi	r31, 0x01	; 1

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    30b6:	81 91       	ld	r24, Z+
    30b8:	de 01       	movw	r26, r28
    30ba:	08 2e       	mov	r0, r24
    30bc:	0e 94 36 1a 	call	0x346c	; 0x346c <__eeprom_write_byte_1F2021>
    30c0:	91 e0       	ldi	r25, 0x01	; 1
    30c2:	e5 35       	cpi	r30, 0x55	; 85
    30c4:	f9 07       	cpc	r31, r25
    30c6:	b9 f7       	brne	.-18     	; 0x30b6 <PM_InterpretAVRISPPacket+0x2e8>
    30c8:	80 91 4c 01 	lds	r24, 0x014C
    30cc:	99 27       	eor	r25, r25
    30ce:	d8 2f       	mov	r29, r24
    30d0:	cc 27       	eor	r28, r28
    30d2:	80 91 4d 01 	lds	r24, 0x014D
    30d6:	99 27       	eor	r25, r25
    30d8:	c8 2b       	or	r28, r24
    30da:	d9 2b       	or	r29, r25
    30dc:	0b e4       	ldi	r16, 0x4B	; 75
    30de:	11 e0       	ldi	r17, 0x01	; 1
    30e0:	06 c0       	rjmp	.+12     	; 0x30ee <PM_InterpretAVRISPPacket+0x320>
    30e2:	f8 01       	movw	r30, r16
    30e4:	82 85       	ldd	r24, Z+10	; 0x0a
    30e6:	0e 94 ba 14 	call	0x2974	; 0x2974 <PM_StoreProgramByte>
    30ea:	0f 5f       	subi	r16, 0xFF	; 255
    30ec:	1f 4f       	sbci	r17, 0xFF	; 255
    30ee:	ce 01       	movw	r24, r28
    30f0:	85 5b       	subi	r24, 0xB5	; 181
    30f2:	9e 4f       	sbci	r25, 0xFE	; 254
    30f4:	08 17       	cp	r16, r24
    30f6:	19 07       	cpc	r17, r25
    30f8:	a1 f7       	brne	.-24     	; 0x30e2 <PM_InterpretAVRISPPacket+0x314>
    30fa:	20 91 6a 02 	lds	r18, 0x026A
    30fe:	30 91 6b 02 	lds	r19, 0x026B
    3102:	37 fd       	sbrc	r19, 7
    3104:	c4 ce       	rjmp	.-632    	; 0x2e8e <PM_InterpretAVRISPPacket+0xc0>
    3106:	80 91 4e 01 	lds	r24, 0x014E
    310a:	87 ff       	sbrs	r24, 7
    310c:	c0 ce       	rjmp	.-640    	; 0x2e8e <PM_InterpretAVRISPPacket+0xc0>
    310e:	21 15       	cp	r18, r1
    3110:	31 05       	cpc	r19, r1
    3112:	09 f4       	brne	.+2      	; 0x3116 <PM_InterpretAVRISPPacket+0x348>
    3114:	bc ce       	rjmp	.-648    	; 0x2e8e <PM_InterpretAVRISPPacket+0xc0>
    3116:	80 91 68 02 	lds	r24, 0x0268
    311a:	81 30       	cpi	r24, 0x01	; 1
    311c:	19 f4       	brne	.+6      	; 0x3124 <PM_InterpretAVRISPPacket+0x356>
    311e:	a2 e8       	ldi	r26, 0x82	; 130
    3120:	b0 e0       	ldi	r27, 0x00	; 0
    3122:	02 c0       	rjmp	.+4      	; 0x3128 <PM_InterpretAVRISPPacket+0x35a>
    3124:	a4 e8       	ldi	r26, 0x84	; 132
    3126:	b0 e0       	ldi	r27, 0x00	; 0

void 
eeprom_write_word (uint16_t *addr,uint16_t value)
{
  asm volatile (
    3128:	09 01       	movw	r0, r18
    312a:	0e 94 42 1a 	call	0x3484	; 0x3484 <__eeprom_write_word_1F2021>
    312e:	80 91 6a 02 	lds	r24, 0x026A
    3132:	90 91 6b 02 	lds	r25, 0x026B
    3136:	90 68       	ori	r25, 0x80	; 128
    3138:	90 93 6b 02 	sts	0x026B, r25
    313c:	80 93 6a 02 	sts	0x026A, r24
    3140:	a6 ce       	rjmp	.-692    	; 0x2e8e <PM_InterpretAVRISPPacket+0xc0>
    3142:	80 91 69 02 	lds	r24, 0x0269
    3146:	82 30       	cpi	r24, 0x02	; 2
    3148:	01 f1       	breq	.+64     	; 0x318a <PM_InterpretAVRISPPacket+0x3bc>
    314a:	0e 94 1b 14 	call	0x2836	; 0x2836 <PM_CheckEndOfFuseLockData>
    314e:	90 e0       	ldi	r25, 0x00	; 0
    3150:	80 91 4b 01 	lds	r24, 0x014B
    3154:	84 31       	cpi	r24, 0x14	; 20
    3156:	09 f4       	brne	.+2      	; 0x315a <PM_InterpretAVRISPPacket+0x38c>
    3158:	91 e0       	ldi	r25, 0x01	; 1
    315a:	89 2f       	mov	r24, r25
    315c:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <PM_SetupDFAddressCounters>
    3160:	60 91 3d 01 	lds	r22, 0x013D
    3164:	70 91 3e 01 	lds	r23, 0x013E
    3168:	80 91 3b 01 	lds	r24, 0x013B
    316c:	90 91 3c 01 	lds	r25, 0x013C
    3170:	0e 94 2b 0a 	call	0x1456	; 0x1456 <DF_ContinuousReadEnable>
    3174:	82 e0       	ldi	r24, 0x02	; 2
    3176:	80 93 69 02 	sts	0x0269, r24
    317a:	10 92 63 02 	sts	0x0263, r1
    317e:	10 92 64 02 	sts	0x0264, r1
    3182:	10 92 65 02 	sts	0x0265, r1
    3186:	10 92 66 02 	sts	0x0266, r1
    318a:	80 91 4c 01 	lds	r24, 0x014C
    318e:	99 27       	eor	r25, r25
    3190:	d8 2f       	mov	r29, r24
    3192:	cc 27       	eor	r28, r28
    3194:	80 91 4d 01 	lds	r24, 0x014D
    3198:	99 27       	eor	r25, r25
    319a:	c8 2b       	or	r28, r24
    319c:	d9 2b       	or	r29, r25
    319e:	90 e0       	ldi	r25, 0x00	; 0
    31a0:	80 91 4b 01 	lds	r24, 0x014B
    31a4:	84 31       	cpi	r24, 0x14	; 20
    31a6:	09 f4       	brne	.+2      	; 0x31aa <PM_InterpretAVRISPPacket+0x3dc>
    31a8:	91 e0       	ldi	r25, 0x01	; 1
    31aa:	89 2f       	mov	r24, r25
    31ac:	0e 94 85 14 	call	0x290a	; 0x290a <PM_GetStoredDataSize>
    31b0:	7b 01       	movw	r14, r22
    31b2:	0b e4       	ldi	r16, 0x4B	; 75
    31b4:	11 e0       	ldi	r17, 0x01	; 1
    31b6:	1b c0       	rjmp	.+54     	; 0x31ee <PM_InterpretAVRISPPacket+0x420>
    31b8:	97 01       	movw	r18, r14
    31ba:	44 27       	eor	r20, r20
    31bc:	55 27       	eor	r21, r21
    31be:	80 91 63 02 	lds	r24, 0x0263
    31c2:	90 91 64 02 	lds	r25, 0x0264
    31c6:	a0 91 65 02 	lds	r26, 0x0265
    31ca:	b0 91 66 02 	lds	r27, 0x0266
    31ce:	82 17       	cp	r24, r18
    31d0:	93 07       	cpc	r25, r19
    31d2:	a4 07       	cpc	r26, r20
    31d4:	b5 07       	cpc	r27, r21
    31d6:	10 f0       	brcs	.+4      	; 0x31dc <PM_InterpretAVRISPPacket+0x40e>
    31d8:	8f ef       	ldi	r24, 0xFF	; 255
    31da:	03 c0       	rjmp	.+6      	; 0x31e2 <PM_InterpretAVRISPPacket+0x414>
    31dc:	80 e0       	ldi	r24, 0x00	; 0
    31de:	0e 94 52 09 	call	0x12a4	; 0x12a4 <SPI_SPITransmit>
    31e2:	f8 01       	movw	r30, r16
    31e4:	82 83       	std	Z+2, r24	; 0x02
    31e6:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <V2P_IncrementCurrAddress>
    31ea:	0f 5f       	subi	r16, 0xFF	; 255
    31ec:	1f 4f       	sbci	r17, 0xFF	; 255
    31ee:	ce 01       	movw	r24, r28
    31f0:	85 5b       	subi	r24, 0xB5	; 181
    31f2:	9e 4f       	sbci	r25, 0xFE	; 254
    31f4:	08 17       	cp	r16, r24
    31f6:	19 07       	cpc	r17, r25
    31f8:	f9 f6       	brne	.-66     	; 0x31b8 <PM_InterpretAVRISPPacket+0x3ea>
    31fa:	23 96       	adiw	r28, 0x03	; 3
    31fc:	d0 93 61 02 	sts	0x0261, r29
    3200:	c0 93 60 02 	sts	0x0260, r28
    3204:	10 92 4c 01 	sts	0x014C, r1
    3208:	f8 01       	movw	r30, r16
    320a:	12 82       	std	Z+2, r1	; 0x02
    320c:	09 c0       	rjmp	.+18     	; 0x3220 <PM_InterpretAVRISPPacket+0x452>
    320e:	81 e0       	ldi	r24, 0x01	; 1
    3210:	90 e0       	ldi	r25, 0x00	; 0
    3212:	90 93 61 02 	sts	0x0261, r25
    3216:	80 93 60 02 	sts	0x0260, r24
    321a:	89 ec       	ldi	r24, 0xC9	; 201
    321c:	80 93 4c 01 	sts	0x014C, r24
    3220:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <V2P_SendPacket>
    3224:	df 91       	pop	r29
    3226:	cf 91       	pop	r28
    3228:	1f 91       	pop	r17
    322a:	0f 91       	pop	r16
    322c:	ff 90       	pop	r15
    322e:	ef 90       	pop	r14
    3230:	08 95       	ret

00003232 <TM_FindNextTag>:
	DF_EnableDataflash(FALSE);
}

void TM_FindNextTag(void)
{
    3232:	cf 92       	push	r12
    3234:	df 92       	push	r13
    3236:	ef 92       	push	r14
    3238:	ff 92       	push	r15
    323a:	0f 93       	push	r16
    323c:	1f 93       	push	r17
    323e:	cf 93       	push	r28
    3240:	df 93       	push	r29
    3242:	cd b7       	in	r28, 0x3d	; 61
    3244:	de b7       	in	r29, 0x3e	; 62
    3246:	69 97       	sbiw	r28, 0x19	; 25
    3248:	0f b6       	in	r0, 0x3f	; 63
    324a:	f8 94       	cli
    324c:	de bf       	out	0x3e, r29	; 62
    324e:	0f be       	out	0x3f, r0	; 63
    3250:	cd bf       	out	0x3d, r28	; 61
	uint8_t  Buffer[21];
	uint8_t  HeadBuff[4]      = BT_TAGHEADER;
    3252:	80 e4       	ldi	r24, 0x40	; 64
    3254:	89 83       	std	Y+1, r24	; 0x01
    3256:	88 e2       	ldi	r24, 0x28	; 40
    3258:	8a 83       	std	Y+2, r24	; 0x02
    325a:	83 e2       	ldi	r24, 0x23	; 35
    325c:	8b 83       	std	Y+3, r24	; 0x03
    325e:	89 e2       	ldi	r24, 0x29	; 41
    3260:	8c 83       	std	Y+4, r24	; 0x04
	uint32_t ProgDataSize     = PM_GetStoredDataSize(TYPE_FLASH);
    3262:	81 e0       	ldi	r24, 0x01	; 1
    3264:	0e 94 85 14 	call	0x290a	; 0x290a <PM_GetStoredDataSize>
    3268:	6b 01       	movw	r12, r22
    326a:	7c 01       	movw	r14, r24
	uint8_t  TotalOkHeadBytes = 0;
	uint8_t  TagByte;
	uint8_t  BytesRead;
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);    // Orange = busy
    326c:	81 b3       	in	r24, 0x11	; 17
    326e:	8f 7c       	andi	r24, 0xCF	; 207
    3270:	80 63       	ori	r24, 0x30	; 48
    3272:	81 bb       	out	0x11, r24	; 17

	while (DFPos < ProgDataSize)
	{
		BytesRead = 1;
		
		TagByte = SPI_SPITransmit(0x00);       // Get next byte from dataflash
		if (TagByte == HeadBuff[TotalOkHeadBytes++])
		{
			if (TotalOkHeadBytes == 4)
			{
				uint8_t HB;
			
				for (HB = 0; HB < 20; HB++)
				{
					TagByte = SPI_SPITransmit(0x00);
					Buffer[HB] = TagByte;
					
					if (TagByte == 0x00)
					  break;
				}
				
				Buffer[20] = '\0';             // Make sure string is null-terminated

				TagExists = TRUE;
				BytesRead = (HB + 2);

				LCD_puts(Buffer);
				MAIN_SETSTATUSLED(MAIN_STATLED_GREEN); // Green = ready
				return;
			}
		}
		else
		{
			TotalOkHeadBytes = ((TagByte == HeadBuff[0])? 1 : 0);
    3274:	09 81       	ldd	r16, Y+1	; 0x01
    3276:	10 e0       	ldi	r17, 0x00	; 0
    3278:	42 c0       	rjmp	.+132    	; 0x32fe <TM_FindNextTag+0xcc>
    327a:	80 e0       	ldi	r24, 0x00	; 0
    327c:	0e 94 52 09 	call	0x12a4	; 0x12a4 <SPI_SPITransmit>
    3280:	98 2f       	mov	r25, r24
    3282:	fe 01       	movw	r30, r28
    3284:	e1 0f       	add	r30, r17
    3286:	f1 1d       	adc	r31, r1
    3288:	81 81       	ldd	r24, Z+1	; 0x01
    328a:	98 17       	cp	r25, r24
    328c:	09 f5       	brne	.+66     	; 0x32d0 <TM_FindNextTag+0x9e>
    328e:	1f 5f       	subi	r17, 0xFF	; 255
    3290:	14 30       	cpi	r17, 0x04	; 4
    3292:	11 f5       	brne	.+68     	; 0x32d8 <TM_FindNextTag+0xa6>
    3294:	8e 01       	movw	r16, r28
    3296:	0b 5f       	subi	r16, 0xFB	; 251
    3298:	1f 4f       	sbci	r17, 0xFF	; 255
    329a:	80 e0       	ldi	r24, 0x00	; 0
    329c:	0e 94 52 09 	call	0x12a4	; 0x12a4 <SPI_SPITransmit>
    32a0:	f8 01       	movw	r30, r16
    32a2:	80 83       	st	Z, r24
    32a4:	88 23       	and	r24, r24
    32a6:	39 f0       	breq	.+14     	; 0x32b6 <TM_FindNextTag+0x84>
    32a8:	0f 5f       	subi	r16, 0xFF	; 255
    32aa:	1f 4f       	sbci	r17, 0xFF	; 255
    32ac:	ce 01       	movw	r24, r28
    32ae:	49 96       	adiw	r24, 0x19	; 25
    32b0:	08 17       	cp	r16, r24
    32b2:	19 07       	cpc	r17, r25
    32b4:	91 f7       	brne	.-28     	; 0x329a <TM_FindNextTag+0x68>
    32b6:	19 8e       	std	Y+25, r1	; 0x19
    32b8:	81 e0       	ldi	r24, 0x01	; 1
    32ba:	80 93 6c 02 	sts	0x026C, r24
    32be:	ce 01       	movw	r24, r28
    32c0:	05 96       	adiw	r24, 0x05	; 5
    32c2:	0e 94 15 08 	call	0x102a	; 0x102a <LCD_puts>
    32c6:	81 b3       	in	r24, 0x11	; 17
    32c8:	8f 7c       	andi	r24, 0xCF	; 207
    32ca:	80 61       	ori	r24, 0x10	; 16
    32cc:	81 bb       	out	0x11, r24	; 17
    32ce:	42 c0       	rjmp	.+132    	; 0x3354 <TM_FindNextTag+0x122>
    32d0:	10 e0       	ldi	r17, 0x00	; 0
    32d2:	90 17       	cp	r25, r16
    32d4:	09 f4       	brne	.+2      	; 0x32d8 <TM_FindNextTag+0xa6>
    32d6:	11 e0       	ldi	r17, 0x01	; 1
		}

		DFPos += BytesRead;
    32d8:	80 91 6d 02 	lds	r24, 0x026D
    32dc:	90 91 6e 02 	lds	r25, 0x026E
    32e0:	a0 91 6f 02 	lds	r26, 0x026F
    32e4:	b0 91 70 02 	lds	r27, 0x0270
    32e8:	01 96       	adiw	r24, 0x01	; 1
    32ea:	a1 1d       	adc	r26, r1
    32ec:	b1 1d       	adc	r27, r1
    32ee:	80 93 6d 02 	sts	0x026D, r24
    32f2:	90 93 6e 02 	sts	0x026E, r25
    32f6:	a0 93 6f 02 	sts	0x026F, r26
    32fa:	b0 93 70 02 	sts	0x0270, r27
    32fe:	80 91 6d 02 	lds	r24, 0x026D
    3302:	90 91 6e 02 	lds	r25, 0x026E
    3306:	a0 91 6f 02 	lds	r26, 0x026F
    330a:	b0 91 70 02 	lds	r27, 0x0270
    330e:	8c 15       	cp	r24, r12
    3310:	9d 05       	cpc	r25, r13
    3312:	ae 05       	cpc	r26, r14
    3314:	bf 05       	cpc	r27, r15
    3316:	08 f4       	brcc	.+2      	; 0x331a <TM_FindNextTag+0xe8>
    3318:	b0 cf       	rjmp	.-160    	; 0x327a <TM_FindNextTag+0x48>
	}
	
	DF_ContinuousReadEnable(0, 0);
    331a:	60 e0       	ldi	r22, 0x00	; 0
    331c:	70 e0       	ldi	r23, 0x00	; 0
    331e:	80 e0       	ldi	r24, 0x00	; 0
    3320:	90 e0       	ldi	r25, 0x00	; 0
    3322:	0e 94 2b 0a 	call	0x1456	; 0x1456 <DF_ContinuousReadEnable>
	DFPos = 0;
    3326:	10 92 6d 02 	sts	0x026D, r1
    332a:	10 92 6e 02 	sts	0x026E, r1
    332e:	10 92 6f 02 	sts	0x026F, r1
    3332:	10 92 70 02 	sts	0x0270, r1
	
	if (TagExists == FALSE)
    3336:	80 91 6c 02 	lds	r24, 0x026C
    333a:	88 23       	and	r24, r24
    333c:	49 f4       	brne	.+18     	; 0x3350 <TM_FindNextTag+0x11e>
	{
		MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);  // Green = ready
    333e:	81 b3       	in	r24, 0x11	; 17
    3340:	8f 7c       	andi	r24, 0xCF	; 207
    3342:	80 61       	ori	r24, 0x10	; 16
    3344:	81 bb       	out	0x11, r24	; 17
		MAIN_ShowError(PSTR("NO TAGS"));
    3346:	83 e3       	ldi	r24, 0x33	; 51
    3348:	94 e0       	ldi	r25, 0x04	; 4
    334a:	0e 94 92 03 	call	0x724	; 0x724 <MAIN_ShowError>
    334e:	02 c0       	rjmp	.+4      	; 0x3354 <TM_FindNextTag+0x122>
	}
	else
	{
		/* The following line _is_ recursion, but the function will only ever call itself
		   a maximum of one time. The function will call itself upon skipping from the last
		   tag stored in the program data to the first; to guard against infinite recursion
		   if no tags are present, the system will error out if the TagExists flag is empty
		   after a full data read. Once a tag has been read and displayed onto the LCD, the
           function returns to the main tag handling routine.                               */
		TM_FindNextTag();
    3350:	0e 94 19 19 	call	0x3232	; 0x3232 <TM_FindNextTag>
    3354:	69 96       	adiw	r28, 0x19	; 25
    3356:	0f b6       	in	r0, 0x3f	; 63
    3358:	f8 94       	cli
    335a:	de bf       	out	0x3e, r29	; 62
    335c:	0f be       	out	0x3f, r0	; 63
    335e:	cd bf       	out	0x3d, r28	; 61
    3360:	df 91       	pop	r29
    3362:	cf 91       	pop	r28
    3364:	1f 91       	pop	r17
    3366:	0f 91       	pop	r16
    3368:	ff 90       	pop	r15
    336a:	ef 90       	pop	r14
    336c:	df 90       	pop	r13
    336e:	cf 90       	pop	r12
    3370:	08 95       	ret

00003372 <TM_ShowTags>:
    3372:	60 e0       	ldi	r22, 0x00	; 0
    3374:	70 e0       	ldi	r23, 0x00	; 0
    3376:	80 e0       	ldi	r24, 0x00	; 0
    3378:	90 e0       	ldi	r25, 0x00	; 0
    337a:	0e 94 2b 0a 	call	0x1456	; 0x1456 <DF_ContinuousReadEnable>
    337e:	10 92 6c 02 	sts	0x026C, r1
    3382:	10 92 6d 02 	sts	0x026D, r1
    3386:	10 92 6e 02 	sts	0x026E, r1
    338a:	10 92 6f 02 	sts	0x026F, r1
    338e:	10 92 70 02 	sts	0x0270, r1
    3392:	0e 94 19 19 	call	0x3232	; 0x3232 <TM_FindNextTag>
    3396:	80 91 6c 02 	lds	r24, 0x026C
    339a:	88 23       	and	r24, r24
    339c:	71 f0       	breq	.+28     	; 0x33ba <TM_ShowTags+0x48>
    339e:	8e b3       	in	r24, 0x1e	; 30
    33a0:	88 23       	and	r24, r24
    33a2:	e9 f3       	breq	.-6      	; 0x339e <TM_ShowTags+0x2c>
    33a4:	f7 9b       	sbis	0x1e, 7	; 30
    33a6:	03 c0       	rjmp	.+6      	; 0x33ae <TM_ShowTags+0x3c>
    33a8:	0e 94 19 19 	call	0x3232	; 0x3232 <TM_FindNextTag>
    33ac:	02 c0       	rjmp	.+4      	; 0x33b2 <TM_ShowTags+0x40>
    33ae:	f2 99       	sbic	0x1e, 2	; 30
    33b0:	03 c0       	rjmp	.+6      	; 0x33b8 <TM_ShowTags+0x46>
    33b2:	0e 94 68 02 	call	0x4d0	; 0x4d0 <MAIN_WaitForJoyRelease>
    33b6:	f3 cf       	rjmp	.-26     	; 0x339e <TM_ShowTags+0x2c>
    33b8:	80 e0       	ldi	r24, 0x00	; 0
    33ba:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <DF_EnableDataflash>
    33be:	08 95       	ret

000033c0 <__vector_2>:
.global PCINT0_vect             ; Pin change 0 (joystick)
.global PCINT1_vect             ; Pin change 1 (joystick)

PCINT0_vect:
  jmp PCINT1_vect
    33c0:	0c 94 91 02 	jmp	0x522	; 0x522 <__vector_3>

000033c4 <__vector_10>:

.global TIMER0_COMP_vect             ; Timer 0 compare

TIMER0_COMP_vect:
  push r24
    33c4:	8f 93       	push	r24
  ldi r24, (USI_CONTROL_REG_FLAGS | (1<<USITC))
    33c6:	8b e5       	ldi	r24, 0x5B	; 91
  sts _SFR_MEM_ADDR(USICR), r24
    33c8:	80 93 b8 00 	sts	0x00B8, r24
  pop r24
    33cc:	8f 91       	pop	r24
  reti
    33ce:	18 95       	reti

000033d0 <strcpy_P>:
    33d0:	fb 01       	movw	r30, r22
    33d2:	dc 01       	movw	r26, r24
    33d4:	05 90       	lpm	r0, Z+
    33d6:	0d 92       	st	X+, r0
    33d8:	00 20       	and	r0, r0
    33da:	e1 f7       	brne	.-8      	; 0x33d4 <strcpy_P+0x4>
    33dc:	08 95       	ret

000033de <ultoa>:
    33de:	fa 01       	movw	r30, r20
    33e0:	cf 93       	push	r28
    33e2:	ff 93       	push	r31
    33e4:	ef 93       	push	r30
    33e6:	22 30       	cpi	r18, 0x02	; 2
    33e8:	cc f0       	brlt	.+50     	; 0x341c <ultoa+0x3e>
    33ea:	25 32       	cpi	r18, 0x25	; 37
    33ec:	bc f4       	brge	.+46     	; 0x341c <ultoa+0x3e>
    33ee:	c2 2f       	mov	r28, r18
    33f0:	2c 2f       	mov	r18, r28
    33f2:	33 27       	eor	r19, r19
    33f4:	44 27       	eor	r20, r20
    33f6:	55 27       	eor	r21, r21
    33f8:	ff 93       	push	r31
    33fa:	ef 93       	push	r30
    33fc:	0e 94 4c 1a 	call	0x3498	; 0x3498 <__udivmodsi4>
    3400:	ef 91       	pop	r30
    3402:	ff 91       	pop	r31
    3404:	60 5d       	subi	r22, 0xD0	; 208
    3406:	6a 33       	cpi	r22, 0x3A	; 58
    3408:	0c f0       	brlt	.+2      	; 0x340c <ultoa+0x2e>
    340a:	69 5d       	subi	r22, 0xD9	; 217
    340c:	61 93       	st	Z+, r22
    340e:	b9 01       	movw	r22, r18
    3410:	ca 01       	movw	r24, r20
    3412:	60 50       	subi	r22, 0x00	; 0
    3414:	70 40       	sbci	r23, 0x00	; 0
    3416:	80 40       	sbci	r24, 0x00	; 0
    3418:	90 40       	sbci	r25, 0x00	; 0
    341a:	51 f7       	brne	.-44     	; 0x33f0 <ultoa+0x12>
    341c:	10 82       	st	Z, r1
    341e:	8f 91       	pop	r24
    3420:	9f 91       	pop	r25
    3422:	cf 91       	pop	r28
    3424:	0c 94 14 1a 	jmp	0x3428	; 0x3428 <strrev>

00003428 <strrev>:
    3428:	dc 01       	movw	r26, r24
    342a:	fc 01       	movw	r30, r24
    342c:	01 90       	ld	r0, Z+
    342e:	00 20       	and	r0, r0
    3430:	e9 f7       	brne	.-6      	; 0x342c <strrev+0x4>
    3432:	32 97       	sbiw	r30, 0x02	; 2
    3434:	ae 17       	cp	r26, r30
    3436:	bf 07       	cpc	r27, r31
    3438:	30 f4       	brcc	.+12     	; 0x3446 <strrev+0x1e>
    343a:	7c 91       	ld	r23, X
    343c:	60 81       	ld	r22, Z
    343e:	70 83       	st	Z, r23
    3440:	31 97       	sbiw	r30, 0x01	; 1
    3442:	6d 93       	st	X+, r22
    3444:	f7 cf       	rjmp	.-18     	; 0x3434 <strrev+0xc>
    3446:	08 95       	ret

00003448 <__eeprom_read_byte_1F2021>:
    3448:	f9 99       	sbic	0x1f, 1	; 31
    344a:	fe cf       	rjmp	.-4      	; 0x3448 <__eeprom_read_byte_1F2021>
    344c:	b2 bd       	out	0x22, r27	; 34
    344e:	a1 bd       	out	0x21, r26	; 33
    3450:	f8 9a       	sbi	0x1f, 0	; 31
    3452:	11 96       	adiw	r26, 0x01	; 1
    3454:	00 b4       	in	r0, 0x20	; 32
    3456:	08 95       	ret

00003458 <__eeprom_read_block_1F2021>:
    3458:	f7 df       	rcall	.-18     	; 0x3448 <__eeprom_read_byte_1F2021>
    345a:	01 92       	st	Z+, r0
    345c:	1a 94       	dec	r1
    345e:	e1 f7       	brne	.-8      	; 0x3458 <__eeprom_read_block_1F2021>
    3460:	08 95       	ret

00003462 <__eeprom_read_word_1F2021>:
    3462:	f2 df       	rcall	.-28     	; 0x3448 <__eeprom_read_byte_1F2021>
    3464:	e0 2d       	mov	r30, r0
    3466:	f0 df       	rcall	.-32     	; 0x3448 <__eeprom_read_byte_1F2021>
    3468:	f0 2d       	mov	r31, r0
    346a:	08 95       	ret

0000346c <__eeprom_write_byte_1F2021>:
    346c:	f9 99       	sbic	0x1f, 1	; 31
    346e:	fe cf       	rjmp	.-4      	; 0x346c <__eeprom_write_byte_1F2021>
    3470:	b2 bd       	out	0x22, r27	; 34
    3472:	a1 bd       	out	0x21, r26	; 33
    3474:	00 bc       	out	0x20, r0	; 32
    3476:	11 96       	adiw	r26, 0x01	; 1
    3478:	0f b6       	in	r0, 0x3f	; 63
    347a:	f8 94       	cli
    347c:	fa 9a       	sbi	0x1f, 2	; 31
    347e:	f9 9a       	sbi	0x1f, 1	; 31
    3480:	0f be       	out	0x3f, r0	; 63
    3482:	08 95       	ret

00003484 <__eeprom_write_word_1F2021>:
    3484:	f3 df       	rcall	.-26     	; 0x346c <__eeprom_write_byte_1F2021>
    3486:	01 2c       	mov	r0, r1
    3488:	f1 df       	rcall	.-30     	; 0x346c <__eeprom_write_byte_1F2021>
    348a:	11 24       	eor	r1, r1
    348c:	08 95       	ret

0000348e <__eeprom_write_block_1F2021>:
    348e:	01 90       	ld	r0, Z+
    3490:	ed df       	rcall	.-38     	; 0x346c <__eeprom_write_byte_1F2021>
    3492:	1a 94       	dec	r1
    3494:	e1 f7       	brne	.-8      	; 0x348e <__eeprom_write_block_1F2021>
    3496:	08 95       	ret

00003498 <__udivmodsi4>:
    3498:	a1 e2       	ldi	r26, 0x21	; 33
    349a:	1a 2e       	mov	r1, r26
    349c:	aa 1b       	sub	r26, r26
    349e:	bb 1b       	sub	r27, r27
    34a0:	fd 01       	movw	r30, r26
    34a2:	0d c0       	rjmp	.+26     	; 0x34be <__udivmodsi4_ep>

000034a4 <__udivmodsi4_loop>:
    34a4:	aa 1f       	adc	r26, r26
    34a6:	bb 1f       	adc	r27, r27
    34a8:	ee 1f       	adc	r30, r30
    34aa:	ff 1f       	adc	r31, r31
    34ac:	a2 17       	cp	r26, r18
    34ae:	b3 07       	cpc	r27, r19
    34b0:	e4 07       	cpc	r30, r20
    34b2:	f5 07       	cpc	r31, r21
    34b4:	20 f0       	brcs	.+8      	; 0x34be <__udivmodsi4_ep>
    34b6:	a2 1b       	sub	r26, r18
    34b8:	b3 0b       	sbc	r27, r19
    34ba:	e4 0b       	sbc	r30, r20
    34bc:	f5 0b       	sbc	r31, r21

000034be <__udivmodsi4_ep>:
    34be:	66 1f       	adc	r22, r22
    34c0:	77 1f       	adc	r23, r23
    34c2:	88 1f       	adc	r24, r24
    34c4:	99 1f       	adc	r25, r25
    34c6:	1a 94       	dec	r1
    34c8:	69 f7       	brne	.-38     	; 0x34a4 <__udivmodsi4_loop>
    34ca:	60 95       	com	r22
    34cc:	70 95       	com	r23
    34ce:	80 95       	com	r24
    34d0:	90 95       	com	r25
    34d2:	9b 01       	movw	r18, r22
    34d4:	ac 01       	movw	r20, r24
    34d6:	bd 01       	movw	r22, r26
    34d8:	cf 01       	movw	r24, r30
    34da:	08 95       	ret

000034dc <_exit>:
    34dc:	ff cf       	rjmp	.-2      	; 0x34dc <_exit>
