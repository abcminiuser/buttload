
ButtLoad.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000026  00800100  00003776  0000380a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003776  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b1  00800126  00800126  00003830  2**0
                  ALLOC
  3 .noinit       00000000  008002d7  008002d7  00003830  2**0
                  CONTENTS
  4 .eeprom       00000000  00810000  00810000  00003830  2**0
                  CONTENTS
  5 .stab         00000084  00000000  00000000  00003830  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      00000078  00000000  00000000  000038b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000140  00000000  00000000  0000392c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000faf  00000000  00000000  00003a6c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000034f5  00000000  00000000  00004a1b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00000e30  00000000  00000000  00007f10  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000030cf  00000000  00000000  00008d40  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00001119  00000000  00000000  0000be0f  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 12 02 	jmp	0x424 <__init>
       4:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
       8:	0c 94 36 1b 	jmp	0x366c <__vector_2>
       c:	0c 94 96 03 	jmp	0x72c <__vector_3>
      10:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      14:	0c 94 90 07 	jmp	0xf20 <__vector_5>
      18:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      1c:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      20:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      24:	0c 94 d8 0b 	jmp	0x17b0 <__vector_9>
      28:	0c 94 38 1b 	jmp	0x3670 <__vector_10>
      2c:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      30:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      34:	0c 94 17 09 	jmp	0x122e <__vector_13>
      38:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      3c:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      40:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      44:	0c 94 5c 09 	jmp	0x12b8 <__vector_17>
      48:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      4c:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      50:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      54:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      58:	0c 94 4d 08 	jmp	0x109a <__vector_22>

0000005c <SIFOOptionPtrs>:
      5c:	6f 00 60 00                                         o.`.

00000060 <SIFO_Tags>:
      60:	56 49 45 57 20 44 41 54 41 20 54 41 47 53 00        VIEW DATA TAGS.

0000006f <SIFO_Size>:
      6f:	53 54 4f 52 41 47 45 20 53 49 5a 45 53 00           STORAGE SIZES.

0000007d <USIPSNamePtrs>:
      7d:	a3 00 99 00 8f 00 85 00                             ........

00000085 <USI_Speed3>:
      85:	32 31 30 36 35 31 20 48 5a 00                       210651 HZ.

0000008f <USI_Speed2>:
      8f:	31 31 33 34 32 37 20 48 5a 00                       113427 HZ.

00000099 <USI_Speed1>:
      99:	20 38 36 37 33 38 20 48 5a 00                        86738 HZ.

000000a3 <USI_Speed0>:
      a3:	20 35 37 31 35 33 20 48 5a 00                        57153 HZ.

000000ad <ProgOptions>:
      ad:	16 01 0a 01 fa 00 ea 00 da 00 c6 00 bb 00           ..............

000000bb <PRG_C>:
      bb:	45 52 41 53 45 20 4f 4e 4c 59 00                    ERASE ONLY.

000000c6 <PRG_FL>:
      c6:	46 55 53 45 20 41 4e 44 20 4c 4f 43 4b 20 42 59     FUSE AND LOCK BY
      d6:	54 45 53 00                                         TES.

000000da <PRG_L>:
      da:	4c 4f 43 4b 20 42 59 54 45 53 20 4f 4e 4c 59 00     LOCK BYTES ONLY.

000000ea <PRG_F>:
      ea:	46 55 53 45 20 42 59 54 45 53 20 4f 4e 4c 59 00     FUSE BYTES ONLY.

000000fa <PRG_DE>:
      fa:	44 41 54 41 20 41 4e 44 20 45 45 50 52 4f 4d 00     DATA AND EEPROM.

0000010a <PRG_E>:
     10a:	45 45 50 52 4f 4d 20 4f 4e 4c 59 00                 EEPROM ONLY.

00000116 <PRG_D>:
     116:	44 41 54 41 20 4f 4e 4c 59 00                       DATA ONLY.

00000120 <SettingFunctionPtrs>:
     120:	3e 06 8a 06 88 05 dd 05 e4 05 31 07                 >.........1.

0000012c <SettingFunctionNames>:
     12c:	88 01 7a 01 6d 01 5e 01 4b 01 38 01                 ..z.m.^.K.8.

00000138 <SFunc_GOBOOTLOADER>:
     138:	4a 55 4d 50 20 54 4f 20 42 4f 4f 54 4c 4f 41 44     JUMP TO BOOTLOAD
     148:	45 52 00                                            ER.

0000014b <SFunc_MANCALIB>:
     14b:	4d 41 4e 55 41 4c 20 43 41 4c 49 42 52 41 54 49     MANUAL CALIBRATI
     15b:	4f 4e 00                                            ON.

0000015e <SFunc_AUTOCALIB>:
     15e:	41 55 54 4f 20 43 41 4c 49 42 52 41 54 45 00        AUTO CALIBRATE.

0000016d <SFunc_CLEARMEM>:
     16d:	43 4c 45 41 52 20 4d 45 4d 4f 52 59 00              CLEAR MEMORY.

0000017a <SFunc_SETSPISPEED>:
     17a:	53 45 54 20 53 50 49 20 53 50 45 45 44 00           SET SPI SPEED.

00000188 <SFunc_SETCONTRAST>:
     188:	53 45 54 20 43 4f 4e 54 52 41 53 54 00              SET CONTRAST.

00000195 <MainFunctionPtrs>:
     195:	e7 03 5d 05 18 04 f4 03 d9 06 b2 03 bf 06           ..]...........

000001a3 <MainFunctionNames>:
     1a3:	ff 01 f4 01 e8 01 d4 01 c5 01 bc 01 b1 01           ..............

000001b1 <Func_SLEEP>:
     1b1:	53 4c 45 45 50 20 4d 4f 44 45 00                    SLEEP MODE.

000001bc <Func_SETTINGS>:
     1bc:	53 45 54 54 49 4e 47 53 00                          SETTINGS.

000001c5 <Func_PRGMSTOREINFO>:
     1c5:	44 41 54 41 53 54 4f 52 45 20 49 4e 46 4f 00        DATASTORE INFO.

000001d4 <Func_PRGMDATAFLASH>:
     1d4:	44 41 54 41 46 4c 41 53 48 20 50 52 47 4d 20 4d     DATAFLASH PRGM M
     1e4:	4f 44 45 00                                         ODE.

000001e8 <Func_PRGMAVR>:
     1e8:	50 52 4f 47 52 41 4d 20 41 56 52 00                 PROGRAM AVR.

000001f4 <Func_STOREPRGM>:
     1f4:	53 54 4f 52 45 20 50 52 47 4d 00                    STORE PRGM.

000001ff <Func_ISPPRGM>:
     1ff:	41 56 52 49 53 50 20 4d 4f 44 45 00                 AVRISP MODE.

0000020b <AboutTextPtrs>:
     20b:	36 02 31 02 22 02 13 02                             6.1."...

00000213 <CopyRight>:
     213:	3c 43 3e 20 32 30 30 36 20 2d 20 47 50 4c 00        <C> 2006 - GPL.

00000222 <AuthorName>:
     222:	42 59 20 44 45 41 4e 20 43 41 4d 45 52 41 00        BY DEAN CAMERA.

00000231 <VersionInfo>:
     231:	56 31 2d 33 00                                      V1-3.

00000236 <ProgrammerName>:
     236:	42 55 54 54 4c 4f 41 44 00                          BUTTLOAD.

0000023f <WaitText>:
     23f:	2a 57 41 49 54 2a 00                                *WAIT*.

00000246 <BUTTTAG_Author>:
     246:	40 28 23 29 42 59 20 44 45 41 4e 20 43 41 4d 45     @(#)BY DEAN CAME
     256:	52 41 00                                            RA.

00000259 <BUTTTAG_Name>:
     259:	40 28 23 29 42 55 54 54 4c 4f 41 44 20 41 56 52     @(#)BUTTLOAD AVR
     269:	49 53 50 00                                         ISP.

0000026d <__c.14>:
     26d:	50 52 47 3e 20 00                                   PRG> .

00000273 <__c.13>:
     273:	42 41 44 49 53 52 00                                BADISR.

0000027a <__c.6>:
     27a:	4e 4f 20 45 52 41 53 45 20 43 4d 44 00              NO ERASE CMD.

00000287 <__c.7>:
     287:	4e 4f 20 44 41 54 41 00                             NO DATA.

0000028f <__c.8>:
     28f:	4e 4f 20 45 45 50 52 4f 4d 00                       NO EEPROM.

00000299 <__c.9>:
     299:	4e 4f 20 46 55 53 45 20 42 59 54 45 53 00           NO FUSE BYTES.

000002a7 <__c.10>:
     2a7:	4e 4f 20 4c 4f 43 4b 20 42 59 54 45 53 00           NO LOCK BYTES.

000002b5 <__c.11>:
     2b5:	50 52 4f 47 52 41 4d 4d 49 4e 47 20 44 4f 4e 45     PROGRAMMING DONE
	...

000002c6 <__c.12>:
     2c6:	46 41 49 4c 45 44 00                                FAILED.

000002cd <__c.5>:
     2cd:	2a 53 54 4f 52 41 47 45 20 4d 4f 44 45 2a 00        *STORAGE MODE*.

000002dc <__c.2>:
     2dc:	43 4f 4e 46 49 52 4d 00                             CONFIRM.

000002e4 <__c.3>:
     2e4:	3c 4e 20 59 3e 00                                   <N Y>.

000002ea <__c.4>:
     2ea:	4d 45 4d 20 43 4c 45 41 52 45 44 00                 MEM CLEARED.

000002f6 <__c.1>:
     2f6:	4e 4f 20 53 54 4f 52 45 44 20 50 52 47 4d 00        NO STORED PRGM.

00000305 <__c.0>:
     305:	2a 4a 54 41 47 20 4f 4e 2a 00                       *JTAG ON*.

0000030f <LCD_SegTable>:
     30f:	a8 ea 80 2a 00 40 00 0a 51 0a 08 40 59 55 18 01     ...*.@..Q..@YU..
     31f:	11 1e 11 1b 50 0b 41 1b 41 1f 11 01 51 1f 51 1b     ....P.A.A...Q.Q.
     32f:	00 00 00 00 08 80 00 1a 20 40 00 00 00 00 51 0f     ........ @....Q.
     33f:	91 39 41 14 91 31 41 1e 41 0e 41 1d 50 0f 80 20     .9A..1A.A.A.P.. 
     34f:	10 15 48 86 40 14 78 05 70 85 51 15 51 0e 51 95     ..H.@.x.p.Q.Q.Q.
     35f:	51 8e 21 90 81 20 50 15 48 44 50 c5 28 c0 28 20     Q.!.. P.HDP.(.( 
     36f:	09 50 41 14 20 80 11 11 00 00 00 10                 .PA. .......

0000037b <USIPSValues>:
     37b:	03 80 02 54 01 40 00 22                             ...T.@."

00000383 <DataFlashError>:
     383:	44 41 54 41 46 4c 41 53 48 20 45 52 52 4f 52 00     DATAFLASH ERROR.

00000393 <DF_Pages>:
     393:	f9 00 f1 01 e1 03 10 3e 84 0f 84 0f 08 1f 08 1f     .......>........

000003a3 <DF_PageSize>:
     3a3:	08 01 08 01 08 01 08 01 08 01 10 02 10 02 20 04     .............. .

000003b3 <DF_PageBits>:
     3b3:	09 09 09 09 09 0a 0a 0b                             ........

000003bb <__c.0>:
     3bb:	42 55 46 46 20 4f 56 45 52 46 4c 4f 57 00           BUFF OVERFLOW.

000003c9 <DataFlashProgMode>:
     3c9:	2a 44 41 54 41 46 4c 41 53 48 20 4d 4f 44 45 2a     *DATAFLASH MODE*
	...

000003da <SignonResponse>:
     3da:	01 00 08 41 56 52 49 53 50 5f 32                    ...AVRISP_2

000003e5 <VersionData>:
     3e5:	02 02 04                                            ...

000003e8 <SyncErrorMessage>:
     3e8:	53 59 4e 43 20 45 52 52 4f 52 00                    SYNC ERROR.

000003f3 <AVRISPModeMessage>:
     3f3:	2a 41 54 41 56 52 49 53 50 20 4d 4f 44 45 2a 00     *ATAVRISP MODE*.

00000403 <__c.0>:
     403:	44 41 54 41 2d 00                                   DATA-.

00000409 <__c.1>:
     409:	45 50 52 4d 2d 00                                   EPRM-.

0000040f <__c.2>:
     40f:	46 55 53 45 2d 00                                   FUSE-.

00000415 <__c.3>:
     415:	4c 4f 43 4b 2d 00                                   LOCK-.

0000041b <__c.0>:
     41b:	4e 4f 20 54 41 47 53 00 00                          NO TAGS..

00000424 <__init>:
     424:	11 24       	eor	r1, r1
     426:	1f be       	out	0x3f, r1	; 63
     428:	cf ef       	ldi	r28, 0xFF	; 255
     42a:	d4 e0       	ldi	r29, 0x04	; 4
     42c:	de bf       	out	0x3e, r29	; 62
     42e:	cd bf       	out	0x3d, r28	; 61

00000430 <__do_copy_data>:
     430:	11 e0       	ldi	r17, 0x01	; 1
     432:	a0 e0       	ldi	r26, 0x00	; 0
     434:	b1 e0       	ldi	r27, 0x01	; 1
     436:	e6 e7       	ldi	r30, 0x76	; 118
     438:	f7 e3       	ldi	r31, 0x37	; 55
     43a:	02 c0       	rjmp	.+4      	; 0x440 <.do_copy_data_start>

0000043c <.do_copy_data_loop>:
     43c:	05 90       	lpm	r0, Z+
     43e:	0d 92       	st	X+, r0

00000440 <.do_copy_data_start>:
     440:	a6 32       	cpi	r26, 0x26	; 38
     442:	b1 07       	cpc	r27, r17
     444:	d9 f7       	brne	.-10     	; 0x43c <.do_copy_data_loop>

00000446 <__do_clear_bss>:
     446:	12 e0       	ldi	r17, 0x02	; 2
     448:	a6 e2       	ldi	r26, 0x26	; 38
     44a:	b1 e0       	ldi	r27, 0x01	; 1
     44c:	01 c0       	rjmp	.+2      	; 0x450 <.do_clear_bss_start>

0000044e <.do_clear_bss_loop>:
     44e:	1d 92       	st	X+, r1

00000450 <.do_clear_bss_start>:
     450:	a7 3d       	cpi	r26, 0xD7	; 215
     452:	b1 07       	cpc	r27, r17
     454:	e1 f7       	brne	.-8      	; 0x44e <.do_clear_bss_loop>
     456:	0c 94 73 02 	jmp	0x4e6 <main>

0000045a <__bad_interrupt>:
     45a:	0c 94 ad 03 	jmp	0x75a <__vector_default>

0000045e <MAIN_Delay10MS>:

// ======================================================================================

void MAIN_Delay10MS(uint8_t loops)
{
     45e:	cf 93       	push	r28
     460:	df 93       	push	r29
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     462:	28 2f       	mov	r18, r24
     464:	21 50       	subi	r18, 0x01	; 1
     466:	2f 3f       	cpi	r18, 0xFF	; 255
     468:	49 f0       	breq	.+18     	; 0x47c <MAIN_Delay10MS+0x1e>
     46a:	a0 e0       	ldi	r26, 0x00	; 0
     46c:	b8 e4       	ldi	r27, 0x48	; 72
     46e:	c0 e0       	ldi	r28, 0x00	; 0
     470:	d0 e0       	ldi	r29, 0x00	; 0
     472:	cd 01       	movw	r24, r26
     474:	01 97       	sbiw	r24, 0x01	; 1
     476:	f1 f7       	brne	.-4      	; 0x474 <MAIN_Delay10MS+0x16>
     478:	21 50       	subi	r18, 0x01	; 1
     47a:	d8 f7       	brcc	.-10     	; 0x472 <MAIN_Delay10MS+0x14>
     47c:	df 91       	pop	r29
     47e:	cf 91       	pop	r28
     480:	08 95       	ret

00000482 <MAIN_WaitForJoyRelease>:
  /* Prevents the use of floating point libraries. Delaying in groups of
     10ms increases accuracy by reducing the time overhead for each loop
     interation of the while.                                            */

	while (loops--)
	  _delay_ms(10);
}

void MAIN_Delay1MS(uint8_t loops)
{
  /* Prevents the use of floating point libraries. Less accurate than the
     Delay10MS routine, but nessesary for many commands. The overhead required
     to call the routine is substantially less than the overhead required to
     calculate the float at compile time, so this actually saves execution time. */

	while (loops--)
	  _delay_ms(1);
}

void MAIN_ResetCSLine(uint8_t ActiveInactive)
{
  /* ActiveInactive controls the /Reset line to an AVR device or external dataflash
     /CS line. If the reset polarity parameter is a 0 then interfacing with AT89
	 devices which has an active high reset. Pins are tristated when inactive.      */
	
	switch (ActiveInactive)
	{
		case MAIN_RESETCS_ACTIVE:   // The target RESET line may be either active high or low.
			DDRF |= (1 << 6);
		
			if (!(eeprom_read_byte_169(&Param_ResetPolarity))) // Translate to correct logic level for target device type
			  PORTF |=  (1 << 6);
			else
			  PORTF &= ~(1 << 6);
		
			break;
		case MAIN_RESETCS_EXTDFACTIVE: // Dataflashes are always active low.
			DDRF  |=  (1 << 6);
			PORTF &= ~(1 << 6);
			
			break;
		case MAIN_RESETCS_INACTIVE: // Both modes tristate the pins when inactive.
			DDRF  &= ~(1 << 6);
			PORTF &= ~(1 << 6);
	}
}

void MAIN_WaitForJoyRelease(void)
{
	while (1)
	{
		while (JoyStatus) {};                   // Wait until joystick released
     482:	8e b3       	in	r24, 0x1e	; 30
     484:	88 23       	and	r24, r24
     486:	e9 f7       	brne	.-6      	; 0x482 <MAIN_WaitForJoyRelease>

		MAIN_Delay10MS(1);
     488:	81 e0       	ldi	r24, 0x01	; 1
     48a:	0e 94 2f 02 	call	0x45e <MAIN_Delay10MS>

		if (!(JoyStatus))                       // Joystick still released (not bouncing), return
     48e:	8e b3       	in	r24, 0x1e	; 30
     490:	88 23       	and	r24, r24
     492:	b9 f7       	brne	.-18     	; 0x482 <MAIN_WaitForJoyRelease>
     494:	08 95       	ret

00000496 <FUNCShowAbout>:
		  return;
	}
}

void MAIN_IntToStr(uint16_t IntV, uint8_t* Buff)
{
	// Shows leading zeros, unlike itoa.

	uint8_t Temp = 0;
	
	while (IntV >= 100)
	{
		Temp++;
		IntV -= 100;
	}

	*(Buff++) = '0' + Temp;
	
	Temp = 0;
	
	while (IntV >= 10)
	{
		Temp++;
		IntV -= 10;
	}
		
	*(Buff++) = '0' + Temp;
	*(Buff++) = '0' + IntV;
	*(Buff)   = '\0';
}

void MAIN_ShowProgType(uint8_t Letter)
{
	uint8_t ProgTypeBuffer[7];

	strcpy_P(ProgTypeBuffer, PSTR("PRG> "));
	ProgTypeBuffer[5] = Letter;
	ProgTypeBuffer[6] = '\0';
	
	LCD_puts(ProgTypeBuffer);
}

void MAIN_ShowError(const uint8_t *pFlashStr)
{
	uint8_t ErrorBuff[LCD_TEXTBUFFER_SIZE];       // New buffer, LCD text buffer size
	
	ErrorBuff[0] = 'E';
	ErrorBuff[1] = '>';

	strcpy_P(&ErrorBuff[2], pFlashStr);       // WARNING: If error text is larger than (TEXTBUFFER_SIZE - 2),
	                                          // this will overflow the buffer and probably crash the micro!
	LCD_puts(ErrorBuff);
	
	MAIN_WaitForJoyRelease();
	while (!(JoyStatus & JOY_PRESS)) {};
	MAIN_WaitForJoyRelease();
}

// ======================================================================================

ISR(PCINT1_vect, ISR_NOBLOCK)                 // Joystick routine; PCINT0_vect is bound to this also via JoystickInterrupt.S
{
	JoyStatus = (~PINB & JOY_BMASK)
	          | (~PINE & JOY_EMASK);
}

ISR(BADISR_vect, ISR_NAKED)                   // Bad ISR routine; should never be called, here for safety
{
	MAIN_ShowError(PSTR("BADISR"));
	while (1) {};
}

// ======================================================================================

void FUNCChangeSettings(void)
{
	uint8_t CurrSFunc = 0;
	
	JoyStatus = 1;

	while (1)
	{
		if (JoyStatus)                         // Joystick is in the non-center position
		{
			if (JoyStatus & JOY_UP)            // Previous function
			  (CurrSFunc == 0)? CurrSFunc = 5 : CurrSFunc--;
			else if (JoyStatus & JOY_DOWN)     // Next function
			  (CurrSFunc == 5)? CurrSFunc = 0 : CurrSFunc++;
			else if (JoyStatus & JOY_PRESS)    // Select current function
			  ((FuncPtr)pgm_read_word(&SettingFunctionPtrs[CurrSFunc]))(); // Run associated function
			else if (JoyStatus & JOY_LEFT)
			  return;
		
			// Show current function onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&SettingFunctionNames[CurrSFunc]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCShowAbout(void)
{
     496:	cf 93       	push	r28
	uint8_t InfoNum = 0;
     498:	c0 e0       	ldi	r28, 0x00	; 0
	
	JoyStatus = 1;
     49a:	81 e0       	ldi	r24, 0x01	; 1
     49c:	8e bb       	out	0x1e, r24	; 30
			
	while (1)
	{
		if (JoyStatus)
     49e:	8e b3       	in	r24, 0x1e	; 30
     4a0:	88 23       	and	r24, r24
     4a2:	e9 f3       	breq	.-6      	; 0x49e <FUNCShowAbout+0x8>
		{
			if (JoyStatus & JOY_UP)
     4a4:	f6 9b       	sbis	0x1e, 6	; 30
     4a6:	06 c0       	rjmp	.+12     	; 0x4b4 <FUNCShowAbout+0x1e>
			  (InfoNum == 0)? InfoNum = 3 : InfoNum--;
     4a8:	cc 23       	and	r28, r28
     4aa:	11 f4       	brne	.+4      	; 0x4b0 <FUNCShowAbout+0x1a>
     4ac:	c3 e0       	ldi	r28, 0x03	; 3
     4ae:	0c c0       	rjmp	.+24     	; 0x4c8 <FUNCShowAbout+0x32>
     4b0:	c1 50       	subi	r28, 0x01	; 1
     4b2:	0a c0       	rjmp	.+20     	; 0x4c8 <FUNCShowAbout+0x32>
			else if (JoyStatus & JOY_DOWN)
     4b4:	f7 9b       	sbis	0x1e, 7	; 30
     4b6:	06 c0       	rjmp	.+12     	; 0x4c4 <FUNCShowAbout+0x2e>
			  (InfoNum == 3)? InfoNum = 0 : InfoNum++;
     4b8:	c3 30       	cpi	r28, 0x03	; 3
     4ba:	11 f4       	brne	.+4      	; 0x4c0 <FUNCShowAbout+0x2a>
     4bc:	c0 e0       	ldi	r28, 0x00	; 0
     4be:	04 c0       	rjmp	.+8      	; 0x4c8 <FUNCShowAbout+0x32>
     4c0:	cf 5f       	subi	r28, 0xFF	; 255
     4c2:	02 c0       	rjmp	.+4      	; 0x4c8 <FUNCShowAbout+0x32>
			else if (JoyStatus & JOY_LEFT)
     4c4:	f2 99       	sbic	0x1e, 2	; 30
     4c6:	0d c0       	rjmp	.+26     	; 0x4e2 <FUNCShowAbout+0x4c>
			  return;

			LCD_puts_f((uint8_t*)pgm_read_word(&AboutTextPtrs[InfoNum]));
     4c8:	ec 2f       	mov	r30, r28
     4ca:	ff 27       	eor	r31, r31
     4cc:	ee 0f       	add	r30, r30
     4ce:	ff 1f       	adc	r31, r31
     4d0:	e5 5f       	subi	r30, 0xF5	; 245
     4d2:	fd 4f       	sbci	r31, 0xFD	; 253
     4d4:	85 91       	lpm	r24, Z+
     4d6:	94 91       	lpm	r25, Z
     4d8:	0e 94 04 08 	call	0x1008 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     4dc:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     4e0:	de cf       	rjmp	.-68     	; 0x49e <FUNCShowAbout+0x8>
     4e2:	cf 91       	pop	r28
     4e4:	08 95       	ret

000004e6 <main>:
     4e6:	cd ef       	ldi	r28, 0xFD	; 253
     4e8:	d4 e0       	ldi	r29, 0x04	; 4
     4ea:	de bf       	out	0x3e, r29	; 62
     4ec:	cd bf       	out	0x3d, r28	; 61
     4ee:	10 e0       	ldi	r17, 0x00	; 0
     4f0:	80 e8       	ldi	r24, 0x80	; 128
     4f2:	80 bf       	out	0x30, r24	; 48
     4f4:	85 e0       	ldi	r24, 0x05	; 5
     4f6:	80 93 64 00 	sts	0x0064, r24
     4fa:	80 e3       	ldi	r24, 0x30	; 48
     4fc:	80 bb       	out	0x10, r24	; 16
     4fe:	87 e2       	ldi	r24, 0x27	; 39
     500:	84 b9       	out	0x04, r24	; 4
     502:	8f ed       	ldi	r24, 0xDF	; 223
     504:	85 b9       	out	0x05, r24	; 5
     506:	8c e0       	ldi	r24, 0x0C	; 12
     508:	8e b9       	out	0x0e, r24	; 14
     50a:	80 93 6b 00 	sts	0x006B, r24
     50e:	80 ed       	ldi	r24, 0xD0	; 208
     510:	80 93 6c 00 	sts	0x006C, r24
     514:	80 ec       	ldi	r24, 0xC0	; 192
     516:	8d bb       	out	0x1d, r24	; 29
     518:	8c bb       	out	0x1c, r24	; 28
     51a:	81 b3       	in	r24, 0x11	; 17
     51c:	8f 7c       	andi	r24, 0xCF	; 207
     51e:	80 62       	ori	r24, 0x20	; 32
     520:	81 bb       	out	0x11, r24	; 17
     522:	82 e0       	ldi	r24, 0x02	; 2
     524:	91 e0       	ldi	r25, 0x01	; 1
     526:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
     52a:	8a 37       	cpi	r24, 0x7A	; 122
     52c:	09 f1       	breq	.+66     	; 0x570 <__stack+0x71>
     52e:	20 e0       	ldi	r18, 0x00	; 0
     530:	30 e0       	ldi	r19, 0x00	; 0
     532:	3a 83       	std	Y+2, r19	; 0x02
     534:	29 83       	std	Y+1, r18	; 0x01
     536:	80 91 02 01 	lds	r24, 0x0102
     53a:	90 91 03 01 	lds	r25, 0x0103
     53e:	28 17       	cp	r18, r24
     540:	39 07       	cpc	r19, r25
     542:	88 f4       	brcc	.+34     	; 0x566 <__stack+0x67>
     544:	6f ef       	ldi	r22, 0xFF	; 255
     546:	ce 01       	movw	r24, r28
     548:	01 96       	adiw	r24, 0x01	; 1
     54a:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
     54e:	89 81       	ldd	r24, Y+1	; 0x01
     550:	9a 81       	ldd	r25, Y+2	; 0x02
     552:	01 96       	adiw	r24, 0x01	; 1
     554:	9a 83       	std	Y+2, r25	; 0x02
     556:	89 83       	std	Y+1, r24	; 0x01
     558:	20 91 02 01 	lds	r18, 0x0102
     55c:	30 91 03 01 	lds	r19, 0x0103
     560:	82 17       	cp	r24, r18
     562:	93 07       	cpc	r25, r19
     564:	78 f3       	brcs	.-34     	; 0x544 <__stack+0x45>
     566:	6a e7       	ldi	r22, 0x7A	; 122
     568:	82 e0       	ldi	r24, 0x02	; 2
     56a:	91 e0       	ldi	r25, 0x01	; 1
     56c:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
     570:	0e 94 b1 07 	call	0xf62 <LCD_Init>
     574:	84 e0       	ldi	r24, 0x04	; 4
     576:	91 e0       	ldi	r25, 0x01	; 1
     578:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
     57c:	8f 70       	andi	r24, 0x0F	; 15
     57e:	80 93 e7 00 	sts	0x00E7, r24
     582:	78 94       	sei
     584:	8f e3       	ldi	r24, 0x3F	; 63
     586:	92 e0       	ldi	r25, 0x02	; 2
     588:	0e 94 04 08 	call	0x1008 <LCD_puts_f>
     58c:	80 e0       	ldi	r24, 0x00	; 0
     58e:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
     592:	81 b3       	in	r24, 0x11	; 17
     594:	80 63       	ori	r24, 0x30	; 48
     596:	81 bb       	out	0x11, r24	; 17
     598:	0e 94 3f 07 	call	0xe7e <OSCCAL_Calibrate>
     59c:	87 e0       	ldi	r24, 0x07	; 7
     59e:	90 e0       	ldi	r25, 0x00	; 0
     5a0:	0e 94 e1 08 	call	0x11c2 <USART_Init>
     5a4:	81 b3       	in	r24, 0x11	; 17
     5a6:	8f 7c       	andi	r24, 0xCF	; 207
     5a8:	80 61       	ori	r24, 0x10	; 16
     5aa:	81 bb       	out	0x11, r24	; 17
     5ac:	81 e0       	ldi	r24, 0x01	; 1
     5ae:	8e bb       	out	0x1e, r24	; 30
     5b0:	8e b3       	in	r24, 0x1e	; 30
     5b2:	88 23       	and	r24, r24
     5b4:	e9 f3       	breq	.-6      	; 0x5b0 <__stack+0xb1>
     5b6:	f6 9b       	sbis	0x1e, 6	; 30
     5b8:	06 c0       	rjmp	.+12     	; 0x5c6 <__stack+0xc7>
     5ba:	11 23       	and	r17, r17
     5bc:	11 f4       	brne	.+4      	; 0x5c2 <__stack+0xc3>
     5be:	16 e0       	ldi	r17, 0x06	; 6
     5c0:	1b c0       	rjmp	.+54     	; 0x5f8 <__stack+0xf9>
     5c2:	11 50       	subi	r17, 0x01	; 1
     5c4:	19 c0       	rjmp	.+50     	; 0x5f8 <__stack+0xf9>
     5c6:	f7 9b       	sbis	0x1e, 7	; 30
     5c8:	06 c0       	rjmp	.+12     	; 0x5d6 <__stack+0xd7>
     5ca:	16 30       	cpi	r17, 0x06	; 6
     5cc:	11 f4       	brne	.+4      	; 0x5d2 <__stack+0xd3>
     5ce:	10 e0       	ldi	r17, 0x00	; 0
     5d0:	13 c0       	rjmp	.+38     	; 0x5f8 <__stack+0xf9>
     5d2:	1f 5f       	subi	r17, 0xFF	; 255
     5d4:	11 c0       	rjmp	.+34     	; 0x5f8 <__stack+0xf9>
     5d6:	f4 9b       	sbis	0x1e, 4	; 30
     5d8:	0b c0       	rjmp	.+22     	; 0x5f0 <__stack+0xf1>
     5da:	e1 2f       	mov	r30, r17
     5dc:	ff 27       	eor	r31, r31
     5de:	ee 0f       	add	r30, r30
     5e0:	ff 1f       	adc	r31, r31
     5e2:	eb 56       	subi	r30, 0x6B	; 107
     5e4:	fe 4f       	sbci	r31, 0xFE	; 254
     5e6:	85 91       	lpm	r24, Z+
     5e8:	94 91       	lpm	r25, Z
     5ea:	fc 01       	movw	r30, r24
     5ec:	09 95       	icall
     5ee:	04 c0       	rjmp	.+8      	; 0x5f8 <__stack+0xf9>
     5f0:	f3 9b       	sbis	0x1e, 3	; 30
     5f2:	02 c0       	rjmp	.+4      	; 0x5f8 <__stack+0xf9>
     5f4:	0e 94 4b 02 	call	0x496 <FUNCShowAbout>
     5f8:	e1 2f       	mov	r30, r17
     5fa:	ff 27       	eor	r31, r31
     5fc:	ee 0f       	add	r30, r30
     5fe:	ff 1f       	adc	r31, r31
     600:	ed 55       	subi	r30, 0x5D	; 93
     602:	fe 4f       	sbci	r31, 0xFE	; 254
     604:	85 91       	lpm	r24, Z+
     606:	94 91       	lpm	r25, Z
     608:	0e 94 04 08 	call	0x1008 <LCD_puts_f>
     60c:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     610:	cf cf       	rjmp	.-98     	; 0x5b0 <__stack+0xb1>

00000612 <MAIN_Delay1MS>:
     612:	cf 93       	push	r28
     614:	df 93       	push	r29
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     616:	28 2f       	mov	r18, r24
     618:	21 50       	subi	r18, 0x01	; 1
     61a:	2f 3f       	cpi	r18, 0xFF	; 255
     61c:	49 f0       	breq	.+18     	; 0x630 <MAIN_Delay1MS+0x1e>
     61e:	a3 e3       	ldi	r26, 0x33	; 51
     620:	b7 e0       	ldi	r27, 0x07	; 7
     622:	c0 e0       	ldi	r28, 0x00	; 0
     624:	d0 e0       	ldi	r29, 0x00	; 0
     626:	cd 01       	movw	r24, r26
     628:	01 97       	sbiw	r24, 0x01	; 1
     62a:	f1 f7       	brne	.-4      	; 0x628 <MAIN_Delay1MS+0x16>
     62c:	21 50       	subi	r18, 0x01	; 1
     62e:	d8 f7       	brcc	.-10     	; 0x626 <MAIN_Delay1MS+0x14>
     630:	df 91       	pop	r29
     632:	cf 91       	pop	r28
     634:	08 95       	ret

00000636 <MAIN_ResetCSLine>:
     636:	99 27       	eor	r25, r25
     638:	81 30       	cpi	r24, 0x01	; 1
     63a:	91 05       	cpc	r25, r1
     63c:	a9 f0       	breq	.+42     	; 0x668 <MAIN_ResetCSLine+0x32>
     63e:	82 30       	cpi	r24, 0x02	; 2
     640:	91 05       	cpc	r25, r1
     642:	1c f4       	brge	.+6      	; 0x64a <MAIN_ResetCSLine+0x14>
     644:	89 2b       	or	r24, r25
     646:	21 f0       	breq	.+8      	; 0x650 <MAIN_ResetCSLine+0x1a>
     648:	08 95       	ret
     64a:	02 97       	sbiw	r24, 0x02	; 2
     64c:	51 f0       	breq	.+20     	; 0x662 <MAIN_ResetCSLine+0x2c>
     64e:	08 95       	ret
     650:	86 9a       	sbi	0x10, 6	; 16
     652:	82 e2       	ldi	r24, 0x22	; 34
     654:	91 e0       	ldi	r25, 0x01	; 1
     656:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
     65a:	88 23       	and	r24, r24
     65c:	19 f4       	brne	.+6      	; 0x664 <MAIN_ResetCSLine+0x2e>
     65e:	8e 9a       	sbi	0x11, 6	; 17
     660:	08 95       	ret
     662:	86 9a       	sbi	0x10, 6	; 16
     664:	8e 98       	cbi	0x11, 6	; 17
     666:	08 95       	ret
     668:	86 98       	cbi	0x10, 6	; 16
     66a:	fc cf       	rjmp	.-8      	; 0x664 <MAIN_ResetCSLine+0x2e>

0000066c <MAIN_IntToStr>:
     66c:	fb 01       	movw	r30, r22
     66e:	20 e0       	ldi	r18, 0x00	; 0
     670:	84 36       	cpi	r24, 0x64	; 100
     672:	91 05       	cpc	r25, r1
     674:	20 f0       	brcs	.+8      	; 0x67e <MAIN_IntToStr+0x12>
     676:	2f 5f       	subi	r18, 0xFF	; 255
     678:	84 56       	subi	r24, 0x64	; 100
     67a:	90 40       	sbci	r25, 0x00	; 0
     67c:	f9 cf       	rjmp	.-14     	; 0x670 <MAIN_IntToStr+0x4>
     67e:	20 5d       	subi	r18, 0xD0	; 208
     680:	21 93       	st	Z+, r18
     682:	20 e0       	ldi	r18, 0x00	; 0
     684:	8a 30       	cpi	r24, 0x0A	; 10
     686:	91 05       	cpc	r25, r1
     688:	18 f0       	brcs	.+6      	; 0x690 <MAIN_IntToStr+0x24>
     68a:	2f 5f       	subi	r18, 0xFF	; 255
     68c:	0a 97       	sbiw	r24, 0x0a	; 10
     68e:	fa cf       	rjmp	.-12     	; 0x684 <MAIN_IntToStr+0x18>
     690:	20 5d       	subi	r18, 0xD0	; 208
     692:	21 93       	st	Z+, r18
     694:	80 5d       	subi	r24, 0xD0	; 208
     696:	81 93       	st	Z+, r24
     698:	10 82       	st	Z, r1
     69a:	08 95       	ret

0000069c <MAIN_ShowProgType>:
     69c:	1f 93       	push	r17
     69e:	cf 93       	push	r28
     6a0:	df 93       	push	r29
     6a2:	cd b7       	in	r28, 0x3d	; 61
     6a4:	de b7       	in	r29, 0x3e	; 62
     6a6:	27 97       	sbiw	r28, 0x07	; 7
     6a8:	0f b6       	in	r0, 0x3f	; 63
     6aa:	f8 94       	cli
     6ac:	de bf       	out	0x3e, r29	; 62
     6ae:	0f be       	out	0x3f, r0	; 63
     6b0:	cd bf       	out	0x3d, r28	; 61
     6b2:	18 2f       	mov	r17, r24
     6b4:	6d e6       	ldi	r22, 0x6D	; 109
     6b6:	72 e0       	ldi	r23, 0x02	; 2
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	0e 94 3e 1b 	call	0x367c <strcpy_P>
     6c0:	1e 83       	std	Y+6, r17	; 0x06
     6c2:	1f 82       	std	Y+7, r1	; 0x07
     6c4:	ce 01       	movw	r24, r28
     6c6:	01 96       	adiw	r24, 0x01	; 1
     6c8:	0e 94 c3 07 	call	0xf86 <LCD_puts>
     6cc:	27 96       	adiw	r28, 0x07	; 7
     6ce:	0f b6       	in	r0, 0x3f	; 63
     6d0:	f8 94       	cli
     6d2:	de bf       	out	0x3e, r29	; 62
     6d4:	0f be       	out	0x3f, r0	; 63
     6d6:	cd bf       	out	0x3d, r28	; 61
     6d8:	df 91       	pop	r29
     6da:	cf 91       	pop	r28
     6dc:	1f 91       	pop	r17
     6de:	08 95       	ret

000006e0 <MAIN_ShowError>:
     6e0:	cf 93       	push	r28
     6e2:	df 93       	push	r29
     6e4:	cd b7       	in	r28, 0x3d	; 61
     6e6:	de b7       	in	r29, 0x3e	; 62
     6e8:	64 97       	sbiw	r28, 0x14	; 20
     6ea:	0f b6       	in	r0, 0x3f	; 63
     6ec:	f8 94       	cli
     6ee:	de bf       	out	0x3e, r29	; 62
     6f0:	0f be       	out	0x3f, r0	; 63
     6f2:	cd bf       	out	0x3d, r28	; 61
     6f4:	25 e4       	ldi	r18, 0x45	; 69
     6f6:	29 83       	std	Y+1, r18	; 0x01
     6f8:	2e e3       	ldi	r18, 0x3E	; 62
     6fa:	2a 83       	std	Y+2, r18	; 0x02
     6fc:	bc 01       	movw	r22, r24
     6fe:	ce 01       	movw	r24, r28
     700:	03 96       	adiw	r24, 0x03	; 3
     702:	0e 94 3e 1b 	call	0x367c <strcpy_P>
     706:	ce 01       	movw	r24, r28
     708:	01 96       	adiw	r24, 0x01	; 1
     70a:	0e 94 c3 07 	call	0xf86 <LCD_puts>
     70e:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     712:	f4 9b       	sbis	0x1e, 4	; 30
     714:	fe cf       	rjmp	.-4      	; 0x712 <MAIN_ShowError+0x32>
     716:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     71a:	64 96       	adiw	r28, 0x14	; 20
     71c:	0f b6       	in	r0, 0x3f	; 63
     71e:	f8 94       	cli
     720:	de bf       	out	0x3e, r29	; 62
     722:	0f be       	out	0x3f, r0	; 63
     724:	cd bf       	out	0x3d, r28	; 61
     726:	df 91       	pop	r29
     728:	cf 91       	pop	r28
     72a:	08 95       	ret

0000072c <__vector_3>:
     72c:	78 94       	sei
     72e:	1f 92       	push	r1
     730:	0f 92       	push	r0
     732:	0f b6       	in	r0, 0x3f	; 63
     734:	0f 92       	push	r0
     736:	11 24       	eor	r1, r1
     738:	8f 93       	push	r24
     73a:	9f 93       	push	r25
     73c:	93 b1       	in	r25, 0x03	; 3
     73e:	90 95       	com	r25
     740:	90 7d       	andi	r25, 0xD0	; 208
     742:	8c b1       	in	r24, 0x0c	; 12
     744:	80 95       	com	r24
     746:	8c 70       	andi	r24, 0x0C	; 12
     748:	98 2b       	or	r25, r24
     74a:	9e bb       	out	0x1e, r25	; 30
     74c:	9f 91       	pop	r25
     74e:	8f 91       	pop	r24
     750:	0f 90       	pop	r0
     752:	0f be       	out	0x3f, r0	; 63
     754:	0f 90       	pop	r0
     756:	1f 90       	pop	r1
     758:	18 95       	reti

0000075a <__vector_default>:
     75a:	83 e7       	ldi	r24, 0x73	; 115
     75c:	92 e0       	ldi	r25, 0x02	; 2
     75e:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
     762:	ff cf       	rjmp	.-2      	; 0x762 <__vector_default+0x8>

00000764 <FUNCChangeSettings>:
     764:	cf 93       	push	r28
     766:	c0 e0       	ldi	r28, 0x00	; 0
     768:	81 e0       	ldi	r24, 0x01	; 1
     76a:	8e bb       	out	0x1e, r24	; 30
     76c:	8e b3       	in	r24, 0x1e	; 30
     76e:	88 23       	and	r24, r24
     770:	e9 f3       	breq	.-6      	; 0x76c <FUNCChangeSettings+0x8>
     772:	f6 9b       	sbis	0x1e, 6	; 30
     774:	06 c0       	rjmp	.+12     	; 0x782 <FUNCChangeSettings+0x1e>
     776:	cc 23       	and	r28, r28
     778:	11 f4       	brne	.+4      	; 0x77e <FUNCChangeSettings+0x1a>
     77a:	c5 e0       	ldi	r28, 0x05	; 5
     77c:	19 c0       	rjmp	.+50     	; 0x7b0 <FUNCChangeSettings+0x4c>
     77e:	c1 50       	subi	r28, 0x01	; 1
     780:	17 c0       	rjmp	.+46     	; 0x7b0 <FUNCChangeSettings+0x4c>
     782:	f7 9b       	sbis	0x1e, 7	; 30
     784:	06 c0       	rjmp	.+12     	; 0x792 <FUNCChangeSettings+0x2e>
     786:	c5 30       	cpi	r28, 0x05	; 5
     788:	11 f4       	brne	.+4      	; 0x78e <FUNCChangeSettings+0x2a>
     78a:	c0 e0       	ldi	r28, 0x00	; 0
     78c:	11 c0       	rjmp	.+34     	; 0x7b0 <FUNCChangeSettings+0x4c>
     78e:	cf 5f       	subi	r28, 0xFF	; 255
     790:	0f c0       	rjmp	.+30     	; 0x7b0 <FUNCChangeSettings+0x4c>
     792:	f4 9b       	sbis	0x1e, 4	; 30
     794:	0b c0       	rjmp	.+22     	; 0x7ac <FUNCChangeSettings+0x48>
     796:	ec 2f       	mov	r30, r28
     798:	ff 27       	eor	r31, r31
     79a:	ee 0f       	add	r30, r30
     79c:	ff 1f       	adc	r31, r31
     79e:	e0 5e       	subi	r30, 0xE0	; 224
     7a0:	fe 4f       	sbci	r31, 0xFE	; 254
     7a2:	85 91       	lpm	r24, Z+
     7a4:	94 91       	lpm	r25, Z
     7a6:	fc 01       	movw	r30, r24
     7a8:	09 95       	icall
     7aa:	02 c0       	rjmp	.+4      	; 0x7b0 <FUNCChangeSettings+0x4c>
     7ac:	f2 99       	sbic	0x1e, 2	; 30
     7ae:	0d c0       	rjmp	.+26     	; 0x7ca <FUNCChangeSettings+0x66>
     7b0:	ec 2f       	mov	r30, r28
     7b2:	ff 27       	eor	r31, r31
     7b4:	ee 0f       	add	r30, r30
     7b6:	ff 1f       	adc	r31, r31
     7b8:	e4 5d       	subi	r30, 0xD4	; 212
     7ba:	fe 4f       	sbci	r31, 0xFE	; 254
     7bc:	85 91       	lpm	r24, Z+
     7be:	94 91       	lpm	r25, Z
     7c0:	0e 94 04 08 	call	0x1008 <LCD_puts_f>
     7c4:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     7c8:	d1 cf       	rjmp	.-94     	; 0x76c <FUNCChangeSettings+0x8>
     7ca:	cf 91       	pop	r28
     7cc:	08 95       	ret

000007ce <FUNCAVRISPMode>:
		}
	}
}

void FUNCAVRISPMode(void)
{
	LCD_puts_f(AVRISPModeMessage);
     7ce:	83 ef       	ldi	r24, 0xF3	; 243
     7d0:	93 e0       	ldi	r25, 0x03	; 3
     7d2:	0e 94 04 08 	call	0x1008 <LCD_puts_f>
	
	InterpretPacketRoutine = (FuncPtr)AICI_InterpretPacket;
     7d6:	80 e1       	ldi	r24, 0x10	; 16
     7d8:	92 e1       	ldi	r25, 0x12	; 18
     7da:	90 93 25 01 	sts	0x0125, r25
     7de:	80 93 24 01 	sts	0x0124, r24
	V2P_RunStateMachine();
     7e2:	0e 94 0c 0f 	call	0x1e18 <V2P_RunStateMachine>
     7e6:	08 95       	ret

000007e8 <FUNCProgramDataflash>:
}

void FUNCProgramDataflash(void)
{
	USI_SPIInitMaster(eeprom_read_byte_169(&Param_SCKDuration));
     7e8:	80 e2       	ldi	r24, 0x20	; 32
     7ea:	91 e0       	ldi	r25, 0x01	; 1
     7ec:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
     7f0:	0e 94 92 09 	call	0x1324 <USI_SPIInitMaster>
	UseExernalDF = TRUE;
     7f4:	81 e0       	ldi	r24, 0x01	; 1
     7f6:	80 93 84 02 	sts	0x0284, r24
	DFSPIRoutinePointer = USI_SPITransmit;
     7fa:	8c ea       	ldi	r24, 0xAC	; 172
     7fc:	99 e0       	ldi	r25, 0x09	; 9
     7fe:	90 93 01 01 	sts	0x0101, r25
     802:	80 93 00 01 	sts	0x0100, r24
	
	LCD_puts_f(DataFlashProgMode);
     806:	89 ec       	ldi	r24, 0xC9	; 201
     808:	93 e0       	ldi	r25, 0x03	; 3
     80a:	0e 94 04 08 	call	0x1008 <LCD_puts_f>

	InterpretPacketRoutine = PD_InterpretAVRISPPacket;
     80e:	80 e6       	ldi	r24, 0x60	; 96
     810:	9c e0       	ldi	r25, 0x0C	; 12
     812:	90 93 25 01 	sts	0x0125, r25
     816:	80 93 24 01 	sts	0x0124, r24
	V2P_RunStateMachine();
     81a:	0e 94 0c 0f 	call	0x1e18 <V2P_RunStateMachine>
	   
	DF_EnableDataflash(FALSE);
     81e:	80 e0       	ldi	r24, 0x00	; 0
     820:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
	SPI_SPIOFF();
     824:	80 91 64 00 	lds	r24, 0x0064
     828:	84 60       	ori	r24, 0x04	; 4
     82a:	80 93 64 00 	sts	0x0064, r24
     82e:	08 95       	ret

00000830 <FUNCProgramAVR>:
}

void FUNCProgramAVR(void)
{
     830:	df 92       	push	r13
     832:	ef 92       	push	r14
     834:	ff 92       	push	r15
     836:	0f 93       	push	r16
     838:	1f 93       	push	r17
     83a:	cf 93       	push	r28
     83c:	df 93       	push	r29
     83e:	cd b7       	in	r28, 0x3d	; 61
     840:	de b7       	in	r29, 0x3e	; 62
     842:	65 97       	sbiw	r28, 0x15	; 21
     844:	0f b6       	in	r0, 0x3f	; 63
     846:	f8 94       	cli
     848:	de bf       	out	0x3e, r29	; 62
     84a:	0f be       	out	0x3f, r0	; 63
     84c:	cd bf       	out	0x3d, r28	; 61
	uint8_t  DoneFailMessageBuff[19];
	uint16_t EEPROMAddress;
	uint8_t  Fault = ISPCC_NO_FAULT;
     84e:	dd 24       	eor	r13, r13
	uint8_t  ProgMode = 0;
     850:	0d 2d       	mov	r16, r13

	SPI_SPIInit();
     852:	0e 94 3d 09 	call	0x127a <SPI_SPIInit>
	UseExernalDF = FALSE;
     856:	d0 92 84 02 	sts	0x0284, r13
	DFSPIRoutinePointer = SPI_SPITransmit;
     85a:	87 e4       	ldi	r24, 0x47	; 71
     85c:	99 e0       	ldi	r25, 0x09	; 9
     85e:	90 93 01 01 	sts	0x0101, r25
     862:	80 93 00 01 	sts	0x0100, r24
	
	if (!(DF_CheckCorrectOnboardChip()))
     866:	0e 94 6b 0b 	call	0x16d6 <DF_CheckCorrectOnboardChip>
     86a:	88 23       	and	r24, r24
     86c:	09 f4       	brne	.+2      	; 0x870 <FUNCProgramAVR+0x40>
     86e:	17 c1       	rjmp	.+558    	; 0xa9e <FUNCProgramAVR+0x26e>
	  return;

	MAIN_WaitForJoyRelease();
     870:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
	
	JoyStatus = 1;                            // Use an invalid joystick value to force the program to write the
     874:	81 e0       	ldi	r24, 0x01	; 1
     876:	8e bb       	out	0x1e, r24	; 30
	                                          // name of the default command onto the LCD
	while (1)
	{
		if (JoyStatus)
     878:	8e b3       	in	r24, 0x1e	; 30
     87a:	88 23       	and	r24, r24
     87c:	e9 f3       	breq	.-6      	; 0x878 <FUNCProgramAVR+0x48>
		{
			if (JoyStatus & JOY_LEFT)
     87e:	f2 99       	sbic	0x1e, 2	; 30
     880:	0e c1       	rjmp	.+540    	; 0xa9e <FUNCProgramAVR+0x26e>
			  return;
			else if (JoyStatus & JOY_PRESS)
     882:	f4 99       	sbic	0x1e, 4	; 30
     884:	1c c0       	rjmp	.+56     	; 0x8be <FUNCProgramAVR+0x8e>
			  break;
			else if (JoyStatus & JOY_UP)
     886:	f6 9b       	sbis	0x1e, 6	; 30
     888:	06 c0       	rjmp	.+12     	; 0x896 <FUNCProgramAVR+0x66>
			  (ProgMode == 0)? ProgMode = 6 : ProgMode--;
     88a:	00 23       	and	r16, r16
     88c:	11 f4       	brne	.+4      	; 0x892 <FUNCProgramAVR+0x62>
     88e:	06 e0       	ldi	r16, 0x06	; 6
     890:	09 c0       	rjmp	.+18     	; 0x8a4 <FUNCProgramAVR+0x74>
     892:	01 50       	subi	r16, 0x01	; 1
     894:	07 c0       	rjmp	.+14     	; 0x8a4 <FUNCProgramAVR+0x74>
			else if (JoyStatus & JOY_DOWN)
     896:	f7 9b       	sbis	0x1e, 7	; 30
     898:	05 c0       	rjmp	.+10     	; 0x8a4 <FUNCProgramAVR+0x74>
			  (ProgMode == 6)? ProgMode = 0 : ProgMode++;
     89a:	06 30       	cpi	r16, 0x06	; 6
     89c:	11 f4       	brne	.+4      	; 0x8a2 <FUNCProgramAVR+0x72>
     89e:	00 e0       	ldi	r16, 0x00	; 0
     8a0:	01 c0       	rjmp	.+2      	; 0x8a4 <FUNCProgramAVR+0x74>
     8a2:	0f 5f       	subi	r16, 0xFF	; 255

			LCD_puts_f((uint8_t*)pgm_read_word(&ProgOptions[ProgMode])); // Show current function onto the LCD
     8a4:	e0 2f       	mov	r30, r16
     8a6:	ff 27       	eor	r31, r31
     8a8:	ee 0f       	add	r30, r30
     8aa:	ff 1f       	adc	r31, r31
     8ac:	e3 55       	subi	r30, 0x53	; 83
     8ae:	ff 4f       	sbci	r31, 0xFF	; 255
     8b0:	85 91       	lpm	r24, Z+
     8b2:	94 91       	lpm	r25, Z
     8b4:	0e 94 04 08 	call	0x1008 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     8b8:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     8bc:	dd cf       	rjmp	.-70     	; 0x878 <FUNCProgramAVR+0x48>
		}
	}

	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);                // Orange = busy
     8be:	81 b3       	in	r24, 0x11	; 17
     8c0:	80 63       	ori	r24, 0x30	; 48
     8c2:	81 bb       	out	0x11, r24	; 17
	LCD_puts_f(WaitText);
     8c4:	8f e3       	ldi	r24, 0x3F	; 63
     8c6:	92 e0       	ldi	r25, 0x02	; 2
     8c8:	0e 94 04 08 	call	0x1008 <LCD_puts_f>

	USI_SPIInitMaster(eeprom_read_byte_169(&Param_SCKDuration));
     8cc:	80 e2       	ldi	r24, 0x20	; 32
     8ce:	91 e0       	ldi	r25, 0x01	; 1
     8d0:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
     8d4:	0e 94 92 09 	call	0x1324 <USI_SPIInitMaster>
	MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE); // Capture the RESET line of the slave AVR
     8d8:	80 e0       	ldi	r24, 0x00	; 0
     8da:	0e 94 1b 03 	call	0x636 <MAIN_ResetCSLine>

	EEPROMAddress = Prog_EnterProgMode;
     8de:	80 91 12 01 	lds	r24, 0x0112
     8e2:	90 91 13 01 	lds	r25, 0x0113
     8e6:	9d 8b       	std	Y+21, r25	; 0x15
     8e8:	8c 8b       	std	Y+20, r24	; 0x14
     8ea:	54 e3       	ldi	r21, 0x34	; 52
     8ec:	e5 2e       	mov	r14, r21
     8ee:	51 e0       	ldi	r21, 0x01	; 1
     8f0:	f5 2e       	mov	r15, r21
     8f2:	1b e0       	ldi	r17, 0x0B	; 11
			
	for (uint8_t PacketB = 0; PacketB <= 11; PacketB++) // Read the enter programming mode command bytes
	{
		PacketBytes[PacketB] = eeprom_read_byte_169(&EEPROMAddress);
     8f4:	ce 01       	movw	r24, r28
     8f6:	44 96       	adiw	r24, 0x14	; 20
     8f8:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
     8fc:	f7 01       	movw	r30, r14
     8fe:	81 93       	st	Z+, r24
     900:	7f 01       	movw	r14, r30
		EEPROMAddress++;
     902:	8c 89       	ldd	r24, Y+20	; 0x14
     904:	9d 89       	ldd	r25, Y+21	; 0x15
     906:	01 96       	adiw	r24, 0x01	; 1
     908:	9d 8b       	std	Y+21, r25	; 0x15
     90a:	8c 8b       	std	Y+20, r24	; 0x14
     90c:	11 50       	subi	r17, 0x01	; 1
     90e:	17 ff       	sbrs	r17, 7
     910:	f1 cf       	rjmp	.-30     	; 0x8f4 <FUNCProgramAVR+0xc4>
	}
	
	ISPCC_EnterChipProgrammingMode();    // Try to sync with the slave AVR
     912:	0e 94 80 10 	call	0x2100 <ISPCC_EnterChipProgrammingMode>

	CurrAddress = 0;
     916:	10 92 2b 01 	sts	0x012B, r1
     91a:	10 92 2c 01 	sts	0x012C, r1
     91e:	10 92 2d 01 	sts	0x012D, r1
     922:	10 92 2e 01 	sts	0x012E, r1

	if (PacketBytes[1] == STATUS_CMD_OK) // ISPCC_EnterChipProgrammingMode alters the PacketBytes buffer rather than returning a value
     926:	80 91 35 01 	lds	r24, 0x0135
     92a:	88 23       	and	r24, r24
     92c:	09 f0       	breq	.+2      	; 0x930 <FUNCProgramAVR+0x100>
     92e:	a2 c0       	rjmp	.+324    	; 0xa74 <FUNCProgramAVR+0x244>
	{						
		if ((ProgMode == 6) || (ProgMode == 0) || (ProgMode == 2)) // Erase chip, or program flash mode
     930:	06 30       	cpi	r16, 0x06	; 6
     932:	21 f0       	breq	.+8      	; 0x93c <FUNCProgramAVR+0x10c>
     934:	00 23       	and	r16, r16
     936:	11 f0       	breq	.+4      	; 0x93c <FUNCProgramAVR+0x10c>
     938:	02 30       	cpi	r16, 0x02	; 2
     93a:	91 f4       	brne	.+36     	; 0x960 <FUNCProgramAVR+0x130>
		{
			MAIN_ShowProgType('C');
     93c:	83 e4       	ldi	r24, 0x43	; 67
     93e:	0e 94 4e 03 	call	0x69c <MAIN_ShowProgType>
			
			if (!(eeprom_read_byte_169(&Prog_EraseCmdStored) == TRUE))
     942:	8a e1       	ldi	r24, 0x1A	; 26
     944:	91 e0       	ldi	r25, 0x01	; 1
     946:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
     94a:	81 30       	cpi	r24, 0x01	; 1
     94c:	39 f0       	breq	.+14     	; 0x95c <FUNCProgramAVR+0x12c>
			{
				Fault = ISPCC_FAULT_NOERASE;
     94e:	42 e0       	ldi	r20, 0x02	; 2
     950:	d4 2e       	mov	r13, r20
				MAIN_ShowError(PSTR("NO ERASE CMD"));
     952:	8a e7       	ldi	r24, 0x7A	; 122
     954:	92 e0       	ldi	r25, 0x02	; 2
     956:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
     95a:	02 c0       	rjmp	.+4      	; 0x960 <FUNCProgramAVR+0x130>
			}
			else
			{
				PM_SendEraseCommand();
     95c:	0e 94 3f 18 	call	0x307e <PM_SendEraseCommand>
			}
		}

		if (((ProgMode == 0) || (ProgMode == 2)) && (Fault == ISPCC_NO_FAULT)) // Program flash
     960:	00 23       	and	r16, r16
     962:	11 f0       	breq	.+4      	; 0x968 <FUNCProgramAVR+0x138>
     964:	02 30       	cpi	r16, 0x02	; 2
     966:	c1 f4       	brne	.+48     	; 0x998 <FUNCProgramAVR+0x168>
     968:	dd 20       	and	r13, r13
     96a:	b1 f4       	brne	.+44     	; 0x998 <FUNCProgramAVR+0x168>
		{
			MAIN_ShowProgType('D');
     96c:	84 e4       	ldi	r24, 0x44	; 68
     96e:	0e 94 4e 03 	call	0x69c <MAIN_ShowProgType>

			if (!(PM_GetStoredDataSize(TYPE_FLASH))) // Check to make sure a program is present in memory
     972:	81 e0       	ldi	r24, 0x01	; 1
     974:	0e 94 7f 13 	call	0x26fe <PM_GetStoredDataSize>
     978:	dc 01       	movw	r26, r24
     97a:	cb 01       	movw	r24, r22
     97c:	00 97       	sbiw	r24, 0x00	; 0
     97e:	a1 05       	cpc	r26, r1
     980:	b1 05       	cpc	r27, r1
     982:	39 f4       	brne	.+14     	; 0x992 <FUNCProgramAVR+0x162>
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
     984:	33 e0       	ldi	r19, 0x03	; 3
     986:	d3 2e       	mov	r13, r19
				MAIN_ShowError(PSTR("NO DATA"));
     988:	87 e8       	ldi	r24, 0x87	; 135
     98a:	92 e0       	ldi	r25, 0x02	; 2
     98c:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
     990:	03 c0       	rjmp	.+6      	; 0x998 <FUNCProgramAVR+0x168>
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_FLASH);
     992:	81 e0       	ldi	r24, 0x01	; 1
     994:	0e 94 8f 18 	call	0x311e <PM_CreateProgrammingPackets>
			}
		}
	
		if ((ProgMode == 1) || (ProgMode == 2)) // Program EEPROM
     998:	80 2f       	mov	r24, r16
     99a:	81 50       	subi	r24, 0x01	; 1
     99c:	82 30       	cpi	r24, 0x02	; 2
     99e:	b0 f4       	brcc	.+44     	; 0x9cc <FUNCProgramAVR+0x19c>
		{
			MAIN_ShowProgType('E');
     9a0:	85 e4       	ldi	r24, 0x45	; 69
     9a2:	0e 94 4e 03 	call	0x69c <MAIN_ShowProgType>
				
			if (!(PM_GetStoredDataSize(TYPE_EEPROM))) // Check to make sure EEPROM data is present in memory
     9a6:	80 e0       	ldi	r24, 0x00	; 0
     9a8:	0e 94 7f 13 	call	0x26fe <PM_GetStoredDataSize>
     9ac:	dc 01       	movw	r26, r24
     9ae:	cb 01       	movw	r24, r22
     9b0:	00 97       	sbiw	r24, 0x00	; 0
     9b2:	a1 05       	cpc	r26, r1
     9b4:	b1 05       	cpc	r27, r1
     9b6:	39 f4       	brne	.+14     	; 0x9c6 <FUNCProgramAVR+0x196>
			{
				Fault = ISPCC_FAULT_NODATATYPE;
     9b8:	23 e0       	ldi	r18, 0x03	; 3
     9ba:	d2 2e       	mov	r13, r18
				MAIN_ShowError(PSTR("NO EEPROM"));
     9bc:	8f e8       	ldi	r24, 0x8F	; 143
     9be:	92 e0       	ldi	r25, 0x02	; 2
     9c0:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
     9c4:	03 c0       	rjmp	.+6      	; 0x9cc <FUNCProgramAVR+0x19c>
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_EEPROM);
     9c6:	80 e0       	ldi	r24, 0x00	; 0
     9c8:	0e 94 8f 18 	call	0x311e <PM_CreateProgrammingPackets>
			}
		}

		if ((ProgMode == 3) || (ProgMode == 5)) // Program Fuse bytes
     9cc:	03 30       	cpi	r16, 0x03	; 3
     9ce:	11 f0       	breq	.+4      	; 0x9d4 <FUNCProgramAVR+0x1a4>
     9d0:	05 30       	cpi	r16, 0x05	; 5
     9d2:	99 f4       	brne	.+38     	; 0x9fa <FUNCProgramAVR+0x1ca>
		{
			MAIN_ShowProgType('F');
     9d4:	86 e4       	ldi	r24, 0x46	; 70
     9d6:	0e 94 4e 03 	call	0x69c <MAIN_ShowProgType>
			
			if (!(eeprom_read_byte_169(&Prog_TotalFuseBytes)))
     9da:	80 e1       	ldi	r24, 0x10	; 16
     9dc:	91 e0       	ldi	r25, 0x01	; 1
     9de:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
     9e2:	88 23       	and	r24, r24
     9e4:	39 f4       	brne	.+14     	; 0x9f4 <FUNCProgramAVR+0x1c4>
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
     9e6:	93 e0       	ldi	r25, 0x03	; 3
     9e8:	d9 2e       	mov	r13, r25
				MAIN_ShowError(PSTR("NO FUSE BYTES"));
     9ea:	89 e9       	ldi	r24, 0x99	; 153
     9ec:	92 e0       	ldi	r25, 0x02	; 2
     9ee:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
     9f2:	03 c0       	rjmp	.+6      	; 0x9fa <FUNCProgramAVR+0x1ca>
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_FUSE);
     9f4:	82 e0       	ldi	r24, 0x02	; 2
     9f6:	0e 94 ef 17 	call	0x2fde <PM_SendFuseLockBytes>
			}
		}

		if ((ProgMode == 4) || (ProgMode == 5)) // Program Lock bytes
     9fa:	80 2f       	mov	r24, r16
     9fc:	84 50       	subi	r24, 0x04	; 4
     9fe:	82 30       	cpi	r24, 0x02	; 2
     a00:	00 f5       	brcc	.+64     	; 0xa42 <FUNCProgramAVR+0x212>
		{
			if (ProgMode == 5)                    // If fusebytes have already been written, we need to reenter programming mode to latch them
     a02:	05 30       	cpi	r16, 0x05	; 5
     a04:	59 f4       	brne	.+22     	; 0xa1c <FUNCProgramAVR+0x1ec>
			{
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line of the slave AVR
     a06:	81 e0       	ldi	r24, 0x01	; 1
     a08:	0e 94 1b 03 	call	0x636 <MAIN_ResetCSLine>
				MAIN_Delay10MS(1);
     a0c:	81 e0       	ldi	r24, 0x01	; 1
     a0e:	0e 94 2f 02 	call	0x45e <MAIN_Delay10MS>
				MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE); // Capture the RESET line of the slave AVR
     a12:	80 e0       	ldi	r24, 0x00	; 0
     a14:	0e 94 1b 03 	call	0x636 <MAIN_ResetCSLine>
				ISPCC_EnterChipProgrammingMode(); // Try to sync with the slave AVR
     a18:	0e 94 80 10 	call	0x2100 <ISPCC_EnterChipProgrammingMode>
			}

			MAIN_ShowProgType('L');
     a1c:	8c e4       	ldi	r24, 0x4C	; 76
     a1e:	0e 94 4e 03 	call	0x69c <MAIN_ShowProgType>
		
			if (!(eeprom_read_byte_169(&Prog_TotalLockBytes)))
     a22:	8e e0       	ldi	r24, 0x0E	; 14
     a24:	91 e0       	ldi	r25, 0x01	; 1
     a26:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
     a2a:	88 23       	and	r24, r24
     a2c:	39 f4       	brne	.+14     	; 0xa3c <FUNCProgramAVR+0x20c>
			{
				Fault = ISPCC_FAULT_NODATATYPE;
     a2e:	83 e0       	ldi	r24, 0x03	; 3
     a30:	d8 2e       	mov	r13, r24
				MAIN_ShowError(PSTR("NO LOCK BYTES"));
     a32:	87 ea       	ldi	r24, 0xA7	; 167
     a34:	92 e0       	ldi	r25, 0x02	; 2
     a36:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
     a3a:	03 c0       	rjmp	.+6      	; 0xa42 <FUNCProgramAVR+0x212>
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_LOCK);
     a3c:	83 e0       	ldi	r24, 0x03	; 3
     a3e:	0e 94 ef 17 	call	0x2fde <PM_SendFuseLockBytes>
			}
		}

		strcpy_P(DoneFailMessageBuff, PSTR("PROGRAMMING DONE"));
     a42:	65 eb       	ldi	r22, 0xB5	; 181
     a44:	72 e0       	ldi	r23, 0x02	; 2
     a46:	ce 01       	movw	r24, r28
     a48:	01 96       	adiw	r24, 0x01	; 1
     a4a:	0e 94 3e 1b 	call	0x367c <strcpy_P>

		if (Fault != ISPCC_NO_FAULT)         // Takes less code to just overwrite part of the string on fail
     a4e:	dd 20       	and	r13, r13
     a50:	31 f0       	breq	.+12     	; 0xa5e <FUNCProgramAVR+0x22e>
		  strcpy_P(&DoneFailMessageBuff[12], PSTR("FAILED"));
     a52:	66 ec       	ldi	r22, 0xC6	; 198
     a54:	72 e0       	ldi	r23, 0x02	; 2
     a56:	ce 01       	movw	r24, r28
     a58:	0d 96       	adiw	r24, 0x0d	; 13
     a5a:	0e 94 3e 1b 	call	0x367c <strcpy_P>

		LCD_puts(DoneFailMessageBuff);
     a5e:	ce 01       	movw	r24, r28
     a60:	01 96       	adiw	r24, 0x01	; 1
     a62:	0e 94 c3 07 	call	0xf86 <LCD_puts>

		MAIN_Delay10MS(255);
     a66:	8f ef       	ldi	r24, 0xFF	; 255
     a68:	0e 94 2f 02 	call	0x45e <MAIN_Delay10MS>
		MAIN_Delay10MS(100);
     a6c:	84 e6       	ldi	r24, 0x64	; 100
     a6e:	0e 94 2f 02 	call	0x45e <MAIN_Delay10MS>
     a72:	04 c0       	rjmp	.+8      	; 0xa7c <FUNCProgramAVR+0x24c>
	}
	else
	{
		MAIN_ShowError(SyncErrorMessage);
     a74:	88 ee       	ldi	r24, 0xE8	; 232
     a76:	93 e0       	ldi	r25, 0x03	; 3
     a78:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
	}
	
	MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run	
     a7c:	81 e0       	ldi	r24, 0x01	; 1
     a7e:	0e 94 1b 03 	call	0x636 <MAIN_ResetCSLine>
	USI_SPIOff();
     a82:	0e 94 a2 09 	call	0x1344 <USI_SPIOff>
	DF_EnableDataflash(FALSE);
     a86:	80 e0       	ldi	r24, 0x00	; 0
     a88:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
	SPI_SPIOFF();
     a8c:	80 91 64 00 	lds	r24, 0x0064
     a90:	84 60       	ori	r24, 0x04	; 4
     a92:	80 93 64 00 	sts	0x0064, r24
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Green = ready
     a96:	81 b3       	in	r24, 0x11	; 17
     a98:	8f 7c       	andi	r24, 0xCF	; 207
     a9a:	80 61       	ori	r24, 0x10	; 16
     a9c:	81 bb       	out	0x11, r24	; 17
     a9e:	65 96       	adiw	r28, 0x15	; 21
     aa0:	0f b6       	in	r0, 0x3f	; 63
     aa2:	f8 94       	cli
     aa4:	de bf       	out	0x3e, r29	; 62
     aa6:	0f be       	out	0x3f, r0	; 63
     aa8:	cd bf       	out	0x3d, r28	; 61
     aaa:	df 91       	pop	r29
     aac:	cf 91       	pop	r28
     aae:	1f 91       	pop	r17
     ab0:	0f 91       	pop	r16
     ab2:	ff 90       	pop	r15
     ab4:	ef 90       	pop	r14
     ab6:	df 90       	pop	r13
     ab8:	08 95       	ret

00000aba <FUNCStoreProgram>:
}

void FUNCStoreProgram(void)
{
	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
     aba:	87 e4       	ldi	r24, 0x47	; 71
     abc:	99 e0       	ldi	r25, 0x09	; 9
     abe:	90 93 01 01 	sts	0x0101, r25
     ac2:	80 93 00 01 	sts	0x0100, r24
	SPI_SPIInit();
     ac6:	0e 94 3d 09 	call	0x127a <SPI_SPIInit>
	UseExernalDF = FALSE;
     aca:	10 92 84 02 	sts	0x0284, r1
	DF_EnableDataflash(TRUE);
     ace:	81 e0       	ldi	r24, 0x01	; 1
     ad0:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>

	if (!(DF_CheckCorrectOnboardChip()))
     ad4:	0e 94 6b 0b 	call	0x16d6 <DF_CheckCorrectOnboardChip>
     ad8:	88 23       	and	r24, r24
     ada:	c9 f0       	breq	.+50     	; 0xb0e <FUNCStoreProgram+0x54>
	  return;
			
	LCD_puts_f(PSTR("*STORAGE MODE*"));
     adc:	8d ec       	ldi	r24, 0xCD	; 205
     ade:	92 e0       	ldi	r25, 0x02	; 2
     ae0:	0e 94 04 08 	call	0x1008 <LCD_puts_f>

	InterpretPacketRoutine = (FuncPtr)PM_InterpretAVRISPPacket;
     ae4:	8d e2       	ldi	r24, 0x2D	; 45
     ae6:	95 e1       	ldi	r25, 0x15	; 21
     ae8:	90 93 25 01 	sts	0x0125, r25
     aec:	80 93 24 01 	sts	0x0124, r24
	InPMMode = TRUE;
     af0:	81 e0       	ldi	r24, 0x01	; 1
     af2:	80 93 47 02 	sts	0x0247, r24
	V2P_RunStateMachine();
     af6:	0e 94 0c 0f 	call	0x1e18 <V2P_RunStateMachine>
	InPMMode = FALSE;
     afa:	10 92 47 02 	sts	0x0247, r1
	DF_EnableDataflash(FALSE);
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
	SPI_SPIOFF();
     b04:	80 91 64 00 	lds	r24, 0x0064
     b08:	84 60       	ori	r24, 0x04	; 4
     b0a:	80 93 64 00 	sts	0x0064, r24
     b0e:	08 95       	ret

00000b10 <FUNCClearMem>:
}

void FUNCClearMem(void)
{
     b10:	0f 93       	push	r16
     b12:	1f 93       	push	r17
     b14:	cf 93       	push	r28
     b16:	df 93       	push	r29
     b18:	cd b7       	in	r28, 0x3d	; 61
     b1a:	de b7       	in	r29, 0x3e	; 62
     b1c:	22 97       	sbiw	r28, 0x02	; 2
     b1e:	0f b6       	in	r0, 0x3f	; 63
     b20:	f8 94       	cli
     b22:	de bf       	out	0x3e, r29	; 62
     b24:	0f be       	out	0x3f, r0	; 63
     b26:	cd bf       	out	0x3d, r28	; 61
	LCD_puts_f(PSTR("CONFIRM"));
     b28:	8c ed       	ldi	r24, 0xDC	; 220
     b2a:	92 e0       	ldi	r25, 0x02	; 2
     b2c:	0e 94 04 08 	call	0x1008 <LCD_puts_f>
	MAIN_Delay10MS(180);
     b30:	84 eb       	ldi	r24, 0xB4	; 180
     b32:	0e 94 2f 02 	call	0x45e <MAIN_Delay10MS>

	LCD_puts_f(PSTR("<N Y>"));
     b36:	84 ee       	ldi	r24, 0xE4	; 228
     b38:	92 e0       	ldi	r25, 0x02	; 2
     b3a:	0e 94 04 08 	call	0x1008 <LCD_puts_f>

	while (1)
	{
		if (JoyStatus)
     b3e:	8e b3       	in	r24, 0x1e	; 30
     b40:	88 23       	and	r24, r24
     b42:	e9 f3       	breq	.-6      	; 0xb3e <FUNCClearMem+0x2e>
		{
			if (JoyStatus & JOY_LEFT)
     b44:	8e b3       	in	r24, 0x1e	; 30
     b46:	99 27       	eor	r25, r25
     b48:	8c 01       	movw	r16, r24
     b4a:	04 70       	andi	r16, 0x04	; 4
     b4c:	10 70       	andi	r17, 0x00	; 0
     b4e:	82 fd       	sbrc	r24, 2
     b50:	29 c0       	rjmp	.+82     	; 0xba4 <FUNCClearMem+0x94>
			  return;
			else if (JoyStatus & JOY_RIGHT)
     b52:	f3 9b       	sbis	0x1e, 3	; 30
     b54:	f4 cf       	rjmp	.-24     	; 0xb3e <FUNCClearMem+0x2e>
			  break;
		}
	}

	MAIN_WaitForJoyRelease();
     b56:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>

	LCD_puts_f(WaitText);
     b5a:	8f e3       	ldi	r24, 0x3F	; 63
     b5c:	92 e0       	ldi	r25, 0x02	; 2
     b5e:	0e 94 04 08 	call	0x1008 <LCD_puts_f>

	for (uint16_t EAddr = 0; EAddr < Sys_MagicNumber; EAddr++)
     b62:	1a 83       	std	Y+2, r17	; 0x02
     b64:	09 83       	std	Y+1, r16	; 0x01
     b66:	80 91 02 01 	lds	r24, 0x0102
     b6a:	90 91 03 01 	lds	r25, 0x0103
     b6e:	08 17       	cp	r16, r24
     b70:	19 07       	cpc	r17, r25
     b72:	88 f4       	brcc	.+34     	; 0xb96 <FUNCClearMem+0x86>
	  eeprom_write_byte_169(&EAddr, 0xFF);
     b74:	6f ef       	ldi	r22, 0xFF	; 255
     b76:	ce 01       	movw	r24, r28
     b78:	01 96       	adiw	r24, 0x01	; 1
     b7a:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
     b7e:	89 81       	ldd	r24, Y+1	; 0x01
     b80:	9a 81       	ldd	r25, Y+2	; 0x02
     b82:	01 96       	adiw	r24, 0x01	; 1
     b84:	9a 83       	std	Y+2, r25	; 0x02
     b86:	89 83       	std	Y+1, r24	; 0x01
     b88:	20 91 02 01 	lds	r18, 0x0102
     b8c:	30 91 03 01 	lds	r19, 0x0103
     b90:	82 17       	cp	r24, r18
     b92:	93 07       	cpc	r25, r19
     b94:	78 f3       	brcs	.-34     	; 0xb74 <FUNCClearMem+0x64>

	LCD_puts_f(PSTR("MEM CLEARED"));
     b96:	8a ee       	ldi	r24, 0xEA	; 234
     b98:	92 e0       	ldi	r25, 0x02	; 2
     b9a:	0e 94 04 08 	call	0x1008 <LCD_puts_f>
	MAIN_Delay10MS(255);
     b9e:	8f ef       	ldi	r24, 0xFF	; 255
     ba0:	0e 94 2f 02 	call	0x45e <MAIN_Delay10MS>
     ba4:	22 96       	adiw	r28, 0x02	; 2
     ba6:	0f b6       	in	r0, 0x3f	; 63
     ba8:	f8 94       	cli
     baa:	de bf       	out	0x3e, r29	; 62
     bac:	0f be       	out	0x3f, r0	; 63
     bae:	cd bf       	out	0x3d, r28	; 61
     bb0:	df 91       	pop	r29
     bb2:	cf 91       	pop	r28
     bb4:	1f 91       	pop	r17
     bb6:	0f 91       	pop	r16
     bb8:	08 95       	ret

00000bba <FUNCAutoCalib>:
}

void FUNCAutoCalib(void)
{
	LCD_puts_f(WaitText);
     bba:	8f e3       	ldi	r24, 0x3F	; 63
     bbc:	92 e0       	ldi	r25, 0x02	; 2
     bbe:	0e 94 04 08 	call	0x1008 <LCD_puts_f>
	OSCCAL_Calibrate();
     bc2:	0e 94 3f 07 	call	0xe7e <OSCCAL_Calibrate>
     bc6:	08 95       	ret

00000bc8 <FUNCManCalib>:
}

void FUNCManCalib(void)
{
     bc8:	cf 93       	push	r28
     bca:	df 93       	push	r29
     bcc:	cd b7       	in	r28, 0x3d	; 61
     bce:	de b7       	in	r29, 0x3e	; 62
     bd0:	29 97       	sbiw	r28, 0x09	; 9
     bd2:	0f b6       	in	r0, 0x3f	; 63
     bd4:	f8 94       	cli
     bd6:	de bf       	out	0x3e, r29	; 62
     bd8:	0f be       	out	0x3f, r0	; 63
     bda:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[9];

	JoyStatus = 1;                           // Invalid value to force the LCD to update
     bdc:	81 e0       	ldi	r24, 0x01	; 1
     bde:	8e bb       	out	0x1e, r24	; 30
	
	USART_ENABLE(USART_TX_ON, USART_RX_OFF);
     be0:	80 91 c1 00 	lds	r24, 0x00C1
     be4:	80 78       	andi	r24, 0x80	; 128
     be6:	88 60       	ori	r24, 0x08	; 8
     be8:	80 93 c1 00 	sts	0x00C1, r24

	while (1)
	{
		if (BuffElements)                    // Routine will also echo send chars (directly accesses the ringbuffer count var)
     bec:	80 91 d2 02 	lds	r24, 0x02D2
     bf0:	88 23       	and	r24, r24
     bf2:	21 f0       	breq	.+8      	; 0xbfc <FUNCManCalib+0x34>
		   USART_Tx(BUFF_GetBuffByte());
     bf4:	0e 94 b6 0b 	call	0x176c <BUFF_GetBuffByte>
     bf8:	0e 94 f4 08 	call	0x11e8 <USART_Tx>
	
		if (JoyStatus)
     bfc:	8e b3       	in	r24, 0x1e	; 30
     bfe:	88 23       	and	r24, r24
     c00:	a9 f3       	breq	.-22     	; 0xbec <FUNCManCalib+0x24>
		{
			if (JoyStatus & JOY_UP)
     c02:	f6 9b       	sbis	0x1e, 6	; 30
     c04:	04 c0       	rjmp	.+8      	; 0xc0e <FUNCManCalib+0x46>
			  OSCCAL++;
     c06:	80 91 66 00 	lds	r24, 0x0066
     c0a:	8f 5f       	subi	r24, 0xFF	; 255
     c0c:	05 c0       	rjmp	.+10     	; 0xc18 <FUNCManCalib+0x50>
			else if (JoyStatus & JOY_DOWN)
     c0e:	f7 9b       	sbis	0x1e, 7	; 30
     c10:	06 c0       	rjmp	.+12     	; 0xc1e <FUNCManCalib+0x56>
			  OSCCAL--;
     c12:	80 91 66 00 	lds	r24, 0x0066
     c16:	81 50       	subi	r24, 0x01	; 1
     c18:	80 93 66 00 	sts	0x0066, r24
     c1c:	02 c0       	rjmp	.+4      	; 0xc22 <FUNCManCalib+0x5a>
			else if (JoyStatus & JOY_LEFT)
     c1e:	f2 99       	sbic	0x1e, 2	; 30
     c20:	1f c0       	rjmp	.+62     	; 0xc60 <FUNCManCalib+0x98>
			  break;
					
			// Copy the programmer name out of memory and transmit it via the USART:
			strcpy_P(Buffer, ProgrammerName);
     c22:	66 e3       	ldi	r22, 0x36	; 54
     c24:	72 e0       	ldi	r23, 0x02	; 2
     c26:	ce 01       	movw	r24, r28
     c28:	01 96       	adiw	r24, 0x01	; 1
     c2a:	0e 94 3e 1b 	call	0x367c <strcpy_P>
			USART_TxString(Buffer);
     c2e:	ce 01       	movw	r24, r28
     c30:	01 96       	adiw	r24, 0x01	; 1
     c32:	0e 94 fc 08 	call	0x11f8 <USART_TxString>

			Buffer[0] = 'C';
     c36:	83 e4       	ldi	r24, 0x43	; 67
     c38:	89 83       	std	Y+1, r24	; 0x01
			Buffer[1] = 'V';
     c3a:	86 e5       	ldi	r24, 0x56	; 86
     c3c:	8a 83       	std	Y+2, r24	; 0x02
			Buffer[2] = ' ';
     c3e:	80 e2       	ldi	r24, 0x20	; 32
     c40:	8b 83       	std	Y+3, r24	; 0x03

			MAIN_IntToStr(OSCCAL, &Buffer[3]);
     c42:	80 91 66 00 	lds	r24, 0x0066
     c46:	be 01       	movw	r22, r28
     c48:	6c 5f       	subi	r22, 0xFC	; 252
     c4a:	7f 4f       	sbci	r23, 0xFF	; 255
     c4c:	99 27       	eor	r25, r25
     c4e:	0e 94 36 03 	call	0x66c <MAIN_IntToStr>
			LCD_puts(Buffer);
     c52:	ce 01       	movw	r24, r28
     c54:	01 96       	adiw	r24, 0x01	; 1
     c56:	0e 94 c3 07 	call	0xf86 <LCD_puts>

			MAIN_WaitForJoyRelease();
     c5a:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     c5e:	c6 cf       	rjmp	.-116    	; 0xbec <FUNCManCalib+0x24>
		}
	}
	
	USART_ENABLE(USART_TX_OFF, USART_RX_OFF);
     c60:	80 91 c1 00 	lds	r24, 0x00C1
     c64:	80 78       	andi	r24, 0x80	; 128
     c66:	80 93 c1 00 	sts	0x00C1, r24
     c6a:	29 96       	adiw	r28, 0x09	; 9
     c6c:	0f b6       	in	r0, 0x3f	; 63
     c6e:	f8 94       	cli
     c70:	de bf       	out	0x3e, r29	; 62
     c72:	0f be       	out	0x3f, r0	; 63
     c74:	cd bf       	out	0x3d, r28	; 61
     c76:	df 91       	pop	r29
     c78:	cf 91       	pop	r28
     c7a:	08 95       	ret

00000c7c <FUNCSetContrast>:
}

void FUNCSetContrast(void)
{
     c7c:	1f 93       	push	r17
     c7e:	cf 93       	push	r28
     c80:	df 93       	push	r29
     c82:	cd b7       	in	r28, 0x3d	; 61
     c84:	de b7       	in	r29, 0x3e	; 62
     c86:	26 97       	sbiw	r28, 0x06	; 6
     c88:	0f b6       	in	r0, 0x3f	; 63
     c8a:	f8 94       	cli
     c8c:	de bf       	out	0x3e, r29	; 62
     c8e:	0f be       	out	0x3f, r0	; 63
     c90:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[6];
	uint8_t Contrast = (eeprom_read_byte_169(&Sys_LCDContrast) & 0x0F); // Ranges from 0-15 so mask retuns 15 on blank EEPROM (0xFF)
     c92:	84 e0       	ldi	r24, 0x04	; 4
     c94:	91 e0       	ldi	r25, 0x01	; 1
     c96:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
     c9a:	18 2f       	mov	r17, r24
     c9c:	1f 70       	andi	r17, 0x0F	; 15
	
	JoyStatus = 1;                          // Invalid value to force the LCD to update
     c9e:	81 e0       	ldi	r24, 0x01	; 1
     ca0:	8e bb       	out	0x1e, r24	; 30
	
	while (1)
	{
		if (JoyStatus)
     ca2:	8e b3       	in	r24, 0x1e	; 30
     ca4:	88 23       	and	r24, r24
     ca6:	e9 f3       	breq	.-6      	; 0xca2 <FUNCSetContrast+0x26>
		{
			if (JoyStatus & JOY_UP)
     ca8:	f6 9b       	sbis	0x1e, 6	; 30
     caa:	04 c0       	rjmp	.+8      	; 0xcb4 <FUNCSetContrast+0x38>
			{
				if (Contrast < 15)
     cac:	1f 30       	cpi	r17, 0x0F	; 15
     cae:	80 f4       	brcc	.+32     	; 0xcd0 <FUNCSetContrast+0x54>
				  Contrast++;
     cb0:	1f 5f       	subi	r17, 0xFF	; 255
     cb2:	0e c0       	rjmp	.+28     	; 0xcd0 <FUNCSetContrast+0x54>
			}
			else if (JoyStatus & JOY_DOWN)
     cb4:	f7 9b       	sbis	0x1e, 7	; 30
     cb6:	04 c0       	rjmp	.+8      	; 0xcc0 <FUNCSetContrast+0x44>
			{
				if (Contrast > 1)          // Zero is non-visible, so 1 is the minimum
     cb8:	12 30       	cpi	r17, 0x02	; 2
     cba:	50 f0       	brcs	.+20     	; 0xcd0 <FUNCSetContrast+0x54>
				  Contrast--;
     cbc:	11 50       	subi	r17, 0x01	; 1
     cbe:	08 c0       	rjmp	.+16     	; 0xcd0 <FUNCSetContrast+0x54>
			}
			else if (JoyStatus & JOY_LEFT)
     cc0:	f2 9b       	sbis	0x1e, 2	; 30
     cc2:	06 c0       	rjmp	.+12     	; 0xcd0 <FUNCSetContrast+0x54>
			{
				eeprom_write_byte_169(&Sys_LCDContrast, Contrast);
     cc4:	61 2f       	mov	r22, r17
     cc6:	84 e0       	ldi	r24, 0x04	; 4
     cc8:	91 e0       	ldi	r25, 0x01	; 1
     cca:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
				return;
     cce:	18 c0       	rjmp	.+48     	; 0xd00 <FUNCSetContrast+0x84>
			}
					
			Buffer[0] = 'C';
     cd0:	83 e4       	ldi	r24, 0x43	; 67
     cd2:	89 83       	std	Y+1, r24	; 0x01
			Buffer[1] = 'T';
     cd4:	84 e5       	ldi	r24, 0x54	; 84
     cd6:	8a 83       	std	Y+2, r24	; 0x02
			Buffer[2] = ' ';
     cd8:	80 e2       	ldi	r24, 0x20	; 32
     cda:	8b 83       	std	Y+3, r24	; 0x03

			MAIN_IntToStr((uint16_t)Contrast, &Buffer[3]);
     cdc:	be 01       	movw	r22, r28
     cde:	6c 5f       	subi	r22, 0xFC	; 252
     ce0:	7f 4f       	sbci	r23, 0xFF	; 255
     ce2:	81 2f       	mov	r24, r17
     ce4:	99 27       	eor	r25, r25
     ce6:	0e 94 36 03 	call	0x66c <MAIN_IntToStr>
			LCD_puts(Buffer);
     cea:	ce 01       	movw	r24, r28
     cec:	01 96       	adiw	r24, 0x01	; 1
     cee:	0e 94 c3 07 	call	0xf86 <LCD_puts>

			LCD_CONTRAST_LEVEL(Contrast);
     cf2:	81 2f       	mov	r24, r17
     cf4:	8f 70       	andi	r24, 0x0F	; 15
     cf6:	80 93 e7 00 	sts	0x00E7, r24

			MAIN_WaitForJoyRelease();
     cfa:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     cfe:	d1 cf       	rjmp	.-94     	; 0xca2 <FUNCSetContrast+0x26>
     d00:	26 96       	adiw	r28, 0x06	; 6
     d02:	0f b6       	in	r0, 0x3f	; 63
     d04:	f8 94       	cli
     d06:	de bf       	out	0x3e, r29	; 62
     d08:	0f be       	out	0x3f, r0	; 63
     d0a:	cd bf       	out	0x3d, r28	; 61
     d0c:	df 91       	pop	r29
     d0e:	cf 91       	pop	r28
     d10:	1f 91       	pop	r17
     d12:	08 95       	ret

00000d14 <FUNCSetISPSpeed>:
		}
	}
}

void FUNCSetISPSpeed(void)
{
     d14:	cf 93       	push	r28
	JoyStatus = 1;                         // Invalid value to force the LCD to update
     d16:	81 e0       	ldi	r24, 0x01	; 1
     d18:	8e bb       	out	0x1e, r24	; 30

	uint8_t CurrSpeed = eeprom_read_byte_169(&Param_SCKDuration);
     d1a:	80 e2       	ldi	r24, 0x20	; 32
     d1c:	91 e0       	ldi	r25, 0x01	; 1
     d1e:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
     d22:	c8 2f       	mov	r28, r24

	if (CurrSpeed > (USI_PRESET_SPEEDS - 1)) CurrSpeed = 0; // Protection against blank EEPROM
     d24:	84 30       	cpi	r24, 0x04	; 4
     d26:	08 f0       	brcs	.+2      	; 0xd2a <FUNCSetISPSpeed+0x16>
     d28:	c0 e0       	ldi	r28, 0x00	; 0

	while (1)
	{
		if (JoyStatus)
     d2a:	8e b3       	in	r24, 0x1e	; 30
     d2c:	88 23       	and	r24, r24
     d2e:	e9 f3       	breq	.-6      	; 0xd2a <FUNCSetISPSpeed+0x16>
		{
			if (JoyStatus & JOY_UP)
     d30:	f6 9b       	sbis	0x1e, 6	; 30
     d32:	06 c0       	rjmp	.+12     	; 0xd40 <FUNCSetISPSpeed+0x2c>
			{
				(CurrSpeed == 0)? CurrSpeed = (USI_PRESET_SPEEDS - 1) : CurrSpeed--;
     d34:	cc 23       	and	r28, r28
     d36:	11 f4       	brne	.+4      	; 0xd3c <FUNCSetISPSpeed+0x28>
     d38:	c3 e0       	ldi	r28, 0x03	; 3
     d3a:	12 c0       	rjmp	.+36     	; 0xd60 <FUNCSetISPSpeed+0x4c>
     d3c:	c1 50       	subi	r28, 0x01	; 1
     d3e:	10 c0       	rjmp	.+32     	; 0xd60 <FUNCSetISPSpeed+0x4c>
			}
			else if (JoyStatus & JOY_DOWN)
     d40:	f7 9b       	sbis	0x1e, 7	; 30
     d42:	06 c0       	rjmp	.+12     	; 0xd50 <FUNCSetISPSpeed+0x3c>
			{
				(CurrSpeed == (USI_PRESET_SPEEDS - 1))? CurrSpeed = 0 : CurrSpeed++;
     d44:	c3 30       	cpi	r28, 0x03	; 3
     d46:	11 f4       	brne	.+4      	; 0xd4c <FUNCSetISPSpeed+0x38>
     d48:	c0 e0       	ldi	r28, 0x00	; 0
     d4a:	0a c0       	rjmp	.+20     	; 0xd60 <FUNCSetISPSpeed+0x4c>
     d4c:	cf 5f       	subi	r28, 0xFF	; 255
     d4e:	08 c0       	rjmp	.+16     	; 0xd60 <FUNCSetISPSpeed+0x4c>
			}
			else if (JoyStatus & JOY_LEFT)
     d50:	f2 9b       	sbis	0x1e, 2	; 30
     d52:	06 c0       	rjmp	.+12     	; 0xd60 <FUNCSetISPSpeed+0x4c>
			{
				eeprom_write_byte_169(&Param_SCKDuration, CurrSpeed);
     d54:	6c 2f       	mov	r22, r28
     d56:	80 e2       	ldi	r24, 0x20	; 32
     d58:	91 e0       	ldi	r25, 0x01	; 1
     d5a:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
				return;
     d5e:	0d c0       	rjmp	.+26     	; 0xd7a <FUNCSetISPSpeed+0x66>
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&USIPSNamePtrs[CurrSpeed]));
     d60:	ec 2f       	mov	r30, r28
     d62:	ff 27       	eor	r31, r31
     d64:	ee 0f       	add	r30, r30
     d66:	ff 1f       	adc	r31, r31
     d68:	e3 58       	subi	r30, 0x83	; 131
     d6a:	ff 4f       	sbci	r31, 0xFF	; 255
     d6c:	85 91       	lpm	r24, Z+
     d6e:	94 91       	lpm	r25, Z
     d70:	0e 94 04 08 	call	0x1008 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     d74:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     d78:	d8 cf       	rjmp	.-80     	; 0xd2a <FUNCSetISPSpeed+0x16>
     d7a:	cf 91       	pop	r28
     d7c:	08 95       	ret

00000d7e <FUNCSleepMode>:
		}
	}
}

void FUNCSleepMode(void)
{
	SMCR    = ((1 << SM1) | (1 << SE));   // Power down sleep mode
     d7e:	85 e0       	ldi	r24, 0x05	; 5
     d80:	83 bf       	out	0x33, r24	; 51
	LCDCRA &= ~(1 << LCDEN); 
     d82:	80 91 e4 00 	lds	r24, 0x00E4
     d86:	8f 77       	andi	r24, 0x7F	; 127
     d88:	80 93 e4 00 	sts	0x00E4, r24
	
	while (!(JoyStatus & JOY_UP))        // Joystick interrupt wakes the micro
	  SLEEP();
     d8c:	f6 99       	sbic	0x1e, 6	; 30
     d8e:	03 c0       	rjmp	.+6      	; 0xd96 <FUNCSleepMode+0x18>
     d90:	88 95       	sleep
     d92:	f6 9b       	sbis	0x1e, 6	; 30
     d94:	fd cf       	rjmp	.-6      	; 0xd90 <FUNCSleepMode+0x12>
	   
	LCDCRA |= (1 << LCDEN);
     d96:	80 91 e4 00 	lds	r24, 0x00E4
     d9a:	80 68       	ori	r24, 0x80	; 128
     d9c:	80 93 e4 00 	sts	0x00E4, r24

	LCD_puts_f(WaitText);
     da0:	8f e3       	ldi	r24, 0x3F	; 63
     da2:	92 e0       	ldi	r25, 0x02	; 2
     da4:	0e 94 04 08 	call	0x1008 <LCD_puts_f>
	OSCCAL_Calibrate();	
     da8:	0e 94 3f 07 	call	0xe7e <OSCCAL_Calibrate>
	
	MAIN_WaitForJoyRelease();
     dac:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     db0:	08 95       	ret

00000db2 <FUNCStorageInfo>:
}

void FUNCStorageInfo(void)
{
     db2:	1f 93       	push	r17
     db4:	cf 93       	push	r28
	uint8_t SelectedItem = 0;
     db6:	10 e0       	ldi	r17, 0x00	; 0

	MAIN_WaitForJoyRelease();
     db8:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>

	JoyStatus = 1;                         // Invalid value to force the LCD to update
     dbc:	81 e0       	ldi	r24, 0x01	; 1
     dbe:	8e bb       	out	0x1e, r24	; 30

	while (1)
	{
		if (JoyStatus)
     dc0:	8e b3       	in	r24, 0x1e	; 30
     dc2:	88 23       	and	r24, r24
     dc4:	e9 f3       	breq	.-6      	; 0xdc0 <FUNCStorageInfo+0xe>
		{
			if (JoyStatus & (JOY_UP | JOY_DOWN))
     dc6:	ce b3       	in	r28, 0x1e	; 30
     dc8:	c0 7c       	andi	r28, 0xC0	; 192
     dca:	19 f0       	breq	.+6      	; 0xdd2 <FUNCStorageInfo+0x20>
			{
				SelectedItem ^= 1;
     dcc:	81 e0       	ldi	r24, 0x01	; 1
     dce:	18 27       	eor	r17, r24
     dd0:	38 c0       	rjmp	.+112    	; 0xe42 <FUNCStorageInfo+0x90>
			}
			else if (JoyStatus & JOY_LEFT)
     dd2:	f2 99       	sbic	0x1e, 2	; 30
     dd4:	43 c0       	rjmp	.+134    	; 0xe5c <FUNCStorageInfo+0xaa>
			{
				return;
			}
			else if (JoyStatus & JOY_PRESS)
     dd6:	f4 9b       	sbis	0x1e, 4	; 30
     dd8:	34 c0       	rjmp	.+104    	; 0xe42 <FUNCStorageInfo+0x90>
			{
				if (SelectedItem == 1)    // View storage tags
     dda:	11 30       	cpi	r17, 0x01	; 1
     ddc:	81 f5       	brne	.+96     	; 0xe3e <FUNCStorageInfo+0x8c>
				{
					DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
     dde:	87 e4       	ldi	r24, 0x47	; 71
     de0:	99 e0       	ldi	r25, 0x09	; 9
     de2:	90 93 01 01 	sts	0x0101, r25
     de6:	80 93 00 01 	sts	0x0100, r24
					SPI_SPIInit();
     dea:	0e 94 3d 09 	call	0x127a <SPI_SPIInit>
					UseExernalDF = FALSE;
     dee:	c0 93 84 02 	sts	0x0284, r28
					DF_EnableDataflash(TRUE);
     df2:	81 2f       	mov	r24, r17
     df4:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>

					if (DF_CheckCorrectOnboardChip())
     df8:	0e 94 6b 0b 	call	0x16d6 <DF_CheckCorrectOnboardChip>
     dfc:	c8 2f       	mov	r28, r24
     dfe:	88 23       	and	r24, r24
     e00:	41 f0       	breq	.+16     	; 0xe12 <FUNCStorageInfo+0x60>
					{
						TM_ShowTags();
     e02:	0e 94 10 1b 	call	0x3620 <TM_ShowTags>
						SPI_SPIOFF();
     e06:	80 91 64 00 	lds	r24, 0x0064
     e0a:	84 60       	ori	r24, 0x04	; 4
     e0c:	80 93 64 00 	sts	0x0064, r24
     e10:	18 c0       	rjmp	.+48     	; 0xe42 <FUNCStorageInfo+0x90>
					}
					else if (!(PM_GetStoredDataSize(TYPE_FLASH)))
     e12:	81 2f       	mov	r24, r17
     e14:	0e 94 7f 13 	call	0x26fe <PM_GetStoredDataSize>
     e18:	dc 01       	movw	r26, r24
     e1a:	cb 01       	movw	r24, r22
     e1c:	00 97       	sbiw	r24, 0x00	; 0
     e1e:	a1 05       	cpc	r26, r1
     e20:	b1 05       	cpc	r27, r1
     e22:	79 f4       	brne	.+30     	; 0xe42 <FUNCStorageInfo+0x90>
					{
						DF_EnableDataflash(FALSE);
     e24:	8c 2f       	mov	r24, r28
     e26:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
						SPI_SPIOFF();
     e2a:	80 91 64 00 	lds	r24, 0x0064
     e2e:	84 60       	ori	r24, 0x04	; 4
     e30:	80 93 64 00 	sts	0x0064, r24

						MAIN_ShowError(PSTR("NO STORED PRGM"));
     e34:	86 ef       	ldi	r24, 0xF6	; 246
     e36:	92 e0       	ldi	r25, 0x02	; 2
     e38:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
     e3c:	02 c0       	rjmp	.+4      	; 0xe42 <FUNCStorageInfo+0x90>
					}	
				}
				else                  // View stored data sizes
				{
					PM_ShowStoredItemSizes();
     e3e:	0e 94 ec 19 	call	0x33d8 <PM_ShowStoredItemSizes>
				}
			}
			
			LCD_puts_f((uint8_t*)pgm_read_word(&SIFOOptionPtrs[SelectedItem]));
     e42:	e1 2f       	mov	r30, r17
     e44:	ff 27       	eor	r31, r31
     e46:	ee 0f       	add	r30, r30
     e48:	ff 1f       	adc	r31, r31
     e4a:	e4 5a       	subi	r30, 0xA4	; 164
     e4c:	ff 4f       	sbci	r31, 0xFF	; 255
     e4e:	85 91       	lpm	r24, Z+
     e50:	94 91       	lpm	r25, Z
     e52:	0e 94 04 08 	call	0x1008 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     e56:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     e5a:	b2 cf       	rjmp	.-156    	; 0xdc0 <FUNCStorageInfo+0xe>
     e5c:	cf 91       	pop	r28
     e5e:	1f 91       	pop	r17
     e60:	08 95       	ret

00000e62 <FUNCGoBootloader>:
		}
	}
}

void FUNCGoBootloader(void)
{
	uint8_t MD = (MCUCR & ~(1 << JTD)); // Forces compiler to use IN, AND plus two OUTs rather than two lots of IN/AND/OUTs
     e62:	85 b7       	in	r24, 0x35	; 53
     e64:	8f 77       	andi	r24, 0x7F	; 127
	MCUCR = MD;  // Turn on JTAG via code
     e66:	85 bf       	out	0x35, r24	; 53
	MCUCR = MD;  // Twice as specified in datasheet        
     e68:	85 bf       	out	0x35, r24	; 53
	
	LCD_puts_f(PSTR("*JTAG ON*"));
     e6a:	85 e0       	ldi	r24, 0x05	; 5
     e6c:	93 e0       	ldi	r25, 0x03	; 3
     e6e:	0e 94 04 08 	call	0x1008 <LCD_puts_f>
	
	MAIN_WaitForJoyRelease();
     e72:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
	
	WDTCR = ((1<<WDCE) | (1<<WDE)); // Enable Watchdog Timer to give reset after minimum timeout
     e76:	88 e1       	ldi	r24, 0x18	; 24
     e78:	80 93 60 00 	sts	0x0060, r24
	while (1) {};                  // Eternal loop - when watchdog resets the AVR it will enter the bootloader
     e7c:	ff cf       	rjmp	.-2      	; 0xe7c <FUNCGoBootloader+0x1a>

00000e7e <OSCCAL_Calibrate>:
	unsigned char SREG_Backup;
	unsigned char LoopCount = 64; // Maximum range is 128, and starts from the middle, so 64 is the max number of iterations required
   
	// Make sure all clock division is turned off (8Mhz RC clock)
	CLKPR = (1 << CLKPCE);
     e7e:	80 e8       	ldi	r24, 0x80	; 128
     e80:	80 93 61 00 	sts	0x0061, r24
	CLKPR = 0;
     e84:	10 92 61 00 	sts	0x0061, r1

	// Inital OSCCAL of half its maximum for speed
	OSCCAL = (0x7F / 2);
     e88:	8f e3       	ldi	r24, 0x3F	; 63
     e8a:	80 93 66 00 	sts	0x0066, r24

	//Save the SREG
	SREG_Backup = SREG;
     e8e:	3f b7       	in	r19, 0x3f	; 63
    
	// Disable all timer 1 interrupts
	TIMSK1 = 0;
     e90:	10 92 6f 00 	sts	0x006F, r1
        
	// Set timer 2 to asyncronous mode (32.768KHz crystal)
	ASSR  = (1 << AS2);
     e94:	88 e0       	ldi	r24, 0x08	; 8
     e96:	80 93 b6 00 	sts	0x00B6, r24
        
	// Timer 2 overflow interrupt enable
	TIMSK2 = (1 << TOIE2);
     e9a:	81 e0       	ldi	r24, 0x01	; 1
     e9c:	80 93 70 00 	sts	0x0070, r24

	//Enable interrupts
	sei();
     ea0:	78 94       	sei

	// Start both counters with no prescaling
	TCCR1B = (1 << CS10);
     ea2:	80 93 81 00 	sts	0x0081, r24
	TCCR2A = (1 << CS20);
     ea6:	80 93 b0 00 	sts	0x00B0, r24
	 	 
	// Wait until timer 2's external 32.768KHz crystal is stable
	while (ASSR & ((1 << TCN2UB) | (1 << TCR2UB) | (1 << OCR2UB)));
     eaa:	80 91 b6 00 	lds	r24, 0x00B6
     eae:	99 27       	eor	r25, r25
     eb0:	87 70       	andi	r24, 0x07	; 7
     eb2:	90 70       	andi	r25, 0x00	; 0
     eb4:	00 97       	sbiw	r24, 0x00	; 0
     eb6:	c9 f7       	brne	.-14     	; 0xeaa <OSCCAL_Calibrate+0x2c>
    
	// Clear the timer values
	TCNT1 = 0;
     eb8:	90 93 85 00 	sts	0x0085, r25
     ebc:	80 93 84 00 	sts	0x0084, r24
	TCNT2 = 0;
     ec0:	10 92 b2 00 	sts	0x00B2, r1
    
	while (LoopCount--)
	{
		// Let it take a few readings (60ms, approx 7 readings)
		_delay_ms(60);
        
		if (ActualCount > (TARGETCOUNT + 5))		    // Clock is running too fast
		{
			// Bit 7 selects low or high range - only low range is nessesary
			OSCCAL = ((OSCCAL - 1) & ~(1 << 7));
		}
		else if (ActualCount < (TARGETCOUNT - 5))		// Clock is running too slow
		{
			// Bit 7 selects low or high range - only low range is nessesary
			OSCCAL = ((OSCCAL + 1) & ~(1 << 7));
		}
		else		                                    // Clock is just right
		{
			break;
     ec4:	2f e3       	ldi	r18, 0x3F	; 63
     ec6:	fc 01       	movw	r30, r24
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     ec8:	cf 01       	movw	r24, r30
     eca:	01 97       	sbiw	r24, 0x01	; 1
     ecc:	f1 f7       	brne	.-4      	; 0xeca <OSCCAL_Calibrate+0x4c>
     ece:	80 91 26 01 	lds	r24, 0x0126
     ed2:	90 91 27 01 	lds	r25, 0x0127
     ed6:	81 50       	subi	r24, 0x01	; 1
     ed8:	91 4e       	sbci	r25, 0xE1	; 225
     eda:	20 f0       	brcs	.+8      	; 0xee4 <OSCCAL_Calibrate+0x66>
     edc:	80 91 66 00 	lds	r24, 0x0066
     ee0:	81 50       	subi	r24, 0x01	; 1
     ee2:	0a c0       	rjmp	.+20     	; 0xef8 <OSCCAL_Calibrate+0x7a>
     ee4:	80 91 26 01 	lds	r24, 0x0126
     ee8:	90 91 27 01 	lds	r25, 0x0127
     eec:	86 5f       	subi	r24, 0xF6	; 246
     eee:	90 4e       	sbci	r25, 0xE0	; 224
     ef0:	40 f4       	brcc	.+16     	; 0xf02 <OSCCAL_Calibrate+0x84>
     ef2:	80 91 66 00 	lds	r24, 0x0066
     ef6:	8f 5f       	subi	r24, 0xFF	; 255
     ef8:	8f 77       	andi	r24, 0x7F	; 127
     efa:	80 93 66 00 	sts	0x0066, r24
     efe:	21 50       	subi	r18, 0x01	; 1
     f00:	18 f7       	brcc	.-58     	; 0xec8 <OSCCAL_Calibrate+0x4a>
		}		
	}
            
	// Disable all timer interrupts
	TIMSK1 = 0;
     f02:	10 92 6f 00 	sts	0x006F, r1
	TIMSK2 = 0;
     f06:	10 92 70 00 	sts	0x0070, r1
    
	// Stop the timers
	TCCR1B = 0x00;
     f0a:	10 92 81 00 	sts	0x0081, r1
	TCCR2A = 0x00;
     f0e:	10 92 b0 00 	sts	0x00B0, r1

	// Turn off timer 2 asynchronous mode
	ASSR  &= ~(1 << AS2);
     f12:	80 91 b6 00 	lds	r24, 0x00B6
     f16:	87 7f       	andi	r24, 0xF7	; 247
     f18:	80 93 b6 00 	sts	0x00B6, r24

	// Restore SREG
	SREG = SREG_Backup;
     f1c:	3f bf       	out	0x3f, r19	; 63
     f1e:	08 95       	ret

00000f20 <__vector_5>:
        
	return;
}

ISR(TIMER2_OVF_vect, ISR_BLOCK) // Occurs 32768/256 timers per second, or 128Hz
{
     f20:	1f 92       	push	r1
     f22:	0f 92       	push	r0
     f24:	0f b6       	in	r0, 0x3f	; 63
     f26:	0f 92       	push	r0
     f28:	11 24       	eor	r1, r1
     f2a:	8f 93       	push	r24
     f2c:	9f 93       	push	r25
	// Stop timer 1 so it can be read
	TCCR1B = 0x00;
     f2e:	10 92 81 00 	sts	0x0081, r1
    
	// Record timer 1's value
	ActualCount = TCNT1;
     f32:	80 91 84 00 	lds	r24, 0x0084
     f36:	90 91 85 00 	lds	r25, 0x0085
     f3a:	90 93 27 01 	sts	0x0127, r25
     f3e:	80 93 26 01 	sts	0x0126, r24
	     
	// Reset counters and restart timer 1
	TCNT1  = 0;
     f42:	10 92 85 00 	sts	0x0085, r1
     f46:	10 92 84 00 	sts	0x0084, r1
	TCNT2  = 0;
     f4a:	10 92 b2 00 	sts	0x00B2, r1
	TCCR1B = (1 << CS10);
     f4e:	81 e0       	ldi	r24, 0x01	; 1
     f50:	80 93 81 00 	sts	0x0081, r24
     f54:	9f 91       	pop	r25
     f56:	8f 91       	pop	r24
     f58:	0f 90       	pop	r0
     f5a:	0f be       	out	0x3f, r0	; 63
     f5c:	0f 90       	pop	r0
     f5e:	1f 90       	pop	r1
     f60:	18 95       	reti

00000f62 <LCD_Init>:
// ======================================================================================

void LCD_Init(void)
{
	LCDCCR = 0x0F;
     f62:	8f e0       	ldi	r24, 0x0F	; 15
     f64:	80 93 e7 00 	sts	0x00E7, r24

    // Select asynchronous clock source, enable all COM pins and enable all segment pins.
    LCDCRB  = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
     f68:	87 eb       	ldi	r24, 0xB7	; 183
     f6a:	80 93 e5 00 	sts	0x00E5, r24

    // Set LCD prescaler to give a framerate of 32,0 Hz
    LCDFRR  = (0<<LCDPS0) | (7<<LCDCD0);    
     f6e:	87 e0       	ldi	r24, 0x07	; 7
     f70:	80 93 e6 00 	sts	0x00E6, r24

	// Enable LCD and set low power waveform
    LCDCRA  = (1<<LCDEN) | (1<<LCDAB); 
     f74:	80 ec       	ldi	r24, 0xC0	; 192
     f76:	80 93 e4 00 	sts	0x00E4, r24

    //Enable LCD start of frame interrupt
    LCDCRA |= (1<<LCDIE);
     f7a:	80 91 e4 00 	lds	r24, 0x00E4
     f7e:	88 60       	ori	r24, 0x08	; 8
     f80:	80 93 e4 00 	sts	0x00E4, r24
     f84:	08 95       	ret

00000f86 <LCD_puts>:
}

void LCD_puts_f(const uint8_t *FlashData)
{
	uint8_t StrBuff[LCD_TEXTBUFFER_SIZE];

	strcpy_P(StrBuff, FlashData);
	LCD_puts(StrBuff);
}

void LCD_puts(uint8_t *Data)
{
     f86:	cf 93       	push	r28
     f88:	df 93       	push	r29
     f8a:	ec 01       	movw	r28, r24
	uint8_t LoadB;
	
	for (LoadB = 0; LoadB < 20; LoadB++)
     f8c:	20 e0       	ldi	r18, 0x00	; 0
     f8e:	3f ef       	ldi	r19, 0xFF	; 255
     f90:	e0 e5       	ldi	r30, 0x50	; 80
     f92:	f2 e0       	ldi	r31, 0x02	; 2
     f94:	df 01       	movw	r26, r30
	{
		uint8_t CByte = *(Data++);
     f96:	89 91       	ld	r24, Y+
	
		if ((CByte >= '*') && (CByte <= 'z'))
     f98:	98 2f       	mov	r25, r24
     f9a:	9a 52       	subi	r25, 0x2A	; 42
     f9c:	91 35       	cpi	r25, 0x51	; 81
     f9e:	38 f4       	brcc	.+14     	; 0xfae <LCD_puts+0x28>
		  TextBuffer[LoadB] = ((CByte == ' ')? 0xFF : (CByte - '*'));
     fa0:	80 32       	cpi	r24, 0x20	; 32
     fa2:	11 f0       	breq	.+4      	; 0xfa8 <LCD_puts+0x22>
     fa4:	89 2f       	mov	r24, r25
     fa6:	01 c0       	rjmp	.+2      	; 0xfaa <LCD_puts+0x24>
     fa8:	8f ef       	ldi	r24, 0xFF	; 255
     faa:	8c 93       	st	X, r24
     fac:	03 c0       	rjmp	.+6      	; 0xfb4 <LCD_puts+0x2e>
		else if (CByte == 0x00)
     fae:	88 23       	and	r24, r24
     fb0:	31 f0       	breq	.+12     	; 0xfbe <LCD_puts+0x38>
		  break;
		else
		  TextBuffer[LoadB] = 0xFF;		
     fb2:	30 83       	st	Z, r19
     fb4:	2f 5f       	subi	r18, 0xFF	; 255
     fb6:	11 96       	adiw	r26, 0x01	; 1
     fb8:	31 96       	adiw	r30, 0x01	; 1
     fba:	24 31       	cpi	r18, 0x14	; 20
     fbc:	60 f3       	brcs	.-40     	; 0xf96 <LCD_puts+0x10>
	}

	ScrollMode  = ((LoadB > 6)? TRUE : FALSE);
     fbe:	80 e0       	ldi	r24, 0x00	; 0
     fc0:	27 30       	cpi	r18, 0x07	; 7
     fc2:	08 f0       	brcs	.+2      	; 0xfc6 <LCD_puts+0x40>
     fc4:	81 e0       	ldi	r24, 0x01	; 1
     fc6:	80 93 80 02 	sts	0x0280, r24
	ScrollCount = 0;
     fca:	10 92 4e 02 	sts	0x024E, r1
     fce:	9f ef       	ldi	r25, 0xFF	; 255
     fd0:	86 e0       	ldi	r24, 0x06	; 6

	for (uint8_t Nulls = 0; Nulls < 7; Nulls++)
		TextBuffer[LoadB++] = 0xFF;
     fd2:	e2 2f       	mov	r30, r18
     fd4:	ff 27       	eor	r31, r31
     fd6:	e0 5b       	subi	r30, 0xB0	; 176
     fd8:	fd 4f       	sbci	r31, 0xFD	; 253
     fda:	90 83       	st	Z, r25
     fdc:	2f 5f       	subi	r18, 0xFF	; 255
     fde:	81 50       	subi	r24, 0x01	; 1
     fe0:	87 ff       	sbrs	r24, 7
     fe2:	f7 cf       	rjmp	.-18     	; 0xfd2 <LCD_puts+0x4c>
	
	TextBuffer[LoadB] = 0x00;
     fe4:	e2 2f       	mov	r30, r18
     fe6:	ff 27       	eor	r31, r31
     fe8:	e0 5b       	subi	r30, 0xB0	; 176
     fea:	fd 4f       	sbci	r31, 0xFD	; 253
     fec:	10 82       	st	Z, r1
	StrStart   = 0;
     fee:	10 92 4f 02 	sts	0x024F, r1
	StrEnd     = LoadB;	
     ff2:	20 93 4d 02 	sts	0x024D, r18
	DelayCount = LCD_DELAYCOUNT_DEFAULT;
     ff6:	8a e0       	ldi	r24, 0x0A	; 10
     ff8:	80 93 81 02 	sts	0x0281, r24

	UpdateLCD  = TRUE;
     ffc:	81 e0       	ldi	r24, 0x01	; 1
     ffe:	80 93 6b 02 	sts	0x026B, r24
    1002:	df 91       	pop	r29
    1004:	cf 91       	pop	r28
    1006:	08 95       	ret

00001008 <LCD_puts_f>:
    1008:	cf 93       	push	r28
    100a:	df 93       	push	r29
    100c:	cd b7       	in	r28, 0x3d	; 61
    100e:	de b7       	in	r29, 0x3e	; 62
    1010:	64 97       	sbiw	r28, 0x14	; 20
    1012:	0f b6       	in	r0, 0x3f	; 63
    1014:	f8 94       	cli
    1016:	de bf       	out	0x3e, r29	; 62
    1018:	0f be       	out	0x3f, r0	; 63
    101a:	cd bf       	out	0x3d, r28	; 61
    101c:	bc 01       	movw	r22, r24
    101e:	ce 01       	movw	r24, r28
    1020:	01 96       	adiw	r24, 0x01	; 1
    1022:	0e 94 3e 1b 	call	0x367c <strcpy_P>
    1026:	ce 01       	movw	r24, r28
    1028:	01 96       	adiw	r24, 0x01	; 1
    102a:	0e 94 c3 07 	call	0xf86 <LCD_puts>
    102e:	64 96       	adiw	r28, 0x14	; 20
    1030:	0f b6       	in	r0, 0x3f	; 63
    1032:	f8 94       	cli
    1034:	de bf       	out	0x3e, r29	; 62
    1036:	0f be       	out	0x3f, r0	; 63
    1038:	cd bf       	out	0x3d, r28	; 61
    103a:	df 91       	pop	r29
    103c:	cf 91       	pop	r28
    103e:	08 95       	ret

00001040 <LCD_WriteChar>:
}

void LCD_WriteChar(uint8_t Byte, uint8_t Digit)
{
    1040:	e8 2f       	mov	r30, r24
	uint16_t SegData  = 0x00;
    1042:	20 e0       	ldi	r18, 0x00	; 0
    1044:	30 e0       	ldi	r19, 0x00	; 0
	uint8_t  *BuffPtr = (&SegBuffer[0] + (Digit >> 1));
    1046:	86 2f       	mov	r24, r22
    1048:	86 95       	lsr	r24
    104a:	a8 2f       	mov	r26, r24
    104c:	bb 27       	eor	r27, r27
    104e:	a4 59       	subi	r26, 0x94	; 148
    1050:	bd 4f       	sbci	r27, 0xFD	; 253

	if (Byte != 0xFF)
    1052:	ef 3f       	cpi	r30, 0xFF	; 255
    1054:	39 f0       	breq	.+14     	; 0x1064 <LCD_WriteChar+0x24>
	  SegData = pgm_read_word(&LCD_SegTable[Byte]);	
    1056:	ff 27       	eor	r31, r31
    1058:	ee 0f       	add	r30, r30
    105a:	ff 1f       	adc	r31, r31
    105c:	e1 5f       	subi	r30, 0xF1	; 241
    105e:	fc 4f       	sbci	r31, 0xFC	; 252
    1060:	25 91       	lpm	r18, Z+
    1062:	34 91       	lpm	r19, Z
    1064:	77 27       	eor	r23, r23
    1066:	61 70       	andi	r22, 0x01	; 1
    1068:	70 70       	andi	r23, 0x00	; 0
    106a:	43 e0       	ldi	r20, 0x03	; 3

	for (uint8_t BNib = 0; BNib < 4; BNib++)
	{
		uint8_t Mask          = 0xF0;
    106c:	50 ef       	ldi	r21, 0xF0	; 240
		uint8_t MaskedSegData = (SegData & 0x0000F);
    106e:	92 2f       	mov	r25, r18
    1070:	9f 70       	andi	r25, 0x0F	; 15
	
		if (Digit & 0x01)
    1072:	61 15       	cp	r22, r1
    1074:	71 05       	cpc	r23, r1
    1076:	19 f0       	breq	.+6      	; 0x107e <LCD_WriteChar+0x3e>
		{
			Mask = 0x0F;
    1078:	5f e0       	ldi	r21, 0x0F	; 15
			MaskedSegData <<= 4;
    107a:	92 95       	swap	r25
    107c:	90 7f       	andi	r25, 0xF0	; 240
		}
		
		*BuffPtr = ((*BuffPtr & Mask) | MaskedSegData);
    107e:	8c 91       	ld	r24, X
    1080:	85 23       	and	r24, r21
    1082:	89 2b       	or	r24, r25
    1084:	8c 93       	st	X, r24

		SegData >>= 4;
    1086:	84 e0       	ldi	r24, 0x04	; 4
    1088:	36 95       	lsr	r19
    108a:	27 95       	ror	r18
    108c:	8a 95       	dec	r24
    108e:	e1 f7       	brne	.-8      	; 0x1088 <LCD_WriteChar+0x48>
		BuffPtr  += 5;
    1090:	15 96       	adiw	r26, 0x05	; 5
    1092:	41 50       	subi	r20, 0x01	; 1
    1094:	47 ff       	sbrs	r20, 7
    1096:	ea cf       	rjmp	.-44     	; 0x106c <LCD_WriteChar+0x2c>
    1098:	08 95       	ret

0000109a <__vector_22>:
	}
}

ISR(LCD_vect, ISR_NOBLOCK)
{
    109a:	78 94       	sei
    109c:	1f 92       	push	r1
    109e:	0f 92       	push	r0
    10a0:	0f b6       	in	r0, 0x3f	; 63
    10a2:	0f 92       	push	r0
    10a4:	11 24       	eor	r1, r1
    10a6:	2f 93       	push	r18
    10a8:	3f 93       	push	r19
    10aa:	4f 93       	push	r20
    10ac:	5f 93       	push	r21
    10ae:	6f 93       	push	r22
    10b0:	7f 93       	push	r23
    10b2:	8f 93       	push	r24
    10b4:	9f 93       	push	r25
    10b6:	af 93       	push	r26
    10b8:	bf 93       	push	r27
    10ba:	cf 93       	push	r28
    10bc:	ef 93       	push	r30
    10be:	ff 93       	push	r31
	if (ScrollMode)
    10c0:	80 91 80 02 	lds	r24, 0x0280
    10c4:	88 23       	and	r24, r24
    10c6:	99 f0       	breq	.+38     	; 0x10ee <__vector_22+0x54>
	{
		if (DelayCount)
    10c8:	80 91 81 02 	lds	r24, 0x0281
    10cc:	88 23       	and	r24, r24
    10ce:	21 f0       	breq	.+8      	; 0x10d8 <__vector_22+0x3e>
		{
			DelayCount--;
    10d0:	81 50       	subi	r24, 0x01	; 1
    10d2:	80 93 81 02 	sts	0x0281, r24
    10d6:	0b c0       	rjmp	.+22     	; 0x10ee <__vector_22+0x54>
		}
		else
		{
			if (!(ScrollCount))
    10d8:	80 91 4e 02 	lds	r24, 0x024E
    10dc:	88 23       	and	r24, r24
    10de:	21 f4       	brne	.+8      	; 0x10e8 <__vector_22+0x4e>
			  UpdateLCD = TRUE;
    10e0:	81 e0       	ldi	r24, 0x01	; 1
    10e2:	80 93 6b 02 	sts	0x026B, r24
    10e6:	03 c0       	rjmp	.+6      	; 0x10ee <__vector_22+0x54>
			else
			  ScrollCount--;
    10e8:	81 50       	subi	r24, 0x01	; 1
    10ea:	80 93 4e 02 	sts	0x024E, r24
		}
	}

	if (UpdateLCD)
    10ee:	80 91 6b 02 	lds	r24, 0x026B
    10f2:	88 23       	and	r24, r24
    10f4:	39 f1       	breq	.+78     	; 0x1144 <__vector_22+0xaa>
	{
		for (uint8_t Character = 0; Character < 6; Character++)
    10f6:	c0 e0       	ldi	r28, 0x00	; 0
		{
			uint8_t Byte = (StrStart + Character);
    10f8:	80 91 4f 02 	lds	r24, 0x024F
    10fc:	8c 0f       	add	r24, r28

			if (Byte >= StrEnd)
    10fe:	90 91 4d 02 	lds	r25, 0x024D
    1102:	e8 2f       	mov	r30, r24
    1104:	ff 27       	eor	r31, r31
    1106:	89 17       	cp	r24, r25
    1108:	10 f0       	brcs	.+4      	; 0x110e <__vector_22+0x74>
			  Byte = TextBuffer[Byte - StrEnd];
    110a:	e9 1b       	sub	r30, r25
    110c:	f1 09       	sbc	r31, r1
			else
			  Byte = TextBuffer[Byte];
    110e:	e0 5b       	subi	r30, 0xB0	; 176
    1110:	fd 4f       	sbci	r31, 0xFD	; 253
    1112:	80 81       	ld	r24, Z
			
			LCD_WriteChar(Byte, Character);
    1114:	6c 2f       	mov	r22, r28
    1116:	0e 94 20 08 	call	0x1040 <LCD_WriteChar>
    111a:	cf 5f       	subi	r28, 0xFF	; 255
    111c:	c6 30       	cpi	r28, 0x06	; 6
    111e:	60 f3       	brcs	.-40     	; 0x10f8 <__vector_22+0x5e>
		}
		
		if (StrStart++ == StrEnd)
    1120:	80 91 4f 02 	lds	r24, 0x024F
    1124:	98 2f       	mov	r25, r24
    1126:	8f 5f       	subi	r24, 0xFF	; 255
    1128:	80 93 4f 02 	sts	0x024F, r24
    112c:	80 91 4d 02 	lds	r24, 0x024D
    1130:	98 17       	cp	r25, r24
    1132:	19 f4       	brne	.+6      	; 0x113a <__vector_22+0xa0>
		  StrStart = 1;
    1134:	81 e0       	ldi	r24, 0x01	; 1
    1136:	80 93 4f 02 	sts	0x024F, r24
		
		ScrollCount = LCD_SCROLLCOUNT_DEFAULT;
    113a:	83 e0       	ldi	r24, 0x03	; 3
    113c:	80 93 4e 02 	sts	0x024E, r24
		UpdateLCD = FALSE;
    1140:	10 92 6b 02 	sts	0x026B, r1
    1144:	ac ee       	ldi	r26, 0xEC	; 236
    1146:	b0 e0       	ldi	r27, 0x00	; 0
    1148:	ec e6       	ldi	r30, 0x6C	; 108
    114a:	f2 e0       	ldi	r31, 0x02	; 2
    114c:	93 e1       	ldi	r25, 0x13	; 19
	}

	for (uint8_t LCDChar = 0; LCDChar < LCD_SEGBUFFER_SIZE; LCDChar++)
	  *(pLCDREG + LCDChar) = SegBuffer[LCDChar];
    114e:	81 91       	ld	r24, Z+
    1150:	8d 93       	st	X+, r24
    1152:	91 50       	subi	r25, 0x01	; 1
    1154:	97 ff       	sbrs	r25, 7
    1156:	fb cf       	rjmp	.-10     	; 0x114e <__vector_22+0xb4>
    1158:	ff 91       	pop	r31
    115a:	ef 91       	pop	r30
    115c:	cf 91       	pop	r28
    115e:	bf 91       	pop	r27
    1160:	af 91       	pop	r26
    1162:	9f 91       	pop	r25
    1164:	8f 91       	pop	r24
    1166:	7f 91       	pop	r23
    1168:	6f 91       	pop	r22
    116a:	5f 91       	pop	r21
    116c:	4f 91       	pop	r20
    116e:	3f 91       	pop	r19
    1170:	2f 91       	pop	r18
    1172:	0f 90       	pop	r0
    1174:	0f be       	out	0x3f, r0	; 63
    1176:	0f 90       	pop	r0
    1178:	1f 90       	pop	r1
    117a:	18 95       	reti

0000117c <eeprom_read_byte_169>:
#include <avr/interrupt.h>
#include "eeprom169.h"

uint8_t eeprom_read_byte_169(const uint16_t *addr)
{
    117c:	fc 01       	movw	r30, r24
	cli();
    117e:	f8 94       	cli
	/* Set up address register */
	EEAR = *addr;
    1180:	80 81       	ld	r24, Z
    1182:	91 81       	ldd	r25, Z+1	; 0x01
    1184:	92 bd       	out	0x22, r25	; 34
    1186:	81 bd       	out	0x21, r24	; 33
	/* Start eeprom read by writing EERE */
	EECR |= (1<<EERE);
    1188:	f8 9a       	sbi	0x1f, 0	; 31
	sei();
    118a:	78 94       	sei
	/* Return data from Data Register */
	return EEDR;
    118c:	80 b5       	in	r24, 0x20	; 32
}
    118e:	99 27       	eor	r25, r25
    1190:	08 95       	ret

00001192 <eeprom_write_byte_169>:

void eeprom_write_byte_169(const uint16_t *addr, uint8_t val) 
{
    1192:	1f 93       	push	r17
    1194:	cf 93       	push	r28
    1196:	df 93       	push	r29
    1198:	ec 01       	movw	r28, r24
    119a:	16 2f       	mov	r17, r22
	if(eeprom_read_byte_169(addr) == val) // Compare stored value with new value for match
    119c:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
    11a0:	81 17       	cp	r24, r17
    11a2:	59 f0       	breq	.+22     	; 0x11ba <eeprom_write_byte_169+0x28>
		return; // Don't re-write the same value and waste EEPROM life

	cli();
    11a4:	f8 94       	cli
	/* Set up address and Data Registers */
	EEAR = *addr;
    11a6:	88 81       	ld	r24, Y
    11a8:	99 81       	ldd	r25, Y+1	; 0x01
    11aa:	92 bd       	out	0x22, r25	; 34
    11ac:	81 bd       	out	0x21, r24	; 33
	EEDR = val;
    11ae:	10 bd       	out	0x20, r17	; 32
	/* Write logical one to EEMWE */
	EECR |= (1<<EEMWE);
    11b0:	fa 9a       	sbi	0x1f, 2	; 31
	/* Start eeprom write by setting EEWE */
	EECR |= (1<<EEWE);
    11b2:	f9 9a       	sbi	0x1f, 1	; 31
	sei();
    11b4:	78 94       	sei
	/* Wait for completion */
	while(EECR & (1<<EEWE));
    11b6:	f9 99       	sbic	0x1f, 1	; 31
    11b8:	fe cf       	rjmp	.-4      	; 0x11b6 <eeprom_write_byte_169+0x24>
    11ba:	df 91       	pop	r29
    11bc:	cf 91       	pop	r28
    11be:	1f 91       	pop	r17
    11c0:	08 95       	ret

000011c2 <USART_Init>:
*   Purpose :       Initialize the USART
*
*****************************************************************************/
void USART_Init(unsigned int baudrate)
{
    11c2:	9c 01       	movw	r18, r24
    // Set baud rate
    UBRRH = (unsigned char)(baudrate>>8);
    11c4:	83 2f       	mov	r24, r19
    11c6:	99 27       	eor	r25, r25
    11c8:	80 93 c5 00 	sts	0x00C5, r24
    UBRRL = (unsigned char)(baudrate);
    11cc:	20 93 c4 00 	sts	0x00C4, r18

    // Double speed
	UCSRA = (USART_DOUBLESPEED << U2X);
    11d0:	82 e0       	ldi	r24, 0x02	; 2
    11d2:	80 93 c0 00 	sts	0x00C0, r24

    // Enable recieve complete interrupt
	UCSRB = (1 << RXCIE);
    11d6:	80 e8       	ldi	r24, 0x80	; 128
    11d8:	80 93 c1 00 	sts	0x00C1, r24
	 
    // Async. mode, 8N1
    UCSRC = (3 << UCSZ0);
    11dc:	86 e0       	ldi	r24, 0x06	; 6
    11de:	80 93 c2 00 	sts	0x00C2, r24
	 
	 // Initalise ringbuffer
	BUFF_InitialiseBuffer();
    11e2:	0e 94 80 0b 	call	0x1700 <BUFF_InitialiseBuffer>
    11e6:	08 95       	ret

000011e8 <USART_Tx>:
}

/*****************************************************************************
*
*   Function name : Usart_Tx
*
*   Returns :       None
*
*   Parameters :    char data: byte to send
*
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_Tx(char data)
{
    11e8:	98 2f       	mov	r25, r24
    while (!(UCSRA & (1<<UDRE)));
    11ea:	80 91 c0 00 	lds	r24, 0x00C0
    11ee:	85 ff       	sbrs	r24, 5
    11f0:	fc cf       	rjmp	.-8      	; 0x11ea <USART_Tx+0x2>
    UDR = data;
    11f2:	90 93 c6 00 	sts	0x00C6, r25
    11f6:	08 95       	ret

000011f8 <USART_TxString>:
}

/*****************************************************************************
*
*   Function name : Usart_Tx
*
*   Returns :       None
*
*   Parameters :    char data: byte to send
*
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_TxString(char *data)
{
    11f8:	cf 93       	push	r28
    11fa:	df 93       	push	r29
    11fc:	ec 01       	movw	r28, r24
	while (*data != '\0')
		USART_Tx(*data++);
    11fe:	88 81       	ld	r24, Y
    1200:	88 23       	and	r24, r24
    1202:	31 f0       	breq	.+12     	; 0x1210 <USART_TxString+0x18>
    1204:	89 91       	ld	r24, Y+
    1206:	0e 94 f4 08 	call	0x11e8 <USART_Tx>
    120a:	88 81       	ld	r24, Y
    120c:	88 23       	and	r24, r24
    120e:	d1 f7       	brne	.-12     	; 0x1204 <USART_TxString+0xc>
    1210:	df 91       	pop	r29
    1212:	cf 91       	pop	r28
    1214:	08 95       	ret

00001216 <USART_Rx>:
}

/*****************************************************************************
*
*   Function name : Usart_Rx
*
*   Returns :       char: byte received
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART
*
*****************************************************************************/
char USART_Rx(void)
{
    while (!(BuffElements) && !(TimeOut)) {};
    1216:	80 91 d2 02 	lds	r24, 0x02D2
    121a:	88 23       	and	r24, r24
    121c:	21 f4       	brne	.+8      	; 0x1226 <USART_Rx+0x10>
    121e:	80 91 28 01 	lds	r24, 0x0128
    1222:	88 23       	and	r24, r24
    1224:	c1 f3       	breq	.-16     	; 0x1216 <USART_Rx>
    return BUFF_GetBuffByte();
    1226:	0e 94 b6 0b 	call	0x176c <BUFF_GetBuffByte>
}
    122a:	99 27       	eor	r25, r25
    122c:	08 95       	ret

0000122e <__vector_13>:

/*****************************************************************************
*
*   Function name : Usart_Rx Interrupt
*
*   Returns :       N/A
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART and stores it into the buffer
*
*****************************************************************************/

ISR(USART0_RX_vect, ISR_BLOCK)
{
    122e:	1f 92       	push	r1
    1230:	0f 92       	push	r0
    1232:	0f b6       	in	r0, 0x3f	; 63
    1234:	0f 92       	push	r0
    1236:	11 24       	eor	r1, r1
    1238:	2f 93       	push	r18
    123a:	3f 93       	push	r19
    123c:	4f 93       	push	r20
    123e:	5f 93       	push	r21
    1240:	6f 93       	push	r22
    1242:	7f 93       	push	r23
    1244:	8f 93       	push	r24
    1246:	9f 93       	push	r25
    1248:	af 93       	push	r26
    124a:	bf 93       	push	r27
    124c:	ef 93       	push	r30
    124e:	ff 93       	push	r31
	BUFF_StoreBuffByte(UDR);
    1250:	80 91 c6 00 	lds	r24, 0x00C6
    1254:	0e 94 8d 0b 	call	0x171a <BUFF_StoreBuffByte>
    1258:	ff 91       	pop	r31
    125a:	ef 91       	pop	r30
    125c:	bf 91       	pop	r27
    125e:	af 91       	pop	r26
    1260:	9f 91       	pop	r25
    1262:	8f 91       	pop	r24
    1264:	7f 91       	pop	r23
    1266:	6f 91       	pop	r22
    1268:	5f 91       	pop	r21
    126a:	4f 91       	pop	r20
    126c:	3f 91       	pop	r19
    126e:	2f 91       	pop	r18
    1270:	0f 90       	pop	r0
    1272:	0f be       	out	0x3f, r0	; 63
    1274:	0f 90       	pop	r0
    1276:	1f 90       	pop	r1
    1278:	18 95       	reti

0000127a <SPI_SPIInit>:
// ======================================================================================

void SPI_SPIInit(void)
{
	PRR &= ~(1 << PRSPI);              // Enable the SPI system by clearing the power save register SPI disable bit
    127a:	80 91 64 00 	lds	r24, 0x0064
    127e:	8b 7f       	andi	r24, 0xFB	; 251
    1280:	80 93 64 00 	sts	0x0064, r24

	// Master, Sample falling edge (setup rising), Fosc/32 speed (8Mhz/32 = 125Khz)
	SPSR = (1 << SPI2X);
    1284:	81 e0       	ldi	r24, 0x01	; 1
    1286:	8d bd       	out	0x2d, r24	; 45
	SPCR = ((1 << SPE) | (1 << MSTR) | (1 << CPHA) | (1 << CPOL) | (1 << SPR1));
    1288:	8e e5       	ldi	r24, 0x5E	; 94
    128a:	8c bd       	out	0x2c, r24	; 44
    128c:	08 95       	ret

0000128e <SPI_SPITransmit>:
}

uint8_t SPI_SPITransmit(uint8_t Data)
{
	SPDR = Data;                       // Loading a byte into the register starts the transmission
    128e:	8e bd       	out	0x2e, r24	; 46
	while (!(SPSR & (1 << SPIF)));    // Wait until transmission completed
    1290:	0d b4       	in	r0, 0x2d	; 45
    1292:	07 fe       	sbrs	r0, 7
    1294:	fd cf       	rjmp	.-6      	; 0x1290 <SPI_SPITransmit+0x2>
	return SPDR;
    1296:	8e b5       	in	r24, 0x2e	; 46
}
    1298:	99 27       	eor	r25, r25
    129a:	08 95       	ret

0000129c <SPI_SPITransmitWord>:

uint8_t SPI_SPITransmitWord(uint16_t Data)
{
    129c:	0f 93       	push	r16
    129e:	1f 93       	push	r17
    12a0:	8c 01       	movw	r16, r24
	SPI_SPITransmit((uint8_t)(Data >> 8));
    12a2:	81 2f       	mov	r24, r17
    12a4:	99 27       	eor	r25, r25
    12a6:	0e 94 47 09 	call	0x128e <SPI_SPITransmit>
	return SPI_SPITransmit((uint8_t)Data);
    12aa:	80 2f       	mov	r24, r16
    12ac:	0e 94 47 09 	call	0x128e <SPI_SPITransmit>
}
    12b0:	99 27       	eor	r25, r25
    12b2:	1f 91       	pop	r17
    12b4:	0f 91       	pop	r16
    12b6:	08 95       	ret

000012b8 <__vector_17>:
 *  have to stop the timer tick.
 *  For all modes the USIDR contents are stored and flags are updated.
 */
ISR(USI_OVERFLOW_vect, ISR_BLOCK)
{
    12b8:	1f 92       	push	r1
    12ba:	0f 92       	push	r0
    12bc:	0f b6       	in	r0, 0x3f	; 63
    12be:	0f 92       	push	r0
    12c0:	11 24       	eor	r1, r1
    12c2:	8f 93       	push	r24
	// Master must now disable the compare match interrupt
	// to prevent more USI counter clocks.
	TIMSK0 &= ~(1<<OCIE0A);
    12c4:	80 91 6e 00 	lds	r24, 0x006E
    12c8:	8d 7f       	andi	r24, 0xFD	; 253
    12ca:	80 93 6e 00 	sts	0x006E, r24
	
	// Update flags and clear USI counter
	USISR = (1<<USIOIF);
    12ce:	80 e4       	ldi	r24, 0x40	; 64
    12d0:	80 93 b9 00 	sts	0x00B9, r24
	TransferComplete = 1;
    12d4:	81 e0       	ldi	r24, 0x01	; 1
    12d6:	80 93 82 02 	sts	0x0282, r24

	// Copy USIDR to buffer to prevent overwrite on next transfer.
	storedUSIDR = USIDR;
    12da:	80 91 ba 00 	lds	r24, 0x00BA
    12de:	80 93 83 02 	sts	0x0283, r24
    12e2:	8f 91       	pop	r24
    12e4:	0f 90       	pop	r0
    12e6:	0f be       	out	0x3f, r0	; 63
    12e8:	0f 90       	pop	r0
    12ea:	1f 90       	pop	r1
    12ec:	18 95       	reti

000012ee <USI_SPISetSpeed>:
}



/*! \brief  Initialize USI as SPI master.
 *
 *  This function sets up all pin directions and module configurations.
 *  Use this function initially or when changing from slave to master mode.
 *  Note that the stored USIDR value is cleared.
 *
 */
void USI_SPIInitMaster(char Freq)
{
	// Configure port directions.
 	USI_DIR_REG |= (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN);  // Outputs.
	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN);                       // Inputs.
	USI_OUT_REG |= (1<<USI_DATAIN_PIN);                        // Pull-ups.
	USI_OUT_REG &= ~(1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN); // Pull-ups.
	
	// Configure USI to 3-wire master mode with overflow interrupt.
	USICR = USI_CONTROL_REG_FLAGS;

	// Set the compare and prescaler for the requested frequency:
	USI_SPISetSpeed(Freq);
	
	// Init driver status register.
	TransferComplete = 0;
	
	storedUSIDR = 0;
}

void USI_SPIOff( void )
{
	USI_DIR_REG &= ~((1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN));                        // Inputs.
	USI_OUT_REG &= ~((1<<USI_DATAIN_PIN)  | (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN)); // Pull-ups.
	DDRF  &= ~(1 << 6);
	PORTF &= ~(1 << 6);
	
	USI_STOPUSITIMER();
}

/*! \brief  Put one byte on bus.
 *
 *  Use this function like you would write to the SPDR register in the native SPI module.
 *  Calling this function in master mode starts a transfer, while in slave mode, a
 *  byte will be prepared for the next transfer initiated by the master device.
 *  If a transfer is in progress, this function will set the write collision flag
 *  and return without altering the data registers.
 *
 *  \returns  0 if a write collision occurred, 1 otherwise.
 */
uint8_t USI_SPITransmit( unsigned char val )
{
	// Reinit flags.
	TransferComplete = 0;

	// Put data in USI data register.
	USIDR = val;
	
	TIFR0  |= (1<<OCF0A);  // Clear compare match flag.
	TIMSK0 |= (1<<OCIE0A); // Enable compare match interrupt.

	// Clear the timer 0 value
	TCNT0 = 0;

	while (!(TransferComplete));

	return storedUSIDR;
}

uint8_t USI_SPITransmitWord( unsigned int val )
{
	USI_SPITransmit((uint8_t)(val >> 8));
	return USI_SPITransmit((uint8_t)val);
}

void USI_SPIToggleClock(void)
{
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);	
}

void USI_SPISetSpeed(uint8_t Freq)
{
    12ee:	48 2f       	mov	r20, r24
	for (uint8_t MatchIndex = 0; MatchIndex < USI_PRESET_SPEEDS; MatchIndex++)
    12f0:	90 e0       	ldi	r25, 0x00	; 0
    12f2:	6c e7       	ldi	r22, 0x7C	; 124
    12f4:	73 e0       	ldi	r23, 0x03	; 3
    12f6:	9b 01       	movw	r18, r22
    12f8:	21 50       	subi	r18, 0x01	; 1
    12fa:	30 40       	sbci	r19, 0x00	; 0
	{
		if ((pgm_read_byte(&USIPSValues[MatchIndex][0]) == Freq) || (MatchIndex == (USI_PRESET_SPEEDS - 1)))
    12fc:	f9 01       	movw	r30, r18
    12fe:	84 91       	lpm	r24, Z
    1300:	84 17       	cp	r24, r20
    1302:	11 f0       	breq	.+4      	; 0x1308 <USI_SPISetSpeed+0x1a>
    1304:	93 30       	cpi	r25, 0x03	; 3
    1306:	31 f4       	brne	.+12     	; 0x1314 <USI_SPISetSpeed+0x26>
		{
			// Init Output Compare Register.
			OCR0A = pgm_read_byte(&USIPSValues[MatchIndex][1]);
    1308:	fb 01       	movw	r30, r22
    130a:	84 91       	lpm	r24, Z
    130c:	87 bd       	out	0x27, r24	; 39

			// Enable 'Clear Timer on Compare match' and set prescaler, which starts the timer
			TCCR0A = ((1<<WGM01) | TC0_PS_1);
    130e:	89 e0       	ldi	r24, 0x09	; 9
    1310:	84 bd       	out	0x24, r24	; 36
				
			return;
    1312:	08 95       	ret
    1314:	9f 5f       	subi	r25, 0xFF	; 255
    1316:	2e 5f       	subi	r18, 0xFE	; 254
    1318:	3f 4f       	sbci	r19, 0xFF	; 255
    131a:	6e 5f       	subi	r22, 0xFE	; 254
    131c:	7f 4f       	sbci	r23, 0xFF	; 255
    131e:	94 30       	cpi	r25, 0x04	; 4
    1320:	68 f3       	brcs	.-38     	; 0x12fc <USI_SPISetSpeed+0xe>
    1322:	08 95       	ret

00001324 <USI_SPIInitMaster>:
    1324:	9d b1       	in	r25, 0x0d	; 13
    1326:	90 65       	ori	r25, 0x50	; 80
    1328:	9d b9       	out	0x0d, r25	; 13
    132a:	6d 98       	cbi	0x0d, 5	; 13
    132c:	75 9a       	sbi	0x0e, 5	; 14
    132e:	76 98       	cbi	0x0e, 6	; 14
    1330:	9a e5       	ldi	r25, 0x5A	; 90
    1332:	90 93 b8 00 	sts	0x00B8, r25
    1336:	0e 94 77 09 	call	0x12ee <USI_SPISetSpeed>
    133a:	10 92 82 02 	sts	0x0282, r1
    133e:	10 92 83 02 	sts	0x0283, r1
    1342:	08 95       	ret

00001344 <USI_SPIOff>:
    1344:	8d b1       	in	r24, 0x0d	; 13
    1346:	8f 7a       	andi	r24, 0xAF	; 175
    1348:	8d b9       	out	0x0d, r24	; 13
    134a:	8e b1       	in	r24, 0x0e	; 14
    134c:	8f 78       	andi	r24, 0x8F	; 143
    134e:	8e b9       	out	0x0e, r24	; 14
    1350:	86 98       	cbi	0x10, 6	; 16
    1352:	8e 98       	cbi	0x11, 6	; 17
    1354:	14 bc       	out	0x24, r1	; 36
    1356:	08 95       	ret

00001358 <USI_SPITransmit>:
    1358:	10 92 82 02 	sts	0x0282, r1
    135c:	80 93 ba 00 	sts	0x00BA, r24
    1360:	a9 9a       	sbi	0x15, 1	; 21
    1362:	80 91 6e 00 	lds	r24, 0x006E
    1366:	82 60       	ori	r24, 0x02	; 2
    1368:	80 93 6e 00 	sts	0x006E, r24
    136c:	16 bc       	out	0x26, r1	; 38
    136e:	80 91 82 02 	lds	r24, 0x0282
    1372:	88 23       	and	r24, r24
    1374:	e1 f3       	breq	.-8      	; 0x136e <USI_SPITransmit+0x16>
    1376:	80 91 83 02 	lds	r24, 0x0283
    137a:	99 27       	eor	r25, r25
    137c:	08 95       	ret

0000137e <USI_SPITransmitWord>:
    137e:	0f 93       	push	r16
    1380:	1f 93       	push	r17
    1382:	8c 01       	movw	r16, r24
    1384:	81 2f       	mov	r24, r17
    1386:	99 27       	eor	r25, r25
    1388:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    138c:	80 2f       	mov	r24, r16
    138e:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    1392:	99 27       	eor	r25, r25
    1394:	1f 91       	pop	r17
    1396:	0f 91       	pop	r16
    1398:	08 95       	ret

0000139a <USI_SPIToggleClock>:
    139a:	81 e0       	ldi	r24, 0x01	; 1
    139c:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    13a0:	80 91 b8 00 	lds	r24, 0x00B8
    13a4:	81 60       	ori	r24, 0x01	; 1
    13a6:	80 93 b8 00 	sts	0x00B8, r24
    13aa:	81 e0       	ldi	r24, 0x01	; 1
    13ac:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    13b0:	80 91 b8 00 	lds	r24, 0x00B8
    13b4:	81 60       	ori	r24, 0x01	; 1
    13b6:	80 93 b8 00 	sts	0x00B8, r24
    13ba:	81 e0       	ldi	r24, 0x01	; 1
    13bc:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    13c0:	08 95       	ret

000013c2 <DF_EnableDataflash>:
	while (DF_BUSY());
}

void DF_EnableDataflash(uint8_t Enabled)
{
    13c2:	90 91 84 02 	lds	r25, 0x0284
	if (Enabled == TRUE)
    13c6:	81 30       	cpi	r24, 0x01	; 1
    13c8:	31 f4       	brne	.+12     	; 0x13d6 <DF_EnableDataflash+0x14>
	{
		if (UseExernalDF == TRUE)
    13ca:	91 30       	cpi	r25, 0x01	; 1
    13cc:	11 f4       	brne	.+4      	; 0x13d2 <DF_EnableDataflash+0x10>
		  MAIN_ResetCSLine(MAIN_RESETCS_EXTDFACTIVE);
    13ce:	82 e0       	ldi	r24, 0x02	; 2
    13d0:	05 c0       	rjmp	.+10     	; 0x13dc <DF_EnableDataflash+0x1a>
		else
		  PORTB &= ~(1 << 0);
    13d2:	28 98       	cbi	0x05, 0	; 5
    13d4:	08 95       	ret
	}
	else
	{
		if (UseExernalDF == TRUE)
    13d6:	91 30       	cpi	r25, 0x01	; 1
    13d8:	21 f4       	brne	.+8      	; 0x13e2 <DF_EnableDataflash+0x20>
		  MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);
    13da:	89 2f       	mov	r24, r25
    13dc:	0e 94 1b 03 	call	0x636 <MAIN_ResetCSLine>
    13e0:	08 95       	ret
		else
		  PORTB |= (1 << 0);
    13e2:	28 9a       	sbi	0x05, 0	; 5
    13e4:	08 95       	ret

000013e6 <DF_ReadBufferByte>:
    13e6:	0f 93       	push	r16
    13e8:	1f 93       	push	r17
    13ea:	8c 01       	movw	r16, r24
    13ec:	80 e0       	ldi	r24, 0x00	; 0
    13ee:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    13f2:	00 00       	nop
    13f4:	81 e0       	ldi	r24, 0x01	; 1
    13f6:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    13fa:	e0 91 00 01 	lds	r30, 0x0100
    13fe:	f0 91 01 01 	lds	r31, 0x0101
    1402:	84 e5       	ldi	r24, 0x54	; 84
    1404:	09 95       	icall
    1406:	81 2f       	mov	r24, r17
    1408:	99 27       	eor	r25, r25
    140a:	e0 91 00 01 	lds	r30, 0x0100
    140e:	f0 91 01 01 	lds	r31, 0x0101
    1412:	09 95       	icall
    1414:	e0 91 00 01 	lds	r30, 0x0100
    1418:	f0 91 01 01 	lds	r31, 0x0101
    141c:	80 2f       	mov	r24, r16
    141e:	09 95       	icall
    1420:	e0 91 00 01 	lds	r30, 0x0100
    1424:	f0 91 01 01 	lds	r31, 0x0101
    1428:	80 e0       	ldi	r24, 0x00	; 0
    142a:	09 95       	icall
    142c:	e0 91 00 01 	lds	r30, 0x0100
    1430:	f0 91 01 01 	lds	r31, 0x0101
    1434:	80 e0       	ldi	r24, 0x00	; 0
    1436:	09 95       	icall
    1438:	99 27       	eor	r25, r25
    143a:	1f 91       	pop	r17
    143c:	0f 91       	pop	r16
    143e:	08 95       	ret

00001440 <DF_ContinuousReadEnable>:
    1440:	ef 92       	push	r14
    1442:	ff 92       	push	r15
    1444:	0f 93       	push	r16
    1446:	1f 93       	push	r17
    1448:	8c 01       	movw	r16, r24
    144a:	7b 01       	movw	r14, r22
    144c:	80 e0       	ldi	r24, 0x00	; 0
    144e:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    1452:	00 00       	nop
    1454:	81 e0       	ldi	r24, 0x01	; 1
    1456:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    145a:	e0 91 00 01 	lds	r30, 0x0100
    145e:	f0 91 01 01 	lds	r31, 0x0101
    1462:	88 e6       	ldi	r24, 0x68	; 104
    1464:	09 95       	icall
    1466:	8a b5       	in	r24, 0x2a	; 42
    1468:	98 01       	movw	r18, r16
    146a:	02 c0       	rjmp	.+4      	; 0x1470 <DF_ContinuousReadEnable+0x30>
    146c:	36 95       	lsr	r19
    146e:	27 95       	ror	r18
    1470:	8a 95       	dec	r24
    1472:	e2 f7       	brpl	.-8      	; 0x146c <DF_ContinuousReadEnable+0x2c>
    1474:	c9 01       	movw	r24, r18
    1476:	e0 91 00 01 	lds	r30, 0x0100
    147a:	f0 91 01 01 	lds	r31, 0x0101
    147e:	09 95       	icall
    1480:	8b b5       	in	r24, 0x2b	; 43
    1482:	02 c0       	rjmp	.+4      	; 0x1488 <DF_ContinuousReadEnable+0x48>
    1484:	00 0f       	add	r16, r16
    1486:	11 1f       	adc	r17, r17
    1488:	8a 95       	dec	r24
    148a:	e2 f7       	brpl	.-8      	; 0x1484 <DF_ContinuousReadEnable+0x44>
    148c:	8f 2d       	mov	r24, r15
    148e:	99 27       	eor	r25, r25
    1490:	e0 91 00 01 	lds	r30, 0x0100
    1494:	f0 91 01 01 	lds	r31, 0x0101
    1498:	80 0f       	add	r24, r16
    149a:	09 95       	icall
    149c:	e0 91 00 01 	lds	r30, 0x0100
    14a0:	f0 91 01 01 	lds	r31, 0x0101
    14a4:	8e 2d       	mov	r24, r14
    14a6:	09 95       	icall
    14a8:	03 e0       	ldi	r16, 0x03	; 3
    14aa:	e0 91 00 01 	lds	r30, 0x0100
    14ae:	f0 91 01 01 	lds	r31, 0x0101
    14b2:	80 e0       	ldi	r24, 0x00	; 0
    14b4:	09 95       	icall
    14b6:	01 50       	subi	r16, 0x01	; 1
    14b8:	07 ff       	sbrs	r16, 7
    14ba:	f7 cf       	rjmp	.-18     	; 0x14aa <DF_ContinuousReadEnable+0x6a>
    14bc:	1f 91       	pop	r17
    14be:	0f 91       	pop	r16
    14c0:	ff 90       	pop	r15
    14c2:	ef 90       	pop	r14
    14c4:	08 95       	ret

000014c6 <DF_BufferWriteEnable>:
    14c6:	0f 93       	push	r16
    14c8:	1f 93       	push	r17
    14ca:	8c 01       	movw	r16, r24
    14cc:	80 e0       	ldi	r24, 0x00	; 0
    14ce:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    14d2:	00 00       	nop
    14d4:	81 e0       	ldi	r24, 0x01	; 1
    14d6:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    14da:	e0 91 00 01 	lds	r30, 0x0100
    14de:	f0 91 01 01 	lds	r31, 0x0101
    14e2:	84 e8       	ldi	r24, 0x84	; 132
    14e4:	09 95       	icall
    14e6:	e0 91 00 01 	lds	r30, 0x0100
    14ea:	f0 91 01 01 	lds	r31, 0x0101
    14ee:	80 e0       	ldi	r24, 0x00	; 0
    14f0:	09 95       	icall
    14f2:	81 2f       	mov	r24, r17
    14f4:	99 27       	eor	r25, r25
    14f6:	e0 91 00 01 	lds	r30, 0x0100
    14fa:	f0 91 01 01 	lds	r31, 0x0101
    14fe:	09 95       	icall
    1500:	e0 91 00 01 	lds	r30, 0x0100
    1504:	f0 91 01 01 	lds	r31, 0x0101
    1508:	80 2f       	mov	r24, r16
    150a:	09 95       	icall
    150c:	1f 91       	pop	r17
    150e:	0f 91       	pop	r16
    1510:	08 95       	ret

00001512 <DF_GetChipCharacteristics>:
    1512:	80 e0       	ldi	r24, 0x00	; 0
    1514:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    1518:	00 00       	nop
    151a:	81 e0       	ldi	r24, 0x01	; 1
    151c:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    1520:	e0 91 00 01 	lds	r30, 0x0100
    1524:	f0 91 01 01 	lds	r31, 0x0101
    1528:	87 e5       	ldi	r24, 0x57	; 87
    152a:	09 95       	icall
    152c:	e0 91 00 01 	lds	r30, 0x0100
    1530:	f0 91 01 01 	lds	r31, 0x0101
    1534:	80 e0       	ldi	r24, 0x00	; 0
    1536:	09 95       	icall
    1538:	68 2f       	mov	r22, r24
    153a:	77 27       	eor	r23, r23
    153c:	cb 01       	movw	r24, r22
    153e:	88 73       	andi	r24, 0x38	; 56
    1540:	90 70       	andi	r25, 0x00	; 0
    1542:	33 e0       	ldi	r19, 0x03	; 3
    1544:	95 95       	asr	r25
    1546:	87 95       	ror	r24
    1548:	3a 95       	dec	r19
    154a:	e1 f7       	brne	.-8      	; 0x1544 <DF_GetChipCharacteristics+0x32>
    154c:	99 27       	eor	r25, r25
    154e:	fc 01       	movw	r30, r24
    1550:	ed 54       	subi	r30, 0x4D	; 77
    1552:	fc 4f       	sbci	r31, 0xFC	; 252
    1554:	44 91       	lpm	r20, Z
    1556:	40 93 87 02 	sts	0x0287, r20
    155a:	9c 01       	movw	r18, r24
    155c:	28 0f       	add	r18, r24
    155e:	39 1f       	adc	r19, r25
    1560:	f9 01       	movw	r30, r18
    1562:	ed 55       	subi	r30, 0x5D	; 93
    1564:	fc 4f       	sbci	r31, 0xFC	; 252
    1566:	85 91       	lpm	r24, Z+
    1568:	94 91       	lpm	r25, Z
    156a:	90 93 89 02 	sts	0x0289, r25
    156e:	80 93 88 02 	sts	0x0288, r24
    1572:	f9 01       	movw	r30, r18
    1574:	ed 56       	subi	r30, 0x6D	; 109
    1576:	fc 4f       	sbci	r31, 0xFC	; 252
    1578:	85 91       	lpm	r24, Z+
    157a:	94 91       	lpm	r25, Z
    157c:	90 93 8b 02 	sts	0x028B, r25
    1580:	80 93 8a 02 	sts	0x028A, r24
    1584:	80 e1       	ldi	r24, 0x10	; 16
    1586:	84 1b       	sub	r24, r20
    1588:	8a bd       	out	0x2a, r24	; 42
    158a:	48 50       	subi	r20, 0x08	; 8
    158c:	4b bd       	out	0x2b, r20	; 43
    158e:	cb 01       	movw	r24, r22
    1590:	08 95       	ret

00001592 <DF_ErasePage>:
    1592:	0f 93       	push	r16
    1594:	1f 93       	push	r17
    1596:	8c 01       	movw	r16, r24
    1598:	80 e0       	ldi	r24, 0x00	; 0
    159a:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    159e:	00 00       	nop
    15a0:	81 e0       	ldi	r24, 0x01	; 1
    15a2:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    15a6:	e0 91 00 01 	lds	r30, 0x0100
    15aa:	f0 91 01 01 	lds	r31, 0x0101
    15ae:	81 e8       	ldi	r24, 0x81	; 129
    15b0:	09 95       	icall
    15b2:	8a b5       	in	r24, 0x2a	; 42
    15b4:	98 01       	movw	r18, r16
    15b6:	02 c0       	rjmp	.+4      	; 0x15bc <DF_ErasePage+0x2a>
    15b8:	36 95       	lsr	r19
    15ba:	27 95       	ror	r18
    15bc:	8a 95       	dec	r24
    15be:	e2 f7       	brpl	.-8      	; 0x15b8 <DF_ErasePage+0x26>
    15c0:	c9 01       	movw	r24, r18
    15c2:	e0 91 00 01 	lds	r30, 0x0100
    15c6:	f0 91 01 01 	lds	r31, 0x0101
    15ca:	09 95       	icall
    15cc:	8b b5       	in	r24, 0x2b	; 43
    15ce:	02 c0       	rjmp	.+4      	; 0x15d4 <DF_ErasePage+0x42>
    15d0:	00 0f       	add	r16, r16
    15d2:	11 1f       	adc	r17, r17
    15d4:	8a 95       	dec	r24
    15d6:	e2 f7       	brpl	.-8      	; 0x15d0 <DF_ErasePage+0x3e>
    15d8:	e0 91 00 01 	lds	r30, 0x0100
    15dc:	f0 91 01 01 	lds	r31, 0x0101
    15e0:	80 2f       	mov	r24, r16
    15e2:	09 95       	icall
    15e4:	e0 91 00 01 	lds	r30, 0x0100
    15e8:	f0 91 01 01 	lds	r31, 0x0101
    15ec:	80 e0       	ldi	r24, 0x00	; 0
    15ee:	09 95       	icall
    15f0:	0e 94 89 0a 	call	0x1512 <DF_GetChipCharacteristics>
    15f4:	88 23       	and	r24, r24
    15f6:	e4 f7       	brge	.-8      	; 0x15f0 <DF_ErasePage+0x5e>
    15f8:	1f 91       	pop	r17
    15fa:	0f 91       	pop	r16
    15fc:	08 95       	ret

000015fe <DF_CopyFlashPageToBuffer>:
    15fe:	0f 93       	push	r16
    1600:	1f 93       	push	r17
    1602:	8c 01       	movw	r16, r24
    1604:	80 e0       	ldi	r24, 0x00	; 0
    1606:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    160a:	00 00       	nop
    160c:	81 e0       	ldi	r24, 0x01	; 1
    160e:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    1612:	e0 91 00 01 	lds	r30, 0x0100
    1616:	f0 91 01 01 	lds	r31, 0x0101
    161a:	83 e5       	ldi	r24, 0x53	; 83
    161c:	09 95       	icall
    161e:	8a b5       	in	r24, 0x2a	; 42
    1620:	98 01       	movw	r18, r16
    1622:	02 c0       	rjmp	.+4      	; 0x1628 <DF_CopyFlashPageToBuffer+0x2a>
    1624:	36 95       	lsr	r19
    1626:	27 95       	ror	r18
    1628:	8a 95       	dec	r24
    162a:	e2 f7       	brpl	.-8      	; 0x1624 <DF_CopyFlashPageToBuffer+0x26>
    162c:	c9 01       	movw	r24, r18
    162e:	e0 91 00 01 	lds	r30, 0x0100
    1632:	f0 91 01 01 	lds	r31, 0x0101
    1636:	09 95       	icall
    1638:	8b b5       	in	r24, 0x2b	; 43
    163a:	02 c0       	rjmp	.+4      	; 0x1640 <DF_CopyFlashPageToBuffer+0x42>
    163c:	00 0f       	add	r16, r16
    163e:	11 1f       	adc	r17, r17
    1640:	8a 95       	dec	r24
    1642:	e2 f7       	brpl	.-8      	; 0x163c <DF_CopyFlashPageToBuffer+0x3e>
    1644:	e0 91 00 01 	lds	r30, 0x0100
    1648:	f0 91 01 01 	lds	r31, 0x0101
    164c:	80 2f       	mov	r24, r16
    164e:	09 95       	icall
    1650:	e0 91 00 01 	lds	r30, 0x0100
    1654:	f0 91 01 01 	lds	r31, 0x0101
    1658:	80 e0       	ldi	r24, 0x00	; 0
    165a:	09 95       	icall
    165c:	0e 94 89 0a 	call	0x1512 <DF_GetChipCharacteristics>
    1660:	88 23       	and	r24, r24
    1662:	e4 f7       	brge	.-8      	; 0x165c <DF_CopyFlashPageToBuffer+0x5e>
    1664:	1f 91       	pop	r17
    1666:	0f 91       	pop	r16
    1668:	08 95       	ret

0000166a <DF_CopyBufferToFlashPage>:
    166a:	0f 93       	push	r16
    166c:	1f 93       	push	r17
    166e:	8c 01       	movw	r16, r24
    1670:	80 e0       	ldi	r24, 0x00	; 0
    1672:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    1676:	00 00       	nop
    1678:	81 e0       	ldi	r24, 0x01	; 1
    167a:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    167e:	e0 91 00 01 	lds	r30, 0x0100
    1682:	f0 91 01 01 	lds	r31, 0x0101
    1686:	83 e8       	ldi	r24, 0x83	; 131
    1688:	09 95       	icall
    168a:	8a b5       	in	r24, 0x2a	; 42
    168c:	98 01       	movw	r18, r16
    168e:	02 c0       	rjmp	.+4      	; 0x1694 <DF_CopyBufferToFlashPage+0x2a>
    1690:	36 95       	lsr	r19
    1692:	27 95       	ror	r18
    1694:	8a 95       	dec	r24
    1696:	e2 f7       	brpl	.-8      	; 0x1690 <DF_CopyBufferToFlashPage+0x26>
    1698:	c9 01       	movw	r24, r18
    169a:	e0 91 00 01 	lds	r30, 0x0100
    169e:	f0 91 01 01 	lds	r31, 0x0101
    16a2:	09 95       	icall
    16a4:	8b b5       	in	r24, 0x2b	; 43
    16a6:	02 c0       	rjmp	.+4      	; 0x16ac <DF_CopyBufferToFlashPage+0x42>
    16a8:	00 0f       	add	r16, r16
    16aa:	11 1f       	adc	r17, r17
    16ac:	8a 95       	dec	r24
    16ae:	e2 f7       	brpl	.-8      	; 0x16a8 <DF_CopyBufferToFlashPage+0x3e>
    16b0:	e0 91 00 01 	lds	r30, 0x0100
    16b4:	f0 91 01 01 	lds	r31, 0x0101
    16b8:	80 2f       	mov	r24, r16
    16ba:	09 95       	icall
    16bc:	e0 91 00 01 	lds	r30, 0x0100
    16c0:	f0 91 01 01 	lds	r31, 0x0101
    16c4:	80 e0       	ldi	r24, 0x00	; 0
    16c6:	09 95       	icall
    16c8:	0e 94 89 0a 	call	0x1512 <DF_GetChipCharacteristics>
    16cc:	88 23       	and	r24, r24
    16ce:	e4 f7       	brge	.-8      	; 0x16c8 <DF_CopyBufferToFlashPage+0x5e>
    16d0:	1f 91       	pop	r17
    16d2:	0f 91       	pop	r16
    16d4:	08 95       	ret

000016d6 <DF_CheckCorrectOnboardChip>:
    16d6:	0e 94 89 0a 	call	0x1512 <DF_GetChipCharacteristics>
    16da:	80 91 87 02 	lds	r24, 0x0287
    16de:	89 30       	cpi	r24, 0x09	; 9
    16e0:	61 f0       	breq	.+24     	; 0x16fa <DF_CheckCorrectOnboardChip+0x24>
    16e2:	80 91 64 00 	lds	r24, 0x0064
    16e6:	84 60       	ori	r24, 0x04	; 4
    16e8:	80 93 64 00 	sts	0x0064, r24
    16ec:	83 e8       	ldi	r24, 0x83	; 131
    16ee:	93 e0       	ldi	r25, 0x03	; 3
    16f0:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
    16f4:	80 e0       	ldi	r24, 0x00	; 0
    16f6:	90 e0       	ldi	r25, 0x00	; 0
    16f8:	08 95       	ret
    16fa:	81 e0       	ldi	r24, 0x01	; 1
    16fc:	90 e0       	ldi	r25, 0x00	; 0
    16fe:	08 95       	ret

00001700 <BUFF_InitialiseBuffer>:

// Routines:
void BUFF_InitialiseBuffer(void)
{
	StoreLoc    = (BuffType*)&RingBuffer[0]; // Set up the IN pointer to the start of the buffer
    1700:	8e e8       	ldi	r24, 0x8E	; 142
    1702:	92 e0       	ldi	r25, 0x02	; 2
    1704:	90 93 cf 02 	sts	0x02CF, r25
    1708:	80 93 ce 02 	sts	0x02CE, r24
	RetrieveLoc = (BuffType*)&RingBuffer[0]; // Set up the OUT pointer to the start of the buffer
    170c:	90 93 d1 02 	sts	0x02D1, r25
    1710:	80 93 d0 02 	sts	0x02D0, r24

	BuffElements = 0;                     // Reset the buffer elements counter
    1714:	10 92 d2 02 	sts	0x02D2, r1
    1718:	08 95       	ret

0000171a <BUFF_StoreBuffByte>:
}

void BUFF_StoreBuffByte(BuffType DataToStore)
{
    171a:	98 2f       	mov	r25, r24
	if (BuffElements == BuffLen)          // Buffer full
    171c:	80 91 d2 02 	lds	r24, 0x02D2
    1720:	80 34       	cpi	r24, 0x40	; 64
    1722:	29 f4       	brne	.+10     	; 0x172e <BUFF_StoreBuffByte+0x14>
	{
		MAIN_ShowError(PSTR("BUFF OVERFLOW"));
    1724:	8b eb       	ldi	r24, 0xBB	; 187
    1726:	93 e0       	ldi	r25, 0x03	; 3
    1728:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
		return;
    172c:	08 95       	ret
	}
		
	*StoreLoc = DataToStore;              // Store the data
    172e:	e0 91 ce 02 	lds	r30, 0x02CE
    1732:	f0 91 cf 02 	lds	r31, 0x02CF
    1736:	90 83       	st	Z, r25

	StoreLoc++;                           // Increment the IN pointer to the next element
    1738:	40 91 ce 02 	lds	r20, 0x02CE
    173c:	50 91 cf 02 	lds	r21, 0x02CF
    1740:	9a 01       	movw	r18, r20
    1742:	2f 5f       	subi	r18, 0xFF	; 255
    1744:	3f 4f       	sbci	r19, 0xFF	; 255
    1746:	30 93 cf 02 	sts	0x02CF, r19
    174a:	20 93 ce 02 	sts	0x02CE, r18
	BuffElements++;                       // Increment the total elements variable
    174e:	80 91 d2 02 	lds	r24, 0x02D2
    1752:	8f 5f       	subi	r24, 0xFF	; 255
    1754:	80 93 d2 02 	sts	0x02D2, r24

	if (StoreLoc == (BuffType*)&RingBuffer[BuffLen])
    1758:	2e 5c       	subi	r18, 0xCE	; 206
    175a:	32 40       	sbci	r19, 0x02	; 2
    175c:	31 f4       	brne	.+12     	; 0x176a <BUFF_StoreBuffByte+0x50>
		StoreLoc = (BuffType*)&RingBuffer[0]; // Wrap pointer if end of array reached
    175e:	4f 53       	subi	r20, 0x3F	; 63
    1760:	50 40       	sbci	r21, 0x00	; 0
    1762:	50 93 cf 02 	sts	0x02CF, r21
    1766:	40 93 ce 02 	sts	0x02CE, r20
    176a:	08 95       	ret

0000176c <BUFF_GetBuffByte>:
}	

BuffType BUFF_GetBuffByte(void)
{
	if (!(BuffElements))                  // No elements in the buffer
    176c:	80 91 d2 02 	lds	r24, 0x02D2
    1770:	88 23       	and	r24, r24
    1772:	19 f4       	brne	.+6      	; 0x177a <BUFF_GetBuffByte+0xe>
		return 0;
    1774:	80 e0       	ldi	r24, 0x00	; 0
    1776:	90 e0       	ldi	r25, 0x00	; 0
    1778:	08 95       	ret

	BuffType RetrievedData = *RetrieveLoc; // Grab the stored byte into a temp variable
    177a:	20 91 d0 02 	lds	r18, 0x02D0
    177e:	30 91 d1 02 	lds	r19, 0x02D1
    1782:	f9 01       	movw	r30, r18
    1784:	91 91       	ld	r25, Z+

	RetrieveLoc++;                         // Increment the OUT pointer to the next element if flag set
    1786:	f0 93 d1 02 	sts	0x02D1, r31
    178a:	e0 93 d0 02 	sts	0x02D0, r30
	BuffElements--;                        // Decrement the total elements variable
    178e:	80 91 d2 02 	lds	r24, 0x02D2
    1792:	81 50       	subi	r24, 0x01	; 1
    1794:	80 93 d2 02 	sts	0x02D2, r24
	
	if (RetrieveLoc == (BuffType*)&RingBuffer[BuffLen])
    1798:	ee 5c       	subi	r30, 0xCE	; 206
    179a:	f2 40       	sbci	r31, 0x02	; 2
    179c:	31 f4       	brne	.+12     	; 0x17aa <BUFF_GetBuffByte+0x3e>
		RetrieveLoc = (BuffType*)&RingBuffer[0]; // Wrap pointer if end of array reached
    179e:	2f 53       	subi	r18, 0x3F	; 63
    17a0:	30 40       	sbci	r19, 0x00	; 0
    17a2:	30 93 d1 02 	sts	0x02D1, r19
    17a6:	20 93 d0 02 	sts	0x02D0, r18
		
	return RetrievedData;                 // Return the retrieved data
    17aa:	89 2f       	mov	r24, r25
    17ac:	99 27       	eor	r25, r25
}
    17ae:	08 95       	ret

000017b0 <__vector_9>:
// ======================================================================================

// Timeout = ((F_CPU / 64) / (65535 * TIMEOUT_TICKSBEFORETIMEOUT)) per second
ISR(TIMER1_OVF_vect, ISR_NOBLOCK)
{
    17b0:	78 94       	sei
    17b2:	1f 92       	push	r1
    17b4:	0f 92       	push	r0
    17b6:	0f b6       	in	r0, 0x3f	; 63
    17b8:	0f 92       	push	r0
    17ba:	11 24       	eor	r1, r1
    17bc:	8f 93       	push	r24
	if (Ticks++ == TIMEOUT_TICKSBEFORETIMEOUT)
    17be:	80 91 29 01 	lds	r24, 0x0129
    17c2:	8f 5f       	subi	r24, 0xFF	; 255
    17c4:	80 93 29 01 	sts	0x0129, r24
    17c8:	80 91 29 01 	lds	r24, 0x0129
    17cc:	87 30       	cpi	r24, 0x07	; 7
    17ce:	29 f4       	brne	.+10     	; 0x17da <__vector_9+0x2a>
	{
	   Ticks   = 0;
    17d0:	10 92 29 01 	sts	0x0129, r1
	   TimeOut = TRUE;
    17d4:	81 e0       	ldi	r24, 0x01	; 1
    17d6:	80 93 28 01 	sts	0x0128, r24
    17da:	8f 91       	pop	r24
    17dc:	0f 90       	pop	r0
    17de:	0f be       	out	0x3f, r0	; 63
    17e0:	0f 90       	pop	r0
    17e2:	1f 90       	pop	r1
    17e4:	18 95       	reti

000017e6 <TIMEOUT_SetupTimeoutTimer>:
	}
}

// ======================================================================================

void TIMEOUT_SetupTimeoutTimer(void)
{
	TCCR1A = 0;
    17e6:	10 92 80 00 	sts	0x0080, r1
	TIMEOUT_TIMER_OFF();
    17ea:	10 92 81 00 	sts	0x0081, r1
    17ee:	10 92 29 01 	sts	0x0129, r1
    17f2:	10 92 85 00 	sts	0x0085, r1
    17f6:	10 92 84 00 	sts	0x0084, r1
	TCCR1C = 0;
    17fa:	10 92 82 00 	sts	0x0082, r1
	
	TIMSK1 = (1 << TOIE1); // Turn timer 1 overflow interrupt on
    17fe:	81 e0       	ldi	r24, 0x01	; 1
    1800:	80 93 6f 00 	sts	0x006F, r24
    1804:	08 95       	ret

00001806 <PD_SetupDFAddressCounters>:
}

void PD_SetupDFAddressCounters(void)
{
	uint32_t StartAddress = CurrAddress;
    1806:	20 91 2b 01 	lds	r18, 0x012B
    180a:	30 91 2c 01 	lds	r19, 0x012C
    180e:	40 91 2d 01 	lds	r20, 0x012D
    1812:	50 91 2e 01 	lds	r21, 0x012E

	CurrPageAddress = 0;
    1816:	10 92 8d 02 	sts	0x028D, r1
    181a:	10 92 8c 02 	sts	0x028C, r1

	while (StartAddress > DataflashInfo.PageSize)      // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DataflashInfo.PageSize;         // Subtract one page's worth of bytes from the desired address
		CurrPageAddress++;
    181e:	80 91 88 02 	lds	r24, 0x0288
    1822:	90 91 89 02 	lds	r25, 0x0289
    1826:	aa 27       	eor	r26, r26
    1828:	bb 27       	eor	r27, r27
    182a:	82 17       	cp	r24, r18
    182c:	93 07       	cpc	r25, r19
    182e:	a4 07       	cpc	r26, r20
    1830:	b5 07       	cpc	r27, r21
    1832:	88 f4       	brcc	.+34     	; 0x1856 <PD_SetupDFAddressCounters+0x50>
    1834:	60 e0       	ldi	r22, 0x00	; 0
    1836:	70 e0       	ldi	r23, 0x00	; 0
    1838:	28 1b       	sub	r18, r24
    183a:	39 0b       	sbc	r19, r25
    183c:	4a 0b       	sbc	r20, r26
    183e:	5b 0b       	sbc	r21, r27
    1840:	6f 5f       	subi	r22, 0xFF	; 255
    1842:	7f 4f       	sbci	r23, 0xFF	; 255
    1844:	82 17       	cp	r24, r18
    1846:	93 07       	cpc	r25, r19
    1848:	a4 07       	cpc	r26, r20
    184a:	b5 07       	cpc	r27, r21
    184c:	a8 f3       	brcs	.-22     	; 0x1838 <PD_SetupDFAddressCounters+0x32>
    184e:	70 93 8d 02 	sts	0x028D, r23
    1852:	60 93 8c 02 	sts	0x028C, r22
	}
	
	CurrBuffByte = (uint16_t)StartAddress;              // The buffer byte is the remainder
    1856:	30 93 86 02 	sts	0x0286, r19
    185a:	20 93 85 02 	sts	0x0285, r18
    185e:	08 95       	ret

00001860 <DF_StoreDataflashByte>:
}

void DF_StoreDataflashByte(uint8_t Data)
{
    1860:	cf 93       	push	r28
    1862:	c8 2f       	mov	r28, r24
	if (CurrBuffByte == DataflashInfo.PageSize)
    1864:	20 91 85 02 	lds	r18, 0x0285
    1868:	30 91 86 02 	lds	r19, 0x0286
    186c:	80 91 88 02 	lds	r24, 0x0288
    1870:	90 91 89 02 	lds	r25, 0x0289
    1874:	28 17       	cp	r18, r24
    1876:	39 07       	cpc	r19, r25
    1878:	a9 f4       	brne	.+42     	; 0x18a4 <DF_StoreDataflashByte+0x44>
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
    187a:	80 91 8c 02 	lds	r24, 0x028C
    187e:	90 91 8d 02 	lds	r25, 0x028D
    1882:	9c 01       	movw	r18, r24
    1884:	01 96       	adiw	r24, 0x01	; 1
    1886:	90 93 8d 02 	sts	0x028D, r25
    188a:	80 93 8c 02 	sts	0x028C, r24
    188e:	c9 01       	movw	r24, r18
    1890:	0e 94 35 0b 	call	0x166a <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    1894:	80 e0       	ldi	r24, 0x00	; 0
    1896:	90 e0       	ldi	r25, 0x00	; 0
    1898:	0e 94 63 0a 	call	0x14c6 <DF_BufferWriteEnable>
		CurrBuffByte = 0;
    189c:	10 92 86 02 	sts	0x0286, r1
    18a0:	10 92 85 02 	sts	0x0285, r1
	}
	
	USI_SPITransmit(Data);                                 // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    18a4:	8c 2f       	mov	r24, r28
    18a6:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
	CurrBuffByte++;
    18aa:	80 91 85 02 	lds	r24, 0x0285
    18ae:	90 91 86 02 	lds	r25, 0x0286
    18b2:	01 96       	adiw	r24, 0x01	; 1
    18b4:	90 93 86 02 	sts	0x0286, r25
    18b8:	80 93 85 02 	sts	0x0285, r24
    18bc:	cf 91       	pop	r28
    18be:	08 95       	ret

000018c0 <PD_InterpretAVRISPPacket>:
    18c0:	ef 92       	push	r14
    18c2:	ff 92       	push	r15
    18c4:	0f 93       	push	r16
    18c6:	1f 93       	push	r17
    18c8:	cf 93       	push	r28
    18ca:	df 93       	push	r29
    18cc:	80 91 34 01 	lds	r24, 0x0134
    18d0:	99 27       	eor	r25, r25
    18d2:	86 31       	cpi	r24, 0x16	; 22
    18d4:	91 05       	cpc	r25, r1
    18d6:	09 f4       	brne	.+2      	; 0x18da <PD_InterpretAVRISPPacket+0x1a>
    18d8:	04 c1       	rjmp	.+520    	; 0x1ae2 <PD_InterpretAVRISPPacket+0x222>
    18da:	87 31       	cpi	r24, 0x17	; 23
    18dc:	91 05       	cpc	r25, r1
    18de:	b4 f4       	brge	.+44     	; 0x190c <PD_InterpretAVRISPPacket+0x4c>
    18e0:	82 31       	cpi	r24, 0x12	; 18
    18e2:	91 05       	cpc	r25, r1
    18e4:	09 f4       	brne	.+2      	; 0x18e8 <PD_InterpretAVRISPPacket+0x28>
    18e6:	69 c0       	rjmp	.+210    	; 0x19ba <PD_InterpretAVRISPPacket+0xfa>
    18e8:	83 31       	cpi	r24, 0x13	; 19
    18ea:	91 05       	cpc	r25, r1
    18ec:	3c f4       	brge	.+14     	; 0x18fc <PD_InterpretAVRISPPacket+0x3c>
    18ee:	80 31       	cpi	r24, 0x10	; 16
    18f0:	91 05       	cpc	r25, r1
    18f2:	31 f1       	breq	.+76     	; 0x1940 <PD_InterpretAVRISPPacket+0x80>
    18f4:	41 97       	sbiw	r24, 0x11	; 17
    18f6:	09 f4       	brne	.+2      	; 0x18fa <PD_InterpretAVRISPPacket+0x3a>
    18f8:	46 c0       	rjmp	.+140    	; 0x1986 <PD_InterpretAVRISPPacket+0xc6>
    18fa:	44 c1       	rjmp	.+648    	; 0x1b84 <PD_InterpretAVRISPPacket+0x2c4>
    18fc:	84 31       	cpi	r24, 0x14	; 20
    18fe:	91 05       	cpc	r25, r1
    1900:	09 f4       	brne	.+2      	; 0x1904 <PD_InterpretAVRISPPacket+0x44>
    1902:	90 c0       	rjmp	.+288    	; 0x1a24 <PD_InterpretAVRISPPacket+0x164>
    1904:	45 97       	sbiw	r24, 0x15	; 21
    1906:	0c f0       	brlt	.+2      	; 0x190a <PD_InterpretAVRISPPacket+0x4a>
    1908:	b3 c0       	rjmp	.+358    	; 0x1a70 <PD_InterpretAVRISPPacket+0x1b0>
    190a:	85 c0       	rjmp	.+266    	; 0x1a16 <PD_InterpretAVRISPPacket+0x156>
    190c:	89 31       	cpi	r24, 0x19	; 25
    190e:	91 05       	cpc	r25, r1
    1910:	09 f4       	brne	.+2      	; 0x1914 <PD_InterpretAVRISPPacket+0x54>
    1912:	76 c0       	rjmp	.+236    	; 0x1a00 <PD_InterpretAVRISPPacket+0x140>
    1914:	8a 31       	cpi	r24, 0x1A	; 26
    1916:	91 05       	cpc	r25, r1
    1918:	44 f4       	brge	.+16     	; 0x192a <PD_InterpretAVRISPPacket+0x6a>
    191a:	87 31       	cpi	r24, 0x17	; 23
    191c:	91 05       	cpc	r25, r1
    191e:	09 f4       	brne	.+2      	; 0x1922 <PD_InterpretAVRISPPacket+0x62>
    1920:	6f c0       	rjmp	.+222    	; 0x1a00 <PD_InterpretAVRISPPacket+0x140>
    1922:	48 97       	sbiw	r24, 0x18	; 24
    1924:	09 f4       	brne	.+2      	; 0x1928 <PD_InterpretAVRISPPacket+0x68>
    1926:	5e c0       	rjmp	.+188    	; 0x19e4 <PD_InterpretAVRISPPacket+0x124>
    1928:	2d c1       	rjmp	.+602    	; 0x1b84 <PD_InterpretAVRISPPacket+0x2c4>
    192a:	8b 31       	cpi	r24, 0x1B	; 27
    192c:	91 05       	cpc	r25, r1
    192e:	d9 f1       	breq	.+118    	; 0x19a6 <PD_InterpretAVRISPPacket+0xe6>
    1930:	8b 31       	cpi	r24, 0x1B	; 27
    1932:	91 05       	cpc	r25, r1
    1934:	0c f4       	brge	.+2      	; 0x1938 <PD_InterpretAVRISPPacket+0x78>
    1936:	56 c0       	rjmp	.+172    	; 0x19e4 <PD_InterpretAVRISPPacket+0x124>
    1938:	4c 97       	sbiw	r24, 0x1c	; 28
    193a:	09 f4       	brne	.+2      	; 0x193e <PD_InterpretAVRISPPacket+0x7e>
    193c:	53 c0       	rjmp	.+166    	; 0x19e4 <PD_InterpretAVRISPPacket+0x124>
    193e:	22 c1       	rjmp	.+580    	; 0x1b84 <PD_InterpretAVRISPPacket+0x2c4>
    1940:	82 e0       	ldi	r24, 0x02	; 2
    1942:	90 e0       	ldi	r25, 0x00	; 0
    1944:	90 93 31 01 	sts	0x0131, r25
    1948:	80 93 30 01 	sts	0x0130, r24
    194c:	81 e0       	ldi	r24, 0x01	; 1
    194e:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    1952:	0e 94 89 0a 	call	0x1512 <DF_GetChipCharacteristics>
    1956:	c0 91 87 02 	lds	r28, 0x0287
    195a:	cc 23       	and	r28, r28
    195c:	59 f0       	breq	.+22     	; 0x1974 <PD_InterpretAVRISPPacket+0xb4>
    195e:	89 ec       	ldi	r24, 0xC9	; 201
    1960:	93 e0       	ldi	r25, 0x03	; 3
    1962:	0e 94 04 08 	call	0x1008 <LCD_puts_f>
    1966:	81 e0       	ldi	r24, 0x01	; 1
    1968:	80 93 2f 01 	sts	0x012F, r24
    196c:	81 b3       	in	r24, 0x11	; 17
    196e:	8f 7c       	andi	r24, 0xCF	; 207
    1970:	80 62       	ori	r24, 0x20	; 32
    1972:	17 c0       	rjmp	.+46     	; 0x19a2 <PD_InterpretAVRISPPacket+0xe2>
    1974:	83 e8       	ldi	r24, 0x83	; 131
    1976:	93 e0       	ldi	r25, 0x03	; 3
    1978:	0e 94 04 08 	call	0x1008 <LCD_puts_f>
    197c:	8c 2f       	mov	r24, r28
    197e:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    1982:	80 ec       	ldi	r24, 0xC0	; 192
    1984:	06 c1       	rjmp	.+524    	; 0x1b92 <PD_InterpretAVRISPPacket+0x2d2>
    1986:	82 e0       	ldi	r24, 0x02	; 2
    1988:	90 e0       	ldi	r25, 0x00	; 0
    198a:	90 93 31 01 	sts	0x0131, r25
    198e:	80 93 30 01 	sts	0x0130, r24
    1992:	10 92 2f 01 	sts	0x012F, r1
    1996:	80 e0       	ldi	r24, 0x00	; 0
    1998:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    199c:	81 b3       	in	r24, 0x11	; 17
    199e:	8f 7c       	andi	r24, 0xCF	; 207
    19a0:	80 61       	ori	r24, 0x10	; 16
    19a2:	81 bb       	out	0x11, r24	; 17
    19a4:	9b c0       	rjmp	.+310    	; 0x1adc <PD_InterpretAVRISPPacket+0x21c>
    19a6:	84 e0       	ldi	r24, 0x04	; 4
    19a8:	90 e0       	ldi	r25, 0x00	; 0
    19aa:	90 93 31 01 	sts	0x0131, r25
    19ae:	80 93 30 01 	sts	0x0130, r24
    19b2:	10 92 35 01 	sts	0x0135, r1
    19b6:	82 e0       	ldi	r24, 0x02	; 2
    19b8:	1e c0       	rjmp	.+60     	; 0x19f6 <PD_InterpretAVRISPPacket+0x136>
    19ba:	82 e0       	ldi	r24, 0x02	; 2
    19bc:	90 e0       	ldi	r25, 0x00	; 0
    19be:	90 93 31 01 	sts	0x0131, r25
    19c2:	80 93 30 01 	sts	0x0130, r24
    19c6:	c0 e0       	ldi	r28, 0x00	; 0
    19c8:	d0 e0       	ldi	r29, 0x00	; 0
    19ca:	80 91 8a 02 	lds	r24, 0x028A
    19ce:	90 91 8b 02 	lds	r25, 0x028B
    19d2:	c8 17       	cp	r28, r24
    19d4:	d9 07       	cpc	r29, r25
    19d6:	08 f0       	brcs	.+2      	; 0x19da <PD_InterpretAVRISPPacket+0x11a>
    19d8:	81 c0       	rjmp	.+258    	; 0x1adc <PD_InterpretAVRISPPacket+0x21c>
    19da:	ce 01       	movw	r24, r28
    19dc:	0e 94 c9 0a 	call	0x1592 <DF_ErasePage>
    19e0:	21 96       	adiw	r28, 0x01	; 1
    19e2:	f3 cf       	rjmp	.-26     	; 0x19ca <PD_InterpretAVRISPPacket+0x10a>
    19e4:	84 e0       	ldi	r24, 0x04	; 4
    19e6:	90 e0       	ldi	r25, 0x00	; 0
    19e8:	90 93 31 01 	sts	0x0131, r25
    19ec:	80 93 30 01 	sts	0x0130, r24
    19f0:	10 92 35 01 	sts	0x0135, r1
    19f4:	8f ef       	ldi	r24, 0xFF	; 255
    19f6:	80 93 36 01 	sts	0x0136, r24
    19fa:	10 92 37 01 	sts	0x0137, r1
    19fe:	cb c0       	rjmp	.+406    	; 0x1b96 <PD_InterpretAVRISPPacket+0x2d6>
    1a00:	83 e0       	ldi	r24, 0x03	; 3
    1a02:	90 e0       	ldi	r25, 0x00	; 0
    1a04:	90 93 31 01 	sts	0x0131, r25
    1a08:	80 93 30 01 	sts	0x0130, r24
    1a0c:	10 92 35 01 	sts	0x0135, r1
    1a10:	10 92 36 01 	sts	0x0136, r1
    1a14:	c0 c0       	rjmp	.+384    	; 0x1b96 <PD_InterpretAVRISPPacket+0x2d6>
    1a16:	82 e0       	ldi	r24, 0x02	; 2
    1a18:	90 e0       	ldi	r25, 0x00	; 0
    1a1a:	90 93 31 01 	sts	0x0131, r25
    1a1e:	80 93 30 01 	sts	0x0130, r24
    1a22:	5c c0       	rjmp	.+184    	; 0x1adc <PD_InterpretAVRISPPacket+0x21c>
    1a24:	80 91 35 01 	lds	r24, 0x0135
    1a28:	99 27       	eor	r25, r25
    1a2a:	38 2f       	mov	r19, r24
    1a2c:	22 27       	eor	r18, r18
    1a2e:	80 91 36 01 	lds	r24, 0x0136
    1a32:	99 27       	eor	r25, r25
    1a34:	28 2b       	or	r18, r24
    1a36:	39 2b       	or	r19, r25
    1a38:	f9 01       	movw	r30, r18
    1a3a:	33 96       	adiw	r30, 0x03	; 3
    1a3c:	f0 93 31 01 	sts	0x0131, r31
    1a40:	e0 93 30 01 	sts	0x0130, r30
    1a44:	10 92 35 01 	sts	0x0135, r1
    1a48:	ed 5c       	subi	r30, 0xCD	; 205
    1a4a:	fe 4f       	sbci	r31, 0xFE	; 254
    1a4c:	10 82       	st	Z, r1
    1a4e:	81 e0       	ldi	r24, 0x01	; 1
    1a50:	90 e0       	ldi	r25, 0x00	; 0
    1a52:	28 0f       	add	r18, r24
    1a54:	39 1f       	adc	r19, r25
    1a56:	82 17       	cp	r24, r18
    1a58:	93 07       	cpc	r25, r19
    1a5a:	08 f0       	brcs	.+2      	; 0x1a5e <PD_InterpretAVRISPPacket+0x19e>
    1a5c:	9c c0       	rjmp	.+312    	; 0x1b96 <PD_InterpretAVRISPPacket+0x2d6>
    1a5e:	4f ef       	ldi	r20, 0xFF	; 255
    1a60:	e5 e3       	ldi	r30, 0x35	; 53
    1a62:	f1 e0       	ldi	r31, 0x01	; 1
    1a64:	41 93       	st	Z+, r20
    1a66:	01 96       	adiw	r24, 0x01	; 1
    1a68:	82 17       	cp	r24, r18
    1a6a:	93 07       	cpc	r25, r19
    1a6c:	d8 f3       	brcs	.-10     	; 0x1a64 <PD_InterpretAVRISPPacket+0x1a4>
    1a6e:	93 c0       	rjmp	.+294    	; 0x1b96 <PD_InterpretAVRISPPacket+0x2d6>
    1a70:	0e 94 03 0c 	call	0x1806 <PD_SetupDFAddressCounters>
    1a74:	80 91 8c 02 	lds	r24, 0x028C
    1a78:	90 91 8d 02 	lds	r25, 0x028D
    1a7c:	0e 94 ff 0a 	call	0x15fe <DF_CopyFlashPageToBuffer>
    1a80:	80 91 85 02 	lds	r24, 0x0285
    1a84:	90 91 86 02 	lds	r25, 0x0286
    1a88:	0e 94 63 0a 	call	0x14c6 <DF_BufferWriteEnable>
    1a8c:	80 91 35 01 	lds	r24, 0x0135
    1a90:	99 27       	eor	r25, r25
    1a92:	d8 2f       	mov	r29, r24
    1a94:	cc 27       	eor	r28, r28
    1a96:	80 91 36 01 	lds	r24, 0x0136
    1a9a:	99 27       	eor	r25, r25
    1a9c:	c8 2b       	or	r28, r24
    1a9e:	d9 2b       	or	r29, r25
    1aa0:	00 e0       	ldi	r16, 0x00	; 0
    1aa2:	10 e0       	ldi	r17, 0x00	; 0
    1aa4:	0c 17       	cp	r16, r28
    1aa6:	1d 07       	cpc	r17, r29
    1aa8:	c8 f4       	brcc	.+50     	; 0x1adc <PD_InterpretAVRISPPacket+0x21c>
    1aaa:	3e e3       	ldi	r19, 0x3E	; 62
    1aac:	e3 2e       	mov	r14, r19
    1aae:	31 e0       	ldi	r19, 0x01	; 1
    1ab0:	f3 2e       	mov	r15, r19
    1ab2:	f7 01       	movw	r30, r14
    1ab4:	81 91       	ld	r24, Z+
    1ab6:	7f 01       	movw	r14, r30
    1ab8:	0e 94 30 0c 	call	0x1860 <DF_StoreDataflashByte>
    1abc:	80 91 85 02 	lds	r24, 0x0285
    1ac0:	90 91 86 02 	lds	r25, 0x0286
    1ac4:	01 96       	adiw	r24, 0x01	; 1
    1ac6:	90 93 86 02 	sts	0x0286, r25
    1aca:	80 93 85 02 	sts	0x0285, r24
    1ace:	0e 94 cf 0e 	call	0x1d9e <V2P_IncrementCurrAddress>
    1ad2:	0f 5f       	subi	r16, 0xFF	; 255
    1ad4:	1f 4f       	sbci	r17, 0xFF	; 255
    1ad6:	0c 17       	cp	r16, r28
    1ad8:	1d 07       	cpc	r17, r29
    1ada:	58 f3       	brcs	.-42     	; 0x1ab2 <PD_InterpretAVRISPPacket+0x1f2>
    1adc:	10 92 35 01 	sts	0x0135, r1
    1ae0:	5a c0       	rjmp	.+180    	; 0x1b96 <PD_InterpretAVRISPPacket+0x2d6>
    1ae2:	0e 94 03 0c 	call	0x1806 <PD_SetupDFAddressCounters>
    1ae6:	80 91 8c 02 	lds	r24, 0x028C
    1aea:	90 91 8d 02 	lds	r25, 0x028D
    1aee:	0e 94 ff 0a 	call	0x15fe <DF_CopyFlashPageToBuffer>
    1af2:	80 91 35 01 	lds	r24, 0x0135
    1af6:	99 27       	eor	r25, r25
    1af8:	d8 2f       	mov	r29, r24
    1afa:	cc 27       	eor	r28, r28
    1afc:	80 91 36 01 	lds	r24, 0x0136
    1b00:	99 27       	eor	r25, r25
    1b02:	c8 2b       	or	r28, r24
    1b04:	d9 2b       	or	r29, r25
    1b06:	00 e0       	ldi	r16, 0x00	; 0
    1b08:	10 e0       	ldi	r17, 0x00	; 0
    1b0a:	0c 17       	cp	r16, r28
    1b0c:	1d 07       	cpc	r17, r29
    1b0e:	70 f5       	brcc	.+92     	; 0x1b6c <PD_InterpretAVRISPPacket+0x2ac>
    1b10:	86 e3       	ldi	r24, 0x36	; 54
    1b12:	e8 2e       	mov	r14, r24
    1b14:	81 e0       	ldi	r24, 0x01	; 1
    1b16:	f8 2e       	mov	r15, r24
    1b18:	20 91 85 02 	lds	r18, 0x0285
    1b1c:	30 91 86 02 	lds	r19, 0x0286
    1b20:	80 91 88 02 	lds	r24, 0x0288
    1b24:	90 91 89 02 	lds	r25, 0x0289
    1b28:	28 17       	cp	r18, r24
    1b2a:	39 07       	cpc	r19, r25
    1b2c:	41 f4       	brne	.+16     	; 0x1b3e <PD_InterpretAVRISPPacket+0x27e>
    1b2e:	0e 94 03 0c 	call	0x1806 <PD_SetupDFAddressCounters>
    1b32:	80 91 8c 02 	lds	r24, 0x028C
    1b36:	90 91 8d 02 	lds	r25, 0x028D
    1b3a:	0e 94 ff 0a 	call	0x15fe <DF_CopyFlashPageToBuffer>
    1b3e:	80 91 85 02 	lds	r24, 0x0285
    1b42:	90 91 86 02 	lds	r25, 0x0286
    1b46:	9c 01       	movw	r18, r24
    1b48:	01 96       	adiw	r24, 0x01	; 1
    1b4a:	90 93 86 02 	sts	0x0286, r25
    1b4e:	80 93 85 02 	sts	0x0285, r24
    1b52:	c9 01       	movw	r24, r18
    1b54:	0e 94 f3 09 	call	0x13e6 <DF_ReadBufferByte>
    1b58:	f7 01       	movw	r30, r14
    1b5a:	81 93       	st	Z+, r24
    1b5c:	7f 01       	movw	r14, r30
    1b5e:	0e 94 cf 0e 	call	0x1d9e <V2P_IncrementCurrAddress>
    1b62:	0f 5f       	subi	r16, 0xFF	; 255
    1b64:	1f 4f       	sbci	r17, 0xFF	; 255
    1b66:	0c 17       	cp	r16, r28
    1b68:	1d 07       	cpc	r17, r29
    1b6a:	b0 f2       	brcs	.-84     	; 0x1b18 <PD_InterpretAVRISPPacket+0x258>
    1b6c:	23 96       	adiw	r28, 0x03	; 3
    1b6e:	d0 93 31 01 	sts	0x0131, r29
    1b72:	c0 93 30 01 	sts	0x0130, r28
    1b76:	23 97       	sbiw	r28, 0x03	; 3
    1b78:	10 92 35 01 	sts	0x0135, r1
    1b7c:	cc 5c       	subi	r28, 0xCC	; 204
    1b7e:	de 4f       	sbci	r29, 0xFE	; 254
    1b80:	1a 82       	std	Y+2, r1	; 0x02
    1b82:	09 c0       	rjmp	.+18     	; 0x1b96 <PD_InterpretAVRISPPacket+0x2d6>
    1b84:	81 e0       	ldi	r24, 0x01	; 1
    1b86:	90 e0       	ldi	r25, 0x00	; 0
    1b88:	90 93 31 01 	sts	0x0131, r25
    1b8c:	80 93 30 01 	sts	0x0130, r24
    1b90:	89 ec       	ldi	r24, 0xC9	; 201
    1b92:	80 93 35 01 	sts	0x0135, r24
    1b96:	0e 94 f5 0d 	call	0x1bea <V2P_SendPacket>
    1b9a:	df 91       	pop	r29
    1b9c:	cf 91       	pop	r28
    1b9e:	1f 91       	pop	r17
    1ba0:	0f 91       	pop	r16
    1ba2:	ff 90       	pop	r15
    1ba4:	ef 90       	pop	r14
    1ba6:	08 95       	ret

00001ba8 <V2P_GetChecksum>:
	
	/* Checksum for the V2 protocol is comprised of an XOR of all the packet 
      bytes, including the start, sequence number, size and token bytes.    */
	
	CheckSumByte  = MESSAGE_START;
    1ba8:	6b e1       	ldi	r22, 0x1B	; 27
	CheckSumByte ^= SequenceNum;
    1baa:	80 91 32 01 	lds	r24, 0x0132
    1bae:	68 27       	eor	r22, r24
	CheckSumByte ^= (uint8_t)(MessageSize >> 8);
    1bb0:	20 91 30 01 	lds	r18, 0x0130
    1bb4:	30 91 31 01 	lds	r19, 0x0131
    1bb8:	83 2f       	mov	r24, r19
    1bba:	99 27       	eor	r25, r25
    1bbc:	68 27       	eor	r22, r24
	CheckSumByte ^= (uint8_t)(MessageSize);
    1bbe:	80 91 30 01 	lds	r24, 0x0130
    1bc2:	68 27       	eor	r22, r24
	CheckSumByte ^= TOKEN;
    1bc4:	8e e0       	ldi	r24, 0x0E	; 14
    1bc6:	68 27       	eor	r22, r24
	
	for(uint16_t CByteIndex = 0; CByteIndex < MessageSize; CByteIndex++)
    1bc8:	40 e0       	ldi	r20, 0x00	; 0
    1bca:	50 e0       	ldi	r21, 0x00	; 0
    1bcc:	42 17       	cp	r20, r18
    1bce:	53 07       	cpc	r21, r19
    1bd0:	48 f4       	brcc	.+18     	; 0x1be4 <V2P_GetChecksum+0x3c>
    1bd2:	e4 e3       	ldi	r30, 0x34	; 52
    1bd4:	f1 e0       	ldi	r31, 0x01	; 1
		CheckSumByte ^= PacketBytes[CByteIndex];
    1bd6:	81 91       	ld	r24, Z+
    1bd8:	68 27       	eor	r22, r24
    1bda:	4f 5f       	subi	r20, 0xFF	; 255
    1bdc:	5f 4f       	sbci	r21, 0xFF	; 255
    1bde:	42 17       	cp	r20, r18
    1be0:	53 07       	cpc	r21, r19
    1be2:	c8 f3       	brcs	.-14     	; 0x1bd6 <V2P_GetChecksum+0x2e>

	return CheckSumByte;
}
    1be4:	86 2f       	mov	r24, r22
    1be6:	99 27       	eor	r25, r25
    1be8:	08 95       	ret

00001bea <V2P_SendPacket>:
    1bea:	0f 93       	push	r16
    1bec:	1f 93       	push	r17
    1bee:	cf 93       	push	r28
    1bf0:	df 93       	push	r29
    1bf2:	8b e1       	ldi	r24, 0x1B	; 27
    1bf4:	0e 94 f4 08 	call	0x11e8 <USART_Tx>
    1bf8:	80 91 32 01 	lds	r24, 0x0132
    1bfc:	0e 94 f4 08 	call	0x11e8 <USART_Tx>
    1c00:	80 91 31 01 	lds	r24, 0x0131
    1c04:	0e 94 f4 08 	call	0x11e8 <USART_Tx>
    1c08:	80 91 30 01 	lds	r24, 0x0130
    1c0c:	0e 94 f4 08 	call	0x11e8 <USART_Tx>
    1c10:	8e e0       	ldi	r24, 0x0E	; 14
    1c12:	0e 94 f4 08 	call	0x11e8 <USART_Tx>
    1c16:	c0 e0       	ldi	r28, 0x00	; 0
    1c18:	d0 e0       	ldi	r29, 0x00	; 0
    1c1a:	80 91 30 01 	lds	r24, 0x0130
    1c1e:	90 91 31 01 	lds	r25, 0x0131
    1c22:	c8 17       	cp	r28, r24
    1c24:	d9 07       	cpc	r29, r25
    1c26:	78 f4       	brcc	.+30     	; 0x1c46 <V2P_SendPacket+0x5c>
    1c28:	04 e3       	ldi	r16, 0x34	; 52
    1c2a:	11 e0       	ldi	r17, 0x01	; 1
    1c2c:	f8 01       	movw	r30, r16
    1c2e:	81 91       	ld	r24, Z+
    1c30:	8f 01       	movw	r16, r30
    1c32:	0e 94 f4 08 	call	0x11e8 <USART_Tx>
    1c36:	21 96       	adiw	r28, 0x01	; 1
    1c38:	80 91 30 01 	lds	r24, 0x0130
    1c3c:	90 91 31 01 	lds	r25, 0x0131
    1c40:	c8 17       	cp	r28, r24
    1c42:	d9 07       	cpc	r29, r25
    1c44:	98 f3       	brcs	.-26     	; 0x1c2c <V2P_SendPacket+0x42>
    1c46:	0e 94 d4 0d 	call	0x1ba8 <V2P_GetChecksum>
    1c4a:	0e 94 f4 08 	call	0x11e8 <USART_Tx>
    1c4e:	80 91 32 01 	lds	r24, 0x0132
    1c52:	90 91 33 01 	lds	r25, 0x0133
    1c56:	01 96       	adiw	r24, 0x01	; 1
    1c58:	90 93 33 01 	sts	0x0133, r25
    1c5c:	80 93 32 01 	sts	0x0132, r24
    1c60:	df 91       	pop	r29
    1c62:	cf 91       	pop	r28
    1c64:	1f 91       	pop	r17
    1c66:	0f 91       	pop	r16
    1c68:	08 95       	ret

00001c6a <V2P_GetSetParamater>:

void V2P_GetSetParamater(void)
{
	uint8_t Param_Name = PacketBytes[1];    // Save the parameter number
    1c6a:	20 91 35 01 	lds	r18, 0x0135

	MessageSize = 3;                        // Set the default response message size to 3 bytes     
    1c6e:	83 e0       	ldi	r24, 0x03	; 3
    1c70:	90 e0       	ldi	r25, 0x00	; 0
    1c72:	90 93 31 01 	sts	0x0131, r25
    1c76:	80 93 30 01 	sts	0x0130, r24
	PacketBytes[1] = STATUS_CMD_OK;         // Set the default response to OK
    1c7a:	10 92 35 01 	sts	0x0135, r1

	switch (Param_Name)                    // Switch based on the recieved parameter byte
    1c7e:	e2 2f       	mov	r30, r18
    1c80:	ff 27       	eor	r31, r31
    1c82:	e8 39       	cpi	r30, 0x98	; 152
    1c84:	f1 05       	cpc	r31, r1
    1c86:	ac f4       	brge	.+42     	; 0x1cb2 <V2P_GetSetParamater+0x48>
    1c88:	e6 39       	cpi	r30, 0x96	; 150
    1c8a:	f1 05       	cpc	r31, r1
    1c8c:	0c f0       	brlt	.+2      	; 0x1c90 <V2P_GetSetParamater+0x26>
    1c8e:	6d c0       	rjmp	.+218    	; 0x1d6a <V2P_GetSetParamater+0x100>
    1c90:	e1 38       	cpi	r30, 0x81	; 129
    1c92:	f1 05       	cpc	r31, r1
    1c94:	f9 f0       	breq	.+62     	; 0x1cd4 <V2P_GetSetParamater+0x6a>
    1c96:	e2 38       	cpi	r30, 0x82	; 130
    1c98:	f1 05       	cpc	r31, r1
    1c9a:	24 f4       	brge	.+8      	; 0x1ca4 <V2P_GetSetParamater+0x3a>
    1c9c:	e0 38       	cpi	r30, 0x80	; 128
    1c9e:	f1 05       	cpc	r31, r1
    1ca0:	b9 f0       	breq	.+46     	; 0x1cd0 <V2P_GetSetParamater+0x66>
    1ca2:	71 c0       	rjmp	.+226    	; 0x1d86 <V2P_GetSetParamater+0x11c>
    1ca4:	cf 01       	movw	r24, r30
    1ca6:	80 59       	subi	r24, 0x90	; 144
    1ca8:	90 40       	sbci	r25, 0x00	; 0
    1caa:	03 97       	sbiw	r24, 0x03	; 3
    1cac:	08 f0       	brcs	.+2      	; 0x1cb0 <V2P_GetSetParamater+0x46>
    1cae:	6b c0       	rjmp	.+214    	; 0x1d86 <V2P_GetSetParamater+0x11c>
    1cb0:	13 c0       	rjmp	.+38     	; 0x1cd8 <V2P_GetSetParamater+0x6e>
    1cb2:	ee 39       	cpi	r30, 0x9E	; 158
    1cb4:	f1 05       	cpc	r31, r1
    1cb6:	09 f4       	brne	.+2      	; 0x1cba <V2P_GetSetParamater+0x50>
    1cb8:	3d c0       	rjmp	.+122    	; 0x1d34 <V2P_GetSetParamater+0xca>
    1cba:	ef 39       	cpi	r30, 0x9F	; 159
    1cbc:	f1 05       	cpc	r31, r1
    1cbe:	24 f4       	brge	.+8      	; 0x1cc8 <V2P_GetSetParamater+0x5e>
    1cc0:	e8 39       	cpi	r30, 0x98	; 152
    1cc2:	f1 05       	cpc	r31, r1
    1cc4:	f9 f0       	breq	.+62     	; 0x1d04 <V2P_GetSetParamater+0x9a>
    1cc6:	5f c0       	rjmp	.+190    	; 0x1d86 <V2P_GetSetParamater+0x11c>
    1cc8:	ef 39       	cpi	r30, 0x9F	; 159
    1cca:	f1 05       	cpc	r31, r1
    1ccc:	49 f0       	breq	.+18     	; 0x1ce0 <V2P_GetSetParamater+0x76>
    1cce:	5b c0       	rjmp	.+182    	; 0x1d86 <V2P_GetSetParamater+0x11c>
	{
		case PARAM_BUILD_NUMBER_LOW:
			PacketBytes[2] = VERSION_MINOR;
    1cd0:	83 e0       	ldi	r24, 0x03	; 3
    1cd2:	38 c0       	rjmp	.+112    	; 0x1d44 <V2P_GetSetParamater+0xda>

			break;
		case PARAM_BUILD_NUMBER_HIGH:
			PacketBytes[2] = VERSION_MAJOR;
    1cd4:	81 e0       	ldi	r24, 0x01	; 1
    1cd6:	36 c0       	rjmp	.+108    	; 0x1d44 <V2P_GetSetParamater+0xda>

			break;
		case PARAM_HARDWARE_VERSION:
		case PARAM_SW_MAJOR:
		case PARAM_SW_MINOR:
			PacketBytes[2] = pgm_read_byte(&VersionData[Param_Name - PARAM_HARDWARE_VERSION]);
    1cd8:	eb 5a       	subi	r30, 0xAB	; 171
    1cda:	fc 4f       	sbci	r31, 0xFC	; 252
    1cdc:	84 91       	lpm	r24, Z
    1cde:	32 c0       	rjmp	.+100    	; 0x1d44 <V2P_GetSetParamater+0xda>

			break;
		case PARAM_CONTROLLER_INIT:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1ce0:	80 91 34 01 	lds	r24, 0x0134
    1ce4:	83 30       	cpi	r24, 0x03	; 3
    1ce6:	19 f4       	brne	.+6      	; 0x1cee <V2P_GetSetParamater+0x84>
			{
				PacketBytes[2] = Param_ControllerInit;
    1ce8:	80 91 2a 01 	lds	r24, 0x012A
    1cec:	2b c0       	rjmp	.+86     	; 0x1d44 <V2P_GetSetParamater+0xda>
			}
			else
			{
				MessageSize = 2;
    1cee:	82 e0       	ldi	r24, 0x02	; 2
    1cf0:	90 e0       	ldi	r25, 0x00	; 0
    1cf2:	90 93 31 01 	sts	0x0131, r25
    1cf6:	80 93 30 01 	sts	0x0130, r24
				Param_ControllerInit = PacketBytes[2];
    1cfa:	80 91 36 01 	lds	r24, 0x0136
    1cfe:	80 93 2a 01 	sts	0x012A, r24
			}
			
			break;
    1d02:	4a c0       	rjmp	.+148    	; 0x1d98 <V2P_GetSetParamater+0x12e>
		case PARAM_SCK_DURATION:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1d04:	80 91 34 01 	lds	r24, 0x0134
    1d08:	83 30       	cpi	r24, 0x03	; 3
    1d0a:	19 f4       	brne	.+6      	; 0x1d12 <V2P_GetSetParamater+0xa8>
			{
				PacketBytes[2] = eeprom_read_byte_169(&Param_SCKDuration);
    1d0c:	80 e2       	ldi	r24, 0x20	; 32
    1d0e:	91 e0       	ldi	r25, 0x01	; 1
    1d10:	17 c0       	rjmp	.+46     	; 0x1d40 <V2P_GetSetParamater+0xd6>
			}
			else
			{
				MessageSize = 2;
    1d12:	82 e0       	ldi	r24, 0x02	; 2
    1d14:	90 e0       	ldi	r25, 0x00	; 0
    1d16:	90 93 31 01 	sts	0x0131, r25
    1d1a:	80 93 30 01 	sts	0x0130, r24
				eeprom_write_byte_169(&Param_SCKDuration, PacketBytes[2]);
    1d1e:	60 91 36 01 	lds	r22, 0x0136
    1d22:	80 e2       	ldi	r24, 0x20	; 32
    1d24:	91 e0       	ldi	r25, 0x01	; 1
    1d26:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
				USI_SPISetSpeed(PacketBytes[2]); // Re-Initialise the USI system with the new frequency
    1d2a:	80 91 36 01 	lds	r24, 0x0136
    1d2e:	0e 94 77 09 	call	0x12ee <USI_SPISetSpeed>
			}
					
			break;
    1d32:	32 c0       	rjmp	.+100    	; 0x1d98 <V2P_GetSetParamater+0x12e>
		case PARAM_RESET_POLARITY:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1d34:	80 91 34 01 	lds	r24, 0x0134
    1d38:	83 30       	cpi	r24, 0x03	; 3
    1d3a:	39 f4       	brne	.+14     	; 0x1d4a <V2P_GetSetParamater+0xe0>
			{
				PacketBytes[2] = eeprom_read_byte_169(&Param_ResetPolarity);		
    1d3c:	82 e2       	ldi	r24, 0x22	; 34
    1d3e:	91 e0       	ldi	r25, 0x01	; 1
    1d40:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
    1d44:	80 93 36 01 	sts	0x0136, r24
    1d48:	27 c0       	rjmp	.+78     	; 0x1d98 <V2P_GetSetParamater+0x12e>
			}
			else
			{
				MessageSize = 2;
    1d4a:	82 e0       	ldi	r24, 0x02	; 2
    1d4c:	90 e0       	ldi	r25, 0x00	; 0
    1d4e:	90 93 31 01 	sts	0x0131, r25
    1d52:	80 93 30 01 	sts	0x0130, r24
				eeprom_write_byte_169(&Param_ResetPolarity, PacketBytes[2]);
    1d56:	60 91 36 01 	lds	r22, 0x0136
    1d5a:	82 e2       	ldi	r24, 0x22	; 34
    1d5c:	91 e0       	ldi	r25, 0x01	; 1
    1d5e:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Change takes effect immediatly
    1d62:	81 e0       	ldi	r24, 0x01	; 1
    1d64:	0e 94 1b 03 	call	0x636 <MAIN_ResetCSLine>
			}
			
			break;
    1d68:	17 c0       	rjmp	.+46     	; 0x1d98 <V2P_GetSetParamater+0x12e>
		case PARAM_OSC_PSCALE:
		case PARAM_OSC_CMATCH:
			/* Despite not supporting these parameters (STK500 only), the AVR Studio programmer
			   sends them along with the SCK duration. A OK must be returned or the sequence will fail
			   and the SCK duration byte will not be sent.                                             */
		
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1d6a:	80 91 34 01 	lds	r24, 0x0134
    1d6e:	83 30       	cpi	r24, 0x03	; 3
    1d70:	19 f4       	brne	.+6      	; 0x1d78 <V2P_GetSetParamater+0x10e>
			{
			   PacketBytes[2] = 0;            // If the command is a read, return a 0 for both parameters
    1d72:	10 92 36 01 	sts	0x0136, r1
    1d76:	10 c0       	rjmp	.+32     	; 0x1d98 <V2P_GetSetParamater+0x12e>
			}
			else
			{
				MessageSize = 2;              // Otherwise just send back an OK if the command is a set		
    1d78:	82 e0       	ldi	r24, 0x02	; 2
    1d7a:	90 e0       	ldi	r25, 0x00	; 0
    1d7c:	90 93 31 01 	sts	0x0131, r25
    1d80:	80 93 30 01 	sts	0x0130, r24
			}
			
			break;
    1d84:	09 c0       	rjmp	.+18     	; 0x1d98 <V2P_GetSetParamater+0x12e>
		default:                             // Unrecognised parameter
			MessageSize = 2;
    1d86:	82 e0       	ldi	r24, 0x02	; 2
    1d88:	90 e0       	ldi	r25, 0x00	; 0
    1d8a:	90 93 31 01 	sts	0x0131, r25
    1d8e:	80 93 30 01 	sts	0x0130, r24
			PacketBytes[1] = STATUS_CMD_FAILED;			
    1d92:	80 ec       	ldi	r24, 0xC0	; 192
    1d94:	80 93 35 01 	sts	0x0135, r24
	}
	
	V2P_SendPacket();
    1d98:	0e 94 f5 0d 	call	0x1bea <V2P_SendPacket>
    1d9c:	08 95       	ret

00001d9e <V2P_IncrementCurrAddress>:
}

void V2P_IncrementCurrAddress(void)
{
	// Incrementing a 32-bit unsigned variable takes a lot of code. Because much of the code is
	// not very time critical (much of it is waiting for the hardware), i've chosen to waste
	// a few extra cycles per increment and save a good 60 bytes or so of code space by putting
	// the incrmement inside a function.

	CurrAddress++;
    1d9e:	80 91 2b 01 	lds	r24, 0x012B
    1da2:	90 91 2c 01 	lds	r25, 0x012C
    1da6:	a0 91 2d 01 	lds	r26, 0x012D
    1daa:	b0 91 2e 01 	lds	r27, 0x012E
    1dae:	01 96       	adiw	r24, 0x01	; 1
    1db0:	a1 1d       	adc	r26, r1
    1db2:	b1 1d       	adc	r27, r1
    1db4:	80 93 2b 01 	sts	0x012B, r24
    1db8:	90 93 2c 01 	sts	0x012C, r25
    1dbc:	a0 93 2d 01 	sts	0x012D, r26
    1dc0:	b0 93 2e 01 	sts	0x012E, r27
    1dc4:	08 95       	ret

00001dc6 <V2P_CheckForExtendedAddress>:
}

void V2P_CheckForExtendedAddress(void)
{
	if (CurrAddress & (1UL << 31))                     // MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
    1dc6:	80 91 2b 01 	lds	r24, 0x012B
    1dca:	90 91 2c 01 	lds	r25, 0x012C
    1dce:	a0 91 2d 01 	lds	r26, 0x012D
    1dd2:	b0 91 2e 01 	lds	r27, 0x012E
    1dd6:	b7 ff       	sbrs	r27, 7
    1dd8:	1e c0       	rjmp	.+60     	; 0x1e16 <V2P_CheckForExtendedAddress+0x50>
	{
		USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);   // Load extended address command
    1dda:	8d e4       	ldi	r24, 0x4D	; 77
    1ddc:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1de0:	80 e0       	ldi	r24, 0x00	; 0
    1de2:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
		USI_SPITransmit((CurrAddress & 0x00FF0000) >> 16); // The 3rd byte of the long holds the extended address
    1de6:	80 91 2d 01 	lds	r24, 0x012D
    1dea:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1dee:	80 e0       	ldi	r24, 0x00	; 0
    1df0:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
		
		CurrAddress &= ~(1UL << 31);                   // Clear the flag
    1df4:	80 91 2b 01 	lds	r24, 0x012B
    1df8:	90 91 2c 01 	lds	r25, 0x012C
    1dfc:	a0 91 2d 01 	lds	r26, 0x012D
    1e00:	b0 91 2e 01 	lds	r27, 0x012E
    1e04:	bf 77       	andi	r27, 0x7F	; 127
    1e06:	80 93 2b 01 	sts	0x012B, r24
    1e0a:	90 93 2c 01 	sts	0x012C, r25
    1e0e:	a0 93 2d 01 	sts	0x012D, r26
    1e12:	b0 93 2e 01 	sts	0x012E, r27
    1e16:	08 95       	ret

00001e18 <V2P_RunStateMachine>:
    1e18:	ef 92       	push	r14
    1e1a:	ff 92       	push	r15
    1e1c:	0f 93       	push	r16
    1e1e:	1f 93       	push	r17
    1e20:	cf 93       	push	r28
    1e22:	c0 e0       	ldi	r28, 0x00	; 0
    1e24:	ee 24       	eor	r14, r14
    1e26:	ff 24       	eor	r15, r15
    1e28:	80 91 c1 00 	lds	r24, 0x00C1
    1e2c:	80 78       	andi	r24, 0x80	; 128
    1e2e:	88 61       	ori	r24, 0x18	; 24
    1e30:	80 93 c1 00 	sts	0x00C1, r24
    1e34:	0e 94 80 0b 	call	0x1700 <BUFF_InitialiseBuffer>
    1e38:	0e 94 f3 0b 	call	0x17e6 <TIMEOUT_SetupTimeoutTimer>
    1e3c:	c0 93 2f 01 	sts	0x012F, r28
    1e40:	10 92 2b 01 	sts	0x012B, r1
    1e44:	10 92 2c 01 	sts	0x012C, r1
    1e48:	10 92 2d 01 	sts	0x012D, r1
    1e4c:	10 92 2e 01 	sts	0x012E, r1
    1e50:	80 91 28 01 	lds	r24, 0x0128
    1e54:	81 30       	cpi	r24, 0x01	; 1
    1e56:	11 f4       	brne	.+4      	; 0x1e5c <V2P_RunStateMachine+0x44>
    1e58:	c9 e0       	ldi	r28, 0x09	; 9
    1e5a:	05 c0       	rjmp	.+10     	; 0x1e66 <V2P_RunStateMachine+0x4e>
    1e5c:	cc 23       	and	r28, r28
    1e5e:	19 f0       	breq	.+6      	; 0x1e66 <V2P_RunStateMachine+0x4e>
    1e60:	83 e0       	ldi	r24, 0x03	; 3
    1e62:	80 93 81 00 	sts	0x0081, r24
    1e66:	8c 2f       	mov	r24, r28
    1e68:	99 27       	eor	r25, r25
    1e6a:	84 30       	cpi	r24, 0x04	; 4
    1e6c:	91 05       	cpc	r25, r1
    1e6e:	09 f4       	brne	.+2      	; 0x1e72 <V2P_RunStateMachine+0x5a>
    1e70:	6d c0       	rjmp	.+218    	; 0x1f4c <V2P_RunStateMachine+0x134>
    1e72:	85 30       	cpi	r24, 0x05	; 5
    1e74:	91 05       	cpc	r25, r1
    1e76:	94 f4       	brge	.+36     	; 0x1e9c <V2P_RunStateMachine+0x84>
    1e78:	81 30       	cpi	r24, 0x01	; 1
    1e7a:	91 05       	cpc	r25, r1
    1e7c:	09 f4       	brne	.+2      	; 0x1e80 <V2P_RunStateMachine+0x68>
    1e7e:	4c c0       	rjmp	.+152    	; 0x1f18 <V2P_RunStateMachine+0x100>
    1e80:	82 30       	cpi	r24, 0x02	; 2
    1e82:	91 05       	cpc	r25, r1
    1e84:	1c f4       	brge	.+6      	; 0x1e8c <V2P_RunStateMachine+0x74>
    1e86:	89 2b       	or	r24, r25
    1e88:	b1 f1       	breq	.+108    	; 0x1ef6 <V2P_RunStateMachine+0xde>
    1e8a:	e2 cf       	rjmp	.-60     	; 0x1e50 <V2P_RunStateMachine+0x38>
    1e8c:	82 30       	cpi	r24, 0x02	; 2
    1e8e:	91 05       	cpc	r25, r1
    1e90:	09 f4       	brne	.+2      	; 0x1e94 <V2P_RunStateMachine+0x7c>
    1e92:	48 c0       	rjmp	.+144    	; 0x1f24 <V2P_RunStateMachine+0x10c>
    1e94:	03 97       	sbiw	r24, 0x03	; 3
    1e96:	09 f4       	brne	.+2      	; 0x1e9a <V2P_RunStateMachine+0x82>
    1e98:	4e c0       	rjmp	.+156    	; 0x1f36 <V2P_RunStateMachine+0x11e>
    1e9a:	da cf       	rjmp	.-76     	; 0x1e50 <V2P_RunStateMachine+0x38>
    1e9c:	87 30       	cpi	r24, 0x07	; 7
    1e9e:	91 05       	cpc	r25, r1
    1ea0:	09 f4       	brne	.+2      	; 0x1ea4 <V2P_RunStateMachine+0x8c>
    1ea2:	85 c0       	rjmp	.+266    	; 0x1fae <V2P_RunStateMachine+0x196>
    1ea4:	88 30       	cpi	r24, 0x08	; 8
    1ea6:	91 05       	cpc	r25, r1
    1ea8:	44 f4       	brge	.+16     	; 0x1eba <V2P_RunStateMachine+0xa2>
    1eaa:	85 30       	cpi	r24, 0x05	; 5
    1eac:	91 05       	cpc	r25, r1
    1eae:	09 f4       	brne	.+2      	; 0x1eb2 <V2P_RunStateMachine+0x9a>
    1eb0:	62 c0       	rjmp	.+196    	; 0x1f76 <V2P_RunStateMachine+0x15e>
    1eb2:	06 97       	sbiw	r24, 0x06	; 6
    1eb4:	09 f4       	brne	.+2      	; 0x1eb8 <V2P_RunStateMachine+0xa0>
    1eb6:	67 c0       	rjmp	.+206    	; 0x1f86 <V2P_RunStateMachine+0x16e>
    1eb8:	cb cf       	rjmp	.-106    	; 0x1e50 <V2P_RunStateMachine+0x38>
    1eba:	88 30       	cpi	r24, 0x08	; 8
    1ebc:	91 05       	cpc	r25, r1
    1ebe:	79 f0       	breq	.+30     	; 0x1ede <V2P_RunStateMachine+0xc6>
    1ec0:	09 97       	sbiw	r24, 0x09	; 9
    1ec2:	31 f6       	brne	.-116    	; 0x1e50 <V2P_RunStateMachine+0x38>
    1ec4:	82 e0       	ldi	r24, 0x02	; 2
    1ec6:	90 e0       	ldi	r25, 0x00	; 0
    1ec8:	90 93 31 01 	sts	0x0131, r25
    1ecc:	80 93 30 01 	sts	0x0130, r24
    1ed0:	80 ec       	ldi	r24, 0xC0	; 192
    1ed2:	80 93 35 01 	sts	0x0135, r24
    1ed6:	10 92 28 01 	sts	0x0128, r1
    1eda:	0e 94 f5 0d 	call	0x1bea <V2P_SendPacket>
    1ede:	0e 94 80 0b 	call	0x1700 <BUFF_InitialiseBuffer>
    1ee2:	10 92 81 00 	sts	0x0081, r1
    1ee6:	10 92 29 01 	sts	0x0129, r1
    1eea:	10 92 85 00 	sts	0x0085, r1
    1eee:	10 92 84 00 	sts	0x0084, r1
    1ef2:	c0 e0       	ldi	r28, 0x00	; 0
    1ef4:	ad cf       	rjmp	.-166    	; 0x1e50 <V2P_RunStateMachine+0x38>
    1ef6:	80 91 d2 02 	lds	r24, 0x02D2
    1efa:	81 11       	cpse	r24, r1
    1efc:	c1 e0       	ldi	r28, 0x01	; 1
    1efe:	f2 9b       	sbis	0x1e, 2	; 30
    1f00:	a7 cf       	rjmp	.-178    	; 0x1e50 <V2P_RunStateMachine+0x38>
    1f02:	80 91 2f 01 	lds	r24, 0x012F
    1f06:	88 23       	and	r24, r24
    1f08:	09 f0       	breq	.+2      	; 0x1f0c <V2P_RunStateMachine+0xf4>
    1f0a:	a2 cf       	rjmp	.-188    	; 0x1e50 <V2P_RunStateMachine+0x38>
    1f0c:	80 91 c1 00 	lds	r24, 0x00C1
    1f10:	80 78       	andi	r24, 0x80	; 128
    1f12:	80 93 c1 00 	sts	0x00C1, r24
    1f16:	ee c0       	rjmp	.+476    	; 0x20f4 <V2P_RunStateMachine+0x2dc>
    1f18:	0e 94 0b 09 	call	0x1216 <USART_Rx>
    1f1c:	8b 31       	cpi	r24, 0x1B	; 27
    1f1e:	89 f5       	brne	.+98     	; 0x1f82 <V2P_RunStateMachine+0x16a>
    1f20:	c2 e0       	ldi	r28, 0x02	; 2
    1f22:	96 cf       	rjmp	.-212    	; 0x1e50 <V2P_RunStateMachine+0x38>
    1f24:	0e 94 0b 09 	call	0x1216 <USART_Rx>
    1f28:	99 27       	eor	r25, r25
    1f2a:	90 93 33 01 	sts	0x0133, r25
    1f2e:	80 93 32 01 	sts	0x0132, r24
    1f32:	c3 e0       	ldi	r28, 0x03	; 3
    1f34:	8d cf       	rjmp	.-230    	; 0x1e50 <V2P_RunStateMachine+0x38>
    1f36:	0e 94 0b 09 	call	0x1216 <USART_Rx>
    1f3a:	99 27       	eor	r25, r25
    1f3c:	98 2f       	mov	r25, r24
    1f3e:	88 27       	eor	r24, r24
    1f40:	90 93 31 01 	sts	0x0131, r25
    1f44:	80 93 30 01 	sts	0x0130, r24
    1f48:	c4 e0       	ldi	r28, 0x04	; 4
    1f4a:	82 cf       	rjmp	.-252    	; 0x1e50 <V2P_RunStateMachine+0x38>
    1f4c:	0e 94 0b 09 	call	0x1216 <USART_Rx>
    1f50:	28 2f       	mov	r18, r24
    1f52:	33 27       	eor	r19, r19
    1f54:	80 91 30 01 	lds	r24, 0x0130
    1f58:	90 91 31 01 	lds	r25, 0x0131
    1f5c:	82 2b       	or	r24, r18
    1f5e:	93 2b       	or	r25, r19
    1f60:	90 93 31 01 	sts	0x0131, r25
    1f64:	80 93 30 01 	sts	0x0130, r24
    1f68:	83 51       	subi	r24, 0x13	; 19
    1f6a:	91 40       	sbci	r25, 0x01	; 1
    1f6c:	50 f4       	brcc	.+20     	; 0x1f82 <V2P_RunStateMachine+0x16a>
    1f6e:	c5 e0       	ldi	r28, 0x05	; 5
    1f70:	ee 24       	eor	r14, r14
    1f72:	ff 24       	eor	r15, r15
    1f74:	6d cf       	rjmp	.-294    	; 0x1e50 <V2P_RunStateMachine+0x38>
    1f76:	0e 94 0b 09 	call	0x1216 <USART_Rx>
    1f7a:	8e 30       	cpi	r24, 0x0E	; 14
    1f7c:	11 f4       	brne	.+4      	; 0x1f82 <V2P_RunStateMachine+0x16a>
    1f7e:	c6 e0       	ldi	r28, 0x06	; 6
    1f80:	67 cf       	rjmp	.-306    	; 0x1e50 <V2P_RunStateMachine+0x38>
    1f82:	c9 e0       	ldi	r28, 0x09	; 9
    1f84:	65 cf       	rjmp	.-310    	; 0x1e50 <V2P_RunStateMachine+0x38>
    1f86:	80 91 30 01 	lds	r24, 0x0130
    1f8a:	90 91 31 01 	lds	r25, 0x0131
    1f8e:	e8 16       	cp	r14, r24
    1f90:	f9 06       	cpc	r15, r25
    1f92:	11 f4       	brne	.+4      	; 0x1f98 <V2P_RunStateMachine+0x180>
    1f94:	c7 e0       	ldi	r28, 0x07	; 7
    1f96:	5c cf       	rjmp	.-328    	; 0x1e50 <V2P_RunStateMachine+0x38>
    1f98:	87 01       	movw	r16, r14
    1f9a:	0c 5c       	subi	r16, 0xCC	; 204
    1f9c:	1e 4f       	sbci	r17, 0xFE	; 254
    1f9e:	08 94       	sec
    1fa0:	e1 1c       	adc	r14, r1
    1fa2:	f1 1c       	adc	r15, r1
    1fa4:	0e 94 0b 09 	call	0x1216 <USART_Rx>
    1fa8:	f8 01       	movw	r30, r16
    1faa:	80 83       	st	Z, r24
    1fac:	51 cf       	rjmp	.-350    	; 0x1e50 <V2P_RunStateMachine+0x38>
    1fae:	0e 94 d4 0d 	call	0x1ba8 <V2P_GetChecksum>
    1fb2:	18 2f       	mov	r17, r24
    1fb4:	0e 94 0b 09 	call	0x1216 <USART_Rx>
    1fb8:	18 17       	cp	r17, r24
    1fba:	09 f0       	breq	.+2      	; 0x1fbe <V2P_RunStateMachine+0x1a6>
    1fbc:	8e c0       	rjmp	.+284    	; 0x20da <V2P_RunStateMachine+0x2c2>
    1fbe:	80 91 34 01 	lds	r24, 0x0134
    1fc2:	99 27       	eor	r25, r25
    1fc4:	84 30       	cpi	r24, 0x04	; 4
    1fc6:	91 05       	cpc	r25, r1
    1fc8:	3c f4       	brge	.+14     	; 0x1fd8 <V2P_RunStateMachine+0x1c0>
    1fca:	82 30       	cpi	r24, 0x02	; 2
    1fcc:	91 05       	cpc	r25, r1
    1fce:	0c f0       	brlt	.+2      	; 0x1fd2 <V2P_RunStateMachine+0x1ba>
    1fd0:	7b c0       	rjmp	.+246    	; 0x20c8 <V2P_RunStateMachine+0x2b0>
    1fd2:	01 97       	sbiw	r24, 0x01	; 1
    1fd4:	39 f0       	breq	.+14     	; 0x1fe4 <V2P_RunStateMachine+0x1cc>
    1fd6:	7b c0       	rjmp	.+246    	; 0x20ce <V2P_RunStateMachine+0x2b6>
    1fd8:	86 30       	cpi	r24, 0x06	; 6
    1fda:	91 05       	cpc	r25, r1
    1fdc:	e9 f0       	breq	.+58     	; 0x2018 <V2P_RunStateMachine+0x200>
    1fde:	07 97       	sbiw	r24, 0x07	; 7
    1fe0:	99 f0       	breq	.+38     	; 0x2008 <V2P_RunStateMachine+0x1f0>
    1fe2:	75 c0       	rjmp	.+234    	; 0x20ce <V2P_RunStateMachine+0x2b6>
    1fe4:	8b e0       	ldi	r24, 0x0B	; 11
    1fe6:	90 e0       	ldi	r25, 0x00	; 0
    1fe8:	90 93 31 01 	sts	0x0131, r25
    1fec:	80 93 30 01 	sts	0x0130, r24
    1ff0:	a4 e3       	ldi	r26, 0x34	; 52
    1ff2:	b1 e0       	ldi	r27, 0x01	; 1
    1ff4:	ea ed       	ldi	r30, 0xDA	; 218
    1ff6:	f3 e0       	ldi	r31, 0x03	; 3
    1ff8:	9a e0       	ldi	r25, 0x0A	; 10
    1ffa:	84 91       	lpm	r24, Z
    1ffc:	8d 93       	st	X+, r24
    1ffe:	91 50       	subi	r25, 0x01	; 1
    2000:	31 96       	adiw	r30, 0x01	; 1
    2002:	97 ff       	sbrs	r25, 7
    2004:	fa cf       	rjmp	.-12     	; 0x1ffa <V2P_RunStateMachine+0x1e2>
    2006:	72 c0       	rjmp	.+228    	; 0x20ec <V2P_RunStateMachine+0x2d4>
    2008:	82 e0       	ldi	r24, 0x02	; 2
    200a:	90 e0       	ldi	r25, 0x00	; 0
    200c:	90 93 31 01 	sts	0x0131, r25
    2010:	80 93 30 01 	sts	0x0130, r24
    2014:	80 ec       	ldi	r24, 0xC0	; 192
    2016:	68 c0       	rjmp	.+208    	; 0x20e8 <V2P_RunStateMachine+0x2d0>
    2018:	82 e0       	ldi	r24, 0x02	; 2
    201a:	90 e0       	ldi	r25, 0x00	; 0
    201c:	90 93 31 01 	sts	0x0131, r25
    2020:	80 93 30 01 	sts	0x0130, r24
    2024:	0e 94 e3 0e 	call	0x1dc6 <V2P_CheckForExtendedAddress>
    2028:	80 91 35 01 	lds	r24, 0x0135
    202c:	99 27       	eor	r25, r25
    202e:	aa 27       	eor	r26, r26
    2030:	bb 27       	eor	r27, r27
    2032:	b8 2f       	mov	r27, r24
    2034:	aa 27       	eor	r26, r26
    2036:	99 27       	eor	r25, r25
    2038:	88 27       	eor	r24, r24
    203a:	20 91 36 01 	lds	r18, 0x0136
    203e:	33 27       	eor	r19, r19
    2040:	44 27       	eor	r20, r20
    2042:	55 27       	eor	r21, r21
    2044:	a9 01       	movw	r20, r18
    2046:	33 27       	eor	r19, r19
    2048:	22 27       	eor	r18, r18
    204a:	82 2b       	or	r24, r18
    204c:	93 2b       	or	r25, r19
    204e:	a4 2b       	or	r26, r20
    2050:	b5 2b       	or	r27, r21
    2052:	20 91 37 01 	lds	r18, 0x0137
    2056:	33 27       	eor	r19, r19
    2058:	44 27       	eor	r20, r20
    205a:	55 27       	eor	r21, r21
    205c:	54 2f       	mov	r21, r20
    205e:	43 2f       	mov	r20, r19
    2060:	32 2f       	mov	r19, r18
    2062:	22 27       	eor	r18, r18
    2064:	82 2b       	or	r24, r18
    2066:	93 2b       	or	r25, r19
    2068:	a4 2b       	or	r26, r20
    206a:	b5 2b       	or	r27, r21
    206c:	20 91 38 01 	lds	r18, 0x0138
    2070:	33 27       	eor	r19, r19
    2072:	44 27       	eor	r20, r20
    2074:	55 27       	eor	r21, r21
    2076:	82 2b       	or	r24, r18
    2078:	93 2b       	or	r25, r19
    207a:	a4 2b       	or	r26, r20
    207c:	b5 2b       	or	r27, r21
    207e:	80 93 2b 01 	sts	0x012B, r24
    2082:	90 93 2c 01 	sts	0x012C, r25
    2086:	a0 93 2d 01 	sts	0x012D, r26
    208a:	b0 93 2e 01 	sts	0x012E, r27
    208e:	80 91 47 02 	lds	r24, 0x0247
    2092:	88 23       	and	r24, r24
    2094:	b1 f0       	breq	.+44     	; 0x20c2 <V2P_RunStateMachine+0x2aa>
    2096:	80 91 8c 02 	lds	r24, 0x028C
    209a:	90 91 8d 02 	lds	r25, 0x028D
    209e:	0e 94 35 0b 	call	0x166a <DF_CopyBufferToFlashPage>
    20a2:	80 91 4b 02 	lds	r24, 0x024B
    20a6:	0e 94 f7 13 	call	0x27ee <PM_SetupDFAddressCounters>
    20aa:	80 91 8c 02 	lds	r24, 0x028C
    20ae:	90 91 8d 02 	lds	r25, 0x028D
    20b2:	0e 94 ff 0a 	call	0x15fe <DF_CopyFlashPageToBuffer>
    20b6:	80 91 85 02 	lds	r24, 0x0285
    20ba:	90 91 86 02 	lds	r25, 0x0286
    20be:	0e 94 63 0a 	call	0x14c6 <DF_BufferWriteEnable>
    20c2:	10 92 35 01 	sts	0x0135, r1
    20c6:	12 c0       	rjmp	.+36     	; 0x20ec <V2P_RunStateMachine+0x2d4>
    20c8:	0e 94 35 0e 	call	0x1c6a <V2P_GetSetParamater>
    20cc:	11 c0       	rjmp	.+34     	; 0x20f0 <V2P_RunStateMachine+0x2d8>
    20ce:	e0 91 24 01 	lds	r30, 0x0124
    20d2:	f0 91 25 01 	lds	r31, 0x0125
    20d6:	09 95       	icall
    20d8:	0b c0       	rjmp	.+22     	; 0x20f0 <V2P_RunStateMachine+0x2d8>
    20da:	82 e0       	ldi	r24, 0x02	; 2
    20dc:	90 e0       	ldi	r25, 0x00	; 0
    20de:	90 93 31 01 	sts	0x0131, r25
    20e2:	80 93 30 01 	sts	0x0130, r24
    20e6:	81 ec       	ldi	r24, 0xC1	; 193
    20e8:	80 93 35 01 	sts	0x0135, r24
    20ec:	0e 94 f5 0d 	call	0x1bea <V2P_SendPacket>
    20f0:	c8 e0       	ldi	r28, 0x08	; 8
    20f2:	ae ce       	rjmp	.-676    	; 0x1e50 <V2P_RunStateMachine+0x38>
    20f4:	cf 91       	pop	r28
    20f6:	1f 91       	pop	r17
    20f8:	0f 91       	pop	r16
    20fa:	ff 90       	pop	r15
    20fc:	ef 90       	pop	r14
    20fe:	08 95       	ret

00002100 <ISPCC_EnterChipProgrammingMode>:

// ======================================================================================

void ISPCC_EnterChipProgrammingMode(void)
{
    2100:	0f 93       	push	r16
    2102:	1f 93       	push	r17
    2104:	cf 93       	push	r28
	uint8_t ByteDelay = PacketBytes[5];
    2106:	10 91 39 01 	lds	r17, 0x0139
	uint8_t Attempts  = PacketBytes[4];
    210a:	c0 91 38 01 	lds	r28, 0x0138
	uint8_t Response;

	MAIN_Delay1MS(PacketBytes[2]);         // Wait before continuing, amount specified in the packet
    210e:	80 91 36 01 	lds	r24, 0x0136
    2112:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>

	if ((!(Attempts)) || (Attempts > 100)) // Safety - if no attempts or too high a value is specified, a fixed number is chosen
    2116:	8c 2f       	mov	r24, r28
    2118:	81 50       	subi	r24, 0x01	; 1
    211a:	84 36       	cpi	r24, 0x64	; 100
    211c:	08 f0       	brcs	.+2      	; 0x2120 <ISPCC_EnterChipProgrammingMode+0x20>
	   Attempts = 24;
    211e:	c8 e1       	ldi	r28, 0x18	; 24
		
	while (Attempts--)
	{
		USI_SPITransmit(PacketBytes[8]);
		MAIN_Delay1MS(ByteDelay);
		USI_SPITransmit(PacketBytes[9]);
		MAIN_Delay1MS(ByteDelay);
			
		Response = USI_SPITransmit(PacketBytes[10]);
		MAIN_Delay1MS(ByteDelay);

		if(PacketBytes[7] == ISPCC_POLL_MODE_AVR)
		  USI_SPITransmit(PacketBytes[11]);
		else
		  Response = USI_SPITransmit(PacketBytes[11]);
				
		if(!(PacketBytes[7]) || (Response == PacketBytes[6])) // Polling disabled, or returned value matches expected poll value
		{
			MAIN_Delay1MS(ByteDelay);

			InProgrammingMode = TRUE;
			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = STATUS_CMD_OK;
			return;
		}
		
		MAIN_Delay1MS(ByteDelay);
		USI_SPIToggleClock();            // Out of sync, shift in one bit and try again
    2120:	c1 50       	subi	r28, 0x01	; 1
    2122:	cf 3f       	cpi	r28, 0xFF	; 255
    2124:	09 f4       	brne	.+2      	; 0x2128 <ISPCC_EnterChipProgrammingMode+0x28>
    2126:	3f c0       	rjmp	.+126    	; 0x21a6 <ISPCC_EnterChipProgrammingMode+0xa6>
    2128:	80 91 3c 01 	lds	r24, 0x013C
    212c:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    2130:	81 2f       	mov	r24, r17
    2132:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    2136:	80 91 3d 01 	lds	r24, 0x013D
    213a:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    213e:	81 2f       	mov	r24, r17
    2140:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    2144:	80 91 3e 01 	lds	r24, 0x013E
    2148:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    214c:	08 2f       	mov	r16, r24
    214e:	81 2f       	mov	r24, r17
    2150:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    2154:	80 91 3b 01 	lds	r24, 0x013B
    2158:	83 30       	cpi	r24, 0x03	; 3
    215a:	29 f4       	brne	.+10     	; 0x2166 <ISPCC_EnterChipProgrammingMode+0x66>
    215c:	80 91 3f 01 	lds	r24, 0x013F
    2160:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    2164:	05 c0       	rjmp	.+10     	; 0x2170 <ISPCC_EnterChipProgrammingMode+0x70>
    2166:	80 91 3f 01 	lds	r24, 0x013F
    216a:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    216e:	08 2f       	mov	r16, r24
    2170:	80 91 3b 01 	lds	r24, 0x013B
    2174:	88 23       	and	r24, r24
    2176:	21 f0       	breq	.+8      	; 0x2180 <ISPCC_EnterChipProgrammingMode+0x80>
    2178:	80 91 3a 01 	lds	r24, 0x013A
    217c:	08 17       	cp	r16, r24
    217e:	69 f4       	brne	.+26     	; 0x219a <ISPCC_EnterChipProgrammingMode+0x9a>
    2180:	81 2f       	mov	r24, r17
    2182:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    2186:	81 e0       	ldi	r24, 0x01	; 1
    2188:	80 93 2f 01 	sts	0x012F, r24
    218c:	81 b3       	in	r24, 0x11	; 17
    218e:	8f 7c       	andi	r24, 0xCF	; 207
    2190:	80 62       	ori	r24, 0x20	; 32
    2192:	81 bb       	out	0x11, r24	; 17
    2194:	10 92 35 01 	sts	0x0135, r1
    2198:	0d c0       	rjmp	.+26     	; 0x21b4 <ISPCC_EnterChipProgrammingMode+0xb4>
    219a:	81 2f       	mov	r24, r17
    219c:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    21a0:	0e 94 cd 09 	call	0x139a <USI_SPIToggleClock>
    21a4:	bd cf       	rjmp	.-134    	; 0x2120 <ISPCC_EnterChipProgrammingMode+0x20>
	}

	// If function hasn't returned by now, all the attempts have failed. Show this by
	// resetting the status leds to green (ready) and send a fail message.

	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
    21a6:	81 b3       	in	r24, 0x11	; 17
    21a8:	8f 7c       	andi	r24, 0xCF	; 207
    21aa:	80 61       	ori	r24, 0x10	; 16
    21ac:	81 bb       	out	0x11, r24	; 17
	PacketBytes[1] = STATUS_CMD_FAILED;
    21ae:	80 ec       	ldi	r24, 0xC0	; 192
    21b0:	80 93 35 01 	sts	0x0135, r24
    21b4:	cf 91       	pop	r28
    21b6:	1f 91       	pop	r17
    21b8:	0f 91       	pop	r16
    21ba:	08 95       	ret

000021bc <ISPCC_PollForProgComplete>:
}

void ISPCC_ProgramChip(void)
{
	uint16_t PollAddress  = 0;
	uint8_t  ProgMode     = PacketBytes[3];
	uint8_t  WriteCommand = PacketBytes[5];
	uint16_t StartAddress = (uint16_t)CurrAddress;
	uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
	                      | PacketBytes[2];
	uint8_t  PollType;
	uint8_t  ByteToWrite;
			
	if (ProgMode & ISPCC_PROG_MODE_PAGE)                 // Page writing mode
	{
		for (uint16_t WriteByte = 0; WriteByte < BytesToWrite; WriteByte++) // Transmit the page bytes
		{
			ByteToWrite = PacketBytes[10 + WriteByte];
		
			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) // Flash write mode - word addresses so MSB/LSB masking 
			   USI_SPITransmit(WriteCommand | ((WriteByte & 0x01)? ISPCC_HIGH_BYTE_WRITE : ISPCC_LOW_BYTE_WRITE));
			else                                         // EEPROM write mode - byte addresses so no masking 
			   USI_SPITransmit(WriteCommand);

			USI_SPITransmitWord(CurrAddress & 0xFFFF);    // Only the LSW of the address should be sent
			USI_SPITransmit(ByteToWrite);                 // Send one of the new bytes to be written

			if (!(PollAddress))
			{
				if ((PacketBytes[8] != ByteToWrite)       // Can do polling
				   && ((PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) || ((PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP) && (PacketBytes[9] != ByteToWrite))))
				{
					PollAddress = (CurrAddress & 0xFFFF); // Save the current address
				
					if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
					   PollAddress = ((PollAddress << 1) + (WriteByte & 0x01));
				}
			}

			// Flash addresses are in words; only increment address on odd byte, OR if it's the EEPROM being programmed (byte addresses)
			if ((WriteByte & 0x01) || (PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP))
			   V2P_IncrementCurrAddress();
		}

		PollType = ProgMode;

		if (ProgMode & ISPCC_PROG_MODE_PAGEDONE)         // If this packet is the end of a page, we need to send the program page command
		{
			USI_SPITransmit(PacketBytes[6]);             // Send the write program memory page command
			USI_SPITransmitWord(StartAddress);           // Send the page address word
			USI_SPITransmit(0x00);

			if (!(PollAddress))                          // No polling address
			   PollType = ((ProgMode & ~ISPCC_PAGE_POLLTYPE_MASK) | ISPCC_PAGE_POLLTYPE_WAIT);

			ISPCC_PollForProgComplete(PollType, PollAddress);
		}
	}
	else                                                 // Flash Word writing mode or EEPROM byte writing mode
	{
		for (uint16_t WriteByte = 0; WriteByte < BytesToWrite; WriteByte++)
		{
			ByteToWrite = PacketBytes[10 + WriteByte];

			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
			   USI_SPITransmit(WriteCommand | ((WriteByte & 0x01)? ISPCC_HIGH_BYTE_WRITE : ISPCC_LOW_BYTE_WRITE));
			else
			   USI_SPITransmit(WriteCommand);					
					
			USI_SPITransmitWord(CurrAddress & 0xFFFF);    // Transmit the current address to the slave AVR
			USI_SPITransmit(ByteToWrite);                 // Send one of the new bytes to be written

			PollType = ProgMode;

			if ((PacketBytes[8] != ByteToWrite)           // Can do polling
			   && ((PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) || ((PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP) && (PacketBytes[9] != ByteToWrite))))
			{
				PollAddress = (CurrAddress & 0xFFFF);     // Save the current address;

				if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
				   PollAddress = ((PollAddress << 1) + (WriteByte & 0x01));
			}
			else
			{
				PollType = ((ProgMode & ~ISPCC_WORD_POLLTYPE_MASK) | ISPCC_WORD_POLLTYPE_WAIT);
			}					

			// Flash addresses are in words; only increment address on the odd byte, OR if it's the EEPROM being programmed (byte addresses)
			if ((WriteByte & 0x01) || (PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP))
			   V2P_IncrementCurrAddress();

			ISPCC_PollForProgComplete(PollType, PollAddress);
		}
	}
}

void ISPCC_PollForProgComplete(uint8_t PollData, uint16_t PollAddr)
{
    21bc:	1f 93       	push	r17
    21be:	cf 93       	push	r28
    21c0:	df 93       	push	r29
    21c2:	eb 01       	movw	r28, r22
	uint8_t PollType;
	uint8_t ProgCommand;

	if (PollData & ISPCC_PROG_MODE_PAGE)
    21c4:	99 27       	eor	r25, r25
    21c6:	80 ff       	sbrs	r24, 0
    21c8:	08 c0       	rjmp	.+16     	; 0x21da <ISPCC_PollForProgComplete+0x1e>
	   PollType = ((PollData & ISPCC_PAGE_POLLTYPE_MASK) >> ISPCC_PAGE_POLLTYPE_MASKSHIFT);
    21ca:	80 77       	andi	r24, 0x70	; 112
    21cc:	90 70       	andi	r25, 0x00	; 0
    21ce:	34 e0       	ldi	r19, 0x04	; 4
    21d0:	95 95       	asr	r25
    21d2:	87 95       	ror	r24
    21d4:	3a 95       	dec	r19
    21d6:	e1 f7       	brne	.-8      	; 0x21d0 <ISPCC_PollForProgComplete+0x14>
    21d8:	04 c0       	rjmp	.+8      	; 0x21e2 <ISPCC_PollForProgComplete+0x26>
	else
	   PollType = ((PollData & ISPCC_WORD_POLLTYPE_MASK) >> ISPCC_WORD_POLLTYPE_MASKSHIFT);	
    21da:	8e 70       	andi	r24, 0x0E	; 14
    21dc:	90 70       	andi	r25, 0x00	; 0
    21de:	95 95       	asr	r25
    21e0:	87 95       	ror	r24

	switch (PollType & ISPCC_POLLTYPE_MASK)
    21e2:	99 27       	eor	r25, r25
    21e4:	87 70       	andi	r24, 0x07	; 7
    21e6:	90 70       	andi	r25, 0x00	; 0
    21e8:	82 30       	cpi	r24, 0x02	; 2
    21ea:	91 05       	cpc	r25, r1
    21ec:	19 f0       	breq	.+6      	; 0x21f4 <ISPCC_PollForProgComplete+0x38>
    21ee:	04 97       	sbiw	r24, 0x04	; 4
    21f0:	e1 f0       	breq	.+56     	; 0x222a <ISPCC_PollForProgComplete+0x6e>
    21f2:	26 c0       	rjmp	.+76     	; 0x2240 <ISPCC_PollForProgComplete+0x84>
	{
		case ISPCC_POLLTYPE_DATA:
			ProgCommand = PacketBytes[7];
    21f4:	10 91 3b 01 	lds	r17, 0x013B
			
			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) // Flash uses word addresses
    21f8:	80 91 34 01 	lds	r24, 0x0134
    21fc:	83 31       	cpi	r24, 0x13	; 19
    21fe:	39 f4       	brne	.+14     	; 0x220e <ISPCC_PollForProgComplete+0x52>
			{
				ProgCommand  |= ((PollAddr & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ);
    2200:	81 2f       	mov	r24, r17
    2202:	99 27       	eor	r25, r25
    2204:	c0 fd       	sbrc	r28, 0
    2206:	88 60       	ori	r24, 0x08	; 8
    2208:	18 2f       	mov	r17, r24
				PollAddr    >>= 1;
    220a:	d6 95       	lsr	r29
    220c:	c7 95       	ror	r28
			}

			do
			{
				USI_SPITransmit(ProgCommand);
    220e:	81 2f       	mov	r24, r17
    2210:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
				USI_SPITransmitWord(PollAddr);
    2214:	ce 01       	movw	r24, r28
    2216:	0e 94 bf 09 	call	0x137e <USI_SPITransmitWord>
			}
    221a:	80 e0       	ldi	r24, 0x00	; 0
    221c:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    2220:	90 91 3c 01 	lds	r25, 0x013C
    2224:	89 17       	cp	r24, r25
    2226:	99 f3       	breq	.-26     	; 0x220e <ISPCC_PollForProgComplete+0x52>
			while (USI_SPITransmit(0x00) == PacketBytes[8]);
						
			break;
    2228:	0f c0       	rjmp	.+30     	; 0x2248 <ISPCC_PollForProgComplete+0x8c>
		case ISPCC_POLLTYPE_READY:
			do
			   USI_SPITransmitWord(0xF000);
    222a:	80 e0       	ldi	r24, 0x00	; 0
    222c:	90 ef       	ldi	r25, 0xF0	; 240
    222e:	0e 94 bf 09 	call	0x137e <USI_SPITransmitWord>
    2232:	80 e0       	ldi	r24, 0x00	; 0
    2234:	90 e0       	ldi	r25, 0x00	; 0
    2236:	0e 94 bf 09 	call	0x137e <USI_SPITransmitWord>
    223a:	80 fd       	sbrc	r24, 0
    223c:	f6 cf       	rjmp	.-20     	; 0x222a <ISPCC_PollForProgComplete+0x6e>
			while (USI_SPITransmitWord(0x0000) & ISPCC_POLL_BUSYFLAG);

			break;
    223e:	04 c0       	rjmp	.+8      	; 0x2248 <ISPCC_PollForProgComplete+0x8c>
		default:                                      // Default is Wait polling
			MAIN_Delay1MS(PacketBytes[4]);	
    2240:	80 91 38 01 	lds	r24, 0x0138
    2244:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    2248:	df 91       	pop	r29
    224a:	cf 91       	pop	r28
    224c:	1f 91       	pop	r17
    224e:	08 95       	ret

00002250 <ISPCC_ProgramChip>:
    2250:	6f 92       	push	r6
    2252:	7f 92       	push	r7
    2254:	9f 92       	push	r9
    2256:	af 92       	push	r10
    2258:	bf 92       	push	r11
    225a:	cf 92       	push	r12
    225c:	df 92       	push	r13
    225e:	ef 92       	push	r14
    2260:	ff 92       	push	r15
    2262:	0f 93       	push	r16
    2264:	1f 93       	push	r17
    2266:	cf 93       	push	r28
    2268:	df 93       	push	r29
    226a:	00 e0       	ldi	r16, 0x00	; 0
    226c:	10 e0       	ldi	r17, 0x00	; 0
    226e:	90 90 37 01 	lds	r9, 0x0137
    2272:	c0 90 39 01 	lds	r12, 0x0139
    2276:	60 90 2b 01 	lds	r6, 0x012B
    227a:	70 90 2c 01 	lds	r7, 0x012C
    227e:	80 91 35 01 	lds	r24, 0x0135
    2282:	99 27       	eor	r25, r25
    2284:	b8 2e       	mov	r11, r24
    2286:	aa 24       	eor	r10, r10
    2288:	80 91 36 01 	lds	r24, 0x0136
    228c:	99 27       	eor	r25, r25
    228e:	a8 2a       	or	r10, r24
    2290:	b9 2a       	or	r11, r25
    2292:	90 fe       	sbrs	r9, 0
    2294:	62 c0       	rjmp	.+196    	; 0x235a <ISPCC_ProgramChip+0x10a>
    2296:	78 01       	movw	r14, r16
    2298:	0a 15       	cp	r16, r10
    229a:	1b 05       	cpc	r17, r11
    229c:	08 f0       	brcs	.+2      	; 0x22a0 <ISPCC_ProgramChip+0x50>
    229e:	46 c0       	rjmp	.+140    	; 0x232c <ISPCC_ProgramChip+0xdc>
    22a0:	ce e3       	ldi	r28, 0x3E	; 62
    22a2:	d1 e0       	ldi	r29, 0x01	; 1
    22a4:	d9 90       	ld	r13, Y+
    22a6:	80 91 34 01 	lds	r24, 0x0134
    22aa:	83 31       	cpi	r24, 0x13	; 19
    22ac:	31 f4       	brne	.+12     	; 0x22ba <ISPCC_ProgramChip+0x6a>
    22ae:	8c 2d       	mov	r24, r12
    22b0:	99 27       	eor	r25, r25
    22b2:	e0 fe       	sbrs	r14, 0
    22b4:	03 c0       	rjmp	.+6      	; 0x22bc <ISPCC_ProgramChip+0x6c>
    22b6:	88 60       	ori	r24, 0x08	; 8
    22b8:	01 c0       	rjmp	.+2      	; 0x22bc <ISPCC_ProgramChip+0x6c>
    22ba:	8c 2d       	mov	r24, r12
    22bc:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    22c0:	80 91 2b 01 	lds	r24, 0x012B
    22c4:	90 91 2c 01 	lds	r25, 0x012C
    22c8:	0e 94 bf 09 	call	0x137e <USI_SPITransmitWord>
    22cc:	8d 2d       	mov	r24, r13
    22ce:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    22d2:	01 15       	cp	r16, r1
    22d4:	11 05       	cpc	r17, r1
    22d6:	d9 f4       	brne	.+54     	; 0x230e <ISPCC_ProgramChip+0xbe>
    22d8:	80 91 3c 01 	lds	r24, 0x013C
    22dc:	8d 15       	cp	r24, r13
    22de:	b9 f0       	breq	.+46     	; 0x230e <ISPCC_ProgramChip+0xbe>
    22e0:	90 91 34 01 	lds	r25, 0x0134
    22e4:	93 31       	cpi	r25, 0x13	; 19
    22e6:	31 f0       	breq	.+12     	; 0x22f4 <ISPCC_ProgramChip+0xa4>
    22e8:	95 31       	cpi	r25, 0x15	; 21
    22ea:	89 f4       	brne	.+34     	; 0x230e <ISPCC_ProgramChip+0xbe>
    22ec:	80 91 3d 01 	lds	r24, 0x013D
    22f0:	8d 15       	cp	r24, r13
    22f2:	69 f0       	breq	.+26     	; 0x230e <ISPCC_ProgramChip+0xbe>
    22f4:	00 91 2b 01 	lds	r16, 0x012B
    22f8:	10 91 2c 01 	lds	r17, 0x012C
    22fc:	93 31       	cpi	r25, 0x13	; 19
    22fe:	39 f4       	brne	.+14     	; 0x230e <ISPCC_ProgramChip+0xbe>
    2300:	00 0f       	add	r16, r16
    2302:	11 1f       	adc	r17, r17
    2304:	c7 01       	movw	r24, r14
    2306:	81 70       	andi	r24, 0x01	; 1
    2308:	90 70       	andi	r25, 0x00	; 0
    230a:	08 0f       	add	r16, r24
    230c:	19 1f       	adc	r17, r25
    230e:	e0 fc       	sbrc	r14, 0
    2310:	04 c0       	rjmp	.+8      	; 0x231a <ISPCC_ProgramChip+0xca>
    2312:	80 91 34 01 	lds	r24, 0x0134
    2316:	85 31       	cpi	r24, 0x15	; 21
    2318:	11 f4       	brne	.+4      	; 0x231e <ISPCC_ProgramChip+0xce>
    231a:	0e 94 cf 0e 	call	0x1d9e <V2P_IncrementCurrAddress>
    231e:	08 94       	sec
    2320:	e1 1c       	adc	r14, r1
    2322:	f1 1c       	adc	r15, r1
    2324:	ea 14       	cp	r14, r10
    2326:	fb 04       	cpc	r15, r11
    2328:	08 f4       	brcc	.+2      	; 0x232c <ISPCC_ProgramChip+0xdc>
    232a:	bc cf       	rjmp	.-136    	; 0x22a4 <ISPCC_ProgramChip+0x54>
    232c:	c9 2d       	mov	r28, r9
    232e:	97 fe       	sbrs	r9, 7
    2330:	69 c0       	rjmp	.+210    	; 0x2404 <ISPCC_ProgramChip+0x1b4>
    2332:	80 91 3a 01 	lds	r24, 0x013A
    2336:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    233a:	c3 01       	movw	r24, r6
    233c:	0e 94 bf 09 	call	0x137e <USI_SPITransmitWord>
    2340:	80 e0       	ldi	r24, 0x00	; 0
    2342:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    2346:	01 15       	cp	r16, r1
    2348:	11 05       	cpc	r17, r1
    234a:	11 f4       	brne	.+4      	; 0x2350 <ISPCC_ProgramChip+0x100>
    234c:	cf 78       	andi	r28, 0x8F	; 143
    234e:	c0 61       	ori	r28, 0x10	; 16
    2350:	b8 01       	movw	r22, r16
    2352:	8c 2f       	mov	r24, r28
    2354:	0e 94 de 10 	call	0x21bc <ISPCC_PollForProgComplete>
    2358:	55 c0       	rjmp	.+170    	; 0x2404 <ISPCC_ProgramChip+0x1b4>
    235a:	78 01       	movw	r14, r16
    235c:	0a 15       	cp	r16, r10
    235e:	1b 05       	cpc	r17, r11
    2360:	08 f0       	brcs	.+2      	; 0x2364 <ISPCC_ProgramChip+0x114>
    2362:	50 c0       	rjmp	.+160    	; 0x2404 <ISPCC_ProgramChip+0x1b4>
    2364:	5e e3       	ldi	r21, 0x3E	; 62
    2366:	65 2e       	mov	r6, r21
    2368:	51 e0       	ldi	r21, 0x01	; 1
    236a:	75 2e       	mov	r7, r21
    236c:	f3 01       	movw	r30, r6
    236e:	d1 90       	ld	r13, Z+
    2370:	3f 01       	movw	r6, r30
    2372:	80 91 34 01 	lds	r24, 0x0134
    2376:	83 31       	cpi	r24, 0x13	; 19
    2378:	31 f4       	brne	.+12     	; 0x2386 <ISPCC_ProgramChip+0x136>
    237a:	8c 2d       	mov	r24, r12
    237c:	99 27       	eor	r25, r25
    237e:	e0 fe       	sbrs	r14, 0
    2380:	03 c0       	rjmp	.+6      	; 0x2388 <ISPCC_ProgramChip+0x138>
    2382:	88 60       	ori	r24, 0x08	; 8
    2384:	01 c0       	rjmp	.+2      	; 0x2388 <ISPCC_ProgramChip+0x138>
    2386:	8c 2d       	mov	r24, r12
    2388:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    238c:	80 91 2b 01 	lds	r24, 0x012B
    2390:	90 91 2c 01 	lds	r25, 0x012C
    2394:	0e 94 bf 09 	call	0x137e <USI_SPITransmitWord>
    2398:	8d 2d       	mov	r24, r13
    239a:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    239e:	c9 2d       	mov	r28, r9
    23a0:	80 91 3c 01 	lds	r24, 0x013C
    23a4:	8d 15       	cp	r24, r13
    23a6:	c1 f0       	breq	.+48     	; 0x23d8 <ISPCC_ProgramChip+0x188>
    23a8:	90 91 34 01 	lds	r25, 0x0134
    23ac:	93 31       	cpi	r25, 0x13	; 19
    23ae:	31 f0       	breq	.+12     	; 0x23bc <ISPCC_ProgramChip+0x16c>
    23b0:	95 31       	cpi	r25, 0x15	; 21
    23b2:	91 f4       	brne	.+36     	; 0x23d8 <ISPCC_ProgramChip+0x188>
    23b4:	80 91 3d 01 	lds	r24, 0x013D
    23b8:	8d 15       	cp	r24, r13
    23ba:	71 f0       	breq	.+28     	; 0x23d8 <ISPCC_ProgramChip+0x188>
    23bc:	00 91 2b 01 	lds	r16, 0x012B
    23c0:	10 91 2c 01 	lds	r17, 0x012C
    23c4:	93 31       	cpi	r25, 0x13	; 19
    23c6:	59 f4       	brne	.+22     	; 0x23de <ISPCC_ProgramChip+0x18e>
    23c8:	00 0f       	add	r16, r16
    23ca:	11 1f       	adc	r17, r17
    23cc:	c7 01       	movw	r24, r14
    23ce:	81 70       	andi	r24, 0x01	; 1
    23d0:	90 70       	andi	r25, 0x00	; 0
    23d2:	08 0f       	add	r16, r24
    23d4:	19 1f       	adc	r17, r25
    23d6:	03 c0       	rjmp	.+6      	; 0x23de <ISPCC_ProgramChip+0x18e>
    23d8:	c9 2d       	mov	r28, r9
    23da:	c1 7f       	andi	r28, 0xF1	; 241
    23dc:	c2 60       	ori	r28, 0x02	; 2
    23de:	e0 fc       	sbrc	r14, 0
    23e0:	04 c0       	rjmp	.+8      	; 0x23ea <ISPCC_ProgramChip+0x19a>
    23e2:	80 91 34 01 	lds	r24, 0x0134
    23e6:	85 31       	cpi	r24, 0x15	; 21
    23e8:	11 f4       	brne	.+4      	; 0x23ee <ISPCC_ProgramChip+0x19e>
    23ea:	0e 94 cf 0e 	call	0x1d9e <V2P_IncrementCurrAddress>
    23ee:	b8 01       	movw	r22, r16
    23f0:	8c 2f       	mov	r24, r28
    23f2:	0e 94 de 10 	call	0x21bc <ISPCC_PollForProgComplete>
    23f6:	08 94       	sec
    23f8:	e1 1c       	adc	r14, r1
    23fa:	f1 1c       	adc	r15, r1
    23fc:	ea 14       	cp	r14, r10
    23fe:	fb 04       	cpc	r15, r11
    2400:	08 f4       	brcc	.+2      	; 0x2404 <ISPCC_ProgramChip+0x1b4>
    2402:	b4 cf       	rjmp	.-152    	; 0x236c <ISPCC_ProgramChip+0x11c>
    2404:	df 91       	pop	r29
    2406:	cf 91       	pop	r28
    2408:	1f 91       	pop	r17
    240a:	0f 91       	pop	r16
    240c:	ff 90       	pop	r15
    240e:	ef 90       	pop	r14
    2410:	df 90       	pop	r13
    2412:	cf 90       	pop	r12
    2414:	bf 90       	pop	r11
    2416:	af 90       	pop	r10
    2418:	9f 90       	pop	r9
    241a:	7f 90       	pop	r7
    241c:	6f 90       	pop	r6
    241e:	08 95       	ret

00002420 <AICI_InterpretPacket>:

// ======================================================================================

void AICI_InterpretPacket(void)
{
    2420:	df 92       	push	r13
    2422:	ef 92       	push	r14
    2424:	ff 92       	push	r15
    2426:	0f 93       	push	r16
    2428:	1f 93       	push	r17
    242a:	cf 93       	push	r28
    242c:	df 93       	push	r29
	switch (PacketBytes[0])
    242e:	80 91 34 01 	lds	r24, 0x0134
    2432:	99 27       	eor	r25, r25
    2434:	86 31       	cpi	r24, 0x16	; 22
    2436:	91 05       	cpc	r25, r1
    2438:	09 f4       	brne	.+2      	; 0x243c <AICI_InterpretPacket+0x1c>
    243a:	fa c0       	rjmp	.+500    	; 0x2630 <AICI_InterpretPacket+0x210>
    243c:	87 31       	cpi	r24, 0x17	; 23
    243e:	91 05       	cpc	r25, r1
    2440:	94 f4       	brge	.+36     	; 0x2466 <AICI_InterpretPacket+0x46>
    2442:	82 31       	cpi	r24, 0x12	; 18
    2444:	91 05       	cpc	r25, r1
    2446:	09 f4       	brne	.+2      	; 0x244a <AICI_InterpretPacket+0x2a>
    2448:	5f c0       	rjmp	.+190    	; 0x2508 <AICI_InterpretPacket+0xe8>
    244a:	83 31       	cpi	r24, 0x13	; 19
    244c:	91 05       	cpc	r25, r1
    244e:	3c f4       	brge	.+14     	; 0x245e <AICI_InterpretPacket+0x3e>
    2450:	80 31       	cpi	r24, 0x10	; 16
    2452:	91 05       	cpc	r25, r1
    2454:	f9 f0       	breq	.+62     	; 0x2494 <AICI_InterpretPacket+0x74>
    2456:	41 97       	sbiw	r24, 0x11	; 17
    2458:	09 f4       	brne	.+2      	; 0x245c <AICI_InterpretPacket+0x3c>
    245a:	3c c0       	rjmp	.+120    	; 0x24d4 <AICI_InterpretPacket+0xb4>
    245c:	3d c1       	rjmp	.+634    	; 0x26d8 <AICI_InterpretPacket+0x2b8>
    245e:	44 97       	sbiw	r24, 0x14	; 20
    2460:	09 f4       	brne	.+2      	; 0x2464 <AICI_InterpretPacket+0x44>
    2462:	e6 c0       	rjmp	.+460    	; 0x2630 <AICI_InterpretPacket+0x210>
    2464:	2e c1       	rjmp	.+604    	; 0x26c2 <AICI_InterpretPacket+0x2a2>
    2466:	89 31       	cpi	r24, 0x19	; 25
    2468:	91 05       	cpc	r25, r1
    246a:	09 f4       	brne	.+2      	; 0x246e <AICI_InterpretPacket+0x4e>
    246c:	cb c0       	rjmp	.+406    	; 0x2604 <AICI_InterpretPacket+0x1e4>
    246e:	8a 31       	cpi	r24, 0x1A	; 26
    2470:	91 05       	cpc	r25, r1
    2472:	44 f4       	brge	.+16     	; 0x2484 <AICI_InterpretPacket+0x64>
    2474:	87 31       	cpi	r24, 0x17	; 23
    2476:	91 05       	cpc	r25, r1
    2478:	09 f4       	brne	.+2      	; 0x247c <AICI_InterpretPacket+0x5c>
    247a:	c4 c0       	rjmp	.+392    	; 0x2604 <AICI_InterpretPacket+0x1e4>
    247c:	48 97       	sbiw	r24, 0x18	; 24
    247e:	09 f4       	brne	.+2      	; 0x2482 <AICI_InterpretPacket+0x62>
    2480:	a4 c0       	rjmp	.+328    	; 0x25ca <AICI_InterpretPacket+0x1aa>
    2482:	2a c1       	rjmp	.+596    	; 0x26d8 <AICI_InterpretPacket+0x2b8>
    2484:	8d 31       	cpi	r24, 0x1D	; 29
    2486:	91 05       	cpc	r25, r1
    2488:	0c f4       	brge	.+2      	; 0x248c <AICI_InterpretPacket+0x6c>
    248a:	9f c0       	rjmp	.+318    	; 0x25ca <AICI_InterpretPacket+0x1aa>
    248c:	4d 97       	sbiw	r24, 0x1d	; 29
    248e:	09 f4       	brne	.+2      	; 0x2492 <AICI_InterpretPacket+0x72>
    2490:	60 c0       	rjmp	.+192    	; 0x2552 <AICI_InterpretPacket+0x132>
    2492:	22 c1       	rjmp	.+580    	; 0x26d8 <AICI_InterpretPacket+0x2b8>
	{
		case CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
    2494:	82 e0       	ldi	r24, 0x02	; 2
    2496:	90 e0       	ldi	r25, 0x00	; 0
    2498:	90 93 31 01 	sts	0x0131, r25
    249c:	80 93 30 01 	sts	0x0130, r24
			
			USI_SPIInitMaster(eeprom_read_byte_169(&Param_SCKDuration));
    24a0:	80 e2       	ldi	r24, 0x20	; 32
    24a2:	91 e0       	ldi	r25, 0x01	; 1
    24a4:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
    24a8:	0e 94 92 09 	call	0x1324 <USI_SPIInitMaster>

			MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);  // Pull the slave AVR's RESET line to active
    24ac:	80 e0       	ldi	r24, 0x00	; 0
    24ae:	0e 94 1b 03 	call	0x636 <MAIN_ResetCSLine>
			MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE); // Orange = Busy
    24b2:	81 b3       	in	r24, 0x11	; 17
    24b4:	80 63       	ori	r24, 0x30	; 48
    24b6:	81 bb       	out	0x11, r24	; 17
			ISPCC_EnterChipProgrammingMode();       // Run the Enter Programming Mode routine
    24b8:	0e 94 80 10 	call	0x2100 <ISPCC_EnterChipProgrammingMode>

			if (InProgrammingMode)
    24bc:	80 91 2f 01 	lds	r24, 0x012F
    24c0:	88 23       	and	r24, r24
    24c2:	19 f0       	breq	.+6      	; 0x24ca <AICI_InterpretPacket+0xaa>
			   LCD_puts_f(AVRISPModeMessage);
    24c4:	83 ef       	ldi	r24, 0xF3	; 243
    24c6:	93 e0       	ldi	r25, 0x03	; 3
    24c8:	02 c0       	rjmp	.+4      	; 0x24ce <AICI_InterpretPacket+0xae>
			else
			   LCD_puts_f(SyncErrorMessage);
    24ca:	88 ee       	ldi	r24, 0xE8	; 232
    24cc:	93 e0       	ldi	r25, 0x03	; 3
    24ce:	0e 94 04 08 	call	0x1008 <LCD_puts_f>
			
			break;
    24d2:	0b c1       	rjmp	.+534    	; 0x26ea <AICI_InterpretPacket+0x2ca>
		case CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;
    24d4:	82 e0       	ldi	r24, 0x02	; 2
    24d6:	90 e0       	ldi	r25, 0x00	; 0
    24d8:	90 93 31 01 	sts	0x0131, r25
    24dc:	80 93 30 01 	sts	0x0130, r24

			MAIN_Delay1MS(PacketBytes[1]);           // Wait for the "PreDelay" amount specified in the packet
    24e0:	80 91 35 01 	lds	r24, 0x0135
    24e4:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Non programming mode = green status led
    24e8:	81 b3       	in	r24, 0x11	; 17
    24ea:	8f 7c       	andi	r24, 0xCF	; 207
    24ec:	80 61       	ori	r24, 0x10	; 16
    24ee:	81 bb       	out	0x11, r24	; 17
			InProgrammingMode = FALSE;
    24f0:	10 92 2f 01 	sts	0x012F, r1
			MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run
    24f4:	81 e0       	ldi	r24, 0x01	; 1
    24f6:	0e 94 1b 03 	call	0x636 <MAIN_ResetCSLine>
			MAIN_Delay1MS(PacketBytes[2]);           // Wait for the "PostDelay" amount specified in the packet
    24fa:	80 91 36 01 	lds	r24, 0x0136
    24fe:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
			
			USI_SPIOff();
    2502:	0e 94 a2 09 	call	0x1344 <USI_SPIOff>
    2506:	e5 c0       	rjmp	.+458    	; 0x26d2 <AICI_InterpretPacket+0x2b2>

			PacketBytes[1] = STATUS_CMD_OK;      // Return OK

			break;
		case CMD_CHIP_ERASE_ISP:
			MessageSize = 2;
    2508:	82 e0       	ldi	r24, 0x02	; 2
    250a:	90 e0       	ldi	r25, 0x00	; 0
    250c:	90 93 31 01 	sts	0x0131, r25
    2510:	80 93 30 01 	sts	0x0130, r24
			
			for (uint8_t PacketB = 3; PacketB <= 6; PacketB++) // Send the erase commands to the slave AVR
    2514:	c3 e0       	ldi	r28, 0x03	; 3
    2516:	07 e3       	ldi	r16, 0x37	; 55
    2518:	11 e0       	ldi	r17, 0x01	; 1
				USI_SPITransmit(PacketBytes[PacketB]);
    251a:	f8 01       	movw	r30, r16
    251c:	81 91       	ld	r24, Z+
    251e:	8f 01       	movw	r16, r30
    2520:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    2524:	c1 50       	subi	r28, 0x01	; 1
    2526:	c7 ff       	sbrs	r28, 7
    2528:	f8 cf       	rjmp	.-16     	; 0x251a <AICI_InterpretPacket+0xfa>

			if (PacketBytes[2])                  // Poll mode, value of 1 indicates a busy flag wait
    252a:	80 91 36 01 	lds	r24, 0x0136
    252e:	88 23       	and	r24, r24
    2530:	59 f0       	breq	.+22     	; 0x2548 <AICI_InterpretPacket+0x128>
			{
				do
					USI_SPITransmitWord(0xF000);
    2532:	80 e0       	ldi	r24, 0x00	; 0
    2534:	90 ef       	ldi	r25, 0xF0	; 240
    2536:	0e 94 bf 09 	call	0x137e <USI_SPITransmitWord>
    253a:	80 e0       	ldi	r24, 0x00	; 0
    253c:	90 e0       	ldi	r25, 0x00	; 0
    253e:	0e 94 bf 09 	call	0x137e <USI_SPITransmitWord>
    2542:	80 fd       	sbrc	r24, 0
    2544:	f6 cf       	rjmp	.-20     	; 0x2532 <AICI_InterpretPacket+0x112>
    2546:	c5 c0       	rjmp	.+394    	; 0x26d2 <AICI_InterpretPacket+0x2b2>
				while (USI_SPITransmitWord(0x0000) & 0x01);
			}
			else                                // Poll mode flag of 0 indicates a predefined delay
			{
				MAIN_Delay1MS(PacketBytes[1]);   // Wait the specified interval to ensure erase complete
    2548:	80 91 35 01 	lds	r24, 0x0135
    254c:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    2550:	c0 c0       	rjmp	.+384    	; 0x26d2 <AICI_InterpretPacket+0x2b2>
			}
			
			PacketBytes[1] = STATUS_CMD_OK;      // Always return OK
			
			break;
		case CMD_SPI_MULTI:
				MessageSize = (3 + PacketBytes[2]);    // Number of recieved bytes, plus two OKs and the command byte
    2552:	e0 90 36 01 	lds	r14, 0x0136
    2556:	8e 2d       	mov	r24, r14
    2558:	99 27       	eor	r25, r25
    255a:	03 96       	adiw	r24, 0x03	; 3
    255c:	90 93 31 01 	sts	0x0131, r25
    2560:	80 93 30 01 	sts	0x0130, r24
		
				uint8_t TxBytes      = PacketBytes[1]; // \. The packet data is overwritten during the transfer. Because
    2564:	00 91 35 01 	lds	r16, 0x0135
				uint8_t RxStartByte  = PacketBytes[2]; // |  of this each data byte must be stored into temp variables
				uint8_t RxBytes      = PacketBytes[3]; // /  so that their contents are not lost.
    2568:	f0 90 37 01 	lds	r15, 0x0137
				uint8_t RxByteNum    = 1;
    256c:	c1 e0       	ldi	r28, 0x01	; 1
				uint8_t TxByteNum    = 1;
				uint8_t RecievedByte = 0;

				while (TxByteNum++ < TxBytes)          // Still bytes to transfer
				{
					RecievedByte = USI_SPITransmit(PacketBytes[3 + TxByteNum]); // Transmit the byte, store the answer

					if ((TxByteNum >= RxStartByte) && (RxByteNum < RxBytes))
					   PacketBytes[2 + RxByteNum++] = RecievedByte;
    256e:	12 e0       	ldi	r17, 0x02	; 2
    2570:	c0 17       	cp	r28, r16
    2572:	a8 f4       	brcc	.+42     	; 0x259e <AICI_InterpretPacket+0x17e>
    2574:	e1 2f       	mov	r30, r17
    2576:	ff 27       	eor	r31, r31
    2578:	ec 5c       	subi	r30, 0xCC	; 204
    257a:	fe 4f       	sbci	r31, 0xFE	; 254
    257c:	83 81       	ldd	r24, Z+3	; 0x03
    257e:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    2582:	1e 15       	cp	r17, r14
    2584:	40 f0       	brcs	.+16     	; 0x2596 <AICI_InterpretPacket+0x176>
    2586:	cf 15       	cp	r28, r15
    2588:	30 f4       	brcc	.+12     	; 0x2596 <AICI_InterpretPacket+0x176>
    258a:	ec 2f       	mov	r30, r28
    258c:	ff 27       	eor	r31, r31
    258e:	ec 5c       	subi	r30, 0xCC	; 204
    2590:	fe 4f       	sbci	r31, 0xFE	; 254
    2592:	82 83       	std	Z+2, r24	; 0x02
    2594:	cf 5f       	subi	r28, 0xFF	; 255
    2596:	81 2f       	mov	r24, r17
    2598:	1f 5f       	subi	r17, 0xFF	; 255
    259a:	80 17       	cp	r24, r16
    259c:	58 f3       	brcs	.-42     	; 0x2574 <AICI_InterpretPacket+0x154>
				}

				while (RxByteNum++ < RxBytes)                         // Still more bytes to recieve
				   PacketBytes[2 + RxByteNum] = USI_SPITransmit(0x00); // its answer to be recorded (or more bytes than sent need responses), send dummy bytes to fetch the response(s)
    259e:	8c 2f       	mov	r24, r28
    25a0:	cf 5f       	subi	r28, 0xFF	; 255
    25a2:	8f 15       	cp	r24, r15
    25a4:	50 f4       	brcc	.+20     	; 0x25ba <AICI_InterpretPacket+0x19a>
    25a6:	0c 2f       	mov	r16, r28
    25a8:	11 27       	eor	r17, r17
    25aa:	0c 5c       	subi	r16, 0xCC	; 204
    25ac:	1e 4f       	sbci	r17, 0xFE	; 254
    25ae:	80 e0       	ldi	r24, 0x00	; 0
    25b0:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    25b4:	f8 01       	movw	r30, r16
    25b6:	82 83       	std	Z+2, r24	; 0x02
    25b8:	f2 cf       	rjmp	.-28     	; 0x259e <AICI_InterpretPacket+0x17e>

				PacketBytes[1]             = STATUS_CMD_OK; // Data should be encompassed
    25ba:	10 92 35 01 	sts	0x0135, r1
				PacketBytes[3 + RxByteNum] = STATUS_CMD_OK; //  by STATS_CMD_OKs
    25be:	ec 2f       	mov	r30, r28
    25c0:	ff 27       	eor	r31, r31
    25c2:	ec 5c       	subi	r30, 0xCC	; 204
    25c4:	fe 4f       	sbci	r31, 0xFE	; 254
    25c6:	13 82       	std	Z+3, r1	; 0x03

				break;
    25c8:	90 c0       	rjmp	.+288    	; 0x26ea <AICI_InterpretPacket+0x2ca>
		case CMD_READ_SIGNATURE_ISP:
		case CMD_READ_FUSE_ISP:
		case CMD_READ_LOCK_ISP:
		case CMD_READ_OSCCAL_ISP:
			MessageSize = 4;
    25ca:	84 e0       	ldi	r24, 0x04	; 4
    25cc:	90 e0       	ldi	r25, 0x00	; 0
    25ce:	90 93 31 01 	sts	0x0131, r25
    25d2:	80 93 30 01 	sts	0x0130, r24
	
			for(uint8_t ByteNum = 1; ByteNum <= 4; ByteNum++)
    25d6:	c1 e0       	ldi	r28, 0x01	; 1
    25d8:	06 e3       	ldi	r16, 0x36	; 54
    25da:	11 e0       	ldi	r17, 0x01	; 1
			{
				uint8_t Response = USI_SPITransmit(PacketBytes[1 + ByteNum]); // Transmit the four signature request bytes
    25dc:	f8 01       	movw	r30, r16
    25de:	81 91       	ld	r24, Z+
    25e0:	8f 01       	movw	r16, r30
    25e2:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    25e6:	98 2f       	mov	r25, r24

				if (ByteNum == PacketBytes[1])         // If the current byte is the requested signature byte, save the reponse in the packet
    25e8:	80 91 35 01 	lds	r24, 0x0135
    25ec:	c8 17       	cp	r28, r24
    25ee:	11 f4       	brne	.+4      	; 0x25f4 <AICI_InterpretPacket+0x1d4>
					PacketBytes[2] = Response;
    25f0:	90 93 36 01 	sts	0x0136, r25
    25f4:	cf 5f       	subi	r28, 0xFF	; 255
    25f6:	c5 30       	cpi	r28, 0x05	; 5
    25f8:	88 f3       	brcs	.-30     	; 0x25dc <AICI_InterpretPacket+0x1bc>
			}

			PacketBytes[1] = STATUS_CMD_OK;            // Data byte is encased in CMD_OKs
    25fa:	10 92 35 01 	sts	0x0135, r1
			PacketBytes[3] = STATUS_CMD_OK;            // Data byte is encased in CMD_OKs
    25fe:	10 92 37 01 	sts	0x0137, r1

			break;
    2602:	73 c0       	rjmp	.+230    	; 0x26ea <AICI_InterpretPacket+0x2ca>
		case CMD_PROGRAM_FUSE_ISP:
		case CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;
    2604:	83 e0       	ldi	r24, 0x03	; 3
    2606:	90 e0       	ldi	r25, 0x00	; 0
    2608:	90 93 31 01 	sts	0x0131, r25
    260c:	80 93 30 01 	sts	0x0130, r24
    2610:	05 e3       	ldi	r16, 0x35	; 53
    2612:	11 e0       	ldi	r17, 0x01	; 1
    2614:	c3 e0       	ldi	r28, 0x03	; 3
			
			for (uint8_t PacketB = 1; PacketB <= 4; PacketB++) // Send the lock-byte values to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    2616:	f8 01       	movw	r30, r16
    2618:	81 91       	ld	r24, Z+
    261a:	8f 01       	movw	r16, r30
    261c:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    2620:	c1 50       	subi	r28, 0x01	; 1
    2622:	c7 ff       	sbrs	r28, 7
    2624:	f8 cf       	rjmp	.-16     	; 0x2616 <AICI_InterpretPacket+0x1f6>

			PacketBytes[1] = STATUS_CMD_OK;            // Two CMD_OKs are always returned
    2626:	10 92 35 01 	sts	0x0135, r1
			PacketBytes[2] = STATUS_CMD_OK;            // Two CMD_OKs are always returned
    262a:	10 92 36 01 	sts	0x0136, r1

			break;
    262e:	5d c0       	rjmp	.+186    	; 0x26ea <AICI_InterpretPacket+0x2ca>
		case CMD_READ_FLASH_ISP:
		case CMD_READ_EEPROM_ISP:
			MessageSize = 0;                           // Here to prevent compiler from complaining if a var dec appears straight after a case

			uint8_t  ReadCommand = PacketBytes[3];
    2630:	d0 90 37 01 	lds	r13, 0x0137
			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8) // Load in the number of bytes that is to
    2634:	80 91 35 01 	lds	r24, 0x0135
    2638:	99 27       	eor	r25, r25
    263a:	d8 2f       	mov	r29, r24
    263c:	cc 27       	eor	r28, r28
    263e:	80 91 36 01 	lds	r24, 0x0136
    2642:	99 27       	eor	r25, r25
    2644:	c8 2b       	or	r28, r24
    2646:	d9 2b       	or	r29, r25
			                     | PacketBytes[2];                 // be read into a temp variable (MSB first)

			MessageSize = BytesToRead + 3;
    2648:	23 96       	adiw	r28, 0x03	; 3
    264a:	d0 93 31 01 	sts	0x0131, r29
    264e:	c0 93 30 01 	sts	0x0130, r28
    2652:	23 97       	sbiw	r28, 0x03	; 3

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
    2654:	00 e0       	ldi	r16, 0x00	; 0
    2656:	10 e0       	ldi	r17, 0x00	; 0
    2658:	0c 17       	cp	r16, r28
    265a:	1d 07       	cpc	r17, r29
    265c:	60 f5       	brcc	.+88     	; 0x26b6 <AICI_InterpretPacket+0x296>
    265e:	86 e3       	ldi	r24, 0x36	; 54
    2660:	e8 2e       	mov	r14, r24
    2662:	81 e0       	ldi	r24, 0x01	; 1
    2664:	f8 2e       	mov	r15, r24
			{
				if (PacketBytes[0] == CMD_READ_FLASH_ISP)  // Flash read mode - word addresses so MSB/LSB masking nessesary
    2666:	80 91 34 01 	lds	r24, 0x0134
    266a:	84 31       	cpi	r24, 0x14	; 20
    266c:	31 f4       	brne	.+12     	; 0x267a <AICI_InterpretPacket+0x25a>
				{
					USI_SPITransmit(ReadCommand | ((ReadByte & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ));
    266e:	8d 2d       	mov	r24, r13
    2670:	99 27       	eor	r25, r25
    2672:	00 ff       	sbrs	r16, 0
    2674:	03 c0       	rjmp	.+6      	; 0x267c <AICI_InterpretPacket+0x25c>
    2676:	88 60       	ori	r24, 0x08	; 8
    2678:	01 c0       	rjmp	.+2      	; 0x267c <AICI_InterpretPacket+0x25c>
				}
				else                                       // EEPROM read mode, address is in bytes and so no masking nessesary
				{
					USI_SPITransmit(ReadCommand);
    267a:	8d 2d       	mov	r24, r13
    267c:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
				}
				
				USI_SPITransmitWord(CurrAddress);          // Transmit the current address to the slave AVR
    2680:	80 91 2b 01 	lds	r24, 0x012B
    2684:	90 91 2c 01 	lds	r25, 0x012C
    2688:	0e 94 bf 09 	call	0x137e <USI_SPITransmitWord>

				PacketBytes[2 + ReadByte] = USI_SPITransmit(0x00); // Read in the byte stored at the requested location
    268c:	80 e0       	ldi	r24, 0x00	; 0
    268e:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    2692:	f7 01       	movw	r30, r14
    2694:	80 83       	st	Z, r24

				if ((ReadByte & 0x01) || (PacketBytes[0] == CMD_READ_EEPROM_ISP)) // Flash addresses are given in words; only increment on the odd byte if reading the flash.
    2696:	00 fd       	sbrc	r16, 0
    2698:	04 c0       	rjmp	.+8      	; 0x26a2 <AICI_InterpretPacket+0x282>
    269a:	80 91 34 01 	lds	r24, 0x0134
    269e:	86 31       	cpi	r24, 0x16	; 22
    26a0:	11 f4       	brne	.+4      	; 0x26a6 <AICI_InterpretPacket+0x286>
				{
					V2P_IncrementCurrAddress();             // Increment the address counter
    26a2:	0e 94 cf 0e 	call	0x1d9e <V2P_IncrementCurrAddress>
    26a6:	0f 5f       	subi	r16, 0xFF	; 255
    26a8:	1f 4f       	sbci	r17, 0xFF	; 255
    26aa:	08 94       	sec
    26ac:	e1 1c       	adc	r14, r1
    26ae:	f1 1c       	adc	r15, r1
    26b0:	0c 17       	cp	r16, r28
    26b2:	1d 07       	cpc	r17, r29
    26b4:	c0 f2       	brcs	.-80     	; 0x2666 <AICI_InterpretPacket+0x246>
				}
				else
				{
					if ((CurrAddress & 0x00FF0000) & !(CurrAddress & 0x0000FFFF))
					{
						CurrAddress |= (1UL << 31);        // Set MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
						V2P_CheckForExtendedAddress();
					}
				}
			}
			
			PacketBytes[1]               = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    26b6:	10 92 35 01 	sts	0x0135, r1
			PacketBytes[2 + BytesToRead] = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    26ba:	cc 5c       	subi	r28, 0xCC	; 204
    26bc:	de 4f       	sbci	r29, 0xFE	; 254
    26be:	1a 82       	std	Y+2, r1	; 0x02

			break;
    26c0:	14 c0       	rjmp	.+40     	; 0x26ea <AICI_InterpretPacket+0x2ca>
		case CMD_PROGRAM_FLASH_ISP:
		case CMD_PROGRAM_EEPROM_ISP:
			ISPCC_ProgramChip();                          // Program the bytes into the chip
    26c2:	0e 94 28 11 	call	0x2250 <ISPCC_ProgramChip>
			
			MessageSize = 2;
    26c6:	82 e0       	ldi	r24, 0x02	; 2
    26c8:	90 e0       	ldi	r25, 0x00	; 0
    26ca:	90 93 31 01 	sts	0x0131, r25
    26ce:	80 93 30 01 	sts	0x0130, r24

			PacketBytes[1] = STATUS_CMD_OK;
    26d2:	10 92 35 01 	sts	0x0135, r1
			
			break;
    26d6:	09 c0       	rjmp	.+18     	; 0x26ea <AICI_InterpretPacket+0x2ca>
		default:                                        // Unknown command, return error
			MessageSize = 1;
    26d8:	81 e0       	ldi	r24, 0x01	; 1
    26da:	90 e0       	ldi	r25, 0x00	; 0
    26dc:	90 93 31 01 	sts	0x0131, r25
    26e0:	80 93 30 01 	sts	0x0130, r24
			
			PacketBytes[1] = STATUS_CMD_UNKNOWN;
    26e4:	89 ec       	ldi	r24, 0xC9	; 201
    26e6:	80 93 35 01 	sts	0x0135, r24
	}

	V2P_SendPacket();                                   // Send the response packet
    26ea:	0e 94 f5 0d 	call	0x1bea <V2P_SendPacket>
    26ee:	df 91       	pop	r29
    26f0:	cf 91       	pop	r28
    26f2:	1f 91       	pop	r17
    26f4:	0f 91       	pop	r16
    26f6:	ff 90       	pop	r15
    26f8:	ef 90       	pop	r14
    26fa:	df 90       	pop	r13
    26fc:	08 95       	ret

000026fe <PM_GetStoredDataSize>:

// ======================================================================================

uint32_t PM_GetStoredDataSize(uint8_t Type)
{
    26fe:	ef 92       	push	r14
    2700:	ff 92       	push	r15
    2702:	0f 93       	push	r16
    2704:	1f 93       	push	r17
    2706:	cf 93       	push	r28
    2708:	df 93       	push	r29
    270a:	cd b7       	in	r28, 0x3d	; 61
    270c:	de b7       	in	r29, 0x3e	; 62
    270e:	22 97       	sbiw	r28, 0x02	; 2
    2710:	0f b6       	in	r0, 0x3f	; 63
    2712:	f8 94       	cli
    2714:	de bf       	out	0x3e, r29	; 62
    2716:	0f be       	out	0x3f, r0	; 63
    2718:	cd bf       	out	0x3d, r28	; 61
	/* This take a **LOT** of code (202 bytes), and is accessed several times throughout
	   the program, so I've put it into a seperate function to save on flash.            */

	uint32_t ProgDataSize = 0;
	uint16_t EEPROMAddress;

	EEPROMAddress = ((Type == TYPE_FLASH)? Prog_DataSize : Prog_EEPROMSize);
    271a:	81 30       	cpi	r24, 0x01	; 1
    271c:	29 f4       	brne	.+10     	; 0x2728 <PM_GetStoredDataSize+0x2a>
    271e:	80 91 16 01 	lds	r24, 0x0116
    2722:	90 91 17 01 	lds	r25, 0x0117
    2726:	04 c0       	rjmp	.+8      	; 0x2730 <PM_GetStoredDataSize+0x32>
    2728:	80 91 14 01 	lds	r24, 0x0114
    272c:	90 91 15 01 	lds	r25, 0x0115
    2730:	9a 83       	std	Y+2, r25	; 0x02
    2732:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize  = ((uint32_t)eeprom_read_byte_169(&EEPROMAddress) << 24);
    2734:	ce 01       	movw	r24, r28
    2736:	01 96       	adiw	r24, 0x01	; 1
    2738:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
    273c:	99 27       	eor	r25, r25
    273e:	aa 27       	eor	r26, r26
    2740:	bb 27       	eor	r27, r27
    2742:	18 2f       	mov	r17, r24
    2744:	00 27       	eor	r16, r16
    2746:	ff 24       	eor	r15, r15
    2748:	ee 24       	eor	r14, r14
	EEPROMAddress++;
    274a:	89 81       	ldd	r24, Y+1	; 0x01
    274c:	9a 81       	ldd	r25, Y+2	; 0x02
    274e:	01 96       	adiw	r24, 0x01	; 1
    2750:	9a 83       	std	Y+2, r25	; 0x02
    2752:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize |= ((uint32_t)eeprom_read_byte_169(&EEPROMAddress) << 16);
    2754:	ce 01       	movw	r24, r28
    2756:	01 96       	adiw	r24, 0x01	; 1
    2758:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
    275c:	99 27       	eor	r25, r25
    275e:	aa 27       	eor	r26, r26
    2760:	bb 27       	eor	r27, r27
    2762:	dc 01       	movw	r26, r24
    2764:	99 27       	eor	r25, r25
    2766:	88 27       	eor	r24, r24
    2768:	e8 2a       	or	r14, r24
    276a:	f9 2a       	or	r15, r25
    276c:	0a 2b       	or	r16, r26
    276e:	1b 2b       	or	r17, r27
	EEPROMAddress++;
    2770:	89 81       	ldd	r24, Y+1	; 0x01
    2772:	9a 81       	ldd	r25, Y+2	; 0x02
    2774:	01 96       	adiw	r24, 0x01	; 1
    2776:	9a 83       	std	Y+2, r25	; 0x02
    2778:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize |= ((uint32_t)eeprom_read_byte_169(&EEPROMAddress) << 8);
    277a:	ce 01       	movw	r24, r28
    277c:	01 96       	adiw	r24, 0x01	; 1
    277e:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
    2782:	99 27       	eor	r25, r25
    2784:	aa 27       	eor	r26, r26
    2786:	bb 27       	eor	r27, r27
    2788:	ba 2f       	mov	r27, r26
    278a:	a9 2f       	mov	r26, r25
    278c:	98 2f       	mov	r25, r24
    278e:	88 27       	eor	r24, r24
    2790:	e8 2a       	or	r14, r24
    2792:	f9 2a       	or	r15, r25
    2794:	0a 2b       	or	r16, r26
    2796:	1b 2b       	or	r17, r27
	EEPROMAddress++;
    2798:	89 81       	ldd	r24, Y+1	; 0x01
    279a:	9a 81       	ldd	r25, Y+2	; 0x02
    279c:	01 96       	adiw	r24, 0x01	; 1
    279e:	9a 83       	std	Y+2, r25	; 0x02
    27a0:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize |= eeprom_read_byte_169(&EEPROMAddress);
    27a2:	ce 01       	movw	r24, r28
    27a4:	01 96       	adiw	r24, 0x01	; 1
    27a6:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
    27aa:	99 27       	eor	r25, r25
    27ac:	aa 27       	eor	r26, r26
    27ae:	bb 27       	eor	r27, r27
    27b0:	e8 2a       	or	r14, r24
    27b2:	f9 2a       	or	r15, r25
    27b4:	0a 2b       	or	r16, r26
    27b6:	1b 2b       	or	r17, r27

	if (ProgDataSize == 0xFFFFFFFF)                                      // Blank EEPROM, return a size  of 0 bytes
    27b8:	8f ef       	ldi	r24, 0xFF	; 255
    27ba:	e8 16       	cp	r14, r24
    27bc:	8f ef       	ldi	r24, 0xFF	; 255
    27be:	f8 06       	cpc	r15, r24
    27c0:	8f ef       	ldi	r24, 0xFF	; 255
    27c2:	08 07       	cpc	r16, r24
    27c4:	8f ef       	ldi	r24, 0xFF	; 255
    27c6:	18 07       	cpc	r17, r24
    27c8:	19 f4       	brne	.+6      	; 0x27d0 <PM_GetStoredDataSize+0xd2>
	   ProgDataSize = 0x00;
    27ca:	ee 24       	eor	r14, r14
    27cc:	ff 24       	eor	r15, r15
    27ce:	87 01       	movw	r16, r14

	return ProgDataSize;
}
    27d0:	c8 01       	movw	r24, r16
    27d2:	b7 01       	movw	r22, r14
    27d4:	22 96       	adiw	r28, 0x02	; 2
    27d6:	0f b6       	in	r0, 0x3f	; 63
    27d8:	f8 94       	cli
    27da:	de bf       	out	0x3e, r29	; 62
    27dc:	0f be       	out	0x3f, r0	; 63
    27de:	cd bf       	out	0x3d, r28	; 61
    27e0:	df 91       	pop	r29
    27e2:	cf 91       	pop	r28
    27e4:	1f 91       	pop	r17
    27e6:	0f 91       	pop	r16
    27e8:	ff 90       	pop	r15
    27ea:	ef 90       	pop	r14
    27ec:	08 95       	ret

000027ee <PM_SetupDFAddressCounters>:

void PM_SetupDFAddressCounters(uint8_t Type)
{
	uint32_t StartAddress;
	
	MemoryType = Type;
    27ee:	80 93 4b 02 	sts	0x024B, r24
	GPageLength = 0;
    27f2:	10 92 49 02 	sts	0x0249, r1
    27f6:	10 92 48 02 	sts	0x0248, r1
    27fa:	20 91 2b 01 	lds	r18, 0x012B
    27fe:	30 91 2c 01 	lds	r19, 0x012C
    2802:	40 91 2d 01 	lds	r20, 0x012D
    2806:	50 91 2e 01 	lds	r21, 0x012E

	if (Type == TYPE_FLASH)                                              // Type 1 = Flash
    280a:	81 30       	cpi	r24, 0x01	; 1
    280c:	39 f4       	brne	.+14     	; 0x281c <PM_SetupDFAddressCounters+0x2e>
		StartAddress = (CurrAddress << 1);                               // Convert flash word address to byte address
    280e:	da 01       	movw	r26, r20
    2810:	c9 01       	movw	r24, r18
    2812:	88 0f       	add	r24, r24
    2814:	99 1f       	adc	r25, r25
    2816:	aa 1f       	adc	r26, r26
    2818:	bb 1f       	adc	r27, r27
    281a:	06 c0       	rjmp	.+12     	; 0x2828 <PM_SetupDFAddressCounters+0x3a>
	else
		StartAddress = CurrAddress + PM_EEPROM_OFFSET;                   // EEPROM uses byte addresses, and starts at the 257th kilobyte in Dataflash
    281c:	da 01       	movw	r26, r20
    281e:	c9 01       	movw	r24, r18
    2820:	80 50       	subi	r24, 0x00	; 0
    2822:	9c 4f       	sbci	r25, 0xFC	; 252
    2824:	ab 4f       	sbci	r26, 0xFB	; 251
    2826:	bf 4f       	sbci	r27, 0xFF	; 255
	
	CurrPageAddress = 0;
    2828:	10 92 8d 02 	sts	0x028D, r1
    282c:	10 92 8c 02 	sts	0x028C, r1

	while (StartAddress >= DF_INTERNALDF_BUFFBYTES)                      // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DF_INTERNALDF_BUFFBYTES;                         // Subtract one page's worth of bytes from the desired address
		CurrPageAddress++;
    2830:	88 30       	cpi	r24, 0x08	; 8
    2832:	21 e0       	ldi	r18, 0x01	; 1
    2834:	92 07       	cpc	r25, r18
    2836:	20 e0       	ldi	r18, 0x00	; 0
    2838:	a2 07       	cpc	r26, r18
    283a:	20 e0       	ldi	r18, 0x00	; 0
    283c:	b2 07       	cpc	r27, r18
    283e:	a0 f0       	brcs	.+40     	; 0x2868 <PM_SetupDFAddressCounters+0x7a>
    2840:	20 e0       	ldi	r18, 0x00	; 0
    2842:	30 e0       	ldi	r19, 0x00	; 0
    2844:	88 50       	subi	r24, 0x08	; 8
    2846:	91 40       	sbci	r25, 0x01	; 1
    2848:	a0 40       	sbci	r26, 0x00	; 0
    284a:	b0 40       	sbci	r27, 0x00	; 0
    284c:	2f 5f       	subi	r18, 0xFF	; 255
    284e:	3f 4f       	sbci	r19, 0xFF	; 255
    2850:	88 30       	cpi	r24, 0x08	; 8
    2852:	41 e0       	ldi	r20, 0x01	; 1
    2854:	94 07       	cpc	r25, r20
    2856:	40 e0       	ldi	r20, 0x00	; 0
    2858:	a4 07       	cpc	r26, r20
    285a:	40 e0       	ldi	r20, 0x00	; 0
    285c:	b4 07       	cpc	r27, r20
    285e:	90 f7       	brcc	.-28     	; 0x2844 <PM_SetupDFAddressCounters+0x56>
    2860:	30 93 8d 02 	sts	0x028D, r19
    2864:	20 93 8c 02 	sts	0x028C, r18
	}
	
	CurrBuffByte = (uint16_t)StartAddress;                               // The buffer byte is the remainder
    2868:	90 93 86 02 	sts	0x0286, r25
    286c:	80 93 85 02 	sts	0x0285, r24
    2870:	08 95       	ret

00002872 <PM_StoreProgramByte>:
}

void PM_StoreProgramByte(uint8_t Data)
{
    2872:	cf 93       	push	r28
    2874:	c8 2f       	mov	r28, r24
	if (CurrBuffByte == DF_INTERNALDF_BUFFBYTES)
    2876:	80 91 85 02 	lds	r24, 0x0285
    287a:	90 91 86 02 	lds	r25, 0x0286
    287e:	88 50       	subi	r24, 0x08	; 8
    2880:	91 40       	sbci	r25, 0x01	; 1
    2882:	d9 f4       	brne	.+54     	; 0x28ba <PM_StoreProgramByte+0x48>
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
    2884:	80 91 8c 02 	lds	r24, 0x028C
    2888:	90 91 8d 02 	lds	r25, 0x028D
    288c:	9c 01       	movw	r18, r24
    288e:	01 96       	adiw	r24, 0x01	; 1
    2890:	90 93 8d 02 	sts	0x028D, r25
    2894:	80 93 8c 02 	sts	0x028C, r24
    2898:	c9 01       	movw	r24, r18
    289a:	0e 94 35 0b 	call	0x166a <DF_CopyBufferToFlashPage>
		DF_CopyFlashPageToBuffer(CurrPageAddress);
    289e:	80 91 8c 02 	lds	r24, 0x028C
    28a2:	90 91 8d 02 	lds	r25, 0x028D
    28a6:	0e 94 ff 0a 	call	0x15fe <DF_CopyFlashPageToBuffer>
		DF_BufferWriteEnable(0);
    28aa:	80 e0       	ldi	r24, 0x00	; 0
    28ac:	90 e0       	ldi	r25, 0x00	; 0
    28ae:	0e 94 63 0a 	call	0x14c6 <DF_BufferWriteEnable>
		CurrBuffByte = 0;
    28b2:	10 92 86 02 	sts	0x0286, r1
    28b6:	10 92 85 02 	sts	0x0285, r1
	}
	
	SPI_SPITransmit(Data);                                               // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    28ba:	8c 2f       	mov	r24, r28
    28bc:	0e 94 47 09 	call	0x128e <SPI_SPITransmit>
	CurrBuffByte++;
    28c0:	80 91 85 02 	lds	r24, 0x0285
    28c4:	90 91 86 02 	lds	r25, 0x0286
    28c8:	01 96       	adiw	r24, 0x01	; 1
    28ca:	90 93 86 02 	sts	0x0286, r25
    28ce:	80 93 85 02 	sts	0x0285, r24
	GPageLength++;
    28d2:	80 91 48 02 	lds	r24, 0x0248
    28d6:	90 91 49 02 	lds	r25, 0x0249
    28da:	01 96       	adiw	r24, 0x01	; 1
    28dc:	90 93 49 02 	sts	0x0249, r25
    28e0:	80 93 48 02 	sts	0x0248, r24
    28e4:	cf 91       	pop	r28
    28e6:	08 95       	ret

000028e8 <PM_CheckEndOfProgramming>:
}

void PM_InterpretAVRISPPacket(void)
{
	uint16_t EEPROMAddress;

	switch (PacketBytes[0])
	{
		case CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
			
			EEPROMAddress = Prog_EnterProgMode;
			
			for (uint8_t PacketB = 0; PacketB <= 11; PacketB++)          // Save the enter programming mode command bytes
			{
				eeprom_write_byte_169(&EEPROMAddress, PacketBytes[PacketB]);
				EEPROMAddress++;
			}
			
			InProgrammingMode = TRUE;                                    // Set the flag, prevent the user from exiting the V2P state machine			
			CurrentMode = PM_NO_SETUP;                                   // Clear the current mode variable

			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = STATUS_CMD_OK;

			break;			
		case CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;

			PM_CheckEndOfProgramming();                                  // Check if the last command was a program - if so store the program length
			PM_CheckEndOfFuseLockStore();                                // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
			
			InProgrammingMode = FALSE;                                   // Clear the flag, allow the user to exit the V2P state machine

			DF_EnableDataflash(FALSE);

			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
			PacketBytes[1] = STATUS_CMD_OK;

			break;
		case CMD_READ_SIGNATURE_ISP:
			MessageSize = 4;

			PacketBytes[1] = STATUS_CMD_OK;                              // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x01;                                       // Signature bytes all return "01" in storage mode
			PacketBytes[3] = STATUS_CMD_OK;                              // Data byte is encased in CMD_OKs

			break;
		case CMD_CHIP_ERASE_ISP:
			MessageSize = 2;

			EEPROMAddress = Prog_EraseChip;                              // Program erase chip command start address
			
			for (uint8_t PacketB = 1; PacketB <= 6; PacketB++)          // Save the erase chip command bytes to EEPROM
			{
				eeprom_write_byte_169(&EEPROMAddress, PacketBytes[PacketB]);
				EEPROMAddress++;
			}

			EEPROMAddress = Prog_DataSize;
										
			for (uint8_t Byte = 0; Byte < 8; Byte++)                    // Clear the program and EEPROM size counters
			{
				if (Byte == 4)
				   EEPROMAddress = Prog_EEPROMSize;

				eeprom_write_byte_169(&EEPROMAddress, 0x00);
				EEPROMAddress++;						
			}
			
			//DF_EraseInternalDF();  TODO: FIX ROUTINE
			
			eeprom_write_byte_169(&Prog_EraseCmdStored, TRUE);
			
			PacketBytes[1] = STATUS_CMD_OK;
			
			break;
		case CMD_READ_OSCCAL_ISP:
			MessageSize = 4;

			PacketBytes[1] = STATUS_CMD_OK;                             // Data byte is encased in CMD_OKs
			PacketBytes[1] = 0x00;                                      // Return 0x00 for the OSCCAL byte
			PacketBytes[3] = STATUS_CMD_OK;                             // Data byte is encased in CMD_OKs

			break;
		case CMD_READ_FUSE_ISP:
		case CMD_READ_LOCK_ISP:
			MessageSize = 4;
	
			if (CurrentMode != PM_LOCKFUSEBITS_READ)                    // First lock or fuse byte being read, set the EEPROM pointer
			{
				PM_CheckEndOfProgramming();                             // Check if the last command was a program - if so store the program length
				PM_CheckEndOfFuseLockStore();                           // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
				
				CurrBuffByte = 0;
				CurrentMode  = PM_LOCKFUSEBITS_READ;
			}
			
			EEPROMAddress = ((PacketBytes[0] == CMD_READ_FUSE_ISP)? Prog_TotalFuseBytes : Prog_TotalLockBytes);

			if (CurrBuffByte > eeprom_read_byte_169(&EEPROMAddress))    // Trying to read more fuse/lock bytes than are stored in memory
			{
				PacketBytes[2] = 0xFF;                                  // Return 0xFF for the fuse/lock byte
			}
			else
			{
				EEPROMAddress  = ((PacketBytes[0] == CMD_READ_FUSE_ISP)? Prog_FuseBytes : Prog_LockBytes) // Starting location
									+ (CurrBuffByte << 2) + (PacketBytes[1] - 1); // The start position of the actual fuse/lock byte to read (4 bytes each)

				PacketBytes[2] = eeprom_read_byte_169(&EEPROMAddress); // Return the fuse/lock byte
			}

			PacketBytes[1] = STATUS_CMD_OK;                            // Data byte is encased in CMD_OKs
			PacketBytes[3] = STATUS_CMD_OK;                            // Data byte is encased in CMD_OKs

			CurrBuffByte++;

			break;
		case CMD_PROGRAM_FUSE_ISP:
		case CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;

			if (CurrentMode != PM_LOCKFUSEBITS_WRITE)                  // First lock or fuse byte being written, set the EEPROM pointer
			{
				CurrentMode   = PM_LOCKFUSEBITS_WRITE;
				CurrBuffByte  = 0;                                     // CurrBuffByte is used to store the total fuse/lock bytes written
			}

			if (PacketBytes[0] == CMD_PROGRAM_FUSE_ISP)
			{
				EEPROMAddress = Prog_FuseBytes + (CurrBuffByte << 2);
				MemoryType    = TYPE_FUSE;
			}
			else
			{
				EEPROMAddress = Prog_LockBytes + (CurrBuffByte << 2);
				MemoryType    = TYPE_LOCK;
			}				
			
			if (CurrBuffByte < PM_MAX_FUSELOCKBITS)
			{
				for (uint8_t FLByte = 1; FLByte <= 4; FLByte++)
				{
					eeprom_write_byte_169(&EEPROMAddress, PacketBytes[FLByte]);
					EEPROMAddress++;
				}

				CurrBuffByte++;                                        // Increment the total fuse/lock bytes written counter
			}
			
			PacketBytes[1] = STATUS_CMD_OK;                            // Two CMD_OKs are always returned
			PacketBytes[2] = STATUS_CMD_OK;                            // Two CMD_OKs are always returned

			break;
		case CMD_PROGRAM_FLASH_ISP:
		case CMD_PROGRAM_EEPROM_ISP:
			MessageSize = 2;

			if (CurrentMode != PM_DATAFLASH_WRITE)                     // First programming packet
			{
				if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)           // Flash programming mode
				{
					EEPROMAddress = Prog_WriteProgram;                 // Set the eeprom address to the Program command bytes location
					PM_SetupDFAddressCounters(TYPE_FLASH);
				}
				else                                                  // EEPROM programming mode
				{
					EEPROMAddress = Prog_WriteEEPROM;                  // Set the eeprom address to the EEPROM command bytes location
					PM_SetupDFAddressCounters(TYPE_EEPROM);
				}
				
				DF_BufferWriteEnable(CurrBuffByte);
				CurrentMode = PM_DATAFLASH_WRITE;
				
				for (uint8_t B = 1; B <= 9; B++)                       // Save the command bytes
				{
					eeprom_write_byte_169(&EEPROMAddress, PacketBytes[B]);
					EEPROMAddress++;				
				}
			}

			uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
			                      | PacketBytes[2];

			for (uint16_t CurrByte = 0; CurrByte < BytesToWrite; CurrByte++)
				PM_StoreProgramByte(PacketBytes[10 + CurrByte]);

			if (!(GPageLength & PM_PAGELENGTH_FOUNDBIT) && (PacketBytes[3] & ISPCC_PROG_MODE_PAGEDONE) && GPageLength)
			{
				EEPROMAddress = ((MemoryType == TYPE_FLASH)? Prog_PageLength : Prog_EPageLength);
	
				eeprom_write_byte_169(&EEPROMAddress, (uint8_t)(GPageLength >> 8));
				EEPROMAddress++;
				eeprom_write_byte_169(&EEPROMAddress, (uint8_t)GPageLength);		
		
				GPageLength |= PM_PAGELENGTH_FOUNDBIT;                 // Bit 15 is used to indicate if the length has been found
			}

			PacketBytes[1] = STATUS_CMD_OK;
		
			break;
		case CMD_READ_FLASH_ISP:
		case CMD_READ_EEPROM_ISP:	
			if (CurrentMode != PM_DATAFLASH_READ)
			{
				PM_CheckEndOfProgramming();                           // Check if the last command was a program - if so store the program length
				PM_CheckEndOfFuseLockStore();                         // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
				
				PM_SetupDFAddressCounters((PacketBytes[0] == CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);
				DF_ContinuousReadEnable(CurrPageAddress, CurrBuffByte);
				
				CurrentMode = PM_DATAFLASH_READ;
				CurrAddress = 0;
			}

			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8)    // \. Load in the number of bytes that is to
			                     | PacketBytes[2];                    // /  be read into a temp variable (MSB first)
						
			uint16_t BytesInMem  = PM_GetStoredDataSize((PacketBytes[0] == CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
			   PacketBytes[2 + ReadByte] = ((CurrAddress < BytesInMem)? SPI_SPITransmit(0x00) : 0xFF); // Read in the next dataflash byte if present
			   V2P_IncrementCurrAddress();
			}
			
			MessageSize = BytesToRead + 3;

			PacketBytes[1]               = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
			PacketBytes[2 + BytesToRead] = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
		
			break;
		default:
			MessageSize = 1;
			
			PacketBytes[1] = STATUS_CMD_UNKNOWN;
	}

	V2P_SendPacket();                                   // Send the response packet
}

void PM_CheckEndOfProgramming(void)
{
    28e8:	ef 92       	push	r14
    28ea:	ff 92       	push	r15
    28ec:	0f 93       	push	r16
    28ee:	1f 93       	push	r17
    28f0:	cf 93       	push	r28
    28f2:	df 93       	push	r29
    28f4:	cd b7       	in	r28, 0x3d	; 61
    28f6:	de b7       	in	r29, 0x3e	; 62
    28f8:	22 97       	sbiw	r28, 0x02	; 2
    28fa:	0f b6       	in	r0, 0x3f	; 63
    28fc:	f8 94       	cli
    28fe:	de bf       	out	0x3e, r29	; 62
    2900:	0f be       	out	0x3f, r0	; 63
    2902:	cd bf       	out	0x3d, r28	; 61
   uint16_t EEPROMAddress;

   if (CurrentMode == PM_DATAFLASH_WRITE)
    2904:	80 91 4a 02 	lds	r24, 0x024A
    2908:	81 30       	cpi	r24, 0x01	; 1
    290a:	09 f0       	breq	.+2      	; 0x290e <PM_CheckEndOfProgramming+0x26>
    290c:	6d c0       	rjmp	.+218    	; 0x29e8 <PM_CheckEndOfProgramming+0x100>
   {
      if (CurrBuffByte)                               // Data in the dataflash buffer, pending to be written
    290e:	80 91 85 02 	lds	r24, 0x0285
    2912:	90 91 86 02 	lds	r25, 0x0286
    2916:	89 2b       	or	r24, r25
    2918:	31 f0       	breq	.+12     	; 0x2926 <PM_CheckEndOfProgramming+0x3e>
         DF_CopyBufferToFlashPage(CurrPageAddress);   // Save the buffer
    291a:	80 91 8c 02 	lds	r24, 0x028C
    291e:	90 91 8d 02 	lds	r25, 0x028D
    2922:	0e 94 35 0b 	call	0x166a <DF_CopyBufferToFlashPage>

      uint32_t DataSize = ((uint32_t)CurrPageAddress * DF_INTERNALDF_BUFFBYTES) + CurrBuffByte;
    2926:	80 91 8c 02 	lds	r24, 0x028C
    292a:	90 91 8d 02 	lds	r25, 0x028D
    292e:	aa 27       	eor	r26, r26
    2930:	bb 27       	eor	r27, r27
    2932:	bc 01       	movw	r22, r24
    2934:	cd 01       	movw	r24, r26
    2936:	28 e0       	ldi	r18, 0x08	; 8
    2938:	31 e0       	ldi	r19, 0x01	; 1
    293a:	40 e0       	ldi	r20, 0x00	; 0
    293c:	50 e0       	ldi	r21, 0x00	; 0
    293e:	0e 94 7a 1b 	call	0x36f4 <__mulsi3>
    2942:	7b 01       	movw	r14, r22
    2944:	8c 01       	movw	r16, r24
    2946:	80 91 85 02 	lds	r24, 0x0285
    294a:	90 91 86 02 	lds	r25, 0x0286
    294e:	aa 27       	eor	r26, r26
    2950:	bb 27       	eor	r27, r27
    2952:	e8 0e       	add	r14, r24
    2954:	f9 1e       	adc	r15, r25
    2956:	0a 1f       	adc	r16, r26
    2958:	1b 1f       	adc	r17, r27

      if (MemoryType == TYPE_FLASH)
    295a:	80 91 4b 02 	lds	r24, 0x024B
    295e:	81 30       	cpi	r24, 0x01	; 1
    2960:	39 f4       	brne	.+14     	; 0x2970 <PM_CheckEndOfProgramming+0x88>
      {
         EEPROMAddress = Prog_DataSize;       
    2962:	80 91 16 01 	lds	r24, 0x0116
    2966:	90 91 17 01 	lds	r25, 0x0117
    296a:	9a 83       	std	Y+2, r25	; 0x02
    296c:	89 83       	std	Y+1, r24	; 0x01
    296e:	0e c0       	rjmp	.+28     	; 0x298c <PM_CheckEndOfProgramming+0xa4>
      }
      else
      {
         EEPROMAddress = Prog_EEPROMSize;
    2970:	80 91 14 01 	lds	r24, 0x0114
    2974:	90 91 15 01 	lds	r25, 0x0115
    2978:	9a 83       	std	Y+2, r25	; 0x02
    297a:	89 83       	std	Y+1, r24	; 0x01
         DataSize -= PM_EEPROM_OFFSET;                // Remove DataFlash starting offset
    297c:	80 e0       	ldi	r24, 0x00	; 0
    297e:	9c ef       	ldi	r25, 0xFC	; 252
    2980:	ab ef       	ldi	r26, 0xFB	; 251
    2982:	bf ef       	ldi	r27, 0xFF	; 255
    2984:	e8 0e       	add	r14, r24
    2986:	f9 1e       	adc	r15, r25
    2988:	0a 1f       	adc	r16, r26
    298a:	1b 1f       	adc	r17, r27
      }

      eeprom_write_byte_169(&EEPROMAddress, (DataSize >> 24));
    298c:	81 2f       	mov	r24, r17
    298e:	99 27       	eor	r25, r25
    2990:	aa 27       	eor	r26, r26
    2992:	bb 27       	eor	r27, r27
    2994:	68 2f       	mov	r22, r24
    2996:	ce 01       	movw	r24, r28
    2998:	01 96       	adiw	r24, 0x01	; 1
    299a:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
      EEPROMAddress++;
    299e:	89 81       	ldd	r24, Y+1	; 0x01
    29a0:	9a 81       	ldd	r25, Y+2	; 0x02
    29a2:	01 96       	adiw	r24, 0x01	; 1
    29a4:	9a 83       	std	Y+2, r25	; 0x02
    29a6:	89 83       	std	Y+1, r24	; 0x01
      eeprom_write_byte_169(&EEPROMAddress, (DataSize >> 16));             
    29a8:	c8 01       	movw	r24, r16
    29aa:	aa 27       	eor	r26, r26
    29ac:	bb 27       	eor	r27, r27
    29ae:	68 2f       	mov	r22, r24
    29b0:	ce 01       	movw	r24, r28
    29b2:	01 96       	adiw	r24, 0x01	; 1
    29b4:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
      EEPROMAddress++;
    29b8:	89 81       	ldd	r24, Y+1	; 0x01
    29ba:	9a 81       	ldd	r25, Y+2	; 0x02
    29bc:	01 96       	adiw	r24, 0x01	; 1
    29be:	9a 83       	std	Y+2, r25	; 0x02
    29c0:	89 83       	std	Y+1, r24	; 0x01
      eeprom_write_byte_169(&EEPROMAddress, (DataSize >> 8));
    29c2:	bb 27       	eor	r27, r27
    29c4:	a1 2f       	mov	r26, r17
    29c6:	90 2f       	mov	r25, r16
    29c8:	8f 2d       	mov	r24, r15
    29ca:	68 2f       	mov	r22, r24
    29cc:	ce 01       	movw	r24, r28
    29ce:	01 96       	adiw	r24, 0x01	; 1
    29d0:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
      EEPROMAddress++;
    29d4:	89 81       	ldd	r24, Y+1	; 0x01
    29d6:	9a 81       	ldd	r25, Y+2	; 0x02
    29d8:	01 96       	adiw	r24, 0x01	; 1
    29da:	9a 83       	std	Y+2, r25	; 0x02
    29dc:	89 83       	std	Y+1, r24	; 0x01
      eeprom_write_byte_169(&EEPROMAddress, DataSize);
    29de:	6e 2d       	mov	r22, r14
    29e0:	ce 01       	movw	r24, r28
    29e2:	01 96       	adiw	r24, 0x01	; 1
    29e4:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
    29e8:	22 96       	adiw	r28, 0x02	; 2
    29ea:	0f b6       	in	r0, 0x3f	; 63
    29ec:	f8 94       	cli
    29ee:	de bf       	out	0x3e, r29	; 62
    29f0:	0f be       	out	0x3f, r0	; 63
    29f2:	cd bf       	out	0x3d, r28	; 61
    29f4:	df 91       	pop	r29
    29f6:	cf 91       	pop	r28
    29f8:	1f 91       	pop	r17
    29fa:	0f 91       	pop	r16
    29fc:	ff 90       	pop	r15
    29fe:	ef 90       	pop	r14
    2a00:	08 95       	ret

00002a02 <PM_CheckEndOfFuseLockStore>:
   }
}

void PM_CheckEndOfFuseLockStore(void)
{
    2a02:	cf 93       	push	r28
    2a04:	df 93       	push	r29
    2a06:	cd b7       	in	r28, 0x3d	; 61
    2a08:	de b7       	in	r29, 0x3e	; 62
    2a0a:	22 97       	sbiw	r28, 0x02	; 2
    2a0c:	0f b6       	in	r0, 0x3f	; 63
    2a0e:	f8 94       	cli
    2a10:	de bf       	out	0x3e, r29	; 62
    2a12:	0f be       	out	0x3f, r0	; 63
    2a14:	cd bf       	out	0x3d, r28	; 61
	uint16_t EEPROMAddress;

	if (CurrentMode == PM_LOCKFUSEBITS_WRITE)
    2a16:	80 91 4a 02 	lds	r24, 0x024A
    2a1a:	83 30       	cpi	r24, 0x03	; 3
    2a1c:	a9 f4       	brne	.+42     	; 0x2a48 <PM_CheckEndOfFuseLockStore+0x46>
	{
		EEPROMAddress = ((MemoryType == TYPE_FUSE)? Prog_TotalFuseBytes : Prog_TotalLockBytes);
    2a1e:	80 91 4b 02 	lds	r24, 0x024B
    2a22:	82 30       	cpi	r24, 0x02	; 2
    2a24:	29 f4       	brne	.+10     	; 0x2a30 <PM_CheckEndOfFuseLockStore+0x2e>
    2a26:	80 91 10 01 	lds	r24, 0x0110
    2a2a:	90 91 11 01 	lds	r25, 0x0111
    2a2e:	04 c0       	rjmp	.+8      	; 0x2a38 <PM_CheckEndOfFuseLockStore+0x36>
    2a30:	80 91 0e 01 	lds	r24, 0x010E
    2a34:	90 91 0f 01 	lds	r25, 0x010F
    2a38:	9a 83       	std	Y+2, r25	; 0x02
    2a3a:	89 83       	std	Y+1, r24	; 0x01
		
		eeprom_write_byte_169(&EEPROMAddress, CurrBuffByte); // CurrBuffByte stores the total number of fuse/lock bytes written in this case
    2a3c:	60 91 85 02 	lds	r22, 0x0285
    2a40:	ce 01       	movw	r24, r28
    2a42:	01 96       	adiw	r24, 0x01	; 1
    2a44:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
    2a48:	22 96       	adiw	r28, 0x02	; 2
    2a4a:	0f b6       	in	r0, 0x3f	; 63
    2a4c:	f8 94       	cli
    2a4e:	de bf       	out	0x3e, r29	; 62
    2a50:	0f be       	out	0x3f, r0	; 63
    2a52:	cd bf       	out	0x3d, r28	; 61
    2a54:	df 91       	pop	r29
    2a56:	cf 91       	pop	r28
    2a58:	08 95       	ret

00002a5a <PM_InterpretAVRISPPacket>:
    2a5a:	af 92       	push	r10
    2a5c:	bf 92       	push	r11
    2a5e:	cf 92       	push	r12
    2a60:	df 92       	push	r13
    2a62:	ef 92       	push	r14
    2a64:	ff 92       	push	r15
    2a66:	0f 93       	push	r16
    2a68:	1f 93       	push	r17
    2a6a:	cf 93       	push	r28
    2a6c:	df 93       	push	r29
    2a6e:	cd b7       	in	r28, 0x3d	; 61
    2a70:	de b7       	in	r29, 0x3e	; 62
    2a72:	22 97       	sbiw	r28, 0x02	; 2
    2a74:	0f b6       	in	r0, 0x3f	; 63
    2a76:	f8 94       	cli
    2a78:	de bf       	out	0x3e, r29	; 62
    2a7a:	0f be       	out	0x3f, r0	; 63
    2a7c:	cd bf       	out	0x3d, r28	; 61
    2a7e:	40 91 34 01 	lds	r20, 0x0134
    2a82:	84 2f       	mov	r24, r20
    2a84:	99 27       	eor	r25, r25
    2a86:	86 31       	cpi	r24, 0x16	; 22
    2a88:	91 05       	cpc	r25, r1
    2a8a:	09 f4       	brne	.+2      	; 0x2a8e <PM_InterpretAVRISPPacket+0x34>
    2a8c:	18 c2       	rjmp	.+1072   	; 0x2ebe <PM_InterpretAVRISPPacket+0x464>
    2a8e:	87 31       	cpi	r24, 0x17	; 23
    2a90:	91 05       	cpc	r25, r1
    2a92:	94 f4       	brge	.+36     	; 0x2ab8 <PM_InterpretAVRISPPacket+0x5e>
    2a94:	82 31       	cpi	r24, 0x12	; 18
    2a96:	91 05       	cpc	r25, r1
    2a98:	09 f4       	brne	.+2      	; 0x2a9c <PM_InterpretAVRISPPacket+0x42>
    2a9a:	72 c0       	rjmp	.+228    	; 0x2b80 <PM_InterpretAVRISPPacket+0x126>
    2a9c:	83 31       	cpi	r24, 0x13	; 19
    2a9e:	91 05       	cpc	r25, r1
    2aa0:	3c f4       	brge	.+14     	; 0x2ab0 <PM_InterpretAVRISPPacket+0x56>
    2aa2:	80 31       	cpi	r24, 0x10	; 16
    2aa4:	91 05       	cpc	r25, r1
    2aa6:	19 f1       	breq	.+70     	; 0x2aee <PM_InterpretAVRISPPacket+0x94>
    2aa8:	41 97       	sbiw	r24, 0x11	; 17
    2aaa:	09 f4       	brne	.+2      	; 0x2aae <PM_InterpretAVRISPPacket+0x54>
    2aac:	49 c0       	rjmp	.+146    	; 0x2b40 <PM_InterpretAVRISPPacket+0xe6>
    2aae:	7b c2       	rjmp	.+1270   	; 0x2fa6 <PM_InterpretAVRISPPacket+0x54c>
    2ab0:	44 97       	sbiw	r24, 0x14	; 20
    2ab2:	09 f4       	brne	.+2      	; 0x2ab6 <PM_InterpretAVRISPPacket+0x5c>
    2ab4:	04 c2       	rjmp	.+1032   	; 0x2ebe <PM_InterpretAVRISPPacket+0x464>
    2ab6:	71 c1       	rjmp	.+738    	; 0x2d9a <PM_InterpretAVRISPPacket+0x340>
    2ab8:	89 31       	cpi	r24, 0x19	; 25
    2aba:	91 05       	cpc	r25, r1
    2abc:	09 f4       	brne	.+2      	; 0x2ac0 <PM_InterpretAVRISPPacket+0x66>
    2abe:	11 c1       	rjmp	.+546    	; 0x2ce2 <PM_InterpretAVRISPPacket+0x288>
    2ac0:	8a 31       	cpi	r24, 0x1A	; 26
    2ac2:	91 05       	cpc	r25, r1
    2ac4:	44 f4       	brge	.+16     	; 0x2ad6 <PM_InterpretAVRISPPacket+0x7c>
    2ac6:	87 31       	cpi	r24, 0x17	; 23
    2ac8:	91 05       	cpc	r25, r1
    2aca:	09 f4       	brne	.+2      	; 0x2ace <PM_InterpretAVRISPPacket+0x74>
    2acc:	0a c1       	rjmp	.+532    	; 0x2ce2 <PM_InterpretAVRISPPacket+0x288>
    2ace:	48 97       	sbiw	r24, 0x18	; 24
    2ad0:	09 f4       	brne	.+2      	; 0x2ad4 <PM_InterpretAVRISPPacket+0x7a>
    2ad2:	a3 c0       	rjmp	.+326    	; 0x2c1a <PM_InterpretAVRISPPacket+0x1c0>
    2ad4:	68 c2       	rjmp	.+1232   	; 0x2fa6 <PM_InterpretAVRISPPacket+0x54c>
    2ad6:	8b 31       	cpi	r24, 0x1B	; 27
    2ad8:	91 05       	cpc	r25, r1
    2ada:	09 f4       	brne	.+2      	; 0x2ade <PM_InterpretAVRISPPacket+0x84>
    2adc:	45 c0       	rjmp	.+138    	; 0x2b68 <PM_InterpretAVRISPPacket+0x10e>
    2ade:	8b 31       	cpi	r24, 0x1B	; 27
    2ae0:	91 05       	cpc	r25, r1
    2ae2:	0c f4       	brge	.+2      	; 0x2ae6 <PM_InterpretAVRISPPacket+0x8c>
    2ae4:	9a c0       	rjmp	.+308    	; 0x2c1a <PM_InterpretAVRISPPacket+0x1c0>
    2ae6:	4c 97       	sbiw	r24, 0x1c	; 28
    2ae8:	09 f4       	brne	.+2      	; 0x2aec <PM_InterpretAVRISPPacket+0x92>
    2aea:	8c c0       	rjmp	.+280    	; 0x2c04 <PM_InterpretAVRISPPacket+0x1aa>
    2aec:	5c c2       	rjmp	.+1208   	; 0x2fa6 <PM_InterpretAVRISPPacket+0x54c>
    2aee:	82 e0       	ldi	r24, 0x02	; 2
    2af0:	90 e0       	ldi	r25, 0x00	; 0
    2af2:	90 93 31 01 	sts	0x0131, r25
    2af6:	80 93 30 01 	sts	0x0130, r24
    2afa:	80 91 12 01 	lds	r24, 0x0112
    2afe:	90 91 13 01 	lds	r25, 0x0113
    2b02:	9a 83       	std	Y+2, r25	; 0x02
    2b04:	89 83       	std	Y+1, r24	; 0x01
    2b06:	f4 e3       	ldi	r31, 0x34	; 52
    2b08:	ef 2e       	mov	r14, r31
    2b0a:	f1 e0       	ldi	r31, 0x01	; 1
    2b0c:	ff 2e       	mov	r15, r31
    2b0e:	1b e0       	ldi	r17, 0x0B	; 11
    2b10:	f7 01       	movw	r30, r14
    2b12:	61 91       	ld	r22, Z+
    2b14:	7f 01       	movw	r14, r30
    2b16:	ce 01       	movw	r24, r28
    2b18:	01 96       	adiw	r24, 0x01	; 1
    2b1a:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
    2b1e:	89 81       	ldd	r24, Y+1	; 0x01
    2b20:	9a 81       	ldd	r25, Y+2	; 0x02
    2b22:	01 96       	adiw	r24, 0x01	; 1
    2b24:	9a 83       	std	Y+2, r25	; 0x02
    2b26:	89 83       	std	Y+1, r24	; 0x01
    2b28:	11 50       	subi	r17, 0x01	; 1
    2b2a:	17 ff       	sbrs	r17, 7
    2b2c:	f1 cf       	rjmp	.-30     	; 0x2b10 <PM_InterpretAVRISPPacket+0xb6>
    2b2e:	81 e0       	ldi	r24, 0x01	; 1
    2b30:	80 93 2f 01 	sts	0x012F, r24
    2b34:	10 92 4a 02 	sts	0x024A, r1
    2b38:	81 b3       	in	r24, 0x11	; 17
    2b3a:	8f 7c       	andi	r24, 0xCF	; 207
    2b3c:	80 62       	ori	r24, 0x20	; 32
    2b3e:	12 c0       	rjmp	.+36     	; 0x2b64 <PM_InterpretAVRISPPacket+0x10a>
    2b40:	82 e0       	ldi	r24, 0x02	; 2
    2b42:	90 e0       	ldi	r25, 0x00	; 0
    2b44:	90 93 31 01 	sts	0x0131, r25
    2b48:	80 93 30 01 	sts	0x0130, r24
    2b4c:	0e 94 74 14 	call	0x28e8 <PM_CheckEndOfProgramming>
    2b50:	0e 94 01 15 	call	0x2a02 <PM_CheckEndOfFuseLockStore>
    2b54:	10 92 2f 01 	sts	0x012F, r1
    2b58:	80 e0       	ldi	r24, 0x00	; 0
    2b5a:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    2b5e:	81 b3       	in	r24, 0x11	; 17
    2b60:	8f 7c       	andi	r24, 0xCF	; 207
    2b62:	80 61       	ori	r24, 0x10	; 16
    2b64:	81 bb       	out	0x11, r24	; 17
    2b66:	a8 c1       	rjmp	.+848    	; 0x2eb8 <PM_InterpretAVRISPPacket+0x45e>
    2b68:	84 e0       	ldi	r24, 0x04	; 4
    2b6a:	90 e0       	ldi	r25, 0x00	; 0
    2b6c:	90 93 31 01 	sts	0x0131, r25
    2b70:	80 93 30 01 	sts	0x0130, r24
    2b74:	10 92 35 01 	sts	0x0135, r1
    2b78:	81 e0       	ldi	r24, 0x01	; 1
    2b7a:	80 93 36 01 	sts	0x0136, r24
    2b7e:	4a c0       	rjmp	.+148    	; 0x2c14 <PM_InterpretAVRISPPacket+0x1ba>
    2b80:	82 e0       	ldi	r24, 0x02	; 2
    2b82:	90 e0       	ldi	r25, 0x00	; 0
    2b84:	90 93 31 01 	sts	0x0131, r25
    2b88:	80 93 30 01 	sts	0x0130, r24
    2b8c:	80 91 18 01 	lds	r24, 0x0118
    2b90:	90 91 19 01 	lds	r25, 0x0119
    2b94:	9a 83       	std	Y+2, r25	; 0x02
    2b96:	89 83       	std	Y+1, r24	; 0x01
    2b98:	e5 e3       	ldi	r30, 0x35	; 53
    2b9a:	ee 2e       	mov	r14, r30
    2b9c:	e1 e0       	ldi	r30, 0x01	; 1
    2b9e:	fe 2e       	mov	r15, r30
    2ba0:	15 e0       	ldi	r17, 0x05	; 5
    2ba2:	f7 01       	movw	r30, r14
    2ba4:	61 91       	ld	r22, Z+
    2ba6:	7f 01       	movw	r14, r30
    2ba8:	ce 01       	movw	r24, r28
    2baa:	01 96       	adiw	r24, 0x01	; 1
    2bac:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
    2bb0:	89 81       	ldd	r24, Y+1	; 0x01
    2bb2:	9a 81       	ldd	r25, Y+2	; 0x02
    2bb4:	01 96       	adiw	r24, 0x01	; 1
    2bb6:	9a 83       	std	Y+2, r25	; 0x02
    2bb8:	89 83       	std	Y+1, r24	; 0x01
    2bba:	11 50       	subi	r17, 0x01	; 1
    2bbc:	17 ff       	sbrs	r17, 7
    2bbe:	f1 cf       	rjmp	.-30     	; 0x2ba2 <PM_InterpretAVRISPPacket+0x148>
    2bc0:	80 91 16 01 	lds	r24, 0x0116
    2bc4:	90 91 17 01 	lds	r25, 0x0117
    2bc8:	9a 83       	std	Y+2, r25	; 0x02
    2bca:	89 83       	std	Y+1, r24	; 0x01
    2bcc:	10 e0       	ldi	r17, 0x00	; 0
    2bce:	14 30       	cpi	r17, 0x04	; 4
    2bd0:	31 f4       	brne	.+12     	; 0x2bde <PM_InterpretAVRISPPacket+0x184>
    2bd2:	80 91 14 01 	lds	r24, 0x0114
    2bd6:	90 91 15 01 	lds	r25, 0x0115
    2bda:	9a 83       	std	Y+2, r25	; 0x02
    2bdc:	89 83       	std	Y+1, r24	; 0x01
    2bde:	60 e0       	ldi	r22, 0x00	; 0
    2be0:	ce 01       	movw	r24, r28
    2be2:	01 96       	adiw	r24, 0x01	; 1
    2be4:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
    2be8:	89 81       	ldd	r24, Y+1	; 0x01
    2bea:	9a 81       	ldd	r25, Y+2	; 0x02
    2bec:	01 96       	adiw	r24, 0x01	; 1
    2bee:	9a 83       	std	Y+2, r25	; 0x02
    2bf0:	89 83       	std	Y+1, r24	; 0x01
    2bf2:	1f 5f       	subi	r17, 0xFF	; 255
    2bf4:	18 30       	cpi	r17, 0x08	; 8
    2bf6:	58 f3       	brcs	.-42     	; 0x2bce <PM_InterpretAVRISPPacket+0x174>
    2bf8:	61 e0       	ldi	r22, 0x01	; 1
    2bfa:	8a e1       	ldi	r24, 0x1A	; 26
    2bfc:	91 e0       	ldi	r25, 0x01	; 1
    2bfe:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
    2c02:	5a c1       	rjmp	.+692    	; 0x2eb8 <PM_InterpretAVRISPPacket+0x45e>
    2c04:	84 e0       	ldi	r24, 0x04	; 4
    2c06:	90 e0       	ldi	r25, 0x00	; 0
    2c08:	90 93 31 01 	sts	0x0131, r25
    2c0c:	80 93 30 01 	sts	0x0130, r24
    2c10:	10 92 35 01 	sts	0x0135, r1
    2c14:	10 92 37 01 	sts	0x0137, r1
    2c18:	cf c1       	rjmp	.+926    	; 0x2fb8 <PM_InterpretAVRISPPacket+0x55e>
    2c1a:	84 e0       	ldi	r24, 0x04	; 4
    2c1c:	90 e0       	ldi	r25, 0x00	; 0
    2c1e:	90 93 31 01 	sts	0x0131, r25
    2c22:	80 93 30 01 	sts	0x0130, r24
    2c26:	80 91 4a 02 	lds	r24, 0x024A
    2c2a:	84 30       	cpi	r24, 0x04	; 4
    2c2c:	59 f0       	breq	.+22     	; 0x2c44 <PM_InterpretAVRISPPacket+0x1ea>
    2c2e:	0e 94 74 14 	call	0x28e8 <PM_CheckEndOfProgramming>
    2c32:	0e 94 01 15 	call	0x2a02 <PM_CheckEndOfFuseLockStore>
    2c36:	10 92 86 02 	sts	0x0286, r1
    2c3a:	10 92 85 02 	sts	0x0285, r1
    2c3e:	84 e0       	ldi	r24, 0x04	; 4
    2c40:	80 93 4a 02 	sts	0x024A, r24
    2c44:	80 91 34 01 	lds	r24, 0x0134
    2c48:	88 31       	cpi	r24, 0x18	; 24
    2c4a:	29 f4       	brne	.+10     	; 0x2c56 <PM_InterpretAVRISPPacket+0x1fc>
    2c4c:	80 91 10 01 	lds	r24, 0x0110
    2c50:	90 91 11 01 	lds	r25, 0x0111
    2c54:	04 c0       	rjmp	.+8      	; 0x2c5e <PM_InterpretAVRISPPacket+0x204>
    2c56:	80 91 0e 01 	lds	r24, 0x010E
    2c5a:	90 91 0f 01 	lds	r25, 0x010F
    2c5e:	9a 83       	std	Y+2, r25	; 0x02
    2c60:	89 83       	std	Y+1, r24	; 0x01
    2c62:	ce 01       	movw	r24, r28
    2c64:	01 96       	adiw	r24, 0x01	; 1
    2c66:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
    2c6a:	99 27       	eor	r25, r25
    2c6c:	20 91 85 02 	lds	r18, 0x0285
    2c70:	30 91 86 02 	lds	r19, 0x0286
    2c74:	82 17       	cp	r24, r18
    2c76:	93 07       	cpc	r25, r19
    2c78:	10 f4       	brcc	.+4      	; 0x2c7e <PM_InterpretAVRISPPacket+0x224>
    2c7a:	8f ef       	ldi	r24, 0xFF	; 255
    2c7c:	22 c0       	rjmp	.+68     	; 0x2cc2 <PM_InterpretAVRISPPacket+0x268>
    2c7e:	a9 01       	movw	r20, r18
    2c80:	44 0f       	add	r20, r20
    2c82:	55 1f       	adc	r21, r21
    2c84:	44 0f       	add	r20, r20
    2c86:	55 1f       	adc	r21, r21
    2c88:	80 91 35 01 	lds	r24, 0x0135
    2c8c:	28 2f       	mov	r18, r24
    2c8e:	33 27       	eor	r19, r19
    2c90:	21 50       	subi	r18, 0x01	; 1
    2c92:	30 40       	sbci	r19, 0x00	; 0
    2c94:	80 91 34 01 	lds	r24, 0x0134
    2c98:	88 31       	cpi	r24, 0x18	; 24
    2c9a:	29 f4       	brne	.+10     	; 0x2ca6 <PM_InterpretAVRISPPacket+0x24c>
    2c9c:	80 91 0c 01 	lds	r24, 0x010C
    2ca0:	90 91 0d 01 	lds	r25, 0x010D
    2ca4:	04 c0       	rjmp	.+8      	; 0x2cae <PM_InterpretAVRISPPacket+0x254>
    2ca6:	80 91 0a 01 	lds	r24, 0x010A
    2caa:	90 91 0b 01 	lds	r25, 0x010B
    2cae:	84 0f       	add	r24, r20
    2cb0:	95 1f       	adc	r25, r21
    2cb2:	82 0f       	add	r24, r18
    2cb4:	93 1f       	adc	r25, r19
    2cb6:	9a 83       	std	Y+2, r25	; 0x02
    2cb8:	89 83       	std	Y+1, r24	; 0x01
    2cba:	ce 01       	movw	r24, r28
    2cbc:	01 96       	adiw	r24, 0x01	; 1
    2cbe:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
    2cc2:	80 93 36 01 	sts	0x0136, r24
    2cc6:	10 92 35 01 	sts	0x0135, r1
    2cca:	10 92 37 01 	sts	0x0137, r1
    2cce:	80 91 85 02 	lds	r24, 0x0285
    2cd2:	90 91 86 02 	lds	r25, 0x0286
    2cd6:	01 96       	adiw	r24, 0x01	; 1
    2cd8:	90 93 86 02 	sts	0x0286, r25
    2cdc:	80 93 85 02 	sts	0x0285, r24
    2ce0:	6b c1       	rjmp	.+726    	; 0x2fb8 <PM_InterpretAVRISPPacket+0x55e>
    2ce2:	83 e0       	ldi	r24, 0x03	; 3
    2ce4:	90 e0       	ldi	r25, 0x00	; 0
    2ce6:	90 93 31 01 	sts	0x0131, r25
    2cea:	80 93 30 01 	sts	0x0130, r24
    2cee:	80 91 4a 02 	lds	r24, 0x024A
    2cf2:	83 30       	cpi	r24, 0x03	; 3
    2cf4:	39 f0       	breq	.+14     	; 0x2d04 <PM_InterpretAVRISPPacket+0x2aa>
    2cf6:	83 e0       	ldi	r24, 0x03	; 3
    2cf8:	80 93 4a 02 	sts	0x024A, r24
    2cfc:	10 92 86 02 	sts	0x0286, r1
    2d00:	10 92 85 02 	sts	0x0285, r1
    2d04:	20 91 85 02 	lds	r18, 0x0285
    2d08:	30 91 86 02 	lds	r19, 0x0286
    2d0c:	47 31       	cpi	r20, 0x17	; 23
    2d0e:	71 f4       	brne	.+28     	; 0x2d2c <PM_InterpretAVRISPPacket+0x2d2>
    2d10:	22 0f       	add	r18, r18
    2d12:	33 1f       	adc	r19, r19
    2d14:	22 0f       	add	r18, r18
    2d16:	33 1f       	adc	r19, r19
    2d18:	80 91 0c 01 	lds	r24, 0x010C
    2d1c:	90 91 0d 01 	lds	r25, 0x010D
    2d20:	82 0f       	add	r24, r18
    2d22:	93 1f       	adc	r25, r19
    2d24:	9a 83       	std	Y+2, r25	; 0x02
    2d26:	89 83       	std	Y+1, r24	; 0x01
    2d28:	82 e0       	ldi	r24, 0x02	; 2
    2d2a:	0d c0       	rjmp	.+26     	; 0x2d46 <PM_InterpretAVRISPPacket+0x2ec>
    2d2c:	22 0f       	add	r18, r18
    2d2e:	33 1f       	adc	r19, r19
    2d30:	22 0f       	add	r18, r18
    2d32:	33 1f       	adc	r19, r19
    2d34:	80 91 0a 01 	lds	r24, 0x010A
    2d38:	90 91 0b 01 	lds	r25, 0x010B
    2d3c:	82 0f       	add	r24, r18
    2d3e:	93 1f       	adc	r25, r19
    2d40:	9a 83       	std	Y+2, r25	; 0x02
    2d42:	89 83       	std	Y+1, r24	; 0x01
    2d44:	83 e0       	ldi	r24, 0x03	; 3
    2d46:	80 93 4b 02 	sts	0x024B, r24
    2d4a:	80 91 85 02 	lds	r24, 0x0285
    2d4e:	90 91 86 02 	lds	r25, 0x0286
    2d52:	0a 97       	sbiw	r24, 0x0a	; 10
    2d54:	e8 f4       	brcc	.+58     	; 0x2d90 <PM_InterpretAVRISPPacket+0x336>
    2d56:	45 e3       	ldi	r20, 0x35	; 53
    2d58:	e4 2e       	mov	r14, r20
    2d5a:	41 e0       	ldi	r20, 0x01	; 1
    2d5c:	f4 2e       	mov	r15, r20
    2d5e:	13 e0       	ldi	r17, 0x03	; 3
    2d60:	f7 01       	movw	r30, r14
    2d62:	61 91       	ld	r22, Z+
    2d64:	7f 01       	movw	r14, r30
    2d66:	ce 01       	movw	r24, r28
    2d68:	01 96       	adiw	r24, 0x01	; 1
    2d6a:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
    2d6e:	89 81       	ldd	r24, Y+1	; 0x01
    2d70:	9a 81       	ldd	r25, Y+2	; 0x02
    2d72:	01 96       	adiw	r24, 0x01	; 1
    2d74:	9a 83       	std	Y+2, r25	; 0x02
    2d76:	89 83       	std	Y+1, r24	; 0x01
    2d78:	11 50       	subi	r17, 0x01	; 1
    2d7a:	17 ff       	sbrs	r17, 7
    2d7c:	f1 cf       	rjmp	.-30     	; 0x2d60 <PM_InterpretAVRISPPacket+0x306>
    2d7e:	80 91 85 02 	lds	r24, 0x0285
    2d82:	90 91 86 02 	lds	r25, 0x0286
    2d86:	01 96       	adiw	r24, 0x01	; 1
    2d88:	90 93 86 02 	sts	0x0286, r25
    2d8c:	80 93 85 02 	sts	0x0285, r24
    2d90:	10 92 35 01 	sts	0x0135, r1
    2d94:	10 92 36 01 	sts	0x0136, r1
    2d98:	0f c1       	rjmp	.+542    	; 0x2fb8 <PM_InterpretAVRISPPacket+0x55e>
    2d9a:	82 e0       	ldi	r24, 0x02	; 2
    2d9c:	90 e0       	ldi	r25, 0x00	; 0
    2d9e:	90 93 31 01 	sts	0x0131, r25
    2da2:	80 93 30 01 	sts	0x0130, r24
    2da6:	80 91 4a 02 	lds	r24, 0x024A
    2daa:	81 30       	cpi	r24, 0x01	; 1
    2dac:	81 f1       	breq	.+96     	; 0x2e0e <PM_InterpretAVRISPPacket+0x3b4>
    2dae:	43 31       	cpi	r20, 0x13	; 19
    2db0:	41 f4       	brne	.+16     	; 0x2dc2 <PM_InterpretAVRISPPacket+0x368>
    2db2:	80 91 1e 01 	lds	r24, 0x011E
    2db6:	90 91 1f 01 	lds	r25, 0x011F
    2dba:	9a 83       	std	Y+2, r25	; 0x02
    2dbc:	89 83       	std	Y+1, r24	; 0x01
    2dbe:	81 e0       	ldi	r24, 0x01	; 1
    2dc0:	07 c0       	rjmp	.+14     	; 0x2dd0 <PM_InterpretAVRISPPacket+0x376>
    2dc2:	80 91 1c 01 	lds	r24, 0x011C
    2dc6:	90 91 1d 01 	lds	r25, 0x011D
    2dca:	9a 83       	std	Y+2, r25	; 0x02
    2dcc:	89 83       	std	Y+1, r24	; 0x01
    2dce:	80 e0       	ldi	r24, 0x00	; 0
    2dd0:	0e 94 f7 13 	call	0x27ee <PM_SetupDFAddressCounters>
    2dd4:	80 91 85 02 	lds	r24, 0x0285
    2dd8:	90 91 86 02 	lds	r25, 0x0286
    2ddc:	0e 94 63 0a 	call	0x14c6 <DF_BufferWriteEnable>
    2de0:	81 e0       	ldi	r24, 0x01	; 1
    2de2:	80 93 4a 02 	sts	0x024A, r24
    2de6:	35 e3       	ldi	r19, 0x35	; 53
    2de8:	e3 2e       	mov	r14, r19
    2dea:	31 e0       	ldi	r19, 0x01	; 1
    2dec:	f3 2e       	mov	r15, r19
    2dee:	18 e0       	ldi	r17, 0x08	; 8
    2df0:	f7 01       	movw	r30, r14
    2df2:	61 91       	ld	r22, Z+
    2df4:	7f 01       	movw	r14, r30
    2df6:	ce 01       	movw	r24, r28
    2df8:	01 96       	adiw	r24, 0x01	; 1
    2dfa:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
    2dfe:	89 81       	ldd	r24, Y+1	; 0x01
    2e00:	9a 81       	ldd	r25, Y+2	; 0x02
    2e02:	01 96       	adiw	r24, 0x01	; 1
    2e04:	9a 83       	std	Y+2, r25	; 0x02
    2e06:	89 83       	std	Y+1, r24	; 0x01
    2e08:	11 50       	subi	r17, 0x01	; 1
    2e0a:	17 ff       	sbrs	r17, 7
    2e0c:	f1 cf       	rjmp	.-30     	; 0x2df0 <PM_InterpretAVRISPPacket+0x396>
    2e0e:	80 91 35 01 	lds	r24, 0x0135
    2e12:	99 27       	eor	r25, r25
    2e14:	18 2f       	mov	r17, r24
    2e16:	00 27       	eor	r16, r16
    2e18:	80 91 36 01 	lds	r24, 0x0136
    2e1c:	99 27       	eor	r25, r25
    2e1e:	08 2b       	or	r16, r24
    2e20:	19 2b       	or	r17, r25
    2e22:	ee 24       	eor	r14, r14
    2e24:	ff 24       	eor	r15, r15
    2e26:	e0 16       	cp	r14, r16
    2e28:	f1 06       	cpc	r15, r17
    2e2a:	78 f4       	brcc	.+30     	; 0x2e4a <PM_InterpretAVRISPPacket+0x3f0>
    2e2c:	8e e3       	ldi	r24, 0x3E	; 62
    2e2e:	c8 2e       	mov	r12, r24
    2e30:	81 e0       	ldi	r24, 0x01	; 1
    2e32:	d8 2e       	mov	r13, r24
    2e34:	f6 01       	movw	r30, r12
    2e36:	81 91       	ld	r24, Z+
    2e38:	6f 01       	movw	r12, r30
    2e3a:	0e 94 39 14 	call	0x2872 <PM_StoreProgramByte>
    2e3e:	08 94       	sec
    2e40:	e1 1c       	adc	r14, r1
    2e42:	f1 1c       	adc	r15, r1
    2e44:	e0 16       	cp	r14, r16
    2e46:	f1 06       	cpc	r15, r17
    2e48:	a8 f3       	brcs	.-22     	; 0x2e34 <PM_InterpretAVRISPPacket+0x3da>
    2e4a:	40 91 48 02 	lds	r20, 0x0248
    2e4e:	50 91 49 02 	lds	r21, 0x0249
    2e52:	57 fd       	sbrc	r21, 7
    2e54:	31 c0       	rjmp	.+98     	; 0x2eb8 <PM_InterpretAVRISPPacket+0x45e>
    2e56:	80 91 37 01 	lds	r24, 0x0137
    2e5a:	87 ff       	sbrs	r24, 7
    2e5c:	2d c0       	rjmp	.+90     	; 0x2eb8 <PM_InterpretAVRISPPacket+0x45e>
    2e5e:	41 15       	cp	r20, r1
    2e60:	51 05       	cpc	r21, r1
    2e62:	51 f1       	breq	.+84     	; 0x2eb8 <PM_InterpretAVRISPPacket+0x45e>
    2e64:	80 91 4b 02 	lds	r24, 0x024B
    2e68:	81 30       	cpi	r24, 0x01	; 1
    2e6a:	29 f4       	brne	.+10     	; 0x2e76 <PM_InterpretAVRISPPacket+0x41c>
    2e6c:	20 91 08 01 	lds	r18, 0x0108
    2e70:	30 91 09 01 	lds	r19, 0x0109
    2e74:	04 c0       	rjmp	.+8      	; 0x2e7e <PM_InterpretAVRISPPacket+0x424>
    2e76:	20 91 06 01 	lds	r18, 0x0106
    2e7a:	30 91 07 01 	lds	r19, 0x0107
    2e7e:	3a 83       	std	Y+2, r19	; 0x02
    2e80:	29 83       	std	Y+1, r18	; 0x01
    2e82:	85 2f       	mov	r24, r21
    2e84:	99 27       	eor	r25, r25
    2e86:	68 2f       	mov	r22, r24
    2e88:	ce 01       	movw	r24, r28
    2e8a:	01 96       	adiw	r24, 0x01	; 1
    2e8c:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
    2e90:	89 81       	ldd	r24, Y+1	; 0x01
    2e92:	9a 81       	ldd	r25, Y+2	; 0x02
    2e94:	01 96       	adiw	r24, 0x01	; 1
    2e96:	9a 83       	std	Y+2, r25	; 0x02
    2e98:	89 83       	std	Y+1, r24	; 0x01
    2e9a:	60 91 48 02 	lds	r22, 0x0248
    2e9e:	ce 01       	movw	r24, r28
    2ea0:	01 96       	adiw	r24, 0x01	; 1
    2ea2:	0e 94 c9 08 	call	0x1192 <eeprom_write_byte_169>
    2ea6:	80 91 48 02 	lds	r24, 0x0248
    2eaa:	90 91 49 02 	lds	r25, 0x0249
    2eae:	90 68       	ori	r25, 0x80	; 128
    2eb0:	90 93 49 02 	sts	0x0249, r25
    2eb4:	80 93 48 02 	sts	0x0248, r24
    2eb8:	10 92 35 01 	sts	0x0135, r1
    2ebc:	7d c0       	rjmp	.+250    	; 0x2fb8 <PM_InterpretAVRISPPacket+0x55e>
    2ebe:	80 91 4a 02 	lds	r24, 0x024A
    2ec2:	82 30       	cpi	r24, 0x02	; 2
    2ec4:	11 f1       	breq	.+68     	; 0x2f0a <PM_InterpretAVRISPPacket+0x4b0>
    2ec6:	0e 94 74 14 	call	0x28e8 <PM_CheckEndOfProgramming>
    2eca:	0e 94 01 15 	call	0x2a02 <PM_CheckEndOfFuseLockStore>
    2ece:	90 e0       	ldi	r25, 0x00	; 0
    2ed0:	80 91 34 01 	lds	r24, 0x0134
    2ed4:	84 31       	cpi	r24, 0x14	; 20
    2ed6:	09 f4       	brne	.+2      	; 0x2eda <PM_InterpretAVRISPPacket+0x480>
    2ed8:	91 e0       	ldi	r25, 0x01	; 1
    2eda:	89 2f       	mov	r24, r25
    2edc:	0e 94 f7 13 	call	0x27ee <PM_SetupDFAddressCounters>
    2ee0:	60 91 85 02 	lds	r22, 0x0285
    2ee4:	70 91 86 02 	lds	r23, 0x0286
    2ee8:	80 91 8c 02 	lds	r24, 0x028C
    2eec:	90 91 8d 02 	lds	r25, 0x028D
    2ef0:	0e 94 20 0a 	call	0x1440 <DF_ContinuousReadEnable>
    2ef4:	82 e0       	ldi	r24, 0x02	; 2
    2ef6:	80 93 4a 02 	sts	0x024A, r24
    2efa:	10 92 2b 01 	sts	0x012B, r1
    2efe:	10 92 2c 01 	sts	0x012C, r1
    2f02:	10 92 2d 01 	sts	0x012D, r1
    2f06:	10 92 2e 01 	sts	0x012E, r1
    2f0a:	80 91 35 01 	lds	r24, 0x0135
    2f0e:	99 27       	eor	r25, r25
    2f10:	18 2f       	mov	r17, r24
    2f12:	00 27       	eor	r16, r16
    2f14:	80 91 36 01 	lds	r24, 0x0136
    2f18:	99 27       	eor	r25, r25
    2f1a:	08 2b       	or	r16, r24
    2f1c:	19 2b       	or	r17, r25
    2f1e:	90 e0       	ldi	r25, 0x00	; 0
    2f20:	80 91 34 01 	lds	r24, 0x0134
    2f24:	84 31       	cpi	r24, 0x14	; 20
    2f26:	09 f4       	brne	.+2      	; 0x2f2a <PM_InterpretAVRISPPacket+0x4d0>
    2f28:	91 e0       	ldi	r25, 0x01	; 1
    2f2a:	89 2f       	mov	r24, r25
    2f2c:	0e 94 7f 13 	call	0x26fe <PM_GetStoredDataSize>
    2f30:	dc 01       	movw	r26, r24
    2f32:	cb 01       	movw	r24, r22
    2f34:	6c 01       	movw	r12, r24
    2f36:	ee 24       	eor	r14, r14
    2f38:	ff 24       	eor	r15, r15
    2f3a:	e0 16       	cp	r14, r16
    2f3c:	f1 06       	cpc	r15, r17
    2f3e:	20 f5       	brcc	.+72     	; 0x2f88 <PM_InterpretAVRISPPacket+0x52e>
    2f40:	f6 e3       	ldi	r31, 0x36	; 54
    2f42:	af 2e       	mov	r10, r31
    2f44:	f1 e0       	ldi	r31, 0x01	; 1
    2f46:	bf 2e       	mov	r11, r31
    2f48:	96 01       	movw	r18, r12
    2f4a:	44 27       	eor	r20, r20
    2f4c:	55 27       	eor	r21, r21
    2f4e:	80 91 2b 01 	lds	r24, 0x012B
    2f52:	90 91 2c 01 	lds	r25, 0x012C
    2f56:	a0 91 2d 01 	lds	r26, 0x012D
    2f5a:	b0 91 2e 01 	lds	r27, 0x012E
    2f5e:	82 17       	cp	r24, r18
    2f60:	93 07       	cpc	r25, r19
    2f62:	a4 07       	cpc	r26, r20
    2f64:	b5 07       	cpc	r27, r21
    2f66:	20 f4       	brcc	.+8      	; 0x2f70 <PM_InterpretAVRISPPacket+0x516>
    2f68:	80 e0       	ldi	r24, 0x00	; 0
    2f6a:	0e 94 47 09 	call	0x128e <SPI_SPITransmit>
    2f6e:	01 c0       	rjmp	.+2      	; 0x2f72 <PM_InterpretAVRISPPacket+0x518>
    2f70:	8f ef       	ldi	r24, 0xFF	; 255
    2f72:	f5 01       	movw	r30, r10
    2f74:	81 93       	st	Z+, r24
    2f76:	5f 01       	movw	r10, r30
    2f78:	0e 94 cf 0e 	call	0x1d9e <V2P_IncrementCurrAddress>
    2f7c:	08 94       	sec
    2f7e:	e1 1c       	adc	r14, r1
    2f80:	f1 1c       	adc	r15, r1
    2f82:	e0 16       	cp	r14, r16
    2f84:	f1 06       	cpc	r15, r17
    2f86:	00 f3       	brcs	.-64     	; 0x2f48 <PM_InterpretAVRISPPacket+0x4ee>
    2f88:	0d 5f       	subi	r16, 0xFD	; 253
    2f8a:	1f 4f       	sbci	r17, 0xFF	; 255
    2f8c:	10 93 31 01 	sts	0x0131, r17
    2f90:	00 93 30 01 	sts	0x0130, r16
    2f94:	03 50       	subi	r16, 0x03	; 3
    2f96:	10 40       	sbci	r17, 0x00	; 0
    2f98:	10 92 35 01 	sts	0x0135, r1
    2f9c:	0c 5c       	subi	r16, 0xCC	; 204
    2f9e:	1e 4f       	sbci	r17, 0xFE	; 254
    2fa0:	f8 01       	movw	r30, r16
    2fa2:	12 82       	std	Z+2, r1	; 0x02
    2fa4:	09 c0       	rjmp	.+18     	; 0x2fb8 <PM_InterpretAVRISPPacket+0x55e>
    2fa6:	81 e0       	ldi	r24, 0x01	; 1
    2fa8:	90 e0       	ldi	r25, 0x00	; 0
    2faa:	90 93 31 01 	sts	0x0131, r25
    2fae:	80 93 30 01 	sts	0x0130, r24
    2fb2:	89 ec       	ldi	r24, 0xC9	; 201
    2fb4:	80 93 35 01 	sts	0x0135, r24
    2fb8:	0e 94 f5 0d 	call	0x1bea <V2P_SendPacket>
    2fbc:	22 96       	adiw	r28, 0x02	; 2
    2fbe:	0f b6       	in	r0, 0x3f	; 63
    2fc0:	f8 94       	cli
    2fc2:	de bf       	out	0x3e, r29	; 62
    2fc4:	0f be       	out	0x3f, r0	; 63
    2fc6:	cd bf       	out	0x3d, r28	; 61
    2fc8:	df 91       	pop	r29
    2fca:	cf 91       	pop	r28
    2fcc:	1f 91       	pop	r17
    2fce:	0f 91       	pop	r16
    2fd0:	ff 90       	pop	r15
    2fd2:	ef 90       	pop	r14
    2fd4:	df 90       	pop	r13
    2fd6:	cf 90       	pop	r12
    2fd8:	bf 90       	pop	r11
    2fda:	af 90       	pop	r10
    2fdc:	08 95       	ret

00002fde <PM_SendFuseLockBytes>:
	}
}

void PM_SendFuseLockBytes(uint8_t Type)
{
    2fde:	0f 93       	push	r16
    2fe0:	1f 93       	push	r17
    2fe2:	cf 93       	push	r28
    2fe4:	df 93       	push	r29
    2fe6:	cd b7       	in	r28, 0x3d	; 61
    2fe8:	de b7       	in	r29, 0x3e	; 62
    2fea:	22 97       	sbiw	r28, 0x02	; 2
    2fec:	0f b6       	in	r0, 0x3f	; 63
    2fee:	f8 94       	cli
    2ff0:	de bf       	out	0x3e, r29	; 62
    2ff2:	0f be       	out	0x3f, r0	; 63
    2ff4:	cd bf       	out	0x3d, r28	; 61
    2ff6:	08 2f       	mov	r16, r24
	uint16_t EEPROMAddress;
	uint8_t  TotalBytes;
	
	EEPROMAddress = ((Type == TYPE_FUSE)? Prog_TotalFuseBytes : Prog_TotalLockBytes);
    2ff8:	82 30       	cpi	r24, 0x02	; 2
    2ffa:	29 f4       	brne	.+10     	; 0x3006 <PM_SendFuseLockBytes+0x28>
    2ffc:	80 91 10 01 	lds	r24, 0x0110
    3000:	90 91 11 01 	lds	r25, 0x0111
    3004:	04 c0       	rjmp	.+8      	; 0x300e <PM_SendFuseLockBytes+0x30>
    3006:	80 91 0e 01 	lds	r24, 0x010E
    300a:	90 91 0f 01 	lds	r25, 0x010F
    300e:	9a 83       	std	Y+2, r25	; 0x02
    3010:	89 83       	std	Y+1, r24	; 0x01

	TotalBytes = eeprom_read_byte_169(&EEPROMAddress); // Get the total number of stored fuse/lock bytes
    3012:	ce 01       	movw	r24, r28
    3014:	01 96       	adiw	r24, 0x01	; 1
    3016:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
    301a:	18 2f       	mov	r17, r24
			
	EEPROMAddress = ((Type == TYPE_FUSE)? Prog_FuseBytes : Prog_LockBytes); // Set the EEPROM pointer to the fuse/lock bytes start (each fuse or lock byte takes four bytes in EEPROM)
    301c:	02 30       	cpi	r16, 0x02	; 2
    301e:	29 f4       	brne	.+10     	; 0x302a <PM_SendFuseLockBytes+0x4c>
    3020:	80 91 0c 01 	lds	r24, 0x010C
    3024:	90 91 0d 01 	lds	r25, 0x010D
    3028:	04 c0       	rjmp	.+8      	; 0x3032 <PM_SendFuseLockBytes+0x54>
    302a:	80 91 0a 01 	lds	r24, 0x010A
    302e:	90 91 0b 01 	lds	r25, 0x010B
    3032:	9a 83       	std	Y+2, r25	; 0x02
    3034:	89 83       	std	Y+1, r24	; 0x01

	while (TotalBytes--)                              // Write each of the fuse/lock bytes stored in memory to the slave AVR
	{
		for (uint8_t CommandByte = 0; CommandByte < 4; CommandByte++)      // Write each individual command byte
		{
			USI_SPITransmit(eeprom_read_byte_169(&EEPROMAddress));
			EEPROMAddress++;
		}
		
		// Add some delay before programming next byte, if there is one:
		if (TotalBytes)
		   MAIN_Delay10MS(5);
    3036:	11 50       	subi	r17, 0x01	; 1
    3038:	1f 3f       	cpi	r17, 0xFF	; 255
    303a:	b1 f0       	breq	.+44     	; 0x3068 <PM_SendFuseLockBytes+0x8a>
    303c:	03 e0       	ldi	r16, 0x03	; 3
    303e:	ce 01       	movw	r24, r28
    3040:	01 96       	adiw	r24, 0x01	; 1
    3042:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
    3046:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    304a:	89 81       	ldd	r24, Y+1	; 0x01
    304c:	9a 81       	ldd	r25, Y+2	; 0x02
    304e:	01 96       	adiw	r24, 0x01	; 1
    3050:	9a 83       	std	Y+2, r25	; 0x02
    3052:	89 83       	std	Y+1, r24	; 0x01
    3054:	01 50       	subi	r16, 0x01	; 1
    3056:	07 ff       	sbrs	r16, 7
    3058:	f2 cf       	rjmp	.-28     	; 0x303e <PM_SendFuseLockBytes+0x60>
    305a:	11 23       	and	r17, r17
    305c:	19 f0       	breq	.+6      	; 0x3064 <PM_SendFuseLockBytes+0x86>
    305e:	85 e0       	ldi	r24, 0x05	; 5
    3060:	0e 94 2f 02 	call	0x45e <MAIN_Delay10MS>
    3064:	11 50       	subi	r17, 0x01	; 1
    3066:	50 f7       	brcc	.-44     	; 0x303c <PM_SendFuseLockBytes+0x5e>
    3068:	22 96       	adiw	r28, 0x02	; 2
    306a:	0f b6       	in	r0, 0x3f	; 63
    306c:	f8 94       	cli
    306e:	de bf       	out	0x3e, r29	; 62
    3070:	0f be       	out	0x3f, r0	; 63
    3072:	cd bf       	out	0x3d, r28	; 61
    3074:	df 91       	pop	r29
    3076:	cf 91       	pop	r28
    3078:	1f 91       	pop	r17
    307a:	0f 91       	pop	r16
    307c:	08 95       	ret

0000307e <PM_SendEraseCommand>:
	}
}

void PM_SendEraseCommand(void)
{
    307e:	0f 93       	push	r16
    3080:	1f 93       	push	r17
    3082:	cf 93       	push	r28
    3084:	df 93       	push	r29
    3086:	cd b7       	in	r28, 0x3d	; 61
    3088:	de b7       	in	r29, 0x3e	; 62
    308a:	22 97       	sbiw	r28, 0x02	; 2
    308c:	0f b6       	in	r0, 0x3f	; 63
    308e:	f8 94       	cli
    3090:	de bf       	out	0x3e, r29	; 62
    3092:	0f be       	out	0x3f, r0	; 63
    3094:	cd bf       	out	0x3d, r28	; 61
	uint16_t EEPROMAddress;

	EEPROMAddress = Prog_EraseChip + 2;               // Start of the erase commands
    3096:	80 91 18 01 	lds	r24, 0x0118
    309a:	90 91 19 01 	lds	r25, 0x0119
    309e:	02 96       	adiw	r24, 0x02	; 2
    30a0:	9a 83       	std	Y+2, r25	; 0x02
    30a2:	89 83       	std	Y+1, r24	; 0x01
    30a4:	13 e0       	ldi	r17, 0x03	; 3
			
	for (uint8_t B = 0; B < 4 ; B++)                  // Read out the erase chip command bytes
	{
		USI_SPITransmit(eeprom_read_byte_169(&EEPROMAddress)); // Send the erase chip commands
    30a6:	ce 01       	movw	r24, r28
    30a8:	01 96       	adiw	r24, 0x01	; 1
    30aa:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
    30ae:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
		EEPROMAddress++;
    30b2:	89 81       	ldd	r24, Y+1	; 0x01
    30b4:	9a 81       	ldd	r25, Y+2	; 0x02
    30b6:	01 96       	adiw	r24, 0x01	; 1
    30b8:	9a 83       	std	Y+2, r25	; 0x02
    30ba:	89 83       	std	Y+1, r24	; 0x01
    30bc:	11 50       	subi	r17, 0x01	; 1
    30be:	17 ff       	sbrs	r17, 7
    30c0:	f2 cf       	rjmp	.-28     	; 0x30a6 <PM_SendEraseCommand+0x28>
	}
			
	EEPROMAddress = Prog_EraseChip + 1;               // Poll mode flag address
    30c2:	00 91 18 01 	lds	r16, 0x0118
    30c6:	10 91 19 01 	lds	r17, 0x0119
    30ca:	0f 5f       	subi	r16, 0xFF	; 255
    30cc:	1f 4f       	sbci	r17, 0xFF	; 255
    30ce:	1a 83       	std	Y+2, r17	; 0x02
    30d0:	09 83       	std	Y+1, r16	; 0x01
    30d2:	01 50       	subi	r16, 0x01	; 1
    30d4:	10 40       	sbci	r17, 0x00	; 0
	if (eeprom_read_byte_169(&EEPROMAddress))         // Value of 1 indicates a busy flag test
    30d6:	ce 01       	movw	r24, r28
    30d8:	01 96       	adiw	r24, 0x01	; 1
    30da:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
    30de:	88 23       	and	r24, r24
    30e0:	59 f0       	breq	.+22     	; 0x30f8 <PM_SendEraseCommand+0x7a>
	{
		do
			USI_SPITransmitWord(0xF000);
    30e2:	80 e0       	ldi	r24, 0x00	; 0
    30e4:	90 ef       	ldi	r25, 0xF0	; 240
    30e6:	0e 94 bf 09 	call	0x137e <USI_SPITransmitWord>
    30ea:	80 e0       	ldi	r24, 0x00	; 0
    30ec:	90 e0       	ldi	r25, 0x00	; 0
    30ee:	0e 94 bf 09 	call	0x137e <USI_SPITransmitWord>
    30f2:	80 fd       	sbrc	r24, 0
    30f4:	f6 cf       	rjmp	.-20     	; 0x30e2 <PM_SendEraseCommand+0x64>
    30f6:	08 c0       	rjmp	.+16     	; 0x3108 <PM_SendEraseCommand+0x8a>
		while (USI_SPITransmitWord(0x0000) & 0x01);
	}
	else                                              // Cleared flag means use a predefined delay
	{
		EEPROMAddress = Prog_EraseChip;               // Delay value address			
    30f8:	1a 83       	std	Y+2, r17	; 0x02
    30fa:	09 83       	std	Y+1, r16	; 0x01
		MAIN_Delay1MS(eeprom_read_byte_169(&EEPROMAddress)); // Wait the erase delay
    30fc:	ce 01       	movw	r24, r28
    30fe:	01 96       	adiw	r24, 0x01	; 1
    3100:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
    3104:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    3108:	22 96       	adiw	r28, 0x02	; 2
    310a:	0f b6       	in	r0, 0x3f	; 63
    310c:	f8 94       	cli
    310e:	de bf       	out	0x3e, r29	; 62
    3110:	0f be       	out	0x3f, r0	; 63
    3112:	cd bf       	out	0x3d, r28	; 61
    3114:	df 91       	pop	r29
    3116:	cf 91       	pop	r28
    3118:	1f 91       	pop	r17
    311a:	0f 91       	pop	r16
    311c:	08 95       	ret

0000311e <PM_CreateProgrammingPackets>:
	}
}

void PM_CreateProgrammingPackets(uint8_t Type)
{			
    311e:	2f 92       	push	r2
    3120:	3f 92       	push	r3
    3122:	4f 92       	push	r4
    3124:	5f 92       	push	r5
    3126:	6f 92       	push	r6
    3128:	7f 92       	push	r7
    312a:	8f 92       	push	r8
    312c:	9f 92       	push	r9
    312e:	af 92       	push	r10
    3130:	bf 92       	push	r11
    3132:	cf 92       	push	r12
    3134:	df 92       	push	r13
    3136:	ef 92       	push	r14
    3138:	ff 92       	push	r15
    313a:	0f 93       	push	r16
    313c:	1f 93       	push	r17
    313e:	cf 93       	push	r28
    3140:	df 93       	push	r29
    3142:	cd b7       	in	r28, 0x3d	; 61
    3144:	de b7       	in	r29, 0x3e	; 62
    3146:	23 97       	sbiw	r28, 0x03	; 3
    3148:	0f b6       	in	r0, 0x3f	; 63
    314a:	f8 94       	cli
    314c:	de bf       	out	0x3e, r29	; 62
    314e:	0f be       	out	0x3f, r0	; 63
    3150:	cd bf       	out	0x3d, r28	; 61
    3152:	18 2f       	mov	r17, r24
	uint32_t BytesRead       = 0;
    3154:	88 24       	eor	r8, r8
    3156:	99 24       	eor	r9, r9
    3158:	54 01       	movw	r10, r8
	uint32_t BytesToRead     = PM_GetStoredDataSize(Type);      // Get the byte size of the stored program
    315a:	0e 94 7f 13 	call	0x26fe <PM_GetStoredDataSize>
    315e:	1b 01       	movw	r2, r22
    3160:	2c 01       	movw	r4, r24
	uint16_t BytesPerProgram;
	uint16_t EEPROMAddress;
	uint16_t PageLength;
	uint8_t  ContinuedPage   = FALSE;
    3162:	1b 82       	std	Y+3, r1	; 0x03

	EEPROMAddress = ((Type == TYPE_FLASH)? Prog_PageLength : Prog_EPageLength);
    3164:	11 30       	cpi	r17, 0x01	; 1
    3166:	29 f4       	brne	.+10     	; 0x3172 <PM_CreateProgrammingPackets+0x54>
    3168:	80 91 08 01 	lds	r24, 0x0108
    316c:	90 91 09 01 	lds	r25, 0x0109
    3170:	04 c0       	rjmp	.+8      	; 0x317a <PM_CreateProgrammingPackets+0x5c>
    3172:	80 91 06 01 	lds	r24, 0x0106
    3176:	90 91 07 01 	lds	r25, 0x0107
    317a:	9a 83       	std	Y+2, r25	; 0x02
    317c:	89 83       	std	Y+1, r24	; 0x01
	PageLength    = ((uint16_t)eeprom_read_byte_169(&EEPROMAddress) << 8);
    317e:	ce 01       	movw	r24, r28
    3180:	01 96       	adiw	r24, 0x01	; 1
    3182:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
    3186:	99 27       	eor	r25, r25
    3188:	78 2e       	mov	r7, r24
    318a:	66 24       	eor	r6, r6
	EEPROMAddress++;
    318c:	89 81       	ldd	r24, Y+1	; 0x01
    318e:	9a 81       	ldd	r25, Y+2	; 0x02
    3190:	01 96       	adiw	r24, 0x01	; 1
    3192:	9a 83       	std	Y+2, r25	; 0x02
    3194:	89 83       	std	Y+1, r24	; 0x01
	PageLength   |= (eeprom_read_byte_169(&EEPROMAddress));
    3196:	ce 01       	movw	r24, r28
    3198:	01 96       	adiw	r24, 0x01	; 1
    319a:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
    319e:	99 27       	eor	r25, r25
    31a0:	68 2a       	or	r6, r24
    31a2:	79 2a       	or	r7, r25
	
	CurrAddress = 0;
    31a4:	10 92 2b 01 	sts	0x012B, r1
    31a8:	10 92 2c 01 	sts	0x012C, r1
    31ac:	10 92 2d 01 	sts	0x012D, r1
    31b0:	10 92 2e 01 	sts	0x012E, r1

	if (Type == TYPE_FLASH)
    31b4:	11 30       	cpi	r17, 0x01	; 1
    31b6:	69 f4       	brne	.+26     	; 0x31d2 <PM_CreateProgrammingPackets+0xb4>
	{
		EEPROMAddress = Prog_WriteProgram;             // Set the EEPROM pointer to the write flash command bytes location
    31b8:	80 91 1e 01 	lds	r24, 0x011E
    31bc:	90 91 1f 01 	lds	r25, 0x011F
    31c0:	9a 83       	std	Y+2, r25	; 0x02
    31c2:	89 83       	std	Y+1, r24	; 0x01
		DF_ContinuousReadEnable(0, 0);
    31c4:	60 e0       	ldi	r22, 0x00	; 0
    31c6:	70 e0       	ldi	r23, 0x00	; 0
    31c8:	cb 01       	movw	r24, r22
    31ca:	0e 94 20 0a 	call	0x1440 <DF_ContinuousReadEnable>
		PacketBytes[0] = CMD_PROGRAM_FLASH_ISP;
    31ce:	83 e1       	ldi	r24, 0x13	; 19
    31d0:	0d c0       	rjmp	.+26     	; 0x31ec <PM_CreateProgrammingPackets+0xce>
	}
	else
	{
		EEPROMAddress = Prog_WriteEEPROM;              // Set the EEPROM pointer to the write EEPROM command bytes location
    31d2:	80 91 1c 01 	lds	r24, 0x011C
    31d6:	90 91 1d 01 	lds	r25, 0x011D
    31da:	9a 83       	std	Y+2, r25	; 0x02
    31dc:	89 83       	std	Y+1, r24	; 0x01
		DF_ContinuousReadEnable(PM_EEPROM_OFFSET / DF_INTERNALDF_BUFFBYTES, PM_EEPROM_OFFSET % DF_INTERNALDF_BUFFBYTES); // Start read from the EEPROM offset location
    31de:	60 ee       	ldi	r22, 0xE0	; 224
    31e0:	70 e0       	ldi	r23, 0x00	; 0
    31e2:	84 ee       	ldi	r24, 0xE4	; 228
    31e4:	93 e0       	ldi	r25, 0x03	; 3
    31e6:	0e 94 20 0a 	call	0x1440 <DF_ContinuousReadEnable>
		PacketBytes[0] = CMD_PROGRAM_EEPROM_ISP;
    31ea:	85 e1       	ldi	r24, 0x15	; 21
    31ec:	80 93 34 01 	sts	0x0134, r24
    31f0:	f5 e3       	ldi	r31, 0x35	; 53
    31f2:	ef 2e       	mov	r14, r31
    31f4:	f1 e0       	ldi	r31, 0x01	; 1
    31f6:	ff 2e       	mov	r15, r31
    31f8:	18 e0       	ldi	r17, 0x08	; 8
	}

	for (uint8_t B = 1; B <= 9 ; B++)                 // Load in the write data command bytes
	{
		PacketBytes[B] = eeprom_read_byte_169(&EEPROMAddress); // Synthesise a write packet header
    31fa:	ce 01       	movw	r24, r28
    31fc:	01 96       	adiw	r24, 0x01	; 1
    31fe:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
    3202:	f7 01       	movw	r30, r14
    3204:	81 93       	st	Z+, r24
    3206:	7f 01       	movw	r14, r30
		EEPROMAddress++;                               // Increment the EEPROM location counter
    3208:	89 81       	ldd	r24, Y+1	; 0x01
    320a:	9a 81       	ldd	r25, Y+2	; 0x02
    320c:	01 96       	adiw	r24, 0x01	; 1
    320e:	9a 83       	std	Y+2, r25	; 0x02
    3210:	89 83       	std	Y+1, r24	; 0x01
    3212:	11 50       	subi	r17, 0x01	; 1
    3214:	17 ff       	sbrs	r17, 7
    3216:	f1 cf       	rjmp	.-30     	; 0x31fa <PM_CreateProgrammingPackets+0xdc>
	}
	
	BytesPerProgram = ((uint16_t)PacketBytes[1] << 8)
    3218:	80 91 35 01 	lds	r24, 0x0135
    321c:	99 27       	eor	r25, r25
    321e:	d8 2e       	mov	r13, r24
    3220:	cc 24       	eor	r12, r12
    3222:	80 91 36 01 	lds	r24, 0x0136
    3226:	99 27       	eor	r25, r25
    3228:	c8 2a       	or	r12, r24
    322a:	d9 2a       	or	r13, r25
	                | PacketBytes[2];

	while (BytesRead < BytesToRead)
	{
		if (PacketBytes[3] & ISPCC_PROG_MODE_PAGE)
		{
			if (PageLength > 160) // Max 160 bytes at a time
			{
				if (!(ContinuedPage))                      // Start of a new page, program in the first 150 bytes
				{
					BytesPerProgram = 160;
					PacketBytes[3] &= ~ISPCC_PROG_MODE_PAGEDONE;		
					ContinuedPage = TRUE;
				}
				else                                       // Middle of a page, program in the remainder
				{
					BytesPerProgram = PageLength - 160;
					PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
					ContinuedPage = FALSE;
				}
				
				for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page				

				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);
				PacketBytes[2] = (uint8_t)(BytesPerProgram);

				BytesRead += BytesPerProgram;                         // Increment the counter
			}
			else
			{
				for (uint16_t LoadB = 0; LoadB < PageLength; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page
			
				PacketBytes[1]  = (uint8_t)(PageLength >> 8);
				PacketBytes[2]  = (uint8_t)(PageLength);
				PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;

				BytesRead     += PageLength;                          // Increment the counter
			}
		}
		else
		{
			if ((BytesRead + BytesPerProgram) > BytesToRead)        // Less than a whole BytesPerProgram left of data to write
			{
				BytesPerProgram = BytesToRead - BytesRead;          // Next lot of bytes will be the remaining data length
				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);   // \. Save the new length
				PacketBytes[2] = (uint8_t)(BytesPerProgram);        // /  into the data packet
			}

			for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
				PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);    // Load in the page
			
			BytesRead += BytesPerProgram;                           // Increment the counter
		}
	
		if (!(BytesRead & 0xFFFF) && (BytesRead & 0x00FF0000))      // Extended address required
		{
			USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);            // Load extended address command
			USI_SPITransmit(0x00);
			USI_SPITransmit((BytesRead & 0x00FF0000) >> 16);        // The 3rd byte of the long holds the extended address
			USI_SPITransmit(0x00);
		}

		ISPCC_ProgramChip();                                        // Start the program cycle
    322c:	82 14       	cp	r8, r2
    322e:	93 04       	cpc	r9, r3
    3230:	a4 04       	cpc	r10, r4
    3232:	b5 04       	cpc	r11, r5
    3234:	08 f0       	brcs	.+2      	; 0x3238 <PM_CreateProgrammingPackets+0x11a>
    3236:	b7 c0       	rjmp	.+366    	; 0x33a6 <PM_CreateProgrammingPackets+0x288>
    3238:	20 91 37 01 	lds	r18, 0x0137
    323c:	82 2f       	mov	r24, r18
    323e:	99 27       	eor	r25, r25
    3240:	ac 01       	movw	r20, r24
    3242:	41 70       	andi	r20, 0x01	; 1
    3244:	50 70       	andi	r21, 0x00	; 0
    3246:	80 ff       	sbrs	r24, 0
    3248:	58 c0       	rjmp	.+176    	; 0x32fa <PM_CreateProgrammingPackets+0x1dc>
    324a:	f1 ea       	ldi	r31, 0xA1	; 161
    324c:	6f 16       	cp	r6, r31
    324e:	71 04       	cpc	r7, r1
    3250:	88 f1       	brcs	.+98     	; 0x32b4 <PM_CreateProgrammingPackets+0x196>
    3252:	8b 81       	ldd	r24, Y+3	; 0x03
    3254:	88 23       	and	r24, r24
    3256:	49 f4       	brne	.+18     	; 0x326a <PM_CreateProgrammingPackets+0x14c>
    3258:	70 ea       	ldi	r23, 0xA0	; 160
    325a:	c7 2e       	mov	r12, r23
    325c:	d1 2c       	mov	r13, r1
    325e:	2f 77       	andi	r18, 0x7F	; 127
    3260:	20 93 37 01 	sts	0x0137, r18
    3264:	e1 e0       	ldi	r30, 0x01	; 1
    3266:	eb 83       	std	Y+3, r30	; 0x03
    3268:	0a c0       	rjmp	.+20     	; 0x327e <PM_CreateProgrammingPackets+0x160>
    326a:	60 e6       	ldi	r22, 0x60	; 96
    326c:	c6 2e       	mov	r12, r22
    326e:	6f ef       	ldi	r22, 0xFF	; 255
    3270:	d6 2e       	mov	r13, r22
    3272:	c6 0c       	add	r12, r6
    3274:	d7 1c       	adc	r13, r7
    3276:	20 68       	ori	r18, 0x80	; 128
    3278:	20 93 37 01 	sts	0x0137, r18
    327c:	1b 82       	std	Y+3, r1	; 0x03
    327e:	00 e0       	ldi	r16, 0x00	; 0
    3280:	10 e0       	ldi	r17, 0x00	; 0
    3282:	0c 15       	cp	r16, r12
    3284:	1d 05       	cpc	r17, r13
    3286:	78 f4       	brcc	.+30     	; 0x32a6 <PM_CreateProgrammingPackets+0x188>
    3288:	5e e3       	ldi	r21, 0x3E	; 62
    328a:	e5 2e       	mov	r14, r21
    328c:	51 e0       	ldi	r21, 0x01	; 1
    328e:	f5 2e       	mov	r15, r21
    3290:	80 e0       	ldi	r24, 0x00	; 0
    3292:	0e 94 47 09 	call	0x128e <SPI_SPITransmit>
    3296:	f7 01       	movw	r30, r14
    3298:	81 93       	st	Z+, r24
    329a:	7f 01       	movw	r14, r30
    329c:	0f 5f       	subi	r16, 0xFF	; 255
    329e:	1f 4f       	sbci	r17, 0xFF	; 255
    32a0:	0c 15       	cp	r16, r12
    32a2:	1d 05       	cpc	r17, r13
    32a4:	a8 f3       	brcs	.-22     	; 0x3290 <PM_CreateProgrammingPackets+0x172>
    32a6:	8d 2d       	mov	r24, r13
    32a8:	99 27       	eor	r25, r25
    32aa:	80 93 35 01 	sts	0x0135, r24
    32ae:	c0 92 36 01 	sts	0x0136, r12
    32b2:	4b c0       	rjmp	.+150    	; 0x334a <PM_CreateProgrammingPackets+0x22c>
    32b4:	00 e0       	ldi	r16, 0x00	; 0
    32b6:	10 e0       	ldi	r17, 0x00	; 0
    32b8:	06 15       	cp	r16, r6
    32ba:	17 05       	cpc	r17, r7
    32bc:	78 f4       	brcc	.+30     	; 0x32dc <PM_CreateProgrammingPackets+0x1be>
    32be:	3e e3       	ldi	r19, 0x3E	; 62
    32c0:	e3 2e       	mov	r14, r19
    32c2:	31 e0       	ldi	r19, 0x01	; 1
    32c4:	f3 2e       	mov	r15, r19
    32c6:	80 e0       	ldi	r24, 0x00	; 0
    32c8:	0e 94 47 09 	call	0x128e <SPI_SPITransmit>
    32cc:	f7 01       	movw	r30, r14
    32ce:	81 93       	st	Z+, r24
    32d0:	7f 01       	movw	r14, r30
    32d2:	0f 5f       	subi	r16, 0xFF	; 255
    32d4:	1f 4f       	sbci	r17, 0xFF	; 255
    32d6:	06 15       	cp	r16, r6
    32d8:	17 05       	cpc	r17, r7
    32da:	a8 f3       	brcs	.-22     	; 0x32c6 <PM_CreateProgrammingPackets+0x1a8>
    32dc:	87 2d       	mov	r24, r7
    32de:	99 27       	eor	r25, r25
    32e0:	80 93 35 01 	sts	0x0135, r24
    32e4:	60 92 36 01 	sts	0x0136, r6
    32e8:	80 91 37 01 	lds	r24, 0x0137
    32ec:	80 68       	ori	r24, 0x80	; 128
    32ee:	80 93 37 01 	sts	0x0137, r24
    32f2:	c3 01       	movw	r24, r6
    32f4:	aa 27       	eor	r26, r26
    32f6:	bb 27       	eor	r27, r27
    32f8:	2b c0       	rjmp	.+86     	; 0x3350 <PM_CreateProgrammingPackets+0x232>
    32fa:	c6 01       	movw	r24, r12
    32fc:	aa 27       	eor	r26, r26
    32fe:	bb 27       	eor	r27, r27
    3300:	88 0d       	add	r24, r8
    3302:	99 1d       	adc	r25, r9
    3304:	aa 1d       	adc	r26, r10
    3306:	bb 1d       	adc	r27, r11
    3308:	28 16       	cp	r2, r24
    330a:	39 06       	cpc	r3, r25
    330c:	4a 06       	cpc	r4, r26
    330e:	5b 06       	cpc	r5, r27
    3310:	48 f4       	brcc	.+18     	; 0x3324 <PM_CreateProgrammingPackets+0x206>
    3312:	61 01       	movw	r12, r2
    3314:	c8 18       	sub	r12, r8
    3316:	d9 08       	sbc	r13, r9
    3318:	8d 2d       	mov	r24, r13
    331a:	99 27       	eor	r25, r25
    331c:	80 93 35 01 	sts	0x0135, r24
    3320:	c0 92 36 01 	sts	0x0136, r12
    3324:	8a 01       	movw	r16, r20
    3326:	4c 15       	cp	r20, r12
    3328:	5d 05       	cpc	r21, r13
    332a:	78 f4       	brcc	.+30     	; 0x334a <PM_CreateProgrammingPackets+0x22c>
    332c:	8e e3       	ldi	r24, 0x3E	; 62
    332e:	e8 2e       	mov	r14, r24
    3330:	81 e0       	ldi	r24, 0x01	; 1
    3332:	f8 2e       	mov	r15, r24
    3334:	80 e0       	ldi	r24, 0x00	; 0
    3336:	0e 94 47 09 	call	0x128e <SPI_SPITransmit>
    333a:	f7 01       	movw	r30, r14
    333c:	81 93       	st	Z+, r24
    333e:	7f 01       	movw	r14, r30
    3340:	0f 5f       	subi	r16, 0xFF	; 255
    3342:	1f 4f       	sbci	r17, 0xFF	; 255
    3344:	0c 15       	cp	r16, r12
    3346:	1d 05       	cpc	r17, r13
    3348:	a8 f3       	brcs	.-22     	; 0x3334 <PM_CreateProgrammingPackets+0x216>
    334a:	c6 01       	movw	r24, r12
    334c:	aa 27       	eor	r26, r26
    334e:	bb 27       	eor	r27, r27
    3350:	88 0e       	add	r8, r24
    3352:	99 1e       	adc	r9, r25
    3354:	aa 1e       	adc	r10, r26
    3356:	bb 1e       	adc	r11, r27
    3358:	81 14       	cp	r8, r1
    335a:	91 04       	cpc	r9, r1
    335c:	e1 f4       	brne	.+56     	; 0x3396 <PM_CreateProgrammingPackets+0x278>
    335e:	e1 2c       	mov	r14, r1
    3360:	f1 2c       	mov	r15, r1
    3362:	bf ef       	ldi	r27, 0xFF	; 255
    3364:	0b 2f       	mov	r16, r27
    3366:	11 2d       	mov	r17, r1
    3368:	e8 20       	and	r14, r8
    336a:	f9 20       	and	r15, r9
    336c:	0a 21       	and	r16, r10
    336e:	1b 21       	and	r17, r11
    3370:	e1 14       	cp	r14, r1
    3372:	f1 04       	cpc	r15, r1
    3374:	01 05       	cpc	r16, r1
    3376:	11 05       	cpc	r17, r1
    3378:	71 f0       	breq	.+28     	; 0x3396 <PM_CreateProgrammingPackets+0x278>
    337a:	8d e4       	ldi	r24, 0x4D	; 77
    337c:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    3380:	80 e0       	ldi	r24, 0x00	; 0
    3382:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    3386:	c8 01       	movw	r24, r16
    3388:	aa 27       	eor	r26, r26
    338a:	bb 27       	eor	r27, r27
    338c:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    3390:	80 e0       	ldi	r24, 0x00	; 0
    3392:	0e 94 ac 09 	call	0x1358 <USI_SPITransmit>
    3396:	0e 94 28 11 	call	0x2250 <ISPCC_ProgramChip>
    339a:	82 14       	cp	r8, r2
    339c:	93 04       	cpc	r9, r3
    339e:	a4 04       	cpc	r10, r4
    33a0:	b5 04       	cpc	r11, r5
    33a2:	08 f4       	brcc	.+2      	; 0x33a6 <PM_CreateProgrammingPackets+0x288>
    33a4:	49 cf       	rjmp	.-366    	; 0x3238 <PM_CreateProgrammingPackets+0x11a>
    33a6:	23 96       	adiw	r28, 0x03	; 3
    33a8:	0f b6       	in	r0, 0x3f	; 63
    33aa:	f8 94       	cli
    33ac:	de bf       	out	0x3e, r29	; 62
    33ae:	0f be       	out	0x3f, r0	; 63
    33b0:	cd bf       	out	0x3d, r28	; 61
    33b2:	df 91       	pop	r29
    33b4:	cf 91       	pop	r28
    33b6:	1f 91       	pop	r17
    33b8:	0f 91       	pop	r16
    33ba:	ff 90       	pop	r15
    33bc:	ef 90       	pop	r14
    33be:	df 90       	pop	r13
    33c0:	cf 90       	pop	r12
    33c2:	bf 90       	pop	r11
    33c4:	af 90       	pop	r10
    33c6:	9f 90       	pop	r9
    33c8:	8f 90       	pop	r8
    33ca:	7f 90       	pop	r7
    33cc:	6f 90       	pop	r6
    33ce:	5f 90       	pop	r5
    33d0:	4f 90       	pop	r4
    33d2:	3f 90       	pop	r3
    33d4:	2f 90       	pop	r2
    33d6:	08 95       	ret

000033d8 <PM_ShowStoredItemSizes>:
	}
}

void PM_ShowStoredItemSizes(void)
{
    33d8:	1f 93       	push	r17
    33da:	cf 93       	push	r28
    33dc:	df 93       	push	r29
    33de:	cd b7       	in	r28, 0x3d	; 61
    33e0:	de b7       	in	r29, 0x3e	; 62
    33e2:	2e 97       	sbiw	r28, 0x0e	; 14
    33e4:	0f b6       	in	r0, 0x3f	; 63
    33e6:	f8 94       	cli
    33e8:	de bf       	out	0x3e, r29	; 62
    33ea:	0f be       	out	0x3f, r0	; 63
    33ec:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[14];
	uint8_t ItemInfoIndex = 0;
    33ee:	10 e0       	ldi	r17, 0x00	; 0
	uint8_t TempB;
	
	JoyStatus = 1;
    33f0:	81 e0       	ldi	r24, 0x01	; 1
    33f2:	8e bb       	out	0x1e, r24	; 30
	
	while (1)
	{
		if (JoyStatus)                           // Joystick is in the non-center position
    33f4:	8e b3       	in	r24, 0x1e	; 30
    33f6:	88 23       	and	r24, r24
    33f8:	e9 f3       	breq	.-6      	; 0x33f4 <PM_ShowStoredItemSizes+0x1c>
		{
			if (JoyStatus & JOY_UP)              // Previous item
    33fa:	f6 9b       	sbis	0x1e, 6	; 30
    33fc:	06 c0       	rjmp	.+12     	; 0x340a <PM_ShowStoredItemSizes+0x32>
				(ItemInfoIndex == 0)? ItemInfoIndex = 3 : ItemInfoIndex--;
    33fe:	11 23       	and	r17, r17
    3400:	11 f4       	brne	.+4      	; 0x3406 <PM_ShowStoredItemSizes+0x2e>
    3402:	13 e0       	ldi	r17, 0x03	; 3
    3404:	0c c0       	rjmp	.+24     	; 0x341e <PM_ShowStoredItemSizes+0x46>
    3406:	11 50       	subi	r17, 0x01	; 1
    3408:	0a c0       	rjmp	.+20     	; 0x341e <PM_ShowStoredItemSizes+0x46>
			else if (JoyStatus & JOY_DOWN)      // Next item
    340a:	f7 9b       	sbis	0x1e, 7	; 30
    340c:	06 c0       	rjmp	.+12     	; 0x341a <PM_ShowStoredItemSizes+0x42>
				(ItemInfoIndex == 3)? ItemInfoIndex = 0 : ItemInfoIndex++;
    340e:	13 30       	cpi	r17, 0x03	; 3
    3410:	11 f4       	brne	.+4      	; 0x3416 <PM_ShowStoredItemSizes+0x3e>
    3412:	10 e0       	ldi	r17, 0x00	; 0
    3414:	04 c0       	rjmp	.+8      	; 0x341e <PM_ShowStoredItemSizes+0x46>
    3416:	1f 5f       	subi	r17, 0xFF	; 255
    3418:	02 c0       	rjmp	.+4      	; 0x341e <PM_ShowStoredItemSizes+0x46>
			else if (JoyStatus & JOY_LEFT)
    341a:	f2 99       	sbic	0x1e, 2	; 30
    341c:	53 c0       	rjmp	.+166    	; 0x34c4 <PM_ShowStoredItemSizes+0xec>
				return;
		
			switch (ItemInfoIndex)
    341e:	81 2f       	mov	r24, r17
    3420:	99 27       	eor	r25, r25
    3422:	81 30       	cpi	r24, 0x01	; 1
    3424:	91 05       	cpc	r25, r1
    3426:	a1 f0       	breq	.+40     	; 0x3450 <PM_ShowStoredItemSizes+0x78>
    3428:	82 30       	cpi	r24, 0x02	; 2
    342a:	91 05       	cpc	r25, r1
    342c:	1c f4       	brge	.+6      	; 0x3434 <PM_ShowStoredItemSizes+0x5c>
    342e:	89 2b       	or	r24, r25
    3430:	39 f0       	breq	.+14     	; 0x3440 <PM_ShowStoredItemSizes+0x68>
    3432:	41 c0       	rjmp	.+130    	; 0x34b6 <PM_ShowStoredItemSizes+0xde>
    3434:	82 30       	cpi	r24, 0x02	; 2
    3436:	91 05       	cpc	r25, r1
    3438:	01 f1       	breq	.+64     	; 0x347a <PM_ShowStoredItemSizes+0xa2>
    343a:	03 97       	sbiw	r24, 0x03	; 3
    343c:	39 f1       	breq	.+78     	; 0x348c <PM_ShowStoredItemSizes+0xb4>
    343e:	3b c0       	rjmp	.+118    	; 0x34b6 <PM_ShowStoredItemSizes+0xde>
			{
				case 0:
					strcpy_P(Buffer, PSTR("DATA-"));
    3440:	63 e0       	ldi	r22, 0x03	; 3
    3442:	74 e0       	ldi	r23, 0x04	; 4
    3444:	ce 01       	movw	r24, r28
    3446:	01 96       	adiw	r24, 0x01	; 1
    3448:	0e 94 3e 1b 	call	0x367c <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_FLASH), &Buffer[5], 10);
    344c:	81 e0       	ldi	r24, 0x01	; 1
    344e:	07 c0       	rjmp	.+14     	; 0x345e <PM_ShowStoredItemSizes+0x86>
					break;
				case 1:
					strcpy_P(Buffer, PSTR("EPRM-"));
    3450:	69 e0       	ldi	r22, 0x09	; 9
    3452:	74 e0       	ldi	r23, 0x04	; 4
    3454:	ce 01       	movw	r24, r28
    3456:	01 96       	adiw	r24, 0x01	; 1
    3458:	0e 94 3e 1b 	call	0x367c <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_EEPROM), &Buffer[5], 10);
    345c:	80 e0       	ldi	r24, 0x00	; 0
    345e:	0e 94 7f 13 	call	0x26fe <PM_GetStoredDataSize>
    3462:	dc 01       	movw	r26, r24
    3464:	cb 01       	movw	r24, r22
    3466:	2a e0       	ldi	r18, 0x0A	; 10
    3468:	30 e0       	ldi	r19, 0x00	; 0
    346a:	ae 01       	movw	r20, r28
    346c:	4a 5f       	subi	r20, 0xFA	; 250
    346e:	5f 4f       	sbci	r21, 0xFF	; 255
    3470:	bc 01       	movw	r22, r24
    3472:	cd 01       	movw	r24, r26
    3474:	0e 94 45 1b 	call	0x368a <ultoa>
					break;
    3478:	1e c0       	rjmp	.+60     	; 0x34b6 <PM_ShowStoredItemSizes+0xde>
				case 2:
					strcpy_P(Buffer, PSTR("FUSE-"));
    347a:	6f e0       	ldi	r22, 0x0F	; 15
    347c:	74 e0       	ldi	r23, 0x04	; 4
    347e:	ce 01       	movw	r24, r28
    3480:	01 96       	adiw	r24, 0x01	; 1
    3482:	0e 94 3e 1b 	call	0x367c <strcpy_P>
					TempB = eeprom_read_byte_169(&Prog_TotalFuseBytes);
    3486:	80 e1       	ldi	r24, 0x10	; 16
    3488:	91 e0       	ldi	r25, 0x01	; 1
    348a:	08 c0       	rjmp	.+16     	; 0x349c <PM_ShowStoredItemSizes+0xc4>
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);
					break;
				case 3:
					strcpy_P(Buffer, PSTR("LOCK-"));
    348c:	65 e1       	ldi	r22, 0x15	; 21
    348e:	74 e0       	ldi	r23, 0x04	; 4
    3490:	ce 01       	movw	r24, r28
    3492:	01 96       	adiw	r24, 0x01	; 1
    3494:	0e 94 3e 1b 	call	0x367c <strcpy_P>
					TempB = eeprom_read_byte_169(&Prog_TotalLockBytes);
    3498:	8e e0       	ldi	r24, 0x0E	; 14
    349a:	91 e0       	ldi	r25, 0x01	; 1
    349c:	0e 94 be 08 	call	0x117c <eeprom_read_byte_169>
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);		
    34a0:	8f 3f       	cpi	r24, 0xFF	; 255
    34a2:	11 f0       	breq	.+4      	; 0x34a8 <PM_ShowStoredItemSizes+0xd0>
    34a4:	99 27       	eor	r25, r25
    34a6:	02 c0       	rjmp	.+4      	; 0x34ac <PM_ShowStoredItemSizes+0xd4>
    34a8:	80 e0       	ldi	r24, 0x00	; 0
    34aa:	90 e0       	ldi	r25, 0x00	; 0
    34ac:	be 01       	movw	r22, r28
    34ae:	6a 5f       	subi	r22, 0xFA	; 250
    34b0:	7f 4f       	sbci	r23, 0xFF	; 255
    34b2:	0e 94 36 03 	call	0x66c <MAIN_IntToStr>
			}
	
			LCD_puts(Buffer);
    34b6:	ce 01       	movw	r24, r28
    34b8:	01 96       	adiw	r24, 0x01	; 1
    34ba:	0e 94 c3 07 	call	0xf86 <LCD_puts>

			MAIN_WaitForJoyRelease();
    34be:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
    34c2:	98 cf       	rjmp	.-208    	; 0x33f4 <PM_ShowStoredItemSizes+0x1c>
    34c4:	2e 96       	adiw	r28, 0x0e	; 14
    34c6:	0f b6       	in	r0, 0x3f	; 63
    34c8:	f8 94       	cli
    34ca:	de bf       	out	0x3e, r29	; 62
    34cc:	0f be       	out	0x3f, r0	; 63
    34ce:	cd bf       	out	0x3d, r28	; 61
    34d0:	df 91       	pop	r29
    34d2:	cf 91       	pop	r28
    34d4:	1f 91       	pop	r17
    34d6:	08 95       	ret

000034d8 <TM_FindNextTag>:
	DF_EnableDataflash(FALSE);
}

void TM_FindNextTag(void)
{
    34d8:	af 92       	push	r10
    34da:	bf 92       	push	r11
    34dc:	df 92       	push	r13
    34de:	ef 92       	push	r14
    34e0:	ff 92       	push	r15
    34e2:	0f 93       	push	r16
    34e4:	1f 93       	push	r17
    34e6:	cf 93       	push	r28
    34e8:	df 93       	push	r29
    34ea:	cd b7       	in	r28, 0x3d	; 61
    34ec:	de b7       	in	r29, 0x3e	; 62
    34ee:	69 97       	sbiw	r28, 0x19	; 25
    34f0:	0f b6       	in	r0, 0x3f	; 63
    34f2:	f8 94       	cli
    34f4:	de bf       	out	0x3e, r29	; 62
    34f6:	0f be       	out	0x3f, r0	; 63
    34f8:	cd bf       	out	0x3d, r28	; 61
	uint8_t  Buffer[21];
	uint8_t  HeadBuff[4]      = BT_TAGHEADER;
    34fa:	80 e4       	ldi	r24, 0x40	; 64
    34fc:	8e 8b       	std	Y+22, r24	; 0x16
    34fe:	86 e1       	ldi	r24, 0x16	; 22
    3500:	a8 2e       	mov	r10, r24
    3502:	b1 2c       	mov	r11, r1
    3504:	ac 0e       	add	r10, r28
    3506:	bd 1e       	adc	r11, r29
    3508:	88 e2       	ldi	r24, 0x28	; 40
    350a:	8f 8b       	std	Y+23, r24	; 0x17
    350c:	83 e2       	ldi	r24, 0x23	; 35
    350e:	88 8f       	std	Y+24, r24	; 0x18
    3510:	89 e2       	ldi	r24, 0x29	; 41
    3512:	89 8f       	std	Y+25, r24	; 0x19
	uint32_t ProgDataSize     = PM_GetStoredDataSize(TYPE_FLASH);
    3514:	81 e0       	ldi	r24, 0x01	; 1
    3516:	0e 94 7f 13 	call	0x26fe <PM_GetStoredDataSize>
    351a:	7b 01       	movw	r14, r22
    351c:	8c 01       	movw	r16, r24
	uint8_t  TotalOkHeadBytes = 0;
    351e:	dd 24       	eor	r13, r13
	uint8_t  TagByte;
	uint8_t  BytesRead;
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);    // Orange = busy
    3520:	81 b3       	in	r24, 0x11	; 17
    3522:	80 63       	ori	r24, 0x30	; 48
    3524:	81 bb       	out	0x11, r24	; 17

	while (DFPos < ProgDataSize)
	{
		BytesRead = 1;
		
		if (SPI_SPITransmit(0x00) == HeadBuff[TotalOkHeadBytes++])
		{
			if (TotalOkHeadBytes == 4)
			{
				uint8_t HB;
			
				for (HB = 0; HB < 20; HB++)
				{
					TagByte = SPI_SPITransmit(0x00);
					Buffer[HB] = TagByte;
					
					if (TagByte == 0x00)
					  break;
				}
				
				Buffer[20] = '\0';             // Make sure string is null-terminated

				TagExists = TRUE;
				BytesRead = (HB + 2);

				LCD_puts(Buffer);
				MAIN_SETSTATUSLED(MAIN_STATLED_GREEN); // Green = ready
				return;
			}
		}
		else
		{
			TotalOkHeadBytes = 0;
		}

		DFPos += BytesRead;
    3526:	80 91 d3 02 	lds	r24, 0x02D3
    352a:	90 91 d4 02 	lds	r25, 0x02D4
    352e:	a0 91 d5 02 	lds	r26, 0x02D5
    3532:	b0 91 d6 02 	lds	r27, 0x02D6
    3536:	8e 15       	cp	r24, r14
    3538:	9f 05       	cpc	r25, r15
    353a:	a0 07       	cpc	r26, r16
    353c:	b1 07       	cpc	r27, r17
    353e:	08 f0       	brcs	.+2      	; 0x3542 <TM_FindNextTag+0x6a>
    3540:	43 c0       	rjmp	.+134    	; 0x35c8 <TM_FindNextTag+0xf0>
    3542:	80 e0       	ldi	r24, 0x00	; 0
    3544:	0e 94 47 09 	call	0x128e <SPI_SPITransmit>
    3548:	f5 01       	movw	r30, r10
    354a:	ed 0d       	add	r30, r13
    354c:	f1 1d       	adc	r31, r1
    354e:	d3 94       	inc	r13
    3550:	90 81       	ld	r25, Z
    3552:	89 17       	cp	r24, r25
    3554:	21 f5       	brne	.+72     	; 0x359e <TM_FindNextTag+0xc6>
    3556:	84 e0       	ldi	r24, 0x04	; 4
    3558:	d8 16       	cp	r13, r24
    355a:	11 f5       	brne	.+68     	; 0x35a0 <TM_FindNextTag+0xc8>
    355c:	ff 24       	eor	r15, r15
    355e:	00 e0       	ldi	r16, 0x00	; 0
    3560:	10 e0       	ldi	r17, 0x00	; 0
    3562:	80 e0       	ldi	r24, 0x00	; 0
    3564:	0e 94 47 09 	call	0x128e <SPI_SPITransmit>
    3568:	9e 01       	movw	r18, r28
    356a:	2f 5f       	subi	r18, 0xFF	; 255
    356c:	3f 4f       	sbci	r19, 0xFF	; 255
    356e:	f8 01       	movw	r30, r16
    3570:	e2 0f       	add	r30, r18
    3572:	f3 1f       	adc	r31, r19
    3574:	80 83       	st	Z, r24
    3576:	88 23       	and	r24, r24
    3578:	31 f0       	breq	.+12     	; 0x3586 <TM_FindNextTag+0xae>
    357a:	f3 94       	inc	r15
    357c:	0f 5f       	subi	r16, 0xFF	; 255
    357e:	1f 4f       	sbci	r17, 0xFF	; 255
    3580:	83 e1       	ldi	r24, 0x13	; 19
    3582:	8f 15       	cp	r24, r15
    3584:	70 f7       	brcc	.-36     	; 0x3562 <TM_FindNextTag+0x8a>
    3586:	1d 8a       	std	Y+21, r1	; 0x15
    3588:	81 e0       	ldi	r24, 0x01	; 1
    358a:	80 93 4c 02 	sts	0x024C, r24
    358e:	c9 01       	movw	r24, r18
    3590:	0e 94 c3 07 	call	0xf86 <LCD_puts>
    3594:	81 b3       	in	r24, 0x11	; 17
    3596:	8f 7c       	andi	r24, 0xCF	; 207
    3598:	80 61       	ori	r24, 0x10	; 16
    359a:	81 bb       	out	0x11, r24	; 17
    359c:	31 c0       	rjmp	.+98     	; 0x3600 <TM_FindNextTag+0x128>
    359e:	dd 24       	eor	r13, r13
    35a0:	80 91 d3 02 	lds	r24, 0x02D3
    35a4:	90 91 d4 02 	lds	r25, 0x02D4
    35a8:	a0 91 d5 02 	lds	r26, 0x02D5
    35ac:	b0 91 d6 02 	lds	r27, 0x02D6
    35b0:	01 96       	adiw	r24, 0x01	; 1
    35b2:	a1 1d       	adc	r26, r1
    35b4:	b1 1d       	adc	r27, r1
    35b6:	80 93 d3 02 	sts	0x02D3, r24
    35ba:	90 93 d4 02 	sts	0x02D4, r25
    35be:	a0 93 d5 02 	sts	0x02D5, r26
    35c2:	b0 93 d6 02 	sts	0x02D6, r27
    35c6:	b7 cf       	rjmp	.-146    	; 0x3536 <TM_FindNextTag+0x5e>
	}
	
	DF_ContinuousReadEnable(0, 0);
    35c8:	60 e0       	ldi	r22, 0x00	; 0
    35ca:	70 e0       	ldi	r23, 0x00	; 0
    35cc:	cb 01       	movw	r24, r22
    35ce:	0e 94 20 0a 	call	0x1440 <DF_ContinuousReadEnable>
	DFPos = 0;
    35d2:	10 92 d3 02 	sts	0x02D3, r1
    35d6:	10 92 d4 02 	sts	0x02D4, r1
    35da:	10 92 d5 02 	sts	0x02D5, r1
    35de:	10 92 d6 02 	sts	0x02D6, r1
	
	if (TagExists == FALSE)
    35e2:	80 91 4c 02 	lds	r24, 0x024C
    35e6:	88 23       	and	r24, r24
    35e8:	49 f4       	brne	.+18     	; 0x35fc <TM_FindNextTag+0x124>
	{
		MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);  // Green = ready
    35ea:	81 b3       	in	r24, 0x11	; 17
    35ec:	8f 7c       	andi	r24, 0xCF	; 207
    35ee:	80 61       	ori	r24, 0x10	; 16
    35f0:	81 bb       	out	0x11, r24	; 17
		MAIN_ShowError(PSTR("NO TAGS"));
    35f2:	8b e1       	ldi	r24, 0x1B	; 27
    35f4:	94 e0       	ldi	r25, 0x04	; 4
    35f6:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
    35fa:	02 c0       	rjmp	.+4      	; 0x3600 <TM_FindNextTag+0x128>
	}
	else
	{
		/* The following line _is_ recursion, but the function will only ever call itself
		   a maximum of one time. The function will call itself upon skipping from the last
		   tag stored in the program data to the first; to guard against infinite recursion
		   if no tags are present, the system will error out if the TagExists flag is empty
		   after a full data read. Once a tag has been read and displayed onto the LCD, the
           function returns to the main tag handling routine.                               */
		TM_FindNextTag();
    35fc:	0e 94 6c 1a 	call	0x34d8 <TM_FindNextTag>
    3600:	69 96       	adiw	r28, 0x19	; 25
    3602:	0f b6       	in	r0, 0x3f	; 63
    3604:	f8 94       	cli
    3606:	de bf       	out	0x3e, r29	; 62
    3608:	0f be       	out	0x3f, r0	; 63
    360a:	cd bf       	out	0x3d, r28	; 61
    360c:	df 91       	pop	r29
    360e:	cf 91       	pop	r28
    3610:	1f 91       	pop	r17
    3612:	0f 91       	pop	r16
    3614:	ff 90       	pop	r15
    3616:	ef 90       	pop	r14
    3618:	df 90       	pop	r13
    361a:	bf 90       	pop	r11
    361c:	af 90       	pop	r10
    361e:	08 95       	ret

00003620 <TM_ShowTags>:
    3620:	60 e0       	ldi	r22, 0x00	; 0
    3622:	70 e0       	ldi	r23, 0x00	; 0
    3624:	cb 01       	movw	r24, r22
    3626:	0e 94 20 0a 	call	0x1440 <DF_ContinuousReadEnable>
    362a:	10 92 4c 02 	sts	0x024C, r1
    362e:	10 92 d3 02 	sts	0x02D3, r1
    3632:	10 92 d4 02 	sts	0x02D4, r1
    3636:	10 92 d5 02 	sts	0x02D5, r1
    363a:	10 92 d6 02 	sts	0x02D6, r1
    363e:	0e 94 6c 1a 	call	0x34d8 <TM_FindNextTag>
    3642:	80 91 4c 02 	lds	r24, 0x024C
    3646:	88 23       	and	r24, r24
    3648:	71 f0       	breq	.+28     	; 0x3666 <TM_ShowTags+0x46>
    364a:	8e b3       	in	r24, 0x1e	; 30
    364c:	88 23       	and	r24, r24
    364e:	e9 f3       	breq	.-6      	; 0x364a <TM_ShowTags+0x2a>
    3650:	f7 9b       	sbis	0x1e, 7	; 30
    3652:	03 c0       	rjmp	.+6      	; 0x365a <TM_ShowTags+0x3a>
    3654:	0e 94 6c 1a 	call	0x34d8 <TM_FindNextTag>
    3658:	02 c0       	rjmp	.+4      	; 0x365e <TM_ShowTags+0x3e>
    365a:	f2 99       	sbic	0x1e, 2	; 30
    365c:	03 c0       	rjmp	.+6      	; 0x3664 <TM_ShowTags+0x44>
    365e:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
    3662:	f3 cf       	rjmp	.-26     	; 0x364a <TM_ShowTags+0x2a>
    3664:	80 e0       	ldi	r24, 0x00	; 0
    3666:	0e 94 e1 09 	call	0x13c2 <DF_EnableDataflash>
    366a:	08 95       	ret

0000366c <__vector_2>:
.global PCINT0_vect             ; Pin change 0 (joystick)
.global PCINT1_vect             ; Pin change 1 (joystick)

PCINT0_vect:
  jmp PCINT1_vect
    366c:	0c 94 96 03 	jmp	0x72c <__vector_3>

00003670 <__vector_10>:

.global TIMER0_COMP_vect             ; Timer 0 compare

TIMER0_COMP_vect:
  push r24
    3670:	8f 93       	push	r24
  ldi r24, (USI_CONTROL_REG_FLAGS | (1<<USITC))
    3672:	8b e5       	ldi	r24, 0x5B	; 91
  sts _SFR_MEM_ADDR(USICR), r24
    3674:	80 93 b8 00 	sts	0x00B8, r24
  pop r24
    3678:	8f 91       	pop	r24
  reti
    367a:	18 95       	reti

0000367c <strcpy_P>:
    367c:	fb 01       	movw	r30, r22
    367e:	dc 01       	movw	r26, r24
    3680:	05 90       	lpm	r0, Z+
    3682:	0d 92       	st	X+, r0
    3684:	00 20       	and	r0, r0
    3686:	e1 f7       	brne	.-8      	; 0x3680 <strcpy_P+0x4>
    3688:	08 95       	ret

0000368a <ultoa>:
    368a:	fa 01       	movw	r30, r20
    368c:	cf 93       	push	r28
    368e:	ff 93       	push	r31
    3690:	ef 93       	push	r30
    3692:	22 30       	cpi	r18, 0x02	; 2
    3694:	cc f0       	brlt	.+50     	; 0x36c8 <ultoa+0x3e>
    3696:	25 32       	cpi	r18, 0x25	; 37
    3698:	bc f4       	brge	.+46     	; 0x36c8 <ultoa+0x3e>
    369a:	c2 2f       	mov	r28, r18
    369c:	2c 2f       	mov	r18, r28
    369e:	33 27       	eor	r19, r19
    36a0:	44 27       	eor	r20, r20
    36a2:	55 27       	eor	r21, r21
    36a4:	ff 93       	push	r31
    36a6:	ef 93       	push	r30
    36a8:	0e 94 99 1b 	call	0x3732 <__udivmodsi4>
    36ac:	ef 91       	pop	r30
    36ae:	ff 91       	pop	r31
    36b0:	60 5d       	subi	r22, 0xD0	; 208
    36b2:	6a 33       	cpi	r22, 0x3A	; 58
    36b4:	0c f0       	brlt	.+2      	; 0x36b8 <ultoa+0x2e>
    36b6:	69 5d       	subi	r22, 0xD9	; 217
    36b8:	61 93       	st	Z+, r22
    36ba:	b9 01       	movw	r22, r18
    36bc:	ca 01       	movw	r24, r20
    36be:	60 50       	subi	r22, 0x00	; 0
    36c0:	70 40       	sbci	r23, 0x00	; 0
    36c2:	80 40       	sbci	r24, 0x00	; 0
    36c4:	90 40       	sbci	r25, 0x00	; 0
    36c6:	51 f7       	brne	.-44     	; 0x369c <ultoa+0x12>
    36c8:	10 82       	st	Z, r1
    36ca:	8f 91       	pop	r24
    36cc:	9f 91       	pop	r25
    36ce:	cf 91       	pop	r28
    36d0:	0c 94 6a 1b 	jmp	0x36d4 <strrev>

000036d4 <strrev>:
    36d4:	dc 01       	movw	r26, r24
    36d6:	fc 01       	movw	r30, r24
    36d8:	01 90       	ld	r0, Z+
    36da:	00 20       	and	r0, r0
    36dc:	e9 f7       	brne	.-6      	; 0x36d8 <strrev+0x4>
    36de:	32 97       	sbiw	r30, 0x02	; 2
    36e0:	ae 17       	cp	r26, r30
    36e2:	bf 07       	cpc	r27, r31
    36e4:	30 f4       	brcc	.+12     	; 0x36f2 <strrev+0x1e>
    36e6:	7c 91       	ld	r23, X
    36e8:	60 81       	ld	r22, Z
    36ea:	70 83       	st	Z, r23
    36ec:	31 97       	sbiw	r30, 0x01	; 1
    36ee:	6d 93       	st	X+, r22
    36f0:	f7 cf       	rjmp	.-18     	; 0x36e0 <strrev+0xc>
    36f2:	08 95       	ret

000036f4 <__mulsi3>:
    36f4:	62 9f       	mul	r22, r18
    36f6:	d0 01       	movw	r26, r0
    36f8:	73 9f       	mul	r23, r19
    36fa:	f0 01       	movw	r30, r0
    36fc:	82 9f       	mul	r24, r18
    36fe:	e0 0d       	add	r30, r0
    3700:	f1 1d       	adc	r31, r1
    3702:	64 9f       	mul	r22, r20
    3704:	e0 0d       	add	r30, r0
    3706:	f1 1d       	adc	r31, r1
    3708:	92 9f       	mul	r25, r18
    370a:	f0 0d       	add	r31, r0
    370c:	83 9f       	mul	r24, r19
    370e:	f0 0d       	add	r31, r0
    3710:	74 9f       	mul	r23, r20
    3712:	f0 0d       	add	r31, r0
    3714:	65 9f       	mul	r22, r21
    3716:	f0 0d       	add	r31, r0
    3718:	99 27       	eor	r25, r25
    371a:	72 9f       	mul	r23, r18
    371c:	b0 0d       	add	r27, r0
    371e:	e1 1d       	adc	r30, r1
    3720:	f9 1f       	adc	r31, r25
    3722:	63 9f       	mul	r22, r19
    3724:	b0 0d       	add	r27, r0
    3726:	e1 1d       	adc	r30, r1
    3728:	f9 1f       	adc	r31, r25
    372a:	bd 01       	movw	r22, r26
    372c:	cf 01       	movw	r24, r30
    372e:	11 24       	eor	r1, r1
    3730:	08 95       	ret

00003732 <__udivmodsi4>:
    3732:	a1 e2       	ldi	r26, 0x21	; 33
    3734:	1a 2e       	mov	r1, r26
    3736:	aa 1b       	sub	r26, r26
    3738:	bb 1b       	sub	r27, r27
    373a:	fd 01       	movw	r30, r26
    373c:	0d c0       	rjmp	.+26     	; 0x3758 <__udivmodsi4_ep>

0000373e <__udivmodsi4_loop>:
    373e:	aa 1f       	adc	r26, r26
    3740:	bb 1f       	adc	r27, r27
    3742:	ee 1f       	adc	r30, r30
    3744:	ff 1f       	adc	r31, r31
    3746:	a2 17       	cp	r26, r18
    3748:	b3 07       	cpc	r27, r19
    374a:	e4 07       	cpc	r30, r20
    374c:	f5 07       	cpc	r31, r21
    374e:	20 f0       	brcs	.+8      	; 0x3758 <__udivmodsi4_ep>
    3750:	a2 1b       	sub	r26, r18
    3752:	b3 0b       	sbc	r27, r19
    3754:	e4 0b       	sbc	r30, r20
    3756:	f5 0b       	sbc	r31, r21

00003758 <__udivmodsi4_ep>:
    3758:	66 1f       	adc	r22, r22
    375a:	77 1f       	adc	r23, r23
    375c:	88 1f       	adc	r24, r24
    375e:	99 1f       	adc	r25, r25
    3760:	1a 94       	dec	r1
    3762:	69 f7       	brne	.-38     	; 0x373e <__udivmodsi4_loop>
    3764:	60 95       	com	r22
    3766:	70 95       	com	r23
    3768:	80 95       	com	r24
    376a:	90 95       	com	r25
    376c:	9b 01       	movw	r18, r22
    376e:	ac 01       	movw	r20, r24
    3770:	bd 01       	movw	r22, r26
    3772:	cf 01       	movw	r24, r30
    3774:	08 95       	ret
