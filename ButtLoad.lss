
ButtLoad.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  000035a8  0000365c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000035a8  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b2  00800104  00800104  00003660  2**0
                  ALLOC
  3 .eeprom       0000008e  00810000  00810000  00003660  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00000084  00000000  00000000  000036f0  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00000078  00000000  00000000  00003774  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 0000012c  00000000  00000000  000037ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 00000d48  00000000  00000000  00003918  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0000456f  00000000  00000000  00004660  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000012e7  00000000  00000000  00008bcf  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00003369  00000000  00000000  00009eb6  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000004ec  00000000  00000000  0000d21f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000011c7  00000000  00000000  0000d70b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00001176  00000000  00000000  0000e8d2  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000070  00000000  00000000  0000fa48  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 33 02 	jmp	0x466	; 0x466 <__ctors_end>
       4:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
       8:	0c 94 45 1a 	jmp	0x348a	; 0x348a <__vector_2>
       c:	0c 94 bb 02 	jmp	0x576	; 0x576 <__vector_3>
      10:	0c 94 af 0c 	jmp	0x195e	; 0x195e <__vector_4>
      14:	0c 94 4d 08 	jmp	0x109a	; 0x109a <__vector_5>
      18:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      1c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      20:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      24:	0c 94 75 0c 	jmp	0x18ea	; 0x18ea <__vector_9>
      28:	0c 94 47 1a 	jmp	0x348e	; 0x348e <__vector_10>
      2c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      30:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      34:	0c 94 03 0c 	jmp	0x1806	; 0x1806 <__vector_13>
      38:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      3c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      40:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      44:	0c 94 ca 09 	jmp	0x1394	; 0x1394 <__vector_17>
      48:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      4c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      50:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      54:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      58:	0c 94 c0 08 	jmp	0x1180	; 0x1180 <__vector_22>

0000005c <BUTTTAG_Title>:
      5c:	40 28 23 29 42 55 54 54 4c 4f 41 44 20 41 56 52     @(#)BUTTLOAD AVR
      6c:	49 53 50 00                                         ISP.

00000070 <BUTTTAG_Version>:
      70:	40 28 23 29 56 31 2d 34 00                          @(#)V1-4.

00000079 <BUTTTAG_Author>:
      79:	40 28 23 29 42 59 20 44 45 41 4e 20 43 41 4d 45     @(#)BY DEAN CAME
      89:	52 41 00                                            RA.

0000008c <BUTTTAG_Copyright>:
      8c:	40 28 23 29 3c 43 3e 20 32 30 30 36 20 2d 20 47     @(#)<C> 2006 - G
      9c:	50 4c 00                                            PL.

0000009f <AboutTextPtrs>:
      9f:	60 00 74 00 7d 00 90 00                             `.t.}...

000000a7 <WaitText>:
      a7:	2a 57 41 49 54 2a 00                                *WAIT*.

000000ae <Func_ISPPRGM>:
      ae:	41 56 52 49 53 50 20 4d 4f 44 45 00                 AVRISP MODE.

000000ba <Func_STOREPRGM>:
      ba:	53 54 4f 52 45 20 50 52 47 4d 00                    STORE PRGM.

000000c5 <Func_PRGMAVR>:
      c5:	50 52 4f 47 52 41 4d 20 41 56 52 00                 PROGRAM AVR.

000000d1 <Func_PRGMDATAFLASH>:
      d1:	44 41 54 41 46 4c 41 53 48 20 50 52 47 4d 00        DATAFLASH PRGM.

000000e0 <Func_PRGMSTOREINFO>:
      e0:	44 41 54 41 53 54 4f 52 45 20 49 4e 46 4f 00        DATASTORE INFO.

000000ef <Func_SETTINGS>:
      ef:	53 45 54 54 49 4e 47 53 00                          SETTINGS.

000000f8 <Func_SLEEP>:
      f8:	53 4c 45 45 50 20 4d 4f 44 45 00                    SLEEP MODE.

00000103 <MainFunctionNames>:
     103:	ae 00 ba 00 c5 00 d1 00 e0 00 ef 00 f8 00           ..............

00000111 <MainFunctionPtrs>:
     111:	8f 04 61 04 f4 04 a4 04 e9 03 2c 03 da 02           ..a.......,...

0000011f <SFunc_SETCONTRAST>:
     11f:	53 45 54 20 43 4f 4e 54 52 41 53 54 00              SET CONTRAST.

0000012c <SFunc_SETSPISPEED>:
     12c:	53 45 54 20 49 53 50 20 53 50 45 45 44 00           SET ISP SPEED.

0000013a <SFunc_SETRESETMODE>:
     13a:	53 45 54 20 52 45 53 45 54 20 4d 4f 44 45 00        SET RESET MODE.

00000149 <SFunc_SETFIRMMINOR>:
     149:	53 45 54 20 46 49 52 4d 20 56 45 52 53 49 4f 4e     SET FIRM VERSION
	...

0000015a <SFunc_SETAUTOSLEEPTO>:
     15a:	53 45 54 20 53 4c 45 45 50 20 54 49 4d 45 4f 55     SET SLEEP TIMEOU
     16a:	54 00                                               T.

0000016c <SFunc_CLEARMEM>:
     16c:	43 4c 45 41 52 20 4d 45 4d 4f 52 59 00              CLEAR MEMORY.

00000179 <SFunc_GOBOOTLOADER>:
     179:	4a 55 4d 50 20 54 4f 20 42 4f 4f 54 4c 4f 41 44     JUMP TO BOOTLOAD
     189:	45 52 00                                            ER.

0000018c <SettingFunctionNames>:
     18c:	1f 01 2c 01 3a 01 49 01 5a 01 6c 01 79 01           ..,.:.I.Z.l.y.

0000019a <SettingFunctionPtrs>:
     19a:	fa 06 46 07 79 07 a1 07 61 03 c7 06 f4 02           ..F.y...a.....

000001a8 <PRG_A>:
     1a8:	50 52 47 4d 20 41 4c 4c 00                          PRGM ALL.

000001b1 <PRG_D>:
     1b1:	44 41 54 41 20 4f 4e 4c 59 00                       DATA ONLY.

000001bb <PRG_E>:
     1bb:	45 45 50 52 4f 4d 20 4f 4e 4c 59 00                 EEPROM ONLY.

000001c7 <PRG_DE>:
     1c7:	44 41 54 41 20 41 4e 44 20 45 45 50 52 4f 4d 00     DATA AND EEPROM.

000001d7 <PRG_F>:
     1d7:	46 55 53 45 20 42 59 54 45 53 20 4f 4e 4c 59 00     FUSE BYTES ONLY.

000001e7 <PRG_L>:
     1e7:	4c 4f 43 4b 20 42 59 54 45 53 20 4f 4e 4c 59 00     LOCK BYTES ONLY.

000001f7 <PRG_FL>:
     1f7:	46 55 53 45 20 41 4e 44 20 4c 4f 43 4b 20 42 59     FUSE AND LOCK BY
     207:	54 45 53 00                                         TES.

0000020b <PRG_C>:
     20b:	45 52 41 53 45 20 4f 4e 4c 59 00                    ERASE ONLY.

00000216 <ProgOptions>:
     216:	a8 01 b1 01 bb 01 c7 01 d7 01 e7 01 f7 01 0b 02     ................

00000226 <USISpeeds>:
     226:	20 35 37 31 35 33 20 48 5a 00 20 38 36 37 33 38      57153 HZ. 86738
     236:	20 48 5a 00 31 31 33 34 32 37 20 48 5a 00 32 31      HZ.113427 HZ.21
     246:	30 36 35 31 20 48 5a 00                             0651 HZ.

0000024e <SPIResetModes>:
     24e:	4c 4f 47 49 43 00 46 4c 4f 41 54 00                 LOGIC.FLOAT.

0000025a <SIFONames>:
     25a:	53 54 4f 52 41 47 45 20 53 49 5a 45 53 00 00 56     STORAGE SIZES..V
     26a:	49 45 57 20 44 41 54 41 20 54 41 47 53 00           IEW DATA TAGS.

00000278 <__c.2510>:
     278:	2a 4a 54 41 47 20 4f 4e 2a 00                       *JTAG ON*.

00000282 <__c.2479>:
     282:	4e 4f 20 53 54 4f 52 45 44 20 50 52 47 4d 00        NO STORED PRGM.

00000291 <__c.2425>:
     291:	4f 46 46 00                                         OFF.

00000295 <__c.2423>:
     295:	20 20 20 20 53 45 43 00                                 SEC.

0000029d <__c.2402>:
     29d:	56 32 2d 20 00                                      V2- .

000002a2 <__c.2304>:
     2a2:	4d 45 4d 20 43 4c 45 41 52 45 44 00                 MEM CLEARED.

000002ae <__c.2296>:
     2ae:	3c 4e 20 59 3e 00                                   <N Y>.

000002b4 <__c.2294>:
     2b4:	43 4f 4e 46 49 52 4d 00                             CONFIRM.

000002bc <__c.2277>:
     2bc:	2a 53 54 4f 52 41 47 45 20 4d 4f 44 45 2a 00        *STORAGE MODE*.

000002cb <__c.2210>:
     2cb:	46 41 49 4c 45 44 00                                FAILED.

000002d2 <__c.2208>:
     2d2:	50 52 4f 47 52 41 4d 4d 49 4e 47 20 44 4f 4e 45     PROGRAMMING DONE
	...

000002e3 <__c.2206>:
     2e3:	4e 4f 20 4c 4f 43 4b 20 42 59 54 45 53 00           NO LOCK BYTES.

000002f1 <__c.2204>:
     2f1:	4e 4f 20 46 55 53 45 20 42 59 54 45 53 00           NO FUSE BYTES.

000002ff <__c.2202>:
     2ff:	4e 4f 20 45 45 50 52 4f 4d 00                       NO EEPROM.

00000309 <__c.2200>:
     309:	4e 4f 20 44 41 54 41 00                             NO DATA.

00000311 <__c.2198>:
     311:	4e 4f 20 45 52 41 53 45 20 43 4d 44 00              NO ERASE CMD.

0000031e <__c.2095>:
     31e:	42 41 44 49 53 52 00                                BADISR.

00000325 <__c.2032>:
     325:	50 52 47 3e 20 20 00                                PRG>  .

0000032c <LCD_SegTable>:
     32c:	a8 ea 80 2a 00 40 00 0a 51 0a 08 40 59 55 18 01     ...*.@..Q..@YU..
     33c:	11 1e 11 1b 50 0b 41 1b 41 1f 11 01 51 1f 51 1b     ....P.A.A...Q.Q.
     34c:	00 00 00 00 08 80 00 1a 20 40 00 00 00 00 51 0f     ........ @....Q.
     35c:	91 39 41 14 91 31 41 1e 41 0e 41 1d 50 0f 80 20     .9A..1A.A.A.P.. 
     36c:	10 15 48 86 40 14 78 05 70 85 51 15 51 0e 51 95     ..H.@.x.p.Q.Q.Q.
     37c:	51 8e 21 90 81 20 50 15 48 44 50 c5 28 c0 28 20     Q.!.. P.HDP.(.( 
     38c:	09 50 41 14 20 80 11 11 00 00 00 10                 .PA. .......

00000398 <USIPSValues>:
     398:	03 80 02 54 01 40 00 22                             ...T.@."

000003a0 <DF_PageBits>:
     3a0:	09 09 09 09 09 0a 0a 0b                             ........

000003a8 <DF_PageSize>:
     3a8:	08 01 08 01 08 01 08 01 08 01 10 02 10 02 20 04     .............. .

000003b8 <DF_Pages>:
     3b8:	00 01 00 02 00 04 00 08 00 10 00 10 00 20 00 20     ............. . 

000003c8 <DataFlashError>:
     3c8:	44 41 54 41 46 4c 41 53 48 20 45 52 52 4f 52 00     DATAFLASH ERROR.

000003d8 <__c.1862>:
     3d8:	42 55 46 46 20 4f 56 46 00                          BUFF OVF.

000003e1 <AutoSleepTOValues>:
     3e1:	00 0f 1e 3c 78                                      ...<x

000003e6 <__c.1865>:
     3e6:	46 52 41 4d 45 20 45 52 52 00                       FRAME ERR.

000003f0 <__c.1863>:
     3f0:	44 41 54 41 20 4f 56 52 00                          DATA OVR.

000003f9 <DataFlashProgMode>:
     3f9:	2a 44 41 54 41 46 4c 41 53 48 20 4d 4f 44 45 2a     *DATAFLASH MODE*
	...

0000040a <SignonResponse>:
     40a:	01 00 08 41 56 52 49 53 50 5f 32 00                 ...AVRISP_2.

00000416 <ButtLoadData>:
     416:	40 28 23 29 2a 53 43 52 45 57 20 52 45 54 52 4f     @(#)*SCREW RETRO
     426:	44 41 4e 00 2a                                      DAN.*

0000042b <SyncErrorMessage>:
     42b:	53 59 4e 43 20 45 52 52 4f 52 00                    SYNC ERROR.

00000436 <AVRISPModeMessage>:
     436:	2a 41 54 41 56 52 49 53 50 20 4d 4f 44 45 2a 00     *ATAVRISP MODE*.

00000446 <__c.2152>:
     446:	4c 4f 43 4b 2d 00                                   LOCK-.

0000044c <__c.2149>:
     44c:	46 55 53 45 2d 00                                   FUSE-.

00000452 <__c.2146>:
     452:	45 50 52 4d 2d 00                                   EPRM-.

00000458 <__c.2142>:
     458:	44 41 54 41 2d 00                                   DATA-.

0000045e <__c.1884>:
     45e:	4e 4f 20 54 41 47 53 00                             NO TAGS.

00000466 <__ctors_end>:
     466:	11 24       	eor	r1, r1
     468:	1f be       	out	0x3f, r1	; 63
     46a:	cf ef       	ldi	r28, 0xFF	; 255
     46c:	d4 e0       	ldi	r29, 0x04	; 4
     46e:	de bf       	out	0x3e, r29	; 62
     470:	cd bf       	out	0x3d, r28	; 61

00000472 <__do_copy_data>:
     472:	11 e0       	ldi	r17, 0x01	; 1
     474:	a0 e0       	ldi	r26, 0x00	; 0
     476:	b1 e0       	ldi	r27, 0x01	; 1
     478:	e8 ea       	ldi	r30, 0xA8	; 168
     47a:	f5 e3       	ldi	r31, 0x35	; 53
     47c:	02 c0       	rjmp	.+4      	; 0x482 <.do_copy_data_start>

0000047e <.do_copy_data_loop>:
     47e:	05 90       	lpm	r0, Z+
     480:	0d 92       	st	X+, r0

00000482 <.do_copy_data_start>:
     482:	a4 30       	cpi	r26, 0x04	; 4
     484:	b1 07       	cpc	r27, r17
     486:	d9 f7       	brne	.-10     	; 0x47e <.do_copy_data_loop>

00000488 <__do_clear_bss>:
     488:	12 e0       	ldi	r17, 0x02	; 2
     48a:	a4 e0       	ldi	r26, 0x04	; 4
     48c:	b1 e0       	ldi	r27, 0x01	; 1
     48e:	01 c0       	rjmp	.+2      	; 0x492 <.do_clear_bss_start>

00000490 <.do_clear_bss_loop>:
     490:	1d 92       	st	X+, r1

00000492 <.do_clear_bss_start>:
     492:	a6 3b       	cpi	r26, 0xB6	; 182
     494:	b1 07       	cpc	r27, r17
     496:	e1 f7       	brne	.-8      	; 0x490 <.do_clear_bss_loop>
     498:	0e 94 37 06 	call	0xc6e	; 0xc6e <main>
     49c:	0c 94 d3 1a 	jmp	0x35a6	; 0x35a6 <_exit>

000004a0 <__bad_interrupt>:
     4a0:	0c 94 f0 04 	jmp	0x9e0	; 0x9e0 <__vector_default>

000004a4 <MAIN_Delay10MS>:

// ======================================================================================

void MAIN_Delay10MS(uint8_t loops)
{
     4a4:	28 2f       	mov	r18, r24
     4a6:	e0 e0       	ldi	r30, 0x00	; 0
     4a8:	f8 e4       	ldi	r31, 0x48	; 72
     4aa:	03 c0       	rjmp	.+6      	; 0x4b2 <MAIN_Delay10MS+0xe>
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     4ac:	cf 01       	movw	r24, r30
     4ae:	01 97       	sbiw	r24, 0x01	; 1
     4b0:	f1 f7       	brne	.-4      	; 0x4ae <MAIN_Delay10MS+0xa>
  /* Prevents the use of floating point libraries. Delaying in groups of
     10ms increases accuracy by reducing the time overhead for each loop
     interation of the while.                                            */

	while (loops--)
     4b2:	21 50       	subi	r18, 0x01	; 1
     4b4:	d8 f7       	brcc	.-10     	; 0x4ac <MAIN_Delay10MS+0x8>
     4b6:	08 95       	ret

000004b8 <MAIN_Delay1MS>:
	  _delay_ms(10);
}

void MAIN_Delay1MS(uint8_t loops)
{
     4b8:	28 2f       	mov	r18, r24
     4ba:	e3 e3       	ldi	r30, 0x33	; 51
     4bc:	f7 e0       	ldi	r31, 0x07	; 7
     4be:	03 c0       	rjmp	.+6      	; 0x4c6 <MAIN_Delay1MS+0xe>
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     4c0:	cf 01       	movw	r24, r30
     4c2:	01 97       	sbiw	r24, 0x01	; 1
     4c4:	f1 f7       	brne	.-4      	; 0x4c2 <MAIN_Delay1MS+0xa>
  /* Prevents the use of floating point libraries. Less accurate than the
     Delay10MS routine, but nessesary for many commands. The overhead required
     to call the routine is substantially less than the overhead required to
     calculate the float at compile time, so this actually saves execution time. */

	while (loops--)
     4c6:	21 50       	subi	r18, 0x01	; 1
     4c8:	d8 f7       	brcc	.-10     	; 0x4c0 <MAIN_Delay1MS+0x8>
     4ca:	08 95       	ret

000004cc <MAIN_ResetCSLine>:
	  _delay_ms(1);
}

void MAIN_ResetCSLine(const uint8_t ActiveInactive)
{
     4cc:	81 30       	cpi	r24, 0x01	; 1
     4ce:	81 f0       	breq	.+32     	; 0x4f0 <MAIN_ResetCSLine+0x24>
	/* ActiveInactive controls the /Reset line to an AVR device or external dataflash
	/CS line. If the reset polarity parameter is a 0 then interfacing with AT89
	devices which has an active high reset. Pins are tristated when inactive.         */
	
	switch (ActiveInactive)
     4d0:	81 30       	cpi	r24, 0x01	; 1
     4d2:	18 f0       	brcs	.+6      	; 0x4da <MAIN_ResetCSLine+0xe>
     4d4:	82 30       	cpi	r24, 0x02	; 2
     4d6:	01 f5       	brne	.+64     	; 0x518 <__stack+0x19>
     4d8:	09 c0       	rjmp	.+18     	; 0x4ec <MAIN_ResetCSLine+0x20>
	{
		case MAIN_RESETCS_ACTIVE:                // The target RESET line may be either active high or low.
			DDRF |= (1 << 6);
     4da:	86 9a       	sbi	0x10, 6	; 16
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     4dc:	a1 e0       	ldi	r26, 0x01	; 1
     4de:	b0 e0       	ldi	r27, 0x00	; 0
     4e0:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
     4e4:	80 2d       	mov	r24, r0
		
			if (eeprom_read_byte(&EEPROMVars.ResetPolarity)) // Translate to correct active logic level for target device type
     4e6:	88 23       	and	r24, r24
     4e8:	59 f4       	brne	.+22     	; 0x500 <__stack+0x1>
     4ea:	13 c0       	rjmp	.+38     	; 0x512 <__stack+0x13>
			  PORTF &= ~(1 << 6);
			else
			  PORTF |= (1 << 6);
		
			break;
		case MAIN_RESETCS_EXTDFACTIVE:           // Dataflashes are always active low.
			DDRF  |=  (1 << 6);
     4ec:	86 9a       	sbi	0x10, 6	; 16
     4ee:	08 c0       	rjmp	.+16     	; 0x500 <__stack+0x1>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     4f0:	ac e8       	ldi	r26, 0x8C	; 140
     4f2:	b0 e0       	ldi	r27, 0x00	; 0
     4f4:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
     4f8:	80 2d       	mov	r24, r0
			PORTF &= ~(1 << 6);
			
			break;
		case MAIN_RESETCS_INACTIVE:              // Must determine what to do for inactive RESET.
			if (eeprom_read_byte(&EEPROMVars.SPIResetMode)) // FLOAT mode reset
     4fa:	88 23       	and	r24, r24
     4fc:	19 f0       	breq	.+6      	; 0x504 <__stack+0x5>
			{
				DDRF  &= ~(1 << 6);
     4fe:	86 98       	cbi	0x10, 6	; 16
				PORTF &= ~(1 << 6);
     500:	8e 98       	cbi	0x11, 6	; 17
     502:	08 95       	ret
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     504:	a1 e0       	ldi	r26, 0x01	; 1
     506:	b0 e0       	ldi	r27, 0x00	; 0
     508:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
     50c:	80 2d       	mov	r24, r0
			}
			else                                 // ACTIVE mode reset
			{
				if (eeprom_read_byte(&EEPROMVars.ResetPolarity)) // Translate to correct inactive logic level for target device type
     50e:	88 23       	and	r24, r24
     510:	11 f0       	breq	.+4      	; 0x516 <__stack+0x17>
				  PORTF |= (1 << 6);
     512:	8e 9a       	sbi	0x11, 6	; 17
     514:	08 95       	ret
				else
				  PORTF &= ~(1 << 6);			
     516:	8e 98       	cbi	0x11, 6	; 17
     518:	08 95       	ret

0000051a <MAIN_WaitForJoyRelease>:
			}
	}
}

void MAIN_WaitForJoyRelease(void)
{
     51a:	8e b3       	in	r24, 0x1e	; 30
     51c:	81 30       	cpi	r24, 0x01	; 1
     51e:	11 f4       	brne	.+4      	; 0x524 <MAIN_WaitForJoyRelease+0xa>
	if (JoyStatus == 1)                          // If invalid value used to force menu drawing, reset value and exit
	{
		JoyStatus = 0;
     520:	1e ba       	out	0x1e, r1	; 30
     522:	08 95       	ret
		return;
	}

	for (;;)
	{
		while (JoyStatus) {};                    // Wait until joystick released
     524:	8e b3       	in	r24, 0x1e	; 30
     526:	88 23       	and	r24, r24
     528:	e9 f7       	brne	.-6      	; 0x524 <MAIN_WaitForJoyRelease+0xa>

		MAIN_Delay10MS(2);
     52a:	82 e0       	ldi	r24, 0x02	; 2
     52c:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>

		if (!(JoyStatus))                        // Joystick still released (not bouncing), return
     530:	8e b3       	in	r24, 0x1e	; 30
     532:	88 23       	and	r24, r24
     534:	b9 f7       	brne	.-18     	; 0x524 <MAIN_WaitForJoyRelease+0xa>
     536:	08 95       	ret

00000538 <MAIN_IntToStr>:
		  return;
	}
}

void MAIN_IntToStr(uint16_t IntV, uint8_t* Buff)
{
     538:	cf 93       	push	r28
     53a:	df 93       	push	r29
     53c:	fb 01       	movw	r30, r22
     53e:	20 e0       	ldi	r18, 0x00	; 0
     540:	03 c0       	rjmp	.+6      	; 0x548 <MAIN_IntToStr+0x10>
	// Shows leading zeros, unlike itoa.

	uint8_t Temp = 0;
	
	while (IntV >= 100)
	{
		Temp++;
     542:	2f 5f       	subi	r18, 0xFF	; 255
		IntV -= 100;
     544:	84 56       	subi	r24, 0x64	; 100
     546:	90 40       	sbci	r25, 0x00	; 0
     548:	84 36       	cpi	r24, 0x64	; 100
     54a:	91 05       	cpc	r25, r1
     54c:	d0 f7       	brcc	.-12     	; 0x542 <MAIN_IntToStr+0xa>
	}

	*(Buff++) = '0' + Temp;
     54e:	20 5d       	subi	r18, 0xD0	; 208
     550:	21 93       	st	Z+, r18
     552:	df 01       	movw	r26, r30
     554:	20 e0       	ldi	r18, 0x00	; 0
     556:	02 c0       	rjmp	.+4      	; 0x55c <MAIN_IntToStr+0x24>
	
	Temp = 0;
	
	while (IntV >= 10)
	{
		Temp++;
     558:	2f 5f       	subi	r18, 0xFF	; 255
		IntV -= 10;
     55a:	0a 97       	sbiw	r24, 0x0a	; 10
     55c:	8a 30       	cpi	r24, 0x0A	; 10
     55e:	91 05       	cpc	r25, r1
     560:	d8 f7       	brcc	.-10     	; 0x558 <MAIN_IntToStr+0x20>
	}
		
	*(Buff++) = '0' + Temp;
     562:	20 5d       	subi	r18, 0xD0	; 208
     564:	fd 01       	movw	r30, r26
     566:	21 93       	st	Z+, r18
	*(Buff++) = '0' + IntV;
     568:	80 5d       	subi	r24, 0xD0	; 208
     56a:	ed 01       	movw	r28, r26
     56c:	89 83       	std	Y+1, r24	; 0x01
	*(Buff)   = '\0';
     56e:	11 82       	std	Z+1, r1	; 0x01
     570:	df 91       	pop	r29
     572:	cf 91       	pop	r28
     574:	08 95       	ret

00000576 <__vector_3>:
}

void MAIN_ShowProgType(const uint8_t Letter)
{
	uint8_t ProgTypeBuffer[7];

	strcpy_P(ProgTypeBuffer, PSTR("PRG>  "));
	ProgTypeBuffer[5] = Letter;
	
	LCD_puts(ProgTypeBuffer);
}

void MAIN_ShowError(const uint8_t *pFlashStr)
{
	uint8_t ErrorBuff[LCD_TEXTBUFFER_SIZE];      // New buffer, LCD text buffer size
	
	ErrorBuff[0] = 'E';
	ErrorBuff[1] = '>';

	strcpy_P(&ErrorBuff[2], pFlashStr);          // WARNING: If flash error text is larger than (TEXTBUFFER_SIZE - 1),
	                                             // this will overflow the buffer and crash the program!
	LCD_puts(ErrorBuff);
	
	MAIN_WaitForJoyRelease();
	while (!(JoyStatus & JOY_PRESS)) {};
	MAIN_WaitForJoyRelease();
}

void MAIN_CrashProgram(const uint8_t *ErrTxtPtr)
{
	SPI_SPIOFF();
	USI_SPIOff();
	TIMEOUT_PACKET_TIMER_OFF();
	TIMEOUT_SLEEP_TIMER_OFF();
	USART_ENABLE(USART_TX_OFF, USART_RX_OFF);

	LCD_puts_f(ErrTxtPtr);
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);	

	for (;;)
	{
		MAIN_Delay10MS(50);
		PORTF ^= MAIN_STATLED_GREEN;               // Loop forever, blinking the status LED from orange to red and back
	}
}

// ======================================================================================

ISR(PCINT1_vect, ISR_NOBLOCK)                    // Joystick routine; PCINT0_vect is bound to this also via JoystickInterrupt.S
{
     576:	78 94       	sei
     578:	1f 92       	push	r1
     57a:	0f 92       	push	r0
     57c:	0f b6       	in	r0, 0x3f	; 63
     57e:	0f 92       	push	r0
     580:	11 24       	eor	r1, r1
     582:	8f 93       	push	r24
     584:	9f 93       	push	r25
	JoyStatus = (~PINB & JOY_BMASK)
     586:	83 b1       	in	r24, 0x03	; 3
     588:	9c b1       	in	r25, 0x0c	; 12
     58a:	80 95       	com	r24
     58c:	80 7d       	andi	r24, 0xD0	; 208
     58e:	90 95       	com	r25
     590:	9c 70       	andi	r25, 0x0C	; 12
     592:	89 2b       	or	r24, r25
     594:	8e bb       	out	0x1e, r24	; 30
	          | (~PINE & JOY_EMASK);
			  
	TIMEOUT_SLEEP_TIMEOUT_RESET();
     596:	10 92 8e 01 	sts	0x018E, r1
     59a:	10 92 8d 01 	sts	0x018D, r1
     59e:	10 92 85 00 	sts	0x0085, r1
     5a2:	10 92 84 00 	sts	0x0084, r1
     5a6:	9f 91       	pop	r25
     5a8:	8f 91       	pop	r24
     5aa:	0f 90       	pop	r0
     5ac:	0f be       	out	0x3f, r0	; 63
     5ae:	0f 90       	pop	r0
     5b0:	1f 90       	pop	r1
     5b2:	18 95       	reti

000005b4 <FUNCSleepMode>:
}

ISR(BADISR_vect, ISR_NAKED)                      // Bad ISR routine; should never be called, here for safety
{
	MAIN_CrashProgram(PSTR("BADISR"));
}

// ======================================================================================

void FUNCChangeSettings(void)
{
	uint8_t CurrSFunc = 0;
	
	JoyStatus = 1;

	for (;;)
	{
		if (JoyStatus)                           // Joystick is in the non-center position
		{
			if (JoyStatus & JOY_UP)              // Previous function
			  (CurrSFunc == 0)? CurrSFunc = ARRAY_UPPERBOUND(SettingFunctionPtrs) : CurrSFunc--;
			else if (JoyStatus & JOY_DOWN)       // Next function
			  (CurrSFunc == ARRAY_UPPERBOUND(SettingFunctionPtrs))? CurrSFunc = 0 : CurrSFunc++;
			else if (JoyStatus & JOY_PRESS)      // Select current function
			  ((FuncPtr)pgm_read_word(&SettingFunctionPtrs[CurrSFunc]))(); // Run associated function
			else if (JoyStatus & JOY_LEFT)
			  return;
		
			// Show current function onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&SettingFunctionNames[CurrSFunc]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCShowAbout(void)
{
	uint8_t InfoNum = 0;
	
	JoyStatus = 1;
			
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			  (InfoNum == 0)? InfoNum = ARRAY_UPPERBOUND(AboutTextPtrs) : InfoNum--;
			else if (JoyStatus & JOY_DOWN)
			  (InfoNum == ARRAY_UPPERBOUND(AboutTextPtrs))? InfoNum = 0 : InfoNum++;
			else if (JoyStatus & JOY_LEFT)
			  return;

			LCD_puts_f((uint8_t*)pgm_read_word(&AboutTextPtrs[InfoNum]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCAVRISPMode(void)
{
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(AVRISPModeMessage);
	
	V2P_RunStateMachine(AICI_InterpretPacket);
}

void FUNCProgramDataflash(void)
{
	USI_SPIInitMaster();
	DataflashInfo.UseExernalDF = TRUE;
	DFSPIRoutinePointer = USI_SPITransmit;
	
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(DataFlashProgMode);

	V2P_RunStateMachine(PD_InterpretAVRISPPacket);
	   
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
}

void FUNCProgramAVR(void)
{
	uint8_t  DoneFailMessageBuff[19];
	uint8_t  Fault    = ISPCC_NO_FAULT;
	uint8_t  ProgMode = 0;

	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
	SPI_SPIInit();
	DataflashInfo.UseExernalDF = FALSE;
	
	if (!(DF_CheckCorrectOnboardChip()))
	  return;

	MAIN_WaitForJoyRelease();
	
	JoyStatus = 1;                               // Use an invalid joystick value to force the program to write the
	                                             // name of the default command onto the LCD
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_LEFT)
			  return;
			else if (JoyStatus & JOY_PRESS)
			  break;
			else if (JoyStatus & JOY_UP)
			  (ProgMode == 0)? ProgMode = ARRAY_UPPERBOUND(ProgOptions) : ProgMode--;
			else if (JoyStatus & JOY_DOWN)
			  (ProgMode == ARRAY_UPPERBOUND(ProgOptions))? ProgMode = 0 : ProgMode++;

			LCD_puts_f((uint8_t*)pgm_read_word(&ProgOptions[ProgMode])); // Show current function onto the LCD

			MAIN_WaitForJoyRelease();
		}
	}

	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_BASECLOCKSPEED_8MHZ);
	LCD_puts_f(WaitText);

	TIMEOUT_SLEEP_TIMER_OFF();

	USI_SPIInitMaster();
	MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);       // Capture the RESET line of the slave AVR
			
	for (uint8_t PacketB = 0; PacketB < 12; PacketB++) // Read the enter programming mode command bytes
	  PacketBytes[PacketB] = eeprom_read_byte(&EEPROMVars.EnterProgMode[PacketB]);
	
	ISPCC_EnterChipProgrammingMode();            // Try to sync with the slave AVR

	CurrAddress = 0;

	if (PacketBytes[1] == AICB_STATUS_CMD_OK)    // ISPCC_EnterChipProgrammingMode alters the PacketBytes buffer rather than returning a value
	{						
		if (!(ProgMode) || (ProgMode == 7) || (ProgMode == 1) || (ProgMode == 3)) // All, erase chip, flash and eeprom, or program flash mode
		{
			MAIN_ShowProgType('C');
			
			if (!(eeprom_read_byte(&EEPROMVars.EraseCmdStored) == TRUE))
			{
				Fault = ISPCC_FAULT_NOERASE;
				MAIN_ShowError(PSTR("NO ERASE CMD"));
			}
			else
			{
				PM_SendEraseCommand();
			}
		}

		if ((!(ProgMode) || (ProgMode == 1) || (ProgMode == 3)) && (Fault == ISPCC_NO_FAULT)) // All, flash and EEPROM, or program flash mode
		{
			MAIN_ShowProgType('D');

			if (!(PM_GetStoredDataSize(TYPE_FLASH))) // Check to make sure a program is present in memory
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
				MAIN_ShowError(PSTR("NO DATA"));
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_FLASH);
			}
		}
	
		if (!(ProgMode) || (ProgMode == 2) || (ProgMode == 3)) // All, flash and EEPROM, or program EEPROM mode
		{
			MAIN_ShowProgType('E');
				
			if (!(PM_GetStoredDataSize(TYPE_EEPROM))) // Check to make sure EEPROM data is present in memory
			{
				Fault = ISPCC_FAULT_NODATATYPE;
				MAIN_ShowError(PSTR("NO EEPROM"));
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_EEPROM);
			}
		}

		if (!(ProgMode) || (ProgMode == 4) || (ProgMode == 6)) // All, fuse and lock bytes, or program fuse bytes mode
		{
			MAIN_ShowProgType('F');
			
			if (!(eeprom_read_byte(&EEPROMVars.TotalFuseBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
				MAIN_ShowError(PSTR("NO FUSE BYTES"));
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_FUSE);
			}
		}

		if (!(ProgMode) || (ProgMode == 5) || (ProgMode == 6)) // All, fuse and lock bytes, or program lock bytes mode
		{
			if (ProgMode == 6)                           // If fusebytes have already been written, we need to reenter programming mode to latch them
			{
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line of the slave AVR
				MAIN_Delay10MS(1);
				MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);   // Capture the RESET line of the slave AVR
				ISPCC_EnterChipProgrammingMode();        // Try to sync with the slave AVR
			}

			MAIN_ShowProgType('L');
		
			if (!(eeprom_read_byte(&EEPROMVars.TotalLockBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;
				MAIN_ShowError(PSTR("NO LOCK BYTES"));
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_LOCK);
			}
		}

		strcpy_P(DoneFailMessageBuff, PSTR("PROGRAMMING DONE"));

		if (Fault != ISPCC_NO_FAULT)             // Takes less code to just overwrite part of the string on fail
		  strcpy_P(&DoneFailMessageBuff[12], PSTR("FAILED"));

		LCD_puts(DoneFailMessageBuff);

		MAIN_Delay10MS(250);
		MAIN_Delay10MS(200);
	}
	else
	{
		MAIN_ShowError(SyncErrorMessage);
	}
	
	TOUT_SetupSleepTimer();
	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_BASECLOCKSPEED_1MHZ);
	MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);     // Release the RESET line and allow the slave AVR to run	
	USI_SPIOff();
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);       // Set status LEDs to green (ready)
}

void FUNCStoreProgram(void)
{
	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
	SPI_SPIInit();
	DataflashInfo.UseExernalDF = FALSE;
	DF_EnableDataflash(TRUE);

	if (!(DF_CheckCorrectOnboardChip()))
	  return;
			
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(PSTR("*STORAGE MODE*"));

	V2P_RunStateMachine(PM_InterpretAVRISPPacket);
	
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
}

void FUNCClearMem(void)
{
	LCD_puts_f(PSTR("CONFIRM"));
	MAIN_Delay10MS(180);

	LCD_puts_f(PSTR("<N Y>"));

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_LEFT)
			  return;
			else if (JoyStatus & JOY_RIGHT)
			  break;
		}
	}

	MAIN_WaitForJoyRelease();

	LCD_puts_f(WaitText);
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);      // Set status LEDs to orange (busy)

	for (uint16_t EAddr = 0; EAddr < sizeof(EEPROMVars); EAddr++)
	  eeprom_write_byte((uint8_t*)EAddr, 0xFF);

	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);       // Set status LEDs to green (ready)
	LCD_puts_f(PSTR("MEM CLEARED"));
	MAIN_Delay10MS(250);
}

void FUNCSetContrast(void)
{
	uint8_t Buffer[6];
	uint8_t Contrast = (eeprom_read_byte(&EEPROMVars.LCDContrast) & 0x0F); // Ranges from 0-15 so mask retuns 15 on blank EEPROM (0xFF)
	
	JoyStatus = 1;                               // Invalid value to force the LCD to update
	
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				if (Contrast < 15)
				  Contrast++;
			}
			else if (JoyStatus & JOY_DOWN)
			{
				if (Contrast > 1)                // Zero is non-visible, so 1 is the minimum
				  Contrast--;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.LCDContrast, Contrast);
				return;
			}
					
			Buffer[0] = 'C';
			Buffer[1] = 'T';
			Buffer[2] = ' ';

			MAIN_IntToStr((uint16_t)Contrast, &Buffer[3]);
			LCD_puts(Buffer);

			LCD_CONTRAST_LEVEL(Contrast);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCSetISPSpeed(void)
{
	uint8_t CurrSpeed = eeprom_read_byte(&EEPROMVars.SCKDuration);

	if (CurrSpeed > ARRAY_UPPERBOUND(USISpeeds))
	  CurrSpeed = ARRAY_UPPERBOUND(USISpeeds);   // Protection against blank EEPROM

	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				(CurrSpeed == 0)? CurrSpeed = ARRAY_UPPERBOUND(USISpeeds) : CurrSpeed--;
			}
			else if (JoyStatus & JOY_DOWN)
			{
				(CurrSpeed == ARRAY_UPPERBOUND(USISpeeds))? CurrSpeed = 0 : CurrSpeed++;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.SCKDuration, CurrSpeed);
				return;
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f(USISpeeds[CurrSpeed]);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCSetResetMode(void)
{
	uint8_t CurrMode = (eeprom_read_byte(&EEPROMVars.SPIResetMode) & 0x01);

	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if ((JoyStatus & JOY_UP) || (JoyStatus & JOY_DOWN))
			{
				CurrMode ^= 1;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.SPIResetMode, CurrMode);
				return;
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f(SPIResetModes[CurrMode]);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCSetFirmMinorVer(void)
{
	uint8_t VerBuffer[5];
	uint8_t VerMinor = eeprom_read_byte(&EEPROMVars.FirmVerMinor);

	if (VerMinor > 9)
	  VerMinor = V2P_SW_VERSION_MINOR_DEFAULT;
	
	strcpy_P(VerBuffer, PSTR("V2- "));

	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				if (VerMinor < 9)
				  VerMinor++;
			}
			if (JoyStatus & JOY_DOWN)
			{
				if (VerMinor)
				  VerMinor--;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.FirmVerMinor, VerMinor);
				return;
			}
			
			VerBuffer[3] = ('0' + VerMinor);
			LCD_puts(VerBuffer);

			MAIN_WaitForJoyRelease();
		}
	}	
}

void FUNCSetAutoSleepTimeOut(void)
{
	uint8_t SleepTxtBuffer[8];
	uint8_t SleepVal = eeprom_read_byte(&EEPROMVars.AutoSleepValIndex);

	if (SleepVal > ARRAY_UPPERBOUND(AutoSleepTOValues))
	  SleepVal = ARRAY_UPPERBOUND(AutoSleepTOValues);

	strcpy_P(SleepTxtBuffer, PSTR("    SEC"));
	
	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				(SleepVal == 0)? SleepVal = ARRAY_UPPERBOUND(AutoSleepTOValues) : SleepVal--;
			}
			if (JoyStatus & JOY_DOWN)
			{
				(SleepVal == ARRAY_UPPERBOUND(AutoSleepTOValues))? SleepVal = 0 : SleepVal++;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.AutoSleepValIndex, SleepVal);
				TOUT_SetupSleepTimer();
				return;
			}

			if (!(SleepVal))
			{
				LCD_puts_f(PSTR("OFF"));
			}
			else
			{
				MAIN_IntToStr(pgm_read_byte(&AutoSleepTOValues[SleepVal]), &SleepTxtBuffer[0]);
				SleepTxtBuffer[3] = ' ';         // Remove the auto-string termination from the buffer
				LCD_puts(SleepTxtBuffer);
			}

			MAIN_WaitForJoyRelease();
		}
	}	
}

void FUNCSleepMode(void)
{
     5b4:	85 e0       	ldi	r24, 0x05	; 5
     5b6:	83 bf       	out	0x33, r24	; 51
	SMCR    = ((1 << SM1) | (1 << SE));          // Power down sleep mode
	LCDCRA &= ~(1 << LCDEN); 
     5b8:	80 91 e4 00 	lds	r24, 0x00E4
     5bc:	8f 77       	andi	r24, 0x7F	; 127
     5be:	80 93 e4 00 	sts	0x00E4, r24
	
	MAIN_SETSTATUSLED(MAIN_STATLED_OFF);         // Save battery power - turn off status LED
     5c2:	81 b3       	in	r24, 0x11	; 17
     5c4:	8f 7c       	andi	r24, 0xCF	; 207
     5c6:	81 bb       	out	0x11, r24	; 17
     5c8:	01 c0       	rjmp	.+2      	; 0x5cc <FUNCSleepMode+0x18>

	while (!(JoyStatus & JOY_UP))                // Joystick interrupt wakes the micro
	  SLEEP();
     5ca:	88 95       	sleep
     5cc:	f6 9b       	sbis	0x1e, 6	; 30
     5ce:	fd cf       	rjmp	.-6      	; 0x5ca <FUNCSleepMode+0x16>
	   
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);       // Turn status LED back on
     5d0:	81 b3       	in	r24, 0x11	; 17
     5d2:	8f 7c       	andi	r24, 0xCF	; 207
     5d4:	80 61       	ori	r24, 0x10	; 16
     5d6:	81 bb       	out	0x11, r24	; 17

	LCDCRA |= (1 << LCDEN);
     5d8:	80 91 e4 00 	lds	r24, 0x00E4
     5dc:	80 68       	ori	r24, 0x80	; 128
     5de:	80 93 e4 00 	sts	0x00E4, r24
	
	MAIN_WaitForJoyRelease();
     5e2:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     5e6:	08 95       	ret

000005e8 <FUNCGoBootloader>:
}

void FUNCStorageInfo(void)
{
	uint8_t SelectedItem = 0;

	MAIN_WaitForJoyRelease();

	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & (JOY_UP | JOY_DOWN))
			{
				SelectedItem ^= 1;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				return;
			}
			else if (JoyStatus & JOY_PRESS)
			{
				if (SelectedItem == 1)           // View storage tags
				{
					DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
					SPI_SPIInit();
					DataflashInfo.UseExernalDF = FALSE;
					DF_EnableDataflash(TRUE);

					if (DF_CheckCorrectOnboardChip())
					{
						TM_ShowTags();
						SPI_SPIOFF();
					}
					else if (!(PM_GetStoredDataSize(TYPE_FLASH)))
					{
						DF_EnableDataflash(FALSE);
						SPI_SPIOFF();

						MAIN_ShowError(PSTR("NO STORED PRGM"));
					}	
				}
				else                             // View stored data sizes
				{
					PM_ShowStoredItemSizes();
				}
			}
			
			LCD_puts_f(SIFONames[SelectedItem]);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCGoBootloader(void)
{
     5e8:	85 b7       	in	r24, 0x35	; 53
     5ea:	8f 77       	andi	r24, 0x7F	; 127
	uint8_t MD = (MCUCR & ~(1 << JTD));         // Forces compiler to use IN, AND plus two OUTs rather than two lots of IN/AND/OUTs
	MCUCR = MD;                                 // Turn on JTAG via code
     5ec:	85 bf       	out	0x35, r24	; 53
	MCUCR = MD;                                 // Set bit twice as specified in datasheet        
     5ee:	85 bf       	out	0x35, r24	; 53

	TIMEOUT_SLEEP_TIMER_OFF();
     5f0:	10 92 81 00 	sts	0x0081, r1
	
	LCD_puts_f(PSTR("*JTAG ON*"));
     5f4:	88 e7       	ldi	r24, 0x78	; 120
     5f6:	92 e0       	ldi	r25, 0x02	; 2
     5f8:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
	
	MAIN_WaitForJoyRelease();
     5fc:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
	
	WDTCR = ((1<<WDCE) | (1<<WDE));             // Enable Watchdog Timer to give reset after minimum timeout
     600:	88 e1       	ldi	r24, 0x18	; 24
     602:	80 93 60 00 	sts	0x0060, r24
     606:	ff cf       	rjmp	.-2      	; 0x606 <FUNCGoBootloader+0x1e>

00000608 <FUNCShowAbout>:
     608:	1f 93       	push	r17
     60a:	81 e0       	ldi	r24, 0x01	; 1
     60c:	8e bb       	out	0x1e, r24	; 30
     60e:	10 e0       	ldi	r17, 0x00	; 0
     610:	8e b3       	in	r24, 0x1e	; 30
     612:	88 23       	and	r24, r24
     614:	e9 f3       	breq	.-6      	; 0x610 <FUNCShowAbout+0x8>
     616:	f6 9b       	sbis	0x1e, 6	; 30
     618:	06 c0       	rjmp	.+12     	; 0x626 <FUNCShowAbout+0x1e>
     61a:	11 23       	and	r17, r17
     61c:	11 f4       	brne	.+4      	; 0x622 <FUNCShowAbout+0x1a>
     61e:	13 e0       	ldi	r17, 0x03	; 3
     620:	0c c0       	rjmp	.+24     	; 0x63a <FUNCShowAbout+0x32>
     622:	11 50       	subi	r17, 0x01	; 1
     624:	0a c0       	rjmp	.+20     	; 0x63a <FUNCShowAbout+0x32>
     626:	f7 9b       	sbis	0x1e, 7	; 30
     628:	06 c0       	rjmp	.+12     	; 0x636 <FUNCShowAbout+0x2e>
     62a:	13 30       	cpi	r17, 0x03	; 3
     62c:	11 f4       	brne	.+4      	; 0x632 <FUNCShowAbout+0x2a>
     62e:	10 e0       	ldi	r17, 0x00	; 0
     630:	04 c0       	rjmp	.+8      	; 0x63a <FUNCShowAbout+0x32>
     632:	1f 5f       	subi	r17, 0xFF	; 255
     634:	02 c0       	rjmp	.+4      	; 0x63a <FUNCShowAbout+0x32>
     636:	f2 99       	sbic	0x1e, 2	; 30
     638:	0d c0       	rjmp	.+26     	; 0x654 <FUNCShowAbout+0x4c>
     63a:	e1 2f       	mov	r30, r17
     63c:	ff 27       	eor	r31, r31
     63e:	ee 0f       	add	r30, r30
     640:	ff 1f       	adc	r31, r31
     642:	e1 56       	subi	r30, 0x61	; 97
     644:	ff 4f       	sbci	r31, 0xFF	; 255
     646:	85 91       	lpm	r24, Z+
     648:	94 91       	lpm	r25, Z
     64a:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     64e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     652:	de cf       	rjmp	.-68     	; 0x610 <FUNCShowAbout+0x8>
     654:	1f 91       	pop	r17
     656:	08 95       	ret

00000658 <FUNCChangeSettings>:
     658:	1f 93       	push	r17
     65a:	81 e0       	ldi	r24, 0x01	; 1
     65c:	8e bb       	out	0x1e, r24	; 30
     65e:	10 e0       	ldi	r17, 0x00	; 0
     660:	8e b3       	in	r24, 0x1e	; 30
     662:	88 23       	and	r24, r24
     664:	e9 f3       	breq	.-6      	; 0x660 <FUNCChangeSettings+0x8>
     666:	f6 9b       	sbis	0x1e, 6	; 30
     668:	06 c0       	rjmp	.+12     	; 0x676 <FUNCChangeSettings+0x1e>
     66a:	11 23       	and	r17, r17
     66c:	11 f4       	brne	.+4      	; 0x672 <FUNCChangeSettings+0x1a>
     66e:	16 e0       	ldi	r17, 0x06	; 6
     670:	19 c0       	rjmp	.+50     	; 0x6a4 <FUNCChangeSettings+0x4c>
     672:	11 50       	subi	r17, 0x01	; 1
     674:	17 c0       	rjmp	.+46     	; 0x6a4 <FUNCChangeSettings+0x4c>
     676:	f7 9b       	sbis	0x1e, 7	; 30
     678:	06 c0       	rjmp	.+12     	; 0x686 <FUNCChangeSettings+0x2e>
     67a:	16 30       	cpi	r17, 0x06	; 6
     67c:	11 f4       	brne	.+4      	; 0x682 <FUNCChangeSettings+0x2a>
     67e:	10 e0       	ldi	r17, 0x00	; 0
     680:	11 c0       	rjmp	.+34     	; 0x6a4 <FUNCChangeSettings+0x4c>
     682:	1f 5f       	subi	r17, 0xFF	; 255
     684:	0f c0       	rjmp	.+30     	; 0x6a4 <FUNCChangeSettings+0x4c>
     686:	f4 9b       	sbis	0x1e, 4	; 30
     688:	0b c0       	rjmp	.+22     	; 0x6a0 <FUNCChangeSettings+0x48>
     68a:	e1 2f       	mov	r30, r17
     68c:	ff 27       	eor	r31, r31
     68e:	ee 0f       	add	r30, r30
     690:	ff 1f       	adc	r31, r31
     692:	e6 56       	subi	r30, 0x66	; 102
     694:	fe 4f       	sbci	r31, 0xFE	; 254
     696:	85 91       	lpm	r24, Z+
     698:	94 91       	lpm	r25, Z
     69a:	fc 01       	movw	r30, r24
     69c:	09 95       	icall
     69e:	02 c0       	rjmp	.+4      	; 0x6a4 <FUNCChangeSettings+0x4c>
     6a0:	f2 99       	sbic	0x1e, 2	; 30
     6a2:	0d c0       	rjmp	.+26     	; 0x6be <FUNCChangeSettings+0x66>
     6a4:	e1 2f       	mov	r30, r17
     6a6:	ff 27       	eor	r31, r31
     6a8:	ee 0f       	add	r30, r30
     6aa:	ff 1f       	adc	r31, r31
     6ac:	e4 57       	subi	r30, 0x74	; 116
     6ae:	fe 4f       	sbci	r31, 0xFE	; 254
     6b0:	85 91       	lpm	r24, Z+
     6b2:	94 91       	lpm	r25, Z
     6b4:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     6b8:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     6bc:	d1 cf       	rjmp	.-94     	; 0x660 <FUNCChangeSettings+0x8>
     6be:	1f 91       	pop	r17
     6c0:	08 95       	ret

000006c2 <FUNCSetAutoSleepTimeOut>:
     6c2:	ef 92       	push	r14
     6c4:	ff 92       	push	r15
     6c6:	0f 93       	push	r16
     6c8:	cf 93       	push	r28
     6ca:	df 93       	push	r29
     6cc:	cd b7       	in	r28, 0x3d	; 61
     6ce:	de b7       	in	r29, 0x3e	; 62
     6d0:	28 97       	sbiw	r28, 0x08	; 8
     6d2:	0f b6       	in	r0, 0x3f	; 63
     6d4:	f8 94       	cli
     6d6:	de bf       	out	0x3e, r29	; 62
     6d8:	0f be       	out	0x3f, r0	; 63
     6da:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     6dc:	ab e8       	ldi	r26, 0x8B	; 139
     6de:	b0 e0       	ldi	r27, 0x00	; 0
     6e0:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
     6e4:	80 2d       	mov	r24, r0
     6e6:	08 2f       	mov	r16, r24
     6e8:	85 30       	cpi	r24, 0x05	; 5
     6ea:	08 f0       	brcs	.+2      	; 0x6ee <FUNCSetAutoSleepTimeOut+0x2c>
     6ec:	04 e0       	ldi	r16, 0x04	; 4
     6ee:	65 e9       	ldi	r22, 0x95	; 149
     6f0:	72 e0       	ldi	r23, 0x02	; 2
     6f2:	ce 01       	movw	r24, r28
     6f4:	01 96       	adiw	r24, 0x01	; 1
     6f6:	0e 94 4d 1a 	call	0x349a	; 0x349a <strcpy_P>
     6fa:	81 e0       	ldi	r24, 0x01	; 1
     6fc:	8e bb       	out	0x1e, r24	; 30
     6fe:	8e b3       	in	r24, 0x1e	; 30
     700:	88 23       	and	r24, r24
     702:	e9 f3       	breq	.-6      	; 0x6fe <FUNCSetAutoSleepTimeOut+0x3c>
     704:	f6 9b       	sbis	0x1e, 6	; 30
     706:	05 c0       	rjmp	.+10     	; 0x712 <FUNCSetAutoSleepTimeOut+0x50>
     708:	00 23       	and	r16, r16
     70a:	11 f4       	brne	.+4      	; 0x710 <FUNCSetAutoSleepTimeOut+0x4e>
     70c:	04 e0       	ldi	r16, 0x04	; 4
     70e:	01 c0       	rjmp	.+2      	; 0x712 <FUNCSetAutoSleepTimeOut+0x50>
     710:	01 50       	subi	r16, 0x01	; 1
     712:	f7 9b       	sbis	0x1e, 7	; 30
     714:	06 c0       	rjmp	.+12     	; 0x722 <FUNCSetAutoSleepTimeOut+0x60>
     716:	04 30       	cpi	r16, 0x04	; 4
     718:	11 f4       	brne	.+4      	; 0x71e <FUNCSetAutoSleepTimeOut+0x5c>
     71a:	00 e0       	ldi	r16, 0x00	; 0
     71c:	06 c0       	rjmp	.+12     	; 0x72a <FUNCSetAutoSleepTimeOut+0x68>
     71e:	0f 5f       	subi	r16, 0xFF	; 255
     720:	02 c0       	rjmp	.+4      	; 0x726 <FUNCSetAutoSleepTimeOut+0x64>
     722:	f2 99       	sbic	0x1e, 2	; 30
     724:	1d c0       	rjmp	.+58     	; 0x760 <FUNCSetAutoSleepTimeOut+0x9e>
     726:	00 23       	and	r16, r16
     728:	29 f4       	brne	.+10     	; 0x734 <FUNCSetAutoSleepTimeOut+0x72>
     72a:	81 e9       	ldi	r24, 0x91	; 145
     72c:	92 e0       	ldi	r25, 0x02	; 2
     72e:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     732:	13 c0       	rjmp	.+38     	; 0x75a <FUNCSetAutoSleepTimeOut+0x98>
     734:	e0 2f       	mov	r30, r16
     736:	ff 27       	eor	r31, r31
     738:	ef 51       	subi	r30, 0x1F	; 31
     73a:	fc 4f       	sbci	r31, 0xFC	; 252
     73c:	e4 91       	lpm	r30, Z
     73e:	7e 01       	movw	r14, r28
     740:	08 94       	sec
     742:	e1 1c       	adc	r14, r1
     744:	f1 1c       	adc	r15, r1
     746:	b7 01       	movw	r22, r14
     748:	8e 2f       	mov	r24, r30
     74a:	99 27       	eor	r25, r25
     74c:	0e 94 9c 02 	call	0x538	; 0x538 <MAIN_IntToStr>
     750:	80 e2       	ldi	r24, 0x20	; 32
     752:	8c 83       	std	Y+4, r24	; 0x04
     754:	c7 01       	movw	r24, r14
     756:	0e 94 81 08 	call	0x1102	; 0x1102 <LCD_puts>
     75a:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     75e:	cf cf       	rjmp	.-98     	; 0x6fe <FUNCSetAutoSleepTimeOut+0x3c>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     760:	ab e8       	ldi	r26, 0x8B	; 139
     762:	b0 e0       	ldi	r27, 0x00	; 0
     764:	00 2e       	mov	r0, r16
     766:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
     76a:	0e 94 44 0c 	call	0x1888	; 0x1888 <TOUT_SetupSleepTimer>
     76e:	28 96       	adiw	r28, 0x08	; 8
     770:	0f b6       	in	r0, 0x3f	; 63
     772:	f8 94       	cli
     774:	de bf       	out	0x3e, r29	; 62
     776:	0f be       	out	0x3f, r0	; 63
     778:	cd bf       	out	0x3d, r28	; 61
     77a:	df 91       	pop	r29
     77c:	cf 91       	pop	r28
     77e:	0f 91       	pop	r16
     780:	ff 90       	pop	r15
     782:	ef 90       	pop	r14
     784:	08 95       	ret

00000786 <MAIN_ShowError>:
     786:	cf 93       	push	r28
     788:	df 93       	push	r29
     78a:	cd b7       	in	r28, 0x3d	; 61
     78c:	de b7       	in	r29, 0x3e	; 62
     78e:	64 97       	sbiw	r28, 0x14	; 20
     790:	0f b6       	in	r0, 0x3f	; 63
     792:	f8 94       	cli
     794:	de bf       	out	0x3e, r29	; 62
     796:	0f be       	out	0x3f, r0	; 63
     798:	cd bf       	out	0x3d, r28	; 61
     79a:	25 e4       	ldi	r18, 0x45	; 69
     79c:	29 83       	std	Y+1, r18	; 0x01
     79e:	2e e3       	ldi	r18, 0x3E	; 62
     7a0:	2a 83       	std	Y+2, r18	; 0x02
     7a2:	bc 01       	movw	r22, r24
     7a4:	ce 01       	movw	r24, r28
     7a6:	03 96       	adiw	r24, 0x03	; 3
     7a8:	0e 94 4d 1a 	call	0x349a	; 0x349a <strcpy_P>
     7ac:	ce 01       	movw	r24, r28
     7ae:	01 96       	adiw	r24, 0x01	; 1
     7b0:	0e 94 81 08 	call	0x1102	; 0x1102 <LCD_puts>
     7b4:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     7b8:	f4 9b       	sbis	0x1e, 4	; 30
     7ba:	fe cf       	rjmp	.-4      	; 0x7b8 <MAIN_ShowError+0x32>
     7bc:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     7c0:	64 96       	adiw	r28, 0x14	; 20
     7c2:	0f b6       	in	r0, 0x3f	; 63
     7c4:	f8 94       	cli
     7c6:	de bf       	out	0x3e, r29	; 62
     7c8:	0f be       	out	0x3f, r0	; 63
     7ca:	cd bf       	out	0x3d, r28	; 61
     7cc:	df 91       	pop	r29
     7ce:	cf 91       	pop	r28
     7d0:	08 95       	ret

000007d2 <FUNCStorageInfo>:
     7d2:	1f 93       	push	r17
     7d4:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     7d8:	81 e0       	ldi	r24, 0x01	; 1
     7da:	8e bb       	out	0x1e, r24	; 30
     7dc:	10 e0       	ldi	r17, 0x00	; 0
     7de:	8e b3       	in	r24, 0x1e	; 30
     7e0:	88 23       	and	r24, r24
     7e2:	e9 f3       	breq	.-6      	; 0x7de <FUNCStorageInfo+0xc>
     7e4:	8e b3       	in	r24, 0x1e	; 30
     7e6:	80 7c       	andi	r24, 0xC0	; 192
     7e8:	19 f0       	breq	.+6      	; 0x7f0 <FUNCStorageInfo+0x1e>
     7ea:	81 e0       	ldi	r24, 0x01	; 1
     7ec:	18 27       	eor	r17, r24
     7ee:	36 c0       	rjmp	.+108    	; 0x85c <FUNCStorageInfo+0x8a>
     7f0:	f2 99       	sbic	0x1e, 2	; 30
     7f2:	3f c0       	rjmp	.+126    	; 0x872 <FUNCStorageInfo+0xa0>
     7f4:	f4 9b       	sbis	0x1e, 4	; 30
     7f6:	32 c0       	rjmp	.+100    	; 0x85c <FUNCStorageInfo+0x8a>
     7f8:	11 30       	cpi	r17, 0x01	; 1
     7fa:	71 f5       	brne	.+92     	; 0x858 <FUNCStorageInfo+0x86>
     7fc:	84 eb       	ldi	r24, 0xB4	; 180
     7fe:	99 e0       	ldi	r25, 0x09	; 9
     800:	90 93 01 01 	sts	0x0101, r25
     804:	80 93 00 01 	sts	0x0100, r24
     808:	0e 94 ac 09 	call	0x1358	; 0x1358 <SPI_SPIInit>
     80c:	10 92 47 01 	sts	0x0147, r1
     810:	81 e0       	ldi	r24, 0x01	; 1
     812:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
     816:	0e 94 c5 0b 	call	0x178a	; 0x178a <DF_CheckCorrectOnboardChip>
     81a:	88 23       	and	r24, r24
     81c:	41 f0       	breq	.+16     	; 0x82e <FUNCStorageInfo+0x5c>
     81e:	0e 94 1e 1a 	call	0x343c	; 0x343c <TM_ShowTags>
     822:	80 91 64 00 	lds	r24, 0x0064
     826:	84 60       	ori	r24, 0x04	; 4
     828:	80 93 64 00 	sts	0x0064, r24
     82c:	17 c0       	rjmp	.+46     	; 0x85c <FUNCStorageInfo+0x8a>
     82e:	81 e0       	ldi	r24, 0x01	; 1
     830:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <PM_GetStoredDataSize>
     834:	61 15       	cp	r22, r1
     836:	71 05       	cpc	r23, r1
     838:	81 05       	cpc	r24, r1
     83a:	91 05       	cpc	r25, r1
     83c:	79 f4       	brne	.+30     	; 0x85c <FUNCStorageInfo+0x8a>
     83e:	80 e0       	ldi	r24, 0x00	; 0
     840:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
     844:	80 91 64 00 	lds	r24, 0x0064
     848:	84 60       	ori	r24, 0x04	; 4
     84a:	80 93 64 00 	sts	0x0064, r24
     84e:	82 e8       	ldi	r24, 0x82	; 130
     850:	92 e0       	ldi	r25, 0x02	; 2
     852:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     856:	02 c0       	rjmp	.+4      	; 0x85c <FUNCStorageInfo+0x8a>
     858:	0e 94 e1 16 	call	0x2dc2	; 0x2dc2 <PM_ShowStoredItemSizes>
     85c:	8f e0       	ldi	r24, 0x0F	; 15
     85e:	18 9f       	mul	r17, r24
     860:	c0 01       	movw	r24, r0
     862:	11 24       	eor	r1, r1
     864:	86 5a       	subi	r24, 0xA6	; 166
     866:	9d 4f       	sbci	r25, 0xFD	; 253
     868:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     86c:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     870:	b6 cf       	rjmp	.-148    	; 0x7de <FUNCStorageInfo+0xc>
     872:	1f 91       	pop	r17
     874:	08 95       	ret

00000876 <MAIN_ShowProgType>:
     876:	ff 92       	push	r15
     878:	0f 93       	push	r16
     87a:	1f 93       	push	r17
     87c:	cf 93       	push	r28
     87e:	df 93       	push	r29
     880:	cd b7       	in	r28, 0x3d	; 61
     882:	de b7       	in	r29, 0x3e	; 62
     884:	27 97       	sbiw	r28, 0x07	; 7
     886:	0f b6       	in	r0, 0x3f	; 63
     888:	f8 94       	cli
     88a:	de bf       	out	0x3e, r29	; 62
     88c:	0f be       	out	0x3f, r0	; 63
     88e:	cd bf       	out	0x3d, r28	; 61
     890:	f8 2e       	mov	r15, r24
     892:	8e 01       	movw	r16, r28
     894:	0f 5f       	subi	r16, 0xFF	; 255
     896:	1f 4f       	sbci	r17, 0xFF	; 255
     898:	65 e2       	ldi	r22, 0x25	; 37
     89a:	73 e0       	ldi	r23, 0x03	; 3
     89c:	c8 01       	movw	r24, r16
     89e:	0e 94 4d 1a 	call	0x349a	; 0x349a <strcpy_P>
     8a2:	fe 82       	std	Y+6, r15	; 0x06
     8a4:	c8 01       	movw	r24, r16
     8a6:	0e 94 81 08 	call	0x1102	; 0x1102 <LCD_puts>
     8aa:	27 96       	adiw	r28, 0x07	; 7
     8ac:	0f b6       	in	r0, 0x3f	; 63
     8ae:	f8 94       	cli
     8b0:	de bf       	out	0x3e, r29	; 62
     8b2:	0f be       	out	0x3f, r0	; 63
     8b4:	cd bf       	out	0x3d, r28	; 61
     8b6:	df 91       	pop	r29
     8b8:	cf 91       	pop	r28
     8ba:	1f 91       	pop	r17
     8bc:	0f 91       	pop	r16
     8be:	ff 90       	pop	r15
     8c0:	08 95       	ret

000008c2 <FUNCStoreProgram>:
     8c2:	84 eb       	ldi	r24, 0xB4	; 180
     8c4:	99 e0       	ldi	r25, 0x09	; 9
     8c6:	90 93 01 01 	sts	0x0101, r25
     8ca:	80 93 00 01 	sts	0x0100, r24
     8ce:	0e 94 ac 09 	call	0x1358	; 0x1358 <SPI_SPIInit>
     8d2:	10 92 47 01 	sts	0x0147, r1
     8d6:	81 e0       	ldi	r24, 0x01	; 1
     8d8:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
     8dc:	0e 94 c5 0b 	call	0x178a	; 0x178a <DF_CheckCorrectOnboardChip>
     8e0:	88 23       	and	r24, r24
     8e2:	e1 f0       	breq	.+56     	; 0x91c <FUNCStoreProgram+0x5a>
     8e4:	87 ea       	ldi	r24, 0xA7	; 167
     8e6:	90 e0       	ldi	r25, 0x00	; 0
     8e8:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     8ec:	0e 94 e6 07 	call	0xfcc	; 0xfcc <OSCCAL_Calibrate>
     8f0:	80 91 c1 00 	lds	r24, 0x00C1
     8f4:	80 78       	andi	r24, 0x80	; 128
     8f6:	88 61       	ori	r24, 0x18	; 24
     8f8:	80 93 c1 00 	sts	0x00C1, r24
     8fc:	8c eb       	ldi	r24, 0xBC	; 188
     8fe:	92 e0       	ldi	r25, 0x02	; 2
     900:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     904:	85 e5       	ldi	r24, 0x55	; 85
     906:	97 e1       	ldi	r25, 0x17	; 23
     908:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <V2P_RunStateMachine>
     90c:	80 e0       	ldi	r24, 0x00	; 0
     90e:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
     912:	80 91 64 00 	lds	r24, 0x0064
     916:	84 60       	ori	r24, 0x04	; 4
     918:	80 93 64 00 	sts	0x0064, r24
     91c:	08 95       	ret

0000091e <FUNCAVRISPMode>:
     91e:	87 ea       	ldi	r24, 0xA7	; 167
     920:	90 e0       	ldi	r25, 0x00	; 0
     922:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     926:	0e 94 e6 07 	call	0xfcc	; 0xfcc <OSCCAL_Calibrate>
     92a:	e1 ec       	ldi	r30, 0xC1	; 193
     92c:	f0 e0       	ldi	r31, 0x00	; 0
     92e:	80 81       	ld	r24, Z
     930:	80 78       	andi	r24, 0x80	; 128
     932:	88 61       	ori	r24, 0x18	; 24
     934:	80 83       	st	Z, r24
     936:	86 e3       	ldi	r24, 0x36	; 54
     938:	94 e0       	ldi	r25, 0x04	; 4
     93a:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     93e:	8d ee       	ldi	r24, 0xED	; 237
     940:	92 e1       	ldi	r25, 0x12	; 18
     942:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <V2P_RunStateMachine>
     946:	08 95       	ret

00000948 <FUNCProgramDataflash>:
     948:	0e 94 32 0a 	call	0x1464	; 0x1464 <USI_SPIInitMaster>
     94c:	81 e0       	ldi	r24, 0x01	; 1
     94e:	80 93 47 01 	sts	0x0147, r24
     952:	83 ef       	ldi	r24, 0xF3	; 243
     954:	99 e0       	ldi	r25, 0x09	; 9
     956:	90 93 01 01 	sts	0x0101, r25
     95a:	80 93 00 01 	sts	0x0100, r24
     95e:	87 ea       	ldi	r24, 0xA7	; 167
     960:	90 e0       	ldi	r25, 0x00	; 0
     962:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     966:	0e 94 e6 07 	call	0xfcc	; 0xfcc <OSCCAL_Calibrate>
     96a:	e1 ec       	ldi	r30, 0xC1	; 193
     96c:	f0 e0       	ldi	r31, 0x00	; 0
     96e:	80 81       	ld	r24, Z
     970:	80 78       	andi	r24, 0x80	; 128
     972:	88 61       	ori	r24, 0x18	; 24
     974:	80 83       	st	Z, r24
     976:	89 ef       	ldi	r24, 0xF9	; 249
     978:	93 e0       	ldi	r25, 0x03	; 3
     97a:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     97e:	86 e5       	ldi	r24, 0x56	; 86
     980:	9d e0       	ldi	r25, 0x0D	; 13
     982:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <V2P_RunStateMachine>
     986:	80 e0       	ldi	r24, 0x00	; 0
     988:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
     98c:	e4 e6       	ldi	r30, 0x64	; 100
     98e:	f0 e0       	ldi	r31, 0x00	; 0
     990:	80 81       	ld	r24, Z
     992:	84 60       	ori	r24, 0x04	; 4
     994:	80 83       	st	Z, r24
     996:	08 95       	ret

00000998 <MAIN_CrashProgram>:
     998:	8c 01       	movw	r16, r24
     99a:	80 91 64 00 	lds	r24, 0x0064
     99e:	84 60       	ori	r24, 0x04	; 4
     9a0:	80 93 64 00 	sts	0x0064, r24
     9a4:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <USI_SPIOff>
     9a8:	10 92 b0 00 	sts	0x00B0, r1
     9ac:	10 92 70 00 	sts	0x0070, r1
     9b0:	10 92 81 00 	sts	0x0081, r1
     9b4:	80 e8       	ldi	r24, 0x80	; 128
     9b6:	80 93 61 00 	sts	0x0061, r24
     9ba:	83 e0       	ldi	r24, 0x03	; 3
     9bc:	80 93 61 00 	sts	0x0061, r24
     9c0:	10 92 c1 00 	sts	0x00C1, r1
     9c4:	c8 01       	movw	r24, r16
     9c6:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     9ca:	81 b3       	in	r24, 0x11	; 17
     9cc:	8f 7c       	andi	r24, 0xCF	; 207
     9ce:	80 63       	ori	r24, 0x30	; 48
     9d0:	81 bb       	out	0x11, r24	; 17
     9d2:	82 e3       	ldi	r24, 0x32	; 50
     9d4:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     9d8:	81 b3       	in	r24, 0x11	; 17
     9da:	90 e1       	ldi	r25, 0x10	; 16
     9dc:	89 27       	eor	r24, r25
     9de:	f8 cf       	rjmp	.-16     	; 0x9d0 <MAIN_CrashProgram+0x38>

000009e0 <__vector_default>:
     9e0:	8e e1       	ldi	r24, 0x1E	; 30
     9e2:	93 e0       	ldi	r25, 0x03	; 3
     9e4:	0e 94 cc 04 	call	0x998	; 0x998 <MAIN_CrashProgram>

000009e8 <FUNCProgramAVR>:
     9e8:	0f 93       	push	r16
     9ea:	1f 93       	push	r17
     9ec:	cf 93       	push	r28
     9ee:	df 93       	push	r29
     9f0:	cd b7       	in	r28, 0x3d	; 61
     9f2:	de b7       	in	r29, 0x3e	; 62
     9f4:	63 97       	sbiw	r28, 0x13	; 19
     9f6:	0f b6       	in	r0, 0x3f	; 63
     9f8:	f8 94       	cli
     9fa:	de bf       	out	0x3e, r29	; 62
     9fc:	0f be       	out	0x3f, r0	; 63
     9fe:	cd bf       	out	0x3d, r28	; 61
     a00:	84 eb       	ldi	r24, 0xB4	; 180
     a02:	99 e0       	ldi	r25, 0x09	; 9
     a04:	90 93 01 01 	sts	0x0101, r25
     a08:	80 93 00 01 	sts	0x0100, r24
     a0c:	0e 94 ac 09 	call	0x1358	; 0x1358 <SPI_SPIInit>
     a10:	10 92 47 01 	sts	0x0147, r1
     a14:	0e 94 c5 0b 	call	0x178a	; 0x178a <DF_CheckCorrectOnboardChip>
     a18:	88 23       	and	r24, r24
     a1a:	09 f4       	brne	.+2      	; 0xa1e <FUNCProgramAVR+0x36>
     a1c:	1d c1       	rjmp	.+570    	; 0xc58 <FUNCProgramAVR+0x270>
     a1e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     a22:	81 e0       	ldi	r24, 0x01	; 1
     a24:	8e bb       	out	0x1e, r24	; 30
     a26:	10 e0       	ldi	r17, 0x00	; 0
     a28:	8e b3       	in	r24, 0x1e	; 30
     a2a:	88 23       	and	r24, r24
     a2c:	e9 f3       	breq	.-6      	; 0xa28 <FUNCProgramAVR+0x40>
     a2e:	f2 99       	sbic	0x1e, 2	; 30
     a30:	13 c1       	rjmp	.+550    	; 0xc58 <FUNCProgramAVR+0x270>
     a32:	f4 99       	sbic	0x1e, 4	; 30
     a34:	1c c0       	rjmp	.+56     	; 0xa6e <FUNCProgramAVR+0x86>
     a36:	f6 9b       	sbis	0x1e, 6	; 30
     a38:	06 c0       	rjmp	.+12     	; 0xa46 <FUNCProgramAVR+0x5e>
     a3a:	11 23       	and	r17, r17
     a3c:	11 f4       	brne	.+4      	; 0xa42 <FUNCProgramAVR+0x5a>
     a3e:	17 e0       	ldi	r17, 0x07	; 7
     a40:	09 c0       	rjmp	.+18     	; 0xa54 <FUNCProgramAVR+0x6c>
     a42:	11 50       	subi	r17, 0x01	; 1
     a44:	07 c0       	rjmp	.+14     	; 0xa54 <FUNCProgramAVR+0x6c>
     a46:	f7 9b       	sbis	0x1e, 7	; 30
     a48:	05 c0       	rjmp	.+10     	; 0xa54 <FUNCProgramAVR+0x6c>
     a4a:	17 30       	cpi	r17, 0x07	; 7
     a4c:	11 f4       	brne	.+4      	; 0xa52 <FUNCProgramAVR+0x6a>
     a4e:	10 e0       	ldi	r17, 0x00	; 0
     a50:	01 c0       	rjmp	.+2      	; 0xa54 <FUNCProgramAVR+0x6c>
     a52:	1f 5f       	subi	r17, 0xFF	; 255
     a54:	e1 2f       	mov	r30, r17
     a56:	ff 27       	eor	r31, r31
     a58:	ee 0f       	add	r30, r30
     a5a:	ff 1f       	adc	r31, r31
     a5c:	ea 5e       	subi	r30, 0xEA	; 234
     a5e:	fd 4f       	sbci	r31, 0xFD	; 253
     a60:	85 91       	lpm	r24, Z+
     a62:	94 91       	lpm	r25, Z
     a64:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     a68:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     a6c:	dd cf       	rjmp	.-70     	; 0xa28 <FUNCProgramAVR+0x40>
     a6e:	80 e8       	ldi	r24, 0x80	; 128
     a70:	80 93 61 00 	sts	0x0061, r24
     a74:	10 92 61 00 	sts	0x0061, r1
     a78:	87 ea       	ldi	r24, 0xA7	; 167
     a7a:	90 e0       	ldi	r25, 0x00	; 0
     a7c:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     a80:	10 92 81 00 	sts	0x0081, r1
     a84:	0e 94 32 0a 	call	0x1464	; 0x1464 <USI_SPIInitMaster>
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     a8e:	27 e2       	ldi	r18, 0x27	; 39
     a90:	30 e0       	ldi	r19, 0x00	; 0
     a92:	e1 e9       	ldi	r30, 0x91	; 145
     a94:	f1 e0       	ldi	r31, 0x01	; 1
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     a96:	d9 01       	movw	r26, r18
     a98:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
     a9c:	80 2d       	mov	r24, r0
     a9e:	81 93       	st	Z+, r24
     aa0:	2f 5f       	subi	r18, 0xFF	; 255
     aa2:	3f 4f       	sbci	r19, 0xFF	; 255
     aa4:	80 e0       	ldi	r24, 0x00	; 0
     aa6:	23 33       	cpi	r18, 0x33	; 51
     aa8:	38 07       	cpc	r19, r24
     aaa:	a9 f7       	brne	.-22     	; 0xa96 <FUNCProgramAVR+0xae>
     aac:	0e 94 8c 12 	call	0x2518	; 0x2518 <ISPCC_EnterChipProgrammingMode>
     ab0:	10 92 a9 02 	sts	0x02A9, r1
     ab4:	10 92 aa 02 	sts	0x02AA, r1
     ab8:	10 92 ab 02 	sts	0x02AB, r1
     abc:	10 92 ac 02 	sts	0x02AC, r1
     ac0:	80 91 92 01 	lds	r24, 0x0192
     ac4:	88 23       	and	r24, r24
     ac6:	09 f0       	breq	.+2      	; 0xaca <FUNCProgramAVR+0xe2>
     ac8:	aa c0       	rjmp	.+340    	; 0xc1e <FUNCProgramAVR+0x236>
     aca:	11 23       	and	r17, r17
     acc:	31 f0       	breq	.+12     	; 0xada <FUNCProgramAVR+0xf2>
     ace:	17 30       	cpi	r17, 0x07	; 7
     ad0:	21 f0       	breq	.+8      	; 0xada <FUNCProgramAVR+0xf2>
     ad2:	11 30       	cpi	r17, 0x01	; 1
     ad4:	11 f0       	breq	.+4      	; 0xada <FUNCProgramAVR+0xf2>
     ad6:	13 30       	cpi	r17, 0x03	; 3
     ad8:	91 f4       	brne	.+36     	; 0xafe <FUNCProgramAVR+0x116>
     ada:	83 e4       	ldi	r24, 0x43	; 67
     adc:	0e 94 3b 04 	call	0x876	; 0x876 <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     ae0:	a7 e1       	ldi	r26, 0x17	; 23
     ae2:	b0 e0       	ldi	r27, 0x00	; 0
     ae4:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
     ae8:	80 2d       	mov	r24, r0
     aea:	81 30       	cpi	r24, 0x01	; 1
     aec:	31 f0       	breq	.+12     	; 0xafa <FUNCProgramAVR+0x112>
     aee:	81 e1       	ldi	r24, 0x11	; 17
     af0:	93 e0       	ldi	r25, 0x03	; 3
     af2:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     af6:	02 e0       	ldi	r16, 0x02	; 2
     af8:	03 c0       	rjmp	.+6      	; 0xb00 <FUNCProgramAVR+0x118>
     afa:	0e 94 8b 15 	call	0x2b16	; 0x2b16 <PM_SendEraseCommand>
     afe:	00 e0       	ldi	r16, 0x00	; 0
     b00:	12 30       	cpi	r17, 0x02	; 2
     b02:	10 f0       	brcs	.+4      	; 0xb08 <FUNCProgramAVR+0x120>
     b04:	13 30       	cpi	r17, 0x03	; 3
     b06:	c1 f4       	brne	.+48     	; 0xb38 <FUNCProgramAVR+0x150>
     b08:	00 23       	and	r16, r16
     b0a:	a1 f4       	brne	.+40     	; 0xb34 <FUNCProgramAVR+0x14c>
     b0c:	84 e4       	ldi	r24, 0x44	; 68
     b0e:	0e 94 3b 04 	call	0x876	; 0x876 <MAIN_ShowProgType>
     b12:	81 e0       	ldi	r24, 0x01	; 1
     b14:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <PM_GetStoredDataSize>
     b18:	61 15       	cp	r22, r1
     b1a:	71 05       	cpc	r23, r1
     b1c:	81 05       	cpc	r24, r1
     b1e:	91 05       	cpc	r25, r1
     b20:	31 f4       	brne	.+12     	; 0xb2e <FUNCProgramAVR+0x146>
     b22:	89 e0       	ldi	r24, 0x09	; 9
     b24:	93 e0       	ldi	r25, 0x03	; 3
     b26:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     b2a:	03 e0       	ldi	r16, 0x03	; 3
     b2c:	03 c0       	rjmp	.+6      	; 0xb34 <FUNCProgramAVR+0x14c>
     b2e:	81 e0       	ldi	r24, 0x01	; 1
     b30:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <PM_CreateProgrammingPackets>
     b34:	11 23       	and	r17, r17
     b36:	21 f0       	breq	.+8      	; 0xb40 <FUNCProgramAVR+0x158>
     b38:	12 30       	cpi	r17, 0x02	; 2
     b3a:	11 f0       	breq	.+4      	; 0xb40 <FUNCProgramAVR+0x158>
     b3c:	13 30       	cpi	r17, 0x03	; 3
     b3e:	b1 f4       	brne	.+44     	; 0xb6c <FUNCProgramAVR+0x184>
     b40:	85 e4       	ldi	r24, 0x45	; 69
     b42:	0e 94 3b 04 	call	0x876	; 0x876 <MAIN_ShowProgType>
     b46:	80 e0       	ldi	r24, 0x00	; 0
     b48:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <PM_GetStoredDataSize>
     b4c:	61 15       	cp	r22, r1
     b4e:	71 05       	cpc	r23, r1
     b50:	81 05       	cpc	r24, r1
     b52:	91 05       	cpc	r25, r1
     b54:	31 f4       	brne	.+12     	; 0xb62 <FUNCProgramAVR+0x17a>
     b56:	8f ef       	ldi	r24, 0xFF	; 255
     b58:	92 e0       	ldi	r25, 0x02	; 2
     b5a:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     b5e:	03 e0       	ldi	r16, 0x03	; 3
     b60:	03 c0       	rjmp	.+6      	; 0xb68 <FUNCProgramAVR+0x180>
     b62:	80 e0       	ldi	r24, 0x00	; 0
     b64:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <PM_CreateProgrammingPackets>
     b68:	11 23       	and	r17, r17
     b6a:	21 f0       	breq	.+8      	; 0xb74 <FUNCProgramAVR+0x18c>
     b6c:	14 30       	cpi	r17, 0x04	; 4
     b6e:	11 f0       	breq	.+4      	; 0xb74 <FUNCProgramAVR+0x18c>
     b70:	16 30       	cpi	r17, 0x06	; 6
     b72:	a9 f4       	brne	.+42     	; 0xb9e <FUNCProgramAVR+0x1b6>
     b74:	86 e4       	ldi	r24, 0x46	; 70
     b76:	0e 94 3b 04 	call	0x876	; 0x876 <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     b7a:	a3 e3       	ldi	r26, 0x33	; 51
     b7c:	b0 e0       	ldi	r27, 0x00	; 0
     b7e:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
     b82:	80 2d       	mov	r24, r0
     b84:	88 23       	and	r24, r24
     b86:	31 f4       	brne	.+12     	; 0xb94 <FUNCProgramAVR+0x1ac>
     b88:	81 ef       	ldi	r24, 0xF1	; 241
     b8a:	92 e0       	ldi	r25, 0x02	; 2
     b8c:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     b90:	03 e0       	ldi	r16, 0x03	; 3
     b92:	03 c0       	rjmp	.+6      	; 0xb9a <FUNCProgramAVR+0x1b2>
     b94:	82 e0       	ldi	r24, 0x02	; 2
     b96:	0e 94 4d 15 	call	0x2a9a	; 0x2a9a <PM_SendFuseLockBytes>
     b9a:	11 23       	and	r17, r17
     b9c:	79 f0       	breq	.+30     	; 0xbbc <FUNCProgramAVR+0x1d4>
     b9e:	15 30       	cpi	r17, 0x05	; 5
     ba0:	69 f0       	breq	.+26     	; 0xbbc <FUNCProgramAVR+0x1d4>
     ba2:	16 30       	cpi	r17, 0x06	; 6
     ba4:	19 f5       	brne	.+70     	; 0xbec <FUNCProgramAVR+0x204>
     ba6:	81 e0       	ldi	r24, 0x01	; 1
     ba8:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     bac:	81 e0       	ldi	r24, 0x01	; 1
     bae:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     bb2:	80 e0       	ldi	r24, 0x00	; 0
     bb4:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     bb8:	0e 94 8c 12 	call	0x2518	; 0x2518 <ISPCC_EnterChipProgrammingMode>
     bbc:	8c e4       	ldi	r24, 0x4C	; 76
     bbe:	0e 94 3b 04 	call	0x876	; 0x876 <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     bc2:	a4 e3       	ldi	r26, 0x34	; 52
     bc4:	b0 e0       	ldi	r27, 0x00	; 0
     bc6:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
     bca:	80 2d       	mov	r24, r0
     bcc:	88 23       	and	r24, r24
     bce:	59 f4       	brne	.+22     	; 0xbe6 <FUNCProgramAVR+0x1fe>
     bd0:	83 ee       	ldi	r24, 0xE3	; 227
     bd2:	92 e0       	ldi	r25, 0x02	; 2
     bd4:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     bd8:	62 ed       	ldi	r22, 0xD2	; 210
     bda:	72 e0       	ldi	r23, 0x02	; 2
     bdc:	ce 01       	movw	r24, r28
     bde:	01 96       	adiw	r24, 0x01	; 1
     be0:	0e 94 4d 1a 	call	0x349a	; 0x349a <strcpy_P>
     be4:	0b c0       	rjmp	.+22     	; 0xbfc <FUNCProgramAVR+0x214>
     be6:	83 e0       	ldi	r24, 0x03	; 3
     be8:	0e 94 4d 15 	call	0x2a9a	; 0x2a9a <PM_SendFuseLockBytes>
     bec:	62 ed       	ldi	r22, 0xD2	; 210
     bee:	72 e0       	ldi	r23, 0x02	; 2
     bf0:	ce 01       	movw	r24, r28
     bf2:	01 96       	adiw	r24, 0x01	; 1
     bf4:	0e 94 4d 1a 	call	0x349a	; 0x349a <strcpy_P>
     bf8:	00 23       	and	r16, r16
     bfa:	31 f0       	breq	.+12     	; 0xc08 <FUNCProgramAVR+0x220>
     bfc:	6b ec       	ldi	r22, 0xCB	; 203
     bfe:	72 e0       	ldi	r23, 0x02	; 2
     c00:	ce 01       	movw	r24, r28
     c02:	0d 96       	adiw	r24, 0x0d	; 13
     c04:	0e 94 4d 1a 	call	0x349a	; 0x349a <strcpy_P>
     c08:	ce 01       	movw	r24, r28
     c0a:	01 96       	adiw	r24, 0x01	; 1
     c0c:	0e 94 81 08 	call	0x1102	; 0x1102 <LCD_puts>
     c10:	8a ef       	ldi	r24, 0xFA	; 250
     c12:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     c16:	88 ec       	ldi	r24, 0xC8	; 200
     c18:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     c1c:	04 c0       	rjmp	.+8      	; 0xc26 <FUNCProgramAVR+0x23e>
     c1e:	8b e2       	ldi	r24, 0x2B	; 43
     c20:	94 e0       	ldi	r25, 0x04	; 4
     c22:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
     c26:	0e 94 44 0c 	call	0x1888	; 0x1888 <TOUT_SetupSleepTimer>
     c2a:	80 e8       	ldi	r24, 0x80	; 128
     c2c:	80 93 61 00 	sts	0x0061, r24
     c30:	83 e0       	ldi	r24, 0x03	; 3
     c32:	80 93 61 00 	sts	0x0061, r24
     c36:	81 e0       	ldi	r24, 0x01	; 1
     c38:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     c3c:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <USI_SPIOff>
     c40:	80 e0       	ldi	r24, 0x00	; 0
     c42:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
     c46:	80 91 64 00 	lds	r24, 0x0064
     c4a:	84 60       	ori	r24, 0x04	; 4
     c4c:	80 93 64 00 	sts	0x0064, r24
     c50:	81 b3       	in	r24, 0x11	; 17
     c52:	8f 7c       	andi	r24, 0xCF	; 207
     c54:	80 61       	ori	r24, 0x10	; 16
     c56:	81 bb       	out	0x11, r24	; 17
     c58:	63 96       	adiw	r28, 0x13	; 19
     c5a:	0f b6       	in	r0, 0x3f	; 63
     c5c:	f8 94       	cli
     c5e:	de bf       	out	0x3e, r29	; 62
     c60:	0f be       	out	0x3f, r0	; 63
     c62:	cd bf       	out	0x3d, r28	; 61
     c64:	df 91       	pop	r29
     c66:	cf 91       	pop	r28
     c68:	1f 91       	pop	r17
     c6a:	0f 91       	pop	r16
     c6c:	08 95       	ret

00000c6e <main>:
     c6e:	1f 93       	push	r17
     c70:	80 e8       	ldi	r24, 0x80	; 128
     c72:	85 bf       	out	0x35, r24	; 53
     c74:	85 bf       	out	0x35, r24	; 53
     c76:	80 bf       	out	0x30, r24	; 48
     c78:	85 e0       	ldi	r24, 0x05	; 5
     c7a:	80 93 64 00 	sts	0x0064, r24
     c7e:	80 e3       	ldi	r24, 0x30	; 48
     c80:	80 bb       	out	0x10, r24	; 16
     c82:	87 e2       	ldi	r24, 0x27	; 39
     c84:	84 b9       	out	0x04, r24	; 4
     c86:	8f ed       	ldi	r24, 0xDF	; 223
     c88:	85 b9       	out	0x05, r24	; 5
     c8a:	8c e0       	ldi	r24, 0x0C	; 12
     c8c:	8e b9       	out	0x0e, r24	; 14
     c8e:	80 93 6b 00 	sts	0x006B, r24
     c92:	80 ed       	ldi	r24, 0xD0	; 208
     c94:	80 93 6c 00 	sts	0x006C, r24
     c98:	80 ec       	ldi	r24, 0xC0	; 192
     c9a:	8d bb       	out	0x1d, r24	; 29
     c9c:	8c bb       	out	0x1c, r24	; 28
     c9e:	81 b3       	in	r24, 0x11	; 17
     ca0:	8f 7c       	andi	r24, 0xCF	; 207
     ca2:	80 63       	ori	r24, 0x30	; 48
     ca4:	81 bb       	out	0x11, r24	; 17
     ca6:	81 e0       	ldi	r24, 0x01	; 1
     ca8:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     cac:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_Init>
     cb0:	8f e0       	ldi	r24, 0x0F	; 15
     cb2:	80 93 e7 00 	sts	0x00E7, r24
     cb6:	87 ea       	ldi	r24, 0xA7	; 167
     cb8:	90 e0       	ldi	r25, 0x00	; 0
     cba:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     cbe:	78 94       	sei
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     cc0:	ad e8       	ldi	r26, 0x8D	; 141
     cc2:	b0 e0       	ldi	r27, 0x00	; 0
     cc4:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
     cc8:	80 2d       	mov	r24, r0
     cca:	8a 37       	cpi	r24, 0x7A	; 122
     ccc:	89 f0       	breq	.+34     	; 0xcf0 <main+0x82>
     cce:	80 e0       	ldi	r24, 0x00	; 0
     cd0:	90 e0       	ldi	r25, 0x00	; 0
     cd2:	2f ef       	ldi	r18, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     cd4:	dc 01       	movw	r26, r24
     cd6:	02 2e       	mov	r0, r18
     cd8:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
     cdc:	01 96       	adiw	r24, 0x01	; 1
     cde:	8e 38       	cpi	r24, 0x8E	; 142
     ce0:	91 05       	cpc	r25, r1
     ce2:	c1 f7       	brne	.-16     	; 0xcd4 <main+0x66>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     ce4:	8a e7       	ldi	r24, 0x7A	; 122
     ce6:	ad e8       	ldi	r26, 0x8D	; 141
     ce8:	b0 e0       	ldi	r27, 0x00	; 0
     cea:	08 2e       	mov	r0, r24
     cec:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
     cf0:	a9 e8       	ldi	r26, 0x89	; 137
     cf2:	b0 e0       	ldi	r27, 0x00	; 0
     cf4:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
     cf8:	80 2d       	mov	r24, r0
     cfa:	8f 70       	andi	r24, 0x0F	; 15
     cfc:	80 93 e7 00 	sts	0x00E7, r24
     d00:	80 e0       	ldi	r24, 0x00	; 0
     d02:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
     d06:	0e 94 9b 09 	call	0x1336	; 0x1336 <USART_Init>
     d0a:	0e 94 e6 07 	call	0xfcc	; 0xfcc <OSCCAL_Calibrate>
     d0e:	0e 94 44 0c 	call	0x1888	; 0x1888 <TOUT_SetupSleepTimer>
     d12:	81 b3       	in	r24, 0x11	; 17
     d14:	8f 7c       	andi	r24, 0xCF	; 207
     d16:	80 61       	ori	r24, 0x10	; 16
     d18:	81 bb       	out	0x11, r24	; 17
     d1a:	80 e8       	ldi	r24, 0x80	; 128
     d1c:	80 93 61 00 	sts	0x0061, r24
     d20:	83 e0       	ldi	r24, 0x03	; 3
     d22:	80 93 61 00 	sts	0x0061, r24
     d26:	81 e0       	ldi	r24, 0x01	; 1
     d28:	8e bb       	out	0x1e, r24	; 30
     d2a:	10 e0       	ldi	r17, 0x00	; 0
     d2c:	8e b3       	in	r24, 0x1e	; 30
     d2e:	88 23       	and	r24, r24
     d30:	e9 f3       	breq	.-6      	; 0xd2c <main+0xbe>
     d32:	f6 9b       	sbis	0x1e, 6	; 30
     d34:	06 c0       	rjmp	.+12     	; 0xd42 <main+0xd4>
     d36:	11 23       	and	r17, r17
     d38:	11 f4       	brne	.+4      	; 0xd3e <main+0xd0>
     d3a:	16 e0       	ldi	r17, 0x06	; 6
     d3c:	1b c0       	rjmp	.+54     	; 0xd74 <main+0x106>
     d3e:	11 50       	subi	r17, 0x01	; 1
     d40:	19 c0       	rjmp	.+50     	; 0xd74 <main+0x106>
     d42:	f7 9b       	sbis	0x1e, 7	; 30
     d44:	06 c0       	rjmp	.+12     	; 0xd52 <main+0xe4>
     d46:	16 30       	cpi	r17, 0x06	; 6
     d48:	11 f4       	brne	.+4      	; 0xd4e <main+0xe0>
     d4a:	10 e0       	ldi	r17, 0x00	; 0
     d4c:	13 c0       	rjmp	.+38     	; 0xd74 <main+0x106>
     d4e:	1f 5f       	subi	r17, 0xFF	; 255
     d50:	11 c0       	rjmp	.+34     	; 0xd74 <main+0x106>
     d52:	f4 9b       	sbis	0x1e, 4	; 30
     d54:	0b c0       	rjmp	.+22     	; 0xd6c <main+0xfe>
     d56:	e1 2f       	mov	r30, r17
     d58:	ff 27       	eor	r31, r31
     d5a:	ee 0f       	add	r30, r30
     d5c:	ff 1f       	adc	r31, r31
     d5e:	ef 5e       	subi	r30, 0xEF	; 239
     d60:	fe 4f       	sbci	r31, 0xFE	; 254
     d62:	85 91       	lpm	r24, Z+
     d64:	94 91       	lpm	r25, Z
     d66:	fc 01       	movw	r30, r24
     d68:	09 95       	icall
     d6a:	04 c0       	rjmp	.+8      	; 0xd74 <main+0x106>
     d6c:	f3 9b       	sbis	0x1e, 3	; 30
     d6e:	02 c0       	rjmp	.+4      	; 0xd74 <main+0x106>
     d70:	0e 94 04 03 	call	0x608	; 0x608 <FUNCShowAbout>
     d74:	e1 2f       	mov	r30, r17
     d76:	ff 27       	eor	r31, r31
     d78:	ee 0f       	add	r30, r30
     d7a:	ff 1f       	adc	r31, r31
     d7c:	ed 5f       	subi	r30, 0xFD	; 253
     d7e:	fe 4f       	sbci	r31, 0xFE	; 254
     d80:	85 91       	lpm	r24, Z+
     d82:	94 91       	lpm	r25, Z
     d84:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     d88:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     d8c:	cf cf       	rjmp	.-98     	; 0xd2c <main+0xbe>

00000d8e <FUNCClearMem>:
     d8e:	84 eb       	ldi	r24, 0xB4	; 180
     d90:	92 e0       	ldi	r25, 0x02	; 2
     d92:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     d96:	84 eb       	ldi	r24, 0xB4	; 180
     d98:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     d9c:	8e ea       	ldi	r24, 0xAE	; 174
     d9e:	92 e0       	ldi	r25, 0x02	; 2
     da0:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     da4:	8e b3       	in	r24, 0x1e	; 30
     da6:	88 23       	and	r24, r24
     da8:	e9 f3       	breq	.-6      	; 0xda4 <FUNCClearMem+0x16>
     daa:	f2 99       	sbic	0x1e, 2	; 30
     dac:	22 c0       	rjmp	.+68     	; 0xdf2 <FUNCClearMem+0x64>
     dae:	f3 9b       	sbis	0x1e, 3	; 30
     db0:	f9 cf       	rjmp	.-14     	; 0xda4 <FUNCClearMem+0x16>
     db2:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     db6:	87 ea       	ldi	r24, 0xA7	; 167
     db8:	90 e0       	ldi	r25, 0x00	; 0
     dba:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     dbe:	81 b3       	in	r24, 0x11	; 17
     dc0:	8f 7c       	andi	r24, 0xCF	; 207
     dc2:	80 63       	ori	r24, 0x30	; 48
     dc4:	81 bb       	out	0x11, r24	; 17
     dc6:	80 e0       	ldi	r24, 0x00	; 0
     dc8:	90 e0       	ldi	r25, 0x00	; 0
     dca:	2f ef       	ldi	r18, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     dcc:	dc 01       	movw	r26, r24
     dce:	02 2e       	mov	r0, r18
     dd0:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
     dd4:	01 96       	adiw	r24, 0x01	; 1
     dd6:	8e 38       	cpi	r24, 0x8E	; 142
     dd8:	91 05       	cpc	r25, r1
     dda:	c1 f7       	brne	.-16     	; 0xdcc <FUNCClearMem+0x3e>
     ddc:	81 b3       	in	r24, 0x11	; 17
     dde:	8f 7c       	andi	r24, 0xCF	; 207
     de0:	80 61       	ori	r24, 0x10	; 16
     de2:	81 bb       	out	0x11, r24	; 17
     de4:	82 ea       	ldi	r24, 0xA2	; 162
     de6:	92 e0       	ldi	r25, 0x02	; 2
     de8:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     dec:	8a ef       	ldi	r24, 0xFA	; 250
     dee:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     df2:	08 95       	ret

00000df4 <FUNCSetContrast>:
     df4:	1f 93       	push	r17
     df6:	cf 93       	push	r28
     df8:	df 93       	push	r29
     dfa:	cd b7       	in	r28, 0x3d	; 61
     dfc:	de b7       	in	r29, 0x3e	; 62
     dfe:	26 97       	sbiw	r28, 0x06	; 6
     e00:	0f b6       	in	r0, 0x3f	; 63
     e02:	f8 94       	cli
     e04:	de bf       	out	0x3e, r29	; 62
     e06:	0f be       	out	0x3f, r0	; 63
     e08:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     e0a:	a9 e8       	ldi	r26, 0x89	; 137
     e0c:	b0 e0       	ldi	r27, 0x00	; 0
     e0e:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
     e12:	80 2d       	mov	r24, r0
     e14:	18 2f       	mov	r17, r24
     e16:	1f 70       	andi	r17, 0x0F	; 15
     e18:	81 e0       	ldi	r24, 0x01	; 1
     e1a:	8e bb       	out	0x1e, r24	; 30
     e1c:	8e b3       	in	r24, 0x1e	; 30
     e1e:	88 23       	and	r24, r24
     e20:	e9 f3       	breq	.-6      	; 0xe1c <FUNCSetContrast+0x28>
     e22:	f6 9b       	sbis	0x1e, 6	; 30
     e24:	04 c0       	rjmp	.+8      	; 0xe2e <FUNCSetContrast+0x3a>
     e26:	1f 30       	cpi	r17, 0x0F	; 15
     e28:	50 f4       	brcc	.+20     	; 0xe3e <FUNCSetContrast+0x4a>
     e2a:	1f 5f       	subi	r17, 0xFF	; 255
     e2c:	08 c0       	rjmp	.+16     	; 0xe3e <FUNCSetContrast+0x4a>
     e2e:	f7 9b       	sbis	0x1e, 7	; 30
     e30:	04 c0       	rjmp	.+8      	; 0xe3a <FUNCSetContrast+0x46>
     e32:	12 30       	cpi	r17, 0x02	; 2
     e34:	20 f0       	brcs	.+8      	; 0xe3e <FUNCSetContrast+0x4a>
     e36:	11 50       	subi	r17, 0x01	; 1
     e38:	02 c0       	rjmp	.+4      	; 0xe3e <FUNCSetContrast+0x4a>
     e3a:	f2 99       	sbic	0x1e, 2	; 30
     e3c:	18 c0       	rjmp	.+48     	; 0xe6e <FUNCSetContrast+0x7a>
     e3e:	83 e4       	ldi	r24, 0x43	; 67
     e40:	89 83       	std	Y+1, r24	; 0x01
     e42:	84 e5       	ldi	r24, 0x54	; 84
     e44:	8a 83       	std	Y+2, r24	; 0x02
     e46:	80 e2       	ldi	r24, 0x20	; 32
     e48:	8b 83       	std	Y+3, r24	; 0x03
     e4a:	be 01       	movw	r22, r28
     e4c:	6c 5f       	subi	r22, 0xFC	; 252
     e4e:	7f 4f       	sbci	r23, 0xFF	; 255
     e50:	81 2f       	mov	r24, r17
     e52:	99 27       	eor	r25, r25
     e54:	0e 94 9c 02 	call	0x538	; 0x538 <MAIN_IntToStr>
     e58:	ce 01       	movw	r24, r28
     e5a:	01 96       	adiw	r24, 0x01	; 1
     e5c:	0e 94 81 08 	call	0x1102	; 0x1102 <LCD_puts>
     e60:	81 2f       	mov	r24, r17
     e62:	8f 70       	andi	r24, 0x0F	; 15
     e64:	80 93 e7 00 	sts	0x00E7, r24
     e68:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     e6c:	d7 cf       	rjmp	.-82     	; 0xe1c <FUNCSetContrast+0x28>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     e6e:	a9 e8       	ldi	r26, 0x89	; 137
     e70:	b0 e0       	ldi	r27, 0x00	; 0
     e72:	01 2e       	mov	r0, r17
     e74:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
     e78:	26 96       	adiw	r28, 0x06	; 6
     e7a:	0f b6       	in	r0, 0x3f	; 63
     e7c:	f8 94       	cli
     e7e:	de bf       	out	0x3e, r29	; 62
     e80:	0f be       	out	0x3f, r0	; 63
     e82:	cd bf       	out	0x3d, r28	; 61
     e84:	df 91       	pop	r29
     e86:	cf 91       	pop	r28
     e88:	1f 91       	pop	r17
     e8a:	08 95       	ret

00000e8c <FUNCSetISPSpeed>:
     e8c:	1f 93       	push	r17
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     e8e:	a2 e0       	ldi	r26, 0x02	; 2
     e90:	b0 e0       	ldi	r27, 0x00	; 0
     e92:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
     e96:	80 2d       	mov	r24, r0
     e98:	18 2f       	mov	r17, r24
     e9a:	84 30       	cpi	r24, 0x04	; 4
     e9c:	08 f0       	brcs	.+2      	; 0xea0 <FUNCSetISPSpeed+0x14>
     e9e:	13 e0       	ldi	r17, 0x03	; 3
     ea0:	81 e0       	ldi	r24, 0x01	; 1
     ea2:	8e bb       	out	0x1e, r24	; 30
     ea4:	8e b3       	in	r24, 0x1e	; 30
     ea6:	88 23       	and	r24, r24
     ea8:	e9 f3       	breq	.-6      	; 0xea4 <FUNCSetISPSpeed+0x18>
     eaa:	f6 9b       	sbis	0x1e, 6	; 30
     eac:	06 c0       	rjmp	.+12     	; 0xeba <FUNCSetISPSpeed+0x2e>
     eae:	11 23       	and	r17, r17
     eb0:	11 f4       	brne	.+4      	; 0xeb6 <FUNCSetISPSpeed+0x2a>
     eb2:	13 e0       	ldi	r17, 0x03	; 3
     eb4:	0c c0       	rjmp	.+24     	; 0xece <FUNCSetISPSpeed+0x42>
     eb6:	11 50       	subi	r17, 0x01	; 1
     eb8:	0a c0       	rjmp	.+20     	; 0xece <FUNCSetISPSpeed+0x42>
     eba:	f7 9b       	sbis	0x1e, 7	; 30
     ebc:	04 c0       	rjmp	.+8      	; 0xec6 <FUNCSetISPSpeed+0x3a>
     ebe:	13 30       	cpi	r17, 0x03	; 3
     ec0:	29 f0       	breq	.+10     	; 0xecc <FUNCSetISPSpeed+0x40>
     ec2:	1f 5f       	subi	r17, 0xFF	; 255
     ec4:	04 c0       	rjmp	.+8      	; 0xece <FUNCSetISPSpeed+0x42>
     ec6:	f2 9b       	sbis	0x1e, 2	; 30
     ec8:	02 c0       	rjmp	.+4      	; 0xece <FUNCSetISPSpeed+0x42>
     eca:	0c c0       	rjmp	.+24     	; 0xee4 <FUNCSetISPSpeed+0x58>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     ecc:	10 e0       	ldi	r17, 0x00	; 0
     ece:	8a e0       	ldi	r24, 0x0A	; 10
     ed0:	18 9f       	mul	r17, r24
     ed2:	c0 01       	movw	r24, r0
     ed4:	11 24       	eor	r1, r1
     ed6:	8a 5d       	subi	r24, 0xDA	; 218
     ed8:	9d 4f       	sbci	r25, 0xFD	; 253
     eda:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     ede:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     ee2:	e0 cf       	rjmp	.-64     	; 0xea4 <FUNCSetISPSpeed+0x18>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     ee4:	a2 e0       	ldi	r26, 0x02	; 2
     ee6:	b0 e0       	ldi	r27, 0x00	; 0
     ee8:	01 2e       	mov	r0, r17
     eea:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
     eee:	1f 91       	pop	r17
     ef0:	08 95       	ret

00000ef2 <FUNCSetResetMode>:
     ef2:	1f 93       	push	r17
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     ef4:	ac e8       	ldi	r26, 0x8C	; 140
     ef6:	b0 e0       	ldi	r27, 0x00	; 0
     ef8:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
     efc:	80 2d       	mov	r24, r0
     efe:	18 2f       	mov	r17, r24
     f00:	11 70       	andi	r17, 0x01	; 1
     f02:	81 e0       	ldi	r24, 0x01	; 1
     f04:	8e bb       	out	0x1e, r24	; 30
     f06:	8e b3       	in	r24, 0x1e	; 30
     f08:	88 23       	and	r24, r24
     f0a:	e9 f3       	breq	.-6      	; 0xf06 <FUNCSetResetMode+0x14>
     f0c:	f6 99       	sbic	0x1e, 6	; 30
     f0e:	02 c0       	rjmp	.+4      	; 0xf14 <FUNCSetResetMode+0x22>
     f10:	f7 9b       	sbis	0x1e, 7	; 30
     f12:	03 c0       	rjmp	.+6      	; 0xf1a <FUNCSetResetMode+0x28>
     f14:	81 e0       	ldi	r24, 0x01	; 1
     f16:	18 27       	eor	r17, r24
     f18:	02 c0       	rjmp	.+4      	; 0xf1e <FUNCSetResetMode+0x2c>
     f1a:	f2 99       	sbic	0x1e, 2	; 30
     f1c:	0b c0       	rjmp	.+22     	; 0xf34 <FUNCSetResetMode+0x42>
     f1e:	86 e0       	ldi	r24, 0x06	; 6
     f20:	18 9f       	mul	r17, r24
     f22:	c0 01       	movw	r24, r0
     f24:	11 24       	eor	r1, r1
     f26:	82 5b       	subi	r24, 0xB2	; 178
     f28:	9d 4f       	sbci	r25, 0xFD	; 253
     f2a:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
     f2e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     f32:	e9 cf       	rjmp	.-46     	; 0xf06 <FUNCSetResetMode+0x14>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     f34:	ac e8       	ldi	r26, 0x8C	; 140
     f36:	b0 e0       	ldi	r27, 0x00	; 0
     f38:	01 2e       	mov	r0, r17
     f3a:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
     f3e:	1f 91       	pop	r17
     f40:	08 95       	ret

00000f42 <FUNCSetFirmMinorVer>:
     f42:	1f 93       	push	r17
     f44:	cf 93       	push	r28
     f46:	df 93       	push	r29
     f48:	cd b7       	in	r28, 0x3d	; 61
     f4a:	de b7       	in	r29, 0x3e	; 62
     f4c:	25 97       	sbiw	r28, 0x05	; 5
     f4e:	0f b6       	in	r0, 0x3f	; 63
     f50:	f8 94       	cli
     f52:	de bf       	out	0x3e, r29	; 62
     f54:	0f be       	out	0x3f, r0	; 63
     f56:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     f58:	aa e8       	ldi	r26, 0x8A	; 138
     f5a:	b0 e0       	ldi	r27, 0x00	; 0
     f5c:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
     f60:	80 2d       	mov	r24, r0
     f62:	18 2f       	mov	r17, r24
     f64:	8a 30       	cpi	r24, 0x0A	; 10
     f66:	08 f0       	brcs	.+2      	; 0xf6a <FUNCSetFirmMinorVer+0x28>
     f68:	14 e0       	ldi	r17, 0x04	; 4
     f6a:	6d e9       	ldi	r22, 0x9D	; 157
     f6c:	72 e0       	ldi	r23, 0x02	; 2
     f6e:	ce 01       	movw	r24, r28
     f70:	01 96       	adiw	r24, 0x01	; 1
     f72:	0e 94 4d 1a 	call	0x349a	; 0x349a <strcpy_P>
     f76:	81 e0       	ldi	r24, 0x01	; 1
     f78:	8e bb       	out	0x1e, r24	; 30
     f7a:	8e b3       	in	r24, 0x1e	; 30
     f7c:	88 23       	and	r24, r24
     f7e:	e9 f3       	breq	.-6      	; 0xf7a <FUNCSetFirmMinorVer+0x38>
     f80:	f6 9b       	sbis	0x1e, 6	; 30
     f82:	03 c0       	rjmp	.+6      	; 0xf8a <FUNCSetFirmMinorVer+0x48>
     f84:	19 30       	cpi	r17, 0x09	; 9
     f86:	08 f4       	brcc	.+2      	; 0xf8a <FUNCSetFirmMinorVer+0x48>
     f88:	1f 5f       	subi	r17, 0xFF	; 255
     f8a:	f7 9b       	sbis	0x1e, 7	; 30
     f8c:	04 c0       	rjmp	.+8      	; 0xf96 <FUNCSetFirmMinorVer+0x54>
     f8e:	11 23       	and	r17, r17
     f90:	21 f0       	breq	.+8      	; 0xf9a <FUNCSetFirmMinorVer+0x58>
     f92:	11 50       	subi	r17, 0x01	; 1
     f94:	02 c0       	rjmp	.+4      	; 0xf9a <FUNCSetFirmMinorVer+0x58>
     f96:	f2 99       	sbic	0x1e, 2	; 30
     f98:	0a c0       	rjmp	.+20     	; 0xfae <FUNCSetFirmMinorVer+0x6c>
     f9a:	10 5d       	subi	r17, 0xD0	; 208
     f9c:	1c 83       	std	Y+4, r17	; 0x04
     f9e:	10 53       	subi	r17, 0x30	; 48
     fa0:	ce 01       	movw	r24, r28
     fa2:	01 96       	adiw	r24, 0x01	; 1
     fa4:	0e 94 81 08 	call	0x1102	; 0x1102 <LCD_puts>
     fa8:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     fac:	e6 cf       	rjmp	.-52     	; 0xf7a <FUNCSetFirmMinorVer+0x38>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     fae:	aa e8       	ldi	r26, 0x8A	; 138
     fb0:	b0 e0       	ldi	r27, 0x00	; 0
     fb2:	01 2e       	mov	r0, r17
     fb4:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
     fb8:	25 96       	adiw	r28, 0x05	; 5
     fba:	0f b6       	in	r0, 0x3f	; 63
     fbc:	f8 94       	cli
     fbe:	de bf       	out	0x3e, r29	; 62
     fc0:	0f be       	out	0x3f, r0	; 63
     fc2:	cd bf       	out	0x3d, r28	; 61
     fc4:	df 91       	pop	r29
     fc6:	cf 91       	pop	r28
     fc8:	1f 91       	pop	r17
     fca:	08 95       	ret

00000fcc <OSCCAL_Calibrate>:

volatile uint16_t ActualCount = 0;

void OSCCAL_Calibrate(void)
{
     fcc:	10 92 05 01 	sts	0x0105, r1
     fd0:	10 92 04 01 	sts	0x0104, r1
	uint8_t SREG_Backup;
	uint8_t LoopCount = (0x7F / 2); // Maximum range is 128, and starts from the middle, so 64 is the max number of iterations required
	uint8_t PrevOSCALValues[4] = {0,0,0,0};
   
	// Reset ActualCount
	ActualCount = 0;
   
	// Make sure all clock division is turned off (8Mhz RC clock)
	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_BASECLOCKSPEED_8MHZ);
     fd4:	80 e8       	ldi	r24, 0x80	; 128
     fd6:	80 93 61 00 	sts	0x0061, r24
     fda:	10 92 61 00 	sts	0x0061, r1

	// Inital OSCCAL of half its maximum
	OSCCAL = (0x7F / 2);
     fde:	8f e3       	ldi	r24, 0x3F	; 63
     fe0:	80 93 66 00 	sts	0x0066, r24

	// Save the SREG
	SREG_Backup = SREG;
     fe4:	7f b7       	in	r23, 0x3f	; 63
    
	// Disable all timer 1 interrupts
	TIMSK1 = 0;
     fe6:	10 92 6f 00 	sts	0x006F, r1
        
	// Set timer 2 to asyncronous mode (32.768KHz crystal)
	ASSR   = (1 << AS2);
     fea:	88 e0       	ldi	r24, 0x08	; 8
     fec:	80 93 b6 00 	sts	0x00B6, r24
        
	// Timer 2 overflow interrupt enable
	TIMSK2 = (1 << TOIE2);
     ff0:	81 e0       	ldi	r24, 0x01	; 1
     ff2:	80 93 70 00 	sts	0x0070, r24

	// Enable interrupts
	sei();
     ff6:	78 94       	sei

	// Start both counters with no prescaling
	TCCR1B = (1 << CS10);
     ff8:	80 93 81 00 	sts	0x0081, r24
	TCCR2A = (1 << CS20);
     ffc:	80 93 b0 00 	sts	0x00B0, r24
	 	 
	// Previous OSCCAL value of 0
	PrevOSCALValues[0] = 0;

	// Wait until timer 2's external 32.768KHz crystal is stable
	while (ASSR & ((1 << TCN2UB) | (1 << TCR2UB) | (1 << OCR2UB)));
    1000:	80 91 b6 00 	lds	r24, 0x00B6
    1004:	99 27       	eor	r25, r25
    1006:	87 70       	andi	r24, 0x07	; 7
    1008:	90 70       	andi	r25, 0x00	; 0
    100a:	89 2b       	or	r24, r25
    100c:	c9 f7       	brne	.-14     	; 0x1000 <OSCCAL_Calibrate+0x34>
    
	// Clear the timer values
	TCNT1  = 0;
    100e:	10 92 85 00 	sts	0x0085, r1
    1012:	10 92 84 00 	sts	0x0084, r1
	TCNT2  = 0;
    1016:	10 92 b2 00 	sts	0x00B2, r1
    101a:	3e e3       	ldi	r19, 0x3E	; 62
    101c:	60 e0       	ldi	r22, 0x00	; 0
    101e:	50 e0       	ldi	r21, 0x00	; 0
    1020:	20 e0       	ldi	r18, 0x00	; 0
    1022:	e9 e9       	ldi	r30, 0x99	; 153
    1024:	f9 ec       	ldi	r31, 0xC9	; 201
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1026:	cf 01       	movw	r24, r30
    1028:	01 97       	sbiw	r24, 0x01	; 1
    102a:	f1 f7       	brne	.-4      	; 0x1028 <OSCCAL_Calibrate+0x5c>
    
	while (LoopCount--)
	{
		// Let it take a few readings (28ms, approx 4 readings)
		_delay_ms(28);

		PrevOSCALValues[3] = PrevOSCALValues[2];
		PrevOSCALValues[2] = PrevOSCALValues[1];
		PrevOSCALValues[1] = PrevOSCALValues[0];
		PrevOSCALValues[0] = OSCCAL;
    102c:	40 91 66 00 	lds	r20, 0x0066
        
		if (ActualCount > OSCCAL_TARGETCOUNT)       // Clock is running too fast
    1030:	80 91 04 01 	lds	r24, 0x0104
    1034:	90 91 05 01 	lds	r25, 0x0105
    1038:	81 50       	subi	r24, 0x01	; 1
    103a:	91 4e       	sbci	r25, 0xE1	; 225
    103c:	20 f0       	brcs	.+8      	; 0x1046 <OSCCAL_Calibrate+0x7a>
			OSCCAL--;
    103e:	80 91 66 00 	lds	r24, 0x0066
    1042:	81 50       	subi	r24, 0x01	; 1
    1044:	0a c0       	rjmp	.+20     	; 0x105a <OSCCAL_Calibrate+0x8e>
		else if (ActualCount < OSCCAL_TARGETCOUNT) // Clock is running too slow
    1046:	80 91 04 01 	lds	r24, 0x0104
    104a:	90 91 05 01 	lds	r25, 0x0105
    104e:	80 50       	subi	r24, 0x00	; 0
    1050:	91 4e       	sbci	r25, 0xE1	; 225
    1052:	28 f4       	brcc	.+10     	; 0x105e <OSCCAL_Calibrate+0x92>
			OSCCAL++;
    1054:	80 91 66 00 	lds	r24, 0x0066
    1058:	8f 5f       	subi	r24, 0xFF	; 255
    105a:	80 93 66 00 	sts	0x0066, r24
		
		// When the routine finds the closest value for the given target count,
		// it will cause the OSCCAL to hover around the closest two values.
		// If the current value is the same as several loops previous, exit the
		// routine as the best value has been found.
		if ((OSCCAL == PrevOSCALValues[1]) && (OSCCAL == PrevOSCALValues[3]))
    105e:	80 91 66 00 	lds	r24, 0x0066
    1062:	82 17       	cp	r24, r18
    1064:	21 f4       	brne	.+8      	; 0x106e <OSCCAL_Calibrate+0xa2>
    1066:	80 91 66 00 	lds	r24, 0x0066
    106a:	85 17       	cp	r24, r21
    106c:	39 f0       	breq	.+14     	; 0x107c <OSCCAL_Calibrate+0xb0>
    106e:	31 50       	subi	r19, 0x01	; 1
    1070:	56 2f       	mov	r21, r22
    1072:	62 2f       	mov	r22, r18
    1074:	3f 3f       	cpi	r19, 0xFF	; 255
    1076:	11 f0       	breq	.+4      	; 0x107c <OSCCAL_Calibrate+0xb0>
    1078:	24 2f       	mov	r18, r20
    107a:	d5 cf       	rjmp	.-86     	; 0x1026 <OSCCAL_Calibrate+0x5a>
		  break;
	}

	// Disable all timer interrupts
	TIMSK1 = 0;
    107c:	10 92 6f 00 	sts	0x006F, r1
	TIMSK2 = 0;
    1080:	10 92 70 00 	sts	0x0070, r1
    
	// Stop the timers
	TCCR1B = 0x00;
    1084:	10 92 81 00 	sts	0x0081, r1
	TCCR2A = 0x00;
    1088:	10 92 b0 00 	sts	0x00B0, r1

	// Turn off timer 2 asynchronous mode
	ASSR  &= ~(1 << AS2);
    108c:	80 91 b6 00 	lds	r24, 0x00B6
    1090:	87 7f       	andi	r24, 0xF7	; 247
    1092:	80 93 b6 00 	sts	0x00B6, r24

	// Restore SREG
	SREG = SREG_Backup;
    1096:	7f bf       	out	0x3f, r23	; 63
    1098:	08 95       	ret

0000109a <__vector_5>:
        
	return;
}

ISR(TIMER2_OVF_vect, ISR_BLOCK) // Occurs 32768/256 timers per second, or 128Hz
{
    109a:	1f 92       	push	r1
    109c:	0f 92       	push	r0
    109e:	0f b6       	in	r0, 0x3f	; 63
    10a0:	0f 92       	push	r0
    10a2:	11 24       	eor	r1, r1
    10a4:	8f 93       	push	r24
    10a6:	9f 93       	push	r25
    10a8:	af 93       	push	r26
    10aa:	bf 93       	push	r27
    10ac:	ef 93       	push	r30
    10ae:	ff 93       	push	r31
	// Stop timer 1 so it can be read
	TCCR1B = 0x00;
    10b0:	a1 e8       	ldi	r26, 0x81	; 129
    10b2:	b0 e0       	ldi	r27, 0x00	; 0
    10b4:	1c 92       	st	X, r1
    
	// Record timer 1's value
	ActualCount = TCNT1;
    10b6:	e4 e8       	ldi	r30, 0x84	; 132
    10b8:	f0 e0       	ldi	r31, 0x00	; 0
    10ba:	80 81       	ld	r24, Z
    10bc:	91 81       	ldd	r25, Z+1	; 0x01
    10be:	90 93 05 01 	sts	0x0105, r25
    10c2:	80 93 04 01 	sts	0x0104, r24
	     
	// Reset counters and restart timer 1
	TCNT1  = 0;
    10c6:	11 82       	std	Z+1, r1	; 0x01
    10c8:	10 82       	st	Z, r1
	TCNT2  = 0;
    10ca:	10 92 b2 00 	sts	0x00B2, r1
	TCCR1B = (1 << CS10);
    10ce:	81 e0       	ldi	r24, 0x01	; 1
    10d0:	8c 93       	st	X, r24
    10d2:	ff 91       	pop	r31
    10d4:	ef 91       	pop	r30
    10d6:	bf 91       	pop	r27
    10d8:	af 91       	pop	r26
    10da:	9f 91       	pop	r25
    10dc:	8f 91       	pop	r24
    10de:	0f 90       	pop	r0
    10e0:	0f be       	out	0x3f, r0	; 63
    10e2:	0f 90       	pop	r0
    10e4:	1f 90       	pop	r1
    10e6:	18 95       	reti

000010e8 <LCD_Init>:

// ======================================================================================

void LCD_Init(void)
{
    10e8:	8f e0       	ldi	r24, 0x0F	; 15
    10ea:	80 93 e7 00 	sts	0x00E7, r24
	// Set the initial contrast level to maximum:
	LCDCCR = 0x0F;

    // Select asynchronous clock source, enable all COM pins and enable all segment pins:
    LCDCRB  = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
    10ee:	87 eb       	ldi	r24, 0xB7	; 183
    10f0:	80 93 e5 00 	sts	0x00E5, r24

    // Set LCD prescaler to give a framerate of 32Hz:
    LCDFRR  = (7<<LCDCD0);    
    10f4:	87 e0       	ldi	r24, 0x07	; 7
    10f6:	80 93 e6 00 	sts	0x00E6, r24

	// Enable LCD and set low power waveform, enable start of frame interrupt:
    LCDCRA  = (1<<LCDEN) | (1<<LCDAB) | (1<<LCDIE);
    10fa:	88 ec       	ldi	r24, 0xC8	; 200
    10fc:	80 93 e4 00 	sts	0x00E4, r24
    1100:	08 95       	ret

00001102 <LCD_puts>:
}

void LCD_puts_f(const uint8_t *FlashData)
{
	uint8_t StrBuff[LCD_TEXTBUFFER_SIZE];

	strcpy_P(StrBuff, FlashData);
	LCD_puts(StrBuff);
}

void LCD_puts(const uint8_t *Data)
{
    1102:	fc 01       	movw	r30, r24
    1104:	ac e0       	ldi	r26, 0x0C	; 12
    1106:	b1 e0       	ldi	r27, 0x01	; 1
    1108:	38 2f       	mov	r19, r24
    110a:	4f ef       	ldi	r20, 0xFF	; 255
    110c:	2e 2f       	mov	r18, r30
    110e:	23 1b       	sub	r18, r19
	uint8_t LoadB;
	
	for (LoadB = 0; LoadB < 20; LoadB++)
	{
		uint8_t CByte = *(Data++);
    1110:	91 91       	ld	r25, Z+
	
		if ((CByte >= '*') && (CByte <= 'z') && (CByte != ' '))
    1112:	89 2f       	mov	r24, r25
    1114:	8a 52       	subi	r24, 0x2A	; 42
    1116:	81 35       	cpi	r24, 0x51	; 81
    1118:	10 f4       	brcc	.+4      	; 0x111e <LCD_puts+0x1c>
		  TextBuffer[LoadB] = (CByte - '*');
    111a:	8c 93       	st	X, r24
    111c:	03 c0       	rjmp	.+6      	; 0x1124 <LCD_puts+0x22>
		else if (CByte == 0x00)
    111e:	99 23       	and	r25, r25
    1120:	41 f0       	breq	.+16     	; 0x1132 <LCD_puts+0x30>
		  break;
		else
		  TextBuffer[LoadB] = 0xFF;		
    1122:	4c 93       	st	X, r20
    1124:	2e 2f       	mov	r18, r30
    1126:	23 1b       	sub	r18, r19
    1128:	11 96       	adiw	r26, 0x01	; 1
    112a:	81 e0       	ldi	r24, 0x01	; 1
    112c:	a0 32       	cpi	r26, 0x20	; 32
    112e:	b8 07       	cpc	r27, r24
    1130:	69 f7       	brne	.-38     	; 0x110c <LCD_puts+0xa>
	}

	ScrollMode  = ((LoadB > 6)? TRUE : FALSE);
    1132:	10 92 06 01 	sts	0x0106, r1
    1136:	27 30       	cpi	r18, 0x07	; 7
    1138:	18 f0       	brcs	.+6      	; 0x1140 <LCD_puts+0x3e>
    113a:	81 e0       	ldi	r24, 0x01	; 1
    113c:	80 93 06 01 	sts	0x0106, r24
	ScrollCount = 0;
    1140:	10 92 08 01 	sts	0x0108, r1
    1144:	82 2f       	mov	r24, r18
    1146:	90 e0       	ldi	r25, 0x00	; 0
    1148:	3f ef       	ldi	r19, 0xFF	; 255

	for (uint8_t Nulls = 0; Nulls < 7; Nulls++)
		TextBuffer[LoadB++] = 0xFF;
    114a:	e8 2f       	mov	r30, r24
    114c:	ff 27       	eor	r31, r31
    114e:	e4 5f       	subi	r30, 0xF4	; 244
    1150:	fe 4f       	sbci	r31, 0xFE	; 254
    1152:	30 83       	st	Z, r19
    1154:	8f 5f       	subi	r24, 0xFF	; 255
    1156:	9f 5f       	subi	r25, 0xFF	; 255
    1158:	97 30       	cpi	r25, 0x07	; 7
    115a:	b9 f7       	brne	.-18     	; 0x114a <LCD_puts+0x48>
    115c:	82 2f       	mov	r24, r18
    115e:	89 5f       	subi	r24, 0xF9	; 249
	
	TextBuffer[LoadB] = 0x00;
    1160:	e8 2f       	mov	r30, r24
    1162:	ff 27       	eor	r31, r31
    1164:	e4 5f       	subi	r30, 0xF4	; 244
    1166:	fe 4f       	sbci	r31, 0xFE	; 254
    1168:	10 82       	st	Z, r1
	StrStart   = 0;
    116a:	10 92 0a 01 	sts	0x010A, r1
	StrEnd     = LoadB;	
    116e:	80 93 0b 01 	sts	0x010B, r24
	DelayCount = LCD_DELAYCOUNT_DEFAULT;
    1172:	8a e0       	ldi	r24, 0x0A	; 10
    1174:	80 93 07 01 	sts	0x0107, r24

	UpdateLCD  = TRUE;
    1178:	81 e0       	ldi	r24, 0x01	; 1
    117a:	80 93 09 01 	sts	0x0109, r24
    117e:	08 95       	ret

00001180 <__vector_22>:
}

static inline void LCD_WriteChar(const uint8_t Byte, const uint8_t Digit)
{
	uint16_t SegData  = 0x00;
	uint8_t  *BuffPtr = (&SegBuffer[0] + (Digit >> 1));

	if (Byte != 0xFF)
	  SegData = pgm_read_word(&LCD_SegTable[Byte]);	

	for (uint8_t BNib = 0; BNib < 4; BNib++)
	{
		uint8_t Mask          = 0xF0;
		uint8_t MaskedSegData = (SegData & 0x0000F);
	
		if (Digit & 0x01)
		{
			Mask = 0x0F;
			MaskedSegData <<= 4;
		}
		
		*BuffPtr = ((*BuffPtr & Mask) | MaskedSegData);

		SegData >>= 4;
		BuffPtr  += 5;
	}
}

ISR(LCD_vect, ISR_NOBLOCK)
{
    1180:	78 94       	sei
    1182:	1f 92       	push	r1
    1184:	0f 92       	push	r0
    1186:	0f b6       	in	r0, 0x3f	; 63
    1188:	0f 92       	push	r0
    118a:	11 24       	eor	r1, r1
    118c:	ef 92       	push	r14
    118e:	ff 92       	push	r15
    1190:	0f 93       	push	r16
    1192:	1f 93       	push	r17
    1194:	2f 93       	push	r18
    1196:	3f 93       	push	r19
    1198:	4f 93       	push	r20
    119a:	5f 93       	push	r21
    119c:	6f 93       	push	r22
    119e:	7f 93       	push	r23
    11a0:	8f 93       	push	r24
    11a2:	9f 93       	push	r25
    11a4:	af 93       	push	r26
    11a6:	bf 93       	push	r27
    11a8:	ef 93       	push	r30
    11aa:	ff 93       	push	r31
	if (ScrollMode)
    11ac:	80 91 06 01 	lds	r24, 0x0106
    11b0:	88 23       	and	r24, r24
    11b2:	99 f0       	breq	.+38     	; 0x11da <__vector_22+0x5a>
	{
		if (DelayCount)
    11b4:	80 91 07 01 	lds	r24, 0x0107
    11b8:	88 23       	and	r24, r24
    11ba:	21 f0       	breq	.+8      	; 0x11c4 <__vector_22+0x44>
		{
			DelayCount--;
    11bc:	81 50       	subi	r24, 0x01	; 1
    11be:	80 93 07 01 	sts	0x0107, r24
    11c2:	0b c0       	rjmp	.+22     	; 0x11da <__vector_22+0x5a>
		}
		else
		{
			if (!(ScrollCount--))
    11c4:	80 91 08 01 	lds	r24, 0x0108
    11c8:	81 50       	subi	r24, 0x01	; 1
    11ca:	80 93 08 01 	sts	0x0108, r24
    11ce:	8f 3f       	cpi	r24, 0xFF	; 255
    11d0:	21 f4       	brne	.+8      	; 0x11da <__vector_22+0x5a>
			  UpdateLCD = TRUE;
    11d2:	81 e0       	ldi	r24, 0x01	; 1
    11d4:	80 93 09 01 	sts	0x0109, r24
    11d8:	05 c0       	rjmp	.+10     	; 0x11e4 <__vector_22+0x64>
		}
	}

	if (UpdateLCD)
    11da:	80 91 09 01 	lds	r24, 0x0109
    11de:	88 23       	and	r24, r24
    11e0:	09 f4       	brne	.+2      	; 0x11e4 <__vector_22+0x64>
    11e2:	55 c0       	rjmp	.+170    	; 0x128e <__vector_22+0x10e>
	{
		for (uint8_t Character = 0; Character < 6; Character++)
		{
			uint8_t Byte = (StrStart + Character);
    11e4:	30 91 0a 01 	lds	r19, 0x010A

			if (Byte >= StrEnd)
    11e8:	e0 90 0b 01 	lds	r14, 0x010B
    11ec:	f3 2e       	mov	r15, r19
    11ee:	fe 18       	sub	r15, r14
    11f0:	13 2f       	mov	r17, r19
    11f2:	60 e0       	ldi	r22, 0x00	; 0
    11f4:	70 e0       	ldi	r23, 0x00	; 0
    11f6:	86 2f       	mov	r24, r22
    11f8:	1e 15       	cp	r17, r14
    11fa:	10 f4       	brcc	.+4      	; 0x1200 <__vector_22+0x80>
    11fc:	e1 2f       	mov	r30, r17
    11fe:	01 c0       	rjmp	.+2      	; 0x1202 <__vector_22+0x82>
    1200:	ef 2d       	mov	r30, r15
			  Byte -= StrEnd;
			
			LCD_WriteChar(TextBuffer[Byte], Character);
    1202:	ff 27       	eor	r31, r31
    1204:	e4 5f       	subi	r30, 0xF4	; 244
    1206:	fe 4f       	sbci	r31, 0xFE	; 254
    1208:	e0 81       	ld	r30, Z
    120a:	ef 3f       	cpi	r30, 0xFF	; 255
    120c:	19 f4       	brne	.+6      	; 0x1214 <__vector_22+0x94>
    120e:	40 e0       	ldi	r20, 0x00	; 0
    1210:	50 e0       	ldi	r21, 0x00	; 0
    1212:	07 c0       	rjmp	.+14     	; 0x1222 <__vector_22+0xa2>
    1214:	ff 27       	eor	r31, r31
    1216:	ee 0f       	add	r30, r30
    1218:	ff 1f       	adc	r31, r31
    121a:	e4 5d       	subi	r30, 0xD4	; 212
    121c:	fc 4f       	sbci	r31, 0xFC	; 252
    121e:	45 91       	lpm	r20, Z+
    1220:	54 91       	lpm	r21, Z
    1222:	86 95       	lsr	r24
    1224:	e8 2f       	mov	r30, r24
    1226:	ff 27       	eor	r31, r31
    1228:	e9 5d       	subi	r30, 0xD9	; 217
    122a:	fe 4f       	sbci	r31, 0xFE	; 254
    122c:	00 e0       	ldi	r16, 0x00	; 0
    122e:	db 01       	movw	r26, r22
    1230:	a1 70       	andi	r26, 0x01	; 1
    1232:	b0 70       	andi	r27, 0x00	; 0
    1234:	24 2f       	mov	r18, r20
    1236:	2f 70       	andi	r18, 0x0F	; 15
    1238:	10 97       	sbiw	r26, 0x00	; 0
    123a:	11 f4       	brne	.+4      	; 0x1240 <__vector_22+0xc0>
    123c:	90 ef       	ldi	r25, 0xF0	; 240
    123e:	03 c0       	rjmp	.+6      	; 0x1246 <__vector_22+0xc6>
    1240:	22 95       	swap	r18
    1242:	20 7f       	andi	r18, 0xF0	; 240
    1244:	9f e0       	ldi	r25, 0x0F	; 15
    1246:	80 81       	ld	r24, Z
    1248:	98 23       	and	r25, r24
    124a:	92 2b       	or	r25, r18
    124c:	90 83       	st	Z, r25
    124e:	0f 5f       	subi	r16, 0xFF	; 255
    1250:	04 30       	cpi	r16, 0x04	; 4
    1252:	39 f0       	breq	.+14     	; 0x1262 <__vector_22+0xe2>
    1254:	84 e0       	ldi	r24, 0x04	; 4
    1256:	56 95       	lsr	r21
    1258:	47 95       	ror	r20
    125a:	8a 95       	dec	r24
    125c:	e1 f7       	brne	.-8      	; 0x1256 <__vector_22+0xd6>
    125e:	35 96       	adiw	r30, 0x05	; 5
    1260:	e9 cf       	rjmp	.-46     	; 0x1234 <__vector_22+0xb4>
    1262:	6f 5f       	subi	r22, 0xFF	; 255
    1264:	7f 4f       	sbci	r23, 0xFF	; 255
    1266:	1f 5f       	subi	r17, 0xFF	; 255
    1268:	f3 94       	inc	r15
    126a:	66 30       	cpi	r22, 0x06	; 6
    126c:	71 05       	cpc	r23, r1
    126e:	09 f0       	breq	.+2      	; 0x1272 <__vector_22+0xf2>
    1270:	c2 cf       	rjmp	.-124    	; 0x11f6 <__vector_22+0x76>
		}
		
		if (StrStart++ == StrEnd)
    1272:	3f 5f       	subi	r19, 0xFF	; 255
    1274:	30 93 0a 01 	sts	0x010A, r19
    1278:	31 50       	subi	r19, 0x01	; 1
    127a:	3e 15       	cp	r19, r14
    127c:	19 f4       	brne	.+6      	; 0x1284 <__vector_22+0x104>
		  StrStart = 1;
    127e:	81 e0       	ldi	r24, 0x01	; 1
    1280:	80 93 0a 01 	sts	0x010A, r24
		
		ScrollCount = LCD_SCROLLCOUNT_DEFAULT;
    1284:	83 e0       	ldi	r24, 0x03	; 3
    1286:	80 93 08 01 	sts	0x0108, r24
		UpdateLCD = FALSE;
    128a:	10 92 09 01 	sts	0x0109, r1
    128e:	a7 e2       	ldi	r26, 0x27	; 39
    1290:	b1 e0       	ldi	r27, 0x01	; 1
    1292:	ec ee       	ldi	r30, 0xEC	; 236
    1294:	f0 e0       	ldi	r31, 0x00	; 0
	}

	for (uint8_t LCDChar = 0; LCDChar < LCD_SEGBUFFER_SIZE; LCDChar++)
	  *(pLCDREG + LCDChar) = SegBuffer[LCDChar];
    1296:	8d 91       	ld	r24, X+
    1298:	81 93       	st	Z+, r24
    129a:	81 e0       	ldi	r24, 0x01	; 1
    129c:	e0 30       	cpi	r30, 0x00	; 0
    129e:	f8 07       	cpc	r31, r24
    12a0:	d1 f7       	brne	.-12     	; 0x1296 <__vector_22+0x116>
    12a2:	ff 91       	pop	r31
    12a4:	ef 91       	pop	r30
    12a6:	bf 91       	pop	r27
    12a8:	af 91       	pop	r26
    12aa:	9f 91       	pop	r25
    12ac:	8f 91       	pop	r24
    12ae:	7f 91       	pop	r23
    12b0:	6f 91       	pop	r22
    12b2:	5f 91       	pop	r21
    12b4:	4f 91       	pop	r20
    12b6:	3f 91       	pop	r19
    12b8:	2f 91       	pop	r18
    12ba:	1f 91       	pop	r17
    12bc:	0f 91       	pop	r16
    12be:	ff 90       	pop	r15
    12c0:	ef 90       	pop	r14
    12c2:	0f 90       	pop	r0
    12c4:	0f be       	out	0x3f, r0	; 63
    12c6:	0f 90       	pop	r0
    12c8:	1f 90       	pop	r1
    12ca:	18 95       	reti

000012cc <LCD_puts_f>:
    12cc:	0f 93       	push	r16
    12ce:	1f 93       	push	r17
    12d0:	cf 93       	push	r28
    12d2:	df 93       	push	r29
    12d4:	cd b7       	in	r28, 0x3d	; 61
    12d6:	de b7       	in	r29, 0x3e	; 62
    12d8:	64 97       	sbiw	r28, 0x14	; 20
    12da:	0f b6       	in	r0, 0x3f	; 63
    12dc:	f8 94       	cli
    12de:	de bf       	out	0x3e, r29	; 62
    12e0:	0f be       	out	0x3f, r0	; 63
    12e2:	cd bf       	out	0x3d, r28	; 61
    12e4:	8e 01       	movw	r16, r28
    12e6:	0f 5f       	subi	r16, 0xFF	; 255
    12e8:	1f 4f       	sbci	r17, 0xFF	; 255
    12ea:	bc 01       	movw	r22, r24
    12ec:	c8 01       	movw	r24, r16
    12ee:	0e 94 4d 1a 	call	0x349a	; 0x349a <strcpy_P>
    12f2:	c8 01       	movw	r24, r16
    12f4:	0e 94 81 08 	call	0x1102	; 0x1102 <LCD_puts>
    12f8:	64 96       	adiw	r28, 0x14	; 20
    12fa:	0f b6       	in	r0, 0x3f	; 63
    12fc:	f8 94       	cli
    12fe:	de bf       	out	0x3e, r29	; 62
    1300:	0f be       	out	0x3f, r0	; 63
    1302:	cd bf       	out	0x3d, r28	; 61
    1304:	df 91       	pop	r29
    1306:	cf 91       	pop	r28
    1308:	1f 91       	pop	r17
    130a:	0f 91       	pop	r16
    130c:	08 95       	ret

0000130e <USART_Tx>:
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_Tx(const char data)
{
    130e:	98 2f       	mov	r25, r24
    while (!(UCSRA & (1 << UDRE)));
    1310:	80 91 c0 00 	lds	r24, 0x00C0
    1314:	85 ff       	sbrs	r24, 5
    1316:	fc cf       	rjmp	.-8      	; 0x1310 <USART_Tx+0x2>
    UDR = data;
    1318:	90 93 c6 00 	sts	0x00C6, r25
    131c:	08 95       	ret

0000131e <USART_Rx>:
}

/*****************************************************************************
*
*   Function name : Usart_Rx
*
*   Returns :       char: byte received
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART
*
*****************************************************************************/
char USART_Rx(void)
{
    131e:	80 91 88 01 	lds	r24, 0x0188
    1322:	88 23       	and	r24, r24
    1324:	21 f4       	brne	.+8      	; 0x132e <USART_Rx+0x10>
    while (!(BuffElements) && !(PacketTimeOut)) {};
    1326:	80 91 8c 01 	lds	r24, 0x018C
    132a:	88 23       	and	r24, r24
    132c:	c1 f3       	breq	.-16     	; 0x131e <USART_Rx>
    return BUFF_GetBuffByte();
    132e:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <BUFF_GetBuffByte>
}
    1332:	99 27       	eor	r25, r25
    1334:	08 95       	ret

00001336 <USART_Init>:
    1336:	10 92 c5 00 	sts	0x00C5, r1
    133a:	87 e0       	ldi	r24, 0x07	; 7
    133c:	80 93 c4 00 	sts	0x00C4, r24
    1340:	82 e0       	ldi	r24, 0x02	; 2
    1342:	80 93 c0 00 	sts	0x00C0, r24
    1346:	80 e8       	ldi	r24, 0x80	; 128
    1348:	80 93 c1 00 	sts	0x00C1, r24
    134c:	86 e0       	ldi	r24, 0x06	; 6
    134e:	80 93 c2 00 	sts	0x00C2, r24
    1352:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <BUFF_InitialiseBuffer>
    1356:	08 95       	ret

00001358 <SPI_SPIInit>:

// ======================================================================================

void SPI_SPIInit(void)
{
    1358:	e4 e6       	ldi	r30, 0x64	; 100
    135a:	f0 e0       	ldi	r31, 0x00	; 0
    135c:	80 81       	ld	r24, Z
    135e:	8b 7f       	andi	r24, 0xFB	; 251
    1360:	80 83       	st	Z, r24
	PRR &= ~(1 << PRSPI);              // Enable the SPI system by clearing the power save register SPI disable bit

	// Master, Sample falling edge (setup rising), Fosc/16 speed (7.3MHz/16 = 467KHz)
	SPCR = ((1 << SPE) | (1 << MSTR) | (1 << CPHA) | (1 << CPOL) | (1 << SPR0));
    1362:	8d e5       	ldi	r24, 0x5D	; 93
    1364:	8c bd       	out	0x2c, r24	; 44
    1366:	08 95       	ret

00001368 <SPI_SPITransmit>:
}

uint8_t SPI_SPITransmit(const uint8_t Data)
{
    1368:	8e bd       	out	0x2e, r24	; 46
	SPDR = Data;                       // Loading a byte into the register starts the transmission
	while (!(SPSR & (1 << SPIF)));    // Wait until transmission completed
    136a:	0d b4       	in	r0, 0x2d	; 45
    136c:	07 fe       	sbrs	r0, 7
    136e:	fd cf       	rjmp	.-6      	; 0x136a <SPI_SPITransmit+0x2>
	return SPDR;
    1370:	8e b5       	in	r24, 0x2e	; 46
}
    1372:	99 27       	eor	r25, r25
    1374:	08 95       	ret

00001376 <SPI_SPITransmitWord>:

uint8_t SPI_SPITransmitWord(const uint16_t Data)
{
    1376:	9c 01       	movw	r18, r24
	SPI_SPITransmit((uint8_t)(Data >> 8));
    1378:	83 2f       	mov	r24, r19
    137a:	99 27       	eor	r25, r25
    137c:	8e bd       	out	0x2e, r24	; 46
    137e:	0d b4       	in	r0, 0x2d	; 45
    1380:	07 fe       	sbrs	r0, 7
    1382:	fd cf       	rjmp	.-6      	; 0x137e <SPI_SPITransmitWord+0x8>
    1384:	8e b5       	in	r24, 0x2e	; 46
    1386:	2e bd       	out	0x2e, r18	; 46
    1388:	0d b4       	in	r0, 0x2d	; 45
    138a:	07 fe       	sbrs	r0, 7
    138c:	fd cf       	rjmp	.-6      	; 0x1388 <SPI_SPITransmitWord+0x12>
    138e:	8e b5       	in	r24, 0x2e	; 46
	return SPI_SPITransmit((uint8_t)Data);
}
    1390:	99 27       	eor	r25, r25
    1392:	08 95       	ret

00001394 <__vector_17>:
 *  have to stop the timer tick.
 *  For all modes the USIDR contents are stored and flags are updated.
 */
ISR(USI_OVERFLOW_vect, ISR_BLOCK)
{
    1394:	1f 92       	push	r1
    1396:	0f 92       	push	r0
    1398:	0f b6       	in	r0, 0x3f	; 63
    139a:	0f 92       	push	r0
    139c:	11 24       	eor	r1, r1
    139e:	8f 93       	push	r24
    13a0:	ef 93       	push	r30
    13a2:	ff 93       	push	r31
	// Master must now disable the compare match interrupt
	// to prevent more USI counter clocks.
	TIMSK0 &= ~(1<<OCIE0A);
    13a4:	ee e6       	ldi	r30, 0x6E	; 110
    13a6:	f0 e0       	ldi	r31, 0x00	; 0
    13a8:	80 81       	ld	r24, Z
    13aa:	8d 7f       	andi	r24, 0xFD	; 253
    13ac:	80 83       	st	Z, r24
	
	// Update flags and clear USI counter
	USISR = (1<<USIOIF);
    13ae:	80 e4       	ldi	r24, 0x40	; 64
    13b0:	80 93 b9 00 	sts	0x00B9, r24
	TransferComplete = 1;
    13b4:	81 e0       	ldi	r24, 0x01	; 1
    13b6:	80 93 3c 01 	sts	0x013C, r24

	// Copy USIDR to buffer to prevent overwrite on next transfer.
	StoredUSIDR = USIDR;
    13ba:	80 91 ba 00 	lds	r24, 0x00BA
    13be:	80 93 3b 01 	sts	0x013B, r24
    13c2:	ff 91       	pop	r31
    13c4:	ef 91       	pop	r30
    13c6:	8f 91       	pop	r24
    13c8:	0f 90       	pop	r0
    13ca:	0f be       	out	0x3f, r0	; 63
    13cc:	0f 90       	pop	r0
    13ce:	1f 90       	pop	r1
    13d0:	18 95       	reti

000013d2 <USI_SPIOff>:
}

/*! \brief  Initialize USI as SPI master.
 *
 *  This function sets up all pin directions and module configurations.
 *  Use this function initially or when changing from slave to master mode.
 *  Note that the stored USIDR value is cleared.
 *
 */
void USI_SPIInitMaster()
{
	// Configure port directions.
 	USI_DIR_REG |= (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN);  // Outputs.
	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN);                       // Inputs.
	USI_OUT_REG |= (1<<USI_DATAIN_PIN);                        // Pull-ups.
	USI_OUT_REG &= ~(1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN); // Pull-ups.
	
	// Configure USI to 3-wire master mode with overflow interrupt.
	USICR = USI_CONTROL_REG_FLAGS;

	// Set the compare and prescaler for the requested frequency:
	USI_SPISetSpeed();
	
	// Init driver status register.
	TransferComplete = 0;
	
	StoredUSIDR = 0;
}

void USI_SPIOff(void)
{
    13d2:	8d b1       	in	r24, 0x0d	; 13
    13d4:	8f 7a       	andi	r24, 0xAF	; 175
    13d6:	8d b9       	out	0x0d, r24	; 13
	USI_DIR_REG &= ~((1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN));                        // Inputs.
	USI_OUT_REG &= ~((1<<USI_DATAIN_PIN)  | (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN)); // Pull-ups.
    13d8:	8e b1       	in	r24, 0x0e	; 14
    13da:	8f 78       	andi	r24, 0x8F	; 143
    13dc:	8e b9       	out	0x0e, r24	; 14
	DDRF  &= ~(1 << 6);
    13de:	86 98       	cbi	0x10, 6	; 16
	PORTF &= ~(1 << 6);
    13e0:	8e 98       	cbi	0x11, 6	; 17
	
	USI_STOPUSITIMER();
    13e2:	14 bc       	out	0x24, r1	; 36
    13e4:	08 95       	ret

000013e6 <USI_SPITransmit>:
}

/*! \brief  Put one byte on bus.
 *
 *  Use this function like you would write to the SPDR register in the native SPI module.
 *  Calling this function in master mode starts a transfer, while in slave mode, a
 *  byte will be prepared for the next transfer initiated by the master device.
 *  If a transfer is in progress, this function will set the write collision flag
 *  and return without altering the data registers.
 *
 *  \returns  Value returned by slave.
 */
uint8_t USI_SPITransmit(uint8_t val)
{
    13e6:	10 92 3c 01 	sts	0x013C, r1
	// Reinit flags.
	TransferComplete = 0;

	// Put data in USI data register.
	USIDR = val;
    13ea:	80 93 ba 00 	sts	0x00BA, r24
	
	TIFR0  |= (1<<OCF0A);  // Clear compare match flag.
    13ee:	a9 9a       	sbi	0x15, 1	; 21
	TIMSK0 |= (1<<OCIE0A); // Enable compare match interrupt.
    13f0:	80 91 6e 00 	lds	r24, 0x006E
    13f4:	82 60       	ori	r24, 0x02	; 2
    13f6:	80 93 6e 00 	sts	0x006E, r24

	// Clear the timer 0 value
	TCNT0 = 0;
    13fa:	16 bc       	out	0x26, r1	; 38

	while (!(TransferComplete));
    13fc:	80 91 3c 01 	lds	r24, 0x013C
    1400:	88 23       	and	r24, r24
    1402:	e1 f3       	breq	.-8      	; 0x13fc <USI_SPITransmit+0x16>

	return StoredUSIDR;
    1404:	80 91 3b 01 	lds	r24, 0x013B
}
    1408:	99 27       	eor	r25, r25
    140a:	08 95       	ret

0000140c <USI_SPITransmitWord>:

uint8_t USI_SPITransmitWord(const uint16_t val )
{
    140c:	0f 93       	push	r16
    140e:	1f 93       	push	r17
    1410:	8c 01       	movw	r16, r24
	USI_SPITransmit((uint8_t)(val >> 8));
    1412:	81 2f       	mov	r24, r17
    1414:	99 27       	eor	r25, r25
    1416:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
	return USI_SPITransmit((uint8_t)val);
    141a:	80 2f       	mov	r24, r16
    141c:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
}
    1420:	99 27       	eor	r25, r25
    1422:	1f 91       	pop	r17
    1424:	0f 91       	pop	r16
    1426:	08 95       	ret

00001428 <USI_SPISetSpeed>:

void USI_SPIToggleClock(void)
{
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);	
}

void USI_SPISetSpeed()
{
    1428:	a2 e0       	ldi	r26, 0x02	; 2
    142a:	b0 e0       	ldi	r27, 0x00	; 0
    142c:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
    1430:	80 2d       	mov	r24, r0
	uint8_t StoredIndex = eeprom_read_byte(&EEPROMVars.SCKDuration);
    1432:	98 2f       	mov	r25, r24

	if (StoredIndex == 0xFF) // Blank EEPROM protection
    1434:	8f 3f       	cpi	r24, 0xFF	; 255
    1436:	09 f4       	brne	.+2      	; 0x143a <USI_SPISetSpeed+0x12>
    1438:	93 e0       	ldi	r25, 0x03	; 3
    143a:	29 e9       	ldi	r18, 0x99	; 153
    143c:	33 e0       	ldi	r19, 0x03	; 3
    143e:	f9 01       	movw	r30, r18
    1440:	31 97       	sbiw	r30, 0x01	; 1
	  StoredIndex = (USI_PRESET_SPEEDS - 1);

	for (uint8_t MatchIndex = 0; MatchIndex < USI_PRESET_SPEEDS; MatchIndex++)
	{
		if ((pgm_read_byte(&USIPSValues[MatchIndex][0]) == StoredIndex))
    1442:	84 91       	lpm	r24, Z
    1444:	89 17       	cp	r24, r25
    1446:	31 f4       	brne	.+12     	; 0x1454 <USI_SPISetSpeed+0x2c>
		{
			// Init Output Compare Register.
			OCR0A = pgm_read_byte(&USIPSValues[MatchIndex][1]);
    1448:	f9 01       	movw	r30, r18
    144a:	84 91       	lpm	r24, Z
    144c:	87 bd       	out	0x27, r24	; 39

			// Enable 'Clear Timer on Compare match' and set prescaler, which starts the timer
			TCCR0A = ((1<<WGM01) | TC0_PS_1);
    144e:	89 e0       	ldi	r24, 0x09	; 9
    1450:	84 bd       	out	0x24, r24	; 36
    1452:	08 95       	ret
    1454:	32 96       	adiw	r30, 0x02	; 2
    1456:	2e 5f       	subi	r18, 0xFE	; 254
    1458:	3f 4f       	sbci	r19, 0xFF	; 255
    145a:	83 e0       	ldi	r24, 0x03	; 3
    145c:	e0 3a       	cpi	r30, 0xA0	; 160
    145e:	f8 07       	cpc	r31, r24
    1460:	81 f7       	brne	.-32     	; 0x1442 <USI_SPISetSpeed+0x1a>
    1462:	08 95       	ret

00001464 <USI_SPIInitMaster>:
    1464:	8d b1       	in	r24, 0x0d	; 13
    1466:	80 65       	ori	r24, 0x50	; 80
    1468:	8d b9       	out	0x0d, r24	; 13
    146a:	6d 98       	cbi	0x0d, 5	; 13
    146c:	75 9a       	sbi	0x0e, 5	; 14
    146e:	76 98       	cbi	0x0e, 6	; 14
    1470:	8a e5       	ldi	r24, 0x5A	; 90
    1472:	80 93 b8 00 	sts	0x00B8, r24
    1476:	0e 94 14 0a 	call	0x1428	; 0x1428 <USI_SPISetSpeed>
    147a:	10 92 3c 01 	sts	0x013C, r1
    147e:	10 92 3b 01 	sts	0x013B, r1
    1482:	08 95       	ret

00001484 <USI_SPIToggleClock>:
    1484:	0f 93       	push	r16
    1486:	1f 93       	push	r17
    1488:	81 e0       	ldi	r24, 0x01	; 1
    148a:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    148e:	08 eb       	ldi	r16, 0xB8	; 184
    1490:	10 e0       	ldi	r17, 0x00	; 0
    1492:	f8 01       	movw	r30, r16
    1494:	80 81       	ld	r24, Z
    1496:	81 60       	ori	r24, 0x01	; 1
    1498:	80 83       	st	Z, r24
    149a:	81 e0       	ldi	r24, 0x01	; 1
    149c:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    14a0:	f8 01       	movw	r30, r16
    14a2:	80 81       	ld	r24, Z
    14a4:	81 60       	ori	r24, 0x01	; 1
    14a6:	80 83       	st	Z, r24
    14a8:	81 e0       	ldi	r24, 0x01	; 1
    14aa:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    14ae:	1f 91       	pop	r17
    14b0:	0f 91       	pop	r16
    14b2:	08 95       	ret

000014b4 <DF_EnableDataflash>:
	DF_WaitWhileBusy();
}

void DF_EnableDataflash(const uint8_t Enabled)
{
    14b4:	90 91 47 01 	lds	r25, 0x0147
	if (Enabled == TRUE)
    14b8:	81 30       	cpi	r24, 0x01	; 1
    14ba:	31 f4       	brne	.+12     	; 0x14c8 <DF_EnableDataflash+0x14>
	{
		if (DataflashInfo.UseExernalDF == TRUE)
    14bc:	91 30       	cpi	r25, 0x01	; 1
    14be:	11 f4       	brne	.+4      	; 0x14c4 <DF_EnableDataflash+0x10>
		  MAIN_ResetCSLine(MAIN_RESETCS_EXTDFACTIVE);
    14c0:	82 e0       	ldi	r24, 0x02	; 2
    14c2:	05 c0       	rjmp	.+10     	; 0x14ce <DF_EnableDataflash+0x1a>
		else
		  PORTB &= ~(1 << 0);
    14c4:	28 98       	cbi	0x05, 0	; 5
    14c6:	08 95       	ret
	}
	else
	{
		if (DataflashInfo.UseExernalDF == TRUE)
    14c8:	91 30       	cpi	r25, 0x01	; 1
    14ca:	21 f4       	brne	.+8      	; 0x14d4 <DF_EnableDataflash+0x20>
		  MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);
    14cc:	81 e0       	ldi	r24, 0x01	; 1
    14ce:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
    14d2:	08 95       	ret
		else
		  PORTB |= (1 << 0);
    14d4:	28 9a       	sbi	0x05, 0	; 5
    14d6:	08 95       	ret

000014d8 <DF_ReadBufferByte>:
    14d8:	ef 92       	push	r14
    14da:	ff 92       	push	r15
    14dc:	0f 93       	push	r16
    14de:	1f 93       	push	r17
    14e0:	7c 01       	movw	r14, r24
    14e2:	00 91 00 01 	lds	r16, 0x0100
    14e6:	10 91 01 01 	lds	r17, 0x0101
    14ea:	80 e0       	ldi	r24, 0x00	; 0
    14ec:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    14f0:	81 e0       	ldi	r24, 0x01	; 1
    14f2:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    14f6:	84 e5       	ldi	r24, 0x54	; 84
    14f8:	f8 01       	movw	r30, r16
    14fa:	09 95       	icall
    14fc:	8f 2d       	mov	r24, r15
    14fe:	99 27       	eor	r25, r25
    1500:	f8 01       	movw	r30, r16
    1502:	09 95       	icall
    1504:	8e 2d       	mov	r24, r14
    1506:	f8 01       	movw	r30, r16
    1508:	09 95       	icall
    150a:	80 e0       	ldi	r24, 0x00	; 0
    150c:	f8 01       	movw	r30, r16
    150e:	09 95       	icall
    1510:	80 e0       	ldi	r24, 0x00	; 0
    1512:	f8 01       	movw	r30, r16
    1514:	09 95       	icall
    1516:	99 27       	eor	r25, r25
    1518:	1f 91       	pop	r17
    151a:	0f 91       	pop	r16
    151c:	ff 90       	pop	r15
    151e:	ef 90       	pop	r14
    1520:	08 95       	ret

00001522 <DF_ContinuousReadEnable>:
    1522:	ef 92       	push	r14
    1524:	ff 92       	push	r15
    1526:	0f 93       	push	r16
    1528:	1f 93       	push	r17
    152a:	cf 93       	push	r28
    152c:	df 93       	push	r29
    152e:	8c 01       	movw	r16, r24
    1530:	7b 01       	movw	r14, r22
    1532:	c0 91 00 01 	lds	r28, 0x0100
    1536:	d0 91 01 01 	lds	r29, 0x0101
    153a:	80 e0       	ldi	r24, 0x00	; 0
    153c:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    1540:	81 e0       	ldi	r24, 0x01	; 1
    1542:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    1546:	88 e6       	ldi	r24, 0x68	; 104
    1548:	fe 01       	movw	r30, r28
    154a:	09 95       	icall
    154c:	8a b5       	in	r24, 0x2a	; 42
    154e:	98 01       	movw	r18, r16
    1550:	02 c0       	rjmp	.+4      	; 0x1556 <DF_ContinuousReadEnable+0x34>
    1552:	36 95       	lsr	r19
    1554:	27 95       	ror	r18
    1556:	8a 95       	dec	r24
    1558:	e2 f7       	brpl	.-8      	; 0x1552 <DF_ContinuousReadEnable+0x30>
    155a:	c9 01       	movw	r24, r18
    155c:	fe 01       	movw	r30, r28
    155e:	09 95       	icall
    1560:	8b b5       	in	r24, 0x2b	; 43
    1562:	02 c0       	rjmp	.+4      	; 0x1568 <DF_ContinuousReadEnable+0x46>
    1564:	00 0f       	add	r16, r16
    1566:	11 1f       	adc	r17, r17
    1568:	8a 95       	dec	r24
    156a:	e2 f7       	brpl	.-8      	; 0x1564 <DF_ContinuousReadEnable+0x42>
    156c:	8f 2d       	mov	r24, r15
    156e:	99 27       	eor	r25, r25
    1570:	80 0f       	add	r24, r16
    1572:	fe 01       	movw	r30, r28
    1574:	09 95       	icall
    1576:	8e 2d       	mov	r24, r14
    1578:	fe 01       	movw	r30, r28
    157a:	09 95       	icall
    157c:	00 e0       	ldi	r16, 0x00	; 0
    157e:	80 e0       	ldi	r24, 0x00	; 0
    1580:	fe 01       	movw	r30, r28
    1582:	09 95       	icall
    1584:	0f 5f       	subi	r16, 0xFF	; 255
    1586:	04 30       	cpi	r16, 0x04	; 4
    1588:	d1 f7       	brne	.-12     	; 0x157e <DF_ContinuousReadEnable+0x5c>
    158a:	df 91       	pop	r29
    158c:	cf 91       	pop	r28
    158e:	1f 91       	pop	r17
    1590:	0f 91       	pop	r16
    1592:	ff 90       	pop	r15
    1594:	ef 90       	pop	r14
    1596:	08 95       	ret

00001598 <DF_BufferWriteEnable>:
    1598:	ef 92       	push	r14
    159a:	ff 92       	push	r15
    159c:	0f 93       	push	r16
    159e:	1f 93       	push	r17
    15a0:	7c 01       	movw	r14, r24
    15a2:	00 91 00 01 	lds	r16, 0x0100
    15a6:	10 91 01 01 	lds	r17, 0x0101
    15aa:	80 e0       	ldi	r24, 0x00	; 0
    15ac:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    15b0:	81 e0       	ldi	r24, 0x01	; 1
    15b2:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    15b6:	84 e8       	ldi	r24, 0x84	; 132
    15b8:	f8 01       	movw	r30, r16
    15ba:	09 95       	icall
    15bc:	80 e0       	ldi	r24, 0x00	; 0
    15be:	f8 01       	movw	r30, r16
    15c0:	09 95       	icall
    15c2:	8f 2d       	mov	r24, r15
    15c4:	99 27       	eor	r25, r25
    15c6:	f8 01       	movw	r30, r16
    15c8:	09 95       	icall
    15ca:	8e 2d       	mov	r24, r14
    15cc:	f8 01       	movw	r30, r16
    15ce:	09 95       	icall
    15d0:	1f 91       	pop	r17
    15d2:	0f 91       	pop	r16
    15d4:	ff 90       	pop	r15
    15d6:	ef 90       	pop	r14
    15d8:	08 95       	ret

000015da <DF_WaitWhileBusy>:
    15da:	cf 93       	push	r28
    15dc:	df 93       	push	r29
    15de:	c0 91 00 01 	lds	r28, 0x0100
    15e2:	d0 91 01 01 	lds	r29, 0x0101
    15e6:	80 e0       	ldi	r24, 0x00	; 0
    15e8:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    15ec:	81 e0       	ldi	r24, 0x01	; 1
    15ee:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    15f2:	87 e5       	ldi	r24, 0x57	; 87
    15f4:	fe 01       	movw	r30, r28
    15f6:	09 95       	icall
    15f8:	80 e0       	ldi	r24, 0x00	; 0
    15fa:	fe 01       	movw	r30, r28
    15fc:	09 95       	icall
    15fe:	87 ff       	sbrs	r24, 7
    1600:	fb cf       	rjmp	.-10     	; 0x15f8 <DF_WaitWhileBusy+0x1e>
    1602:	df 91       	pop	r29
    1604:	cf 91       	pop	r28
    1606:	08 95       	ret

00001608 <DF_EraseBlock>:
    1608:	ef 92       	push	r14
    160a:	ff 92       	push	r15
    160c:	0f 93       	push	r16
    160e:	1f 93       	push	r17
    1610:	7c 01       	movw	r14, r24
    1612:	00 91 00 01 	lds	r16, 0x0100
    1616:	10 91 01 01 	lds	r17, 0x0101
    161a:	80 e0       	ldi	r24, 0x00	; 0
    161c:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    1620:	81 e0       	ldi	r24, 0x01	; 1
    1622:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    1626:	80 e5       	ldi	r24, 0x50	; 80
    1628:	f8 01       	movw	r30, r16
    162a:	09 95       	icall
    162c:	8f 2d       	mov	r24, r15
    162e:	99 27       	eor	r25, r25
    1630:	f8 01       	movw	r30, r16
    1632:	09 95       	icall
    1634:	8e 2d       	mov	r24, r14
    1636:	f8 01       	movw	r30, r16
    1638:	09 95       	icall
    163a:	80 e0       	ldi	r24, 0x00	; 0
    163c:	f8 01       	movw	r30, r16
    163e:	09 95       	icall
    1640:	0e 94 ed 0a 	call	0x15da	; 0x15da <DF_WaitWhileBusy>
    1644:	1f 91       	pop	r17
    1646:	0f 91       	pop	r16
    1648:	ff 90       	pop	r15
    164a:	ef 90       	pop	r14
    164c:	08 95       	ret

0000164e <DF_CopyFlashPageToBuffer>:
    164e:	ef 92       	push	r14
    1650:	ff 92       	push	r15
    1652:	0f 93       	push	r16
    1654:	1f 93       	push	r17
    1656:	8c 01       	movw	r16, r24
    1658:	e0 90 00 01 	lds	r14, 0x0100
    165c:	f0 90 01 01 	lds	r15, 0x0101
    1660:	80 e0       	ldi	r24, 0x00	; 0
    1662:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    1666:	81 e0       	ldi	r24, 0x01	; 1
    1668:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    166c:	83 e5       	ldi	r24, 0x53	; 83
    166e:	f7 01       	movw	r30, r14
    1670:	09 95       	icall
    1672:	8a b5       	in	r24, 0x2a	; 42
    1674:	98 01       	movw	r18, r16
    1676:	02 c0       	rjmp	.+4      	; 0x167c <DF_CopyFlashPageToBuffer+0x2e>
    1678:	36 95       	lsr	r19
    167a:	27 95       	ror	r18
    167c:	8a 95       	dec	r24
    167e:	e2 f7       	brpl	.-8      	; 0x1678 <DF_CopyFlashPageToBuffer+0x2a>
    1680:	c9 01       	movw	r24, r18
    1682:	f7 01       	movw	r30, r14
    1684:	09 95       	icall
    1686:	8b b5       	in	r24, 0x2b	; 43
    1688:	02 c0       	rjmp	.+4      	; 0x168e <DF_CopyFlashPageToBuffer+0x40>
    168a:	00 0f       	add	r16, r16
    168c:	11 1f       	adc	r17, r17
    168e:	8a 95       	dec	r24
    1690:	e2 f7       	brpl	.-8      	; 0x168a <DF_CopyFlashPageToBuffer+0x3c>
    1692:	80 2f       	mov	r24, r16
    1694:	f7 01       	movw	r30, r14
    1696:	09 95       	icall
    1698:	80 e0       	ldi	r24, 0x00	; 0
    169a:	f7 01       	movw	r30, r14
    169c:	09 95       	icall
    169e:	0e 94 ed 0a 	call	0x15da	; 0x15da <DF_WaitWhileBusy>
    16a2:	1f 91       	pop	r17
    16a4:	0f 91       	pop	r16
    16a6:	ff 90       	pop	r15
    16a8:	ef 90       	pop	r14
    16aa:	08 95       	ret

000016ac <DF_CopyBufferToFlashPage>:
    16ac:	ef 92       	push	r14
    16ae:	ff 92       	push	r15
    16b0:	0f 93       	push	r16
    16b2:	1f 93       	push	r17
    16b4:	8c 01       	movw	r16, r24
    16b6:	e0 90 00 01 	lds	r14, 0x0100
    16ba:	f0 90 01 01 	lds	r15, 0x0101
    16be:	80 e0       	ldi	r24, 0x00	; 0
    16c0:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    16c4:	81 e0       	ldi	r24, 0x01	; 1
    16c6:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    16ca:	83 e8       	ldi	r24, 0x83	; 131
    16cc:	f7 01       	movw	r30, r14
    16ce:	09 95       	icall
    16d0:	8a b5       	in	r24, 0x2a	; 42
    16d2:	98 01       	movw	r18, r16
    16d4:	02 c0       	rjmp	.+4      	; 0x16da <DF_CopyBufferToFlashPage+0x2e>
    16d6:	36 95       	lsr	r19
    16d8:	27 95       	ror	r18
    16da:	8a 95       	dec	r24
    16dc:	e2 f7       	brpl	.-8      	; 0x16d6 <DF_CopyBufferToFlashPage+0x2a>
    16de:	c9 01       	movw	r24, r18
    16e0:	f7 01       	movw	r30, r14
    16e2:	09 95       	icall
    16e4:	8b b5       	in	r24, 0x2b	; 43
    16e6:	02 c0       	rjmp	.+4      	; 0x16ec <DF_CopyBufferToFlashPage+0x40>
    16e8:	00 0f       	add	r16, r16
    16ea:	11 1f       	adc	r17, r17
    16ec:	8a 95       	dec	r24
    16ee:	e2 f7       	brpl	.-8      	; 0x16e8 <DF_CopyBufferToFlashPage+0x3c>
    16f0:	80 2f       	mov	r24, r16
    16f2:	f7 01       	movw	r30, r14
    16f4:	09 95       	icall
    16f6:	80 e0       	ldi	r24, 0x00	; 0
    16f8:	f7 01       	movw	r30, r14
    16fa:	09 95       	icall
    16fc:	0e 94 ed 0a 	call	0x15da	; 0x15da <DF_WaitWhileBusy>
    1700:	1f 91       	pop	r17
    1702:	0f 91       	pop	r16
    1704:	ff 90       	pop	r15
    1706:	ef 90       	pop	r14
    1708:	08 95       	ret

0000170a <DF_GetChipCharacteristics>:
    170a:	0f 93       	push	r16
    170c:	1f 93       	push	r17
    170e:	00 91 00 01 	lds	r16, 0x0100
    1712:	10 91 01 01 	lds	r17, 0x0101
    1716:	80 e0       	ldi	r24, 0x00	; 0
    1718:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    171c:	81 e0       	ldi	r24, 0x01	; 1
    171e:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    1722:	87 e5       	ldi	r24, 0x57	; 87
    1724:	f8 01       	movw	r30, r16
    1726:	09 95       	icall
    1728:	80 e0       	ldi	r24, 0x00	; 0
    172a:	f8 01       	movw	r30, r16
    172c:	09 95       	icall
    172e:	99 27       	eor	r25, r25
    1730:	88 73       	andi	r24, 0x38	; 56
    1732:	90 70       	andi	r25, 0x00	; 0
    1734:	63 e0       	ldi	r22, 0x03	; 3
    1736:	96 95       	lsr	r25
    1738:	87 95       	ror	r24
    173a:	6a 95       	dec	r22
    173c:	e1 f7       	brne	.-8      	; 0x1736 <DF_GetChipCharacteristics+0x2c>
    173e:	fc 01       	movw	r30, r24
    1740:	e0 56       	subi	r30, 0x60	; 96
    1742:	fc 4f       	sbci	r31, 0xFC	; 252
    1744:	e4 91       	lpm	r30, Z
    1746:	4e 2f       	mov	r20, r30
    1748:	55 27       	eor	r21, r21
    174a:	50 93 3e 01 	sts	0x013E, r21
    174e:	40 93 3d 01 	sts	0x013D, r20
    1752:	88 0f       	add	r24, r24
    1754:	99 1f       	adc	r25, r25
    1756:	fc 01       	movw	r30, r24
    1758:	e8 55       	subi	r30, 0x58	; 88
    175a:	fc 4f       	sbci	r31, 0xFC	; 252
    175c:	25 91       	lpm	r18, Z+
    175e:	34 91       	lpm	r19, Z
    1760:	30 93 40 01 	sts	0x0140, r19
    1764:	20 93 3f 01 	sts	0x013F, r18
    1768:	88 54       	subi	r24, 0x48	; 72
    176a:	9c 4f       	sbci	r25, 0xFC	; 252
    176c:	fc 01       	movw	r30, r24
    176e:	25 91       	lpm	r18, Z+
    1770:	34 91       	lpm	r19, Z
    1772:	30 93 42 01 	sts	0x0142, r19
    1776:	20 93 41 01 	sts	0x0141, r18
    177a:	80 e1       	ldi	r24, 0x10	; 16
    177c:	84 1b       	sub	r24, r20
    177e:	8a bd       	out	0x2a, r24	; 42
    1780:	48 50       	subi	r20, 0x08	; 8
    1782:	4b bd       	out	0x2b, r20	; 43
    1784:	1f 91       	pop	r17
    1786:	0f 91       	pop	r16
    1788:	08 95       	ret

0000178a <DF_CheckCorrectOnboardChip>:
    178a:	0e 94 85 0b 	call	0x170a	; 0x170a <DF_GetChipCharacteristics>
    178e:	80 91 41 01 	lds	r24, 0x0141
    1792:	90 91 42 01 	lds	r25, 0x0142
    1796:	80 50       	subi	r24, 0x00	; 0
    1798:	98 40       	sbci	r25, 0x08	; 8
    179a:	19 f4       	brne	.+6      	; 0x17a2 <DF_CheckCorrectOnboardChip+0x18>
    179c:	81 e0       	ldi	r24, 0x01	; 1
    179e:	90 e0       	ldi	r25, 0x00	; 0
    17a0:	08 95       	ret
    17a2:	80 91 64 00 	lds	r24, 0x0064
    17a6:	84 60       	ori	r24, 0x04	; 4
    17a8:	80 93 64 00 	sts	0x0064, r24
    17ac:	88 ec       	ldi	r24, 0xC8	; 200
    17ae:	93 e0       	ldi	r25, 0x03	; 3
    17b0:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
    17b4:	80 e0       	ldi	r24, 0x00	; 0
    17b6:	90 e0       	ldi	r25, 0x00	; 0
    17b8:	08 95       	ret

000017ba <BUFF_InitialiseBuffer>:

// ======================================================================================

void BUFF_InitialiseBuffer(void)
{
    17ba:	10 92 89 01 	sts	0x0189, r1
	InPos  = 0;                            // Set up the IN counter to the start of the buffer
	OutPos = 0;                            // Set up the OUT counter to the start of the buffer
    17be:	10 92 8a 01 	sts	0x018A, r1

	BuffElements = 0;                      // Reset the buffer elements counter
    17c2:	10 92 88 01 	sts	0x0188, r1
    17c6:	08 95       	ret

000017c8 <BUFF_GetBuffByte>:
}

uint8_t BUFF_GetBuffByte(void)
{
    17c8:	80 91 88 01 	lds	r24, 0x0188
    17cc:	88 23       	and	r24, r24
    17ce:	19 f4       	brne	.+6      	; 0x17d6 <BUFF_GetBuffByte+0xe>
	if (!(BuffElements))                   // No elements in the buffer
    17d0:	80 e0       	ldi	r24, 0x00	; 0
    17d2:	90 e0       	ldi	r25, 0x00	; 0
    17d4:	08 95       	ret
	  return 0;

	uint8_t RetrievedData = RingBuffer[OutPos++]; // Grab the stored byte into a temp variable
    17d6:	80 91 8a 01 	lds	r24, 0x018A
    17da:	e8 2f       	mov	r30, r24
    17dc:	ff 27       	eor	r31, r31
    17de:	e8 5b       	subi	r30, 0xB8	; 184
    17e0:	fe 4f       	sbci	r31, 0xFE	; 254
    17e2:	e0 81       	ld	r30, Z
    17e4:	8f 5f       	subi	r24, 0xFF	; 255
    17e6:	80 93 8a 01 	sts	0x018A, r24
	BuffElements--;                        // Decrement the total elements variable
    17ea:	80 91 88 01 	lds	r24, 0x0188
    17ee:	81 50       	subi	r24, 0x01	; 1
    17f0:	80 93 88 01 	sts	0x0188, r24
	
	if (OutPos == BUFF_BUFFLEN)
    17f4:	80 91 8a 01 	lds	r24, 0x018A
    17f8:	80 34       	cpi	r24, 0x40	; 64
    17fa:	11 f4       	brne	.+4      	; 0x1800 <BUFF_GetBuffByte+0x38>
	  OutPos = 0;                        // Wrap pointer if end of array reached
    17fc:	10 92 8a 01 	sts	0x018A, r1
		
	return RetrievedData;                 // Return the retrieved data
    1800:	8e 2f       	mov	r24, r30
    1802:	99 27       	eor	r25, r25
}
    1804:	08 95       	ret

00001806 <__vector_13>:
    1806:	1f 92       	push	r1
    1808:	0f 92       	push	r0
    180a:	0f b6       	in	r0, 0x3f	; 63
    180c:	0f 92       	push	r0
    180e:	11 24       	eor	r1, r1
    1810:	2f 93       	push	r18
    1812:	3f 93       	push	r19
    1814:	4f 93       	push	r20
    1816:	5f 93       	push	r21
    1818:	6f 93       	push	r22
    181a:	7f 93       	push	r23
    181c:	8f 93       	push	r24
    181e:	9f 93       	push	r25
    1820:	af 93       	push	r26
    1822:	bf 93       	push	r27
    1824:	ef 93       	push	r30
    1826:	ff 93       	push	r31
    1828:	80 91 88 01 	lds	r24, 0x0188
    182c:	80 34       	cpi	r24, 0x40	; 64
    182e:	21 f4       	brne	.+8      	; 0x1838 <__vector_13+0x32>
    1830:	88 ed       	ldi	r24, 0xD8	; 216
    1832:	93 e0       	ldi	r25, 0x03	; 3
    1834:	0e 94 cc 04 	call	0x998	; 0x998 <MAIN_CrashProgram>
    1838:	80 91 89 01 	lds	r24, 0x0189
    183c:	e8 2f       	mov	r30, r24
    183e:	ff 27       	eor	r31, r31
    1840:	90 91 c6 00 	lds	r25, 0x00C6
    1844:	e8 5b       	subi	r30, 0xB8	; 184
    1846:	fe 4f       	sbci	r31, 0xFE	; 254
    1848:	90 83       	st	Z, r25
    184a:	8f 5f       	subi	r24, 0xFF	; 255
    184c:	80 93 89 01 	sts	0x0189, r24
    1850:	80 91 88 01 	lds	r24, 0x0188
    1854:	8f 5f       	subi	r24, 0xFF	; 255
    1856:	80 93 88 01 	sts	0x0188, r24
    185a:	80 91 89 01 	lds	r24, 0x0189
    185e:	80 34       	cpi	r24, 0x40	; 64
    1860:	11 f4       	brne	.+4      	; 0x1866 <__vector_13+0x60>
    1862:	10 92 89 01 	sts	0x0189, r1
    1866:	ff 91       	pop	r31
    1868:	ef 91       	pop	r30
    186a:	bf 91       	pop	r27
    186c:	af 91       	pop	r26
    186e:	9f 91       	pop	r25
    1870:	8f 91       	pop	r24
    1872:	7f 91       	pop	r23
    1874:	6f 91       	pop	r22
    1876:	5f 91       	pop	r21
    1878:	4f 91       	pop	r20
    187a:	3f 91       	pop	r19
    187c:	2f 91       	pop	r18
    187e:	0f 90       	pop	r0
    1880:	0f be       	out	0x3f, r0	; 63
    1882:	0f 90       	pop	r0
    1884:	1f 90       	pop	r1
    1886:	18 95       	reti

00001888 <TOUT_SetupSleepTimer>:

// ======================================================================================

void TOUT_SetupSleepTimer(void)
{
    1888:	ab e8       	ldi	r26, 0x8B	; 139
    188a:	b0 e0       	ldi	r27, 0x00	; 0
    188c:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
    1890:	80 2d       	mov	r24, r0
	uint8_t NewTicksIndex = eeprom_read_byte(&EEPROMVars.AutoSleepValIndex);
    1892:	48 2f       	mov	r20, r24

	if (NewTicksIndex == 0xFF) // Blank EEPROM protection
    1894:	8f 3f       	cpi	r24, 0xFF	; 255
    1896:	09 f4       	brne	.+2      	; 0x189a <TOUT_SetupSleepTimer+0x12>
    1898:	44 e0       	ldi	r20, 0x04	; 4
	  NewTicksIndex = 4;

	TIMSK1 = (1 << TOIE1);
    189a:	51 e0       	ldi	r21, 0x01	; 1
    189c:	50 93 6f 00 	sts	0x006F, r21
	TicksBeforeAutoSleep = ((pgm_read_byte(&AutoSleepTOValues[NewTicksIndex]) << 1) * 5); // ((x << 1) * 5) == (x * 10)
    18a0:	e4 2f       	mov	r30, r20
    18a2:	ff 27       	eor	r31, r31
    18a4:	ef 51       	subi	r30, 0x1F	; 31
    18a6:	fc 4f       	sbci	r31, 0xFC	; 252
    18a8:	e4 91       	lpm	r30, Z
    18aa:	8e 2f       	mov	r24, r30
    18ac:	99 27       	eor	r25, r25
    18ae:	9c 01       	movw	r18, r24
    18b0:	73 e0       	ldi	r23, 0x03	; 3
    18b2:	22 0f       	add	r18, r18
    18b4:	33 1f       	adc	r19, r19
    18b6:	7a 95       	dec	r23
    18b8:	e1 f7       	brne	.-8      	; 0x18b2 <TOUT_SetupSleepTimer+0x2a>
    18ba:	88 0f       	add	r24, r24
    18bc:	99 1f       	adc	r25, r25
    18be:	28 0f       	add	r18, r24
    18c0:	39 1f       	adc	r19, r25
    18c2:	30 93 90 01 	sts	0x0190, r19
    18c6:	20 93 8f 01 	sts	0x018F, r18

	TIMEOUT_SLEEP_TIMEOUT_RESET();
    18ca:	10 92 8e 01 	sts	0x018E, r1
    18ce:	10 92 8d 01 	sts	0x018D, r1
    18d2:	10 92 85 00 	sts	0x0085, r1
    18d6:	10 92 84 00 	sts	0x0084, r1
	
	if (NewTicksIndex)
    18da:	44 23       	and	r20, r20
    18dc:	19 f0       	breq	.+6      	; 0x18e4 <TOUT_SetupSleepTimer+0x5c>
	  TIMEOUT_SLEEP_TIMER_ON();
    18de:	50 93 81 00 	sts	0x0081, r21
    18e2:	08 95       	ret
	else
	  TIMEOUT_SLEEP_TIMER_OFF();
    18e4:	10 92 81 00 	sts	0x0081, r1
    18e8:	08 95       	ret

000018ea <__vector_9>:
    18ea:	78 94       	sei
    18ec:	1f 92       	push	r1
    18ee:	0f 92       	push	r0
    18f0:	0f b6       	in	r0, 0x3f	; 63
    18f2:	0f 92       	push	r0
    18f4:	11 24       	eor	r1, r1
    18f6:	2f 93       	push	r18
    18f8:	3f 93       	push	r19
    18fa:	4f 93       	push	r20
    18fc:	5f 93       	push	r21
    18fe:	6f 93       	push	r22
    1900:	7f 93       	push	r23
    1902:	8f 93       	push	r24
    1904:	9f 93       	push	r25
    1906:	af 93       	push	r26
    1908:	bf 93       	push	r27
    190a:	ef 93       	push	r30
    190c:	ff 93       	push	r31
    190e:	80 91 8d 01 	lds	r24, 0x018D
    1912:	90 91 8e 01 	lds	r25, 0x018E
    1916:	20 91 8f 01 	lds	r18, 0x018F
    191a:	30 91 90 01 	lds	r19, 0x0190
    191e:	01 96       	adiw	r24, 0x01	; 1
    1920:	90 93 8e 01 	sts	0x018E, r25
    1924:	80 93 8d 01 	sts	0x018D, r24
    1928:	01 97       	sbiw	r24, 0x01	; 1
    192a:	82 17       	cp	r24, r18
    192c:	93 07       	cpc	r25, r19
    192e:	31 f4       	brne	.+12     	; 0x193c <__vector_9+0x52>
    1930:	10 92 81 00 	sts	0x0081, r1
    1934:	0e 94 da 02 	call	0x5b4	; 0x5b4 <FUNCSleepMode>
    1938:	0e 94 44 0c 	call	0x1888	; 0x1888 <TOUT_SetupSleepTimer>
    193c:	ff 91       	pop	r31
    193e:	ef 91       	pop	r30
    1940:	bf 91       	pop	r27
    1942:	af 91       	pop	r26
    1944:	9f 91       	pop	r25
    1946:	8f 91       	pop	r24
    1948:	7f 91       	pop	r23
    194a:	6f 91       	pop	r22
    194c:	5f 91       	pop	r21
    194e:	4f 91       	pop	r20
    1950:	3f 91       	pop	r19
    1952:	2f 91       	pop	r18
    1954:	0f 90       	pop	r0
    1956:	0f be       	out	0x3f, r0	; 63
    1958:	0f 90       	pop	r0
    195a:	1f 90       	pop	r1
    195c:	18 95       	reti

0000195e <__vector_4>:
    195e:	78 94       	sei
    1960:	1f 92       	push	r1
    1962:	0f 92       	push	r0
    1964:	0f b6       	in	r0, 0x3f	; 63
    1966:	0f 92       	push	r0
    1968:	11 24       	eor	r1, r1
    196a:	2f 93       	push	r18
    196c:	3f 93       	push	r19
    196e:	4f 93       	push	r20
    1970:	5f 93       	push	r21
    1972:	6f 93       	push	r22
    1974:	7f 93       	push	r23
    1976:	8f 93       	push	r24
    1978:	9f 93       	push	r25
    197a:	af 93       	push	r26
    197c:	bf 93       	push	r27
    197e:	ef 93       	push	r30
    1980:	ff 93       	push	r31
    1982:	80 91 8b 01 	lds	r24, 0x018B
    1986:	8f 5f       	subi	r24, 0xFF	; 255
    1988:	80 93 8b 01 	sts	0x018B, r24
    198c:	80 91 8b 01 	lds	r24, 0x018B
    1990:	87 39       	cpi	r24, 0x97	; 151
    1992:	29 f4       	brne	.+10     	; 0x199e <__vector_4+0x40>
    1994:	10 92 8b 01 	sts	0x018B, r1
    1998:	81 e0       	ldi	r24, 0x01	; 1
    199a:	80 93 8c 01 	sts	0x018C, r24
    199e:	80 91 c0 00 	lds	r24, 0x00C0
    19a2:	83 ff       	sbrs	r24, 3
    19a4:	03 c0       	rjmp	.+6      	; 0x19ac <__vector_4+0x4e>
    19a6:	80 ef       	ldi	r24, 0xF0	; 240
    19a8:	93 e0       	ldi	r25, 0x03	; 3
    19aa:	06 c0       	rjmp	.+12     	; 0x19b8 <__vector_4+0x5a>
    19ac:	80 91 c0 00 	lds	r24, 0x00C0
    19b0:	84 ff       	sbrs	r24, 4
    19b2:	04 c0       	rjmp	.+8      	; 0x19bc <__vector_4+0x5e>
    19b4:	86 ee       	ldi	r24, 0xE6	; 230
    19b6:	93 e0       	ldi	r25, 0x03	; 3
    19b8:	0e 94 cc 04 	call	0x998	; 0x998 <MAIN_CrashProgram>
    19bc:	ff 91       	pop	r31
    19be:	ef 91       	pop	r30
    19c0:	bf 91       	pop	r27
    19c2:	af 91       	pop	r26
    19c4:	9f 91       	pop	r25
    19c6:	8f 91       	pop	r24
    19c8:	7f 91       	pop	r23
    19ca:	6f 91       	pop	r22
    19cc:	5f 91       	pop	r21
    19ce:	4f 91       	pop	r20
    19d0:	3f 91       	pop	r19
    19d2:	2f 91       	pop	r18
    19d4:	0f 90       	pop	r0
    19d6:	0f be       	out	0x3f, r0	; 63
    19d8:	0f 90       	pop	r0
    19da:	1f 90       	pop	r1
    19dc:	18 95       	reti

000019de <PD_SetupDFAddressCounters>:
	}
}

void PD_SetupDFAddressCounters(void)
{
    19de:	ef 92       	push	r14
    19e0:	ff 92       	push	r15
    19e2:	0f 93       	push	r16
    19e4:	1f 93       	push	r17
	uint32_t StartAddress = CurrAddress;
    19e6:	20 91 a9 02 	lds	r18, 0x02A9
    19ea:	30 91 aa 02 	lds	r19, 0x02AA
    19ee:	40 91 ab 02 	lds	r20, 0x02AB
    19f2:	50 91 ac 02 	lds	r21, 0x02AC

	DataflashInfo.CurrPageAddress = 0;
    19f6:	10 92 44 01 	sts	0x0144, r1
    19fa:	10 92 43 01 	sts	0x0143, r1

	while (StartAddress > DataflashInfo.PageSize)      // This loop is the equivalent of a DIV and a MOD
    19fe:	80 91 3f 01 	lds	r24, 0x013F
    1a02:	90 91 40 01 	lds	r25, 0x0140
    1a06:	aa 27       	eor	r26, r26
    1a08:	bb 27       	eor	r27, r27
    1a0a:	60 e0       	ldi	r22, 0x00	; 0
    1a0c:	70 e0       	ldi	r23, 0x00	; 0
    1a0e:	ee 24       	eor	r14, r14
    1a10:	ff 24       	eor	r15, r15
    1a12:	87 01       	movw	r16, r14
    1a14:	e8 1a       	sub	r14, r24
    1a16:	f9 0a       	sbc	r15, r25
    1a18:	0a 0b       	sbc	r16, r26
    1a1a:	1b 0b       	sbc	r17, r27
    1a1c:	06 c0       	rjmp	.+12     	; 0x1a2a <PD_SetupDFAddressCounters+0x4c>
    1a1e:	2e 0d       	add	r18, r14
    1a20:	3f 1d       	adc	r19, r15
    1a22:	40 1f       	adc	r20, r16
    1a24:	51 1f       	adc	r21, r17
    1a26:	6f 5f       	subi	r22, 0xFF	; 255
    1a28:	7f 4f       	sbci	r23, 0xFF	; 255
    1a2a:	82 17       	cp	r24, r18
    1a2c:	93 07       	cpc	r25, r19
    1a2e:	a4 07       	cpc	r26, r20
    1a30:	b5 07       	cpc	r27, r21
    1a32:	a8 f3       	brcs	.-22     	; 0x1a1e <PD_SetupDFAddressCounters+0x40>
    1a34:	70 93 44 01 	sts	0x0144, r23
    1a38:	60 93 43 01 	sts	0x0143, r22
	{
		StartAddress -= DataflashInfo.PageSize;         // Subtract one page's worth of bytes from the desired address
		DataflashInfo.CurrPageAddress++;
	}
	
	DataflashInfo.CurrBuffByte = (uint16_t)StartAddress; // The buffer byte is the remainder
    1a3c:	30 93 46 01 	sts	0x0146, r19
    1a40:	20 93 45 01 	sts	0x0145, r18
    1a44:	1f 91       	pop	r17
    1a46:	0f 91       	pop	r16
    1a48:	ff 90       	pop	r15
    1a4a:	ef 90       	pop	r14
    1a4c:	08 95       	ret

00001a4e <PD_StoreDataflashByte>:
}

void PD_StoreDataflashByte(const uint8_t Data)
{
    1a4e:	1f 93       	push	r17
    1a50:	18 2f       	mov	r17, r24
	if (DataflashInfo.CurrBuffByte == DataflashInfo.PageSize)
    1a52:	20 91 45 01 	lds	r18, 0x0145
    1a56:	30 91 46 01 	lds	r19, 0x0146
    1a5a:	80 91 3f 01 	lds	r24, 0x013F
    1a5e:	90 91 40 01 	lds	r25, 0x0140
    1a62:	28 17       	cp	r18, r24
    1a64:	39 07       	cpc	r19, r25
    1a66:	a1 f4       	brne	.+40     	; 0x1a90 <PD_StoreDataflashByte+0x42>
	{
		DF_CopyBufferToFlashPage(DataflashInfo.CurrPageAddress++);
    1a68:	80 91 43 01 	lds	r24, 0x0143
    1a6c:	90 91 44 01 	lds	r25, 0x0144
    1a70:	01 96       	adiw	r24, 0x01	; 1
    1a72:	90 93 44 01 	sts	0x0144, r25
    1a76:	80 93 43 01 	sts	0x0143, r24
    1a7a:	01 97       	sbiw	r24, 0x01	; 1
    1a7c:	0e 94 56 0b 	call	0x16ac	; 0x16ac <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    1a80:	80 e0       	ldi	r24, 0x00	; 0
    1a82:	90 e0       	ldi	r25, 0x00	; 0
    1a84:	0e 94 cc 0a 	call	0x1598	; 0x1598 <DF_BufferWriteEnable>
		DataflashInfo.CurrBuffByte = 0;
    1a88:	10 92 46 01 	sts	0x0146, r1
    1a8c:	10 92 45 01 	sts	0x0145, r1
	}
	
	USI_SPITransmit(Data);                                 // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    1a90:	81 2f       	mov	r24, r17
    1a92:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
	DataflashInfo.CurrBuffByte++;
    1a96:	80 91 45 01 	lds	r24, 0x0145
    1a9a:	90 91 46 01 	lds	r25, 0x0146
    1a9e:	01 96       	adiw	r24, 0x01	; 1
    1aa0:	90 93 46 01 	sts	0x0146, r25
    1aa4:	80 93 45 01 	sts	0x0145, r24
    1aa8:	1f 91       	pop	r17
    1aaa:	08 95       	ret

00001aac <PD_InterpretAVRISPPacket>:
    1aac:	0f 93       	push	r16
    1aae:	1f 93       	push	r17
    1ab0:	cf 93       	push	r28
    1ab2:	df 93       	push	r29
    1ab4:	80 91 91 01 	lds	r24, 0x0191
    1ab8:	86 31       	cpi	r24, 0x16	; 22
    1aba:	09 f4       	brne	.+2      	; 0x1abe <PD_InterpretAVRISPPacket+0x12>
    1abc:	f1 c0       	rjmp	.+482    	; 0x1ca0 <PD_InterpretAVRISPPacket+0x1f4>
    1abe:	87 31       	cpi	r24, 0x17	; 23
    1ac0:	90 f4       	brcc	.+36     	; 0x1ae6 <PD_InterpretAVRISPPacket+0x3a>
    1ac2:	82 31       	cpi	r24, 0x12	; 18
    1ac4:	09 f4       	brne	.+2      	; 0x1ac8 <PD_InterpretAVRISPPacket+0x1c>
    1ac6:	65 c0       	rjmp	.+202    	; 0x1b92 <PD_InterpretAVRISPPacket+0xe6>
    1ac8:	83 31       	cpi	r24, 0x13	; 19
    1aca:	30 f4       	brcc	.+12     	; 0x1ad8 <PD_InterpretAVRISPPacket+0x2c>
    1acc:	80 31       	cpi	r24, 0x10	; 16
    1ace:	01 f1       	breq	.+64     	; 0x1b10 <PD_InterpretAVRISPPacket+0x64>
    1ad0:	81 31       	cpi	r24, 0x11	; 17
    1ad2:	09 f0       	breq	.+2      	; 0x1ad6 <PD_InterpretAVRISPPacket+0x2a>
    1ad4:	2f c1       	rjmp	.+606    	; 0x1d34 <PD_InterpretAVRISPPacket+0x288>
    1ad6:	41 c0       	rjmp	.+130    	; 0x1b5a <PD_InterpretAVRISPPacket+0xae>
    1ad8:	84 31       	cpi	r24, 0x14	; 20
    1ada:	09 f4       	brne	.+2      	; 0x1ade <PD_InterpretAVRISPPacket+0x32>
    1adc:	8b c0       	rjmp	.+278    	; 0x1bf4 <PD_InterpretAVRISPPacket+0x148>
    1ade:	85 31       	cpi	r24, 0x15	; 21
    1ae0:	08 f0       	brcs	.+2      	; 0x1ae4 <PD_InterpretAVRISPPacket+0x38>
    1ae2:	ab c0       	rjmp	.+342    	; 0x1c3a <PD_InterpretAVRISPPacket+0x18e>
    1ae4:	80 c0       	rjmp	.+256    	; 0x1be6 <PD_InterpretAVRISPPacket+0x13a>
    1ae6:	89 31       	cpi	r24, 0x19	; 25
    1ae8:	09 f4       	brne	.+2      	; 0x1aec <PD_InterpretAVRISPPacket+0x40>
    1aea:	72 c0       	rjmp	.+228    	; 0x1bd0 <PD_InterpretAVRISPPacket+0x124>
    1aec:	8a 31       	cpi	r24, 0x1A	; 26
    1aee:	38 f4       	brcc	.+14     	; 0x1afe <PD_InterpretAVRISPPacket+0x52>
    1af0:	87 31       	cpi	r24, 0x17	; 23
    1af2:	09 f4       	brne	.+2      	; 0x1af6 <PD_InterpretAVRISPPacket+0x4a>
    1af4:	6d c0       	rjmp	.+218    	; 0x1bd0 <PD_InterpretAVRISPPacket+0x124>
    1af6:	88 31       	cpi	r24, 0x18	; 24
    1af8:	09 f0       	breq	.+2      	; 0x1afc <PD_InterpretAVRISPPacket+0x50>
    1afa:	1c c1       	rjmp	.+568    	; 0x1d34 <PD_InterpretAVRISPPacket+0x288>
    1afc:	5b c0       	rjmp	.+182    	; 0x1bb4 <PD_InterpretAVRISPPacket+0x108>
    1afe:	8b 31       	cpi	r24, 0x1B	; 27
    1b00:	f1 f1       	breq	.+124    	; 0x1b7e <PD_InterpretAVRISPPacket+0xd2>
    1b02:	8b 31       	cpi	r24, 0x1B	; 27
    1b04:	08 f4       	brcc	.+2      	; 0x1b08 <PD_InterpretAVRISPPacket+0x5c>
    1b06:	56 c0       	rjmp	.+172    	; 0x1bb4 <PD_InterpretAVRISPPacket+0x108>
    1b08:	8c 31       	cpi	r24, 0x1C	; 28
    1b0a:	09 f0       	breq	.+2      	; 0x1b0e <PD_InterpretAVRISPPacket+0x62>
    1b0c:	13 c1       	rjmp	.+550    	; 0x1d34 <PD_InterpretAVRISPPacket+0x288>
    1b0e:	52 c0       	rjmp	.+164    	; 0x1bb4 <PD_InterpretAVRISPPacket+0x108>
    1b10:	82 e0       	ldi	r24, 0x02	; 2
    1b12:	90 e0       	ldi	r25, 0x00	; 0
    1b14:	90 93 a7 02 	sts	0x02A7, r25
    1b18:	80 93 a6 02 	sts	0x02A6, r24
    1b1c:	81 e0       	ldi	r24, 0x01	; 1
    1b1e:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    1b22:	0e 94 85 0b 	call	0x170a	; 0x170a <DF_GetChipCharacteristics>
    1b26:	80 91 3d 01 	lds	r24, 0x013D
    1b2a:	90 91 3e 01 	lds	r25, 0x013E
    1b2e:	89 2b       	or	r24, r25
    1b30:	59 f0       	breq	.+22     	; 0x1b48 <PD_InterpretAVRISPPacket+0x9c>
    1b32:	89 ef       	ldi	r24, 0xF9	; 249
    1b34:	93 e0       	ldi	r25, 0x03	; 3
    1b36:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
    1b3a:	81 e0       	ldi	r24, 0x01	; 1
    1b3c:	80 93 a8 02 	sts	0x02A8, r24
    1b40:	81 b3       	in	r24, 0x11	; 17
    1b42:	8f 7c       	andi	r24, 0xCF	; 207
    1b44:	80 62       	ori	r24, 0x20	; 32
    1b46:	17 c0       	rjmp	.+46     	; 0x1b76 <PD_InterpretAVRISPPacket+0xca>
    1b48:	88 ec       	ldi	r24, 0xC8	; 200
    1b4a:	93 e0       	ldi	r25, 0x03	; 3
    1b4c:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
    1b50:	80 e0       	ldi	r24, 0x00	; 0
    1b52:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    1b56:	80 ec       	ldi	r24, 0xC0	; 192
    1b58:	f4 c0       	rjmp	.+488    	; 0x1d42 <PD_InterpretAVRISPPacket+0x296>
    1b5a:	82 e0       	ldi	r24, 0x02	; 2
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	90 93 a7 02 	sts	0x02A7, r25
    1b62:	80 93 a6 02 	sts	0x02A6, r24
    1b66:	10 92 a8 02 	sts	0x02A8, r1
    1b6a:	80 e0       	ldi	r24, 0x00	; 0
    1b6c:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    1b70:	81 b3       	in	r24, 0x11	; 17
    1b72:	8f 7c       	andi	r24, 0xCF	; 207
    1b74:	80 61       	ori	r24, 0x10	; 16
    1b76:	81 bb       	out	0x11, r24	; 17
    1b78:	10 92 92 01 	sts	0x0192, r1
    1b7c:	e4 c0       	rjmp	.+456    	; 0x1d46 <PD_InterpretAVRISPPacket+0x29a>
    1b7e:	84 e0       	ldi	r24, 0x04	; 4
    1b80:	90 e0       	ldi	r25, 0x00	; 0
    1b82:	90 93 a7 02 	sts	0x02A7, r25
    1b86:	80 93 a6 02 	sts	0x02A6, r24
    1b8a:	10 92 92 01 	sts	0x0192, r1
    1b8e:	82 e0       	ldi	r24, 0x02	; 2
    1b90:	1a c0       	rjmp	.+52     	; 0x1bc6 <PD_InterpretAVRISPPacket+0x11a>
    1b92:	82 e0       	ldi	r24, 0x02	; 2
    1b94:	90 e0       	ldi	r25, 0x00	; 0
    1b96:	90 93 a7 02 	sts	0x02A7, r25
    1b9a:	80 93 a6 02 	sts	0x02A6, r24
    1b9e:	10 92 92 01 	sts	0x0192, r1
    1ba2:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <V2P_SendPacket>
    1ba6:	87 ea       	ldi	r24, 0xA7	; 167
    1ba8:	90 e0       	ldi	r25, 0x00	; 0
    1baa:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
    1bae:	c0 e0       	ldi	r28, 0x00	; 0
    1bb0:	d0 e0       	ldi	r29, 0x00	; 0
    1bb2:	d0 c0       	rjmp	.+416    	; 0x1d54 <PD_InterpretAVRISPPacket+0x2a8>
    1bb4:	84 e0       	ldi	r24, 0x04	; 4
    1bb6:	90 e0       	ldi	r25, 0x00	; 0
    1bb8:	90 93 a7 02 	sts	0x02A7, r25
    1bbc:	80 93 a6 02 	sts	0x02A6, r24
    1bc0:	10 92 92 01 	sts	0x0192, r1
    1bc4:	8f ef       	ldi	r24, 0xFF	; 255
    1bc6:	80 93 93 01 	sts	0x0193, r24
    1bca:	10 92 94 01 	sts	0x0194, r1
    1bce:	bb c0       	rjmp	.+374    	; 0x1d46 <PD_InterpretAVRISPPacket+0x29a>
    1bd0:	83 e0       	ldi	r24, 0x03	; 3
    1bd2:	90 e0       	ldi	r25, 0x00	; 0
    1bd4:	90 93 a7 02 	sts	0x02A7, r25
    1bd8:	80 93 a6 02 	sts	0x02A6, r24
    1bdc:	10 92 92 01 	sts	0x0192, r1
    1be0:	10 92 93 01 	sts	0x0193, r1
    1be4:	b0 c0       	rjmp	.+352    	; 0x1d46 <PD_InterpretAVRISPPacket+0x29a>
    1be6:	82 e0       	ldi	r24, 0x02	; 2
    1be8:	90 e0       	ldi	r25, 0x00	; 0
    1bea:	90 93 a7 02 	sts	0x02A7, r25
    1bee:	80 93 a6 02 	sts	0x02A6, r24
    1bf2:	c2 cf       	rjmp	.-124    	; 0x1b78 <PD_InterpretAVRISPPacket+0xcc>
    1bf4:	20 91 92 01 	lds	r18, 0x0192
    1bf8:	33 27       	eor	r19, r19
    1bfa:	32 2f       	mov	r19, r18
    1bfc:	22 27       	eor	r18, r18
    1bfe:	80 91 93 01 	lds	r24, 0x0193
    1c02:	99 27       	eor	r25, r25
    1c04:	28 2b       	or	r18, r24
    1c06:	39 2b       	or	r19, r25
    1c08:	f9 01       	movw	r30, r18
    1c0a:	33 96       	adiw	r30, 0x03	; 3
    1c0c:	f0 93 a7 02 	sts	0x02A7, r31
    1c10:	e0 93 a6 02 	sts	0x02A6, r30
    1c14:	81 e0       	ldi	r24, 0x01	; 1
    1c16:	90 e0       	ldi	r25, 0x00	; 0
    1c18:	a2 e9       	ldi	r26, 0x92	; 146
    1c1a:	b1 e0       	ldi	r27, 0x01	; 1
    1c1c:	2f 5f       	subi	r18, 0xFF	; 255
    1c1e:	3f 4f       	sbci	r19, 0xFF	; 255
    1c20:	4f ef       	ldi	r20, 0xFF	; 255
    1c22:	02 c0       	rjmp	.+4      	; 0x1c28 <PD_InterpretAVRISPPacket+0x17c>
    1c24:	4d 93       	st	X+, r20
    1c26:	01 96       	adiw	r24, 0x01	; 1
    1c28:	82 17       	cp	r24, r18
    1c2a:	93 07       	cpc	r25, r19
    1c2c:	d8 f3       	brcs	.-10     	; 0x1c24 <PD_InterpretAVRISPPacket+0x178>
    1c2e:	10 92 92 01 	sts	0x0192, r1
    1c32:	e0 57       	subi	r30, 0x70	; 112
    1c34:	fe 4f       	sbci	r31, 0xFE	; 254
    1c36:	10 82       	st	Z, r1
    1c38:	86 c0       	rjmp	.+268    	; 0x1d46 <PD_InterpretAVRISPPacket+0x29a>
    1c3a:	0e 94 ef 0c 	call	0x19de	; 0x19de <PD_SetupDFAddressCounters>
    1c3e:	80 91 43 01 	lds	r24, 0x0143
    1c42:	90 91 44 01 	lds	r25, 0x0144
    1c46:	0e 94 27 0b 	call	0x164e	; 0x164e <DF_CopyFlashPageToBuffer>
    1c4a:	80 91 45 01 	lds	r24, 0x0145
    1c4e:	90 91 46 01 	lds	r25, 0x0146
    1c52:	0e 94 cc 0a 	call	0x1598	; 0x1598 <DF_BufferWriteEnable>
    1c56:	80 91 92 01 	lds	r24, 0x0192
    1c5a:	99 27       	eor	r25, r25
    1c5c:	d8 2f       	mov	r29, r24
    1c5e:	cc 27       	eor	r28, r28
    1c60:	80 91 93 01 	lds	r24, 0x0193
    1c64:	99 27       	eor	r25, r25
    1c66:	c8 2b       	or	r28, r24
    1c68:	d9 2b       	or	r29, r25
    1c6a:	01 e9       	ldi	r16, 0x91	; 145
    1c6c:	11 e0       	ldi	r17, 0x01	; 1
    1c6e:	11 c0       	rjmp	.+34     	; 0x1c92 <PD_InterpretAVRISPPacket+0x1e6>
    1c70:	f8 01       	movw	r30, r16
    1c72:	82 85       	ldd	r24, Z+10	; 0x0a
    1c74:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <PD_StoreDataflashByte>
    1c78:	80 91 45 01 	lds	r24, 0x0145
    1c7c:	90 91 46 01 	lds	r25, 0x0146
    1c80:	01 96       	adiw	r24, 0x01	; 1
    1c82:	90 93 46 01 	sts	0x0146, r25
    1c86:	80 93 45 01 	sts	0x0145, r24
    1c8a:	0e 94 dc 0e 	call	0x1db8	; 0x1db8 <V2P_IncrementCurrAddress>
    1c8e:	0f 5f       	subi	r16, 0xFF	; 255
    1c90:	1f 4f       	sbci	r17, 0xFF	; 255
    1c92:	ce 01       	movw	r24, r28
    1c94:	8f 56       	subi	r24, 0x6F	; 111
    1c96:	9e 4f       	sbci	r25, 0xFE	; 254
    1c98:	08 17       	cp	r16, r24
    1c9a:	19 07       	cpc	r17, r25
    1c9c:	49 f7       	brne	.-46     	; 0x1c70 <PD_InterpretAVRISPPacket+0x1c4>
    1c9e:	6c cf       	rjmp	.-296    	; 0x1b78 <PD_InterpretAVRISPPacket+0xcc>
    1ca0:	0e 94 ef 0c 	call	0x19de	; 0x19de <PD_SetupDFAddressCounters>
    1ca4:	80 91 43 01 	lds	r24, 0x0143
    1ca8:	90 91 44 01 	lds	r25, 0x0144
    1cac:	0e 94 27 0b 	call	0x164e	; 0x164e <DF_CopyFlashPageToBuffer>
    1cb0:	80 91 92 01 	lds	r24, 0x0192
    1cb4:	99 27       	eor	r25, r25
    1cb6:	d8 2f       	mov	r29, r24
    1cb8:	cc 27       	eor	r28, r28
    1cba:	80 91 93 01 	lds	r24, 0x0193
    1cbe:	99 27       	eor	r25, r25
    1cc0:	c8 2b       	or	r28, r24
    1cc2:	d9 2b       	or	r29, r25
    1cc4:	01 e9       	ldi	r16, 0x91	; 145
    1cc6:	11 e0       	ldi	r17, 0x01	; 1
    1cc8:	25 c0       	rjmp	.+74     	; 0x1d14 <PD_InterpretAVRISPPacket+0x268>
    1cca:	20 91 45 01 	lds	r18, 0x0145
    1cce:	30 91 46 01 	lds	r19, 0x0146
    1cd2:	80 91 3f 01 	lds	r24, 0x013F
    1cd6:	90 91 40 01 	lds	r25, 0x0140
    1cda:	28 17       	cp	r18, r24
    1cdc:	39 07       	cpc	r19, r25
    1cde:	41 f4       	brne	.+16     	; 0x1cf0 <PD_InterpretAVRISPPacket+0x244>
    1ce0:	0e 94 ef 0c 	call	0x19de	; 0x19de <PD_SetupDFAddressCounters>
    1ce4:	80 91 43 01 	lds	r24, 0x0143
    1ce8:	90 91 44 01 	lds	r25, 0x0144
    1cec:	0e 94 27 0b 	call	0x164e	; 0x164e <DF_CopyFlashPageToBuffer>
    1cf0:	80 91 45 01 	lds	r24, 0x0145
    1cf4:	90 91 46 01 	lds	r25, 0x0146
    1cf8:	01 96       	adiw	r24, 0x01	; 1
    1cfa:	90 93 46 01 	sts	0x0146, r25
    1cfe:	80 93 45 01 	sts	0x0145, r24
    1d02:	01 97       	sbiw	r24, 0x01	; 1
    1d04:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <DF_ReadBufferByte>
    1d08:	f8 01       	movw	r30, r16
    1d0a:	82 83       	std	Z+2, r24	; 0x02
    1d0c:	0e 94 dc 0e 	call	0x1db8	; 0x1db8 <V2P_IncrementCurrAddress>
    1d10:	0f 5f       	subi	r16, 0xFF	; 255
    1d12:	1f 4f       	sbci	r17, 0xFF	; 255
    1d14:	ce 01       	movw	r24, r28
    1d16:	8f 56       	subi	r24, 0x6F	; 111
    1d18:	9e 4f       	sbci	r25, 0xFE	; 254
    1d1a:	08 17       	cp	r16, r24
    1d1c:	19 07       	cpc	r17, r25
    1d1e:	a9 f6       	brne	.-86     	; 0x1cca <PD_InterpretAVRISPPacket+0x21e>
    1d20:	23 96       	adiw	r28, 0x03	; 3
    1d22:	d0 93 a7 02 	sts	0x02A7, r29
    1d26:	c0 93 a6 02 	sts	0x02A6, r28
    1d2a:	10 92 92 01 	sts	0x0192, r1
    1d2e:	f8 01       	movw	r30, r16
    1d30:	12 82       	std	Z+2, r1	; 0x02
    1d32:	09 c0       	rjmp	.+18     	; 0x1d46 <PD_InterpretAVRISPPacket+0x29a>
    1d34:	81 e0       	ldi	r24, 0x01	; 1
    1d36:	90 e0       	ldi	r25, 0x00	; 0
    1d38:	90 93 a7 02 	sts	0x02A7, r25
    1d3c:	80 93 a6 02 	sts	0x02A6, r24
    1d40:	89 ec       	ldi	r24, 0xC9	; 201
    1d42:	80 93 92 01 	sts	0x0192, r24
    1d46:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <V2P_SendPacket>
    1d4a:	14 c0       	rjmp	.+40     	; 0x1d74 <PD_InterpretAVRISPPacket+0x2c8>
    1d4c:	ce 01       	movw	r24, r28
    1d4e:	0e 94 04 0b 	call	0x1608	; 0x1608 <DF_EraseBlock>
    1d52:	21 96       	adiw	r28, 0x01	; 1
    1d54:	80 91 41 01 	lds	r24, 0x0141
    1d58:	90 91 42 01 	lds	r25, 0x0142
    1d5c:	23 e0       	ldi	r18, 0x03	; 3
    1d5e:	96 95       	lsr	r25
    1d60:	87 95       	ror	r24
    1d62:	2a 95       	dec	r18
    1d64:	e1 f7       	brne	.-8      	; 0x1d5e <PD_InterpretAVRISPPacket+0x2b2>
    1d66:	c8 17       	cp	r28, r24
    1d68:	d9 07       	cpc	r29, r25
    1d6a:	80 f3       	brcs	.-32     	; 0x1d4c <PD_InterpretAVRISPPacket+0x2a0>
    1d6c:	89 ef       	ldi	r24, 0xF9	; 249
    1d6e:	93 e0       	ldi	r25, 0x03	; 3
    1d70:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
    1d74:	df 91       	pop	r29
    1d76:	cf 91       	pop	r28
    1d78:	1f 91       	pop	r17
    1d7a:	0f 91       	pop	r16
    1d7c:	08 95       	ret

00001d7e <V2P_GetChecksum>:
	SequenceNum++;
}

uint8_t V2P_GetChecksum()
{
    1d7e:	90 91 a4 02 	lds	r25, 0x02A4
    1d82:	8b e1       	ldi	r24, 0x1B	; 27
    1d84:	98 27       	eor	r25, r24
	uint8_t CheckSumByte;
	
	/* Checksum for the V2 protocol is comprised of an XOR of all the packet 
      bytes, including the start, sequence number, size and token bytes.    */
	
	CheckSumByte  = AICB_MESSAGE_START;
	CheckSumByte ^= SequenceNum;
	CheckSumByte ^= (uint8_t)(MessageSize >> 8);
    1d86:	40 91 a6 02 	lds	r20, 0x02A6
    1d8a:	50 91 a7 02 	lds	r21, 0x02A7
    1d8e:	94 27       	eor	r25, r20
	CheckSumByte ^= (uint8_t)(MessageSize & 0xFF);
    1d90:	25 2f       	mov	r18, r21
    1d92:	33 27       	eor	r19, r19
    1d94:	8e e0       	ldi	r24, 0x0E	; 14
    1d96:	82 27       	eor	r24, r18
	CheckSumByte ^= AICB_TOKEN;
    1d98:	98 27       	eor	r25, r24
    1d9a:	20 e0       	ldi	r18, 0x00	; 0
    1d9c:	30 e0       	ldi	r19, 0x00	; 0
    1d9e:	e1 e9       	ldi	r30, 0x91	; 145
    1da0:	f1 e0       	ldi	r31, 0x01	; 1
    1da2:	04 c0       	rjmp	.+8      	; 0x1dac <V2P_GetChecksum+0x2e>
	
	for (uint16_t CByteIndex = 0; CByteIndex < MessageSize; CByteIndex++)
	   CheckSumByte ^= PacketBytes[CByteIndex];
    1da4:	81 91       	ld	r24, Z+
    1da6:	98 27       	eor	r25, r24
    1da8:	2f 5f       	subi	r18, 0xFF	; 255
    1daa:	3f 4f       	sbci	r19, 0xFF	; 255
    1dac:	24 17       	cp	r18, r20
    1dae:	35 07       	cpc	r19, r21
    1db0:	c9 f7       	brne	.-14     	; 0x1da4 <V2P_GetChecksum+0x26>

	return CheckSumByte;
}
    1db2:	89 2f       	mov	r24, r25
    1db4:	99 27       	eor	r25, r25
    1db6:	08 95       	ret

00001db8 <V2P_IncrementCurrAddress>:

void V2P_GetSetParamater(void)
{
	uint8_t Param_Name = PacketBytes[1];    // Save the parameter number

	MessageSize = 3;                        // Set the default response message size to 3 bytes     
	PacketBytes[1] = AICB_STATUS_CMD_OK;    // Set the default response to OK

	switch (Param_Name)                     // Switch based on the recieved parameter byte
	{
		case AICB_PARAM_BUILD_NUMBER_LOW:
			PacketBytes[2] = VERSION_MINOR;

			break;
		case AICB_PARAM_BUILD_NUMBER_HIGH:
			PacketBytes[2] = VERSION_MAJOR;

			break;
		case AICB_PARAM_HARDWARE_VERSION:
			PacketBytes[2] = V2P_HW_VERSION;

			break;
		case AICB_PARAM_SW_MAJOR:
			PacketBytes[2] = V2P_SW_VERSION_MAJOR;

			break;
		case AICB_PARAM_SW_MINOR:
			PacketBytes[2] = ((eeprom_read_byte(&EEPROMVars.FirmVerMinor) == 0xFF)? V2P_SW_VERSION_MINOR_DEFAULT : eeprom_read_byte(&EEPROMVars.FirmVerMinor));

			break;
		case AICB_PARAM_CONTROLLER_INIT:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = Param_ControllerInit;
			}
			else
			{
				MessageSize = 2;
				Param_ControllerInit = PacketBytes[2];
			}
			
			break;
		case AICB_PARAM_SCK_DURATION:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.SCKDuration);
			}
			else
			{
				MessageSize = 2;
				eeprom_write_byte(&EEPROMVars.SCKDuration, PacketBytes[2]);
				USI_SPISetSpeed();          // Re-Initialise the USI system with the new frequency
			}
					
			break;
		case AICB_PARAM_RESET_POLARITY:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.ResetPolarity);		
			}
			else
			{
				MessageSize = 2;
				eeprom_write_byte(&EEPROMVars.ResetPolarity, PacketBytes[2]);
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Change takes effect immediatly
			}
			
			break;
		case AICB_PARAM_OSC_PSCALE:
		case AICB_PARAM_OSC_CMATCH:
			/* Despite not supporting these parameters (STK500 only), the AVR Studio programmer
			   sends them occasionally. A OK must be returned or the sequence will fail.        */
		
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			  PacketBytes[2] = 0;             // If the command is a read, return a 0 for both parameters
			else
			  MessageSize = 2;                // Otherwise just send back an OK if the command is a set		
			
			break;
		default:                             // Unrecognised parameter
			MessageSize = 2;
			PacketBytes[1] = AICB_STATUS_CMD_FAILED;			
	}
	
	V2P_SendPacket();
}

void V2P_IncrementCurrAddress(void)
{
    1db8:	80 91 a9 02 	lds	r24, 0x02A9
    1dbc:	90 91 aa 02 	lds	r25, 0x02AA
    1dc0:	a0 91 ab 02 	lds	r26, 0x02AB
    1dc4:	b0 91 ac 02 	lds	r27, 0x02AC
    1dc8:	01 96       	adiw	r24, 0x01	; 1
    1dca:	a1 1d       	adc	r26, r1
    1dcc:	b1 1d       	adc	r27, r1
    1dce:	80 93 a9 02 	sts	0x02A9, r24
    1dd2:	90 93 aa 02 	sts	0x02AA, r25
    1dd6:	a0 93 ab 02 	sts	0x02AB, r26
    1dda:	b0 93 ac 02 	sts	0x02AC, r27
    1dde:	08 95       	ret

00001de0 <V2P_CheckForExtendedAddress>:
	// Incrementing a 32-bit unsigned variable takes a lot of code. Because much of the code is
	// not very time critical (much of it is waiting for the hardware), I've chosen to waste
	// a few extra cycles per increment and save a good 60 bytes or so of code space by putting
	// the increment inside a function.

	CurrAddress++;
}

void V2P_CheckForExtendedAddress(void)
{
    1de0:	80 91 a9 02 	lds	r24, 0x02A9
    1de4:	90 91 aa 02 	lds	r25, 0x02AA
    1de8:	a0 91 ab 02 	lds	r26, 0x02AB
    1dec:	b0 91 ac 02 	lds	r27, 0x02AC
    1df0:	b7 ff       	sbrs	r27, 7
    1df2:	1e c0       	rjmp	.+60     	; 0x1e30 <V2P_CheckForExtendedAddress+0x50>
	if (CurrAddress & V2P_LOAD_EXTENDED_ADDR_FLAG)     // MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
	{
		USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);   // Load extended address command
    1df4:	8d e4       	ldi	r24, 0x4D	; 77
    1df6:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1dfa:	80 e0       	ldi	r24, 0x00	; 0
    1dfc:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
		USI_SPITransmit((CurrAddress & V2P_LOAD_EXTENDED_ADDR_MASK) >> V2P_LOAD_EXTENDED_ADDR_SHIFT);
    1e00:	80 91 ab 02 	lds	r24, 0x02AB
    1e04:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1e08:	80 e0       	ldi	r24, 0x00	; 0
    1e0a:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
		
		CurrAddress &= ~(V2P_LOAD_EXTENDED_ADDR_FLAG); // Clear the flag
    1e0e:	80 91 a9 02 	lds	r24, 0x02A9
    1e12:	90 91 aa 02 	lds	r25, 0x02AA
    1e16:	a0 91 ab 02 	lds	r26, 0x02AB
    1e1a:	b0 91 ac 02 	lds	r27, 0x02AC
    1e1e:	bf 77       	andi	r27, 0x7F	; 127
    1e20:	80 93 a9 02 	sts	0x02A9, r24
    1e24:	90 93 aa 02 	sts	0x02AA, r25
    1e28:	a0 93 ab 02 	sts	0x02AB, r26
    1e2c:	b0 93 ac 02 	sts	0x02AC, r27
    1e30:	08 95       	ret

00001e32 <V2P_SendPacket>:
    1e32:	0f 93       	push	r16
    1e34:	1f 93       	push	r17
    1e36:	cf 93       	push	r28
    1e38:	df 93       	push	r29
    1e3a:	8b e1       	ldi	r24, 0x1B	; 27
    1e3c:	0e 94 87 09 	call	0x130e	; 0x130e <USART_Tx>
    1e40:	80 91 a4 02 	lds	r24, 0x02A4
    1e44:	0e 94 87 09 	call	0x130e	; 0x130e <USART_Tx>
    1e48:	80 91 a7 02 	lds	r24, 0x02A7
    1e4c:	0e 94 87 09 	call	0x130e	; 0x130e <USART_Tx>
    1e50:	80 91 a6 02 	lds	r24, 0x02A6
    1e54:	0e 94 87 09 	call	0x130e	; 0x130e <USART_Tx>
    1e58:	8e e0       	ldi	r24, 0x0E	; 14
    1e5a:	0e 94 87 09 	call	0x130e	; 0x130e <USART_Tx>
    1e5e:	c0 e0       	ldi	r28, 0x00	; 0
    1e60:	d0 e0       	ldi	r29, 0x00	; 0
    1e62:	01 e9       	ldi	r16, 0x91	; 145
    1e64:	11 e0       	ldi	r17, 0x01	; 1
    1e66:	06 c0       	rjmp	.+12     	; 0x1e74 <V2P_SendPacket+0x42>
    1e68:	f8 01       	movw	r30, r16
    1e6a:	81 91       	ld	r24, Z+
    1e6c:	8f 01       	movw	r16, r30
    1e6e:	0e 94 87 09 	call	0x130e	; 0x130e <USART_Tx>
    1e72:	21 96       	adiw	r28, 0x01	; 1
    1e74:	80 91 a6 02 	lds	r24, 0x02A6
    1e78:	90 91 a7 02 	lds	r25, 0x02A7
    1e7c:	c8 17       	cp	r28, r24
    1e7e:	d9 07       	cpc	r29, r25
    1e80:	98 f3       	brcs	.-26     	; 0x1e68 <V2P_SendPacket+0x36>
    1e82:	0e 94 bf 0e 	call	0x1d7e	; 0x1d7e <V2P_GetChecksum>
    1e86:	0e 94 87 09 	call	0x130e	; 0x130e <USART_Tx>
    1e8a:	80 91 a4 02 	lds	r24, 0x02A4
    1e8e:	90 91 a5 02 	lds	r25, 0x02A5
    1e92:	01 96       	adiw	r24, 0x01	; 1
    1e94:	90 93 a5 02 	sts	0x02A5, r25
    1e98:	80 93 a4 02 	sts	0x02A4, r24
    1e9c:	df 91       	pop	r29
    1e9e:	cf 91       	pop	r28
    1ea0:	1f 91       	pop	r17
    1ea2:	0f 91       	pop	r16
    1ea4:	08 95       	ret

00001ea6 <V2P_GetSetParamater>:
    1ea6:	20 91 92 01 	lds	r18, 0x0192
    1eaa:	83 e0       	ldi	r24, 0x03	; 3
    1eac:	90 e0       	ldi	r25, 0x00	; 0
    1eae:	90 93 a7 02 	sts	0x02A7, r25
    1eb2:	80 93 a6 02 	sts	0x02A6, r24
    1eb6:	10 92 92 01 	sts	0x0192, r1
    1eba:	22 39       	cpi	r18, 0x92	; 146
    1ebc:	21 f1       	breq	.+72     	; 0x1f06 <V2P_GetSetParamater+0x60>
    1ebe:	23 39       	cpi	r18, 0x93	; 147
    1ec0:	70 f4       	brcc	.+28     	; 0x1ede <V2P_GetSetParamater+0x38>
    1ec2:	21 38       	cpi	r18, 0x81	; 129
    1ec4:	d1 f0       	breq	.+52     	; 0x1efa <V2P_GetSetParamater+0x54>
    1ec6:	22 38       	cpi	r18, 0x82	; 130
    1ec8:	20 f4       	brcc	.+8      	; 0x1ed2 <V2P_GetSetParamater+0x2c>
    1eca:	20 38       	cpi	r18, 0x80	; 128
    1ecc:	09 f0       	breq	.+2      	; 0x1ed0 <V2P_GetSetParamater+0x2a>
    1ece:	74 c0       	rjmp	.+232    	; 0x1fb8 <V2P_GetSetParamater+0x112>
    1ed0:	22 c0       	rjmp	.+68     	; 0x1f16 <V2P_GetSetParamater+0x70>
    1ed2:	20 39       	cpi	r18, 0x90	; 144
    1ed4:	b1 f0       	breq	.+44     	; 0x1f02 <V2P_GetSetParamater+0x5c>
    1ed6:	21 39       	cpi	r18, 0x91	; 145
    1ed8:	09 f0       	breq	.+2      	; 0x1edc <V2P_GetSetParamater+0x36>
    1eda:	6e c0       	rjmp	.+220    	; 0x1fb8 <V2P_GetSetParamater+0x112>
    1edc:	12 c0       	rjmp	.+36     	; 0x1f02 <V2P_GetSetParamater+0x5c>
    1ede:	28 39       	cpi	r18, 0x98	; 152
    1ee0:	81 f1       	breq	.+96     	; 0x1f42 <V2P_GetSetParamater+0x9c>
    1ee2:	29 39       	cpi	r18, 0x99	; 153
    1ee4:	20 f4       	brcc	.+8      	; 0x1eee <V2P_GetSetParamater+0x48>
    1ee6:	26 39       	cpi	r18, 0x96	; 150
    1ee8:	08 f4       	brcc	.+2      	; 0x1eec <V2P_GetSetParamater+0x46>
    1eea:	66 c0       	rjmp	.+204    	; 0x1fb8 <V2P_GetSetParamater+0x112>
    1eec:	57 c0       	rjmp	.+174    	; 0x1f9c <V2P_GetSetParamater+0xf6>
    1eee:	2e 39       	cpi	r18, 0x9E	; 158
    1ef0:	e1 f1       	breq	.+120    	; 0x1f6a <V2P_GetSetParamater+0xc4>
    1ef2:	2f 39       	cpi	r18, 0x9F	; 159
    1ef4:	09 f0       	breq	.+2      	; 0x1ef8 <V2P_GetSetParamater+0x52>
    1ef6:	60 c0       	rjmp	.+192    	; 0x1fb8 <V2P_GetSetParamater+0x112>
    1ef8:	12 c0       	rjmp	.+36     	; 0x1f1e <V2P_GetSetParamater+0x78>
    1efa:	81 e0       	ldi	r24, 0x01	; 1
    1efc:	80 93 93 01 	sts	0x0193, r24
    1f00:	64 c0       	rjmp	.+200    	; 0x1fca <V2P_GetSetParamater+0x124>
    1f02:	82 e0       	ldi	r24, 0x02	; 2
    1f04:	fb cf       	rjmp	.-10     	; 0x1efc <V2P_GetSetParamater+0x56>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1f06:	2a e8       	ldi	r18, 0x8A	; 138
    1f08:	30 e0       	ldi	r19, 0x00	; 0
    1f0a:	d9 01       	movw	r26, r18
    1f0c:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
    1f10:	80 2d       	mov	r24, r0
    1f12:	8f 3f       	cpi	r24, 0xFF	; 255
    1f14:	11 f4       	brne	.+4      	; 0x1f1a <V2P_GetSetParamater+0x74>
    1f16:	84 e0       	ldi	r24, 0x04	; 4
    1f18:	f1 cf       	rjmp	.-30     	; 0x1efc <V2P_GetSetParamater+0x56>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1f1a:	d9 01       	movw	r26, r18
    1f1c:	2c c0       	rjmp	.+88     	; 0x1f76 <V2P_GetSetParamater+0xd0>
    1f1e:	80 91 91 01 	lds	r24, 0x0191
    1f22:	83 30       	cpi	r24, 0x03	; 3
    1f24:	19 f4       	brne	.+6      	; 0x1f2c <V2P_GetSetParamater+0x86>
    1f26:	80 91 ad 02 	lds	r24, 0x02AD
    1f2a:	e8 cf       	rjmp	.-48     	; 0x1efc <V2P_GetSetParamater+0x56>
    1f2c:	82 e0       	ldi	r24, 0x02	; 2
    1f2e:	90 e0       	ldi	r25, 0x00	; 0
    1f30:	90 93 a7 02 	sts	0x02A7, r25
    1f34:	80 93 a6 02 	sts	0x02A6, r24
    1f38:	80 91 93 01 	lds	r24, 0x0193
    1f3c:	80 93 ad 02 	sts	0x02AD, r24
    1f40:	44 c0       	rjmp	.+136    	; 0x1fca <V2P_GetSetParamater+0x124>
    1f42:	80 91 91 01 	lds	r24, 0x0191
    1f46:	a2 e0       	ldi	r26, 0x02	; 2
    1f48:	b0 e0       	ldi	r27, 0x00	; 0
    1f4a:	83 30       	cpi	r24, 0x03	; 3
    1f4c:	a1 f0       	breq	.+40     	; 0x1f76 <V2P_GetSetParamater+0xd0>
    1f4e:	82 e0       	ldi	r24, 0x02	; 2
    1f50:	90 e0       	ldi	r25, 0x00	; 0
    1f52:	90 93 a7 02 	sts	0x02A7, r25
    1f56:	80 93 a6 02 	sts	0x02A6, r24

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    1f5a:	80 91 93 01 	lds	r24, 0x0193
    1f5e:	08 2e       	mov	r0, r24
    1f60:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
    1f64:	0e 94 14 0a 	call	0x1428	; 0x1428 <USI_SPISetSpeed>
    1f68:	30 c0       	rjmp	.+96     	; 0x1fca <V2P_GetSetParamater+0x124>
    1f6a:	80 91 91 01 	lds	r24, 0x0191
    1f6e:	a1 e0       	ldi	r26, 0x01	; 1
    1f70:	b0 e0       	ldi	r27, 0x00	; 0
    1f72:	83 30       	cpi	r24, 0x03	; 3
    1f74:	21 f4       	brne	.+8      	; 0x1f7e <V2P_GetSetParamater+0xd8>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1f76:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
    1f7a:	80 2d       	mov	r24, r0
    1f7c:	bf cf       	rjmp	.-130    	; 0x1efc <V2P_GetSetParamater+0x56>
    1f7e:	82 e0       	ldi	r24, 0x02	; 2
    1f80:	90 e0       	ldi	r25, 0x00	; 0
    1f82:	90 93 a7 02 	sts	0x02A7, r25
    1f86:	80 93 a6 02 	sts	0x02A6, r24

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    1f8a:	80 91 93 01 	lds	r24, 0x0193
    1f8e:	08 2e       	mov	r0, r24
    1f90:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
    1f94:	81 e0       	ldi	r24, 0x01	; 1
    1f96:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
    1f9a:	17 c0       	rjmp	.+46     	; 0x1fca <V2P_GetSetParamater+0x124>
    1f9c:	80 91 91 01 	lds	r24, 0x0191
    1fa0:	83 30       	cpi	r24, 0x03	; 3
    1fa2:	19 f4       	brne	.+6      	; 0x1faa <V2P_GetSetParamater+0x104>
    1fa4:	10 92 93 01 	sts	0x0193, r1
    1fa8:	10 c0       	rjmp	.+32     	; 0x1fca <V2P_GetSetParamater+0x124>
    1faa:	82 e0       	ldi	r24, 0x02	; 2
    1fac:	90 e0       	ldi	r25, 0x00	; 0
    1fae:	90 93 a7 02 	sts	0x02A7, r25
    1fb2:	80 93 a6 02 	sts	0x02A6, r24
    1fb6:	09 c0       	rjmp	.+18     	; 0x1fca <V2P_GetSetParamater+0x124>
    1fb8:	82 e0       	ldi	r24, 0x02	; 2
    1fba:	90 e0       	ldi	r25, 0x00	; 0
    1fbc:	90 93 a7 02 	sts	0x02A7, r25
    1fc0:	80 93 a6 02 	sts	0x02A6, r24
    1fc4:	80 ec       	ldi	r24, 0xC0	; 192
    1fc6:	80 93 92 01 	sts	0x0192, r24
    1fca:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <V2P_SendPacket>
    1fce:	08 95       	ret

00001fd0 <V2P_RunStateMachine>:
    1fd0:	cf 92       	push	r12
    1fd2:	df 92       	push	r13
    1fd4:	ef 92       	push	r14
    1fd6:	ff 92       	push	r15
    1fd8:	0f 93       	push	r16
    1fda:	1f 93       	push	r17
    1fdc:	cf 93       	push	r28
    1fde:	df 93       	push	r29
    1fe0:	6c 01       	movw	r12, r24
    1fe2:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <BUFF_InitialiseBuffer>
    1fe6:	10 92 81 00 	sts	0x0081, r1
    1fea:	10 92 a8 02 	sts	0x02A8, r1
    1fee:	10 92 a9 02 	sts	0x02A9, r1
    1ff2:	10 92 aa 02 	sts	0x02AA, r1
    1ff6:	10 92 ab 02 	sts	0x02AB, r1
    1ffa:	10 92 ac 02 	sts	0x02AC, r1
    1ffe:	10 e0       	ldi	r17, 0x00	; 0
    2000:	73 c0       	rjmp	.+230    	; 0x20e8 <V2P_RunStateMachine+0x118>
    2002:	12 e0       	ldi	r17, 0x02	; 2
    2004:	01 c0       	rjmp	.+2      	; 0x2008 <V2P_RunStateMachine+0x38>
    2006:	19 e0       	ldi	r17, 0x09	; 9
    2008:	80 91 8c 01 	lds	r24, 0x018C
    200c:	81 30       	cpi	r24, 0x01	; 1
    200e:	09 f4       	brne	.+2      	; 0x2012 <V2P_RunStateMachine+0x42>
    2010:	0e c1       	rjmp	.+540    	; 0x222e <V2P_RunStateMachine+0x25e>
    2012:	11 23       	and	r17, r17
    2014:	81 f1       	breq	.+96     	; 0x2076 <V2P_RunStateMachine+0xa6>
    2016:	10 92 8c 01 	sts	0x018C, r1
    201a:	10 92 8b 01 	sts	0x018B, r1
    201e:	10 92 b2 00 	sts	0x00B2, r1
    2022:	80 ef       	ldi	r24, 0xF0	; 240
    2024:	80 93 b3 00 	sts	0x00B3, r24
    2028:	82 e0       	ldi	r24, 0x02	; 2
    202a:	80 93 70 00 	sts	0x0070, r24
    202e:	8f e0       	ldi	r24, 0x0F	; 15
    2030:	80 93 b0 00 	sts	0x00B0, r24
    2034:	15 30       	cpi	r17, 0x05	; 5
    2036:	09 f4       	brne	.+2      	; 0x203a <V2P_RunStateMachine+0x6a>
    2038:	5a c0       	rjmp	.+180    	; 0x20ee <V2P_RunStateMachine+0x11e>
    203a:	16 30       	cpi	r17, 0x06	; 6
    203c:	70 f4       	brcc	.+28     	; 0x205a <V2P_RunStateMachine+0x8a>
    203e:	12 30       	cpi	r17, 0x02	; 2
    2040:	69 f1       	breq	.+90     	; 0x209c <V2P_RunStateMachine+0xcc>
    2042:	13 30       	cpi	r17, 0x03	; 3
    2044:	28 f4       	brcc	.+10     	; 0x2050 <V2P_RunStateMachine+0x80>
    2046:	11 23       	and	r17, r17
    2048:	b1 f0       	breq	.+44     	; 0x2076 <V2P_RunStateMachine+0xa6>
    204a:	11 30       	cpi	r17, 0x01	; 1
    204c:	e9 f6       	brne	.-70     	; 0x2008 <V2P_RunStateMachine+0x38>
    204e:	20 c0       	rjmp	.+64     	; 0x2090 <V2P_RunStateMachine+0xc0>
    2050:	13 30       	cpi	r17, 0x03	; 3
    2052:	69 f1       	breq	.+90     	; 0x20ae <V2P_RunStateMachine+0xde>
    2054:	14 30       	cpi	r17, 0x04	; 4
    2056:	c1 f6       	brne	.-80     	; 0x2008 <V2P_RunStateMachine+0x38>
    2058:	35 c0       	rjmp	.+106    	; 0x20c4 <V2P_RunStateMachine+0xf4>
    205a:	18 30       	cpi	r17, 0x08	; 8
    205c:	09 f4       	brne	.+2      	; 0x2060 <V2P_RunStateMachine+0x90>
    205e:	f4 c0       	rjmp	.+488    	; 0x2248 <V2P_RunStateMachine+0x278>
    2060:	19 30       	cpi	r17, 0x09	; 9
    2062:	30 f4       	brcc	.+12     	; 0x2070 <V2P_RunStateMachine+0xa0>
    2064:	16 30       	cpi	r17, 0x06	; 6
    2066:	09 f4       	brne	.+2      	; 0x206a <V2P_RunStateMachine+0x9a>
    2068:	49 c0       	rjmp	.+146    	; 0x20fc <V2P_RunStateMachine+0x12c>
    206a:	17 30       	cpi	r17, 0x07	; 7
    206c:	69 f6       	brne	.-102    	; 0x2008 <V2P_RunStateMachine+0x38>
    206e:	57 c0       	rjmp	.+174    	; 0x211e <V2P_RunStateMachine+0x14e>
    2070:	1c 30       	cpi	r17, 0x0C	; 12
    2072:	50 f6       	brcc	.-108    	; 0x2008 <V2P_RunStateMachine+0x38>
    2074:	d6 c0       	rjmp	.+428    	; 0x2222 <V2P_RunStateMachine+0x252>
    2076:	80 91 88 01 	lds	r24, 0x0188
    207a:	81 11       	cpse	r24, r1
    207c:	81 e0       	ldi	r24, 0x01	; 1
    207e:	18 2f       	mov	r17, r24
    2080:	f2 9b       	sbis	0x1e, 2	; 30
    2082:	c2 cf       	rjmp	.-124    	; 0x2008 <V2P_RunStateMachine+0x38>
    2084:	80 91 a8 02 	lds	r24, 0x02A8
    2088:	88 23       	and	r24, r24
    208a:	09 f0       	breq	.+2      	; 0x208e <V2P_RunStateMachine+0xbe>
    208c:	bd cf       	rjmp	.-134    	; 0x2008 <V2P_RunStateMachine+0x38>
    208e:	e6 c0       	rjmp	.+460    	; 0x225c <V2P_RunStateMachine+0x28c>
    2090:	0e 94 8f 09 	call	0x131e	; 0x131e <USART_Rx>
    2094:	8b 31       	cpi	r24, 0x1B	; 27
    2096:	09 f0       	breq	.+2      	; 0x209a <V2P_RunStateMachine+0xca>
    2098:	b6 cf       	rjmp	.-148    	; 0x2006 <V2P_RunStateMachine+0x36>
    209a:	b3 cf       	rjmp	.-154    	; 0x2002 <V2P_RunStateMachine+0x32>
    209c:	0e 94 8f 09 	call	0x131e	; 0x131e <USART_Rx>
    20a0:	99 27       	eor	r25, r25
    20a2:	90 93 a5 02 	sts	0x02A5, r25
    20a6:	80 93 a4 02 	sts	0x02A4, r24
    20aa:	13 e0       	ldi	r17, 0x03	; 3
    20ac:	ad cf       	rjmp	.-166    	; 0x2008 <V2P_RunStateMachine+0x38>
    20ae:	0e 94 8f 09 	call	0x131e	; 0x131e <USART_Rx>
    20b2:	99 27       	eor	r25, r25
    20b4:	98 2f       	mov	r25, r24
    20b6:	88 27       	eor	r24, r24
    20b8:	90 93 a7 02 	sts	0x02A7, r25
    20bc:	80 93 a6 02 	sts	0x02A6, r24
    20c0:	14 e0       	ldi	r17, 0x04	; 4
    20c2:	a2 cf       	rjmp	.-188    	; 0x2008 <V2P_RunStateMachine+0x38>
    20c4:	00 91 a6 02 	lds	r16, 0x02A6
    20c8:	10 91 a7 02 	lds	r17, 0x02A7
    20cc:	0e 94 8f 09 	call	0x131e	; 0x131e <USART_Rx>
    20d0:	99 27       	eor	r25, r25
    20d2:	80 2b       	or	r24, r16
    20d4:	91 2b       	or	r25, r17
    20d6:	90 93 a7 02 	sts	0x02A7, r25
    20da:	80 93 a6 02 	sts	0x02A6, r24
    20de:	83 51       	subi	r24, 0x13	; 19
    20e0:	91 40       	sbci	r25, 0x01	; 1
    20e2:	08 f0       	brcs	.+2      	; 0x20e6 <V2P_RunStateMachine+0x116>
    20e4:	90 cf       	rjmp	.-224    	; 0x2006 <V2P_RunStateMachine+0x36>
    20e6:	15 e0       	ldi	r17, 0x05	; 5
    20e8:	c0 e0       	ldi	r28, 0x00	; 0
    20ea:	d0 e0       	ldi	r29, 0x00	; 0
    20ec:	8d cf       	rjmp	.-230    	; 0x2008 <V2P_RunStateMachine+0x38>
    20ee:	0e 94 8f 09 	call	0x131e	; 0x131e <USART_Rx>
    20f2:	8e 30       	cpi	r24, 0x0E	; 14
    20f4:	09 f0       	breq	.+2      	; 0x20f8 <V2P_RunStateMachine+0x128>
    20f6:	87 cf       	rjmp	.-242    	; 0x2006 <V2P_RunStateMachine+0x36>
    20f8:	16 e0       	ldi	r17, 0x06	; 6
    20fa:	86 cf       	rjmp	.-244    	; 0x2008 <V2P_RunStateMachine+0x38>
    20fc:	80 91 a6 02 	lds	r24, 0x02A6
    2100:	90 91 a7 02 	lds	r25, 0x02A7
    2104:	c8 17       	cp	r28, r24
    2106:	d9 07       	cpc	r29, r25
    2108:	11 f4       	brne	.+4      	; 0x210e <V2P_RunStateMachine+0x13e>
    210a:	17 e0       	ldi	r17, 0x07	; 7
    210c:	7d cf       	rjmp	.-262    	; 0x2008 <V2P_RunStateMachine+0x38>
    210e:	0e 94 8f 09 	call	0x131e	; 0x131e <USART_Rx>
    2112:	fe 01       	movw	r30, r28
    2114:	ef 56       	subi	r30, 0x6F	; 111
    2116:	fe 4f       	sbci	r31, 0xFE	; 254
    2118:	80 83       	st	Z, r24
    211a:	21 96       	adiw	r28, 0x01	; 1
    211c:	75 cf       	rjmp	.-278    	; 0x2008 <V2P_RunStateMachine+0x38>
    211e:	80 91 8c 01 	lds	r24, 0x018C
    2122:	88 23       	and	r24, r24
    2124:	09 f0       	breq	.+2      	; 0x2128 <V2P_RunStateMachine+0x158>
    2126:	70 cf       	rjmp	.-288    	; 0x2008 <V2P_RunStateMachine+0x38>
    2128:	0e 94 bf 0e 	call	0x1d7e	; 0x1d7e <V2P_GetChecksum>
    212c:	18 2f       	mov	r17, r24
    212e:	0e 94 8f 09 	call	0x131e	; 0x131e <USART_Rx>
    2132:	18 17       	cp	r17, r24
    2134:	11 f0       	breq	.+4      	; 0x213a <V2P_RunStateMachine+0x16a>
    2136:	1b e0       	ldi	r17, 0x0B	; 11
    2138:	67 cf       	rjmp	.-306    	; 0x2008 <V2P_RunStateMachine+0x38>
    213a:	80 91 91 01 	lds	r24, 0x0191
    213e:	84 30       	cpi	r24, 0x04	; 4
    2140:	38 f4       	brcc	.+14     	; 0x2150 <V2P_RunStateMachine+0x180>
    2142:	82 30       	cpi	r24, 0x02	; 2
    2144:	08 f0       	brcs	.+2      	; 0x2148 <V2P_RunStateMachine+0x178>
    2146:	66 c0       	rjmp	.+204    	; 0x2214 <V2P_RunStateMachine+0x244>
    2148:	81 30       	cpi	r24, 0x01	; 1
    214a:	09 f0       	breq	.+2      	; 0x214e <V2P_RunStateMachine+0x17e>
    214c:	66 c0       	rjmp	.+204    	; 0x221a <V2P_RunStateMachine+0x24a>
    214e:	06 c0       	rjmp	.+12     	; 0x215c <V2P_RunStateMachine+0x18c>
    2150:	86 30       	cpi	r24, 0x06	; 6
    2152:	01 f1       	breq	.+64     	; 0x2194 <V2P_RunStateMachine+0x1c4>
    2154:	87 30       	cpi	r24, 0x07	; 7
    2156:	09 f0       	breq	.+2      	; 0x215a <V2P_RunStateMachine+0x18a>
    2158:	60 c0       	rjmp	.+192    	; 0x221a <V2P_RunStateMachine+0x24a>
    215a:	12 c0       	rjmp	.+36     	; 0x2180 <V2P_RunStateMachine+0x1b0>
    215c:	8b e0       	ldi	r24, 0x0B	; 11
    215e:	90 e0       	ldi	r25, 0x00	; 0
    2160:	90 93 a7 02 	sts	0x02A7, r25
    2164:	80 93 a6 02 	sts	0x02A6, r24
    2168:	ea e0       	ldi	r30, 0x0A	; 10
    216a:	f4 e0       	ldi	r31, 0x04	; 4
    216c:	a1 e9       	ldi	r26, 0x91	; 145
    216e:	b1 e0       	ldi	r27, 0x01	; 1
    2170:	84 91       	lpm	r24, Z
    2172:	8d 93       	st	X+, r24
    2174:	31 96       	adiw	r30, 0x01	; 1
    2176:	81 e0       	ldi	r24, 0x01	; 1
    2178:	ac 39       	cpi	r26, 0x9C	; 156
    217a:	b8 07       	cpc	r27, r24
    217c:	c9 f7       	brne	.-14     	; 0x2170 <V2P_RunStateMachine+0x1a0>
    217e:	47 c0       	rjmp	.+142    	; 0x220e <V2P_RunStateMachine+0x23e>
    2180:	82 e0       	ldi	r24, 0x02	; 2
    2182:	90 e0       	ldi	r25, 0x00	; 0
    2184:	90 93 a7 02 	sts	0x02A7, r25
    2188:	80 93 a6 02 	sts	0x02A6, r24
    218c:	80 ec       	ldi	r24, 0xC0	; 192
    218e:	80 93 92 01 	sts	0x0192, r24
    2192:	3d c0       	rjmp	.+122    	; 0x220e <V2P_RunStateMachine+0x23e>
    2194:	82 e0       	ldi	r24, 0x02	; 2
    2196:	90 e0       	ldi	r25, 0x00	; 0
    2198:	90 93 a7 02 	sts	0x02A7, r25
    219c:	80 93 a6 02 	sts	0x02A6, r24
    21a0:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <V2P_CheckForExtendedAddress>
    21a4:	e0 90 94 01 	lds	r14, 0x0194
    21a8:	ff 24       	eor	r15, r15
    21aa:	00 27       	eor	r16, r16
    21ac:	11 27       	eor	r17, r17
    21ae:	10 2f       	mov	r17, r16
    21b0:	0f 2d       	mov	r16, r15
    21b2:	fe 2c       	mov	r15, r14
    21b4:	ee 24       	eor	r14, r14
    21b6:	20 91 92 01 	lds	r18, 0x0192
    21ba:	33 27       	eor	r19, r19
    21bc:	44 27       	eor	r20, r20
    21be:	55 27       	eor	r21, r21
    21c0:	52 2f       	mov	r21, r18
    21c2:	44 27       	eor	r20, r20
    21c4:	33 27       	eor	r19, r19
    21c6:	22 27       	eor	r18, r18
    21c8:	80 91 93 01 	lds	r24, 0x0193
    21cc:	99 27       	eor	r25, r25
    21ce:	aa 27       	eor	r26, r26
    21d0:	bb 27       	eor	r27, r27
    21d2:	dc 01       	movw	r26, r24
    21d4:	99 27       	eor	r25, r25
    21d6:	88 27       	eor	r24, r24
    21d8:	28 2b       	or	r18, r24
    21da:	39 2b       	or	r19, r25
    21dc:	4a 2b       	or	r20, r26
    21de:	5b 2b       	or	r21, r27
    21e0:	80 91 95 01 	lds	r24, 0x0195
    21e4:	99 27       	eor	r25, r25
    21e6:	aa 27       	eor	r26, r26
    21e8:	bb 27       	eor	r27, r27
    21ea:	28 2b       	or	r18, r24
    21ec:	39 2b       	or	r19, r25
    21ee:	4a 2b       	or	r20, r26
    21f0:	5b 2b       	or	r21, r27
    21f2:	e2 2a       	or	r14, r18
    21f4:	f3 2a       	or	r15, r19
    21f6:	04 2b       	or	r16, r20
    21f8:	15 2b       	or	r17, r21
    21fa:	e0 92 a9 02 	sts	0x02A9, r14
    21fe:	f0 92 aa 02 	sts	0x02AA, r15
    2202:	00 93 ab 02 	sts	0x02AB, r16
    2206:	10 93 ac 02 	sts	0x02AC, r17
    220a:	10 92 92 01 	sts	0x0192, r1
    220e:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <V2P_SendPacket>
    2212:	05 c0       	rjmp	.+10     	; 0x221e <V2P_RunStateMachine+0x24e>
    2214:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <V2P_GetSetParamater>
    2218:	02 c0       	rjmp	.+4      	; 0x221e <V2P_RunStateMachine+0x24e>
    221a:	f6 01       	movw	r30, r12
    221c:	09 95       	icall
    221e:	18 e0       	ldi	r17, 0x08	; 8
    2220:	f3 ce       	rjmp	.-538    	; 0x2008 <V2P_RunStateMachine+0x38>
    2222:	1b 30       	cpi	r17, 0x0B	; 11
    2224:	11 f4       	brne	.+4      	; 0x222a <V2P_RunStateMachine+0x25a>
    2226:	81 ec       	ldi	r24, 0xC1	; 193
    2228:	05 c0       	rjmp	.+10     	; 0x2234 <V2P_RunStateMachine+0x264>
    222a:	1a 30       	cpi	r17, 0x0A	; 10
    222c:	11 f4       	brne	.+4      	; 0x2232 <V2P_RunStateMachine+0x262>
    222e:	80 e8       	ldi	r24, 0x80	; 128
    2230:	01 c0       	rjmp	.+2      	; 0x2234 <V2P_RunStateMachine+0x264>
    2232:	80 ec       	ldi	r24, 0xC0	; 192
    2234:	80 93 92 01 	sts	0x0192, r24
    2238:	82 e0       	ldi	r24, 0x02	; 2
    223a:	90 e0       	ldi	r25, 0x00	; 0
    223c:	90 93 a7 02 	sts	0x02A7, r25
    2240:	80 93 a6 02 	sts	0x02A6, r24
    2244:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <V2P_SendPacket>
    2248:	10 92 8c 01 	sts	0x018C, r1
    224c:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <BUFF_InitialiseBuffer>
    2250:	10 92 b0 00 	sts	0x00B0, r1
    2254:	10 92 70 00 	sts	0x0070, r1
    2258:	10 e0       	ldi	r17, 0x00	; 0
    225a:	d6 ce       	rjmp	.-596    	; 0x2008 <V2P_RunStateMachine+0x38>
    225c:	80 e8       	ldi	r24, 0x80	; 128
    225e:	80 93 61 00 	sts	0x0061, r24
    2262:	83 e0       	ldi	r24, 0x03	; 3
    2264:	80 93 61 00 	sts	0x0061, r24
    2268:	10 92 c1 00 	sts	0x00C1, r1
    226c:	0e 94 44 0c 	call	0x1888	; 0x1888 <TOUT_SetupSleepTimer>
    2270:	df 91       	pop	r29
    2272:	cf 91       	pop	r28
    2274:	1f 91       	pop	r17
    2276:	0f 91       	pop	r16
    2278:	ff 90       	pop	r15
    227a:	ef 90       	pop	r14
    227c:	df 90       	pop	r13
    227e:	cf 90       	pop	r12
    2280:	08 95       	ret

00002282 <ISPCC_PollForProgComplete>:
	}
}

void ISPCC_PollForProgComplete(const uint8_t PollData, uint16_t PollAddr)
{
    2282:	1f 93       	push	r17
    2284:	cf 93       	push	r28
    2286:	df 93       	push	r29
    2288:	eb 01       	movw	r28, r22
	uint8_t PollType;
	uint8_t ProgCommand;

	if (PollData & ISPCC_PROG_MODE_PAGE)
    228a:	99 27       	eor	r25, r25
    228c:	80 ff       	sbrs	r24, 0
    228e:	08 c0       	rjmp	.+16     	; 0x22a0 <ISPCC_PollForProgComplete+0x1e>
	   PollType = ((PollData & ISPCC_PAGE_POLLTYPE_MASK) >> ISPCC_PAGE_POLLTYPE_MASKSHIFT);
    2290:	80 77       	andi	r24, 0x70	; 112
    2292:	90 70       	andi	r25, 0x00	; 0
    2294:	34 e0       	ldi	r19, 0x04	; 4
    2296:	95 95       	asr	r25
    2298:	87 95       	ror	r24
    229a:	3a 95       	dec	r19
    229c:	e1 f7       	brne	.-8      	; 0x2296 <ISPCC_PollForProgComplete+0x14>
    229e:	04 c0       	rjmp	.+8      	; 0x22a8 <ISPCC_PollForProgComplete+0x26>
	else
	   PollType = ((PollData & ISPCC_WORD_POLLTYPE_MASK) >> ISPCC_WORD_POLLTYPE_MASKSHIFT);	
    22a0:	8e 70       	andi	r24, 0x0E	; 14
    22a2:	90 70       	andi	r25, 0x00	; 0
    22a4:	95 95       	asr	r25
    22a6:	87 95       	ror	r24

	switch (PollType & ISPCC_POLLTYPE_MASK)
    22a8:	99 27       	eor	r25, r25
    22aa:	87 70       	andi	r24, 0x07	; 7
    22ac:	90 70       	andi	r25, 0x00	; 0
    22ae:	82 30       	cpi	r24, 0x02	; 2
    22b0:	91 05       	cpc	r25, r1
    22b2:	19 f0       	breq	.+6      	; 0x22ba <ISPCC_PollForProgComplete+0x38>
    22b4:	04 97       	sbiw	r24, 0x04	; 4
    22b6:	41 f5       	brne	.+80     	; 0x2308 <ISPCC_PollForProgComplete+0x86>
    22b8:	1c c0       	rjmp	.+56     	; 0x22f2 <ISPCC_PollForProgComplete+0x70>
	{
		case ISPCC_POLLTYPE_DATA:
			ProgCommand = PacketBytes[7];
    22ba:	10 91 98 01 	lds	r17, 0x0198
			
			if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP) // Flash uses word addresses
    22be:	80 91 91 01 	lds	r24, 0x0191
    22c2:	83 31       	cpi	r24, 0x13	; 19
    22c4:	41 f4       	brne	.+16     	; 0x22d6 <ISPCC_PollForProgComplete+0x54>
			{
				ProgCommand  |= ((PollAddr & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ);
    22c6:	c0 ff       	sbrs	r28, 0
    22c8:	02 c0       	rjmp	.+4      	; 0x22ce <ISPCC_PollForProgComplete+0x4c>
    22ca:	88 e0       	ldi	r24, 0x08	; 8
    22cc:	01 c0       	rjmp	.+2      	; 0x22d0 <ISPCC_PollForProgComplete+0x4e>
    22ce:	80 e0       	ldi	r24, 0x00	; 0
    22d0:	18 2b       	or	r17, r24
				PollAddr    >>= 1;
    22d2:	d6 95       	lsr	r29
    22d4:	c7 95       	ror	r28
			}

			do
			{
				USI_SPITransmit(ProgCommand);
    22d6:	81 2f       	mov	r24, r17
    22d8:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
				USI_SPITransmitWord(PollAddr);
    22dc:	ce 01       	movw	r24, r28
    22de:	0e 94 06 0a 	call	0x140c	; 0x140c <USI_SPITransmitWord>
			}
			while (USI_SPITransmit(0x00) == PacketBytes[8]);
    22e2:	80 e0       	ldi	r24, 0x00	; 0
    22e4:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    22e8:	90 91 99 01 	lds	r25, 0x0199
    22ec:	89 17       	cp	r24, r25
    22ee:	81 f4       	brne	.+32     	; 0x2310 <ISPCC_PollForProgComplete+0x8e>
    22f0:	f2 cf       	rjmp	.-28     	; 0x22d6 <ISPCC_PollForProgComplete+0x54>
						
			break;
		case ISPCC_POLLTYPE_READY:
			do
			   USI_SPITransmitWord(0xF000);
    22f2:	80 e0       	ldi	r24, 0x00	; 0
    22f4:	90 ef       	ldi	r25, 0xF0	; 240
    22f6:	0e 94 06 0a 	call	0x140c	; 0x140c <USI_SPITransmitWord>
			while (USI_SPITransmitWord(0x0000) & ISPCC_POLL_BUSYFLAG);
    22fa:	80 e0       	ldi	r24, 0x00	; 0
    22fc:	90 e0       	ldi	r25, 0x00	; 0
    22fe:	0e 94 06 0a 	call	0x140c	; 0x140c <USI_SPITransmitWord>
    2302:	80 ff       	sbrs	r24, 0
    2304:	05 c0       	rjmp	.+10     	; 0x2310 <ISPCC_PollForProgComplete+0x8e>
    2306:	f5 cf       	rjmp	.-22     	; 0x22f2 <ISPCC_PollForProgComplete+0x70>

			break;
		default:                                      // Default is Wait polling
			MAIN_Delay1MS(PacketBytes[4]);	
    2308:	80 91 95 01 	lds	r24, 0x0195
    230c:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2310:	df 91       	pop	r29
    2312:	cf 91       	pop	r28
    2314:	1f 91       	pop	r17
    2316:	08 95       	ret

00002318 <ISPCC_ProgramChip>:
    2318:	4f 92       	push	r4
    231a:	5f 92       	push	r5
    231c:	6f 92       	push	r6
    231e:	7f 92       	push	r7
    2320:	8f 92       	push	r8
    2322:	9f 92       	push	r9
    2324:	af 92       	push	r10
    2326:	bf 92       	push	r11
    2328:	cf 92       	push	r12
    232a:	df 92       	push	r13
    232c:	ef 92       	push	r14
    232e:	ff 92       	push	r15
    2330:	0f 93       	push	r16
    2332:	1f 93       	push	r17
    2334:	cf 93       	push	r28
    2336:	df 93       	push	r29
    2338:	b0 90 94 01 	lds	r11, 0x0194
    233c:	a0 90 96 01 	lds	r10, 0x0196
    2340:	40 90 a9 02 	lds	r4, 0x02A9
    2344:	50 90 aa 02 	lds	r5, 0x02AA
    2348:	60 90 ab 02 	lds	r6, 0x02AB
    234c:	70 90 ac 02 	lds	r7, 0x02AC
    2350:	80 91 92 01 	lds	r24, 0x0192
    2354:	99 27       	eor	r25, r25
    2356:	98 2e       	mov	r9, r24
    2358:	88 24       	eor	r8, r8
    235a:	80 91 93 01 	lds	r24, 0x0193
    235e:	99 27       	eor	r25, r25
    2360:	88 2a       	or	r8, r24
    2362:	99 2a       	or	r9, r25
    2364:	e0 90 91 01 	lds	r14, 0x0191
    2368:	b0 fc       	sbrc	r11, 0
    236a:	09 c0       	rjmp	.+18     	; 0x237e <ISPCC_ProgramChip+0x66>
    236c:	c0 e0       	ldi	r28, 0x00	; 0
    236e:	d0 e0       	ldi	r29, 0x00	; 0
    2370:	cc 24       	eor	r12, r12
    2372:	dd 24       	eor	r13, r13
    2374:	7b e9       	ldi	r23, 0x9B	; 155
    2376:	67 2e       	mov	r6, r23
    2378:	71 e0       	ldi	r23, 0x01	; 1
    237a:	77 2e       	mov	r7, r23
    237c:	ac c0       	rjmp	.+344    	; 0x24d6 <ISPCC_ProgramChip+0x1be>
    237e:	c0 e0       	ldi	r28, 0x00	; 0
    2380:	d0 e0       	ldi	r29, 0x00	; 0
    2382:	00 e0       	ldi	r16, 0x00	; 0
    2384:	10 e0       	ldi	r17, 0x00	; 0
    2386:	6b e9       	ldi	r22, 0x9B	; 155
    2388:	c6 2e       	mov	r12, r22
    238a:	61 e0       	ldi	r22, 0x01	; 1
    238c:	d6 2e       	mov	r13, r22
    238e:	41 c0       	rjmp	.+130    	; 0x2412 <ISPCC_ProgramChip+0xfa>
    2390:	f6 01       	movw	r30, r12
    2392:	f0 80       	ld	r15, Z
    2394:	f3 e1       	ldi	r31, 0x13	; 19
    2396:	ef 16       	cp	r14, r31
    2398:	39 f4       	brne	.+14     	; 0x23a8 <ISPCC_ProgramChip+0x90>
    239a:	00 ff       	sbrs	r16, 0
    239c:	02 c0       	rjmp	.+4      	; 0x23a2 <ISPCC_ProgramChip+0x8a>
    239e:	88 e0       	ldi	r24, 0x08	; 8
    23a0:	01 c0       	rjmp	.+2      	; 0x23a4 <ISPCC_ProgramChip+0x8c>
    23a2:	80 e0       	ldi	r24, 0x00	; 0
    23a4:	8a 29       	or	r24, r10
    23a6:	01 c0       	rjmp	.+2      	; 0x23aa <ISPCC_ProgramChip+0x92>
    23a8:	8a 2d       	mov	r24, r10
    23aa:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    23ae:	80 91 a9 02 	lds	r24, 0x02A9
    23b2:	90 91 aa 02 	lds	r25, 0x02AA
    23b6:	0e 94 06 0a 	call	0x140c	; 0x140c <USI_SPITransmitWord>
    23ba:	8f 2d       	mov	r24, r15
    23bc:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    23c0:	20 97       	sbiw	r28, 0x00	; 0
    23c2:	d9 f4       	brne	.+54     	; 0x23fa <ISPCC_ProgramChip+0xe2>
    23c4:	80 91 99 01 	lds	r24, 0x0199
    23c8:	8f 15       	cp	r24, r15
    23ca:	b9 f0       	breq	.+46     	; 0x23fa <ISPCC_ProgramChip+0xe2>
    23cc:	83 e1       	ldi	r24, 0x13	; 19
    23ce:	e8 16       	cp	r14, r24
    23d0:	49 f0       	breq	.+18     	; 0x23e4 <ISPCC_ProgramChip+0xcc>
    23d2:	e5 e1       	ldi	r30, 0x15	; 21
    23d4:	ee 16       	cp	r14, r30
    23d6:	89 f4       	brne	.+34     	; 0x23fa <ISPCC_ProgramChip+0xe2>
    23d8:	80 91 9a 01 	lds	r24, 0x019A
    23dc:	8f 15       	cp	r24, r15
    23de:	09 f0       	breq	.+2      	; 0x23e2 <ISPCC_ProgramChip+0xca>
    23e0:	7f c0       	rjmp	.+254    	; 0x24e0 <ISPCC_ProgramChip+0x1c8>
    23e2:	0b c0       	rjmp	.+22     	; 0x23fa <ISPCC_ProgramChip+0xe2>
    23e4:	c0 91 a9 02 	lds	r28, 0x02A9
    23e8:	d0 91 aa 02 	lds	r29, 0x02AA
    23ec:	cc 0f       	add	r28, r28
    23ee:	dd 1f       	adc	r29, r29
    23f0:	c8 01       	movw	r24, r16
    23f2:	81 70       	andi	r24, 0x01	; 1
    23f4:	90 70       	andi	r25, 0x00	; 0
    23f6:	c8 0f       	add	r28, r24
    23f8:	d9 1f       	adc	r29, r25
    23fa:	00 fd       	sbrc	r16, 0
    23fc:	03 c0       	rjmp	.+6      	; 0x2404 <ISPCC_ProgramChip+0xec>
    23fe:	f5 e1       	ldi	r31, 0x15	; 21
    2400:	ef 16       	cp	r14, r31
    2402:	11 f4       	brne	.+4      	; 0x2408 <ISPCC_ProgramChip+0xf0>
    2404:	0e 94 dc 0e 	call	0x1db8	; 0x1db8 <V2P_IncrementCurrAddress>
    2408:	0f 5f       	subi	r16, 0xFF	; 255
    240a:	1f 4f       	sbci	r17, 0xFF	; 255
    240c:	08 94       	sec
    240e:	c1 1c       	adc	r12, r1
    2410:	d1 1c       	adc	r13, r1
    2412:	08 15       	cp	r16, r8
    2414:	19 05       	cpc	r17, r9
    2416:	09 f0       	breq	.+2      	; 0x241a <ISPCC_ProgramChip+0x102>
    2418:	bb cf       	rjmp	.-138    	; 0x2390 <ISPCC_ProgramChip+0x78>
    241a:	b7 fe       	sbrs	r11, 7
    241c:	6c c0       	rjmp	.+216    	; 0x24f6 <ISPCC_ProgramChip+0x1de>
    241e:	80 91 97 01 	lds	r24, 0x0197
    2422:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    2426:	c2 01       	movw	r24, r4
    2428:	0e 94 06 0a 	call	0x140c	; 0x140c <USI_SPITransmitWord>
    242c:	80 e0       	ldi	r24, 0x00	; 0
    242e:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    2432:	20 97       	sbiw	r28, 0x00	; 0
    2434:	11 f0       	breq	.+4      	; 0x243a <ISPCC_ProgramChip+0x122>
    2436:	8b 2d       	mov	r24, r11
    2438:	03 c0       	rjmp	.+6      	; 0x2440 <ISPCC_ProgramChip+0x128>
    243a:	8b 2d       	mov	r24, r11
    243c:	8f 78       	andi	r24, 0x8F	; 143
    243e:	80 61       	ori	r24, 0x10	; 16
    2440:	be 01       	movw	r22, r28
    2442:	0e 94 41 11 	call	0x2282	; 0x2282 <ISPCC_PollForProgComplete>
    2446:	57 c0       	rjmp	.+174    	; 0x24f6 <ISPCC_ProgramChip+0x1de>
    2448:	f3 01       	movw	r30, r6
    244a:	10 81       	ld	r17, Z
    244c:	f3 e1       	ldi	r31, 0x13	; 19
    244e:	ef 16       	cp	r14, r31
    2450:	39 f4       	brne	.+14     	; 0x2460 <ISPCC_ProgramChip+0x148>
    2452:	c0 fe       	sbrs	r12, 0
    2454:	02 c0       	rjmp	.+4      	; 0x245a <ISPCC_ProgramChip+0x142>
    2456:	88 e0       	ldi	r24, 0x08	; 8
    2458:	01 c0       	rjmp	.+2      	; 0x245c <ISPCC_ProgramChip+0x144>
    245a:	80 e0       	ldi	r24, 0x00	; 0
    245c:	8a 29       	or	r24, r10
    245e:	01 c0       	rjmp	.+2      	; 0x2462 <ISPCC_ProgramChip+0x14a>
    2460:	8a 2d       	mov	r24, r10
    2462:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    2466:	80 91 a9 02 	lds	r24, 0x02A9
    246a:	90 91 aa 02 	lds	r25, 0x02AA
    246e:	0e 94 06 0a 	call	0x140c	; 0x140c <USI_SPITransmitWord>
    2472:	81 2f       	mov	r24, r17
    2474:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    2478:	80 91 99 01 	lds	r24, 0x0199
    247c:	81 17       	cp	r24, r17
    247e:	b9 f0       	breq	.+46     	; 0x24ae <ISPCC_ProgramChip+0x196>
    2480:	83 e1       	ldi	r24, 0x13	; 19
    2482:	e8 16       	cp	r14, r24
    2484:	41 f0       	breq	.+16     	; 0x2496 <ISPCC_ProgramChip+0x17e>
    2486:	e5 e1       	ldi	r30, 0x15	; 21
    2488:	ee 16       	cp	r14, r30
    248a:	89 f4       	brne	.+34     	; 0x24ae <ISPCC_ProgramChip+0x196>
    248c:	80 91 9a 01 	lds	r24, 0x019A
    2490:	81 17       	cp	r24, r17
    2492:	59 f5       	brne	.+86     	; 0x24ea <ISPCC_ProgramChip+0x1d2>
    2494:	0c c0       	rjmp	.+24     	; 0x24ae <ISPCC_ProgramChip+0x196>
    2496:	c0 91 a9 02 	lds	r28, 0x02A9
    249a:	d0 91 aa 02 	lds	r29, 0x02AA
    249e:	cc 0f       	add	r28, r28
    24a0:	dd 1f       	adc	r29, r29
    24a2:	c6 01       	movw	r24, r12
    24a4:	81 70       	andi	r24, 0x01	; 1
    24a6:	90 70       	andi	r25, 0x00	; 0
    24a8:	c8 0f       	add	r28, r24
    24aa:	d9 1f       	adc	r29, r25
    24ac:	22 c0       	rjmp	.+68     	; 0x24f2 <ISPCC_ProgramChip+0x1da>
    24ae:	1b 2d       	mov	r17, r11
    24b0:	11 7f       	andi	r17, 0xF1	; 241
    24b2:	12 60       	ori	r17, 0x02	; 2
    24b4:	c0 fc       	sbrc	r12, 0
    24b6:	03 c0       	rjmp	.+6      	; 0x24be <ISPCC_ProgramChip+0x1a6>
    24b8:	f5 e1       	ldi	r31, 0x15	; 21
    24ba:	ef 16       	cp	r14, r31
    24bc:	11 f4       	brne	.+4      	; 0x24c2 <ISPCC_ProgramChip+0x1aa>
    24be:	0e 94 dc 0e 	call	0x1db8	; 0x1db8 <V2P_IncrementCurrAddress>
    24c2:	be 01       	movw	r22, r28
    24c4:	81 2f       	mov	r24, r17
    24c6:	0e 94 41 11 	call	0x2282	; 0x2282 <ISPCC_PollForProgComplete>
    24ca:	08 94       	sec
    24cc:	c1 1c       	adc	r12, r1
    24ce:	d1 1c       	adc	r13, r1
    24d0:	08 94       	sec
    24d2:	61 1c       	adc	r6, r1
    24d4:	71 1c       	adc	r7, r1
    24d6:	c8 14       	cp	r12, r8
    24d8:	d9 04       	cpc	r13, r9
    24da:	09 f0       	breq	.+2      	; 0x24de <ISPCC_ProgramChip+0x1c6>
    24dc:	b5 cf       	rjmp	.-150    	; 0x2448 <ISPCC_ProgramChip+0x130>
    24de:	0b c0       	rjmp	.+22     	; 0x24f6 <ISPCC_ProgramChip+0x1de>
    24e0:	c0 91 a9 02 	lds	r28, 0x02A9
    24e4:	d0 91 aa 02 	lds	r29, 0x02AA
    24e8:	88 cf       	rjmp	.-240    	; 0x23fa <ISPCC_ProgramChip+0xe2>
    24ea:	c0 91 a9 02 	lds	r28, 0x02A9
    24ee:	d0 91 aa 02 	lds	r29, 0x02AA
    24f2:	1b 2d       	mov	r17, r11
    24f4:	df cf       	rjmp	.-66     	; 0x24b4 <ISPCC_ProgramChip+0x19c>
    24f6:	df 91       	pop	r29
    24f8:	cf 91       	pop	r28
    24fa:	1f 91       	pop	r17
    24fc:	0f 91       	pop	r16
    24fe:	ff 90       	pop	r15
    2500:	ef 90       	pop	r14
    2502:	df 90       	pop	r13
    2504:	cf 90       	pop	r12
    2506:	bf 90       	pop	r11
    2508:	af 90       	pop	r10
    250a:	9f 90       	pop	r9
    250c:	8f 90       	pop	r8
    250e:	7f 90       	pop	r7
    2510:	6f 90       	pop	r6
    2512:	5f 90       	pop	r5
    2514:	4f 90       	pop	r4
    2516:	08 95       	ret

00002518 <ISPCC_EnterChipProgrammingMode>:
    2518:	ff 92       	push	r15
    251a:	0f 93       	push	r16
    251c:	1f 93       	push	r17
    251e:	00 91 96 01 	lds	r16, 0x0196
    2522:	10 91 95 01 	lds	r17, 0x0195
    2526:	81 b3       	in	r24, 0x11	; 17
    2528:	8f 7c       	andi	r24, 0xCF	; 207
    252a:	80 63       	ori	r24, 0x30	; 48
    252c:	81 bb       	out	0x11, r24	; 17
    252e:	80 91 93 01 	lds	r24, 0x0193
    2532:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2536:	81 2f       	mov	r24, r17
    2538:	81 50       	subi	r24, 0x01	; 1
    253a:	84 36       	cpi	r24, 0x64	; 100
    253c:	08 f4       	brcc	.+2      	; 0x2540 <ISPCC_EnterChipProgrammingMode+0x28>
    253e:	40 c0       	rjmp	.+128    	; 0x25c0 <ISPCC_EnterChipProgrammingMode+0xa8>
    2540:	18 e1       	ldi	r17, 0x18	; 24
    2542:	3e c0       	rjmp	.+124    	; 0x25c0 <ISPCC_EnterChipProgrammingMode+0xa8>
    2544:	80 91 99 01 	lds	r24, 0x0199
    2548:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    254c:	80 2f       	mov	r24, r16
    254e:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2552:	80 91 9a 01 	lds	r24, 0x019A
    2556:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    255a:	80 2f       	mov	r24, r16
    255c:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2560:	80 91 9b 01 	lds	r24, 0x019B
    2564:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    2568:	f8 2e       	mov	r15, r24
    256a:	80 2f       	mov	r24, r16
    256c:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2570:	80 91 98 01 	lds	r24, 0x0198
    2574:	83 30       	cpi	r24, 0x03	; 3
    2576:	29 f4       	brne	.+10     	; 0x2582 <ISPCC_EnterChipProgrammingMode+0x6a>
    2578:	80 91 9c 01 	lds	r24, 0x019C
    257c:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    2580:	05 c0       	rjmp	.+10     	; 0x258c <ISPCC_EnterChipProgrammingMode+0x74>
    2582:	80 91 9c 01 	lds	r24, 0x019C
    2586:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    258a:	f8 2e       	mov	r15, r24
    258c:	80 91 98 01 	lds	r24, 0x0198
    2590:	88 23       	and	r24, r24
    2592:	21 f0       	breq	.+8      	; 0x259c <ISPCC_EnterChipProgrammingMode+0x84>
    2594:	80 91 97 01 	lds	r24, 0x0197
    2598:	f8 16       	cp	r15, r24
    259a:	69 f4       	brne	.+26     	; 0x25b6 <ISPCC_EnterChipProgrammingMode+0x9e>
    259c:	80 2f       	mov	r24, r16
    259e:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    25a2:	81 e0       	ldi	r24, 0x01	; 1
    25a4:	80 93 a8 02 	sts	0x02A8, r24
    25a8:	81 b3       	in	r24, 0x11	; 17
    25aa:	8f 7c       	andi	r24, 0xCF	; 207
    25ac:	80 62       	ori	r24, 0x20	; 32
    25ae:	81 bb       	out	0x11, r24	; 17
    25b0:	10 92 92 01 	sts	0x0192, r1
    25b4:	0e c0       	rjmp	.+28     	; 0x25d2 <ISPCC_EnterChipProgrammingMode+0xba>
    25b6:	80 2f       	mov	r24, r16
    25b8:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    25bc:	0e 94 42 0a 	call	0x1484	; 0x1484 <USI_SPIToggleClock>
    25c0:	11 50       	subi	r17, 0x01	; 1
    25c2:	00 f6       	brcc	.-128    	; 0x2544 <ISPCC_EnterChipProgrammingMode+0x2c>
    25c4:	81 b3       	in	r24, 0x11	; 17
    25c6:	8f 7c       	andi	r24, 0xCF	; 207
    25c8:	80 61       	ori	r24, 0x10	; 16
    25ca:	81 bb       	out	0x11, r24	; 17
    25cc:	80 ec       	ldi	r24, 0xC0	; 192
    25ce:	80 93 92 01 	sts	0x0192, r24
    25d2:	1f 91       	pop	r17
    25d4:	0f 91       	pop	r16
    25d6:	ff 90       	pop	r15
    25d8:	08 95       	ret

000025da <AICI_InterpretPacket>:

// ======================================================================================

void AICI_InterpretPacket(void)
{
    25da:	df 92       	push	r13
    25dc:	ef 92       	push	r14
    25de:	ff 92       	push	r15
    25e0:	0f 93       	push	r16
    25e2:	1f 93       	push	r17
    25e4:	cf 93       	push	r28
    25e6:	df 93       	push	r29
	switch (PacketBytes[0])
    25e8:	80 91 91 01 	lds	r24, 0x0191
    25ec:	86 31       	cpi	r24, 0x16	; 22
    25ee:	09 f4       	brne	.+2      	; 0x25f2 <AICI_InterpretPacket+0x18>
    25f0:	e5 c0       	rjmp	.+458    	; 0x27bc <AICI_InterpretPacket+0x1e2>
    25f2:	87 31       	cpi	r24, 0x17	; 23
    25f4:	78 f4       	brcc	.+30     	; 0x2614 <AICI_InterpretPacket+0x3a>
    25f6:	82 31       	cpi	r24, 0x12	; 18
    25f8:	09 f4       	brne	.+2      	; 0x25fc <AICI_InterpretPacket+0x22>
    25fa:	52 c0       	rjmp	.+164    	; 0x26a0 <AICI_InterpretPacket+0xc6>
    25fc:	83 31       	cpi	r24, 0x13	; 19
    25fe:	30 f4       	brcc	.+12     	; 0x260c <AICI_InterpretPacket+0x32>
    2600:	80 31       	cpi	r24, 0x10	; 16
    2602:	d9 f0       	breq	.+54     	; 0x263a <AICI_InterpretPacket+0x60>
    2604:	81 31       	cpi	r24, 0x11	; 17
    2606:	09 f0       	breq	.+2      	; 0x260a <AICI_InterpretPacket+0x30>
    2608:	2c c1       	rjmp	.+600    	; 0x2862 <AICI_InterpretPacket+0x288>
    260a:	30 c0       	rjmp	.+96     	; 0x266c <AICI_InterpretPacket+0x92>
    260c:	84 31       	cpi	r24, 0x14	; 20
    260e:	09 f0       	breq	.+2      	; 0x2612 <AICI_InterpretPacket+0x38>
    2610:	1d c1       	rjmp	.+570    	; 0x284c <AICI_InterpretPacket+0x272>
    2612:	d4 c0       	rjmp	.+424    	; 0x27bc <AICI_InterpretPacket+0x1e2>
    2614:	89 31       	cpi	r24, 0x19	; 25
    2616:	09 f4       	brne	.+2      	; 0x261a <AICI_InterpretPacket+0x40>
    2618:	bd c0       	rjmp	.+378    	; 0x2794 <AICI_InterpretPacket+0x1ba>
    261a:	8a 31       	cpi	r24, 0x1A	; 26
    261c:	38 f4       	brcc	.+14     	; 0x262c <AICI_InterpretPacket+0x52>
    261e:	87 31       	cpi	r24, 0x17	; 23
    2620:	09 f4       	brne	.+2      	; 0x2624 <AICI_InterpretPacket+0x4a>
    2622:	b8 c0       	rjmp	.+368    	; 0x2794 <AICI_InterpretPacket+0x1ba>
    2624:	88 31       	cpi	r24, 0x18	; 24
    2626:	09 f0       	breq	.+2      	; 0x262a <AICI_InterpretPacket+0x50>
    2628:	1c c1       	rjmp	.+568    	; 0x2862 <AICI_InterpretPacket+0x288>
    262a:	95 c0       	rjmp	.+298    	; 0x2756 <AICI_InterpretPacket+0x17c>
    262c:	8d 31       	cpi	r24, 0x1D	; 29
    262e:	08 f4       	brcc	.+2      	; 0x2632 <AICI_InterpretPacket+0x58>
    2630:	92 c0       	rjmp	.+292    	; 0x2756 <AICI_InterpretPacket+0x17c>
    2632:	8d 31       	cpi	r24, 0x1D	; 29
    2634:	09 f0       	breq	.+2      	; 0x2638 <AICI_InterpretPacket+0x5e>
    2636:	15 c1       	rjmp	.+554    	; 0x2862 <AICI_InterpretPacket+0x288>
    2638:	56 c0       	rjmp	.+172    	; 0x26e6 <AICI_InterpretPacket+0x10c>
	{
		case AICB_CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
    263a:	82 e0       	ldi	r24, 0x02	; 2
    263c:	90 e0       	ldi	r25, 0x00	; 0
    263e:	90 93 a7 02 	sts	0x02A7, r25
    2642:	80 93 a6 02 	sts	0x02A6, r24
			
			USI_SPIInitMaster();
    2646:	0e 94 32 0a 	call	0x1464	; 0x1464 <USI_SPIInitMaster>

			MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);  // Pull the slave AVR's RESET line to active
    264a:	80 e0       	ldi	r24, 0x00	; 0
    264c:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
			ISPCC_EnterChipProgrammingMode();       // Run the Enter Programming Mode routine
    2650:	0e 94 8c 12 	call	0x2518	; 0x2518 <ISPCC_EnterChipProgrammingMode>

			if (InProgrammingMode)
    2654:	80 91 a8 02 	lds	r24, 0x02A8
    2658:	88 23       	and	r24, r24
    265a:	19 f0       	breq	.+6      	; 0x2662 <AICI_InterpretPacket+0x88>
			   LCD_puts_f(AVRISPModeMessage);
    265c:	86 e3       	ldi	r24, 0x36	; 54
    265e:	94 e0       	ldi	r25, 0x04	; 4
    2660:	02 c0       	rjmp	.+4      	; 0x2666 <AICI_InterpretPacket+0x8c>
			else
			   LCD_puts_f(SyncErrorMessage);
    2662:	8b e2       	ldi	r24, 0x2B	; 43
    2664:	94 e0       	ldi	r25, 0x04	; 4
    2666:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
    266a:	04 c1       	rjmp	.+520    	; 0x2874 <AICI_InterpretPacket+0x29a>
			
			break;
		case AICB_CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;
    266c:	82 e0       	ldi	r24, 0x02	; 2
    266e:	90 e0       	ldi	r25, 0x00	; 0
    2670:	90 93 a7 02 	sts	0x02A7, r25
    2674:	80 93 a6 02 	sts	0x02A6, r24

			MAIN_Delay1MS(PacketBytes[1]);           // Wait for the "PreDelay" amount specified in the packet
    2678:	80 91 92 01 	lds	r24, 0x0192
    267c:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Non programming mode = green status led
    2680:	81 b3       	in	r24, 0x11	; 17
    2682:	8f 7c       	andi	r24, 0xCF	; 207
    2684:	80 61       	ori	r24, 0x10	; 16
    2686:	81 bb       	out	0x11, r24	; 17
			InProgrammingMode = FALSE;
    2688:	10 92 a8 02 	sts	0x02A8, r1
			MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run
    268c:	81 e0       	ldi	r24, 0x01	; 1
    268e:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
			MAIN_Delay1MS(PacketBytes[2]);           // Wait for the "PostDelay" amount specified in the packet
    2692:	80 91 93 01 	lds	r24, 0x0193
    2696:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
			
			USI_SPIOff();
    269a:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <USI_SPIOff>
    269e:	de c0       	rjmp	.+444    	; 0x285c <AICI_InterpretPacket+0x282>

			PacketBytes[1] = AICB_STATUS_CMD_OK;     // Return OK

			break;
		case AICB_CMD_CHIP_ERASE_ISP:
			MessageSize = 2;
    26a0:	82 e0       	ldi	r24, 0x02	; 2
    26a2:	90 e0       	ldi	r25, 0x00	; 0
    26a4:	90 93 a7 02 	sts	0x02A7, r25
    26a8:	80 93 a6 02 	sts	0x02A6, r24
    26ac:	c4 e9       	ldi	r28, 0x94	; 148
    26ae:	d1 e0       	ldi	r29, 0x01	; 1
			
			for (uint8_t PacketB = 3; PacketB <= 6; PacketB++) // Send the erase commands to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    26b0:	89 91       	ld	r24, Y+
    26b2:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    26b6:	81 e0       	ldi	r24, 0x01	; 1
    26b8:	c8 39       	cpi	r28, 0x98	; 152
    26ba:	d8 07       	cpc	r29, r24
    26bc:	c9 f7       	brne	.-14     	; 0x26b0 <AICI_InterpretPacket+0xd6>

			if (PacketBytes[2])                       // Poll mode, value of 1 indicates a busy flag wait
    26be:	80 91 93 01 	lds	r24, 0x0193
    26c2:	88 23       	and	r24, r24
    26c4:	59 f0       	breq	.+22     	; 0x26dc <AICI_InterpretPacket+0x102>
			{
				do
					USI_SPITransmitWord(0xF000);
    26c6:	80 e0       	ldi	r24, 0x00	; 0
    26c8:	90 ef       	ldi	r25, 0xF0	; 240
    26ca:	0e 94 06 0a 	call	0x140c	; 0x140c <USI_SPITransmitWord>
				while (USI_SPITransmitWord(0x0000) & 0x01);
    26ce:	80 e0       	ldi	r24, 0x00	; 0
    26d0:	90 e0       	ldi	r25, 0x00	; 0
    26d2:	0e 94 06 0a 	call	0x140c	; 0x140c <USI_SPITransmitWord>
    26d6:	80 ff       	sbrs	r24, 0
    26d8:	c1 c0       	rjmp	.+386    	; 0x285c <AICI_InterpretPacket+0x282>
    26da:	f5 cf       	rjmp	.-22     	; 0x26c6 <AICI_InterpretPacket+0xec>
			}
			else                                      // Poll mode flag of 0 indicates a predefined delay
			{
				MAIN_Delay1MS(PacketBytes[1]);         // Wait the specified interval to ensure erase complete
    26dc:	80 91 92 01 	lds	r24, 0x0192
    26e0:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    26e4:	bb c0       	rjmp	.+374    	; 0x285c <AICI_InterpretPacket+0x282>
			}
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Always return OK
			
			break;
		case AICB_CMD_SPI_MULTI:
				MessageSize = (3 + PacketBytes[2]);    // Number of recieved bytes, plus two OKs and the command byte
    26e6:	f0 90 93 01 	lds	r15, 0x0193
    26ea:	8f 2d       	mov	r24, r15
    26ec:	99 27       	eor	r25, r25
    26ee:	03 96       	adiw	r24, 0x03	; 3
    26f0:	90 93 a7 02 	sts	0x02A7, r25
    26f4:	80 93 a6 02 	sts	0x02A6, r24
		
				uint8_t TxBytes      = PacketBytes[1]; // \. The packet data is overwritten during the transfer. Because
    26f8:	d0 90 92 01 	lds	r13, 0x0192
				uint8_t RxStartByte  = PacketBytes[2]; // |  of this each data byte must be stored into temp variables
				uint8_t RxBytes      = PacketBytes[3]; // /  so that their contents are not lost.
    26fc:	e0 90 94 01 	lds	r14, 0x0194
    2700:	11 e0       	ldi	r17, 0x01	; 1
    2702:	01 e0       	ldi	r16, 0x01	; 1
    2704:	12 c0       	rjmp	.+36     	; 0x272a <AICI_InterpretPacket+0x150>
				uint8_t RxByteNum    = 1;
				uint8_t TxByteNum    = 1;
				uint8_t RecievedByte = 0;

				while (TxByteNum++ < TxBytes)          // Still bytes to transfer
    2706:	0f 5f       	subi	r16, 0xFF	; 255
				{
					RecievedByte = USI_SPITransmit(PacketBytes[3 + TxByteNum]); // Transmit the byte, store the answer
    2708:	e0 2f       	mov	r30, r16
    270a:	ff 27       	eor	r31, r31
    270c:	ef 56       	subi	r30, 0x6F	; 111
    270e:	fe 4f       	sbci	r31, 0xFE	; 254
    2710:	83 81       	ldd	r24, Z+3	; 0x03
    2712:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>

					if ((TxByteNum >= RxStartByte) && (RxByteNum < RxBytes))
    2716:	0f 15       	cp	r16, r15
    2718:	40 f0       	brcs	.+16     	; 0x272a <AICI_InterpretPacket+0x150>
    271a:	1e 15       	cp	r17, r14
    271c:	30 f4       	brcc	.+12     	; 0x272a <AICI_InterpretPacket+0x150>
					   PacketBytes[2 + RxByteNum++] = RecievedByte;
    271e:	e1 2f       	mov	r30, r17
    2720:	ff 27       	eor	r31, r31
    2722:	ef 56       	subi	r30, 0x6F	; 111
    2724:	fe 4f       	sbci	r31, 0xFE	; 254
    2726:	82 83       	std	Z+2, r24	; 0x02
    2728:	1f 5f       	subi	r17, 0xFF	; 255
    272a:	0d 15       	cp	r16, r13
    272c:	60 f3       	brcs	.-40     	; 0x2706 <AICI_InterpretPacket+0x12c>
    272e:	06 c0       	rjmp	.+12     	; 0x273c <AICI_InterpretPacket+0x162>
				}

				while (RxByteNum++ < RxBytes)                         // Still more bytes to recieve
				   PacketBytes[2 + RxByteNum] = USI_SPITransmit(0x00); // its answer to be recorded (or more bytes than sent need responses), send dummy bytes to fetch the response(s)
    2730:	80 e0       	ldi	r24, 0x00	; 0
    2732:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    2736:	cf 56       	subi	r28, 0x6F	; 111
    2738:	de 4f       	sbci	r29, 0xFE	; 254
    273a:	8a 83       	std	Y+2, r24	; 0x02
    273c:	1f 5f       	subi	r17, 0xFF	; 255
    273e:	81 2f       	mov	r24, r17
    2740:	81 50       	subi	r24, 0x01	; 1
    2742:	c1 2f       	mov	r28, r17
    2744:	dd 27       	eor	r29, r29
    2746:	8e 15       	cp	r24, r14
    2748:	98 f3       	brcs	.-26     	; 0x2730 <AICI_InterpretPacket+0x156>

				PacketBytes[1]             = AICB_STATUS_CMD_OK; // Data should be encompassed
    274a:	10 92 92 01 	sts	0x0192, r1
				PacketBytes[3 + RxByteNum] = AICB_STATUS_CMD_OK; //  by STATS_CMD_OKs
    274e:	cf 56       	subi	r28, 0x6F	; 111
    2750:	de 4f       	sbci	r29, 0xFE	; 254
    2752:	1b 82       	std	Y+3, r1	; 0x03
    2754:	8f c0       	rjmp	.+286    	; 0x2874 <AICI_InterpretPacket+0x29a>

				break;
		case AICB_CMD_READ_SIGNATURE_ISP:
		case AICB_CMD_READ_FUSE_ISP:
		case AICB_CMD_READ_LOCK_ISP:
		case AICB_CMD_READ_OSCCAL_ISP:
			MessageSize = 4;
    2756:	84 e0       	ldi	r24, 0x04	; 4
    2758:	90 e0       	ldi	r25, 0x00	; 0
    275a:	90 93 a7 02 	sts	0x02A7, r25
    275e:	80 93 a6 02 	sts	0x02A6, r24
    2762:	c1 e0       	ldi	r28, 0x01	; 1
    2764:	d0 e0       	ldi	r29, 0x00	; 0
    2766:	03 e9       	ldi	r16, 0x93	; 147
    2768:	11 e0       	ldi	r17, 0x01	; 1
	
			for (uint8_t ByteNum = 1; ByteNum <= 4; ByteNum++)
			{
				uint8_t Response = USI_SPITransmit(PacketBytes[1 + ByteNum]); // Transmit the four signature request bytes
    276a:	f8 01       	movw	r30, r16
    276c:	81 91       	ld	r24, Z+
    276e:	8f 01       	movw	r16, r30
    2770:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    2774:	98 2f       	mov	r25, r24

				if (ByteNum == PacketBytes[1])         // If the current byte is the requested signature byte, save the reponse in the packet
    2776:	80 91 92 01 	lds	r24, 0x0192
    277a:	8c 17       	cp	r24, r28
    277c:	11 f4       	brne	.+4      	; 0x2782 <AICI_InterpretPacket+0x1a8>
					PacketBytes[2] = Response;
    277e:	90 93 93 01 	sts	0x0193, r25
    2782:	21 96       	adiw	r28, 0x01	; 1
    2784:	c5 30       	cpi	r28, 0x05	; 5
    2786:	d1 05       	cpc	r29, r1
    2788:	81 f7       	brne	.-32     	; 0x276a <AICI_InterpretPacket+0x190>
			}

			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Data byte is encased in CMD_OKs
    278a:	10 92 92 01 	sts	0x0192, r1
			PacketBytes[3] = AICB_STATUS_CMD_OK;       // Data byte is encased in CMD_OKs
    278e:	10 92 94 01 	sts	0x0194, r1
    2792:	70 c0       	rjmp	.+224    	; 0x2874 <AICI_InterpretPacket+0x29a>

			break;
		case AICB_CMD_PROGRAM_FUSE_ISP:
		case AICB_CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;
    2794:	83 e0       	ldi	r24, 0x03	; 3
    2796:	90 e0       	ldi	r25, 0x00	; 0
    2798:	90 93 a7 02 	sts	0x02A7, r25
    279c:	80 93 a6 02 	sts	0x02A6, r24
    27a0:	c2 e9       	ldi	r28, 0x92	; 146
    27a2:	d1 e0       	ldi	r29, 0x01	; 1
			
			for (uint8_t PacketB = 1; PacketB <= 4; PacketB++) // Send the lock-byte values to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    27a4:	89 91       	ld	r24, Y+
    27a6:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    27aa:	f1 e0       	ldi	r31, 0x01	; 1
    27ac:	c6 39       	cpi	r28, 0x96	; 150
    27ae:	df 07       	cpc	r29, r31
    27b0:	c9 f7       	brne	.-14     	; 0x27a4 <AICI_InterpretPacket+0x1ca>

			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Two CMD_OKs are always returned
    27b2:	10 92 92 01 	sts	0x0192, r1
			PacketBytes[2] = AICB_STATUS_CMD_OK;       // Two CMD_OKs are always returned
    27b6:	10 92 93 01 	sts	0x0193, r1
    27ba:	5c c0       	rjmp	.+184    	; 0x2874 <AICI_InterpretPacket+0x29a>

			break;
		case AICB_CMD_READ_FLASH_ISP:
		case AICB_CMD_READ_EEPROM_ISP:
			MessageSize = 0;                           // Here to prevent compiler from complaining if a var dec appears straight after a case

			uint8_t  ReadCommand = PacketBytes[3];
    27bc:	d0 90 94 01 	lds	r13, 0x0194
			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8) // Load in the number of bytes that is to
			                     | PacketBytes[2];                 // be read into a temp variable (MSB first)
    27c0:	80 91 92 01 	lds	r24, 0x0192
    27c4:	99 27       	eor	r25, r25
    27c6:	d8 2f       	mov	r29, r24
    27c8:	cc 27       	eor	r28, r28
    27ca:	80 91 93 01 	lds	r24, 0x0193
    27ce:	99 27       	eor	r25, r25
    27d0:	c8 2b       	or	r28, r24
    27d2:	d9 2b       	or	r29, r25

			MessageSize = BytesToRead + 3;
    27d4:	23 96       	adiw	r28, 0x03	; 3
    27d6:	d0 93 a7 02 	sts	0x02A7, r29
    27da:	c0 93 a6 02 	sts	0x02A6, r28
    27de:	23 97       	sbiw	r28, 0x03	; 3
    27e0:	00 e0       	ldi	r16, 0x00	; 0
    27e2:	10 e0       	ldi	r17, 0x00	; 0
    27e4:	83 e9       	ldi	r24, 0x93	; 147
    27e6:	e8 2e       	mov	r14, r24
    27e8:	81 e0       	ldi	r24, 0x01	; 1
    27ea:	f8 2e       	mov	r15, r24
    27ec:	26 c0       	rjmp	.+76     	; 0x283a <AICI_InterpretPacket+0x260>

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
				if (PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)  // Flash read mode - word addresses so MSB/LSB masking nessesary
    27ee:	80 91 91 01 	lds	r24, 0x0191
    27f2:	84 31       	cpi	r24, 0x14	; 20
    27f4:	39 f4       	brne	.+14     	; 0x2804 <AICI_InterpretPacket+0x22a>
				{
					USI_SPITransmit(ReadCommand | ((ReadByte & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ));
    27f6:	00 ff       	sbrs	r16, 0
    27f8:	02 c0       	rjmp	.+4      	; 0x27fe <AICI_InterpretPacket+0x224>
    27fa:	88 e0       	ldi	r24, 0x08	; 8
    27fc:	01 c0       	rjmp	.+2      	; 0x2800 <AICI_InterpretPacket+0x226>
    27fe:	80 e0       	ldi	r24, 0x00	; 0
    2800:	8d 29       	or	r24, r13
    2802:	01 c0       	rjmp	.+2      	; 0x2806 <AICI_InterpretPacket+0x22c>
				}
				else                                       // EEPROM read mode, address is in bytes and so no masking nessesary
				{
					USI_SPITransmit(ReadCommand);
    2804:	8d 2d       	mov	r24, r13
    2806:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
				}
				
				USI_SPITransmitWord(CurrAddress);          // Transmit the current address to the slave AVR
    280a:	80 91 a9 02 	lds	r24, 0x02A9
    280e:	90 91 aa 02 	lds	r25, 0x02AA
    2812:	0e 94 06 0a 	call	0x140c	; 0x140c <USI_SPITransmitWord>

				PacketBytes[2 + ReadByte] = USI_SPITransmit(0x00); // Read in the byte stored at the requested location
    2816:	80 e0       	ldi	r24, 0x00	; 0
    2818:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    281c:	f7 01       	movw	r30, r14
    281e:	80 83       	st	Z, r24

				if ((ReadByte & 0x01) || (PacketBytes[0] == AICB_CMD_READ_EEPROM_ISP)) // Flash addresses are given in words; only increment on the odd byte if reading the flash.
    2820:	00 fd       	sbrc	r16, 0
    2822:	04 c0       	rjmp	.+8      	; 0x282c <AICI_InterpretPacket+0x252>
    2824:	80 91 91 01 	lds	r24, 0x0191
    2828:	86 31       	cpi	r24, 0x16	; 22
    282a:	11 f4       	brne	.+4      	; 0x2830 <AICI_InterpretPacket+0x256>
				{
					V2P_IncrementCurrAddress();             // Increment the address counter
    282c:	0e 94 dc 0e 	call	0x1db8	; 0x1db8 <V2P_IncrementCurrAddress>
    2830:	0f 5f       	subi	r16, 0xFF	; 255
    2832:	1f 4f       	sbci	r17, 0xFF	; 255
    2834:	08 94       	sec
    2836:	e1 1c       	adc	r14, r1
    2838:	f1 1c       	adc	r15, r1
    283a:	0c 17       	cp	r16, r28
    283c:	1d 07       	cpc	r17, r29
    283e:	b9 f6       	brne	.-82     	; 0x27ee <AICI_InterpretPacket+0x214>
				}
				else
				{
					if ((CurrAddress & 0x00FF0000) & !(CurrAddress & 0x0000FFFF))
					{
						CurrAddress |= (1UL << 31);        // Set MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
						V2P_CheckForExtendedAddress();
					}
				}
			}
			
			PacketBytes[1]               = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    2840:	10 92 92 01 	sts	0x0192, r1
			PacketBytes[2 + BytesToRead] = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    2844:	cf 56       	subi	r28, 0x6F	; 111
    2846:	de 4f       	sbci	r29, 0xFE	; 254
    2848:	1a 82       	std	Y+2, r1	; 0x02
    284a:	14 c0       	rjmp	.+40     	; 0x2874 <AICI_InterpretPacket+0x29a>

			break;
		case AICB_CMD_PROGRAM_FLASH_ISP:
		case AICB_CMD_PROGRAM_EEPROM_ISP:
			ISPCC_ProgramChip();                         // Program the bytes into the chip
    284c:	0e 94 8c 11 	call	0x2318	; 0x2318 <ISPCC_ProgramChip>
			
			MessageSize = 2;
    2850:	82 e0       	ldi	r24, 0x02	; 2
    2852:	90 e0       	ldi	r25, 0x00	; 0
    2854:	90 93 a7 02 	sts	0x02A7, r25
    2858:	80 93 a6 02 	sts	0x02A6, r24

			PacketBytes[1] = AICB_STATUS_CMD_OK;
    285c:	10 92 92 01 	sts	0x0192, r1
    2860:	09 c0       	rjmp	.+18     	; 0x2874 <AICI_InterpretPacket+0x29a>
			
			break;
		default:                                        // Unknown command, return error
			MessageSize = 1;
    2862:	81 e0       	ldi	r24, 0x01	; 1
    2864:	90 e0       	ldi	r25, 0x00	; 0
    2866:	90 93 a7 02 	sts	0x02A7, r25
    286a:	80 93 a6 02 	sts	0x02A6, r24
			
			PacketBytes[1] = AICB_STATUS_CMD_UNKNOWN;
    286e:	89 ec       	ldi	r24, 0xC9	; 201
    2870:	80 93 92 01 	sts	0x0192, r24
	}

	V2P_SendPacket();                                    // Send the response packet
    2874:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <V2P_SendPacket>
    2878:	df 91       	pop	r29
    287a:	cf 91       	pop	r28
    287c:	1f 91       	pop	r17
    287e:	0f 91       	pop	r16
    2880:	ff 90       	pop	r15
    2882:	ef 90       	pop	r14
    2884:	df 90       	pop	r13
    2886:	08 95       	ret

00002888 <PM_SetupDFAddressCounters>:
	  return ProgDataSize;
}

void PM_SetupDFAddressCounters(const uint8_t Type)
{
    2888:	80 93 02 01 	sts	0x0102, r24
	uint32_t StartAddress;
	
	MemoryType  = Type;
	GPageLength = 0;
    288c:	10 92 b0 02 	sts	0x02B0, r1
    2890:	10 92 af 02 	sts	0x02AF, r1
    2894:	20 91 a9 02 	lds	r18, 0x02A9
    2898:	30 91 aa 02 	lds	r19, 0x02AA
    289c:	40 91 ab 02 	lds	r20, 0x02AB
    28a0:	50 91 ac 02 	lds	r21, 0x02AC

	if (Type == TYPE_FLASH)                                             // Type 1 = Flash
    28a4:	81 30       	cpi	r24, 0x01	; 1
    28a6:	39 f4       	brne	.+14     	; 0x28b6 <PM_SetupDFAddressCounters+0x2e>
	  StartAddress = (CurrAddress << 1);                                // Convert flash word address to byte address
    28a8:	da 01       	movw	r26, r20
    28aa:	c9 01       	movw	r24, r18
    28ac:	88 0f       	add	r24, r24
    28ae:	99 1f       	adc	r25, r25
    28b0:	aa 1f       	adc	r26, r26
    28b2:	bb 1f       	adc	r27, r27
    28b4:	06 c0       	rjmp	.+12     	; 0x28c2 <PM_SetupDFAddressCounters+0x3a>
	else
	  StartAddress = CurrAddress + PM_EEPROM_OFFSET;                    // EEPROM uses byte addresses, and starts at the 257th kilobyte in Dataflash
    28b6:	da 01       	movw	r26, r20
    28b8:	c9 01       	movw	r24, r18
    28ba:	80 50       	subi	r24, 0x00	; 0
    28bc:	9c 4f       	sbci	r25, 0xFC	; 252
    28be:	ab 4f       	sbci	r26, 0xFB	; 251
    28c0:	bf 4f       	sbci	r27, 0xFF	; 255
	
	DataflashInfo.CurrPageAddress = 0;
    28c2:	10 92 44 01 	sts	0x0144, r1
    28c6:	10 92 43 01 	sts	0x0143, r1
    28ca:	20 e0       	ldi	r18, 0x00	; 0
    28cc:	30 e0       	ldi	r19, 0x00	; 0
    28ce:	06 c0       	rjmp	.+12     	; 0x28dc <PM_SetupDFAddressCounters+0x54>

	while (StartAddress >= DF_INTERNALDF_BUFFBYTES)                     // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DF_INTERNALDF_BUFFBYTES;                        // Subtract one page's worth of bytes from the desired address
    28d0:	88 50       	subi	r24, 0x08	; 8
    28d2:	91 40       	sbci	r25, 0x01	; 1
    28d4:	a0 40       	sbci	r26, 0x00	; 0
    28d6:	b0 40       	sbci	r27, 0x00	; 0
    28d8:	2f 5f       	subi	r18, 0xFF	; 255
    28da:	3f 4f       	sbci	r19, 0xFF	; 255
    28dc:	88 30       	cpi	r24, 0x08	; 8
    28de:	41 e0       	ldi	r20, 0x01	; 1
    28e0:	94 07       	cpc	r25, r20
    28e2:	40 e0       	ldi	r20, 0x00	; 0
    28e4:	a4 07       	cpc	r26, r20
    28e6:	40 e0       	ldi	r20, 0x00	; 0
    28e8:	b4 07       	cpc	r27, r20
    28ea:	90 f7       	brcc	.-28     	; 0x28d0 <PM_SetupDFAddressCounters+0x48>
    28ec:	30 93 44 01 	sts	0x0144, r19
    28f0:	20 93 43 01 	sts	0x0143, r18
		DataflashInfo.CurrPageAddress++;
	}
	
	DataflashInfo.CurrBuffByte = (uint16_t)StartAddress;                // The buffer byte is the remainder
    28f4:	90 93 46 01 	sts	0x0146, r25
    28f8:	80 93 45 01 	sts	0x0145, r24
    28fc:	08 95       	ret

000028fe <PM_CheckEndOfFuseLockData>:
}

void PM_StoreProgramByte(const uint8_t Data)
{
	if (DataflashInfo.CurrBuffByte == DF_INTERNALDF_BUFFBYTES)          // Finished current dataflash buffer page; write it to dataflash and get ready for the next one
	{
		DF_CopyBufferToFlashPage(DataflashInfo.CurrPageAddress++);
		DF_BufferWriteEnable(0);
		DataflashInfo.CurrBuffByte = 0;
	}
	
	SPI_SPITransmit(Data);                                              // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
	DataflashInfo.CurrBuffByte++;
	GPageLength++;
}

void PM_InterpretAVRISPPacket(void)
{
	uint8_t* EEPROMAddress;

	switch (PacketBytes[0])
	{
		case AICB_CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
						
			for (uint8_t PacketB = 0; PacketB <= 11; PacketB++)         // Save the enter programming mode command bytes
			  eeprom_write_byte(&EEPROMVars.EnterProgMode[PacketB], PacketBytes[PacketB]);
			
			InProgrammingMode = TRUE;                                   // Set the flag, prevent the user from exiting the V2P state machine			
			CurrentMode = PM_NO_SETUP;                                  // Clear the current mode variable

			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = AICB_STATUS_CMD_OK;

			break;			
		case AICB_CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;

			PM_CheckEndOfFuseLockData();                                // Check for remaining bytes to be stored and general cleanup
			
			InProgrammingMode = FALSE;                                  // Clear the flag, allow the user to exit the V2P state machine

			DF_EnableDataflash(FALSE);

			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
			PacketBytes[1] = AICB_STATUS_CMD_OK;

			break;
		case AICB_CMD_READ_SIGNATURE_ISP:
			MessageSize = 4;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x01;                                      // Signature bytes all return "01" in storage mode
			PacketBytes[3] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_CHIP_ERASE_ISP:
			MessageSize = 2;

			for (uint8_t PacketB = 1; PacketB < 7; PacketB++)           // Save the erase chip command bytes to EEPROM
			  eeprom_write_byte(&EEPROMVars.EraseChip[PacketB], PacketBytes[PacketB]);

			for (uint8_t Byte = 0; Byte < 4; Byte++)                    // Clear the program and EEPROM size counters
			{
				eeprom_write_byte(&EEPROMVars.DataSize[Byte], 0x00);
				eeprom_write_byte(&EEPROMVars.EEPROMSize[Byte], 0x00);
			}
						
			eeprom_write_byte(&EEPROMVars.EraseCmdStored, TRUE);
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;
			
			break;
		case AICB_CMD_READ_OSCCAL_ISP:
			MessageSize = 4;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x00;                                      // Return 0x00 for the OSCCAL byte
			PacketBytes[3] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_PROGRAM_FUSE_ISP:
		case AICB_CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;

			if (CurrentMode != PM_LOCKFUSEBITS_WRITE)                   // First lock or fuse byte being written, set the EEPROM pointer
			{
				CurrentMode   = PM_LOCKFUSEBITS_WRITE;
				DataflashInfo.CurrBuffByte  = 0;                        // CurrBuffByte is used to store the total fuse/lock bytes written
			}

			if (PacketBytes[0] == AICB_CMD_PROGRAM_FUSE_ISP)
			{
				EEPROMAddress = &EEPROMVars.FuseBytes[DataflashInfo.CurrBuffByte][0];
				MemoryType    = TYPE_FUSE;
			}
			else
			{
				EEPROMAddress = &EEPROMVars.LockBytes[DataflashInfo.CurrBuffByte][0];
				MemoryType    = TYPE_LOCK;
			}				
			
			if (DataflashInfo.CurrBuffByte < PM_MAX_FUSELOCKBITS)
			{
				for (uint8_t FLByte = 1; FLByte < 5; FLByte++)
				{
					eeprom_write_byte(EEPROMAddress, PacketBytes[FLByte]);
					EEPROMAddress++;
				}

				DataflashInfo.CurrBuffByte++;                           // Increment the total fuse/lock bytes written counter
			}
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;                        // Two CMD_OKs are always returned
			PacketBytes[2] = AICB_STATUS_CMD_OK;                        // Two CMD_OKs are always returned

			break;
		case AICB_CMD_READ_FUSE_ISP:
		case AICB_CMD_READ_LOCK_ISP:
			MessageSize = 4;
	
			if (CurrentMode != PM_LOCKFUSEBITS_READ)                    // First lock or fuse byte being read, set the EEPROM pointer
			{
				PM_CheckEndOfFuseLockData();                            // Check for remaining bytes to be stored and general cleanup
				
				DataflashInfo.CurrBuffByte = 0;
				CurrentMode  = PM_LOCKFUSEBITS_READ;
			}
			
			if (DataflashInfo.CurrBuffByte > eeprom_read_byte((PacketBytes[0] == AICB_CMD_READ_FUSE_ISP)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes))  // Trying to read more fuse/lock bytes than are stored in memory
			{
				PacketBytes[2] = 0xFF;                                  // Return 0xFF for the fuse/lock byte
			}
			else
			{
				uint8_t FuseLockNum  = DataflashInfo.CurrBuffByte;
				uint8_t FuseLockByte = (PacketBytes[1] - 1);
				
				PacketBytes[2] = eeprom_read_byte((uint8_t*)(((PacketBytes[0] == AICB_CMD_READ_FUSE_ISP)? &EEPROMVars.FuseBytes[FuseLockNum][FuseLockByte] : &EEPROMVars.LockBytes[FuseLockNum][FuseLockByte])));
			}

			DataflashInfo.CurrBuffByte++;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs
			PacketBytes[3] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_PROGRAM_FLASH_ISP:
		case AICB_CMD_PROGRAM_EEPROM_ISP:
			MessageSize = 2;

			if (CurrentMode != PM_DATAFLASH_WRITE)                      // First programming packet
			{
				if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP)       // Flash programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram; // Set the eeprom address to the Program command bytes location
					PM_SetupDFAddressCounters(TYPE_FLASH);
				}
				else                                                    // EEPROM programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;  // Set the eeprom address to the EEPROM command bytes location
					PM_SetupDFAddressCounters(TYPE_EEPROM);
				}
				
				DF_BufferWriteEnable(DataflashInfo.CurrBuffByte);
				CurrentMode = PM_DATAFLASH_WRITE;
				
				for (uint8_t B = 1; B < 10; B++)                        // Save the command bytes
				{
					eeprom_write_byte(EEPROMAddress, PacketBytes[B]);
					EEPROMAddress++;
				}
			}

			uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
			                      | PacketBytes[2];

			for (uint16_t CurrByte = 0; CurrByte < BytesToWrite; CurrByte++)
			  PM_StoreProgramByte(PacketBytes[10 + CurrByte]);

			if (!(GPageLength & PM_PAGELENGTH_FOUNDBIT) && (PacketBytes[3] & ISPCC_PROG_MODE_PAGEDONE) && GPageLength)
			{
				eeprom_write_word(((MemoryType == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength), GPageLength);
		
				GPageLength |= PM_PAGELENGTH_FOUNDBIT;                  // Bit 15 is used to indicate if the length has been found
			}

			PacketBytes[1] = AICB_STATUS_CMD_OK;
		
			break;
		case AICB_CMD_READ_FLASH_ISP:
		case AICB_CMD_READ_EEPROM_ISP:	
			if (CurrentMode != PM_DATAFLASH_READ)
			{
				PM_CheckEndOfFuseLockData();                            // Check for remaining bytes to be stored and general cleanup
				
				PM_SetupDFAddressCounters((PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);
				DF_ContinuousReadEnable(DataflashInfo.CurrPageAddress, DataflashInfo.CurrBuffByte);
				
				CurrentMode = PM_DATAFLASH_READ;
				CurrAddress = 0;
			}

			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8)      // \. Load in the number of bytes that is to
			                     | PacketBytes[2];                      // /  be read into a temp variable (MSB first)
						
			uint16_t BytesInMem  = PM_GetStoredDataSize((PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
			   PacketBytes[2 + ReadByte] = ((CurrAddress < BytesInMem)? SPI_SPITransmit(0x00) : 0xFF); // Read in the next dataflash byte if present
			   V2P_IncrementCurrAddress();
			}
			
			MessageSize = BytesToRead + 3;

			PacketBytes[1]               = AICB_STATUS_CMD_OK;          // Return data should be encompassed in STATUS_CMD_OKs
			PacketBytes[2 + BytesToRead] = AICB_STATUS_CMD_OK;          // Return data should be encompassed in STATUS_CMD_OKs
		
			break;
		default:
			MessageSize = 1;
			
			PacketBytes[1] = AICB_STATUS_CMD_UNKNOWN;
	}

	V2P_SendPacket();                                                   // Send the response packet
}

void PM_CheckEndOfFuseLockData(void)
{
    28fe:	cf 93       	push	r28
    2900:	df 93       	push	r29
    2902:	cd b7       	in	r28, 0x3d	; 61
    2904:	de b7       	in	r29, 0x3e	; 62
    2906:	24 97       	sbiw	r28, 0x04	; 4
    2908:	0f b6       	in	r0, 0x3f	; 63
    290a:	f8 94       	cli
    290c:	de bf       	out	0x3e, r29	; 62
    290e:	0f be       	out	0x3f, r0	; 63
    2910:	cd bf       	out	0x3d, r28	; 61
	if (CurrentMode == PM_DATAFLASH_WRITE)
    2912:	80 91 ae 02 	lds	r24, 0x02AE
    2916:	81 30       	cpi	r24, 0x01	; 1
    2918:	09 f0       	breq	.+2      	; 0x291c <PM_CheckEndOfFuseLockData+0x1e>
    291a:	40 c0       	rjmp	.+128    	; 0x299c <PM_CheckEndOfFuseLockData+0x9e>
	{
		if (DataflashInfo.CurrBuffByte)                                 // Data in the dataflash buffer, pending to be written
    291c:	80 91 45 01 	lds	r24, 0x0145
    2920:	90 91 46 01 	lds	r25, 0x0146
    2924:	89 2b       	or	r24, r25
    2926:	31 f0       	breq	.+12     	; 0x2934 <PM_CheckEndOfFuseLockData+0x36>
		  DF_CopyBufferToFlashPage(DataflashInfo.CurrPageAddress);      // Save the remaining buffer bytes
    2928:	80 91 43 01 	lds	r24, 0x0143
    292c:	90 91 44 01 	lds	r25, 0x0144
    2930:	0e 94 56 0b 	call	0x16ac	; 0x16ac <DF_CopyBufferToFlashPage>

		uint32_t DataSize = ((DataflashInfo.CurrPageAddress * DF_INTERNALDF_BUFFBYTES) + DataflashInfo.CurrBuffByte);
    2934:	20 91 43 01 	lds	r18, 0x0143
    2938:	30 91 44 01 	lds	r19, 0x0144
    293c:	88 e0       	ldi	r24, 0x08	; 8
    293e:	91 e0       	ldi	r25, 0x01	; 1
    2940:	ac 01       	movw	r20, r24
    2942:	24 9f       	mul	r18, r20
    2944:	c0 01       	movw	r24, r0
    2946:	25 9f       	mul	r18, r21
    2948:	90 0d       	add	r25, r0
    294a:	34 9f       	mul	r19, r20
    294c:	90 0d       	add	r25, r0
    294e:	11 24       	eor	r1, r1
    2950:	20 91 45 01 	lds	r18, 0x0145
    2954:	30 91 46 01 	lds	r19, 0x0146
    2958:	82 0f       	add	r24, r18
    295a:	93 1f       	adc	r25, r19
    295c:	9c 01       	movw	r18, r24
    295e:	44 27       	eor	r20, r20
    2960:	55 27       	eor	r21, r21
    2962:	29 83       	std	Y+1, r18	; 0x01
    2964:	3a 83       	std	Y+2, r19	; 0x02
    2966:	4b 83       	std	Y+3, r20	; 0x03
    2968:	5c 83       	std	Y+4, r21	; 0x04

		if (MemoryType == TYPE_FLASH)
    296a:	80 91 02 01 	lds	r24, 0x0102
    296e:	fe 01       	movw	r30, r28
    2970:	31 96       	adiw	r30, 0x01	; 1
    2972:	81 30       	cpi	r24, 0x01	; 1
    2974:	21 f4       	brne	.+8      	; 0x297e <PM_CheckEndOfFuseLockData+0x80>
            {
              uint8_t len;
              len = (uint8_t) n;

              asm volatile (
    2976:	84 e0       	ldi	r24, 0x04	; 4
    2978:	af e1       	ldi	r26, 0x1F	; 31
    297a:	b0 e0       	ldi	r27, 0x00	; 0
    297c:	0b c0       	rjmp	.+22     	; 0x2994 <PM_CheckEndOfFuseLockData+0x96>
		{
			eeprom_write_block((const void*)&DataSize, (void*)&EEPROMVars.DataSize, sizeof(uint32_t));
		}
		else
		{
			DataSize -= PM_EEPROM_OFFSET;                               // Remove DataFlash EEPROM start offset
    297e:	20 50       	subi	r18, 0x00	; 0
    2980:	34 40       	sbci	r19, 0x04	; 4
    2982:	44 40       	sbci	r20, 0x04	; 4
    2984:	50 40       	sbci	r21, 0x00	; 0
    2986:	29 83       	std	Y+1, r18	; 0x01
    2988:	3a 83       	std	Y+2, r19	; 0x02
    298a:	4b 83       	std	Y+3, r20	; 0x03
    298c:	5c 83       	std	Y+4, r21	; 0x04
            {
              uint8_t len;
              len = (uint8_t) n;

              asm volatile (
    298e:	84 e0       	ldi	r24, 0x04	; 4
    2990:	a3 e2       	ldi	r26, 0x23	; 35
    2992:	b0 e0       	ldi	r27, 0x00	; 0
    2994:	18 2e       	mov	r1, r24
    2996:	0e 94 ac 1a 	call	0x3558	; 0x3558 <__eeprom_write_block_1F2021>
    299a:	12 c0       	rjmp	.+36     	; 0x29c0 <PM_CheckEndOfFuseLockData+0xc2>
			eeprom_write_block((const void*)&DataSize, (void*)&EEPROMVars.EEPROMSize, sizeof(uint32_t));
		}
	}
	else if (CurrentMode == PM_LOCKFUSEBITS_WRITE)
    299c:	83 30       	cpi	r24, 0x03	; 3
    299e:	81 f4       	brne	.+32     	; 0x29c0 <PM_CheckEndOfFuseLockData+0xc2>
	{
		// CurrBuffByte stores the total number of fuse/lock bytes written in this case:
		eeprom_write_byte(((MemoryType == TYPE_FUSE)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes), DataflashInfo.CurrBuffByte);
    29a0:	20 91 45 01 	lds	r18, 0x0145
    29a4:	30 91 46 01 	lds	r19, 0x0146
    29a8:	80 91 02 01 	lds	r24, 0x0102
    29ac:	82 30       	cpi	r24, 0x02	; 2
    29ae:	19 f4       	brne	.+6      	; 0x29b6 <PM_CheckEndOfFuseLockData+0xb8>
    29b0:	a3 e3       	ldi	r26, 0x33	; 51
    29b2:	b0 e0       	ldi	r27, 0x00	; 0
    29b4:	02 c0       	rjmp	.+4      	; 0x29ba <PM_CheckEndOfFuseLockData+0xbc>
    29b6:	a4 e3       	ldi	r26, 0x34	; 52
    29b8:	b0 e0       	ldi	r27, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    29ba:	02 2e       	mov	r0, r18
    29bc:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
    29c0:	24 96       	adiw	r28, 0x04	; 4
    29c2:	0f b6       	in	r0, 0x3f	; 63
    29c4:	f8 94       	cli
    29c6:	de bf       	out	0x3e, r29	; 62
    29c8:	0f be       	out	0x3f, r0	; 63
    29ca:	cd bf       	out	0x3d, r28	; 61
    29cc:	df 91       	pop	r29
    29ce:	cf 91       	pop	r28
    29d0:	08 95       	ret

000029d2 <PM_GetStoredDataSize>:
    29d2:	cf 93       	push	r28
    29d4:	df 93       	push	r29
    29d6:	cd b7       	in	r28, 0x3d	; 61
    29d8:	de b7       	in	r29, 0x3e	; 62
    29da:	24 97       	sbiw	r28, 0x04	; 4
    29dc:	0f b6       	in	r0, 0x3f	; 63
    29de:	f8 94       	cli
    29e0:	de bf       	out	0x3e, r29	; 62
    29e2:	0f be       	out	0x3f, r0	; 63
    29e4:	cd bf       	out	0x3d, r28	; 61
    29e6:	81 30       	cpi	r24, 0x01	; 1
    29e8:	19 f4       	brne	.+6      	; 0x29f0 <PM_GetStoredDataSize+0x1e>
    29ea:	af e1       	ldi	r26, 0x1F	; 31
    29ec:	b0 e0       	ldi	r27, 0x00	; 0
    29ee:	02 c0       	rjmp	.+4      	; 0x29f4 <PM_GetStoredDataSize+0x22>
    29f0:	a3 e2       	ldi	r26, 0x23	; 35
    29f2:	b0 e0       	ldi	r27, 0x00	; 0
              /* Needed in order to truncate to 8 bit.  */
              uint8_t len;
              len = (uint8_t) n; 

              asm volatile (
    29f4:	84 e0       	ldi	r24, 0x04	; 4
    29f6:	fe 01       	movw	r30, r28
    29f8:	31 96       	adiw	r30, 0x01	; 1
    29fa:	18 2e       	mov	r1, r24
    29fc:	0e 94 91 1a 	call	0x3522	; 0x3522 <__eeprom_read_block_1F2021>
    2a00:	69 81       	ldd	r22, Y+1	; 0x01
    2a02:	7a 81       	ldd	r23, Y+2	; 0x02
    2a04:	8b 81       	ldd	r24, Y+3	; 0x03
    2a06:	9c 81       	ldd	r25, Y+4	; 0x04
    2a08:	6f 3f       	cpi	r22, 0xFF	; 255
    2a0a:	2f ef       	ldi	r18, 0xFF	; 255
    2a0c:	72 07       	cpc	r23, r18
    2a0e:	2f ef       	ldi	r18, 0xFF	; 255
    2a10:	82 07       	cpc	r24, r18
    2a12:	2f ef       	ldi	r18, 0xFF	; 255
    2a14:	92 07       	cpc	r25, r18
    2a16:	21 f4       	brne	.+8      	; 0x2a20 <PM_GetStoredDataSize+0x4e>
    2a18:	60 e0       	ldi	r22, 0x00	; 0
    2a1a:	70 e0       	ldi	r23, 0x00	; 0
    2a1c:	80 e0       	ldi	r24, 0x00	; 0
    2a1e:	90 e0       	ldi	r25, 0x00	; 0
    2a20:	24 96       	adiw	r28, 0x04	; 4
    2a22:	0f b6       	in	r0, 0x3f	; 63
    2a24:	f8 94       	cli
    2a26:	de bf       	out	0x3e, r29	; 62
    2a28:	0f be       	out	0x3f, r0	; 63
    2a2a:	cd bf       	out	0x3d, r28	; 61
    2a2c:	df 91       	pop	r29
    2a2e:	cf 91       	pop	r28
    2a30:	08 95       	ret

00002a32 <PM_StoreProgramByte>:
    2a32:	1f 93       	push	r17
    2a34:	18 2f       	mov	r17, r24
    2a36:	80 91 45 01 	lds	r24, 0x0145
    2a3a:	90 91 46 01 	lds	r25, 0x0146
    2a3e:	88 50       	subi	r24, 0x08	; 8
    2a40:	91 40       	sbci	r25, 0x01	; 1
    2a42:	a1 f4       	brne	.+40     	; 0x2a6c <PM_StoreProgramByte+0x3a>
    2a44:	80 91 43 01 	lds	r24, 0x0143
    2a48:	90 91 44 01 	lds	r25, 0x0144
    2a4c:	01 96       	adiw	r24, 0x01	; 1
    2a4e:	90 93 44 01 	sts	0x0144, r25
    2a52:	80 93 43 01 	sts	0x0143, r24
    2a56:	01 97       	sbiw	r24, 0x01	; 1
    2a58:	0e 94 56 0b 	call	0x16ac	; 0x16ac <DF_CopyBufferToFlashPage>
    2a5c:	80 e0       	ldi	r24, 0x00	; 0
    2a5e:	90 e0       	ldi	r25, 0x00	; 0
    2a60:	0e 94 cc 0a 	call	0x1598	; 0x1598 <DF_BufferWriteEnable>
    2a64:	10 92 46 01 	sts	0x0146, r1
    2a68:	10 92 45 01 	sts	0x0145, r1
    2a6c:	81 2f       	mov	r24, r17
    2a6e:	0e 94 b4 09 	call	0x1368	; 0x1368 <SPI_SPITransmit>
    2a72:	80 91 45 01 	lds	r24, 0x0145
    2a76:	90 91 46 01 	lds	r25, 0x0146
    2a7a:	01 96       	adiw	r24, 0x01	; 1
    2a7c:	90 93 46 01 	sts	0x0146, r25
    2a80:	80 93 45 01 	sts	0x0145, r24
    2a84:	80 91 af 02 	lds	r24, 0x02AF
    2a88:	90 91 b0 02 	lds	r25, 0x02B0
    2a8c:	01 96       	adiw	r24, 0x01	; 1
    2a8e:	90 93 b0 02 	sts	0x02B0, r25
    2a92:	80 93 af 02 	sts	0x02AF, r24
    2a96:	1f 91       	pop	r17
    2a98:	08 95       	ret

00002a9a <PM_SendFuseLockBytes>:
	}
}

void PM_SendFuseLockBytes(const uint8_t Type)
{
    2a9a:	ef 92       	push	r14
    2a9c:	ff 92       	push	r15
    2a9e:	0f 93       	push	r16
    2aa0:	1f 93       	push	r17
    2aa2:	cf 93       	push	r28
    2aa4:	df 93       	push	r29
	uint8_t  TotalBytes;
	uint8_t* EEPROMAddress;

	if (Type == TYPE_FUSE)
    2aa6:	82 30       	cpi	r24, 0x02	; 2
    2aa8:	59 f4       	brne	.+22     	; 0x2ac0 <PM_SendFuseLockBytes+0x26>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2aaa:	43 e3       	ldi	r20, 0x33	; 51
    2aac:	50 e0       	ldi	r21, 0x00	; 0
    2aae:	da 01       	movw	r26, r20
    2ab0:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
    2ab4:	80 2d       	mov	r24, r0
	{
		TotalBytes    = eeprom_read_byte(&EEPROMVars.TotalFuseBytes);
    2ab6:	18 2f       	mov	r17, r24
		EEPROMAddress = &EEPROMVars.FuseBytes[0][0];
    2ab8:	62 e0       	ldi	r22, 0x02	; 2
    2aba:	e6 2e       	mov	r14, r22
    2abc:	f1 2c       	mov	r15, r1
    2abe:	0a c0       	rjmp	.+20     	; 0x2ad4 <PM_SendFuseLockBytes+0x3a>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2ac0:	44 e3       	ldi	r20, 0x34	; 52
    2ac2:	50 e0       	ldi	r21, 0x00	; 0
    2ac4:	da 01       	movw	r26, r20
    2ac6:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
    2aca:	80 2d       	mov	r24, r0
	}
	else
	{
		TotalBytes    = eeprom_read_byte(&EEPROMVars.TotalLockBytes);
    2acc:	18 2f       	mov	r17, r24
		EEPROMAddress = &EEPROMVars.LockBytes[0][0];	
    2ace:	39 e2       	ldi	r19, 0x29	; 41
    2ad0:	e3 2e       	mov	r14, r19
    2ad2:	f1 2c       	mov	r15, r1
    2ad4:	e4 0e       	add	r14, r20
    2ad6:	f5 1e       	adc	r15, r21
    2ad8:	15 c0       	rjmp	.+42     	; 0x2b04 <PM_SendFuseLockBytes+0x6a>
    2ada:	e7 01       	movw	r28, r14
    2adc:	00 e0       	ldi	r16, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2ade:	de 01       	movw	r26, r28
    2ae0:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
    2ae4:	80 2d       	mov	r24, r0
	}

	while (TotalBytes--)                                                // Write each of the fuse/lock bytes stored in memory to the slave AVR
	{
		for (uint8_t CommandByte = 0; CommandByte < 4; CommandByte++)   // Write each individual command byte
		{
			USI_SPITransmit(eeprom_read_byte(EEPROMAddress));
    2ae6:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
			EEPROMAddress++;
    2aea:	21 96       	adiw	r28, 0x01	; 1
    2aec:	0f 5f       	subi	r16, 0xFF	; 255
    2aee:	04 30       	cpi	r16, 0x04	; 4
    2af0:	b1 f7       	brne	.-20     	; 0x2ade <PM_SendFuseLockBytes+0x44>
    2af2:	84 e0       	ldi	r24, 0x04	; 4
    2af4:	90 e0       	ldi	r25, 0x00	; 0
    2af6:	e8 0e       	add	r14, r24
    2af8:	f9 1e       	adc	r15, r25
		}
		
		// Add some delay before programming next byte, if there is one:
		if (TotalBytes)
    2afa:	11 23       	and	r17, r17
    2afc:	19 f0       	breq	.+6      	; 0x2b04 <PM_SendFuseLockBytes+0x6a>
		  MAIN_Delay10MS(5);
    2afe:	85 e0       	ldi	r24, 0x05	; 5
    2b00:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
    2b04:	11 50       	subi	r17, 0x01	; 1
    2b06:	48 f7       	brcc	.-46     	; 0x2ada <PM_SendFuseLockBytes+0x40>
    2b08:	df 91       	pop	r29
    2b0a:	cf 91       	pop	r28
    2b0c:	1f 91       	pop	r17
    2b0e:	0f 91       	pop	r16
    2b10:	ff 90       	pop	r15
    2b12:	ef 90       	pop	r14
    2b14:	08 95       	ret

00002b16 <PM_SendEraseCommand>:
	}
}

void PM_SendEraseCommand(void)
{			
    2b16:	cf 93       	push	r28
    2b18:	df 93       	push	r29
    2b1a:	cb e1       	ldi	r28, 0x1B	; 27
    2b1c:	d0 e0       	ldi	r29, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2b1e:	de 01       	movw	r26, r28
    2b20:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
    2b24:	80 2d       	mov	r24, r0
	for (uint8_t B = 3; B < 7 ; B++)                                    // Read out the erase chip command bytes
	  USI_SPITransmit(eeprom_read_byte(&EEPROMVars.EraseChip[B]));      // Send the erase chip commands
    2b26:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
    2b2a:	21 96       	adiw	r28, 0x01	; 1
    2b2c:	80 e0       	ldi	r24, 0x00	; 0
    2b2e:	cf 31       	cpi	r28, 0x1F	; 31
    2b30:	d8 07       	cpc	r29, r24
    2b32:	a9 f7       	brne	.-22     	; 0x2b1e <PM_SendEraseCommand+0x8>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2b34:	25 97       	sbiw	r28, 0x05	; 5
    2b36:	de 01       	movw	r26, r28
    2b38:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
    2b3c:	80 2d       	mov	r24, r0
    2b3e:	25 96       	adiw	r28, 0x05	; 5
			
	if (eeprom_read_byte(&EEPROMVars.EraseChip[2]))                     // Value of 1 indicates a busy flag test
    2b40:	88 23       	and	r24, r24
    2b42:	59 f0       	breq	.+22     	; 0x2b5a <PM_SendEraseCommand+0x44>
	{
		do
		  USI_SPITransmitWord(0xF000);
    2b44:	80 e0       	ldi	r24, 0x00	; 0
    2b46:	90 ef       	ldi	r25, 0xF0	; 240
    2b48:	0e 94 06 0a 	call	0x140c	; 0x140c <USI_SPITransmitWord>
		while (USI_SPITransmitWord(0x0000) & 0x01);
    2b4c:	80 e0       	ldi	r24, 0x00	; 0
    2b4e:	90 e0       	ldi	r25, 0x00	; 0
    2b50:	0e 94 06 0a 	call	0x140c	; 0x140c <USI_SPITransmitWord>
    2b54:	80 ff       	sbrs	r24, 0
    2b56:	08 c0       	rjmp	.+16     	; 0x2b68 <PM_SendEraseCommand+0x52>
    2b58:	f5 cf       	rjmp	.-22     	; 0x2b44 <PM_SendEraseCommand+0x2e>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2b5a:	26 97       	sbiw	r28, 0x06	; 6
    2b5c:	de 01       	movw	r26, r28
    2b5e:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
    2b62:	80 2d       	mov	r24, r0
	}
	else                                                                // Cleared flag means use a predefined delay
	{		
		MAIN_Delay1MS(eeprom_read_byte(&EEPROMVars.EraseChip[1]));      // Wait the erase delay
    2b64:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2b68:	df 91       	pop	r29
    2b6a:	cf 91       	pop	r28
    2b6c:	08 95       	ret

00002b6e <PM_CreateProgrammingPackets>:
	}
}

void PM_CreateProgrammingPackets(const uint8_t Type)
{			
    2b6e:	3f 92       	push	r3
    2b70:	4f 92       	push	r4
    2b72:	5f 92       	push	r5
    2b74:	6f 92       	push	r6
    2b76:	7f 92       	push	r7
    2b78:	8f 92       	push	r8
    2b7a:	9f 92       	push	r9
    2b7c:	af 92       	push	r10
    2b7e:	bf 92       	push	r11
    2b80:	cf 92       	push	r12
    2b82:	df 92       	push	r13
    2b84:	ef 92       	push	r14
    2b86:	ff 92       	push	r15
    2b88:	0f 93       	push	r16
    2b8a:	1f 93       	push	r17
    2b8c:	cf 93       	push	r28
    2b8e:	df 93       	push	r29
    2b90:	18 2f       	mov	r17, r24
	uint32_t BytesRead       = 0;
	uint32_t BytesToRead     = PM_GetStoredDataSize(Type);              // Get the byte size of the stored program
    2b92:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <PM_GetStoredDataSize>
    2b96:	2b 01       	movw	r4, r22
    2b98:	3c 01       	movw	r6, r24
	uint16_t BytesPerProgram;
	uint16_t PageLength      = eeprom_read_word((Type == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength);
    2b9a:	11 30       	cpi	r17, 0x01	; 1
    2b9c:	09 f0       	breq	.+2      	; 0x2ba0 <PM_CreateProgrammingPackets+0x32>
    2b9e:	e6 c0       	rjmp	.+460    	; 0x2d6c <PM_CreateProgrammingPackets+0x1fe>
eeprom_read_word (const uint16_t *addr)
{
  uint16_t result;

  asm ( 
    2ba0:	a5 e8       	ldi	r26, 0x85	; 133
    2ba2:	b0 e0       	ldi	r27, 0x00	; 0
    2ba4:	0e 94 96 1a 	call	0x352c	; 0x352c <__eeprom_read_word_1F2021>
    2ba8:	4f 01       	movw	r8, r30
	uint8_t  ContinuedPage   = FALSE;
	uint8_t* EEPROMAddress;

	CurrAddress = 0;
    2baa:	10 92 a9 02 	sts	0x02A9, r1
    2bae:	10 92 aa 02 	sts	0x02AA, r1
    2bb2:	10 92 ab 02 	sts	0x02AB, r1
    2bb6:	10 92 ac 02 	sts	0x02AC, r1

	if (Type == TYPE_FLASH)
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram;             // Set the EEPROM pointer to the write flash command bytes location
		DF_ContinuousReadEnable(0, 0);
    2bba:	60 e0       	ldi	r22, 0x00	; 0
    2bbc:	70 e0       	ldi	r23, 0x00	; 0
    2bbe:	80 e0       	ldi	r24, 0x00	; 0
    2bc0:	90 e0       	ldi	r25, 0x00	; 0
    2bc2:	0e 94 91 0a 	call	0x1522	; 0x1522 <DF_ContinuousReadEnable>
		PacketBytes[0] = AICB_CMD_PROGRAM_FLASH_ISP;
    2bc6:	83 e1       	ldi	r24, 0x13	; 19
    2bc8:	80 93 91 01 	sts	0x0191, r24
    2bcc:	03 e0       	ldi	r16, 0x03	; 3
    2bce:	10 e0       	ldi	r17, 0x00	; 0
	}
	else
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;              // Set the EEPROM pointer to the write EEPROM command bytes location
		DF_ContinuousReadEnable(PM_EEPROM_OFFSET / DF_INTERNALDF_BUFFBYTES, PM_EEPROM_OFFSET % DF_INTERNALDF_BUFFBYTES); // Start read from the EEPROM offset location
		PacketBytes[0] = AICB_CMD_PROGRAM_EEPROM_ISP;
	}

	// DEBUG:
	USART_ENABLE(1,0);
    2bd0:	87 ea       	ldi	r24, 0xA7	; 167
    2bd2:	90 e0       	ldi	r25, 0x00	; 0
    2bd4:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_puts_f>
    2bd8:	0e 94 e6 07 	call	0xfcc	; 0xfcc <OSCCAL_Calibrate>
    2bdc:	80 91 c1 00 	lds	r24, 0x00C1
    2be0:	80 78       	andi	r24, 0x80	; 128
    2be2:	88 60       	ori	r24, 0x08	; 8
    2be4:	80 93 c1 00 	sts	0x00C1, r24
    2be8:	c1 e9       	ldi	r28, 0x91	; 145
    2bea:	d1 e0       	ldi	r29, 0x01	; 1

	for (uint8_t B = 0; B < 9 ; B++)                                    // Load in the write data command bytes
	{
		EEPROMAddress++;                                                // Increment the EEPROM location counter
    2bec:	0f 5f       	subi	r16, 0xFF	; 255
    2bee:	1f 4f       	sbci	r17, 0xFF	; 255
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2bf0:	d8 01       	movw	r26, r16
    2bf2:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
    2bf6:	80 2d       	mov	r24, r0
		PacketBytes[B] = eeprom_read_byte(EEPROMAddress);               // Synthesise a write packet header
    2bf8:	99 27       	eor	r25, r25
    2bfa:	89 93       	st	Y+, r24

		USART_Tx(PacketBytes[B]);
    2bfc:	0e 94 87 09 	call	0x130e	; 0x130e <USART_Tx>
    2c00:	f1 e0       	ldi	r31, 0x01	; 1
    2c02:	ca 39       	cpi	r28, 0x9A	; 154
    2c04:	df 07       	cpc	r29, r31
    2c06:	91 f7       	brne	.-28     	; 0x2bec <PM_CreateProgrammingPackets+0x7e>
	}
	
	BytesPerProgram = ((uint16_t)PacketBytes[1] << 8)
    2c08:	80 91 92 01 	lds	r24, 0x0192
    2c0c:	99 27       	eor	r25, r25
    2c0e:	d8 2f       	mov	r29, r24
    2c10:	cc 27       	eor	r28, r28
    2c12:	80 91 93 01 	lds	r24, 0x0193
    2c16:	99 27       	eor	r25, r25
    2c18:	c8 2b       	or	r28, r24
    2c1a:	d9 2b       	or	r29, r25
    2c1c:	aa 24       	eor	r10, r10
    2c1e:	bb 24       	eor	r11, r11
    2c20:	65 01       	movw	r12, r10
    2c22:	33 24       	eor	r3, r3
    2c24:	9c c0       	rjmp	.+312    	; 0x2d5e <PM_CreateProgrammingPackets+0x1f0>
	                | PacketBytes[2];

	while (BytesRead < BytesToRead)
	{
		if (PacketBytes[3] & ISPCC_PROG_MODE_PAGE)
    2c26:	80 91 94 01 	lds	r24, 0x0194
    2c2a:	80 ff       	sbrs	r24, 0
    2c2c:	4b c0       	rjmp	.+150    	; 0x2cc4 <PM_CreateProgrammingPackets+0x156>
		{
			if (PageLength > 160)                                       // Max 160 bytes at a time
    2c2e:	91 ea       	ldi	r25, 0xA1	; 161
    2c30:	89 16       	cp	r8, r25
    2c32:	91 04       	cpc	r9, r1
    2c34:	18 f4       	brcc	.+6      	; 0x2c3c <PM_CreateProgrammingPackets+0xce>
    2c36:	01 e9       	ldi	r16, 0x91	; 145
    2c38:	11 e0       	ldi	r17, 0x01	; 1
    2c3a:	2f c0       	rjmp	.+94     	; 0x2c9a <PM_CreateProgrammingPackets+0x12c>
			{
				if (!(ContinuedPage))                                   // Start of a new page, program in the first 150 bytes
    2c3c:	33 20       	and	r3, r3
    2c3e:	41 f4       	brne	.+16     	; 0x2c50 <PM_CreateProgrammingPackets+0xe2>
				{
					BytesPerProgram = 160;
					PacketBytes[3] &= ~ISPCC_PROG_MODE_PAGEDONE;		
    2c40:	8f 77       	andi	r24, 0x7F	; 127
    2c42:	80 93 94 01 	sts	0x0194, r24
    2c46:	c0 ea       	ldi	r28, 0xA0	; 160
    2c48:	d0 e0       	ldi	r29, 0x00	; 0
    2c4a:	11 e0       	ldi	r17, 0x01	; 1
    2c4c:	31 2e       	mov	r3, r17
    2c4e:	07 c0       	rjmp	.+14     	; 0x2c5e <PM_CreateProgrammingPackets+0xf0>
					ContinuedPage   = TRUE;
				}
				else                                                    // Middle of a page, program in the remainder
				{
					BytesPerProgram = PageLength - 160;
    2c50:	e4 01       	movw	r28, r8
    2c52:	c0 5a       	subi	r28, 0xA0	; 160
    2c54:	d0 40       	sbci	r29, 0x00	; 0
					PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
    2c56:	80 68       	ori	r24, 0x80	; 128
    2c58:	80 93 94 01 	sts	0x0194, r24
    2c5c:	33 24       	eor	r3, r3
    2c5e:	01 e9       	ldi	r16, 0x91	; 145
    2c60:	11 e0       	ldi	r17, 0x01	; 1
    2c62:	07 c0       	rjmp	.+14     	; 0x2c72 <PM_CreateProgrammingPackets+0x104>
					ContinuedPage   = FALSE;
				}
				
				for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
				  PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);    // Load in the page				
    2c64:	80 e0       	ldi	r24, 0x00	; 0
    2c66:	0e 94 b4 09 	call	0x1368	; 0x1368 <SPI_SPITransmit>
    2c6a:	f8 01       	movw	r30, r16
    2c6c:	82 87       	std	Z+10, r24	; 0x0a
    2c6e:	0f 5f       	subi	r16, 0xFF	; 255
    2c70:	1f 4f       	sbci	r17, 0xFF	; 255
    2c72:	ce 01       	movw	r24, r28
    2c74:	8f 56       	subi	r24, 0x6F	; 111
    2c76:	9e 4f       	sbci	r25, 0xFE	; 254
    2c78:	08 17       	cp	r16, r24
    2c7a:	19 07       	cpc	r17, r25
    2c7c:	99 f7       	brne	.-26     	; 0x2c64 <PM_CreateProgrammingPackets+0xf6>

				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);
    2c7e:	8d 2f       	mov	r24, r29
    2c80:	99 27       	eor	r25, r25
    2c82:	80 93 92 01 	sts	0x0192, r24
				PacketBytes[2] = (uint8_t)(BytesPerProgram);
    2c86:	c0 93 93 01 	sts	0x0193, r28
    2c8a:	41 c0       	rjmp	.+130    	; 0x2d0e <PM_CreateProgrammingPackets+0x1a0>

				BytesRead += BytesPerProgram;                           // Increment the counter
			}
			else
			{
				for (uint16_t LoadB = 0; LoadB < PageLength; LoadB++)
				  PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);    // Load in the page
    2c8c:	80 e0       	ldi	r24, 0x00	; 0
    2c8e:	0e 94 b4 09 	call	0x1368	; 0x1368 <SPI_SPITransmit>
    2c92:	f8 01       	movw	r30, r16
    2c94:	82 87       	std	Z+10, r24	; 0x0a
    2c96:	0f 5f       	subi	r16, 0xFF	; 255
    2c98:	1f 4f       	sbci	r17, 0xFF	; 255
    2c9a:	c4 01       	movw	r24, r8
    2c9c:	8f 56       	subi	r24, 0x6F	; 111
    2c9e:	9e 4f       	sbci	r25, 0xFE	; 254
    2ca0:	08 17       	cp	r16, r24
    2ca2:	19 07       	cpc	r17, r25
    2ca4:	99 f7       	brne	.-26     	; 0x2c8c <PM_CreateProgrammingPackets+0x11e>
			
				PacketBytes[1]  = (uint8_t)(PageLength >> 8);
    2ca6:	89 2d       	mov	r24, r9
    2ca8:	99 27       	eor	r25, r25
    2caa:	80 93 92 01 	sts	0x0192, r24
				PacketBytes[2]  = (uint8_t)(PageLength);
    2cae:	80 92 93 01 	sts	0x0193, r8
				PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
    2cb2:	80 91 94 01 	lds	r24, 0x0194
    2cb6:	80 68       	ori	r24, 0x80	; 128
    2cb8:	80 93 94 01 	sts	0x0194, r24

				BytesRead += PageLength;                                // Increment the counter
    2cbc:	c4 01       	movw	r24, r8
    2cbe:	aa 27       	eor	r26, r26
    2cc0:	bb 27       	eor	r27, r27
    2cc2:	28 c0       	rjmp	.+80     	; 0x2d14 <PM_CreateProgrammingPackets+0x1a6>
			}
		}
		else
		{
			if ((BytesRead + BytesPerProgram) > BytesToRead)            // Less than a whole BytesPerProgram left of data to write
    2cc4:	ce 01       	movw	r24, r28
    2cc6:	aa 27       	eor	r26, r26
    2cc8:	bb 27       	eor	r27, r27
    2cca:	8a 0d       	add	r24, r10
    2ccc:	9b 1d       	adc	r25, r11
    2cce:	ac 1d       	adc	r26, r12
    2cd0:	bd 1d       	adc	r27, r13
    2cd2:	48 16       	cp	r4, r24
    2cd4:	59 06       	cpc	r5, r25
    2cd6:	6a 06       	cpc	r6, r26
    2cd8:	7b 06       	cpc	r7, r27
    2cda:	48 f4       	brcc	.+18     	; 0x2cee <PM_CreateProgrammingPackets+0x180>
			{
				BytesPerProgram = BytesToRead - BytesRead;              // Next lot of bytes will be the remaining data length
    2cdc:	e2 01       	movw	r28, r4
    2cde:	ca 19       	sub	r28, r10
    2ce0:	db 09       	sbc	r29, r11
				PacketBytes[1]  = (uint8_t)(BytesPerProgram >> 8);       // \. Save the new length
    2ce2:	8d 2f       	mov	r24, r29
    2ce4:	99 27       	eor	r25, r25
    2ce6:	80 93 92 01 	sts	0x0192, r24
				PacketBytes[2]  = (uint8_t)(BytesPerProgram);            // /  into the data packet
    2cea:	c0 93 93 01 	sts	0x0193, r28
    2cee:	01 e9       	ldi	r16, 0x91	; 145
    2cf0:	11 e0       	ldi	r17, 0x01	; 1
    2cf2:	07 c0       	rjmp	.+14     	; 0x2d02 <PM_CreateProgrammingPackets+0x194>
			}

			for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
			  PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);          // Load in the page
    2cf4:	80 e0       	ldi	r24, 0x00	; 0
    2cf6:	0e 94 b4 09 	call	0x1368	; 0x1368 <SPI_SPITransmit>
    2cfa:	f8 01       	movw	r30, r16
    2cfc:	82 87       	std	Z+10, r24	; 0x0a
    2cfe:	0f 5f       	subi	r16, 0xFF	; 255
    2d00:	1f 4f       	sbci	r17, 0xFF	; 255
    2d02:	ce 01       	movw	r24, r28
    2d04:	8f 56       	subi	r24, 0x6F	; 111
    2d06:	9e 4f       	sbci	r25, 0xFE	; 254
    2d08:	08 17       	cp	r16, r24
    2d0a:	19 07       	cpc	r17, r25
    2d0c:	99 f7       	brne	.-26     	; 0x2cf4 <PM_CreateProgrammingPackets+0x186>
		
			BytesRead += BytesPerProgram;                               // Increment the counter
    2d0e:	ce 01       	movw	r24, r28
    2d10:	aa 27       	eor	r26, r26
    2d12:	bb 27       	eor	r27, r27
    2d14:	a8 0e       	add	r10, r24
    2d16:	b9 1e       	adc	r11, r25
    2d18:	ca 1e       	adc	r12, r26
    2d1a:	db 1e       	adc	r13, r27
		}
	
		if (!(BytesRead & 0xFFFF) && (BytesRead & 0x00FF0000))          // Extended address required
    2d1c:	a1 14       	cp	r10, r1
    2d1e:	b1 04       	cpc	r11, r1
    2d20:	e1 f4       	brne	.+56     	; 0x2d5a <PM_CreateProgrammingPackets+0x1ec>
    2d22:	e1 2c       	mov	r14, r1
    2d24:	f1 2c       	mov	r15, r1
    2d26:	ef ef       	ldi	r30, 0xFF	; 255
    2d28:	0e 2f       	mov	r16, r30
    2d2a:	11 2d       	mov	r17, r1
    2d2c:	ea 20       	and	r14, r10
    2d2e:	fb 20       	and	r15, r11
    2d30:	0c 21       	and	r16, r12
    2d32:	1d 21       	and	r17, r13
    2d34:	e1 14       	cp	r14, r1
    2d36:	f1 04       	cpc	r15, r1
    2d38:	01 05       	cpc	r16, r1
    2d3a:	11 05       	cpc	r17, r1
    2d3c:	71 f0       	breq	.+28     	; 0x2d5a <PM_CreateProgrammingPackets+0x1ec>
		{
			USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);                // Load extended address command
    2d3e:	8d e4       	ldi	r24, 0x4D	; 77
    2d40:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
			USI_SPITransmit(0x00);
    2d44:	80 e0       	ldi	r24, 0x00	; 0
    2d46:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
			USI_SPITransmit((BytesRead & 0x00FF0000) >> 16);            // The 3rd byte of the long holds the extended address
    2d4a:	c8 01       	movw	r24, r16
    2d4c:	aa 27       	eor	r26, r26
    2d4e:	bb 27       	eor	r27, r27
    2d50:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
			USI_SPITransmit(0x00);
    2d54:	80 e0       	ldi	r24, 0x00	; 0
    2d56:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <USI_SPITransmit>
		}

		ISPCC_ProgramChip();                                            // Start the program cycle
    2d5a:	0e 94 8c 11 	call	0x2318	; 0x2318 <ISPCC_ProgramChip>
    2d5e:	a4 14       	cp	r10, r4
    2d60:	b5 04       	cpc	r11, r5
    2d62:	c6 04       	cpc	r12, r6
    2d64:	d7 04       	cpc	r13, r7
    2d66:	08 f4       	brcc	.+2      	; 0x2d6a <PM_CreateProgrammingPackets+0x1fc>
    2d68:	5e cf       	rjmp	.-324    	; 0x2c26 <PM_CreateProgrammingPackets+0xb8>
    2d6a:	19 c0       	rjmp	.+50     	; 0x2d9e <PM_CreateProgrammingPackets+0x230>
eeprom_read_word (const uint16_t *addr)
{
  uint16_t result;

  asm ( 
    2d6c:	a7 e8       	ldi	r26, 0x87	; 135
    2d6e:	b0 e0       	ldi	r27, 0x00	; 0
    2d70:	0e 94 96 1a 	call	0x352c	; 0x352c <__eeprom_read_word_1F2021>
    2d74:	4f 01       	movw	r8, r30
    2d76:	10 92 a9 02 	sts	0x02A9, r1
    2d7a:	10 92 aa 02 	sts	0x02AA, r1
    2d7e:	10 92 ab 02 	sts	0x02AB, r1
    2d82:	10 92 ac 02 	sts	0x02AC, r1
    2d86:	60 ee       	ldi	r22, 0xE0	; 224
    2d88:	70 e0       	ldi	r23, 0x00	; 0
    2d8a:	84 ee       	ldi	r24, 0xE4	; 228
    2d8c:	93 e0       	ldi	r25, 0x03	; 3
    2d8e:	0e 94 91 0a 	call	0x1522	; 0x1522 <DF_ContinuousReadEnable>
    2d92:	85 e1       	ldi	r24, 0x15	; 21
    2d94:	80 93 91 01 	sts	0x0191, r24
    2d98:	0d e0       	ldi	r16, 0x0D	; 13
    2d9a:	10 e0       	ldi	r17, 0x00	; 0
    2d9c:	19 cf       	rjmp	.-462    	; 0x2bd0 <PM_CreateProgrammingPackets+0x62>
    2d9e:	df 91       	pop	r29
    2da0:	cf 91       	pop	r28
    2da2:	1f 91       	pop	r17
    2da4:	0f 91       	pop	r16
    2da6:	ff 90       	pop	r15
    2da8:	ef 90       	pop	r14
    2daa:	df 90       	pop	r13
    2dac:	cf 90       	pop	r12
    2dae:	bf 90       	pop	r11
    2db0:	af 90       	pop	r10
    2db2:	9f 90       	pop	r9
    2db4:	8f 90       	pop	r8
    2db6:	7f 90       	pop	r7
    2db8:	6f 90       	pop	r6
    2dba:	5f 90       	pop	r5
    2dbc:	4f 90       	pop	r4
    2dbe:	3f 90       	pop	r3
    2dc0:	08 95       	ret

00002dc2 <PM_ShowStoredItemSizes>:
	}
}

void PM_ShowStoredItemSizes(void)
{
    2dc2:	1f 93       	push	r17
    2dc4:	cf 93       	push	r28
    2dc6:	df 93       	push	r29
    2dc8:	cd b7       	in	r28, 0x3d	; 61
    2dca:	de b7       	in	r29, 0x3e	; 62
    2dcc:	2e 97       	sbiw	r28, 0x0e	; 14
    2dce:	0f b6       	in	r0, 0x3f	; 63
    2dd0:	f8 94       	cli
    2dd2:	de bf       	out	0x3e, r29	; 62
    2dd4:	0f be       	out	0x3f, r0	; 63
    2dd6:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[14];
	uint8_t ItemInfoIndex = 0;
	uint8_t TempB;
	
	JoyStatus = 1;
    2dd8:	81 e0       	ldi	r24, 0x01	; 1
    2dda:	8e bb       	out	0x1e, r24	; 30
    2ddc:	10 e0       	ldi	r17, 0x00	; 0
	
	for (;;)
	{
		if (JoyStatus)
    2dde:	8e b3       	in	r24, 0x1e	; 30
    2de0:	88 23       	and	r24, r24
    2de2:	e9 f3       	breq	.-6      	; 0x2dde <PM_ShowStoredItemSizes+0x1c>
		{
			if (JoyStatus & JOY_UP)
    2de4:	f6 9b       	sbis	0x1e, 6	; 30
    2de6:	04 c0       	rjmp	.+8      	; 0x2df0 <PM_ShowStoredItemSizes+0x2e>
			  (ItemInfoIndex == 0)? ItemInfoIndex = 3 : ItemInfoIndex--;
    2de8:	11 23       	and	r17, r17
    2dea:	81 f1       	breq	.+96     	; 0x2e4c <PM_ShowStoredItemSizes+0x8a>
    2dec:	11 50       	subi	r17, 0x01	; 1
    2dee:	0a c0       	rjmp	.+20     	; 0x2e04 <PM_ShowStoredItemSizes+0x42>
			else if (JoyStatus & JOY_DOWN)
    2df0:	f7 9b       	sbis	0x1e, 7	; 30
    2df2:	06 c0       	rjmp	.+12     	; 0x2e00 <PM_ShowStoredItemSizes+0x3e>
			  (ItemInfoIndex == 3)? ItemInfoIndex = 0 : ItemInfoIndex++;
    2df4:	13 30       	cpi	r17, 0x03	; 3
    2df6:	11 f4       	brne	.+4      	; 0x2dfc <PM_ShowStoredItemSizes+0x3a>
    2df8:	10 e0       	ldi	r17, 0x00	; 0
    2dfa:	0d c0       	rjmp	.+26     	; 0x2e16 <PM_ShowStoredItemSizes+0x54>
    2dfc:	1f 5f       	subi	r17, 0xFF	; 255
    2dfe:	02 c0       	rjmp	.+4      	; 0x2e04 <PM_ShowStoredItemSizes+0x42>
			else if (JoyStatus & JOY_LEFT)
    2e00:	f2 99       	sbic	0x1e, 2	; 30
    2e02:	49 c0       	rjmp	.+146    	; 0x2e96 <PM_ShowStoredItemSizes+0xd4>
			  return;
		
			switch (ItemInfoIndex)
    2e04:	11 30       	cpi	r17, 0x01	; 1
    2e06:	79 f0       	breq	.+30     	; 0x2e26 <PM_ShowStoredItemSizes+0x64>
    2e08:	11 30       	cpi	r17, 0x01	; 1
    2e0a:	28 f0       	brcs	.+10     	; 0x2e16 <PM_ShowStoredItemSizes+0x54>
    2e0c:	12 30       	cpi	r17, 0x02	; 2
    2e0e:	a9 f0       	breq	.+42     	; 0x2e3a <PM_ShowStoredItemSizes+0x78>
    2e10:	13 30       	cpi	r17, 0x03	; 3
    2e12:	d1 f5       	brne	.+116    	; 0x2e88 <PM_ShowStoredItemSizes+0xc6>
    2e14:	1c c0       	rjmp	.+56     	; 0x2e4e <PM_ShowStoredItemSizes+0x8c>
			{
				case 0:
					strcpy_P(Buffer, PSTR("DATA-"));
    2e16:	68 e5       	ldi	r22, 0x58	; 88
    2e18:	74 e0       	ldi	r23, 0x04	; 4
    2e1a:	ce 01       	movw	r24, r28
    2e1c:	01 96       	adiw	r24, 0x01	; 1
    2e1e:	0e 94 4d 1a 	call	0x349a	; 0x349a <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_FLASH), &Buffer[5], 10);
    2e22:	81 e0       	ldi	r24, 0x01	; 1
    2e24:	07 c0       	rjmp	.+14     	; 0x2e34 <PM_ShowStoredItemSizes+0x72>
					break;
				case 1:
					strcpy_P(Buffer, PSTR("EPRM-"));
    2e26:	62 e5       	ldi	r22, 0x52	; 82
    2e28:	74 e0       	ldi	r23, 0x04	; 4
    2e2a:	ce 01       	movw	r24, r28
    2e2c:	01 96       	adiw	r24, 0x01	; 1
    2e2e:	0e 94 4d 1a 	call	0x349a	; 0x349a <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_EEPROM), &Buffer[5], 10);
    2e32:	80 e0       	ldi	r24, 0x00	; 0
    2e34:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <PM_GetStoredDataSize>
    2e38:	20 c0       	rjmp	.+64     	; 0x2e7a <PM_ShowStoredItemSizes+0xb8>
					break;
				case 2:
					strcpy_P(Buffer, PSTR("FUSE-"));
    2e3a:	6c e4       	ldi	r22, 0x4C	; 76
    2e3c:	74 e0       	ldi	r23, 0x04	; 4
    2e3e:	ce 01       	movw	r24, r28
    2e40:	01 96       	adiw	r24, 0x01	; 1
    2e42:	0e 94 4d 1a 	call	0x349a	; 0x349a <strcpy_P>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2e46:	a3 e3       	ldi	r26, 0x33	; 51
    2e48:	b0 e0       	ldi	r27, 0x00	; 0
    2e4a:	09 c0       	rjmp	.+18     	; 0x2e5e <PM_ShowStoredItemSizes+0x9c>
					TempB = eeprom_read_byte(&EEPROMVars.TotalFuseBytes);
					ultoa(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5], 10);
					break;
    2e4c:	13 e0       	ldi	r17, 0x03	; 3
				case 3:
					strcpy_P(Buffer, PSTR("LOCK-"));
    2e4e:	66 e4       	ldi	r22, 0x46	; 70
    2e50:	74 e0       	ldi	r23, 0x04	; 4
    2e52:	ce 01       	movw	r24, r28
    2e54:	01 96       	adiw	r24, 0x01	; 1
    2e56:	0e 94 4d 1a 	call	0x349a	; 0x349a <strcpy_P>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2e5a:	a4 e3       	ldi	r26, 0x34	; 52
    2e5c:	b0 e0       	ldi	r27, 0x00	; 0
    2e5e:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
    2e62:	80 2d       	mov	r24, r0
					TempB = eeprom_read_byte(&EEPROMVars.TotalLockBytes);
					ultoa(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5], 10);
    2e64:	8f 3f       	cpi	r24, 0xFF	; 255
    2e66:	29 f4       	brne	.+10     	; 0x2e72 <PM_ShowStoredItemSizes+0xb0>
    2e68:	60 e0       	ldi	r22, 0x00	; 0
    2e6a:	70 e0       	ldi	r23, 0x00	; 0
    2e6c:	80 e0       	ldi	r24, 0x00	; 0
    2e6e:	90 e0       	ldi	r25, 0x00	; 0
    2e70:	04 c0       	rjmp	.+8      	; 0x2e7a <PM_ShowStoredItemSizes+0xb8>
    2e72:	68 2f       	mov	r22, r24
    2e74:	77 27       	eor	r23, r23
    2e76:	88 27       	eor	r24, r24
    2e78:	99 27       	eor	r25, r25
    2e7a:	2a e0       	ldi	r18, 0x0A	; 10
    2e7c:	30 e0       	ldi	r19, 0x00	; 0
    2e7e:	ae 01       	movw	r20, r28
    2e80:	4a 5f       	subi	r20, 0xFA	; 250
    2e82:	5f 4f       	sbci	r21, 0xFF	; 255
    2e84:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <ultoa>
			}
	
			LCD_puts(Buffer);
    2e88:	ce 01       	movw	r24, r28
    2e8a:	01 96       	adiw	r24, 0x01	; 1
    2e8c:	0e 94 81 08 	call	0x1102	; 0x1102 <LCD_puts>

			MAIN_WaitForJoyRelease();
    2e90:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
    2e94:	a4 cf       	rjmp	.-184    	; 0x2dde <PM_ShowStoredItemSizes+0x1c>
    2e96:	2e 96       	adiw	r28, 0x0e	; 14
    2e98:	0f b6       	in	r0, 0x3f	; 63
    2e9a:	f8 94       	cli
    2e9c:	de bf       	out	0x3e, r29	; 62
    2e9e:	0f be       	out	0x3f, r0	; 63
    2ea0:	cd bf       	out	0x3d, r28	; 61
    2ea2:	df 91       	pop	r29
    2ea4:	cf 91       	pop	r28
    2ea6:	1f 91       	pop	r17
    2ea8:	08 95       	ret

00002eaa <PM_InterpretAVRISPPacket>:
    2eaa:	ef 92       	push	r14
    2eac:	ff 92       	push	r15
    2eae:	0f 93       	push	r16
    2eb0:	1f 93       	push	r17
    2eb2:	cf 93       	push	r28
    2eb4:	df 93       	push	r29
    2eb6:	20 91 91 01 	lds	r18, 0x0191
    2eba:	26 31       	cpi	r18, 0x16	; 22
    2ebc:	09 f4       	brne	.+2      	; 0x2ec0 <PM_InterpretAVRISPPacket+0x16>
    2ebe:	a6 c1       	rjmp	.+844    	; 0x320c <PM_InterpretAVRISPPacket+0x362>
    2ec0:	27 31       	cpi	r18, 0x17	; 23
    2ec2:	78 f4       	brcc	.+30     	; 0x2ee2 <PM_InterpretAVRISPPacket+0x38>
    2ec4:	22 31       	cpi	r18, 0x12	; 18
    2ec6:	09 f4       	brne	.+2      	; 0x2eca <PM_InterpretAVRISPPacket+0x20>
    2ec8:	5f c0       	rjmp	.+190    	; 0x2f88 <PM_InterpretAVRISPPacket+0xde>
    2eca:	23 31       	cpi	r18, 0x13	; 19
    2ecc:	30 f4       	brcc	.+12     	; 0x2eda <PM_InterpretAVRISPPacket+0x30>
    2ece:	20 31       	cpi	r18, 0x10	; 16
    2ed0:	e9 f0       	breq	.+58     	; 0x2f0c <PM_InterpretAVRISPPacket+0x62>
    2ed2:	21 31       	cpi	r18, 0x11	; 17
    2ed4:	09 f0       	breq	.+2      	; 0x2ed8 <PM_InterpretAVRISPPacket+0x2e>
    2ed6:	00 c2       	rjmp	.+1024   	; 0x32d8 <PM_InterpretAVRISPPacket+0x42e>
    2ed8:	37 c0       	rjmp	.+110    	; 0x2f48 <PM_InterpretAVRISPPacket+0x9e>
    2eda:	24 31       	cpi	r18, 0x14	; 20
    2edc:	09 f0       	breq	.+2      	; 0x2ee0 <PM_InterpretAVRISPPacket+0x36>
    2ede:	2d c1       	rjmp	.+602    	; 0x313a <PM_InterpretAVRISPPacket+0x290>
    2ee0:	95 c1       	rjmp	.+810    	; 0x320c <PM_InterpretAVRISPPacket+0x362>
    2ee2:	29 31       	cpi	r18, 0x19	; 25
    2ee4:	09 f4       	brne	.+2      	; 0x2ee8 <PM_InterpretAVRISPPacket+0x3e>
    2ee6:	8c c0       	rjmp	.+280    	; 0x3000 <PM_InterpretAVRISPPacket+0x156>
    2ee8:	2a 31       	cpi	r18, 0x1A	; 26
    2eea:	38 f4       	brcc	.+14     	; 0x2efa <PM_InterpretAVRISPPacket+0x50>
    2eec:	27 31       	cpi	r18, 0x17	; 23
    2eee:	09 f4       	brne	.+2      	; 0x2ef2 <PM_InterpretAVRISPPacket+0x48>
    2ef0:	87 c0       	rjmp	.+270    	; 0x3000 <PM_InterpretAVRISPPacket+0x156>
    2ef2:	28 31       	cpi	r18, 0x18	; 24
    2ef4:	09 f0       	breq	.+2      	; 0x2ef8 <PM_InterpretAVRISPPacket+0x4e>
    2ef6:	f0 c1       	rjmp	.+992    	; 0x32d8 <PM_InterpretAVRISPPacket+0x42e>
    2ef8:	ce c0       	rjmp	.+412    	; 0x3096 <PM_InterpretAVRISPPacket+0x1ec>
    2efa:	2b 31       	cpi	r18, 0x1B	; 27
    2efc:	c9 f1       	breq	.+114    	; 0x2f70 <PM_InterpretAVRISPPacket+0xc6>
    2efe:	2b 31       	cpi	r18, 0x1B	; 27
    2f00:	08 f4       	brcc	.+2      	; 0x2f04 <PM_InterpretAVRISPPacket+0x5a>
    2f02:	c9 c0       	rjmp	.+402    	; 0x3096 <PM_InterpretAVRISPPacket+0x1ec>
    2f04:	2c 31       	cpi	r18, 0x1C	; 28
    2f06:	09 f0       	breq	.+2      	; 0x2f0a <PM_InterpretAVRISPPacket+0x60>
    2f08:	e7 c1       	rjmp	.+974    	; 0x32d8 <PM_InterpretAVRISPPacket+0x42e>
    2f0a:	6d c0       	rjmp	.+218    	; 0x2fe6 <PM_InterpretAVRISPPacket+0x13c>
    2f0c:	82 e0       	ldi	r24, 0x02	; 2
    2f0e:	90 e0       	ldi	r25, 0x00	; 0
    2f10:	90 93 a7 02 	sts	0x02A7, r25
    2f14:	80 93 a6 02 	sts	0x02A6, r24
    2f18:	e1 e9       	ldi	r30, 0x91	; 145
    2f1a:	f1 e0       	ldi	r31, 0x01	; 1
    2f1c:	27 e2       	ldi	r18, 0x27	; 39
    2f1e:	30 e0       	ldi	r19, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2f20:	81 91       	ld	r24, Z+
    2f22:	d9 01       	movw	r26, r18
    2f24:	08 2e       	mov	r0, r24
    2f26:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
    2f2a:	2f 5f       	subi	r18, 0xFF	; 255
    2f2c:	3f 4f       	sbci	r19, 0xFF	; 255
    2f2e:	81 e0       	ldi	r24, 0x01	; 1
    2f30:	ed 39       	cpi	r30, 0x9D	; 157
    2f32:	f8 07       	cpc	r31, r24
    2f34:	a9 f7       	brne	.-22     	; 0x2f20 <PM_InterpretAVRISPPacket+0x76>
    2f36:	81 e0       	ldi	r24, 0x01	; 1
    2f38:	80 93 a8 02 	sts	0x02A8, r24
    2f3c:	10 92 ae 02 	sts	0x02AE, r1
    2f40:	81 b3       	in	r24, 0x11	; 17
    2f42:	8f 7c       	andi	r24, 0xCF	; 207
    2f44:	80 62       	ori	r24, 0x20	; 32
    2f46:	10 c0       	rjmp	.+32     	; 0x2f68 <PM_InterpretAVRISPPacket+0xbe>
    2f48:	82 e0       	ldi	r24, 0x02	; 2
    2f4a:	90 e0       	ldi	r25, 0x00	; 0
    2f4c:	90 93 a7 02 	sts	0x02A7, r25
    2f50:	80 93 a6 02 	sts	0x02A6, r24
    2f54:	0e 94 7f 14 	call	0x28fe	; 0x28fe <PM_CheckEndOfFuseLockData>
    2f58:	10 92 a8 02 	sts	0x02A8, r1
    2f5c:	80 e0       	ldi	r24, 0x00	; 0
    2f5e:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    2f62:	81 b3       	in	r24, 0x11	; 17
    2f64:	8f 7c       	andi	r24, 0xCF	; 207
    2f66:	80 61       	ori	r24, 0x10	; 16
    2f68:	81 bb       	out	0x11, r24	; 17
    2f6a:	10 92 92 01 	sts	0x0192, r1
    2f6e:	bd c1       	rjmp	.+890    	; 0x32ea <PM_InterpretAVRISPPacket+0x440>
    2f70:	84 e0       	ldi	r24, 0x04	; 4
    2f72:	90 e0       	ldi	r25, 0x00	; 0
    2f74:	90 93 a7 02 	sts	0x02A7, r25
    2f78:	80 93 a6 02 	sts	0x02A6, r24
    2f7c:	10 92 92 01 	sts	0x0192, r1
    2f80:	81 e0       	ldi	r24, 0x01	; 1
    2f82:	80 93 93 01 	sts	0x0193, r24
    2f86:	39 c0       	rjmp	.+114    	; 0x2ffa <PM_InterpretAVRISPPacket+0x150>
    2f88:	82 e0       	ldi	r24, 0x02	; 2
    2f8a:	90 e0       	ldi	r25, 0x00	; 0
    2f8c:	90 93 a7 02 	sts	0x02A7, r25
    2f90:	80 93 a6 02 	sts	0x02A6, r24
    2f94:	e2 e9       	ldi	r30, 0x92	; 146
    2f96:	f1 e0       	ldi	r31, 0x01	; 1
    2f98:	29 e1       	ldi	r18, 0x19	; 25
    2f9a:	30 e0       	ldi	r19, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2f9c:	81 91       	ld	r24, Z+
    2f9e:	d9 01       	movw	r26, r18
    2fa0:	08 2e       	mov	r0, r24
    2fa2:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
    2fa6:	2f 5f       	subi	r18, 0xFF	; 255
    2fa8:	3f 4f       	sbci	r19, 0xFF	; 255
    2faa:	91 e0       	ldi	r25, 0x01	; 1
    2fac:	e8 39       	cpi	r30, 0x98	; 152
    2fae:	f9 07       	cpc	r31, r25
    2fb0:	a9 f7       	brne	.-22     	; 0x2f9c <PM_InterpretAVRISPPacket+0xf2>
    2fb2:	2f e1       	ldi	r18, 0x1F	; 31
    2fb4:	30 e0       	ldi	r19, 0x00	; 0
    2fb6:	80 e0       	ldi	r24, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2fb8:	d9 01       	movw	r26, r18
    2fba:	08 2e       	mov	r0, r24
    2fbc:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
    2fc0:	d9 01       	movw	r26, r18
    2fc2:	14 96       	adiw	r26, 0x04	; 4
    2fc4:	08 2e       	mov	r0, r24
    2fc6:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
    2fca:	2f 5f       	subi	r18, 0xFF	; 255
    2fcc:	3f 4f       	sbci	r19, 0xFF	; 255
    2fce:	e0 e0       	ldi	r30, 0x00	; 0
    2fd0:	23 32       	cpi	r18, 0x23	; 35
    2fd2:	3e 07       	cpc	r19, r30
    2fd4:	89 f7       	brne	.-30     	; 0x2fb8 <PM_InterpretAVRISPPacket+0x10e>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2fd6:	81 e0       	ldi	r24, 0x01	; 1
    2fd8:	2c 50       	subi	r18, 0x0C	; 12
    2fda:	30 40       	sbci	r19, 0x00	; 0
    2fdc:	d9 01       	movw	r26, r18
    2fde:	08 2e       	mov	r0, r24
    2fe0:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
    2fe4:	c2 cf       	rjmp	.-124    	; 0x2f6a <PM_InterpretAVRISPPacket+0xc0>
    2fe6:	84 e0       	ldi	r24, 0x04	; 4
    2fe8:	90 e0       	ldi	r25, 0x00	; 0
    2fea:	90 93 a7 02 	sts	0x02A7, r25
    2fee:	80 93 a6 02 	sts	0x02A6, r24
    2ff2:	10 92 92 01 	sts	0x0192, r1
    2ff6:	10 92 93 01 	sts	0x0193, r1
    2ffa:	10 92 94 01 	sts	0x0194, r1
    2ffe:	75 c1       	rjmp	.+746    	; 0x32ea <PM_InterpretAVRISPPacket+0x440>
    3000:	83 e0       	ldi	r24, 0x03	; 3
    3002:	90 e0       	ldi	r25, 0x00	; 0
    3004:	90 93 a7 02 	sts	0x02A7, r25
    3008:	80 93 a6 02 	sts	0x02A6, r24
    300c:	80 91 ae 02 	lds	r24, 0x02AE
    3010:	83 30       	cpi	r24, 0x03	; 3
    3012:	39 f0       	breq	.+14     	; 0x3022 <PM_InterpretAVRISPPacket+0x178>
    3014:	83 e0       	ldi	r24, 0x03	; 3
    3016:	80 93 ae 02 	sts	0x02AE, r24
    301a:	10 92 46 01 	sts	0x0146, r1
    301e:	10 92 45 01 	sts	0x0145, r1
    3022:	80 91 45 01 	lds	r24, 0x0145
    3026:	90 91 46 01 	lds	r25, 0x0146
    302a:	27 31       	cpi	r18, 0x17	; 23
    302c:	49 f4       	brne	.+18     	; 0x3040 <PM_InterpretAVRISPPacket+0x196>
    302e:	9c 01       	movw	r18, r24
    3030:	22 0f       	add	r18, r18
    3032:	33 1f       	adc	r19, r19
    3034:	22 0f       	add	r18, r18
    3036:	33 1f       	adc	r19, r19
    3038:	2b 5c       	subi	r18, 0xCB	; 203
    303a:	3f 4f       	sbci	r19, 0xFF	; 255
    303c:	82 e0       	ldi	r24, 0x02	; 2
    303e:	08 c0       	rjmp	.+16     	; 0x3050 <PM_InterpretAVRISPPacket+0x1a6>
    3040:	9c 01       	movw	r18, r24
    3042:	22 0f       	add	r18, r18
    3044:	33 1f       	adc	r19, r19
    3046:	22 0f       	add	r18, r18
    3048:	33 1f       	adc	r19, r19
    304a:	23 5a       	subi	r18, 0xA3	; 163
    304c:	3f 4f       	sbci	r19, 0xFF	; 255
    304e:	83 e0       	ldi	r24, 0x03	; 3
    3050:	80 93 02 01 	sts	0x0102, r24
    3054:	80 91 45 01 	lds	r24, 0x0145
    3058:	90 91 46 01 	lds	r25, 0x0146
    305c:	0a 97       	sbiw	r24, 0x0a	; 10
    305e:	b0 f4       	brcc	.+44     	; 0x308c <PM_InterpretAVRISPPacket+0x1e2>
    3060:	e2 e9       	ldi	r30, 0x92	; 146
    3062:	f1 e0       	ldi	r31, 0x01	; 1

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    3064:	81 91       	ld	r24, Z+
    3066:	d9 01       	movw	r26, r18
    3068:	08 2e       	mov	r0, r24
    306a:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
    306e:	2f 5f       	subi	r18, 0xFF	; 255
    3070:	3f 4f       	sbci	r19, 0xFF	; 255
    3072:	81 e0       	ldi	r24, 0x01	; 1
    3074:	e6 39       	cpi	r30, 0x96	; 150
    3076:	f8 07       	cpc	r31, r24
    3078:	a9 f7       	brne	.-22     	; 0x3064 <PM_InterpretAVRISPPacket+0x1ba>
    307a:	80 91 45 01 	lds	r24, 0x0145
    307e:	90 91 46 01 	lds	r25, 0x0146
    3082:	01 96       	adiw	r24, 0x01	; 1
    3084:	90 93 46 01 	sts	0x0146, r25
    3088:	80 93 45 01 	sts	0x0145, r24
    308c:	10 92 92 01 	sts	0x0192, r1
    3090:	10 92 93 01 	sts	0x0193, r1
    3094:	2a c1       	rjmp	.+596    	; 0x32ea <PM_InterpretAVRISPPacket+0x440>
    3096:	84 e0       	ldi	r24, 0x04	; 4
    3098:	90 e0       	ldi	r25, 0x00	; 0
    309a:	90 93 a7 02 	sts	0x02A7, r25
    309e:	80 93 a6 02 	sts	0x02A6, r24
    30a2:	80 91 ae 02 	lds	r24, 0x02AE
    30a6:	84 30       	cpi	r24, 0x04	; 4
    30a8:	49 f0       	breq	.+18     	; 0x30bc <PM_InterpretAVRISPPacket+0x212>
    30aa:	0e 94 7f 14 	call	0x28fe	; 0x28fe <PM_CheckEndOfFuseLockData>
    30ae:	10 92 46 01 	sts	0x0146, r1
    30b2:	10 92 45 01 	sts	0x0145, r1
    30b6:	84 e0       	ldi	r24, 0x04	; 4
    30b8:	80 93 ae 02 	sts	0x02AE, r24
    30bc:	40 91 45 01 	lds	r20, 0x0145
    30c0:	50 91 46 01 	lds	r21, 0x0146
    30c4:	60 91 91 01 	lds	r22, 0x0191
    30c8:	68 31       	cpi	r22, 0x18	; 24
    30ca:	19 f0       	breq	.+6      	; 0x30d2 <PM_InterpretAVRISPPacket+0x228>
    30cc:	a4 e3       	ldi	r26, 0x34	; 52
    30ce:	b0 e0       	ldi	r27, 0x00	; 0
    30d0:	02 c0       	rjmp	.+4      	; 0x30d6 <PM_InterpretAVRISPPacket+0x22c>
    30d2:	a3 e3       	ldi	r26, 0x33	; 51
    30d4:	b0 e0       	ldi	r27, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    30d6:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
    30da:	80 2d       	mov	r24, r0
    30dc:	99 27       	eor	r25, r25
    30de:	84 17       	cp	r24, r20
    30e0:	95 07       	cpc	r25, r21
    30e2:	10 f4       	brcc	.+4      	; 0x30e8 <PM_InterpretAVRISPPacket+0x23e>
    30e4:	8f ef       	ldi	r24, 0xFF	; 255
    30e6:	1e c0       	rjmp	.+60     	; 0x3124 <PM_InterpretAVRISPPacket+0x27a>
    30e8:	80 91 92 01 	lds	r24, 0x0192
    30ec:	81 50       	subi	r24, 0x01	; 1
    30ee:	24 2f       	mov	r18, r20
    30f0:	33 27       	eor	r19, r19
    30f2:	99 27       	eor	r25, r25
    30f4:	68 31       	cpi	r22, 0x18	; 24
    30f6:	51 f4       	brne	.+20     	; 0x310c <PM_InterpretAVRISPPacket+0x262>
    30f8:	d9 01       	movw	r26, r18
    30fa:	aa 0f       	add	r26, r26
    30fc:	bb 1f       	adc	r27, r27
    30fe:	aa 0f       	add	r26, r26
    3100:	bb 1f       	adc	r27, r27
    3102:	a8 0f       	add	r26, r24
    3104:	b9 1f       	adc	r27, r25
    3106:	ab 5c       	subi	r26, 0xCB	; 203
    3108:	bf 4f       	sbci	r27, 0xFF	; 255
    310a:	09 c0       	rjmp	.+18     	; 0x311e <PM_InterpretAVRISPPacket+0x274>
    310c:	d9 01       	movw	r26, r18
    310e:	aa 0f       	add	r26, r26
    3110:	bb 1f       	adc	r27, r27
    3112:	aa 0f       	add	r26, r26
    3114:	bb 1f       	adc	r27, r27
    3116:	a8 0f       	add	r26, r24
    3118:	b9 1f       	adc	r27, r25
    311a:	a3 5a       	subi	r26, 0xA3	; 163
    311c:	bf 4f       	sbci	r27, 0xFF	; 255
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    311e:	0e 94 89 1a 	call	0x3512	; 0x3512 <__eeprom_read_byte_1F2021>
    3122:	80 2d       	mov	r24, r0
    3124:	80 93 93 01 	sts	0x0193, r24
    3128:	4f 5f       	subi	r20, 0xFF	; 255
    312a:	5f 4f       	sbci	r21, 0xFF	; 255
    312c:	50 93 46 01 	sts	0x0146, r21
    3130:	40 93 45 01 	sts	0x0145, r20
    3134:	10 92 92 01 	sts	0x0192, r1
    3138:	60 cf       	rjmp	.-320    	; 0x2ffa <PM_InterpretAVRISPPacket+0x150>
    313a:	82 e0       	ldi	r24, 0x02	; 2
    313c:	90 e0       	ldi	r25, 0x00	; 0
    313e:	90 93 a7 02 	sts	0x02A7, r25
    3142:	80 93 a6 02 	sts	0x02A6, r24
    3146:	80 91 ae 02 	lds	r24, 0x02AE
    314a:	81 30       	cpi	r24, 0x01	; 1
    314c:	11 f1       	breq	.+68     	; 0x3192 <PM_InterpretAVRISPPacket+0x2e8>
    314e:	23 31       	cpi	r18, 0x13	; 19
    3150:	31 f4       	brne	.+12     	; 0x315e <PM_InterpretAVRISPPacket+0x2b4>
    3152:	81 e0       	ldi	r24, 0x01	; 1
    3154:	0e 94 44 14 	call	0x2888	; 0x2888 <PM_SetupDFAddressCounters>
    3158:	c3 e0       	ldi	r28, 0x03	; 3
    315a:	d0 e0       	ldi	r29, 0x00	; 0
    315c:	05 c0       	rjmp	.+10     	; 0x3168 <PM_InterpretAVRISPPacket+0x2be>
    315e:	80 e0       	ldi	r24, 0x00	; 0
    3160:	0e 94 44 14 	call	0x2888	; 0x2888 <PM_SetupDFAddressCounters>
    3164:	cd e0       	ldi	r28, 0x0D	; 13
    3166:	d0 e0       	ldi	r29, 0x00	; 0
    3168:	80 91 45 01 	lds	r24, 0x0145
    316c:	90 91 46 01 	lds	r25, 0x0146
    3170:	0e 94 cc 0a 	call	0x1598	; 0x1598 <DF_BufferWriteEnable>
    3174:	81 e0       	ldi	r24, 0x01	; 1
    3176:	80 93 ae 02 	sts	0x02AE, r24
    317a:	e2 e9       	ldi	r30, 0x92	; 146
    317c:	f1 e0       	ldi	r31, 0x01	; 1

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    317e:	81 91       	ld	r24, Z+
    3180:	de 01       	movw	r26, r28
    3182:	08 2e       	mov	r0, r24
    3184:	0e 94 9b 1a 	call	0x3536	; 0x3536 <__eeprom_write_byte_1F2021>
    3188:	21 96       	adiw	r28, 0x01	; 1
    318a:	91 e0       	ldi	r25, 0x01	; 1
    318c:	eb 39       	cpi	r30, 0x9B	; 155
    318e:	f9 07       	cpc	r31, r25
    3190:	b1 f7       	brne	.-20     	; 0x317e <PM_InterpretAVRISPPacket+0x2d4>
    3192:	80 91 92 01 	lds	r24, 0x0192
    3196:	99 27       	eor	r25, r25
    3198:	d8 2f       	mov	r29, r24
    319a:	cc 27       	eor	r28, r28
    319c:	80 91 93 01 	lds	r24, 0x0193
    31a0:	99 27       	eor	r25, r25
    31a2:	c8 2b       	or	r28, r24
    31a4:	d9 2b       	or	r29, r25
    31a6:	01 e9       	ldi	r16, 0x91	; 145
    31a8:	11 e0       	ldi	r17, 0x01	; 1
    31aa:	06 c0       	rjmp	.+12     	; 0x31b8 <PM_InterpretAVRISPPacket+0x30e>
    31ac:	f8 01       	movw	r30, r16
    31ae:	82 85       	ldd	r24, Z+10	; 0x0a
    31b0:	0e 94 19 15 	call	0x2a32	; 0x2a32 <PM_StoreProgramByte>
    31b4:	0f 5f       	subi	r16, 0xFF	; 255
    31b6:	1f 4f       	sbci	r17, 0xFF	; 255
    31b8:	ce 01       	movw	r24, r28
    31ba:	8f 56       	subi	r24, 0x6F	; 111
    31bc:	9e 4f       	sbci	r25, 0xFE	; 254
    31be:	08 17       	cp	r16, r24
    31c0:	19 07       	cpc	r17, r25
    31c2:	a1 f7       	brne	.-24     	; 0x31ac <PM_InterpretAVRISPPacket+0x302>
    31c4:	20 91 af 02 	lds	r18, 0x02AF
    31c8:	30 91 b0 02 	lds	r19, 0x02B0
    31cc:	37 fd       	sbrc	r19, 7
    31ce:	cd ce       	rjmp	.-614    	; 0x2f6a <PM_InterpretAVRISPPacket+0xc0>
    31d0:	80 91 94 01 	lds	r24, 0x0194
    31d4:	87 ff       	sbrs	r24, 7
    31d6:	c9 ce       	rjmp	.-622    	; 0x2f6a <PM_InterpretAVRISPPacket+0xc0>
    31d8:	21 15       	cp	r18, r1
    31da:	31 05       	cpc	r19, r1
    31dc:	09 f4       	brne	.+2      	; 0x31e0 <PM_InterpretAVRISPPacket+0x336>
    31de:	c5 ce       	rjmp	.-630    	; 0x2f6a <PM_InterpretAVRISPPacket+0xc0>
    31e0:	80 91 02 01 	lds	r24, 0x0102
    31e4:	81 30       	cpi	r24, 0x01	; 1
    31e6:	19 f4       	brne	.+6      	; 0x31ee <PM_InterpretAVRISPPacket+0x344>
    31e8:	a5 e8       	ldi	r26, 0x85	; 133
    31ea:	b0 e0       	ldi	r27, 0x00	; 0
    31ec:	02 c0       	rjmp	.+4      	; 0x31f2 <PM_InterpretAVRISPPacket+0x348>
    31ee:	a7 e8       	ldi	r26, 0x87	; 135
    31f0:	b0 e0       	ldi	r27, 0x00	; 0

void 
eeprom_write_word (uint16_t *addr,uint16_t value)
{
  asm volatile (
    31f2:	09 01       	movw	r0, r18
    31f4:	0e 94 a7 1a 	call	0x354e	; 0x354e <__eeprom_write_word_1F2021>
    31f8:	80 91 af 02 	lds	r24, 0x02AF
    31fc:	90 91 b0 02 	lds	r25, 0x02B0
    3200:	90 68       	ori	r25, 0x80	; 128
    3202:	90 93 b0 02 	sts	0x02B0, r25
    3206:	80 93 af 02 	sts	0x02AF, r24
    320a:	af ce       	rjmp	.-674    	; 0x2f6a <PM_InterpretAVRISPPacket+0xc0>
    320c:	80 91 ae 02 	lds	r24, 0x02AE
    3210:	82 30       	cpi	r24, 0x02	; 2
    3212:	01 f1       	breq	.+64     	; 0x3254 <PM_InterpretAVRISPPacket+0x3aa>
    3214:	0e 94 7f 14 	call	0x28fe	; 0x28fe <PM_CheckEndOfFuseLockData>
    3218:	90 e0       	ldi	r25, 0x00	; 0
    321a:	80 91 91 01 	lds	r24, 0x0191
    321e:	84 31       	cpi	r24, 0x14	; 20
    3220:	09 f4       	brne	.+2      	; 0x3224 <PM_InterpretAVRISPPacket+0x37a>
    3222:	91 e0       	ldi	r25, 0x01	; 1
    3224:	89 2f       	mov	r24, r25
    3226:	0e 94 44 14 	call	0x2888	; 0x2888 <PM_SetupDFAddressCounters>
    322a:	60 91 45 01 	lds	r22, 0x0145
    322e:	70 91 46 01 	lds	r23, 0x0146
    3232:	80 91 43 01 	lds	r24, 0x0143
    3236:	90 91 44 01 	lds	r25, 0x0144
    323a:	0e 94 91 0a 	call	0x1522	; 0x1522 <DF_ContinuousReadEnable>
    323e:	82 e0       	ldi	r24, 0x02	; 2
    3240:	80 93 ae 02 	sts	0x02AE, r24
    3244:	10 92 a9 02 	sts	0x02A9, r1
    3248:	10 92 aa 02 	sts	0x02AA, r1
    324c:	10 92 ab 02 	sts	0x02AB, r1
    3250:	10 92 ac 02 	sts	0x02AC, r1
    3254:	80 91 92 01 	lds	r24, 0x0192
    3258:	99 27       	eor	r25, r25
    325a:	d8 2f       	mov	r29, r24
    325c:	cc 27       	eor	r28, r28
    325e:	80 91 93 01 	lds	r24, 0x0193
    3262:	99 27       	eor	r25, r25
    3264:	c8 2b       	or	r28, r24
    3266:	d9 2b       	or	r29, r25
    3268:	90 e0       	ldi	r25, 0x00	; 0
    326a:	80 91 91 01 	lds	r24, 0x0191
    326e:	84 31       	cpi	r24, 0x14	; 20
    3270:	09 f4       	brne	.+2      	; 0x3274 <PM_InterpretAVRISPPacket+0x3ca>
    3272:	91 e0       	ldi	r25, 0x01	; 1
    3274:	89 2f       	mov	r24, r25
    3276:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <PM_GetStoredDataSize>
    327a:	7b 01       	movw	r14, r22
    327c:	01 e9       	ldi	r16, 0x91	; 145
    327e:	11 e0       	ldi	r17, 0x01	; 1
    3280:	1b c0       	rjmp	.+54     	; 0x32b8 <PM_InterpretAVRISPPacket+0x40e>
    3282:	97 01       	movw	r18, r14
    3284:	44 27       	eor	r20, r20
    3286:	55 27       	eor	r21, r21
    3288:	80 91 a9 02 	lds	r24, 0x02A9
    328c:	90 91 aa 02 	lds	r25, 0x02AA
    3290:	a0 91 ab 02 	lds	r26, 0x02AB
    3294:	b0 91 ac 02 	lds	r27, 0x02AC
    3298:	82 17       	cp	r24, r18
    329a:	93 07       	cpc	r25, r19
    329c:	a4 07       	cpc	r26, r20
    329e:	b5 07       	cpc	r27, r21
    32a0:	10 f0       	brcs	.+4      	; 0x32a6 <PM_InterpretAVRISPPacket+0x3fc>
    32a2:	8f ef       	ldi	r24, 0xFF	; 255
    32a4:	03 c0       	rjmp	.+6      	; 0x32ac <PM_InterpretAVRISPPacket+0x402>
    32a6:	80 e0       	ldi	r24, 0x00	; 0
    32a8:	0e 94 b4 09 	call	0x1368	; 0x1368 <SPI_SPITransmit>
    32ac:	f8 01       	movw	r30, r16
    32ae:	82 83       	std	Z+2, r24	; 0x02
    32b0:	0e 94 dc 0e 	call	0x1db8	; 0x1db8 <V2P_IncrementCurrAddress>
    32b4:	0f 5f       	subi	r16, 0xFF	; 255
    32b6:	1f 4f       	sbci	r17, 0xFF	; 255
    32b8:	ce 01       	movw	r24, r28
    32ba:	8f 56       	subi	r24, 0x6F	; 111
    32bc:	9e 4f       	sbci	r25, 0xFE	; 254
    32be:	08 17       	cp	r16, r24
    32c0:	19 07       	cpc	r17, r25
    32c2:	f9 f6       	brne	.-66     	; 0x3282 <PM_InterpretAVRISPPacket+0x3d8>
    32c4:	23 96       	adiw	r28, 0x03	; 3
    32c6:	d0 93 a7 02 	sts	0x02A7, r29
    32ca:	c0 93 a6 02 	sts	0x02A6, r28
    32ce:	10 92 92 01 	sts	0x0192, r1
    32d2:	f8 01       	movw	r30, r16
    32d4:	12 82       	std	Z+2, r1	; 0x02
    32d6:	09 c0       	rjmp	.+18     	; 0x32ea <PM_InterpretAVRISPPacket+0x440>
    32d8:	81 e0       	ldi	r24, 0x01	; 1
    32da:	90 e0       	ldi	r25, 0x00	; 0
    32dc:	90 93 a7 02 	sts	0x02A7, r25
    32e0:	80 93 a6 02 	sts	0x02A6, r24
    32e4:	89 ec       	ldi	r24, 0xC9	; 201
    32e6:	80 93 92 01 	sts	0x0192, r24
    32ea:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <V2P_SendPacket>
    32ee:	df 91       	pop	r29
    32f0:	cf 91       	pop	r28
    32f2:	1f 91       	pop	r17
    32f4:	0f 91       	pop	r16
    32f6:	ff 90       	pop	r15
    32f8:	ef 90       	pop	r14
    32fa:	08 95       	ret

000032fc <TM_FindNextTag>:
	DF_EnableDataflash(FALSE);
}

void TM_FindNextTag(void)
{
    32fc:	cf 92       	push	r12
    32fe:	df 92       	push	r13
    3300:	ef 92       	push	r14
    3302:	ff 92       	push	r15
    3304:	0f 93       	push	r16
    3306:	1f 93       	push	r17
    3308:	cf 93       	push	r28
    330a:	df 93       	push	r29
    330c:	cd b7       	in	r28, 0x3d	; 61
    330e:	de b7       	in	r29, 0x3e	; 62
    3310:	69 97       	sbiw	r28, 0x19	; 25
    3312:	0f b6       	in	r0, 0x3f	; 63
    3314:	f8 94       	cli
    3316:	de bf       	out	0x3e, r29	; 62
    3318:	0f be       	out	0x3f, r0	; 63
    331a:	cd bf       	out	0x3d, r28	; 61
	uint8_t  Buffer[21];
	uint8_t  HeadBuff[4]      = BT_TAGHEADER;
    331c:	80 e4       	ldi	r24, 0x40	; 64
    331e:	89 83       	std	Y+1, r24	; 0x01
    3320:	88 e2       	ldi	r24, 0x28	; 40
    3322:	8a 83       	std	Y+2, r24	; 0x02
    3324:	83 e2       	ldi	r24, 0x23	; 35
    3326:	8b 83       	std	Y+3, r24	; 0x03
    3328:	89 e2       	ldi	r24, 0x29	; 41
    332a:	8c 83       	std	Y+4, r24	; 0x04
	uint32_t ProgDataSize     = PM_GetStoredDataSize(TYPE_FLASH);
    332c:	81 e0       	ldi	r24, 0x01	; 1
    332e:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <PM_GetStoredDataSize>
    3332:	6b 01       	movw	r12, r22
    3334:	7c 01       	movw	r14, r24
	uint8_t  TotalOkHeadBytes = 0;
	uint8_t  TagByte;
	uint8_t  BytesRead;
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);    // Orange = busy
    3336:	81 b3       	in	r24, 0x11	; 17
    3338:	8f 7c       	andi	r24, 0xCF	; 207
    333a:	80 63       	ori	r24, 0x30	; 48
    333c:	81 bb       	out	0x11, r24	; 17

	while (DFPos < ProgDataSize)
	{
		BytesRead = 1;
		
		TagByte = SPI_SPITransmit(0x00);       // Get next byte from dataflash
		if (TagByte == HeadBuff[TotalOkHeadBytes++])
		{
			if (TotalOkHeadBytes == 4)
			{
				uint8_t HB;
			
				for (HB = 0; HB < 20; HB++)
				{
					TagByte = SPI_SPITransmit(0x00);
					Buffer[HB] = TagByte;
					
					if (TagByte == 0x00)
					  break;
				}
				
				Buffer[20] = '\0';             // Make sure string is null-terminated

				TagExists = TRUE;
				BytesRead = (HB + 2);

				LCD_puts(Buffer);
				MAIN_SETSTATUSLED(MAIN_STATLED_GREEN); // Green = ready
				return;
			}
		}
		else
		{
			TotalOkHeadBytes = ((TagByte == HeadBuff[0])? 1 : 0);
    333e:	09 81       	ldd	r16, Y+1	; 0x01
    3340:	10 e0       	ldi	r17, 0x00	; 0
    3342:	42 c0       	rjmp	.+132    	; 0x33c8 <TM_FindNextTag+0xcc>
    3344:	80 e0       	ldi	r24, 0x00	; 0
    3346:	0e 94 b4 09 	call	0x1368	; 0x1368 <SPI_SPITransmit>
    334a:	98 2f       	mov	r25, r24
    334c:	fe 01       	movw	r30, r28
    334e:	e1 0f       	add	r30, r17
    3350:	f1 1d       	adc	r31, r1
    3352:	81 81       	ldd	r24, Z+1	; 0x01
    3354:	98 17       	cp	r25, r24
    3356:	09 f5       	brne	.+66     	; 0x339a <TM_FindNextTag+0x9e>
    3358:	1f 5f       	subi	r17, 0xFF	; 255
    335a:	14 30       	cpi	r17, 0x04	; 4
    335c:	11 f5       	brne	.+68     	; 0x33a2 <TM_FindNextTag+0xa6>
    335e:	8e 01       	movw	r16, r28
    3360:	0b 5f       	subi	r16, 0xFB	; 251
    3362:	1f 4f       	sbci	r17, 0xFF	; 255
    3364:	80 e0       	ldi	r24, 0x00	; 0
    3366:	0e 94 b4 09 	call	0x1368	; 0x1368 <SPI_SPITransmit>
    336a:	f8 01       	movw	r30, r16
    336c:	80 83       	st	Z, r24
    336e:	88 23       	and	r24, r24
    3370:	39 f0       	breq	.+14     	; 0x3380 <TM_FindNextTag+0x84>
    3372:	0f 5f       	subi	r16, 0xFF	; 255
    3374:	1f 4f       	sbci	r17, 0xFF	; 255
    3376:	ce 01       	movw	r24, r28
    3378:	49 96       	adiw	r24, 0x19	; 25
    337a:	08 17       	cp	r16, r24
    337c:	19 07       	cpc	r17, r25
    337e:	91 f7       	brne	.-28     	; 0x3364 <TM_FindNextTag+0x68>
    3380:	19 8e       	std	Y+25, r1	; 0x19
    3382:	81 e0       	ldi	r24, 0x01	; 1
    3384:	80 93 b1 02 	sts	0x02B1, r24
    3388:	ce 01       	movw	r24, r28
    338a:	05 96       	adiw	r24, 0x05	; 5
    338c:	0e 94 81 08 	call	0x1102	; 0x1102 <LCD_puts>
    3390:	81 b3       	in	r24, 0x11	; 17
    3392:	8f 7c       	andi	r24, 0xCF	; 207
    3394:	80 61       	ori	r24, 0x10	; 16
    3396:	81 bb       	out	0x11, r24	; 17
    3398:	42 c0       	rjmp	.+132    	; 0x341e <TM_FindNextTag+0x122>
    339a:	10 e0       	ldi	r17, 0x00	; 0
    339c:	90 17       	cp	r25, r16
    339e:	09 f4       	brne	.+2      	; 0x33a2 <TM_FindNextTag+0xa6>
    33a0:	11 e0       	ldi	r17, 0x01	; 1
		}

		DFPos += BytesRead;
    33a2:	80 91 b2 02 	lds	r24, 0x02B2
    33a6:	90 91 b3 02 	lds	r25, 0x02B3
    33aa:	a0 91 b4 02 	lds	r26, 0x02B4
    33ae:	b0 91 b5 02 	lds	r27, 0x02B5
    33b2:	01 96       	adiw	r24, 0x01	; 1
    33b4:	a1 1d       	adc	r26, r1
    33b6:	b1 1d       	adc	r27, r1
    33b8:	80 93 b2 02 	sts	0x02B2, r24
    33bc:	90 93 b3 02 	sts	0x02B3, r25
    33c0:	a0 93 b4 02 	sts	0x02B4, r26
    33c4:	b0 93 b5 02 	sts	0x02B5, r27
    33c8:	80 91 b2 02 	lds	r24, 0x02B2
    33cc:	90 91 b3 02 	lds	r25, 0x02B3
    33d0:	a0 91 b4 02 	lds	r26, 0x02B4
    33d4:	b0 91 b5 02 	lds	r27, 0x02B5
    33d8:	8c 15       	cp	r24, r12
    33da:	9d 05       	cpc	r25, r13
    33dc:	ae 05       	cpc	r26, r14
    33de:	bf 05       	cpc	r27, r15
    33e0:	08 f4       	brcc	.+2      	; 0x33e4 <TM_FindNextTag+0xe8>
    33e2:	b0 cf       	rjmp	.-160    	; 0x3344 <TM_FindNextTag+0x48>
	}
	
	DF_ContinuousReadEnable(0, 0);
    33e4:	60 e0       	ldi	r22, 0x00	; 0
    33e6:	70 e0       	ldi	r23, 0x00	; 0
    33e8:	80 e0       	ldi	r24, 0x00	; 0
    33ea:	90 e0       	ldi	r25, 0x00	; 0
    33ec:	0e 94 91 0a 	call	0x1522	; 0x1522 <DF_ContinuousReadEnable>
	DFPos = 0;
    33f0:	10 92 b2 02 	sts	0x02B2, r1
    33f4:	10 92 b3 02 	sts	0x02B3, r1
    33f8:	10 92 b4 02 	sts	0x02B4, r1
    33fc:	10 92 b5 02 	sts	0x02B5, r1
	
	if (TagExists == FALSE)
    3400:	80 91 b1 02 	lds	r24, 0x02B1
    3404:	88 23       	and	r24, r24
    3406:	49 f4       	brne	.+18     	; 0x341a <TM_FindNextTag+0x11e>
	{
		MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);  // Green = ready
    3408:	81 b3       	in	r24, 0x11	; 17
    340a:	8f 7c       	andi	r24, 0xCF	; 207
    340c:	80 61       	ori	r24, 0x10	; 16
    340e:	81 bb       	out	0x11, r24	; 17
		MAIN_ShowError(PSTR("NO TAGS"));
    3410:	8e e5       	ldi	r24, 0x5E	; 94
    3412:	94 e0       	ldi	r25, 0x04	; 4
    3414:	0e 94 c3 03 	call	0x786	; 0x786 <MAIN_ShowError>
    3418:	02 c0       	rjmp	.+4      	; 0x341e <TM_FindNextTag+0x122>
	}
	else
	{
		/* The following line _is_ recursion, but the function will only ever call itself
		   a maximum of one time. The function will call itself upon skipping from the last
		   tag stored in the program data to the first; to guard against infinite recursion
		   if no tags are present, the system will error out if the TagExists flag is empty
		   after a full data read. Once a tag has been read and displayed onto the LCD, the
           function returns to the main tag handling routine.                               */
		TM_FindNextTag();
    341a:	0e 94 7e 19 	call	0x32fc	; 0x32fc <TM_FindNextTag>
    341e:	69 96       	adiw	r28, 0x19	; 25
    3420:	0f b6       	in	r0, 0x3f	; 63
    3422:	f8 94       	cli
    3424:	de bf       	out	0x3e, r29	; 62
    3426:	0f be       	out	0x3f, r0	; 63
    3428:	cd bf       	out	0x3d, r28	; 61
    342a:	df 91       	pop	r29
    342c:	cf 91       	pop	r28
    342e:	1f 91       	pop	r17
    3430:	0f 91       	pop	r16
    3432:	ff 90       	pop	r15
    3434:	ef 90       	pop	r14
    3436:	df 90       	pop	r13
    3438:	cf 90       	pop	r12
    343a:	08 95       	ret

0000343c <TM_ShowTags>:
    343c:	60 e0       	ldi	r22, 0x00	; 0
    343e:	70 e0       	ldi	r23, 0x00	; 0
    3440:	80 e0       	ldi	r24, 0x00	; 0
    3442:	90 e0       	ldi	r25, 0x00	; 0
    3444:	0e 94 91 0a 	call	0x1522	; 0x1522 <DF_ContinuousReadEnable>
    3448:	10 92 b1 02 	sts	0x02B1, r1
    344c:	10 92 b2 02 	sts	0x02B2, r1
    3450:	10 92 b3 02 	sts	0x02B3, r1
    3454:	10 92 b4 02 	sts	0x02B4, r1
    3458:	10 92 b5 02 	sts	0x02B5, r1
    345c:	0e 94 7e 19 	call	0x32fc	; 0x32fc <TM_FindNextTag>
    3460:	80 91 b1 02 	lds	r24, 0x02B1
    3464:	88 23       	and	r24, r24
    3466:	71 f0       	breq	.+28     	; 0x3484 <TM_ShowTags+0x48>
    3468:	8e b3       	in	r24, 0x1e	; 30
    346a:	88 23       	and	r24, r24
    346c:	e9 f3       	breq	.-6      	; 0x3468 <TM_ShowTags+0x2c>
    346e:	f7 9b       	sbis	0x1e, 7	; 30
    3470:	03 c0       	rjmp	.+6      	; 0x3478 <TM_ShowTags+0x3c>
    3472:	0e 94 7e 19 	call	0x32fc	; 0x32fc <TM_FindNextTag>
    3476:	02 c0       	rjmp	.+4      	; 0x347c <TM_ShowTags+0x40>
    3478:	f2 99       	sbic	0x1e, 2	; 30
    347a:	03 c0       	rjmp	.+6      	; 0x3482 <TM_ShowTags+0x46>
    347c:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
    3480:	f3 cf       	rjmp	.-26     	; 0x3468 <TM_ShowTags+0x2c>
    3482:	80 e0       	ldi	r24, 0x00	; 0
    3484:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <DF_EnableDataflash>
    3488:	08 95       	ret

0000348a <__vector_2>:
.global PCINT0_vect             ; Pin change 0 (joystick)
.global PCINT1_vect             ; Pin change 1 (joystick)

PCINT0_vect:
  jmp PCINT1_vect
    348a:	0c 94 bb 02 	jmp	0x576	; 0x576 <__vector_3>

0000348e <__vector_10>:

.global TIMER0_COMP_vect             ; Timer 0 compare

TIMER0_COMP_vect:
  push r24
    348e:	8f 93       	push	r24
  ldi r24, (USI_CONTROL_REG_FLAGS | (1<<USITC))
    3490:	8b e5       	ldi	r24, 0x5B	; 91
  sts _SFR_MEM_ADDR(USICR), r24
    3492:	80 93 b8 00 	sts	0x00B8, r24
  pop r24
    3496:	8f 91       	pop	r24
  reti
    3498:	18 95       	reti

0000349a <strcpy_P>:
    349a:	fb 01       	movw	r30, r22
    349c:	dc 01       	movw	r26, r24
    349e:	05 90       	lpm	r0, Z+
    34a0:	0d 92       	st	X+, r0
    34a2:	00 20       	and	r0, r0
    34a4:	e1 f7       	brne	.-8      	; 0x349e <strcpy_P+0x4>
    34a6:	08 95       	ret

000034a8 <ultoa>:
    34a8:	fa 01       	movw	r30, r20
    34aa:	cf 93       	push	r28
    34ac:	ff 93       	push	r31
    34ae:	ef 93       	push	r30
    34b0:	22 30       	cpi	r18, 0x02	; 2
    34b2:	cc f0       	brlt	.+50     	; 0x34e6 <ultoa+0x3e>
    34b4:	25 32       	cpi	r18, 0x25	; 37
    34b6:	bc f4       	brge	.+46     	; 0x34e6 <ultoa+0x3e>
    34b8:	c2 2f       	mov	r28, r18
    34ba:	2c 2f       	mov	r18, r28
    34bc:	33 27       	eor	r19, r19
    34be:	44 27       	eor	r20, r20
    34c0:	55 27       	eor	r21, r21
    34c2:	ff 93       	push	r31
    34c4:	ef 93       	push	r30
    34c6:	0e 94 b1 1a 	call	0x3562	; 0x3562 <__udivmodsi4>
    34ca:	ef 91       	pop	r30
    34cc:	ff 91       	pop	r31
    34ce:	60 5d       	subi	r22, 0xD0	; 208
    34d0:	6a 33       	cpi	r22, 0x3A	; 58
    34d2:	0c f0       	brlt	.+2      	; 0x34d6 <ultoa+0x2e>
    34d4:	69 5d       	subi	r22, 0xD9	; 217
    34d6:	61 93       	st	Z+, r22
    34d8:	b9 01       	movw	r22, r18
    34da:	ca 01       	movw	r24, r20
    34dc:	60 50       	subi	r22, 0x00	; 0
    34de:	70 40       	sbci	r23, 0x00	; 0
    34e0:	80 40       	sbci	r24, 0x00	; 0
    34e2:	90 40       	sbci	r25, 0x00	; 0
    34e4:	51 f7       	brne	.-44     	; 0x34ba <ultoa+0x12>
    34e6:	10 82       	st	Z, r1
    34e8:	8f 91       	pop	r24
    34ea:	9f 91       	pop	r25
    34ec:	cf 91       	pop	r28
    34ee:	0c 94 79 1a 	jmp	0x34f2	; 0x34f2 <strrev>

000034f2 <strrev>:
    34f2:	dc 01       	movw	r26, r24
    34f4:	fc 01       	movw	r30, r24
    34f6:	01 90       	ld	r0, Z+
    34f8:	00 20       	and	r0, r0
    34fa:	e9 f7       	brne	.-6      	; 0x34f6 <strrev+0x4>
    34fc:	32 97       	sbiw	r30, 0x02	; 2
    34fe:	ae 17       	cp	r26, r30
    3500:	bf 07       	cpc	r27, r31
    3502:	30 f4       	brcc	.+12     	; 0x3510 <strrev+0x1e>
    3504:	7c 91       	ld	r23, X
    3506:	60 81       	ld	r22, Z
    3508:	70 83       	st	Z, r23
    350a:	31 97       	sbiw	r30, 0x01	; 1
    350c:	6d 93       	st	X+, r22
    350e:	f7 cf       	rjmp	.-18     	; 0x34fe <strrev+0xc>
    3510:	08 95       	ret

00003512 <__eeprom_read_byte_1F2021>:
    3512:	f9 99       	sbic	0x1f, 1	; 31
    3514:	fe cf       	rjmp	.-4      	; 0x3512 <__eeprom_read_byte_1F2021>
    3516:	b2 bd       	out	0x22, r27	; 34
    3518:	a1 bd       	out	0x21, r26	; 33
    351a:	f8 9a       	sbi	0x1f, 0	; 31
    351c:	11 96       	adiw	r26, 0x01	; 1
    351e:	00 b4       	in	r0, 0x20	; 32
    3520:	08 95       	ret

00003522 <__eeprom_read_block_1F2021>:
    3522:	f7 df       	rcall	.-18     	; 0x3512 <__eeprom_read_byte_1F2021>
    3524:	01 92       	st	Z+, r0
    3526:	1a 94       	dec	r1
    3528:	e1 f7       	brne	.-8      	; 0x3522 <__eeprom_read_block_1F2021>
    352a:	08 95       	ret

0000352c <__eeprom_read_word_1F2021>:
    352c:	f2 df       	rcall	.-28     	; 0x3512 <__eeprom_read_byte_1F2021>
    352e:	e0 2d       	mov	r30, r0
    3530:	f0 df       	rcall	.-32     	; 0x3512 <__eeprom_read_byte_1F2021>
    3532:	f0 2d       	mov	r31, r0
    3534:	08 95       	ret

00003536 <__eeprom_write_byte_1F2021>:
    3536:	f9 99       	sbic	0x1f, 1	; 31
    3538:	fe cf       	rjmp	.-4      	; 0x3536 <__eeprom_write_byte_1F2021>
    353a:	b2 bd       	out	0x22, r27	; 34
    353c:	a1 bd       	out	0x21, r26	; 33
    353e:	00 bc       	out	0x20, r0	; 32
    3540:	11 96       	adiw	r26, 0x01	; 1
    3542:	0f b6       	in	r0, 0x3f	; 63
    3544:	f8 94       	cli
    3546:	fa 9a       	sbi	0x1f, 2	; 31
    3548:	f9 9a       	sbi	0x1f, 1	; 31
    354a:	0f be       	out	0x3f, r0	; 63
    354c:	08 95       	ret

0000354e <__eeprom_write_word_1F2021>:
    354e:	f3 df       	rcall	.-26     	; 0x3536 <__eeprom_write_byte_1F2021>
    3550:	01 2c       	mov	r0, r1
    3552:	f1 df       	rcall	.-30     	; 0x3536 <__eeprom_write_byte_1F2021>
    3554:	11 24       	eor	r1, r1
    3556:	08 95       	ret

00003558 <__eeprom_write_block_1F2021>:
    3558:	01 90       	ld	r0, Z+
    355a:	ed df       	rcall	.-38     	; 0x3536 <__eeprom_write_byte_1F2021>
    355c:	1a 94       	dec	r1
    355e:	e1 f7       	brne	.-8      	; 0x3558 <__eeprom_write_block_1F2021>
    3560:	08 95       	ret

00003562 <__udivmodsi4>:
    3562:	a1 e2       	ldi	r26, 0x21	; 33
    3564:	1a 2e       	mov	r1, r26
    3566:	aa 1b       	sub	r26, r26
    3568:	bb 1b       	sub	r27, r27
    356a:	fd 01       	movw	r30, r26
    356c:	0d c0       	rjmp	.+26     	; 0x3588 <__udivmodsi4_ep>

0000356e <__udivmodsi4_loop>:
    356e:	aa 1f       	adc	r26, r26
    3570:	bb 1f       	adc	r27, r27
    3572:	ee 1f       	adc	r30, r30
    3574:	ff 1f       	adc	r31, r31
    3576:	a2 17       	cp	r26, r18
    3578:	b3 07       	cpc	r27, r19
    357a:	e4 07       	cpc	r30, r20
    357c:	f5 07       	cpc	r31, r21
    357e:	20 f0       	brcs	.+8      	; 0x3588 <__udivmodsi4_ep>
    3580:	a2 1b       	sub	r26, r18
    3582:	b3 0b       	sbc	r27, r19
    3584:	e4 0b       	sbc	r30, r20
    3586:	f5 0b       	sbc	r31, r21

00003588 <__udivmodsi4_ep>:
    3588:	66 1f       	adc	r22, r22
    358a:	77 1f       	adc	r23, r23
    358c:	88 1f       	adc	r24, r24
    358e:	99 1f       	adc	r25, r25
    3590:	1a 94       	dec	r1
    3592:	69 f7       	brne	.-38     	; 0x356e <__udivmodsi4_loop>
    3594:	60 95       	com	r22
    3596:	70 95       	com	r23
    3598:	80 95       	com	r24
    359a:	90 95       	com	r25
    359c:	9b 01       	movw	r18, r22
    359e:	ac 01       	movw	r20, r24
    35a0:	bd 01       	movw	r22, r26
    35a2:	cf 01       	movw	r24, r30
    35a4:	08 95       	ret

000035a6 <_exit>:
    35a6:	ff cf       	rjmp	.-2      	; 0x35a6 <_exit>
