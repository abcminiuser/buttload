
ButtLoad.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000026  00800100  0000378a  0000381e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000378a  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b0  00800126  00800126  00003844  2**0
                  ALLOC
  3 .noinit       00000000  008002d6  008002d6  00003844  2**0
                  CONTENTS
  4 .eeprom       00000000  00810000  00810000  00003844  2**0
                  CONTENTS
  5 .stab         00000084  00000000  00000000  00003844  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      00000078  00000000  00000000  000038c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000140  00000000  00000000  00003940  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000fa3  00000000  00000000  00003a80  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000034e5  00000000  00000000  00004a23  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00000e30  00000000  00000000  00007f08  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000030c7  00000000  00000000  00008d38  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00001165  00000000  00000000  0000bdff  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 12 02 	jmp	0x424 <__init>
       4:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
       8:	0c 94 40 1b 	jmp	0x3680 <__vector_2>
       c:	0c 94 96 03 	jmp	0x72c <__vector_3>
      10:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      14:	0c 94 8b 07 	jmp	0xf16 <__vector_5>
      18:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      1c:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      20:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      24:	0c 94 c7 0b 	jmp	0x178e <__vector_9>
      28:	0c 94 42 1b 	jmp	0x3684 <__vector_10>
      2c:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      30:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      34:	0c 94 12 09 	jmp	0x1224 <__vector_13>
      38:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      3c:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      40:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      44:	0c 94 57 09 	jmp	0x12ae <__vector_17>
      48:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      4c:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      50:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      54:	0c 94 2d 02 	jmp	0x45a <__bad_interrupt>
      58:	0c 94 48 08 	jmp	0x1090 <__vector_22>

0000005c <SIFOOptionPtrs>:
      5c:	6f 00 60 00                                         o.`.

00000060 <SIFO_Tags>:
      60:	56 49 45 57 20 44 41 54 41 20 54 41 47 53 00        VIEW DATA TAGS.

0000006f <SIFO_Size>:
      6f:	53 54 4f 52 41 47 45 20 53 49 5a 45 53 00           STORAGE SIZES.

0000007d <USIPSNamePtrs>:
      7d:	a3 00 99 00 8f 00 85 00                             ........

00000085 <USI_Speed3>:
      85:	32 31 30 36 35 31 20 48 5a 00                       210651 HZ.

0000008f <USI_Speed2>:
      8f:	31 31 33 34 32 37 20 48 5a 00                       113427 HZ.

00000099 <USI_Speed1>:
      99:	20 38 36 37 33 38 20 48 5a 00                        86738 HZ.

000000a3 <USI_Speed0>:
      a3:	20 35 37 31 35 33 20 48 5a 00                        57153 HZ.

000000ad <ProgOptions>:
      ad:	16 01 0a 01 fa 00 ea 00 da 00 c6 00 bb 00           ..............

000000bb <PRG_C>:
      bb:	45 52 41 53 45 20 4f 4e 4c 59 00                    ERASE ONLY.

000000c6 <PRG_FL>:
      c6:	46 55 53 45 20 41 4e 44 20 4c 4f 43 4b 20 42 59     FUSE AND LOCK BY
      d6:	54 45 53 00                                         TES.

000000da <PRG_L>:
      da:	4c 4f 43 4b 20 42 59 54 45 53 20 4f 4e 4c 59 00     LOCK BYTES ONLY.

000000ea <PRG_F>:
      ea:	46 55 53 45 20 42 59 54 45 53 20 4f 4e 4c 59 00     FUSE BYTES ONLY.

000000fa <PRG_DE>:
      fa:	44 41 54 41 20 41 4e 44 20 45 45 50 52 4f 4d 00     DATA AND EEPROM.

0000010a <PRG_E>:
     10a:	45 45 50 52 4f 4d 20 4f 4e 4c 59 00                 EEPROM ONLY.

00000116 <PRG_D>:
     116:	44 41 54 41 20 4f 4e 4c 59 00                       DATA ONLY.

00000120 <SettingFunctionPtrs>:
     120:	39 06 85 06 83 05 d8 05 df 05 2c 07                 9.........,.

0000012c <SettingFunctionNames>:
     12c:	88 01 7a 01 6d 01 5e 01 4b 01 38 01                 ..z.m.^.K.8.

00000138 <SFunc_GOBOOTLOADER>:
     138:	4a 55 4d 50 20 54 4f 20 42 4f 4f 54 4c 4f 41 44     JUMP TO BOOTLOAD
     148:	45 52 00                                            ER.

0000014b <SFunc_MANCALIB>:
     14b:	4d 41 4e 55 41 4c 20 43 41 4c 49 42 52 41 54 49     MANUAL CALIBRATI
     15b:	4f 4e 00                                            ON.

0000015e <SFunc_AUTOCALIB>:
     15e:	41 55 54 4f 20 43 41 4c 49 42 52 41 54 45 00        AUTO CALIBRATE.

0000016d <SFunc_CLEARMEM>:
     16d:	43 4c 45 41 52 20 4d 45 4d 4f 52 59 00              CLEAR MEMORY.

0000017a <SFunc_SETSPISPEED>:
     17a:	53 45 54 20 53 50 49 20 53 50 45 45 44 00           SET SPI SPEED.

00000188 <SFunc_SETCONTRAST>:
     188:	53 45 54 20 43 4f 4e 54 52 41 53 54 00              SET CONTRAST.

00000195 <MainFunctionPtrs>:
     195:	e7 03 5d 05 18 04 f4 03 d4 06 b2 03 ba 06           ..]...........

000001a3 <MainFunctionNames>:
     1a3:	ff 01 f4 01 e8 01 d4 01 c5 01 bc 01 b1 01           ..............

000001b1 <Func_SLEEP>:
     1b1:	53 4c 45 45 50 20 4d 4f 44 45 00                    SLEEP MODE.

000001bc <Func_SETTINGS>:
     1bc:	53 45 54 54 49 4e 47 53 00                          SETTINGS.

000001c5 <Func_PRGMSTOREINFO>:
     1c5:	44 41 54 41 53 54 4f 52 45 20 49 4e 46 4f 00        DATASTORE INFO.

000001d4 <Func_PRGMDATAFLASH>:
     1d4:	44 41 54 41 46 4c 41 53 48 20 50 52 47 4d 20 4d     DATAFLASH PRGM M
     1e4:	4f 44 45 00                                         ODE.

000001e8 <Func_PRGMAVR>:
     1e8:	50 52 4f 47 52 41 4d 20 41 56 52 00                 PROGRAM AVR.

000001f4 <Func_STOREPRGM>:
     1f4:	53 54 4f 52 45 20 50 52 47 4d 00                    STORE PRGM.

000001ff <Func_ISPPRGM>:
     1ff:	41 56 52 49 53 50 20 4d 4f 44 45 00                 AVRISP MODE.

0000020b <AboutTextPtrs>:
     20b:	36 02 31 02 22 02 13 02                             6.1."...

00000213 <CopyRight>:
     213:	3c 43 3e 20 32 30 30 36 20 2d 20 47 50 4c 00        <C> 2006 - GPL.

00000222 <AuthorName>:
     222:	42 59 20 44 45 41 4e 20 43 41 4d 45 52 41 00        BY DEAN CAMERA.

00000231 <VersionInfo>:
     231:	56 31 2d 33 00                                      V1-3.

00000236 <ProgrammerName>:
     236:	42 55 54 54 4c 4f 41 44 00                          BUTTLOAD.

0000023f <WaitText>:
     23f:	2a 57 41 49 54 2a 00                                *WAIT*.

00000246 <BUTTTAG_Author>:
     246:	40 28 23 29 42 59 20 44 45 41 4e 20 43 41 4d 45     @(#)BY DEAN CAME
     256:	52 41 00                                            RA.

00000259 <BUTTTAG_Name>:
     259:	40 28 23 29 42 55 54 54 4c 4f 41 44 20 41 56 52     @(#)BUTTLOAD AVR
     269:	49 53 50 00                                         ISP.

0000026d <__c.14>:
     26d:	50 52 47 3e 20 00                                   PRG> .

00000273 <__c.13>:
     273:	42 41 44 49 53 52 00                                BADISR.

0000027a <__c.6>:
     27a:	4e 4f 20 45 52 41 53 45 20 43 4d 44 00              NO ERASE CMD.

00000287 <__c.7>:
     287:	4e 4f 20 44 41 54 41 00                             NO DATA.

0000028f <__c.8>:
     28f:	4e 4f 20 45 45 50 52 4f 4d 00                       NO EEPROM.

00000299 <__c.9>:
     299:	4e 4f 20 46 55 53 45 20 42 59 54 45 53 00           NO FUSE BYTES.

000002a7 <__c.10>:
     2a7:	4e 4f 20 4c 4f 43 4b 20 42 59 54 45 53 00           NO LOCK BYTES.

000002b5 <__c.11>:
     2b5:	50 52 4f 47 52 41 4d 4d 49 4e 47 20 44 4f 4e 45     PROGRAMMING DONE
	...

000002c6 <__c.12>:
     2c6:	46 41 49 4c 45 44 00                                FAILED.

000002cd <__c.5>:
     2cd:	2a 53 54 4f 52 41 47 45 20 4d 4f 44 45 2a 00        *STORAGE MODE*.

000002dc <__c.2>:
     2dc:	43 4f 4e 46 49 52 4d 00                             CONFIRM.

000002e4 <__c.3>:
     2e4:	3c 4e 20 59 3e 00                                   <N Y>.

000002ea <__c.4>:
     2ea:	4d 45 4d 20 43 4c 45 41 52 45 44 00                 MEM CLEARED.

000002f6 <__c.1>:
     2f6:	4e 4f 20 53 54 4f 52 45 44 20 50 52 47 4d 00        NO STORED PRGM.

00000305 <__c.0>:
     305:	2a 4a 54 41 47 20 4f 4e 2a 00                       *JTAG ON*.

0000030f <LCD_SegTable>:
     30f:	a8 ea 80 2a 00 40 00 0a 51 0a 08 40 59 55 18 01     ...*.@..Q..@YU..
     31f:	11 1e 11 1b 50 0b 41 1b 41 1f 11 01 51 1f 51 1b     ....P.A.A...Q.Q.
     32f:	00 00 00 00 08 80 00 1a 20 40 00 00 00 00 51 0f     ........ @....Q.
     33f:	91 39 41 14 91 31 41 1e 41 0e 41 1d 50 0f 80 20     .9A..1A.A.A.P.. 
     34f:	10 15 48 86 40 14 78 05 70 85 51 15 51 0e 51 95     ..H.@.x.p.Q.Q.Q.
     35f:	51 8e 21 90 81 20 50 15 48 44 50 c5 28 c0 28 20     Q.!.. P.HDP.(.( 
     36f:	09 50 41 14 20 80 11 11 00 00 00 10                 .PA. .......

0000037b <USIPSValues>:
     37b:	03 80 02 54 01 40 00 22                             ...T.@."

00000383 <DataFlashError>:
     383:	44 41 54 41 46 4c 41 53 48 20 45 52 52 4f 52 00     DATAFLASH ERROR.

00000393 <DF_Pages>:
     393:	f9 00 f1 01 e1 03 10 3e 84 0f 84 0f 08 1f 08 1f     .......>........

000003a3 <DF_PageSize>:
     3a3:	08 01 08 01 08 01 08 01 08 01 10 02 10 02 20 04     .............. .

000003b3 <DF_PageBits>:
     3b3:	09 09 09 09 09 0a 0a 0b                             ........

000003bb <__c.0>:
     3bb:	42 55 46 46 20 4f 56 45 52 46 4c 4f 57 00           BUFF OVERFLOW.

000003c9 <DataFlashProgMode>:
     3c9:	2a 44 41 54 41 46 4c 41 53 48 20 4d 4f 44 45 2a     *DATAFLASH MODE*
	...

000003da <SignonResponse>:
     3da:	01 00 08 41 56 52 49 53 50 5f 32                    ...AVRISP_2

000003e5 <VersionData>:
     3e5:	02 02 04                                            ...

000003e8 <SyncErrorMessage>:
     3e8:	53 59 4e 43 20 45 52 52 4f 52 00                    SYNC ERROR.

000003f3 <AVRISPModeMessage>:
     3f3:	2a 41 54 41 56 52 49 53 50 20 4d 4f 44 45 2a 00     *ATAVRISP MODE*.

00000403 <__c.0>:
     403:	44 41 54 41 2d 00                                   DATA-.

00000409 <__c.1>:
     409:	45 50 52 4d 2d 00                                   EPRM-.

0000040f <__c.2>:
     40f:	46 55 53 45 2d 00                                   FUSE-.

00000415 <__c.3>:
     415:	4c 4f 43 4b 2d 00                                   LOCK-.

0000041b <__c.0>:
     41b:	4e 4f 20 54 41 47 53 00 00                          NO TAGS..

00000424 <__init>:
     424:	11 24       	eor	r1, r1
     426:	1f be       	out	0x3f, r1	; 63
     428:	cf ef       	ldi	r28, 0xFF	; 255
     42a:	d4 e0       	ldi	r29, 0x04	; 4
     42c:	de bf       	out	0x3e, r29	; 62
     42e:	cd bf       	out	0x3d, r28	; 61

00000430 <__do_copy_data>:
     430:	11 e0       	ldi	r17, 0x01	; 1
     432:	a0 e0       	ldi	r26, 0x00	; 0
     434:	b1 e0       	ldi	r27, 0x01	; 1
     436:	ea e8       	ldi	r30, 0x8A	; 138
     438:	f7 e3       	ldi	r31, 0x37	; 55
     43a:	02 c0       	rjmp	.+4      	; 0x440 <.do_copy_data_start>

0000043c <.do_copy_data_loop>:
     43c:	05 90       	lpm	r0, Z+
     43e:	0d 92       	st	X+, r0

00000440 <.do_copy_data_start>:
     440:	a6 32       	cpi	r26, 0x26	; 38
     442:	b1 07       	cpc	r27, r17
     444:	d9 f7       	brne	.-10     	; 0x43c <.do_copy_data_loop>

00000446 <__do_clear_bss>:
     446:	12 e0       	ldi	r17, 0x02	; 2
     448:	a6 e2       	ldi	r26, 0x26	; 38
     44a:	b1 e0       	ldi	r27, 0x01	; 1
     44c:	01 c0       	rjmp	.+2      	; 0x450 <.do_clear_bss_start>

0000044e <.do_clear_bss_loop>:
     44e:	1d 92       	st	X+, r1

00000450 <.do_clear_bss_start>:
     450:	a6 3d       	cpi	r26, 0xD6	; 214
     452:	b1 07       	cpc	r27, r17
     454:	e1 f7       	brne	.-8      	; 0x44e <.do_clear_bss_loop>
     456:	0c 94 73 02 	jmp	0x4e6 <main>

0000045a <__bad_interrupt>:
     45a:	0c 94 ad 03 	jmp	0x75a <__vector_default>

0000045e <MAIN_Delay10MS>:

// ======================================================================================

void MAIN_Delay10MS(uint8_t loops)
{
     45e:	cf 93       	push	r28
     460:	df 93       	push	r29
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     462:	28 2f       	mov	r18, r24
     464:	21 50       	subi	r18, 0x01	; 1
     466:	2f 3f       	cpi	r18, 0xFF	; 255
     468:	49 f0       	breq	.+18     	; 0x47c <MAIN_Delay10MS+0x1e>
     46a:	a0 e0       	ldi	r26, 0x00	; 0
     46c:	b8 e4       	ldi	r27, 0x48	; 72
     46e:	c0 e0       	ldi	r28, 0x00	; 0
     470:	d0 e0       	ldi	r29, 0x00	; 0
     472:	cd 01       	movw	r24, r26
     474:	01 97       	sbiw	r24, 0x01	; 1
     476:	f1 f7       	brne	.-4      	; 0x474 <MAIN_Delay10MS+0x16>
     478:	21 50       	subi	r18, 0x01	; 1
     47a:	d8 f7       	brcc	.-10     	; 0x472 <MAIN_Delay10MS+0x14>
     47c:	df 91       	pop	r29
     47e:	cf 91       	pop	r28
     480:	08 95       	ret

00000482 <MAIN_WaitForJoyRelease>:
  /* Prevents the use of floating point libraries. Delaying in groups of
     10ms increases accuracy by reducing the time overhead for each loop
     interation of the while.                                            */

	while (loops--)
	  _delay_ms(10);
}

void MAIN_Delay1MS(uint8_t loops)
{
  /* Prevents the use of floating point libraries. Less accurate than the
     Delay10MS routine, but nessesary for many commands. The overhead required
     to call the routine is substantially less than the overhead required to
     calculate the float at compile time, so this actually saves execution time. */

	while (loops--)
	  _delay_ms(1);
}

void MAIN_ResetCSLine(uint8_t ActiveInactive)
{
  /* ActiveInactive controls the /Reset line to an AVR device or external dataflash
     /CS line. If the reset polarity parameter is a 0 then interfacing with AT89
	 devices which has an active high reset. Pins are tristated when inactive.      */
	
	switch (ActiveInactive)
	{
		case MAIN_RESETCS_ACTIVE:   // The target RESET line may be either active high or low.
			DDRF |= (1 << 6);
		
			if (!(eeprom_read_byte_169(&Param_ResetPolarity))) // Translate to correct logic level for target device type
			  PORTF |=  (1 << 6);
			else
			  PORTF &= ~(1 << 6);
		
			break;
		case MAIN_RESETCS_EXTDFACTIVE: // Dataflashes are always active low.
			DDRF  |=  (1 << 6);
			PORTF &= ~(1 << 6);
			
			break;
		case MAIN_RESETCS_INACTIVE: // Both modes tristate the pins when inactive.
			DDRF  &= ~(1 << 6);
			PORTF &= ~(1 << 6);
	}
}

void MAIN_WaitForJoyRelease(void)
{
	while (1)
	{
		while (JoyStatus) {};                   // Wait until joystick released
     482:	8e b3       	in	r24, 0x1e	; 30
     484:	88 23       	and	r24, r24
     486:	e9 f7       	brne	.-6      	; 0x482 <MAIN_WaitForJoyRelease>

		MAIN_Delay10MS(1);
     488:	81 e0       	ldi	r24, 0x01	; 1
     48a:	0e 94 2f 02 	call	0x45e <MAIN_Delay10MS>

		if (!(JoyStatus))                       // Joystick still released (not bouncing), return
     48e:	8e b3       	in	r24, 0x1e	; 30
     490:	88 23       	and	r24, r24
     492:	b9 f7       	brne	.-18     	; 0x482 <MAIN_WaitForJoyRelease>
     494:	08 95       	ret

00000496 <FUNCShowAbout>:
		  return;
	}
}

void MAIN_IntToStr(uint16_t IntV, uint8_t* Buff)
{
	// Shows leading zeros, unlike itoa.

	uint8_t Temp = 0;
	
	while (IntV >= 100)
	{
		Temp++;
		IntV -= 100;
	}

	*(Buff++) = '0' + Temp;
	
	Temp = 0;
	
	while (IntV >= 10)
	{
		Temp++;
		IntV -= 10;
	}
		
	*(Buff++) = '0' + Temp;
	*(Buff++) = '0' + IntV;
	*(Buff)   = '\0';
}

void MAIN_ShowProgType(uint8_t Letter)
{
	uint8_t ProgTypeBuffer[7];

	strcpy_P(ProgTypeBuffer, PSTR("PRG> "));
	ProgTypeBuffer[5] = Letter;
	ProgTypeBuffer[6] = '\0';
	
	LCD_puts(ProgTypeBuffer);
}

void MAIN_ShowError(const uint8_t *pFlashStr)
{
	uint8_t ErrorBuff[LCD_TEXTBUFFER_SIZE];       // New buffer, LCD text buffer size
	
	ErrorBuff[0] = 'E';
	ErrorBuff[1] = '>';

	strcpy_P(&ErrorBuff[2], pFlashStr);       // WARNING: If error text is larger than (TEXTBUFFER_SIZE - 2),
	                                          // this will overflow the buffer and probably crash the micro!
	LCD_puts(ErrorBuff);
	
	MAIN_WaitForJoyRelease();
	while (!(JoyStatus & JOY_PRESS)) {};
	MAIN_WaitForJoyRelease();
}

// ======================================================================================

ISR(PCINT1_vect, ISR_NOBLOCK)                 // Joystick routine; PCINT0_vect is bound to this also via JoystickInterrupt.S
{
	JoyStatus = (~PINB & JOY_BMASK)
	          | (~PINE & JOY_EMASK);
}

ISR(BADISR_vect, ISR_NAKED)                   // Bad ISR routine; should never be called, here for safety
{
	MAIN_ShowError(PSTR("BADISR"));
	while (1) {};
}

// ======================================================================================

void FUNCChangeSettings(void)
{
	uint8_t CurrSFunc = 0;
	
	JoyStatus = 1;

	while (1)
	{
		if (JoyStatus)                         // Joystick is in the non-center position
		{
			if (JoyStatus & JOY_UP)            // Previous function
			  (CurrSFunc == 0)? CurrSFunc = 5 : CurrSFunc--;
			else if (JoyStatus & JOY_DOWN)     // Next function
			  (CurrSFunc == 5)? CurrSFunc = 0 : CurrSFunc++;
			else if (JoyStatus & JOY_PRESS)    // Select current function
			  ((FuncPtr)pgm_read_word(&SettingFunctionPtrs[CurrSFunc]))(); // Run associated function
			else if (JoyStatus & JOY_LEFT)
			  return;
		
			// Show current function onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&SettingFunctionNames[CurrSFunc]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCShowAbout(void)
{
     496:	cf 93       	push	r28
	uint8_t InfoNum = 0;
     498:	c0 e0       	ldi	r28, 0x00	; 0
	
	JoyStatus = 1;
     49a:	81 e0       	ldi	r24, 0x01	; 1
     49c:	8e bb       	out	0x1e, r24	; 30
			
	while (1)
	{
		if (JoyStatus)
     49e:	8e b3       	in	r24, 0x1e	; 30
     4a0:	88 23       	and	r24, r24
     4a2:	e9 f3       	breq	.-6      	; 0x49e <FUNCShowAbout+0x8>
		{
			if (JoyStatus & JOY_UP)
     4a4:	f6 9b       	sbis	0x1e, 6	; 30
     4a6:	06 c0       	rjmp	.+12     	; 0x4b4 <FUNCShowAbout+0x1e>
			  (InfoNum == 0)? InfoNum = 3 : InfoNum--;
     4a8:	cc 23       	and	r28, r28
     4aa:	11 f4       	brne	.+4      	; 0x4b0 <FUNCShowAbout+0x1a>
     4ac:	c3 e0       	ldi	r28, 0x03	; 3
     4ae:	0c c0       	rjmp	.+24     	; 0x4c8 <FUNCShowAbout+0x32>
     4b0:	c1 50       	subi	r28, 0x01	; 1
     4b2:	0a c0       	rjmp	.+20     	; 0x4c8 <FUNCShowAbout+0x32>
			else if (JoyStatus & JOY_DOWN)
     4b4:	f7 9b       	sbis	0x1e, 7	; 30
     4b6:	06 c0       	rjmp	.+12     	; 0x4c4 <FUNCShowAbout+0x2e>
			  (InfoNum == 3)? InfoNum = 0 : InfoNum++;
     4b8:	c3 30       	cpi	r28, 0x03	; 3
     4ba:	11 f4       	brne	.+4      	; 0x4c0 <FUNCShowAbout+0x2a>
     4bc:	c0 e0       	ldi	r28, 0x00	; 0
     4be:	04 c0       	rjmp	.+8      	; 0x4c8 <FUNCShowAbout+0x32>
     4c0:	cf 5f       	subi	r28, 0xFF	; 255
     4c2:	02 c0       	rjmp	.+4      	; 0x4c8 <FUNCShowAbout+0x32>
			else if (JoyStatus & JOY_LEFT)
     4c4:	f2 99       	sbic	0x1e, 2	; 30
     4c6:	0d c0       	rjmp	.+26     	; 0x4e2 <FUNCShowAbout+0x4c>
			  return;

			LCD_puts_f((uint8_t*)pgm_read_word(&AboutTextPtrs[InfoNum]));
     4c8:	ec 2f       	mov	r30, r28
     4ca:	ff 27       	eor	r31, r31
     4cc:	ee 0f       	add	r30, r30
     4ce:	ff 1f       	adc	r31, r31
     4d0:	e5 5f       	subi	r30, 0xF5	; 245
     4d2:	fd 4f       	sbci	r31, 0xFD	; 253
     4d4:	85 91       	lpm	r24, Z+
     4d6:	94 91       	lpm	r25, Z
     4d8:	0e 94 ff 07 	call	0xffe <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     4dc:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     4e0:	de cf       	rjmp	.-68     	; 0x49e <FUNCShowAbout+0x8>
     4e2:	cf 91       	pop	r28
     4e4:	08 95       	ret

000004e6 <main>:
     4e6:	cd ef       	ldi	r28, 0xFD	; 253
     4e8:	d4 e0       	ldi	r29, 0x04	; 4
     4ea:	de bf       	out	0x3e, r29	; 62
     4ec:	cd bf       	out	0x3d, r28	; 61
     4ee:	10 e0       	ldi	r17, 0x00	; 0
     4f0:	80 e8       	ldi	r24, 0x80	; 128
     4f2:	80 bf       	out	0x30, r24	; 48
     4f4:	85 e0       	ldi	r24, 0x05	; 5
     4f6:	80 93 64 00 	sts	0x0064, r24
     4fa:	80 e3       	ldi	r24, 0x30	; 48
     4fc:	80 bb       	out	0x10, r24	; 16
     4fe:	87 e2       	ldi	r24, 0x27	; 39
     500:	84 b9       	out	0x04, r24	; 4
     502:	8f ed       	ldi	r24, 0xDF	; 223
     504:	85 b9       	out	0x05, r24	; 5
     506:	8c e0       	ldi	r24, 0x0C	; 12
     508:	8e b9       	out	0x0e, r24	; 14
     50a:	80 93 6b 00 	sts	0x006B, r24
     50e:	80 ed       	ldi	r24, 0xD0	; 208
     510:	80 93 6c 00 	sts	0x006C, r24
     514:	80 ec       	ldi	r24, 0xC0	; 192
     516:	8d bb       	out	0x1d, r24	; 29
     518:	8c bb       	out	0x1c, r24	; 28
     51a:	81 b3       	in	r24, 0x11	; 17
     51c:	8f 7c       	andi	r24, 0xCF	; 207
     51e:	80 62       	ori	r24, 0x20	; 32
     520:	81 bb       	out	0x11, r24	; 17
     522:	82 e0       	ldi	r24, 0x02	; 2
     524:	91 e0       	ldi	r25, 0x01	; 1
     526:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
     52a:	8a 37       	cpi	r24, 0x7A	; 122
     52c:	09 f1       	breq	.+66     	; 0x570 <__stack+0x71>
     52e:	20 e0       	ldi	r18, 0x00	; 0
     530:	30 e0       	ldi	r19, 0x00	; 0
     532:	3a 83       	std	Y+2, r19	; 0x02
     534:	29 83       	std	Y+1, r18	; 0x01
     536:	80 91 02 01 	lds	r24, 0x0102
     53a:	90 91 03 01 	lds	r25, 0x0103
     53e:	28 17       	cp	r18, r24
     540:	39 07       	cpc	r19, r25
     542:	88 f4       	brcc	.+34     	; 0x566 <__stack+0x67>
     544:	6f ef       	ldi	r22, 0xFF	; 255
     546:	ce 01       	movw	r24, r28
     548:	01 96       	adiw	r24, 0x01	; 1
     54a:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
     54e:	89 81       	ldd	r24, Y+1	; 0x01
     550:	9a 81       	ldd	r25, Y+2	; 0x02
     552:	01 96       	adiw	r24, 0x01	; 1
     554:	9a 83       	std	Y+2, r25	; 0x02
     556:	89 83       	std	Y+1, r24	; 0x01
     558:	20 91 02 01 	lds	r18, 0x0102
     55c:	30 91 03 01 	lds	r19, 0x0103
     560:	82 17       	cp	r24, r18
     562:	93 07       	cpc	r25, r19
     564:	78 f3       	brcs	.-34     	; 0x544 <__stack+0x45>
     566:	6a e7       	ldi	r22, 0x7A	; 122
     568:	82 e0       	ldi	r24, 0x02	; 2
     56a:	91 e0       	ldi	r25, 0x01	; 1
     56c:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
     570:	0e 94 ac 07 	call	0xf58 <LCD_Init>
     574:	84 e0       	ldi	r24, 0x04	; 4
     576:	91 e0       	ldi	r25, 0x01	; 1
     578:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
     57c:	8f 70       	andi	r24, 0x0F	; 15
     57e:	80 93 e7 00 	sts	0x00E7, r24
     582:	78 94       	sei
     584:	8f e3       	ldi	r24, 0x3F	; 63
     586:	92 e0       	ldi	r25, 0x02	; 2
     588:	0e 94 ff 07 	call	0xffe <LCD_puts_f>
     58c:	80 e0       	ldi	r24, 0x00	; 0
     58e:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
     592:	81 b3       	in	r24, 0x11	; 17
     594:	80 63       	ori	r24, 0x30	; 48
     596:	81 bb       	out	0x11, r24	; 17
     598:	0e 94 3a 07 	call	0xe74 <OSCCAL_Calibrate>
     59c:	87 e0       	ldi	r24, 0x07	; 7
     59e:	90 e0       	ldi	r25, 0x00	; 0
     5a0:	0e 94 dc 08 	call	0x11b8 <USART_Init>
     5a4:	81 b3       	in	r24, 0x11	; 17
     5a6:	8f 7c       	andi	r24, 0xCF	; 207
     5a8:	80 61       	ori	r24, 0x10	; 16
     5aa:	81 bb       	out	0x11, r24	; 17
     5ac:	81 e0       	ldi	r24, 0x01	; 1
     5ae:	8e bb       	out	0x1e, r24	; 30
     5b0:	8e b3       	in	r24, 0x1e	; 30
     5b2:	88 23       	and	r24, r24
     5b4:	e9 f3       	breq	.-6      	; 0x5b0 <__stack+0xb1>
     5b6:	f6 9b       	sbis	0x1e, 6	; 30
     5b8:	06 c0       	rjmp	.+12     	; 0x5c6 <__stack+0xc7>
     5ba:	11 23       	and	r17, r17
     5bc:	11 f4       	brne	.+4      	; 0x5c2 <__stack+0xc3>
     5be:	16 e0       	ldi	r17, 0x06	; 6
     5c0:	1b c0       	rjmp	.+54     	; 0x5f8 <__stack+0xf9>
     5c2:	11 50       	subi	r17, 0x01	; 1
     5c4:	19 c0       	rjmp	.+50     	; 0x5f8 <__stack+0xf9>
     5c6:	f7 9b       	sbis	0x1e, 7	; 30
     5c8:	06 c0       	rjmp	.+12     	; 0x5d6 <__stack+0xd7>
     5ca:	16 30       	cpi	r17, 0x06	; 6
     5cc:	11 f4       	brne	.+4      	; 0x5d2 <__stack+0xd3>
     5ce:	10 e0       	ldi	r17, 0x00	; 0
     5d0:	13 c0       	rjmp	.+38     	; 0x5f8 <__stack+0xf9>
     5d2:	1f 5f       	subi	r17, 0xFF	; 255
     5d4:	11 c0       	rjmp	.+34     	; 0x5f8 <__stack+0xf9>
     5d6:	f4 9b       	sbis	0x1e, 4	; 30
     5d8:	0b c0       	rjmp	.+22     	; 0x5f0 <__stack+0xf1>
     5da:	e1 2f       	mov	r30, r17
     5dc:	ff 27       	eor	r31, r31
     5de:	ee 0f       	add	r30, r30
     5e0:	ff 1f       	adc	r31, r31
     5e2:	eb 56       	subi	r30, 0x6B	; 107
     5e4:	fe 4f       	sbci	r31, 0xFE	; 254
     5e6:	85 91       	lpm	r24, Z+
     5e8:	94 91       	lpm	r25, Z
     5ea:	fc 01       	movw	r30, r24
     5ec:	09 95       	icall
     5ee:	04 c0       	rjmp	.+8      	; 0x5f8 <__stack+0xf9>
     5f0:	f3 9b       	sbis	0x1e, 3	; 30
     5f2:	02 c0       	rjmp	.+4      	; 0x5f8 <__stack+0xf9>
     5f4:	0e 94 4b 02 	call	0x496 <FUNCShowAbout>
     5f8:	e1 2f       	mov	r30, r17
     5fa:	ff 27       	eor	r31, r31
     5fc:	ee 0f       	add	r30, r30
     5fe:	ff 1f       	adc	r31, r31
     600:	ed 55       	subi	r30, 0x5D	; 93
     602:	fe 4f       	sbci	r31, 0xFE	; 254
     604:	85 91       	lpm	r24, Z+
     606:	94 91       	lpm	r25, Z
     608:	0e 94 ff 07 	call	0xffe <LCD_puts_f>
     60c:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     610:	cf cf       	rjmp	.-98     	; 0x5b0 <__stack+0xb1>

00000612 <MAIN_Delay1MS>:
     612:	cf 93       	push	r28
     614:	df 93       	push	r29
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     616:	28 2f       	mov	r18, r24
     618:	21 50       	subi	r18, 0x01	; 1
     61a:	2f 3f       	cpi	r18, 0xFF	; 255
     61c:	49 f0       	breq	.+18     	; 0x630 <MAIN_Delay1MS+0x1e>
     61e:	a3 e3       	ldi	r26, 0x33	; 51
     620:	b7 e0       	ldi	r27, 0x07	; 7
     622:	c0 e0       	ldi	r28, 0x00	; 0
     624:	d0 e0       	ldi	r29, 0x00	; 0
     626:	cd 01       	movw	r24, r26
     628:	01 97       	sbiw	r24, 0x01	; 1
     62a:	f1 f7       	brne	.-4      	; 0x628 <MAIN_Delay1MS+0x16>
     62c:	21 50       	subi	r18, 0x01	; 1
     62e:	d8 f7       	brcc	.-10     	; 0x626 <MAIN_Delay1MS+0x14>
     630:	df 91       	pop	r29
     632:	cf 91       	pop	r28
     634:	08 95       	ret

00000636 <MAIN_ResetCSLine>:
     636:	99 27       	eor	r25, r25
     638:	81 30       	cpi	r24, 0x01	; 1
     63a:	91 05       	cpc	r25, r1
     63c:	a9 f0       	breq	.+42     	; 0x668 <MAIN_ResetCSLine+0x32>
     63e:	82 30       	cpi	r24, 0x02	; 2
     640:	91 05       	cpc	r25, r1
     642:	1c f4       	brge	.+6      	; 0x64a <MAIN_ResetCSLine+0x14>
     644:	89 2b       	or	r24, r25
     646:	21 f0       	breq	.+8      	; 0x650 <MAIN_ResetCSLine+0x1a>
     648:	08 95       	ret
     64a:	02 97       	sbiw	r24, 0x02	; 2
     64c:	51 f0       	breq	.+20     	; 0x662 <MAIN_ResetCSLine+0x2c>
     64e:	08 95       	ret
     650:	86 9a       	sbi	0x10, 6	; 16
     652:	82 e2       	ldi	r24, 0x22	; 34
     654:	91 e0       	ldi	r25, 0x01	; 1
     656:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
     65a:	88 23       	and	r24, r24
     65c:	19 f4       	brne	.+6      	; 0x664 <MAIN_ResetCSLine+0x2e>
     65e:	8e 9a       	sbi	0x11, 6	; 17
     660:	08 95       	ret
     662:	86 9a       	sbi	0x10, 6	; 16
     664:	8e 98       	cbi	0x11, 6	; 17
     666:	08 95       	ret
     668:	86 98       	cbi	0x10, 6	; 16
     66a:	fc cf       	rjmp	.-8      	; 0x664 <MAIN_ResetCSLine+0x2e>

0000066c <MAIN_IntToStr>:
     66c:	fb 01       	movw	r30, r22
     66e:	20 e0       	ldi	r18, 0x00	; 0
     670:	84 36       	cpi	r24, 0x64	; 100
     672:	91 05       	cpc	r25, r1
     674:	20 f0       	brcs	.+8      	; 0x67e <MAIN_IntToStr+0x12>
     676:	2f 5f       	subi	r18, 0xFF	; 255
     678:	84 56       	subi	r24, 0x64	; 100
     67a:	90 40       	sbci	r25, 0x00	; 0
     67c:	f9 cf       	rjmp	.-14     	; 0x670 <MAIN_IntToStr+0x4>
     67e:	20 5d       	subi	r18, 0xD0	; 208
     680:	21 93       	st	Z+, r18
     682:	20 e0       	ldi	r18, 0x00	; 0
     684:	8a 30       	cpi	r24, 0x0A	; 10
     686:	91 05       	cpc	r25, r1
     688:	18 f0       	brcs	.+6      	; 0x690 <MAIN_IntToStr+0x24>
     68a:	2f 5f       	subi	r18, 0xFF	; 255
     68c:	0a 97       	sbiw	r24, 0x0a	; 10
     68e:	fa cf       	rjmp	.-12     	; 0x684 <MAIN_IntToStr+0x18>
     690:	20 5d       	subi	r18, 0xD0	; 208
     692:	21 93       	st	Z+, r18
     694:	80 5d       	subi	r24, 0xD0	; 208
     696:	81 93       	st	Z+, r24
     698:	10 82       	st	Z, r1
     69a:	08 95       	ret

0000069c <MAIN_ShowProgType>:
     69c:	1f 93       	push	r17
     69e:	cf 93       	push	r28
     6a0:	df 93       	push	r29
     6a2:	cd b7       	in	r28, 0x3d	; 61
     6a4:	de b7       	in	r29, 0x3e	; 62
     6a6:	27 97       	sbiw	r28, 0x07	; 7
     6a8:	0f b6       	in	r0, 0x3f	; 63
     6aa:	f8 94       	cli
     6ac:	de bf       	out	0x3e, r29	; 62
     6ae:	0f be       	out	0x3f, r0	; 63
     6b0:	cd bf       	out	0x3d, r28	; 61
     6b2:	18 2f       	mov	r17, r24
     6b4:	6d e6       	ldi	r22, 0x6D	; 109
     6b6:	72 e0       	ldi	r23, 0x02	; 2
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	0e 94 48 1b 	call	0x3690 <strcpy_P>
     6c0:	1e 83       	std	Y+6, r17	; 0x06
     6c2:	1f 82       	std	Y+7, r1	; 0x07
     6c4:	ce 01       	movw	r24, r28
     6c6:	01 96       	adiw	r24, 0x01	; 1
     6c8:	0e 94 be 07 	call	0xf7c <LCD_puts>
     6cc:	27 96       	adiw	r28, 0x07	; 7
     6ce:	0f b6       	in	r0, 0x3f	; 63
     6d0:	f8 94       	cli
     6d2:	de bf       	out	0x3e, r29	; 62
     6d4:	0f be       	out	0x3f, r0	; 63
     6d6:	cd bf       	out	0x3d, r28	; 61
     6d8:	df 91       	pop	r29
     6da:	cf 91       	pop	r28
     6dc:	1f 91       	pop	r17
     6de:	08 95       	ret

000006e0 <MAIN_ShowError>:
     6e0:	cf 93       	push	r28
     6e2:	df 93       	push	r29
     6e4:	cd b7       	in	r28, 0x3d	; 61
     6e6:	de b7       	in	r29, 0x3e	; 62
     6e8:	64 97       	sbiw	r28, 0x14	; 20
     6ea:	0f b6       	in	r0, 0x3f	; 63
     6ec:	f8 94       	cli
     6ee:	de bf       	out	0x3e, r29	; 62
     6f0:	0f be       	out	0x3f, r0	; 63
     6f2:	cd bf       	out	0x3d, r28	; 61
     6f4:	25 e4       	ldi	r18, 0x45	; 69
     6f6:	29 83       	std	Y+1, r18	; 0x01
     6f8:	2e e3       	ldi	r18, 0x3E	; 62
     6fa:	2a 83       	std	Y+2, r18	; 0x02
     6fc:	bc 01       	movw	r22, r24
     6fe:	ce 01       	movw	r24, r28
     700:	03 96       	adiw	r24, 0x03	; 3
     702:	0e 94 48 1b 	call	0x3690 <strcpy_P>
     706:	ce 01       	movw	r24, r28
     708:	01 96       	adiw	r24, 0x01	; 1
     70a:	0e 94 be 07 	call	0xf7c <LCD_puts>
     70e:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     712:	f4 9b       	sbis	0x1e, 4	; 30
     714:	fe cf       	rjmp	.-4      	; 0x712 <MAIN_ShowError+0x32>
     716:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     71a:	64 96       	adiw	r28, 0x14	; 20
     71c:	0f b6       	in	r0, 0x3f	; 63
     71e:	f8 94       	cli
     720:	de bf       	out	0x3e, r29	; 62
     722:	0f be       	out	0x3f, r0	; 63
     724:	cd bf       	out	0x3d, r28	; 61
     726:	df 91       	pop	r29
     728:	cf 91       	pop	r28
     72a:	08 95       	ret

0000072c <__vector_3>:
     72c:	78 94       	sei
     72e:	1f 92       	push	r1
     730:	0f 92       	push	r0
     732:	0f b6       	in	r0, 0x3f	; 63
     734:	0f 92       	push	r0
     736:	11 24       	eor	r1, r1
     738:	8f 93       	push	r24
     73a:	9f 93       	push	r25
     73c:	93 b1       	in	r25, 0x03	; 3
     73e:	90 95       	com	r25
     740:	90 7d       	andi	r25, 0xD0	; 208
     742:	8c b1       	in	r24, 0x0c	; 12
     744:	80 95       	com	r24
     746:	8c 70       	andi	r24, 0x0C	; 12
     748:	98 2b       	or	r25, r24
     74a:	9e bb       	out	0x1e, r25	; 30
     74c:	9f 91       	pop	r25
     74e:	8f 91       	pop	r24
     750:	0f 90       	pop	r0
     752:	0f be       	out	0x3f, r0	; 63
     754:	0f 90       	pop	r0
     756:	1f 90       	pop	r1
     758:	18 95       	reti

0000075a <__vector_default>:
     75a:	83 e7       	ldi	r24, 0x73	; 115
     75c:	92 e0       	ldi	r25, 0x02	; 2
     75e:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
     762:	ff cf       	rjmp	.-2      	; 0x762 <__vector_default+0x8>

00000764 <FUNCChangeSettings>:
     764:	cf 93       	push	r28
     766:	c0 e0       	ldi	r28, 0x00	; 0
     768:	81 e0       	ldi	r24, 0x01	; 1
     76a:	8e bb       	out	0x1e, r24	; 30
     76c:	8e b3       	in	r24, 0x1e	; 30
     76e:	88 23       	and	r24, r24
     770:	e9 f3       	breq	.-6      	; 0x76c <FUNCChangeSettings+0x8>
     772:	f6 9b       	sbis	0x1e, 6	; 30
     774:	06 c0       	rjmp	.+12     	; 0x782 <FUNCChangeSettings+0x1e>
     776:	cc 23       	and	r28, r28
     778:	11 f4       	brne	.+4      	; 0x77e <FUNCChangeSettings+0x1a>
     77a:	c5 e0       	ldi	r28, 0x05	; 5
     77c:	19 c0       	rjmp	.+50     	; 0x7b0 <FUNCChangeSettings+0x4c>
     77e:	c1 50       	subi	r28, 0x01	; 1
     780:	17 c0       	rjmp	.+46     	; 0x7b0 <FUNCChangeSettings+0x4c>
     782:	f7 9b       	sbis	0x1e, 7	; 30
     784:	06 c0       	rjmp	.+12     	; 0x792 <FUNCChangeSettings+0x2e>
     786:	c5 30       	cpi	r28, 0x05	; 5
     788:	11 f4       	brne	.+4      	; 0x78e <FUNCChangeSettings+0x2a>
     78a:	c0 e0       	ldi	r28, 0x00	; 0
     78c:	11 c0       	rjmp	.+34     	; 0x7b0 <FUNCChangeSettings+0x4c>
     78e:	cf 5f       	subi	r28, 0xFF	; 255
     790:	0f c0       	rjmp	.+30     	; 0x7b0 <FUNCChangeSettings+0x4c>
     792:	f4 9b       	sbis	0x1e, 4	; 30
     794:	0b c0       	rjmp	.+22     	; 0x7ac <FUNCChangeSettings+0x48>
     796:	ec 2f       	mov	r30, r28
     798:	ff 27       	eor	r31, r31
     79a:	ee 0f       	add	r30, r30
     79c:	ff 1f       	adc	r31, r31
     79e:	e0 5e       	subi	r30, 0xE0	; 224
     7a0:	fe 4f       	sbci	r31, 0xFE	; 254
     7a2:	85 91       	lpm	r24, Z+
     7a4:	94 91       	lpm	r25, Z
     7a6:	fc 01       	movw	r30, r24
     7a8:	09 95       	icall
     7aa:	02 c0       	rjmp	.+4      	; 0x7b0 <FUNCChangeSettings+0x4c>
     7ac:	f2 99       	sbic	0x1e, 2	; 30
     7ae:	0d c0       	rjmp	.+26     	; 0x7ca <FUNCChangeSettings+0x66>
     7b0:	ec 2f       	mov	r30, r28
     7b2:	ff 27       	eor	r31, r31
     7b4:	ee 0f       	add	r30, r30
     7b6:	ff 1f       	adc	r31, r31
     7b8:	e4 5d       	subi	r30, 0xD4	; 212
     7ba:	fe 4f       	sbci	r31, 0xFE	; 254
     7bc:	85 91       	lpm	r24, Z+
     7be:	94 91       	lpm	r25, Z
     7c0:	0e 94 ff 07 	call	0xffe <LCD_puts_f>
     7c4:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     7c8:	d1 cf       	rjmp	.-94     	; 0x76c <FUNCChangeSettings+0x8>
     7ca:	cf 91       	pop	r28
     7cc:	08 95       	ret

000007ce <FUNCAVRISPMode>:
		}
	}
}

void FUNCAVRISPMode(void)
{
	LCD_puts_f(AVRISPModeMessage);
     7ce:	83 ef       	ldi	r24, 0xF3	; 243
     7d0:	93 e0       	ldi	r25, 0x03	; 3
     7d2:	0e 94 ff 07 	call	0xffe <LCD_puts_f>
	
	InterpretPacketRoutine = (FuncPtr)AICI_InterpretPacket;
     7d6:	81 e1       	ldi	r24, 0x11	; 17
     7d8:	92 e1       	ldi	r25, 0x12	; 18
     7da:	90 93 25 01 	sts	0x0125, r25
     7de:	80 93 24 01 	sts	0x0124, r24
	V2P_RunStateMachine();
     7e2:	0e 94 00 0f 	call	0x1e00 <V2P_RunStateMachine>
     7e6:	08 95       	ret

000007e8 <FUNCProgramDataflash>:
}

void FUNCProgramDataflash(void)
{
	USI_SPIInitMaster(eeprom_read_byte_169(&Param_SCKDuration));
     7e8:	80 e2       	ldi	r24, 0x20	; 32
     7ea:	91 e0       	ldi	r25, 0x01	; 1
     7ec:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
     7f0:	0e 94 8d 09 	call	0x131a <USI_SPIInitMaster>
	UseExernalDF = TRUE;
     7f4:	81 e0       	ldi	r24, 0x01	; 1
     7f6:	80 93 83 02 	sts	0x0283, r24
	DFSPIRoutinePointer = USI_SPITransmit;
     7fa:	87 ea       	ldi	r24, 0xA7	; 167
     7fc:	99 e0       	ldi	r25, 0x09	; 9
     7fe:	90 93 01 01 	sts	0x0101, r25
     802:	80 93 00 01 	sts	0x0100, r24
	
	LCD_puts_f(DataFlashProgMode);
     806:	89 ec       	ldi	r24, 0xC9	; 201
     808:	93 e0       	ldi	r25, 0x03	; 3
     80a:	0e 94 ff 07 	call	0xffe <LCD_puts_f>

	InterpretPacketRoutine = PD_InterpretAVRISPPacket;
     80e:	8f e4       	ldi	r24, 0x4F	; 79
     810:	9c e0       	ldi	r25, 0x0C	; 12
     812:	90 93 25 01 	sts	0x0125, r25
     816:	80 93 24 01 	sts	0x0124, r24
	V2P_RunStateMachine();
     81a:	0e 94 00 0f 	call	0x1e00 <V2P_RunStateMachine>
	   
	DF_EnableDataflash(FALSE);
     81e:	80 e0       	ldi	r24, 0x00	; 0
     820:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
	SPI_SPIOFF();
     824:	80 91 64 00 	lds	r24, 0x0064
     828:	84 60       	ori	r24, 0x04	; 4
     82a:	80 93 64 00 	sts	0x0064, r24
     82e:	08 95       	ret

00000830 <FUNCProgramAVR>:
}

void FUNCProgramAVR(void)
{
     830:	df 92       	push	r13
     832:	ef 92       	push	r14
     834:	ff 92       	push	r15
     836:	0f 93       	push	r16
     838:	1f 93       	push	r17
     83a:	cf 93       	push	r28
     83c:	df 93       	push	r29
     83e:	cd b7       	in	r28, 0x3d	; 61
     840:	de b7       	in	r29, 0x3e	; 62
     842:	65 97       	sbiw	r28, 0x15	; 21
     844:	0f b6       	in	r0, 0x3f	; 63
     846:	f8 94       	cli
     848:	de bf       	out	0x3e, r29	; 62
     84a:	0f be       	out	0x3f, r0	; 63
     84c:	cd bf       	out	0x3d, r28	; 61
	uint8_t  DoneFailMessageBuff[19];
	uint16_t EEPROMAddress;
	uint8_t  Fault = ISPCC_NO_FAULT;
     84e:	dd 24       	eor	r13, r13
	uint8_t  ProgMode = 0;
     850:	0d 2d       	mov	r16, r13

	SPI_SPIInit();
     852:	0e 94 38 09 	call	0x1270 <SPI_SPIInit>
	UseExernalDF = FALSE;
     856:	d0 92 83 02 	sts	0x0283, r13
	DFSPIRoutinePointer = SPI_SPITransmit;
     85a:	82 e4       	ldi	r24, 0x42	; 66
     85c:	99 e0       	ldi	r25, 0x09	; 9
     85e:	90 93 01 01 	sts	0x0101, r25
     862:	80 93 00 01 	sts	0x0100, r24
	
	if (!(DF_CheckCorrectOnboardChip()))
     866:	0e 94 5a 0b 	call	0x16b4 <DF_CheckCorrectOnboardChip>
     86a:	88 23       	and	r24, r24
     86c:	09 f4       	brne	.+2      	; 0x870 <FUNCProgramAVR+0x40>
     86e:	17 c1       	rjmp	.+558    	; 0xa9e <FUNCProgramAVR+0x26e>
	  return;

	MAIN_WaitForJoyRelease();
     870:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
	
	JoyStatus = 1;                            // Use an invalid joystick value to force the program to write the
     874:	81 e0       	ldi	r24, 0x01	; 1
     876:	8e bb       	out	0x1e, r24	; 30
	                                          // name of the default command onto the LCD
	while (1)
	{
		if (JoyStatus)
     878:	8e b3       	in	r24, 0x1e	; 30
     87a:	88 23       	and	r24, r24
     87c:	e9 f3       	breq	.-6      	; 0x878 <FUNCProgramAVR+0x48>
		{
			if (JoyStatus & JOY_LEFT)
     87e:	f2 99       	sbic	0x1e, 2	; 30
     880:	0e c1       	rjmp	.+540    	; 0xa9e <FUNCProgramAVR+0x26e>
			  return;
			else if (JoyStatus & JOY_PRESS)
     882:	f4 99       	sbic	0x1e, 4	; 30
     884:	1c c0       	rjmp	.+56     	; 0x8be <FUNCProgramAVR+0x8e>
			  break;
			else if (JoyStatus & JOY_UP)
     886:	f6 9b       	sbis	0x1e, 6	; 30
     888:	06 c0       	rjmp	.+12     	; 0x896 <FUNCProgramAVR+0x66>
			  (ProgMode == 0)? ProgMode = 6 : ProgMode--;
     88a:	00 23       	and	r16, r16
     88c:	11 f4       	brne	.+4      	; 0x892 <FUNCProgramAVR+0x62>
     88e:	06 e0       	ldi	r16, 0x06	; 6
     890:	09 c0       	rjmp	.+18     	; 0x8a4 <FUNCProgramAVR+0x74>
     892:	01 50       	subi	r16, 0x01	; 1
     894:	07 c0       	rjmp	.+14     	; 0x8a4 <FUNCProgramAVR+0x74>
			else if (JoyStatus & JOY_DOWN)
     896:	f7 9b       	sbis	0x1e, 7	; 30
     898:	05 c0       	rjmp	.+10     	; 0x8a4 <FUNCProgramAVR+0x74>
			  (ProgMode == 6)? ProgMode = 0 : ProgMode++;
     89a:	06 30       	cpi	r16, 0x06	; 6
     89c:	11 f4       	brne	.+4      	; 0x8a2 <FUNCProgramAVR+0x72>
     89e:	00 e0       	ldi	r16, 0x00	; 0
     8a0:	01 c0       	rjmp	.+2      	; 0x8a4 <FUNCProgramAVR+0x74>
     8a2:	0f 5f       	subi	r16, 0xFF	; 255

			LCD_puts_f((uint8_t*)pgm_read_word(&ProgOptions[ProgMode])); // Show current function onto the LCD
     8a4:	e0 2f       	mov	r30, r16
     8a6:	ff 27       	eor	r31, r31
     8a8:	ee 0f       	add	r30, r30
     8aa:	ff 1f       	adc	r31, r31
     8ac:	e3 55       	subi	r30, 0x53	; 83
     8ae:	ff 4f       	sbci	r31, 0xFF	; 255
     8b0:	85 91       	lpm	r24, Z+
     8b2:	94 91       	lpm	r25, Z
     8b4:	0e 94 ff 07 	call	0xffe <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     8b8:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     8bc:	dd cf       	rjmp	.-70     	; 0x878 <FUNCProgramAVR+0x48>
		}
	}

	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);                // Orange = busy
     8be:	81 b3       	in	r24, 0x11	; 17
     8c0:	80 63       	ori	r24, 0x30	; 48
     8c2:	81 bb       	out	0x11, r24	; 17
	LCD_puts_f(WaitText);
     8c4:	8f e3       	ldi	r24, 0x3F	; 63
     8c6:	92 e0       	ldi	r25, 0x02	; 2
     8c8:	0e 94 ff 07 	call	0xffe <LCD_puts_f>

	USI_SPIInitMaster(eeprom_read_byte_169(&Param_SCKDuration));
     8cc:	80 e2       	ldi	r24, 0x20	; 32
     8ce:	91 e0       	ldi	r25, 0x01	; 1
     8d0:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
     8d4:	0e 94 8d 09 	call	0x131a <USI_SPIInitMaster>
	MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE); // Capture the RESET line of the slave AVR
     8d8:	80 e0       	ldi	r24, 0x00	; 0
     8da:	0e 94 1b 03 	call	0x636 <MAIN_ResetCSLine>

	EEPROMAddress = Prog_EnterProgMode;
     8de:	80 91 12 01 	lds	r24, 0x0112
     8e2:	90 91 13 01 	lds	r25, 0x0113
     8e6:	9d 8b       	std	Y+21, r25	; 0x15
     8e8:	8c 8b       	std	Y+20, r24	; 0x14
     8ea:	54 e3       	ldi	r21, 0x34	; 52
     8ec:	e5 2e       	mov	r14, r21
     8ee:	51 e0       	ldi	r21, 0x01	; 1
     8f0:	f5 2e       	mov	r15, r21
     8f2:	1b e0       	ldi	r17, 0x0B	; 11
			
	for (uint8_t PacketB = 0; PacketB <= 11; PacketB++) // Read the enter programming mode command bytes
	{
		PacketBytes[PacketB] = eeprom_read_byte_169(&EEPROMAddress);
     8f4:	ce 01       	movw	r24, r28
     8f6:	44 96       	adiw	r24, 0x14	; 20
     8f8:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
     8fc:	f7 01       	movw	r30, r14
     8fe:	81 93       	st	Z+, r24
     900:	7f 01       	movw	r14, r30
		EEPROMAddress++;
     902:	8c 89       	ldd	r24, Y+20	; 0x14
     904:	9d 89       	ldd	r25, Y+21	; 0x15
     906:	01 96       	adiw	r24, 0x01	; 1
     908:	9d 8b       	std	Y+21, r25	; 0x15
     90a:	8c 8b       	std	Y+20, r24	; 0x14
     90c:	11 50       	subi	r17, 0x01	; 1
     90e:	17 ff       	sbrs	r17, 7
     910:	f1 cf       	rjmp	.-30     	; 0x8f4 <FUNCProgramAVR+0xc4>
	}
	
	ISPCC_EnterChipProgrammingMode();    // Try to sync with the slave AVR
     912:	0e 94 81 10 	call	0x2102 <ISPCC_EnterChipProgrammingMode>

	CurrAddress = 0;
     916:	10 92 2b 01 	sts	0x012B, r1
     91a:	10 92 2c 01 	sts	0x012C, r1
     91e:	10 92 2d 01 	sts	0x012D, r1
     922:	10 92 2e 01 	sts	0x012E, r1

	if (PacketBytes[1] == STATUS_CMD_OK) // ISPCC_EnterChipProgrammingMode alters the PacketBytes buffer rather than returning a value
     926:	80 91 35 01 	lds	r24, 0x0135
     92a:	88 23       	and	r24, r24
     92c:	09 f0       	breq	.+2      	; 0x930 <FUNCProgramAVR+0x100>
     92e:	a2 c0       	rjmp	.+324    	; 0xa74 <FUNCProgramAVR+0x244>
	{						
		if ((ProgMode == 6) || (ProgMode == 0) || (ProgMode == 2)) // Erase chip, or program flash mode
     930:	06 30       	cpi	r16, 0x06	; 6
     932:	21 f0       	breq	.+8      	; 0x93c <FUNCProgramAVR+0x10c>
     934:	00 23       	and	r16, r16
     936:	11 f0       	breq	.+4      	; 0x93c <FUNCProgramAVR+0x10c>
     938:	02 30       	cpi	r16, 0x02	; 2
     93a:	91 f4       	brne	.+36     	; 0x960 <FUNCProgramAVR+0x130>
		{
			MAIN_ShowProgType('C');
     93c:	83 e4       	ldi	r24, 0x43	; 67
     93e:	0e 94 4e 03 	call	0x69c <MAIN_ShowProgType>
			
			if (!(eeprom_read_byte_169(&Prog_EraseCmdStored) == TRUE))
     942:	8a e1       	ldi	r24, 0x1A	; 26
     944:	91 e0       	ldi	r25, 0x01	; 1
     946:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
     94a:	81 30       	cpi	r24, 0x01	; 1
     94c:	39 f0       	breq	.+14     	; 0x95c <FUNCProgramAVR+0x12c>
			{
				Fault = ISPCC_FAULT_NOERASE;
     94e:	42 e0       	ldi	r20, 0x02	; 2
     950:	d4 2e       	mov	r13, r20
				MAIN_ShowError(PSTR("NO ERASE CMD"));
     952:	8a e7       	ldi	r24, 0x7A	; 122
     954:	92 e0       	ldi	r25, 0x02	; 2
     956:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
     95a:	02 c0       	rjmp	.+4      	; 0x960 <FUNCProgramAVR+0x130>
			}
			else
			{
				PM_SendEraseCommand();
     95c:	0e 94 49 18 	call	0x3092 <PM_SendEraseCommand>
			}
		}

		if (((ProgMode == 0) || (ProgMode == 2)) && (Fault == ISPCC_NO_FAULT)) // Program flash
     960:	00 23       	and	r16, r16
     962:	11 f0       	breq	.+4      	; 0x968 <FUNCProgramAVR+0x138>
     964:	02 30       	cpi	r16, 0x02	; 2
     966:	c1 f4       	brne	.+48     	; 0x998 <FUNCProgramAVR+0x168>
     968:	dd 20       	and	r13, r13
     96a:	b1 f4       	brne	.+44     	; 0x998 <FUNCProgramAVR+0x168>
		{
			MAIN_ShowProgType('D');
     96c:	84 e4       	ldi	r24, 0x44	; 68
     96e:	0e 94 4e 03 	call	0x69c <MAIN_ShowProgType>

			if (!(PM_GetStoredDataSize(TYPE_FLASH))) // Check to make sure a program is present in memory
     972:	81 e0       	ldi	r24, 0x01	; 1
     974:	0e 94 80 13 	call	0x2700 <PM_GetStoredDataSize>
     978:	dc 01       	movw	r26, r24
     97a:	cb 01       	movw	r24, r22
     97c:	00 97       	sbiw	r24, 0x00	; 0
     97e:	a1 05       	cpc	r26, r1
     980:	b1 05       	cpc	r27, r1
     982:	39 f4       	brne	.+14     	; 0x992 <FUNCProgramAVR+0x162>
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
     984:	33 e0       	ldi	r19, 0x03	; 3
     986:	d3 2e       	mov	r13, r19
				MAIN_ShowError(PSTR("NO DATA"));
     988:	87 e8       	ldi	r24, 0x87	; 135
     98a:	92 e0       	ldi	r25, 0x02	; 2
     98c:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
     990:	03 c0       	rjmp	.+6      	; 0x998 <FUNCProgramAVR+0x168>
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_FLASH);
     992:	81 e0       	ldi	r24, 0x01	; 1
     994:	0e 94 99 18 	call	0x3132 <PM_CreateProgrammingPackets>
			}
		}
	
		if ((ProgMode == 1) || (ProgMode == 2)) // Program EEPROM
     998:	80 2f       	mov	r24, r16
     99a:	81 50       	subi	r24, 0x01	; 1
     99c:	82 30       	cpi	r24, 0x02	; 2
     99e:	b0 f4       	brcc	.+44     	; 0x9cc <FUNCProgramAVR+0x19c>
		{
			MAIN_ShowProgType('E');
     9a0:	85 e4       	ldi	r24, 0x45	; 69
     9a2:	0e 94 4e 03 	call	0x69c <MAIN_ShowProgType>
				
			if (!(PM_GetStoredDataSize(TYPE_EEPROM))) // Check to make sure EEPROM data is present in memory
     9a6:	80 e0       	ldi	r24, 0x00	; 0
     9a8:	0e 94 80 13 	call	0x2700 <PM_GetStoredDataSize>
     9ac:	dc 01       	movw	r26, r24
     9ae:	cb 01       	movw	r24, r22
     9b0:	00 97       	sbiw	r24, 0x00	; 0
     9b2:	a1 05       	cpc	r26, r1
     9b4:	b1 05       	cpc	r27, r1
     9b6:	39 f4       	brne	.+14     	; 0x9c6 <FUNCProgramAVR+0x196>
			{
				Fault = ISPCC_FAULT_NODATATYPE;
     9b8:	23 e0       	ldi	r18, 0x03	; 3
     9ba:	d2 2e       	mov	r13, r18
				MAIN_ShowError(PSTR("NO EEPROM"));
     9bc:	8f e8       	ldi	r24, 0x8F	; 143
     9be:	92 e0       	ldi	r25, 0x02	; 2
     9c0:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
     9c4:	03 c0       	rjmp	.+6      	; 0x9cc <FUNCProgramAVR+0x19c>
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_EEPROM);
     9c6:	80 e0       	ldi	r24, 0x00	; 0
     9c8:	0e 94 99 18 	call	0x3132 <PM_CreateProgrammingPackets>
			}
		}

		if ((ProgMode == 3) || (ProgMode == 5)) // Program Fuse bytes
     9cc:	03 30       	cpi	r16, 0x03	; 3
     9ce:	11 f0       	breq	.+4      	; 0x9d4 <FUNCProgramAVR+0x1a4>
     9d0:	05 30       	cpi	r16, 0x05	; 5
     9d2:	99 f4       	brne	.+38     	; 0x9fa <FUNCProgramAVR+0x1ca>
		{
			MAIN_ShowProgType('F');
     9d4:	86 e4       	ldi	r24, 0x46	; 70
     9d6:	0e 94 4e 03 	call	0x69c <MAIN_ShowProgType>
			
			if (!(eeprom_read_byte_169(&Prog_TotalFuseBytes)))
     9da:	80 e1       	ldi	r24, 0x10	; 16
     9dc:	91 e0       	ldi	r25, 0x01	; 1
     9de:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
     9e2:	88 23       	and	r24, r24
     9e4:	39 f4       	brne	.+14     	; 0x9f4 <FUNCProgramAVR+0x1c4>
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
     9e6:	93 e0       	ldi	r25, 0x03	; 3
     9e8:	d9 2e       	mov	r13, r25
				MAIN_ShowError(PSTR("NO FUSE BYTES"));
     9ea:	89 e9       	ldi	r24, 0x99	; 153
     9ec:	92 e0       	ldi	r25, 0x02	; 2
     9ee:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
     9f2:	03 c0       	rjmp	.+6      	; 0x9fa <FUNCProgramAVR+0x1ca>
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_FUSE);
     9f4:	82 e0       	ldi	r24, 0x02	; 2
     9f6:	0e 94 f9 17 	call	0x2ff2 <PM_SendFuseLockBytes>
			}
		}

		if ((ProgMode == 4) || (ProgMode == 5)) // Program Lock bytes
     9fa:	80 2f       	mov	r24, r16
     9fc:	84 50       	subi	r24, 0x04	; 4
     9fe:	82 30       	cpi	r24, 0x02	; 2
     a00:	00 f5       	brcc	.+64     	; 0xa42 <FUNCProgramAVR+0x212>
		{
			if (ProgMode == 5)                    // If fusebytes have already been written, we need to reenter programming mode to latch them
     a02:	05 30       	cpi	r16, 0x05	; 5
     a04:	59 f4       	brne	.+22     	; 0xa1c <FUNCProgramAVR+0x1ec>
			{
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line of the slave AVR
     a06:	81 e0       	ldi	r24, 0x01	; 1
     a08:	0e 94 1b 03 	call	0x636 <MAIN_ResetCSLine>
				MAIN_Delay10MS(1);
     a0c:	81 e0       	ldi	r24, 0x01	; 1
     a0e:	0e 94 2f 02 	call	0x45e <MAIN_Delay10MS>
				MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE); // Capture the RESET line of the slave AVR
     a12:	80 e0       	ldi	r24, 0x00	; 0
     a14:	0e 94 1b 03 	call	0x636 <MAIN_ResetCSLine>
				ISPCC_EnterChipProgrammingMode(); // Try to sync with the slave AVR
     a18:	0e 94 81 10 	call	0x2102 <ISPCC_EnterChipProgrammingMode>
			}

			MAIN_ShowProgType('L');
     a1c:	8c e4       	ldi	r24, 0x4C	; 76
     a1e:	0e 94 4e 03 	call	0x69c <MAIN_ShowProgType>
		
			if (!(eeprom_read_byte_169(&Prog_TotalLockBytes)))
     a22:	8e e0       	ldi	r24, 0x0E	; 14
     a24:	91 e0       	ldi	r25, 0x01	; 1
     a26:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
     a2a:	88 23       	and	r24, r24
     a2c:	39 f4       	brne	.+14     	; 0xa3c <FUNCProgramAVR+0x20c>
			{
				Fault = ISPCC_FAULT_NODATATYPE;
     a2e:	83 e0       	ldi	r24, 0x03	; 3
     a30:	d8 2e       	mov	r13, r24
				MAIN_ShowError(PSTR("NO LOCK BYTES"));
     a32:	87 ea       	ldi	r24, 0xA7	; 167
     a34:	92 e0       	ldi	r25, 0x02	; 2
     a36:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
     a3a:	03 c0       	rjmp	.+6      	; 0xa42 <FUNCProgramAVR+0x212>
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_LOCK);
     a3c:	83 e0       	ldi	r24, 0x03	; 3
     a3e:	0e 94 f9 17 	call	0x2ff2 <PM_SendFuseLockBytes>
			}
		}

		strcpy_P(DoneFailMessageBuff, PSTR("PROGRAMMING DONE"));
     a42:	65 eb       	ldi	r22, 0xB5	; 181
     a44:	72 e0       	ldi	r23, 0x02	; 2
     a46:	ce 01       	movw	r24, r28
     a48:	01 96       	adiw	r24, 0x01	; 1
     a4a:	0e 94 48 1b 	call	0x3690 <strcpy_P>

		if (Fault != ISPCC_NO_FAULT)         // Takes less code to just overwrite part of the string on fail
     a4e:	dd 20       	and	r13, r13
     a50:	31 f0       	breq	.+12     	; 0xa5e <FUNCProgramAVR+0x22e>
		  strcpy_P(&DoneFailMessageBuff[12], PSTR("FAILED"));
     a52:	66 ec       	ldi	r22, 0xC6	; 198
     a54:	72 e0       	ldi	r23, 0x02	; 2
     a56:	ce 01       	movw	r24, r28
     a58:	0d 96       	adiw	r24, 0x0d	; 13
     a5a:	0e 94 48 1b 	call	0x3690 <strcpy_P>

		LCD_puts(DoneFailMessageBuff);
     a5e:	ce 01       	movw	r24, r28
     a60:	01 96       	adiw	r24, 0x01	; 1
     a62:	0e 94 be 07 	call	0xf7c <LCD_puts>

		MAIN_Delay10MS(255);
     a66:	8f ef       	ldi	r24, 0xFF	; 255
     a68:	0e 94 2f 02 	call	0x45e <MAIN_Delay10MS>
		MAIN_Delay10MS(100);
     a6c:	84 e6       	ldi	r24, 0x64	; 100
     a6e:	0e 94 2f 02 	call	0x45e <MAIN_Delay10MS>
     a72:	04 c0       	rjmp	.+8      	; 0xa7c <FUNCProgramAVR+0x24c>
	}
	else
	{
		MAIN_ShowError(SyncErrorMessage);
     a74:	88 ee       	ldi	r24, 0xE8	; 232
     a76:	93 e0       	ldi	r25, 0x03	; 3
     a78:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
	}
	
	MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run	
     a7c:	81 e0       	ldi	r24, 0x01	; 1
     a7e:	0e 94 1b 03 	call	0x636 <MAIN_ResetCSLine>
	USI_SPIOff();
     a82:	0e 94 9d 09 	call	0x133a <USI_SPIOff>
	DF_EnableDataflash(FALSE);
     a86:	80 e0       	ldi	r24, 0x00	; 0
     a88:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
	SPI_SPIOFF();
     a8c:	80 91 64 00 	lds	r24, 0x0064
     a90:	84 60       	ori	r24, 0x04	; 4
     a92:	80 93 64 00 	sts	0x0064, r24
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Green = ready
     a96:	81 b3       	in	r24, 0x11	; 17
     a98:	8f 7c       	andi	r24, 0xCF	; 207
     a9a:	80 61       	ori	r24, 0x10	; 16
     a9c:	81 bb       	out	0x11, r24	; 17
     a9e:	65 96       	adiw	r28, 0x15	; 21
     aa0:	0f b6       	in	r0, 0x3f	; 63
     aa2:	f8 94       	cli
     aa4:	de bf       	out	0x3e, r29	; 62
     aa6:	0f be       	out	0x3f, r0	; 63
     aa8:	cd bf       	out	0x3d, r28	; 61
     aaa:	df 91       	pop	r29
     aac:	cf 91       	pop	r28
     aae:	1f 91       	pop	r17
     ab0:	0f 91       	pop	r16
     ab2:	ff 90       	pop	r15
     ab4:	ef 90       	pop	r14
     ab6:	df 90       	pop	r13
     ab8:	08 95       	ret

00000aba <FUNCStoreProgram>:
}

void FUNCStoreProgram(void)
{
	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
     aba:	82 e4       	ldi	r24, 0x42	; 66
     abc:	99 e0       	ldi	r25, 0x09	; 9
     abe:	90 93 01 01 	sts	0x0101, r25
     ac2:	80 93 00 01 	sts	0x0100, r24
	SPI_SPIInit();
     ac6:	0e 94 38 09 	call	0x1270 <SPI_SPIInit>
	UseExernalDF = FALSE;
     aca:	10 92 83 02 	sts	0x0283, r1
	DF_EnableDataflash(TRUE);
     ace:	81 e0       	ldi	r24, 0x01	; 1
     ad0:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>

	if (!(DF_CheckCorrectOnboardChip()))
     ad4:	0e 94 5a 0b 	call	0x16b4 <DF_CheckCorrectOnboardChip>
     ad8:	88 23       	and	r24, r24
     ada:	a1 f0       	breq	.+40     	; 0xb04 <FUNCStoreProgram+0x4a>
	  return;
			
	LCD_puts_f(PSTR("*STORAGE MODE*"));
     adc:	8d ec       	ldi	r24, 0xCD	; 205
     ade:	92 e0       	ldi	r25, 0x02	; 2
     ae0:	0e 94 ff 07 	call	0xffe <LCD_puts_f>

	InterpretPacketRoutine = (FuncPtr)PM_InterpretAVRISPPacket;
     ae4:	8e e2       	ldi	r24, 0x2E	; 46
     ae6:	95 e1       	ldi	r25, 0x15	; 21
     ae8:	90 93 25 01 	sts	0x0125, r25
     aec:	80 93 24 01 	sts	0x0124, r24
	V2P_RunStateMachine();
     af0:	0e 94 00 0f 	call	0x1e00 <V2P_RunStateMachine>
	DF_EnableDataflash(FALSE);
     af4:	80 e0       	ldi	r24, 0x00	; 0
     af6:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
	SPI_SPIOFF();
     afa:	80 91 64 00 	lds	r24, 0x0064
     afe:	84 60       	ori	r24, 0x04	; 4
     b00:	80 93 64 00 	sts	0x0064, r24
     b04:	08 95       	ret

00000b06 <FUNCClearMem>:
}

void FUNCClearMem(void)
{
     b06:	0f 93       	push	r16
     b08:	1f 93       	push	r17
     b0a:	cf 93       	push	r28
     b0c:	df 93       	push	r29
     b0e:	cd b7       	in	r28, 0x3d	; 61
     b10:	de b7       	in	r29, 0x3e	; 62
     b12:	22 97       	sbiw	r28, 0x02	; 2
     b14:	0f b6       	in	r0, 0x3f	; 63
     b16:	f8 94       	cli
     b18:	de bf       	out	0x3e, r29	; 62
     b1a:	0f be       	out	0x3f, r0	; 63
     b1c:	cd bf       	out	0x3d, r28	; 61
	LCD_puts_f(PSTR("CONFIRM"));
     b1e:	8c ed       	ldi	r24, 0xDC	; 220
     b20:	92 e0       	ldi	r25, 0x02	; 2
     b22:	0e 94 ff 07 	call	0xffe <LCD_puts_f>
	MAIN_Delay10MS(180);
     b26:	84 eb       	ldi	r24, 0xB4	; 180
     b28:	0e 94 2f 02 	call	0x45e <MAIN_Delay10MS>

	LCD_puts_f(PSTR("<N Y>"));
     b2c:	84 ee       	ldi	r24, 0xE4	; 228
     b2e:	92 e0       	ldi	r25, 0x02	; 2
     b30:	0e 94 ff 07 	call	0xffe <LCD_puts_f>

	while (1)
	{
		if (JoyStatus)
     b34:	8e b3       	in	r24, 0x1e	; 30
     b36:	88 23       	and	r24, r24
     b38:	e9 f3       	breq	.-6      	; 0xb34 <FUNCClearMem+0x2e>
		{
			if (JoyStatus & JOY_LEFT)
     b3a:	8e b3       	in	r24, 0x1e	; 30
     b3c:	99 27       	eor	r25, r25
     b3e:	8c 01       	movw	r16, r24
     b40:	04 70       	andi	r16, 0x04	; 4
     b42:	10 70       	andi	r17, 0x00	; 0
     b44:	82 fd       	sbrc	r24, 2
     b46:	29 c0       	rjmp	.+82     	; 0xb9a <FUNCClearMem+0x94>
			  return;
			else if (JoyStatus & JOY_RIGHT)
     b48:	f3 9b       	sbis	0x1e, 3	; 30
     b4a:	f4 cf       	rjmp	.-24     	; 0xb34 <FUNCClearMem+0x2e>
			  break;
		}
	}

	MAIN_WaitForJoyRelease();
     b4c:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>

	LCD_puts_f(WaitText);
     b50:	8f e3       	ldi	r24, 0x3F	; 63
     b52:	92 e0       	ldi	r25, 0x02	; 2
     b54:	0e 94 ff 07 	call	0xffe <LCD_puts_f>

	for (uint16_t EAddr = 0; EAddr < Sys_MagicNumber; EAddr++)
     b58:	1a 83       	std	Y+2, r17	; 0x02
     b5a:	09 83       	std	Y+1, r16	; 0x01
     b5c:	80 91 02 01 	lds	r24, 0x0102
     b60:	90 91 03 01 	lds	r25, 0x0103
     b64:	08 17       	cp	r16, r24
     b66:	19 07       	cpc	r17, r25
     b68:	88 f4       	brcc	.+34     	; 0xb8c <FUNCClearMem+0x86>
	  eeprom_write_byte_169(&EAddr, 0xFF);
     b6a:	6f ef       	ldi	r22, 0xFF	; 255
     b6c:	ce 01       	movw	r24, r28
     b6e:	01 96       	adiw	r24, 0x01	; 1
     b70:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
     b74:	89 81       	ldd	r24, Y+1	; 0x01
     b76:	9a 81       	ldd	r25, Y+2	; 0x02
     b78:	01 96       	adiw	r24, 0x01	; 1
     b7a:	9a 83       	std	Y+2, r25	; 0x02
     b7c:	89 83       	std	Y+1, r24	; 0x01
     b7e:	20 91 02 01 	lds	r18, 0x0102
     b82:	30 91 03 01 	lds	r19, 0x0103
     b86:	82 17       	cp	r24, r18
     b88:	93 07       	cpc	r25, r19
     b8a:	78 f3       	brcs	.-34     	; 0xb6a <FUNCClearMem+0x64>

	LCD_puts_f(PSTR("MEM CLEARED"));
     b8c:	8a ee       	ldi	r24, 0xEA	; 234
     b8e:	92 e0       	ldi	r25, 0x02	; 2
     b90:	0e 94 ff 07 	call	0xffe <LCD_puts_f>
	MAIN_Delay10MS(255);
     b94:	8f ef       	ldi	r24, 0xFF	; 255
     b96:	0e 94 2f 02 	call	0x45e <MAIN_Delay10MS>
     b9a:	22 96       	adiw	r28, 0x02	; 2
     b9c:	0f b6       	in	r0, 0x3f	; 63
     b9e:	f8 94       	cli
     ba0:	de bf       	out	0x3e, r29	; 62
     ba2:	0f be       	out	0x3f, r0	; 63
     ba4:	cd bf       	out	0x3d, r28	; 61
     ba6:	df 91       	pop	r29
     ba8:	cf 91       	pop	r28
     baa:	1f 91       	pop	r17
     bac:	0f 91       	pop	r16
     bae:	08 95       	ret

00000bb0 <FUNCAutoCalib>:
}

void FUNCAutoCalib(void)
{
	LCD_puts_f(WaitText);
     bb0:	8f e3       	ldi	r24, 0x3F	; 63
     bb2:	92 e0       	ldi	r25, 0x02	; 2
     bb4:	0e 94 ff 07 	call	0xffe <LCD_puts_f>
	OSCCAL_Calibrate();
     bb8:	0e 94 3a 07 	call	0xe74 <OSCCAL_Calibrate>
     bbc:	08 95       	ret

00000bbe <FUNCManCalib>:
}

void FUNCManCalib(void)
{
     bbe:	cf 93       	push	r28
     bc0:	df 93       	push	r29
     bc2:	cd b7       	in	r28, 0x3d	; 61
     bc4:	de b7       	in	r29, 0x3e	; 62
     bc6:	29 97       	sbiw	r28, 0x09	; 9
     bc8:	0f b6       	in	r0, 0x3f	; 63
     bca:	f8 94       	cli
     bcc:	de bf       	out	0x3e, r29	; 62
     bce:	0f be       	out	0x3f, r0	; 63
     bd0:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[9];

	JoyStatus = 1;                           // Invalid value to force the LCD to update
     bd2:	81 e0       	ldi	r24, 0x01	; 1
     bd4:	8e bb       	out	0x1e, r24	; 30
	
	USART_ENABLE(USART_TX_ON, USART_RX_OFF);
     bd6:	80 91 c1 00 	lds	r24, 0x00C1
     bda:	80 78       	andi	r24, 0x80	; 128
     bdc:	88 60       	ori	r24, 0x08	; 8
     bde:	80 93 c1 00 	sts	0x00C1, r24

	while (1)
	{
		if (BuffElements)                    // Routine will also echo send chars (directly accesses the ringbuffer count var)
     be2:	80 91 d1 02 	lds	r24, 0x02D1
     be6:	88 23       	and	r24, r24
     be8:	21 f0       	breq	.+8      	; 0xbf2 <FUNCManCalib+0x34>
		   USART_Tx(BUFF_GetBuffByte());
     bea:	0e 94 a5 0b 	call	0x174a <BUFF_GetBuffByte>
     bee:	0e 94 ef 08 	call	0x11de <USART_Tx>
	
		if (JoyStatus)
     bf2:	8e b3       	in	r24, 0x1e	; 30
     bf4:	88 23       	and	r24, r24
     bf6:	a9 f3       	breq	.-22     	; 0xbe2 <FUNCManCalib+0x24>
		{
			if (JoyStatus & JOY_UP)
     bf8:	f6 9b       	sbis	0x1e, 6	; 30
     bfa:	04 c0       	rjmp	.+8      	; 0xc04 <FUNCManCalib+0x46>
			  OSCCAL++;
     bfc:	80 91 66 00 	lds	r24, 0x0066
     c00:	8f 5f       	subi	r24, 0xFF	; 255
     c02:	05 c0       	rjmp	.+10     	; 0xc0e <FUNCManCalib+0x50>
			else if (JoyStatus & JOY_DOWN)
     c04:	f7 9b       	sbis	0x1e, 7	; 30
     c06:	06 c0       	rjmp	.+12     	; 0xc14 <FUNCManCalib+0x56>
			  OSCCAL--;
     c08:	80 91 66 00 	lds	r24, 0x0066
     c0c:	81 50       	subi	r24, 0x01	; 1
     c0e:	80 93 66 00 	sts	0x0066, r24
     c12:	02 c0       	rjmp	.+4      	; 0xc18 <FUNCManCalib+0x5a>
			else if (JoyStatus & JOY_LEFT)
     c14:	f2 99       	sbic	0x1e, 2	; 30
     c16:	1f c0       	rjmp	.+62     	; 0xc56 <FUNCManCalib+0x98>
			  break;
					
			// Copy the programmer name out of memory and transmit it via the USART:
			strcpy_P(Buffer, ProgrammerName);
     c18:	66 e3       	ldi	r22, 0x36	; 54
     c1a:	72 e0       	ldi	r23, 0x02	; 2
     c1c:	ce 01       	movw	r24, r28
     c1e:	01 96       	adiw	r24, 0x01	; 1
     c20:	0e 94 48 1b 	call	0x3690 <strcpy_P>
			USART_TxString(Buffer);
     c24:	ce 01       	movw	r24, r28
     c26:	01 96       	adiw	r24, 0x01	; 1
     c28:	0e 94 f7 08 	call	0x11ee <USART_TxString>

			Buffer[0] = 'C';
     c2c:	83 e4       	ldi	r24, 0x43	; 67
     c2e:	89 83       	std	Y+1, r24	; 0x01
			Buffer[1] = 'V';
     c30:	86 e5       	ldi	r24, 0x56	; 86
     c32:	8a 83       	std	Y+2, r24	; 0x02
			Buffer[2] = ' ';
     c34:	80 e2       	ldi	r24, 0x20	; 32
     c36:	8b 83       	std	Y+3, r24	; 0x03

			MAIN_IntToStr(OSCCAL, &Buffer[3]);
     c38:	80 91 66 00 	lds	r24, 0x0066
     c3c:	be 01       	movw	r22, r28
     c3e:	6c 5f       	subi	r22, 0xFC	; 252
     c40:	7f 4f       	sbci	r23, 0xFF	; 255
     c42:	99 27       	eor	r25, r25
     c44:	0e 94 36 03 	call	0x66c <MAIN_IntToStr>
			LCD_puts(Buffer);
     c48:	ce 01       	movw	r24, r28
     c4a:	01 96       	adiw	r24, 0x01	; 1
     c4c:	0e 94 be 07 	call	0xf7c <LCD_puts>

			MAIN_WaitForJoyRelease();
     c50:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     c54:	c6 cf       	rjmp	.-116    	; 0xbe2 <FUNCManCalib+0x24>
		}
	}
	
	USART_ENABLE(USART_TX_OFF, USART_RX_OFF);
     c56:	80 91 c1 00 	lds	r24, 0x00C1
     c5a:	80 78       	andi	r24, 0x80	; 128
     c5c:	80 93 c1 00 	sts	0x00C1, r24
     c60:	29 96       	adiw	r28, 0x09	; 9
     c62:	0f b6       	in	r0, 0x3f	; 63
     c64:	f8 94       	cli
     c66:	de bf       	out	0x3e, r29	; 62
     c68:	0f be       	out	0x3f, r0	; 63
     c6a:	cd bf       	out	0x3d, r28	; 61
     c6c:	df 91       	pop	r29
     c6e:	cf 91       	pop	r28
     c70:	08 95       	ret

00000c72 <FUNCSetContrast>:
}

void FUNCSetContrast(void)
{
     c72:	1f 93       	push	r17
     c74:	cf 93       	push	r28
     c76:	df 93       	push	r29
     c78:	cd b7       	in	r28, 0x3d	; 61
     c7a:	de b7       	in	r29, 0x3e	; 62
     c7c:	26 97       	sbiw	r28, 0x06	; 6
     c7e:	0f b6       	in	r0, 0x3f	; 63
     c80:	f8 94       	cli
     c82:	de bf       	out	0x3e, r29	; 62
     c84:	0f be       	out	0x3f, r0	; 63
     c86:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[6];
	uint8_t Contrast = (eeprom_read_byte_169(&Sys_LCDContrast) & 0x0F); // Ranges from 0-15 so mask retuns 15 on blank EEPROM (0xFF)
     c88:	84 e0       	ldi	r24, 0x04	; 4
     c8a:	91 e0       	ldi	r25, 0x01	; 1
     c8c:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
     c90:	18 2f       	mov	r17, r24
     c92:	1f 70       	andi	r17, 0x0F	; 15
	
	JoyStatus = 1;                          // Invalid value to force the LCD to update
     c94:	81 e0       	ldi	r24, 0x01	; 1
     c96:	8e bb       	out	0x1e, r24	; 30
	
	while (1)
	{
		if (JoyStatus)
     c98:	8e b3       	in	r24, 0x1e	; 30
     c9a:	88 23       	and	r24, r24
     c9c:	e9 f3       	breq	.-6      	; 0xc98 <FUNCSetContrast+0x26>
		{
			if (JoyStatus & JOY_UP)
     c9e:	f6 9b       	sbis	0x1e, 6	; 30
     ca0:	04 c0       	rjmp	.+8      	; 0xcaa <FUNCSetContrast+0x38>
			{
				if (Contrast < 15)
     ca2:	1f 30       	cpi	r17, 0x0F	; 15
     ca4:	80 f4       	brcc	.+32     	; 0xcc6 <FUNCSetContrast+0x54>
				  Contrast++;
     ca6:	1f 5f       	subi	r17, 0xFF	; 255
     ca8:	0e c0       	rjmp	.+28     	; 0xcc6 <FUNCSetContrast+0x54>
			}
			else if (JoyStatus & JOY_DOWN)
     caa:	f7 9b       	sbis	0x1e, 7	; 30
     cac:	04 c0       	rjmp	.+8      	; 0xcb6 <FUNCSetContrast+0x44>
			{
				if (Contrast > 1)          // Zero is non-visible, so 1 is the minimum
     cae:	12 30       	cpi	r17, 0x02	; 2
     cb0:	50 f0       	brcs	.+20     	; 0xcc6 <FUNCSetContrast+0x54>
				  Contrast--;
     cb2:	11 50       	subi	r17, 0x01	; 1
     cb4:	08 c0       	rjmp	.+16     	; 0xcc6 <FUNCSetContrast+0x54>
			}
			else if (JoyStatus & JOY_LEFT)
     cb6:	f2 9b       	sbis	0x1e, 2	; 30
     cb8:	06 c0       	rjmp	.+12     	; 0xcc6 <FUNCSetContrast+0x54>
			{
				eeprom_write_byte_169(&Sys_LCDContrast, Contrast);
     cba:	61 2f       	mov	r22, r17
     cbc:	84 e0       	ldi	r24, 0x04	; 4
     cbe:	91 e0       	ldi	r25, 0x01	; 1
     cc0:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
				return;
     cc4:	18 c0       	rjmp	.+48     	; 0xcf6 <FUNCSetContrast+0x84>
			}
					
			Buffer[0] = 'C';
     cc6:	83 e4       	ldi	r24, 0x43	; 67
     cc8:	89 83       	std	Y+1, r24	; 0x01
			Buffer[1] = 'T';
     cca:	84 e5       	ldi	r24, 0x54	; 84
     ccc:	8a 83       	std	Y+2, r24	; 0x02
			Buffer[2] = ' ';
     cce:	80 e2       	ldi	r24, 0x20	; 32
     cd0:	8b 83       	std	Y+3, r24	; 0x03

			MAIN_IntToStr((uint16_t)Contrast, &Buffer[3]);
     cd2:	be 01       	movw	r22, r28
     cd4:	6c 5f       	subi	r22, 0xFC	; 252
     cd6:	7f 4f       	sbci	r23, 0xFF	; 255
     cd8:	81 2f       	mov	r24, r17
     cda:	99 27       	eor	r25, r25
     cdc:	0e 94 36 03 	call	0x66c <MAIN_IntToStr>
			LCD_puts(Buffer);
     ce0:	ce 01       	movw	r24, r28
     ce2:	01 96       	adiw	r24, 0x01	; 1
     ce4:	0e 94 be 07 	call	0xf7c <LCD_puts>

			LCD_CONTRAST_LEVEL(Contrast);
     ce8:	81 2f       	mov	r24, r17
     cea:	8f 70       	andi	r24, 0x0F	; 15
     cec:	80 93 e7 00 	sts	0x00E7, r24

			MAIN_WaitForJoyRelease();
     cf0:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     cf4:	d1 cf       	rjmp	.-94     	; 0xc98 <FUNCSetContrast+0x26>
     cf6:	26 96       	adiw	r28, 0x06	; 6
     cf8:	0f b6       	in	r0, 0x3f	; 63
     cfa:	f8 94       	cli
     cfc:	de bf       	out	0x3e, r29	; 62
     cfe:	0f be       	out	0x3f, r0	; 63
     d00:	cd bf       	out	0x3d, r28	; 61
     d02:	df 91       	pop	r29
     d04:	cf 91       	pop	r28
     d06:	1f 91       	pop	r17
     d08:	08 95       	ret

00000d0a <FUNCSetISPSpeed>:
		}
	}
}

void FUNCSetISPSpeed(void)
{
     d0a:	cf 93       	push	r28
	JoyStatus = 1;                         // Invalid value to force the LCD to update
     d0c:	81 e0       	ldi	r24, 0x01	; 1
     d0e:	8e bb       	out	0x1e, r24	; 30

	uint8_t CurrSpeed = eeprom_read_byte_169(&Param_SCKDuration);
     d10:	80 e2       	ldi	r24, 0x20	; 32
     d12:	91 e0       	ldi	r25, 0x01	; 1
     d14:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
     d18:	c8 2f       	mov	r28, r24

	if (CurrSpeed > (USI_PRESET_SPEEDS - 1)) CurrSpeed = 0; // Protection against blank EEPROM
     d1a:	84 30       	cpi	r24, 0x04	; 4
     d1c:	08 f0       	brcs	.+2      	; 0xd20 <FUNCSetISPSpeed+0x16>
     d1e:	c0 e0       	ldi	r28, 0x00	; 0

	while (1)
	{
		if (JoyStatus)
     d20:	8e b3       	in	r24, 0x1e	; 30
     d22:	88 23       	and	r24, r24
     d24:	e9 f3       	breq	.-6      	; 0xd20 <FUNCSetISPSpeed+0x16>
		{
			if (JoyStatus & JOY_UP)
     d26:	f6 9b       	sbis	0x1e, 6	; 30
     d28:	06 c0       	rjmp	.+12     	; 0xd36 <FUNCSetISPSpeed+0x2c>
			{
				(CurrSpeed == 0)? CurrSpeed = (USI_PRESET_SPEEDS - 1) : CurrSpeed--;
     d2a:	cc 23       	and	r28, r28
     d2c:	11 f4       	brne	.+4      	; 0xd32 <FUNCSetISPSpeed+0x28>
     d2e:	c3 e0       	ldi	r28, 0x03	; 3
     d30:	12 c0       	rjmp	.+36     	; 0xd56 <FUNCSetISPSpeed+0x4c>
     d32:	c1 50       	subi	r28, 0x01	; 1
     d34:	10 c0       	rjmp	.+32     	; 0xd56 <FUNCSetISPSpeed+0x4c>
			}
			else if (JoyStatus & JOY_DOWN)
     d36:	f7 9b       	sbis	0x1e, 7	; 30
     d38:	06 c0       	rjmp	.+12     	; 0xd46 <FUNCSetISPSpeed+0x3c>
			{
				(CurrSpeed == (USI_PRESET_SPEEDS - 1))? CurrSpeed = 0 : CurrSpeed++;
     d3a:	c3 30       	cpi	r28, 0x03	; 3
     d3c:	11 f4       	brne	.+4      	; 0xd42 <FUNCSetISPSpeed+0x38>
     d3e:	c0 e0       	ldi	r28, 0x00	; 0
     d40:	0a c0       	rjmp	.+20     	; 0xd56 <FUNCSetISPSpeed+0x4c>
     d42:	cf 5f       	subi	r28, 0xFF	; 255
     d44:	08 c0       	rjmp	.+16     	; 0xd56 <FUNCSetISPSpeed+0x4c>
			}
			else if (JoyStatus & JOY_LEFT)
     d46:	f2 9b       	sbis	0x1e, 2	; 30
     d48:	06 c0       	rjmp	.+12     	; 0xd56 <FUNCSetISPSpeed+0x4c>
			{
				eeprom_write_byte_169(&Param_SCKDuration, CurrSpeed);
     d4a:	6c 2f       	mov	r22, r28
     d4c:	80 e2       	ldi	r24, 0x20	; 32
     d4e:	91 e0       	ldi	r25, 0x01	; 1
     d50:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
				return;
     d54:	0d c0       	rjmp	.+26     	; 0xd70 <FUNCSetISPSpeed+0x66>
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&USIPSNamePtrs[CurrSpeed]));
     d56:	ec 2f       	mov	r30, r28
     d58:	ff 27       	eor	r31, r31
     d5a:	ee 0f       	add	r30, r30
     d5c:	ff 1f       	adc	r31, r31
     d5e:	e3 58       	subi	r30, 0x83	; 131
     d60:	ff 4f       	sbci	r31, 0xFF	; 255
     d62:	85 91       	lpm	r24, Z+
     d64:	94 91       	lpm	r25, Z
     d66:	0e 94 ff 07 	call	0xffe <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     d6a:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     d6e:	d8 cf       	rjmp	.-80     	; 0xd20 <FUNCSetISPSpeed+0x16>
     d70:	cf 91       	pop	r28
     d72:	08 95       	ret

00000d74 <FUNCSleepMode>:
		}
	}
}

void FUNCSleepMode(void)
{
	SMCR    = ((1 << SM1) | (1 << SE));   // Power down sleep mode
     d74:	85 e0       	ldi	r24, 0x05	; 5
     d76:	83 bf       	out	0x33, r24	; 51
	LCDCRA &= ~(1 << LCDEN); 
     d78:	80 91 e4 00 	lds	r24, 0x00E4
     d7c:	8f 77       	andi	r24, 0x7F	; 127
     d7e:	80 93 e4 00 	sts	0x00E4, r24
	
	while (!(JoyStatus & JOY_UP))        // Joystick interrupt wakes the micro
	  SLEEP();
     d82:	f6 99       	sbic	0x1e, 6	; 30
     d84:	03 c0       	rjmp	.+6      	; 0xd8c <FUNCSleepMode+0x18>
     d86:	88 95       	sleep
     d88:	f6 9b       	sbis	0x1e, 6	; 30
     d8a:	fd cf       	rjmp	.-6      	; 0xd86 <FUNCSleepMode+0x12>
	   
	LCDCRA |= (1 << LCDEN);
     d8c:	80 91 e4 00 	lds	r24, 0x00E4
     d90:	80 68       	ori	r24, 0x80	; 128
     d92:	80 93 e4 00 	sts	0x00E4, r24

	LCD_puts_f(WaitText);
     d96:	8f e3       	ldi	r24, 0x3F	; 63
     d98:	92 e0       	ldi	r25, 0x02	; 2
     d9a:	0e 94 ff 07 	call	0xffe <LCD_puts_f>
	OSCCAL_Calibrate();	
     d9e:	0e 94 3a 07 	call	0xe74 <OSCCAL_Calibrate>
	
	MAIN_WaitForJoyRelease();
     da2:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     da6:	08 95       	ret

00000da8 <FUNCStorageInfo>:
}

void FUNCStorageInfo(void)
{
     da8:	1f 93       	push	r17
     daa:	cf 93       	push	r28
	uint8_t SelectedItem = 0;
     dac:	10 e0       	ldi	r17, 0x00	; 0

	MAIN_WaitForJoyRelease();
     dae:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>

	JoyStatus = 1;                         // Invalid value to force the LCD to update
     db2:	81 e0       	ldi	r24, 0x01	; 1
     db4:	8e bb       	out	0x1e, r24	; 30

	while (1)
	{
		if (JoyStatus)
     db6:	8e b3       	in	r24, 0x1e	; 30
     db8:	88 23       	and	r24, r24
     dba:	e9 f3       	breq	.-6      	; 0xdb6 <FUNCStorageInfo+0xe>
		{
			if (JoyStatus & (JOY_UP | JOY_DOWN))
     dbc:	ce b3       	in	r28, 0x1e	; 30
     dbe:	c0 7c       	andi	r28, 0xC0	; 192
     dc0:	19 f0       	breq	.+6      	; 0xdc8 <FUNCStorageInfo+0x20>
			{
				SelectedItem ^= 1;
     dc2:	81 e0       	ldi	r24, 0x01	; 1
     dc4:	18 27       	eor	r17, r24
     dc6:	38 c0       	rjmp	.+112    	; 0xe38 <FUNCStorageInfo+0x90>
			}
			else if (JoyStatus & JOY_LEFT)
     dc8:	f2 99       	sbic	0x1e, 2	; 30
     dca:	43 c0       	rjmp	.+134    	; 0xe52 <FUNCStorageInfo+0xaa>
			{
				return;
			}
			else if (JoyStatus & JOY_PRESS)
     dcc:	f4 9b       	sbis	0x1e, 4	; 30
     dce:	34 c0       	rjmp	.+104    	; 0xe38 <FUNCStorageInfo+0x90>
			{
				if (SelectedItem == 1)    // View storage tags
     dd0:	11 30       	cpi	r17, 0x01	; 1
     dd2:	81 f5       	brne	.+96     	; 0xe34 <FUNCStorageInfo+0x8c>
				{
					DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
     dd4:	82 e4       	ldi	r24, 0x42	; 66
     dd6:	99 e0       	ldi	r25, 0x09	; 9
     dd8:	90 93 01 01 	sts	0x0101, r25
     ddc:	80 93 00 01 	sts	0x0100, r24
					SPI_SPIInit();
     de0:	0e 94 38 09 	call	0x1270 <SPI_SPIInit>
					UseExernalDF = FALSE;
     de4:	c0 93 83 02 	sts	0x0283, r28
					DF_EnableDataflash(TRUE);
     de8:	81 2f       	mov	r24, r17
     dea:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>

					if (DF_CheckCorrectOnboardChip())
     dee:	0e 94 5a 0b 	call	0x16b4 <DF_CheckCorrectOnboardChip>
     df2:	c8 2f       	mov	r28, r24
     df4:	88 23       	and	r24, r24
     df6:	41 f0       	breq	.+16     	; 0xe08 <FUNCStorageInfo+0x60>
					{
						TM_ShowTags();
     df8:	0e 94 1a 1b 	call	0x3634 <TM_ShowTags>
						SPI_SPIOFF();
     dfc:	80 91 64 00 	lds	r24, 0x0064
     e00:	84 60       	ori	r24, 0x04	; 4
     e02:	80 93 64 00 	sts	0x0064, r24
     e06:	18 c0       	rjmp	.+48     	; 0xe38 <FUNCStorageInfo+0x90>
					}
					else if (!(PM_GetStoredDataSize(TYPE_FLASH)))
     e08:	81 2f       	mov	r24, r17
     e0a:	0e 94 80 13 	call	0x2700 <PM_GetStoredDataSize>
     e0e:	dc 01       	movw	r26, r24
     e10:	cb 01       	movw	r24, r22
     e12:	00 97       	sbiw	r24, 0x00	; 0
     e14:	a1 05       	cpc	r26, r1
     e16:	b1 05       	cpc	r27, r1
     e18:	79 f4       	brne	.+30     	; 0xe38 <FUNCStorageInfo+0x90>
					{
						DF_EnableDataflash(FALSE);
     e1a:	8c 2f       	mov	r24, r28
     e1c:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
						SPI_SPIOFF();
     e20:	80 91 64 00 	lds	r24, 0x0064
     e24:	84 60       	ori	r24, 0x04	; 4
     e26:	80 93 64 00 	sts	0x0064, r24

						MAIN_ShowError(PSTR("NO STORED PRGM"));
     e2a:	86 ef       	ldi	r24, 0xF6	; 246
     e2c:	92 e0       	ldi	r25, 0x02	; 2
     e2e:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
     e32:	02 c0       	rjmp	.+4      	; 0xe38 <FUNCStorageInfo+0x90>
					}	
				}
				else                  // View stored data sizes
				{
					PM_ShowStoredItemSizes();
     e34:	0e 94 f6 19 	call	0x33ec <PM_ShowStoredItemSizes>
				}
			}
			
			LCD_puts_f((uint8_t*)pgm_read_word(&SIFOOptionPtrs[SelectedItem]));
     e38:	e1 2f       	mov	r30, r17
     e3a:	ff 27       	eor	r31, r31
     e3c:	ee 0f       	add	r30, r30
     e3e:	ff 1f       	adc	r31, r31
     e40:	e4 5a       	subi	r30, 0xA4	; 164
     e42:	ff 4f       	sbci	r31, 0xFF	; 255
     e44:	85 91       	lpm	r24, Z+
     e46:	94 91       	lpm	r25, Z
     e48:	0e 94 ff 07 	call	0xffe <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     e4c:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
     e50:	b2 cf       	rjmp	.-156    	; 0xdb6 <FUNCStorageInfo+0xe>
     e52:	cf 91       	pop	r28
     e54:	1f 91       	pop	r17
     e56:	08 95       	ret

00000e58 <FUNCGoBootloader>:
		}
	}
}

void FUNCGoBootloader(void)
{
	uint8_t MD = (MCUCR & ~(1 << JTD)); // Forces compiler to use IN, AND plus two OUTs rather than two lots of IN/AND/OUTs
     e58:	85 b7       	in	r24, 0x35	; 53
     e5a:	8f 77       	andi	r24, 0x7F	; 127
	MCUCR = MD;  // Turn on JTAG via code
     e5c:	85 bf       	out	0x35, r24	; 53
	MCUCR = MD;  // Twice as specified in datasheet        
     e5e:	85 bf       	out	0x35, r24	; 53
	
	LCD_puts_f(PSTR("*JTAG ON*"));
     e60:	85 e0       	ldi	r24, 0x05	; 5
     e62:	93 e0       	ldi	r25, 0x03	; 3
     e64:	0e 94 ff 07 	call	0xffe <LCD_puts_f>
	
	MAIN_WaitForJoyRelease();
     e68:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
	
	WDTCR = ((1<<WDCE) | (1<<WDE)); // Enable Watchdog Timer to give reset after minimum timeout
     e6c:	88 e1       	ldi	r24, 0x18	; 24
     e6e:	80 93 60 00 	sts	0x0060, r24
	while (1) {};                  // Eternal loop - when watchdog resets the AVR it will enter the bootloader
     e72:	ff cf       	rjmp	.-2      	; 0xe72 <FUNCGoBootloader+0x1a>

00000e74 <OSCCAL_Calibrate>:
	unsigned char SREG_Backup;
	unsigned char LoopCount = 64; // Maximum range is 128, and starts from the middle, so 64 is the max number of iterations required
   
	// Make sure all clock division is turned off (8Mhz RC clock)
	CLKPR = (1 << CLKPCE);
     e74:	80 e8       	ldi	r24, 0x80	; 128
     e76:	80 93 61 00 	sts	0x0061, r24
	CLKPR = 0;
     e7a:	10 92 61 00 	sts	0x0061, r1

	// Inital OSCCAL of half its maximum for speed
	OSCCAL = (0x7F / 2);
     e7e:	8f e3       	ldi	r24, 0x3F	; 63
     e80:	80 93 66 00 	sts	0x0066, r24

	//Save the SREG
	SREG_Backup = SREG;
     e84:	3f b7       	in	r19, 0x3f	; 63
    
	// Disable all timer 1 interrupts
	TIMSK1 = 0;
     e86:	10 92 6f 00 	sts	0x006F, r1
        
	// Set timer 2 to asyncronous mode (32.768KHz crystal)
	ASSR  = (1 << AS2);
     e8a:	88 e0       	ldi	r24, 0x08	; 8
     e8c:	80 93 b6 00 	sts	0x00B6, r24
        
	// Timer 2 overflow interrupt enable
	TIMSK2 = (1 << TOIE2);
     e90:	81 e0       	ldi	r24, 0x01	; 1
     e92:	80 93 70 00 	sts	0x0070, r24

	//Enable interrupts
	sei();
     e96:	78 94       	sei

	// Start both counters with no prescaling
	TCCR1B = (1 << CS10);
     e98:	80 93 81 00 	sts	0x0081, r24
	TCCR2A = (1 << CS20);
     e9c:	80 93 b0 00 	sts	0x00B0, r24
	 	 
	// Wait until timer 2's external 32.768KHz crystal is stable
	while (ASSR & ((1 << TCN2UB) | (1 << TCR2UB) | (1 << OCR2UB)));
     ea0:	80 91 b6 00 	lds	r24, 0x00B6
     ea4:	99 27       	eor	r25, r25
     ea6:	87 70       	andi	r24, 0x07	; 7
     ea8:	90 70       	andi	r25, 0x00	; 0
     eaa:	00 97       	sbiw	r24, 0x00	; 0
     eac:	c9 f7       	brne	.-14     	; 0xea0 <OSCCAL_Calibrate+0x2c>
    
	// Clear the timer values
	TCNT1 = 0;
     eae:	90 93 85 00 	sts	0x0085, r25
     eb2:	80 93 84 00 	sts	0x0084, r24
	TCNT2 = 0;
     eb6:	10 92 b2 00 	sts	0x00B2, r1
    
	while (LoopCount--)
	{
		// Let it take a few readings (60ms, approx 7 readings)
		_delay_ms(60);
        
		if (ActualCount > (TARGETCOUNT + 5))		    // Clock is running too fast
		{
			// Bit 7 selects low or high range - only low range is nessesary
			OSCCAL = ((OSCCAL - 1) & ~(1 << 7));
		}
		else if (ActualCount < (TARGETCOUNT - 5))		// Clock is running too slow
		{
			// Bit 7 selects low or high range - only low range is nessesary
			OSCCAL = ((OSCCAL + 1) & ~(1 << 7));
		}
		else		                                    // Clock is just right
		{
			break;
     eba:	2f e3       	ldi	r18, 0x3F	; 63
     ebc:	fc 01       	movw	r30, r24
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     ebe:	cf 01       	movw	r24, r30
     ec0:	01 97       	sbiw	r24, 0x01	; 1
     ec2:	f1 f7       	brne	.-4      	; 0xec0 <OSCCAL_Calibrate+0x4c>
     ec4:	80 91 26 01 	lds	r24, 0x0126
     ec8:	90 91 27 01 	lds	r25, 0x0127
     ecc:	81 50       	subi	r24, 0x01	; 1
     ece:	91 4e       	sbci	r25, 0xE1	; 225
     ed0:	20 f0       	brcs	.+8      	; 0xeda <OSCCAL_Calibrate+0x66>
     ed2:	80 91 66 00 	lds	r24, 0x0066
     ed6:	81 50       	subi	r24, 0x01	; 1
     ed8:	0a c0       	rjmp	.+20     	; 0xeee <OSCCAL_Calibrate+0x7a>
     eda:	80 91 26 01 	lds	r24, 0x0126
     ede:	90 91 27 01 	lds	r25, 0x0127
     ee2:	86 5f       	subi	r24, 0xF6	; 246
     ee4:	90 4e       	sbci	r25, 0xE0	; 224
     ee6:	40 f4       	brcc	.+16     	; 0xef8 <OSCCAL_Calibrate+0x84>
     ee8:	80 91 66 00 	lds	r24, 0x0066
     eec:	8f 5f       	subi	r24, 0xFF	; 255
     eee:	8f 77       	andi	r24, 0x7F	; 127
     ef0:	80 93 66 00 	sts	0x0066, r24
     ef4:	21 50       	subi	r18, 0x01	; 1
     ef6:	18 f7       	brcc	.-58     	; 0xebe <OSCCAL_Calibrate+0x4a>
		}		
	}
            
	// Disable all timer interrupts
	TIMSK1 = 0;
     ef8:	10 92 6f 00 	sts	0x006F, r1
	TIMSK2 = 0;
     efc:	10 92 70 00 	sts	0x0070, r1
    
	// Stop the timers
	TCCR1B = 0x00;
     f00:	10 92 81 00 	sts	0x0081, r1
	TCCR2A = 0x00;
     f04:	10 92 b0 00 	sts	0x00B0, r1

	// Turn off timer 2 asynchronous mode
	ASSR  &= ~(1 << AS2);
     f08:	80 91 b6 00 	lds	r24, 0x00B6
     f0c:	87 7f       	andi	r24, 0xF7	; 247
     f0e:	80 93 b6 00 	sts	0x00B6, r24

	// Restore SREG
	SREG = SREG_Backup;
     f12:	3f bf       	out	0x3f, r19	; 63
     f14:	08 95       	ret

00000f16 <__vector_5>:
        
	return;
}

ISR(TIMER2_OVF_vect, ISR_BLOCK) // Occurs 32768/256 timers per second, or 128Hz
{
     f16:	1f 92       	push	r1
     f18:	0f 92       	push	r0
     f1a:	0f b6       	in	r0, 0x3f	; 63
     f1c:	0f 92       	push	r0
     f1e:	11 24       	eor	r1, r1
     f20:	8f 93       	push	r24
     f22:	9f 93       	push	r25
	// Stop timer 1 so it can be read
	TCCR1B = 0x00;
     f24:	10 92 81 00 	sts	0x0081, r1
    
	// Record timer 1's value
	ActualCount = TCNT1;
     f28:	80 91 84 00 	lds	r24, 0x0084
     f2c:	90 91 85 00 	lds	r25, 0x0085
     f30:	90 93 27 01 	sts	0x0127, r25
     f34:	80 93 26 01 	sts	0x0126, r24
	     
	// Reset counters and restart timer 1
	TCNT1  = 0;
     f38:	10 92 85 00 	sts	0x0085, r1
     f3c:	10 92 84 00 	sts	0x0084, r1
	TCNT2  = 0;
     f40:	10 92 b2 00 	sts	0x00B2, r1
	TCCR1B = (1 << CS10);
     f44:	81 e0       	ldi	r24, 0x01	; 1
     f46:	80 93 81 00 	sts	0x0081, r24
     f4a:	9f 91       	pop	r25
     f4c:	8f 91       	pop	r24
     f4e:	0f 90       	pop	r0
     f50:	0f be       	out	0x3f, r0	; 63
     f52:	0f 90       	pop	r0
     f54:	1f 90       	pop	r1
     f56:	18 95       	reti

00000f58 <LCD_Init>:
// ======================================================================================

void LCD_Init(void)
{
	LCDCCR = 0x0F;
     f58:	8f e0       	ldi	r24, 0x0F	; 15
     f5a:	80 93 e7 00 	sts	0x00E7, r24

    // Select asynchronous clock source, enable all COM pins and enable all segment pins.
    LCDCRB  = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
     f5e:	87 eb       	ldi	r24, 0xB7	; 183
     f60:	80 93 e5 00 	sts	0x00E5, r24

    // Set LCD prescaler to give a framerate of 32,0 Hz
    LCDFRR  = (0<<LCDPS0) | (7<<LCDCD0);    
     f64:	87 e0       	ldi	r24, 0x07	; 7
     f66:	80 93 e6 00 	sts	0x00E6, r24

	// Enable LCD and set low power waveform
    LCDCRA  = (1<<LCDEN) | (1<<LCDAB); 
     f6a:	80 ec       	ldi	r24, 0xC0	; 192
     f6c:	80 93 e4 00 	sts	0x00E4, r24

    //Enable LCD start of frame interrupt
    LCDCRA |= (1<<LCDIE);
     f70:	80 91 e4 00 	lds	r24, 0x00E4
     f74:	88 60       	ori	r24, 0x08	; 8
     f76:	80 93 e4 00 	sts	0x00E4, r24
     f7a:	08 95       	ret

00000f7c <LCD_puts>:
}

void LCD_puts_f(const uint8_t *FlashData)
{
	uint8_t StrBuff[LCD_TEXTBUFFER_SIZE];

	strcpy_P(StrBuff, FlashData);
	LCD_puts(StrBuff);
}

void LCD_puts(uint8_t *Data)
{
     f7c:	cf 93       	push	r28
     f7e:	df 93       	push	r29
     f80:	ec 01       	movw	r28, r24
	uint8_t LoadB;
	
	for (LoadB = 0; LoadB < 20; LoadB++)
     f82:	20 e0       	ldi	r18, 0x00	; 0
     f84:	3f ef       	ldi	r19, 0xFF	; 255
     f86:	ef e4       	ldi	r30, 0x4F	; 79
     f88:	f2 e0       	ldi	r31, 0x02	; 2
     f8a:	df 01       	movw	r26, r30
	{
		uint8_t CByte = *(Data++);
     f8c:	89 91       	ld	r24, Y+
	
		if ((CByte >= '*') && (CByte <= 'z'))
     f8e:	98 2f       	mov	r25, r24
     f90:	9a 52       	subi	r25, 0x2A	; 42
     f92:	91 35       	cpi	r25, 0x51	; 81
     f94:	38 f4       	brcc	.+14     	; 0xfa4 <LCD_puts+0x28>
		  TextBuffer[LoadB] = ((CByte == ' ')? 0xFF : (CByte - '*'));
     f96:	80 32       	cpi	r24, 0x20	; 32
     f98:	11 f0       	breq	.+4      	; 0xf9e <LCD_puts+0x22>
     f9a:	89 2f       	mov	r24, r25
     f9c:	01 c0       	rjmp	.+2      	; 0xfa0 <LCD_puts+0x24>
     f9e:	8f ef       	ldi	r24, 0xFF	; 255
     fa0:	8c 93       	st	X, r24
     fa2:	03 c0       	rjmp	.+6      	; 0xfaa <LCD_puts+0x2e>
		else if (CByte == 0x00)
     fa4:	88 23       	and	r24, r24
     fa6:	31 f0       	breq	.+12     	; 0xfb4 <LCD_puts+0x38>
		  break;
		else
		  TextBuffer[LoadB] = 0xFF;		
     fa8:	30 83       	st	Z, r19
     faa:	2f 5f       	subi	r18, 0xFF	; 255
     fac:	11 96       	adiw	r26, 0x01	; 1
     fae:	31 96       	adiw	r30, 0x01	; 1
     fb0:	24 31       	cpi	r18, 0x14	; 20
     fb2:	60 f3       	brcs	.-40     	; 0xf8c <LCD_puts+0x10>
	}

	ScrollMode  = ((LoadB > 6)? TRUE : FALSE);
     fb4:	80 e0       	ldi	r24, 0x00	; 0
     fb6:	27 30       	cpi	r18, 0x07	; 7
     fb8:	08 f0       	brcs	.+2      	; 0xfbc <LCD_puts+0x40>
     fba:	81 e0       	ldi	r24, 0x01	; 1
     fbc:	80 93 7f 02 	sts	0x027F, r24
	ScrollCount = 0;
     fc0:	10 92 4d 02 	sts	0x024D, r1
     fc4:	9f ef       	ldi	r25, 0xFF	; 255
     fc6:	86 e0       	ldi	r24, 0x06	; 6

	for (uint8_t Nulls = 0; Nulls < 7; Nulls++)
		TextBuffer[LoadB++] = 0xFF;
     fc8:	e2 2f       	mov	r30, r18
     fca:	ff 27       	eor	r31, r31
     fcc:	e1 5b       	subi	r30, 0xB1	; 177
     fce:	fd 4f       	sbci	r31, 0xFD	; 253
     fd0:	90 83       	st	Z, r25
     fd2:	2f 5f       	subi	r18, 0xFF	; 255
     fd4:	81 50       	subi	r24, 0x01	; 1
     fd6:	87 ff       	sbrs	r24, 7
     fd8:	f7 cf       	rjmp	.-18     	; 0xfc8 <LCD_puts+0x4c>
	
	TextBuffer[LoadB] = 0x00;
     fda:	e2 2f       	mov	r30, r18
     fdc:	ff 27       	eor	r31, r31
     fde:	e1 5b       	subi	r30, 0xB1	; 177
     fe0:	fd 4f       	sbci	r31, 0xFD	; 253
     fe2:	10 82       	st	Z, r1
	StrStart   = 0;
     fe4:	10 92 4e 02 	sts	0x024E, r1
	StrEnd     = LoadB;	
     fe8:	20 93 4c 02 	sts	0x024C, r18
	DelayCount = LCD_DELAYCOUNT_DEFAULT;
     fec:	8a e0       	ldi	r24, 0x0A	; 10
     fee:	80 93 80 02 	sts	0x0280, r24

	UpdateLCD  = TRUE;
     ff2:	81 e0       	ldi	r24, 0x01	; 1
     ff4:	80 93 6a 02 	sts	0x026A, r24
     ff8:	df 91       	pop	r29
     ffa:	cf 91       	pop	r28
     ffc:	08 95       	ret

00000ffe <LCD_puts_f>:
     ffe:	cf 93       	push	r28
    1000:	df 93       	push	r29
    1002:	cd b7       	in	r28, 0x3d	; 61
    1004:	de b7       	in	r29, 0x3e	; 62
    1006:	64 97       	sbiw	r28, 0x14	; 20
    1008:	0f b6       	in	r0, 0x3f	; 63
    100a:	f8 94       	cli
    100c:	de bf       	out	0x3e, r29	; 62
    100e:	0f be       	out	0x3f, r0	; 63
    1010:	cd bf       	out	0x3d, r28	; 61
    1012:	bc 01       	movw	r22, r24
    1014:	ce 01       	movw	r24, r28
    1016:	01 96       	adiw	r24, 0x01	; 1
    1018:	0e 94 48 1b 	call	0x3690 <strcpy_P>
    101c:	ce 01       	movw	r24, r28
    101e:	01 96       	adiw	r24, 0x01	; 1
    1020:	0e 94 be 07 	call	0xf7c <LCD_puts>
    1024:	64 96       	adiw	r28, 0x14	; 20
    1026:	0f b6       	in	r0, 0x3f	; 63
    1028:	f8 94       	cli
    102a:	de bf       	out	0x3e, r29	; 62
    102c:	0f be       	out	0x3f, r0	; 63
    102e:	cd bf       	out	0x3d, r28	; 61
    1030:	df 91       	pop	r29
    1032:	cf 91       	pop	r28
    1034:	08 95       	ret

00001036 <LCD_WriteChar>:
}

void LCD_WriteChar(uint8_t Byte, uint8_t Digit)
{
    1036:	e8 2f       	mov	r30, r24
	uint16_t SegData  = 0x00;
    1038:	20 e0       	ldi	r18, 0x00	; 0
    103a:	30 e0       	ldi	r19, 0x00	; 0
	uint8_t  *BuffPtr = (&SegBuffer[0] + (Digit >> 1));
    103c:	86 2f       	mov	r24, r22
    103e:	86 95       	lsr	r24
    1040:	a8 2f       	mov	r26, r24
    1042:	bb 27       	eor	r27, r27
    1044:	a5 59       	subi	r26, 0x95	; 149
    1046:	bd 4f       	sbci	r27, 0xFD	; 253

	if (Byte != 0xFF)
    1048:	ef 3f       	cpi	r30, 0xFF	; 255
    104a:	39 f0       	breq	.+14     	; 0x105a <LCD_WriteChar+0x24>
	  SegData = pgm_read_word(&LCD_SegTable[Byte]);	
    104c:	ff 27       	eor	r31, r31
    104e:	ee 0f       	add	r30, r30
    1050:	ff 1f       	adc	r31, r31
    1052:	e1 5f       	subi	r30, 0xF1	; 241
    1054:	fc 4f       	sbci	r31, 0xFC	; 252
    1056:	25 91       	lpm	r18, Z+
    1058:	34 91       	lpm	r19, Z
    105a:	77 27       	eor	r23, r23
    105c:	61 70       	andi	r22, 0x01	; 1
    105e:	70 70       	andi	r23, 0x00	; 0
    1060:	43 e0       	ldi	r20, 0x03	; 3

	for (uint8_t BNib = 0; BNib < 4; BNib++)
	{
		uint8_t Mask          = 0xF0;
    1062:	50 ef       	ldi	r21, 0xF0	; 240
		uint8_t MaskedSegData = (SegData & 0x0000F);
    1064:	92 2f       	mov	r25, r18
    1066:	9f 70       	andi	r25, 0x0F	; 15
	
		if (Digit & 0x01)
    1068:	61 15       	cp	r22, r1
    106a:	71 05       	cpc	r23, r1
    106c:	19 f0       	breq	.+6      	; 0x1074 <LCD_WriteChar+0x3e>
		{
			Mask = 0x0F;
    106e:	5f e0       	ldi	r21, 0x0F	; 15
			MaskedSegData <<= 4;
    1070:	92 95       	swap	r25
    1072:	90 7f       	andi	r25, 0xF0	; 240
		}
		
		*BuffPtr = ((*BuffPtr & Mask) | MaskedSegData);
    1074:	8c 91       	ld	r24, X
    1076:	85 23       	and	r24, r21
    1078:	89 2b       	or	r24, r25
    107a:	8c 93       	st	X, r24

		SegData >>= 4;
    107c:	84 e0       	ldi	r24, 0x04	; 4
    107e:	36 95       	lsr	r19
    1080:	27 95       	ror	r18
    1082:	8a 95       	dec	r24
    1084:	e1 f7       	brne	.-8      	; 0x107e <LCD_WriteChar+0x48>
		BuffPtr  += 5;
    1086:	15 96       	adiw	r26, 0x05	; 5
    1088:	41 50       	subi	r20, 0x01	; 1
    108a:	47 ff       	sbrs	r20, 7
    108c:	ea cf       	rjmp	.-44     	; 0x1062 <LCD_WriteChar+0x2c>
    108e:	08 95       	ret

00001090 <__vector_22>:
	}
}

ISR(LCD_vect, ISR_NOBLOCK)
{
    1090:	78 94       	sei
    1092:	1f 92       	push	r1
    1094:	0f 92       	push	r0
    1096:	0f b6       	in	r0, 0x3f	; 63
    1098:	0f 92       	push	r0
    109a:	11 24       	eor	r1, r1
    109c:	2f 93       	push	r18
    109e:	3f 93       	push	r19
    10a0:	4f 93       	push	r20
    10a2:	5f 93       	push	r21
    10a4:	6f 93       	push	r22
    10a6:	7f 93       	push	r23
    10a8:	8f 93       	push	r24
    10aa:	9f 93       	push	r25
    10ac:	af 93       	push	r26
    10ae:	bf 93       	push	r27
    10b0:	cf 93       	push	r28
    10b2:	ef 93       	push	r30
    10b4:	ff 93       	push	r31
	if (ScrollMode)
    10b6:	80 91 7f 02 	lds	r24, 0x027F
    10ba:	88 23       	and	r24, r24
    10bc:	99 f0       	breq	.+38     	; 0x10e4 <__vector_22+0x54>
	{
		if (DelayCount)
    10be:	80 91 80 02 	lds	r24, 0x0280
    10c2:	88 23       	and	r24, r24
    10c4:	21 f0       	breq	.+8      	; 0x10ce <__vector_22+0x3e>
		{
			DelayCount--;
    10c6:	81 50       	subi	r24, 0x01	; 1
    10c8:	80 93 80 02 	sts	0x0280, r24
    10cc:	0b c0       	rjmp	.+22     	; 0x10e4 <__vector_22+0x54>
		}
		else
		{
			if (!(ScrollCount))
    10ce:	80 91 4d 02 	lds	r24, 0x024D
    10d2:	88 23       	and	r24, r24
    10d4:	21 f4       	brne	.+8      	; 0x10de <__vector_22+0x4e>
			  UpdateLCD = TRUE;
    10d6:	81 e0       	ldi	r24, 0x01	; 1
    10d8:	80 93 6a 02 	sts	0x026A, r24
    10dc:	03 c0       	rjmp	.+6      	; 0x10e4 <__vector_22+0x54>
			else
			  ScrollCount--;
    10de:	81 50       	subi	r24, 0x01	; 1
    10e0:	80 93 4d 02 	sts	0x024D, r24
		}
	}

	if (UpdateLCD)
    10e4:	80 91 6a 02 	lds	r24, 0x026A
    10e8:	88 23       	and	r24, r24
    10ea:	39 f1       	breq	.+78     	; 0x113a <__vector_22+0xaa>
	{
		for (uint8_t Character = 0; Character < 6; Character++)
    10ec:	c0 e0       	ldi	r28, 0x00	; 0
		{
			uint8_t Byte = (StrStart + Character);
    10ee:	80 91 4e 02 	lds	r24, 0x024E
    10f2:	8c 0f       	add	r24, r28

			if (Byte >= StrEnd)
    10f4:	90 91 4c 02 	lds	r25, 0x024C
    10f8:	e8 2f       	mov	r30, r24
    10fa:	ff 27       	eor	r31, r31
    10fc:	89 17       	cp	r24, r25
    10fe:	10 f0       	brcs	.+4      	; 0x1104 <__vector_22+0x74>
			  Byte = TextBuffer[Byte - StrEnd];
    1100:	e9 1b       	sub	r30, r25
    1102:	f1 09       	sbc	r31, r1
			else
			  Byte = TextBuffer[Byte];
    1104:	e1 5b       	subi	r30, 0xB1	; 177
    1106:	fd 4f       	sbci	r31, 0xFD	; 253
    1108:	80 81       	ld	r24, Z
			
			LCD_WriteChar(Byte, Character);
    110a:	6c 2f       	mov	r22, r28
    110c:	0e 94 1b 08 	call	0x1036 <LCD_WriteChar>
    1110:	cf 5f       	subi	r28, 0xFF	; 255
    1112:	c6 30       	cpi	r28, 0x06	; 6
    1114:	60 f3       	brcs	.-40     	; 0x10ee <__vector_22+0x5e>
		}
		
		if (StrStart++ == StrEnd)
    1116:	80 91 4e 02 	lds	r24, 0x024E
    111a:	98 2f       	mov	r25, r24
    111c:	8f 5f       	subi	r24, 0xFF	; 255
    111e:	80 93 4e 02 	sts	0x024E, r24
    1122:	80 91 4c 02 	lds	r24, 0x024C
    1126:	98 17       	cp	r25, r24
    1128:	19 f4       	brne	.+6      	; 0x1130 <__vector_22+0xa0>
		  StrStart = 1;
    112a:	81 e0       	ldi	r24, 0x01	; 1
    112c:	80 93 4e 02 	sts	0x024E, r24
		
		ScrollCount = LCD_SCROLLCOUNT_DEFAULT;
    1130:	83 e0       	ldi	r24, 0x03	; 3
    1132:	80 93 4d 02 	sts	0x024D, r24
		UpdateLCD = FALSE;
    1136:	10 92 6a 02 	sts	0x026A, r1
    113a:	ac ee       	ldi	r26, 0xEC	; 236
    113c:	b0 e0       	ldi	r27, 0x00	; 0
    113e:	eb e6       	ldi	r30, 0x6B	; 107
    1140:	f2 e0       	ldi	r31, 0x02	; 2
    1142:	93 e1       	ldi	r25, 0x13	; 19
	}

	for (uint8_t LCDChar = 0; LCDChar < LCD_SEGBUFFER_SIZE; LCDChar++)
	  *(pLCDREG + LCDChar) = SegBuffer[LCDChar];
    1144:	81 91       	ld	r24, Z+
    1146:	8d 93       	st	X+, r24
    1148:	91 50       	subi	r25, 0x01	; 1
    114a:	97 ff       	sbrs	r25, 7
    114c:	fb cf       	rjmp	.-10     	; 0x1144 <__vector_22+0xb4>
    114e:	ff 91       	pop	r31
    1150:	ef 91       	pop	r30
    1152:	cf 91       	pop	r28
    1154:	bf 91       	pop	r27
    1156:	af 91       	pop	r26
    1158:	9f 91       	pop	r25
    115a:	8f 91       	pop	r24
    115c:	7f 91       	pop	r23
    115e:	6f 91       	pop	r22
    1160:	5f 91       	pop	r21
    1162:	4f 91       	pop	r20
    1164:	3f 91       	pop	r19
    1166:	2f 91       	pop	r18
    1168:	0f 90       	pop	r0
    116a:	0f be       	out	0x3f, r0	; 63
    116c:	0f 90       	pop	r0
    116e:	1f 90       	pop	r1
    1170:	18 95       	reti

00001172 <eeprom_read_byte_169>:
#include <avr/interrupt.h>
#include "eeprom169.h"

uint8_t eeprom_read_byte_169(const uint16_t *addr)
{
    1172:	fc 01       	movw	r30, r24
	cli();
    1174:	f8 94       	cli
	/* Set up address register */
	EEAR = *addr;
    1176:	80 81       	ld	r24, Z
    1178:	91 81       	ldd	r25, Z+1	; 0x01
    117a:	92 bd       	out	0x22, r25	; 34
    117c:	81 bd       	out	0x21, r24	; 33
	/* Start eeprom read by writing EERE */
	EECR |= (1<<EERE);
    117e:	f8 9a       	sbi	0x1f, 0	; 31
	sei();
    1180:	78 94       	sei
	/* Return data from Data Register */
	return EEDR;
    1182:	80 b5       	in	r24, 0x20	; 32
}
    1184:	99 27       	eor	r25, r25
    1186:	08 95       	ret

00001188 <eeprom_write_byte_169>:

void eeprom_write_byte_169(const uint16_t *addr, uint8_t val) 
{
    1188:	1f 93       	push	r17
    118a:	cf 93       	push	r28
    118c:	df 93       	push	r29
    118e:	ec 01       	movw	r28, r24
    1190:	16 2f       	mov	r17, r22
	if(eeprom_read_byte_169(addr) == val) // Compare stored value with new value for match
    1192:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
    1196:	81 17       	cp	r24, r17
    1198:	59 f0       	breq	.+22     	; 0x11b0 <eeprom_write_byte_169+0x28>
		return; // Don't re-write the same value and waste EEPROM life

	cli();
    119a:	f8 94       	cli
	/* Set up address and Data Registers */
	EEAR = *addr;
    119c:	88 81       	ld	r24, Y
    119e:	99 81       	ldd	r25, Y+1	; 0x01
    11a0:	92 bd       	out	0x22, r25	; 34
    11a2:	81 bd       	out	0x21, r24	; 33
	EEDR = val;
    11a4:	10 bd       	out	0x20, r17	; 32
	/* Write logical one to EEMWE */
	EECR |= (1<<EEMWE);
    11a6:	fa 9a       	sbi	0x1f, 2	; 31
	/* Start eeprom write by setting EEWE */
	EECR |= (1<<EEWE);
    11a8:	f9 9a       	sbi	0x1f, 1	; 31
	sei();
    11aa:	78 94       	sei
	/* Wait for completion */
	while(EECR & (1<<EEWE));
    11ac:	f9 99       	sbic	0x1f, 1	; 31
    11ae:	fe cf       	rjmp	.-4      	; 0x11ac <eeprom_write_byte_169+0x24>
    11b0:	df 91       	pop	r29
    11b2:	cf 91       	pop	r28
    11b4:	1f 91       	pop	r17
    11b6:	08 95       	ret

000011b8 <USART_Init>:
*   Purpose :       Initialize the USART
*
*****************************************************************************/
void USART_Init(unsigned int baudrate)
{
    11b8:	9c 01       	movw	r18, r24
    // Set baud rate
    UBRRH = (unsigned char)(baudrate>>8);
    11ba:	83 2f       	mov	r24, r19
    11bc:	99 27       	eor	r25, r25
    11be:	80 93 c5 00 	sts	0x00C5, r24
    UBRRL = (unsigned char)(baudrate);
    11c2:	20 93 c4 00 	sts	0x00C4, r18

    // Double speed
	UCSRA = (USART_DOUBLESPEED << U2X);
    11c6:	82 e0       	ldi	r24, 0x02	; 2
    11c8:	80 93 c0 00 	sts	0x00C0, r24

    // Enable recieve complete interrupt
	UCSRB = (1 << RXCIE);
    11cc:	80 e8       	ldi	r24, 0x80	; 128
    11ce:	80 93 c1 00 	sts	0x00C1, r24
	 
    // Async. mode, 8N1
    UCSRC = (3 << UCSZ0);
    11d2:	86 e0       	ldi	r24, 0x06	; 6
    11d4:	80 93 c2 00 	sts	0x00C2, r24
	 
	 // Initalise ringbuffer
	BUFF_InitialiseBuffer();
    11d8:	0e 94 6f 0b 	call	0x16de <BUFF_InitialiseBuffer>
    11dc:	08 95       	ret

000011de <USART_Tx>:
}

/*****************************************************************************
*
*   Function name : Usart_Tx
*
*   Returns :       None
*
*   Parameters :    char data: byte to send
*
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_Tx(char data)
{
    11de:	98 2f       	mov	r25, r24
    while (!(UCSRA & (1<<UDRE)));
    11e0:	80 91 c0 00 	lds	r24, 0x00C0
    11e4:	85 ff       	sbrs	r24, 5
    11e6:	fc cf       	rjmp	.-8      	; 0x11e0 <USART_Tx+0x2>
    UDR = data;
    11e8:	90 93 c6 00 	sts	0x00C6, r25
    11ec:	08 95       	ret

000011ee <USART_TxString>:
}

/*****************************************************************************
*
*   Function name : Usart_Tx
*
*   Returns :       None
*
*   Parameters :    char data: byte to send
*
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_TxString(char *data)
{
    11ee:	cf 93       	push	r28
    11f0:	df 93       	push	r29
    11f2:	ec 01       	movw	r28, r24
	while (*data != '\0')
		USART_Tx(*data++);
    11f4:	88 81       	ld	r24, Y
    11f6:	88 23       	and	r24, r24
    11f8:	31 f0       	breq	.+12     	; 0x1206 <USART_TxString+0x18>
    11fa:	89 91       	ld	r24, Y+
    11fc:	0e 94 ef 08 	call	0x11de <USART_Tx>
    1200:	88 81       	ld	r24, Y
    1202:	88 23       	and	r24, r24
    1204:	d1 f7       	brne	.-12     	; 0x11fa <USART_TxString+0xc>
    1206:	df 91       	pop	r29
    1208:	cf 91       	pop	r28
    120a:	08 95       	ret

0000120c <USART_Rx>:
}

/*****************************************************************************
*
*   Function name : Usart_Rx
*
*   Returns :       char: byte received
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART
*
*****************************************************************************/
char USART_Rx(void)
{
    while (!(BuffElements) && !(TimeOut)) {};
    120c:	80 91 d1 02 	lds	r24, 0x02D1
    1210:	88 23       	and	r24, r24
    1212:	21 f4       	brne	.+8      	; 0x121c <USART_Rx+0x10>
    1214:	80 91 28 01 	lds	r24, 0x0128
    1218:	88 23       	and	r24, r24
    121a:	c1 f3       	breq	.-16     	; 0x120c <USART_Rx>
    return BUFF_GetBuffByte();
    121c:	0e 94 a5 0b 	call	0x174a <BUFF_GetBuffByte>
}
    1220:	99 27       	eor	r25, r25
    1222:	08 95       	ret

00001224 <__vector_13>:

/*****************************************************************************
*
*   Function name : Usart_Rx Interrupt
*
*   Returns :       N/A
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART and stores it into the buffer
*
*****************************************************************************/

ISR(USART0_RX_vect, ISR_BLOCK)
{
    1224:	1f 92       	push	r1
    1226:	0f 92       	push	r0
    1228:	0f b6       	in	r0, 0x3f	; 63
    122a:	0f 92       	push	r0
    122c:	11 24       	eor	r1, r1
    122e:	2f 93       	push	r18
    1230:	3f 93       	push	r19
    1232:	4f 93       	push	r20
    1234:	5f 93       	push	r21
    1236:	6f 93       	push	r22
    1238:	7f 93       	push	r23
    123a:	8f 93       	push	r24
    123c:	9f 93       	push	r25
    123e:	af 93       	push	r26
    1240:	bf 93       	push	r27
    1242:	ef 93       	push	r30
    1244:	ff 93       	push	r31
	BUFF_StoreBuffByte(UDR);
    1246:	80 91 c6 00 	lds	r24, 0x00C6
    124a:	0e 94 7c 0b 	call	0x16f8 <BUFF_StoreBuffByte>
    124e:	ff 91       	pop	r31
    1250:	ef 91       	pop	r30
    1252:	bf 91       	pop	r27
    1254:	af 91       	pop	r26
    1256:	9f 91       	pop	r25
    1258:	8f 91       	pop	r24
    125a:	7f 91       	pop	r23
    125c:	6f 91       	pop	r22
    125e:	5f 91       	pop	r21
    1260:	4f 91       	pop	r20
    1262:	3f 91       	pop	r19
    1264:	2f 91       	pop	r18
    1266:	0f 90       	pop	r0
    1268:	0f be       	out	0x3f, r0	; 63
    126a:	0f 90       	pop	r0
    126c:	1f 90       	pop	r1
    126e:	18 95       	reti

00001270 <SPI_SPIInit>:
// ======================================================================================

void SPI_SPIInit(void)
{
	PRR &= ~(1 << PRSPI);              // Enable the SPI system by clearing the power save register SPI disable bit
    1270:	80 91 64 00 	lds	r24, 0x0064
    1274:	8b 7f       	andi	r24, 0xFB	; 251
    1276:	80 93 64 00 	sts	0x0064, r24

	// Master, Sample falling edge (setup rising), Fosc/32 speed (8Mhz/32 = 125Khz)
	SPSR = (1 << SPI2X);
    127a:	81 e0       	ldi	r24, 0x01	; 1
    127c:	8d bd       	out	0x2d, r24	; 45
	SPCR = ((1 << SPE) | (1 << MSTR) | (1 << CPHA) | (1 << CPOL) | (1 << SPR1));
    127e:	8e e5       	ldi	r24, 0x5E	; 94
    1280:	8c bd       	out	0x2c, r24	; 44
    1282:	08 95       	ret

00001284 <SPI_SPITransmit>:
}

uint8_t SPI_SPITransmit(uint8_t Data)
{
	SPDR = Data;                       // Loading a byte into the register starts the transmission
    1284:	8e bd       	out	0x2e, r24	; 46
	while (!(SPSR & (1 << SPIF)));    // Wait until transmission completed
    1286:	0d b4       	in	r0, 0x2d	; 45
    1288:	07 fe       	sbrs	r0, 7
    128a:	fd cf       	rjmp	.-6      	; 0x1286 <SPI_SPITransmit+0x2>
	return SPDR;
    128c:	8e b5       	in	r24, 0x2e	; 46
}
    128e:	99 27       	eor	r25, r25
    1290:	08 95       	ret

00001292 <SPI_SPITransmitWord>:

uint8_t SPI_SPITransmitWord(uint16_t Data)
{
    1292:	0f 93       	push	r16
    1294:	1f 93       	push	r17
    1296:	8c 01       	movw	r16, r24
	SPI_SPITransmit((uint8_t)(Data >> 8));
    1298:	81 2f       	mov	r24, r17
    129a:	99 27       	eor	r25, r25
    129c:	0e 94 42 09 	call	0x1284 <SPI_SPITransmit>
	return SPI_SPITransmit((uint8_t)Data);
    12a0:	80 2f       	mov	r24, r16
    12a2:	0e 94 42 09 	call	0x1284 <SPI_SPITransmit>
}
    12a6:	99 27       	eor	r25, r25
    12a8:	1f 91       	pop	r17
    12aa:	0f 91       	pop	r16
    12ac:	08 95       	ret

000012ae <__vector_17>:
 *  have to stop the timer tick.
 *  For all modes the USIDR contents are stored and flags are updated.
 */
ISR(USI_OVERFLOW_vect, ISR_BLOCK)
{
    12ae:	1f 92       	push	r1
    12b0:	0f 92       	push	r0
    12b2:	0f b6       	in	r0, 0x3f	; 63
    12b4:	0f 92       	push	r0
    12b6:	11 24       	eor	r1, r1
    12b8:	8f 93       	push	r24
	// Master must now disable the compare match interrupt
	// to prevent more USI counter clocks.
	TIMSK0 &= ~(1<<OCIE0A);
    12ba:	80 91 6e 00 	lds	r24, 0x006E
    12be:	8d 7f       	andi	r24, 0xFD	; 253
    12c0:	80 93 6e 00 	sts	0x006E, r24
	
	// Update flags and clear USI counter
	USISR = (1<<USIOIF);
    12c4:	80 e4       	ldi	r24, 0x40	; 64
    12c6:	80 93 b9 00 	sts	0x00B9, r24
	TransferComplete = 1;
    12ca:	81 e0       	ldi	r24, 0x01	; 1
    12cc:	80 93 81 02 	sts	0x0281, r24

	// Copy USIDR to buffer to prevent overwrite on next transfer.
	storedUSIDR = USIDR;
    12d0:	80 91 ba 00 	lds	r24, 0x00BA
    12d4:	80 93 82 02 	sts	0x0282, r24
    12d8:	8f 91       	pop	r24
    12da:	0f 90       	pop	r0
    12dc:	0f be       	out	0x3f, r0	; 63
    12de:	0f 90       	pop	r0
    12e0:	1f 90       	pop	r1
    12e2:	18 95       	reti

000012e4 <USI_SPISetSpeed>:
}



/*! \brief  Initialize USI as SPI master.
 *
 *  This function sets up all pin directions and module configurations.
 *  Use this function initially or when changing from slave to master mode.
 *  Note that the stored USIDR value is cleared.
 *
 */
void USI_SPIInitMaster(char Freq)
{
	// Configure port directions.
 	USI_DIR_REG |= (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN);  // Outputs.
	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN);                       // Inputs.
	USI_OUT_REG |= (1<<USI_DATAIN_PIN);                        // Pull-ups.
	USI_OUT_REG &= ~(1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN); // Pull-ups.
	
	// Configure USI to 3-wire master mode with overflow interrupt.
	USICR = USI_CONTROL_REG_FLAGS;

	// Set the compare and prescaler for the requested frequency:
	USI_SPISetSpeed(Freq);
	
	// Init driver status register.
	TransferComplete = 0;
	
	storedUSIDR = 0;
}

void USI_SPIOff( void )
{
	USI_DIR_REG &= ~((1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN));                        // Inputs.
	USI_OUT_REG &= ~((1<<USI_DATAIN_PIN)  | (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN)); // Pull-ups.
	DDRF  &= ~(1 << 6);
	PORTF &= ~(1 << 6);
	
	USI_STOPUSITIMER();
}

/*! \brief  Put one byte on bus.
 *
 *  Use this function like you would write to the SPDR register in the native SPI module.
 *  Calling this function in master mode starts a transfer, while in slave mode, a
 *  byte will be prepared for the next transfer initiated by the master device.
 *  If a transfer is in progress, this function will set the write collision flag
 *  and return without altering the data registers.
 *
 *  \returns  0 if a write collision occurred, 1 otherwise.
 */
uint8_t USI_SPITransmit( unsigned char val )
{
	// Reinit flags.
	TransferComplete = 0;

	// Put data in USI data register.
	USIDR = val;
	
	TIFR0  |= (1<<OCF0A);  // Clear compare match flag.
	TIMSK0 |= (1<<OCIE0A); // Enable compare match interrupt.

	// Clear the timer 0 value
	TCNT0 = 0;

	while (!(TransferComplete));

	return storedUSIDR;
}

uint8_t USI_SPITransmitWord( unsigned int val )
{
	USI_SPITransmit((uint8_t)(val >> 8));
	return USI_SPITransmit((uint8_t)val);
}

void USI_SPIToggleClock(void)
{
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);	
}

void USI_SPISetSpeed(uint8_t Freq)
{
    12e4:	48 2f       	mov	r20, r24
	for (uint8_t MatchIndex = 0; MatchIndex < USI_PRESET_SPEEDS; MatchIndex++)
    12e6:	90 e0       	ldi	r25, 0x00	; 0
    12e8:	6c e7       	ldi	r22, 0x7C	; 124
    12ea:	73 e0       	ldi	r23, 0x03	; 3
    12ec:	9b 01       	movw	r18, r22
    12ee:	21 50       	subi	r18, 0x01	; 1
    12f0:	30 40       	sbci	r19, 0x00	; 0
	{
		if ((pgm_read_byte(&USIPSValues[MatchIndex][0]) == Freq) || (MatchIndex == (USI_PRESET_SPEEDS - 1)))
    12f2:	f9 01       	movw	r30, r18
    12f4:	84 91       	lpm	r24, Z
    12f6:	84 17       	cp	r24, r20
    12f8:	11 f0       	breq	.+4      	; 0x12fe <USI_SPISetSpeed+0x1a>
    12fa:	93 30       	cpi	r25, 0x03	; 3
    12fc:	31 f4       	brne	.+12     	; 0x130a <USI_SPISetSpeed+0x26>
		{
			// Init Output Compare Register.
			OCR0A = pgm_read_byte(&USIPSValues[MatchIndex][1]);
    12fe:	fb 01       	movw	r30, r22
    1300:	84 91       	lpm	r24, Z
    1302:	87 bd       	out	0x27, r24	; 39

			// Enable 'Clear Timer on Compare match' and set prescaler, which starts the timer
			TCCR0A = ((1<<WGM01) | TC0_PS_1);
    1304:	89 e0       	ldi	r24, 0x09	; 9
    1306:	84 bd       	out	0x24, r24	; 36
				
			return;
    1308:	08 95       	ret
    130a:	9f 5f       	subi	r25, 0xFF	; 255
    130c:	2e 5f       	subi	r18, 0xFE	; 254
    130e:	3f 4f       	sbci	r19, 0xFF	; 255
    1310:	6e 5f       	subi	r22, 0xFE	; 254
    1312:	7f 4f       	sbci	r23, 0xFF	; 255
    1314:	94 30       	cpi	r25, 0x04	; 4
    1316:	68 f3       	brcs	.-38     	; 0x12f2 <USI_SPISetSpeed+0xe>
    1318:	08 95       	ret

0000131a <USI_SPIInitMaster>:
    131a:	9d b1       	in	r25, 0x0d	; 13
    131c:	90 65       	ori	r25, 0x50	; 80
    131e:	9d b9       	out	0x0d, r25	; 13
    1320:	6d 98       	cbi	0x0d, 5	; 13
    1322:	75 9a       	sbi	0x0e, 5	; 14
    1324:	76 98       	cbi	0x0e, 6	; 14
    1326:	9a e5       	ldi	r25, 0x5A	; 90
    1328:	90 93 b8 00 	sts	0x00B8, r25
    132c:	0e 94 72 09 	call	0x12e4 <USI_SPISetSpeed>
    1330:	10 92 81 02 	sts	0x0281, r1
    1334:	10 92 82 02 	sts	0x0282, r1
    1338:	08 95       	ret

0000133a <USI_SPIOff>:
    133a:	8d b1       	in	r24, 0x0d	; 13
    133c:	8f 7a       	andi	r24, 0xAF	; 175
    133e:	8d b9       	out	0x0d, r24	; 13
    1340:	8e b1       	in	r24, 0x0e	; 14
    1342:	8f 78       	andi	r24, 0x8F	; 143
    1344:	8e b9       	out	0x0e, r24	; 14
    1346:	86 98       	cbi	0x10, 6	; 16
    1348:	8e 98       	cbi	0x11, 6	; 17
    134a:	14 bc       	out	0x24, r1	; 36
    134c:	08 95       	ret

0000134e <USI_SPITransmit>:
    134e:	10 92 81 02 	sts	0x0281, r1
    1352:	80 93 ba 00 	sts	0x00BA, r24
    1356:	a9 9a       	sbi	0x15, 1	; 21
    1358:	80 91 6e 00 	lds	r24, 0x006E
    135c:	82 60       	ori	r24, 0x02	; 2
    135e:	80 93 6e 00 	sts	0x006E, r24
    1362:	16 bc       	out	0x26, r1	; 38
    1364:	80 91 81 02 	lds	r24, 0x0281
    1368:	88 23       	and	r24, r24
    136a:	e1 f3       	breq	.-8      	; 0x1364 <USI_SPITransmit+0x16>
    136c:	80 91 82 02 	lds	r24, 0x0282
    1370:	99 27       	eor	r25, r25
    1372:	08 95       	ret

00001374 <USI_SPITransmitWord>:
    1374:	0f 93       	push	r16
    1376:	1f 93       	push	r17
    1378:	8c 01       	movw	r16, r24
    137a:	81 2f       	mov	r24, r17
    137c:	99 27       	eor	r25, r25
    137e:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    1382:	80 2f       	mov	r24, r16
    1384:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    1388:	99 27       	eor	r25, r25
    138a:	1f 91       	pop	r17
    138c:	0f 91       	pop	r16
    138e:	08 95       	ret

00001390 <USI_SPIToggleClock>:
    1390:	81 e0       	ldi	r24, 0x01	; 1
    1392:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    1396:	80 91 b8 00 	lds	r24, 0x00B8
    139a:	81 60       	ori	r24, 0x01	; 1
    139c:	80 93 b8 00 	sts	0x00B8, r24
    13a0:	81 e0       	ldi	r24, 0x01	; 1
    13a2:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    13a6:	80 91 b8 00 	lds	r24, 0x00B8
    13aa:	81 60       	ori	r24, 0x01	; 1
    13ac:	80 93 b8 00 	sts	0x00B8, r24
    13b0:	81 e0       	ldi	r24, 0x01	; 1
    13b2:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    13b6:	08 95       	ret

000013b8 <DF_EnableDataflash>:
	while (DF_BUSY());
}

void DF_EnableDataflash(uint8_t Enabled)
{
    13b8:	90 91 83 02 	lds	r25, 0x0283
	if (Enabled == TRUE)
    13bc:	81 30       	cpi	r24, 0x01	; 1
    13be:	31 f4       	brne	.+12     	; 0x13cc <DF_EnableDataflash+0x14>
	{
		if (UseExernalDF == TRUE)
    13c0:	91 30       	cpi	r25, 0x01	; 1
    13c2:	11 f4       	brne	.+4      	; 0x13c8 <DF_EnableDataflash+0x10>
		  MAIN_ResetCSLine(MAIN_RESETCS_EXTDFACTIVE);
    13c4:	82 e0       	ldi	r24, 0x02	; 2
    13c6:	05 c0       	rjmp	.+10     	; 0x13d2 <DF_EnableDataflash+0x1a>
		else
		  PORTB &= ~(1 << 0);
    13c8:	28 98       	cbi	0x05, 0	; 5
    13ca:	08 95       	ret
	}
	else
	{
		if (UseExernalDF == TRUE)
    13cc:	91 30       	cpi	r25, 0x01	; 1
    13ce:	21 f4       	brne	.+8      	; 0x13d8 <DF_EnableDataflash+0x20>
		  MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);
    13d0:	89 2f       	mov	r24, r25
    13d2:	0e 94 1b 03 	call	0x636 <MAIN_ResetCSLine>
    13d6:	08 95       	ret
		else
		  PORTB |= (1 << 0);
    13d8:	28 9a       	sbi	0x05, 0	; 5
    13da:	08 95       	ret

000013dc <DF_ReadBufferByte>:
    13dc:	0f 93       	push	r16
    13de:	1f 93       	push	r17
    13e0:	8c 01       	movw	r16, r24
    13e2:	80 e0       	ldi	r24, 0x00	; 0
    13e4:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    13e8:	00 00       	nop
    13ea:	81 e0       	ldi	r24, 0x01	; 1
    13ec:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    13f0:	e0 91 00 01 	lds	r30, 0x0100
    13f4:	f0 91 01 01 	lds	r31, 0x0101
    13f8:	84 e5       	ldi	r24, 0x54	; 84
    13fa:	09 95       	icall
    13fc:	81 2f       	mov	r24, r17
    13fe:	99 27       	eor	r25, r25
    1400:	e0 91 00 01 	lds	r30, 0x0100
    1404:	f0 91 01 01 	lds	r31, 0x0101
    1408:	09 95       	icall
    140a:	e0 91 00 01 	lds	r30, 0x0100
    140e:	f0 91 01 01 	lds	r31, 0x0101
    1412:	80 2f       	mov	r24, r16
    1414:	09 95       	icall
    1416:	e0 91 00 01 	lds	r30, 0x0100
    141a:	f0 91 01 01 	lds	r31, 0x0101
    141e:	80 e0       	ldi	r24, 0x00	; 0
    1420:	09 95       	icall
    1422:	e0 91 00 01 	lds	r30, 0x0100
    1426:	f0 91 01 01 	lds	r31, 0x0101
    142a:	80 e0       	ldi	r24, 0x00	; 0
    142c:	09 95       	icall
    142e:	99 27       	eor	r25, r25
    1430:	1f 91       	pop	r17
    1432:	0f 91       	pop	r16
    1434:	08 95       	ret

00001436 <DF_ContinuousReadEnable>:
    1436:	ef 92       	push	r14
    1438:	ff 92       	push	r15
    143a:	0f 93       	push	r16
    143c:	1f 93       	push	r17
    143e:	8c 01       	movw	r16, r24
    1440:	7b 01       	movw	r14, r22
    1442:	80 e0       	ldi	r24, 0x00	; 0
    1444:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    1448:	00 00       	nop
    144a:	81 e0       	ldi	r24, 0x01	; 1
    144c:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    1450:	e0 91 00 01 	lds	r30, 0x0100
    1454:	f0 91 01 01 	lds	r31, 0x0101
    1458:	88 e6       	ldi	r24, 0x68	; 104
    145a:	09 95       	icall
    145c:	8a b5       	in	r24, 0x2a	; 42
    145e:	98 01       	movw	r18, r16
    1460:	02 c0       	rjmp	.+4      	; 0x1466 <DF_ContinuousReadEnable+0x30>
    1462:	36 95       	lsr	r19
    1464:	27 95       	ror	r18
    1466:	8a 95       	dec	r24
    1468:	e2 f7       	brpl	.-8      	; 0x1462 <DF_ContinuousReadEnable+0x2c>
    146a:	c9 01       	movw	r24, r18
    146c:	e0 91 00 01 	lds	r30, 0x0100
    1470:	f0 91 01 01 	lds	r31, 0x0101
    1474:	09 95       	icall
    1476:	8b b5       	in	r24, 0x2b	; 43
    1478:	02 c0       	rjmp	.+4      	; 0x147e <DF_ContinuousReadEnable+0x48>
    147a:	00 0f       	add	r16, r16
    147c:	11 1f       	adc	r17, r17
    147e:	8a 95       	dec	r24
    1480:	e2 f7       	brpl	.-8      	; 0x147a <DF_ContinuousReadEnable+0x44>
    1482:	8f 2d       	mov	r24, r15
    1484:	99 27       	eor	r25, r25
    1486:	e0 91 00 01 	lds	r30, 0x0100
    148a:	f0 91 01 01 	lds	r31, 0x0101
    148e:	80 0f       	add	r24, r16
    1490:	09 95       	icall
    1492:	e0 91 00 01 	lds	r30, 0x0100
    1496:	f0 91 01 01 	lds	r31, 0x0101
    149a:	8e 2d       	mov	r24, r14
    149c:	09 95       	icall
    149e:	03 e0       	ldi	r16, 0x03	; 3
    14a0:	e0 91 00 01 	lds	r30, 0x0100
    14a4:	f0 91 01 01 	lds	r31, 0x0101
    14a8:	80 e0       	ldi	r24, 0x00	; 0
    14aa:	09 95       	icall
    14ac:	01 50       	subi	r16, 0x01	; 1
    14ae:	07 ff       	sbrs	r16, 7
    14b0:	f7 cf       	rjmp	.-18     	; 0x14a0 <DF_ContinuousReadEnable+0x6a>
    14b2:	1f 91       	pop	r17
    14b4:	0f 91       	pop	r16
    14b6:	ff 90       	pop	r15
    14b8:	ef 90       	pop	r14
    14ba:	08 95       	ret

000014bc <DF_BufferWriteEnable>:
    14bc:	0f 93       	push	r16
    14be:	1f 93       	push	r17
    14c0:	8c 01       	movw	r16, r24
    14c2:	80 e0       	ldi	r24, 0x00	; 0
    14c4:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    14c8:	00 00       	nop
    14ca:	81 e0       	ldi	r24, 0x01	; 1
    14cc:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    14d0:	e0 91 00 01 	lds	r30, 0x0100
    14d4:	f0 91 01 01 	lds	r31, 0x0101
    14d8:	84 e8       	ldi	r24, 0x84	; 132
    14da:	09 95       	icall
    14dc:	e0 91 00 01 	lds	r30, 0x0100
    14e0:	f0 91 01 01 	lds	r31, 0x0101
    14e4:	80 e0       	ldi	r24, 0x00	; 0
    14e6:	09 95       	icall
    14e8:	81 2f       	mov	r24, r17
    14ea:	99 27       	eor	r25, r25
    14ec:	e0 91 00 01 	lds	r30, 0x0100
    14f0:	f0 91 01 01 	lds	r31, 0x0101
    14f4:	09 95       	icall
    14f6:	e0 91 00 01 	lds	r30, 0x0100
    14fa:	f0 91 01 01 	lds	r31, 0x0101
    14fe:	80 2f       	mov	r24, r16
    1500:	09 95       	icall
    1502:	1f 91       	pop	r17
    1504:	0f 91       	pop	r16
    1506:	08 95       	ret

00001508 <DF_GetChipCharacteristics>:
    1508:	80 e0       	ldi	r24, 0x00	; 0
    150a:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    150e:	00 00       	nop
    1510:	81 e0       	ldi	r24, 0x01	; 1
    1512:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    1516:	e0 91 00 01 	lds	r30, 0x0100
    151a:	f0 91 01 01 	lds	r31, 0x0101
    151e:	87 e5       	ldi	r24, 0x57	; 87
    1520:	09 95       	icall
    1522:	e0 91 00 01 	lds	r30, 0x0100
    1526:	f0 91 01 01 	lds	r31, 0x0101
    152a:	80 e0       	ldi	r24, 0x00	; 0
    152c:	09 95       	icall
    152e:	68 2f       	mov	r22, r24
    1530:	77 27       	eor	r23, r23
    1532:	cb 01       	movw	r24, r22
    1534:	88 73       	andi	r24, 0x38	; 56
    1536:	90 70       	andi	r25, 0x00	; 0
    1538:	33 e0       	ldi	r19, 0x03	; 3
    153a:	95 95       	asr	r25
    153c:	87 95       	ror	r24
    153e:	3a 95       	dec	r19
    1540:	e1 f7       	brne	.-8      	; 0x153a <DF_GetChipCharacteristics+0x32>
    1542:	99 27       	eor	r25, r25
    1544:	fc 01       	movw	r30, r24
    1546:	ed 54       	subi	r30, 0x4D	; 77
    1548:	fc 4f       	sbci	r31, 0xFC	; 252
    154a:	44 91       	lpm	r20, Z
    154c:	40 93 86 02 	sts	0x0286, r20
    1550:	9c 01       	movw	r18, r24
    1552:	28 0f       	add	r18, r24
    1554:	39 1f       	adc	r19, r25
    1556:	f9 01       	movw	r30, r18
    1558:	ed 55       	subi	r30, 0x5D	; 93
    155a:	fc 4f       	sbci	r31, 0xFC	; 252
    155c:	85 91       	lpm	r24, Z+
    155e:	94 91       	lpm	r25, Z
    1560:	90 93 88 02 	sts	0x0288, r25
    1564:	80 93 87 02 	sts	0x0287, r24
    1568:	f9 01       	movw	r30, r18
    156a:	ed 56       	subi	r30, 0x6D	; 109
    156c:	fc 4f       	sbci	r31, 0xFC	; 252
    156e:	85 91       	lpm	r24, Z+
    1570:	94 91       	lpm	r25, Z
    1572:	90 93 8a 02 	sts	0x028A, r25
    1576:	80 93 89 02 	sts	0x0289, r24
    157a:	80 e1       	ldi	r24, 0x10	; 16
    157c:	84 1b       	sub	r24, r20
    157e:	8a bd       	out	0x2a, r24	; 42
    1580:	48 50       	subi	r20, 0x08	; 8
    1582:	4b bd       	out	0x2b, r20	; 43
    1584:	cb 01       	movw	r24, r22
    1586:	08 95       	ret

00001588 <DF_EraseBlock>:
    1588:	0f 93       	push	r16
    158a:	1f 93       	push	r17
    158c:	8c 01       	movw	r16, r24
    158e:	80 e0       	ldi	r24, 0x00	; 0
    1590:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    1594:	00 00       	nop
    1596:	81 e0       	ldi	r24, 0x01	; 1
    1598:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    159c:	e0 91 00 01 	lds	r30, 0x0100
    15a0:	f0 91 01 01 	lds	r31, 0x0101
    15a4:	80 e5       	ldi	r24, 0x50	; 80
    15a6:	09 95       	icall
    15a8:	81 2f       	mov	r24, r17
    15aa:	99 27       	eor	r25, r25
    15ac:	e0 91 00 01 	lds	r30, 0x0100
    15b0:	f0 91 01 01 	lds	r31, 0x0101
    15b4:	09 95       	icall
    15b6:	e0 91 00 01 	lds	r30, 0x0100
    15ba:	f0 91 01 01 	lds	r31, 0x0101
    15be:	80 2f       	mov	r24, r16
    15c0:	09 95       	icall
    15c2:	e0 91 00 01 	lds	r30, 0x0100
    15c6:	f0 91 01 01 	lds	r31, 0x0101
    15ca:	80 e0       	ldi	r24, 0x00	; 0
    15cc:	09 95       	icall
    15ce:	0e 94 84 0a 	call	0x1508 <DF_GetChipCharacteristics>
    15d2:	88 23       	and	r24, r24
    15d4:	e4 f7       	brge	.-8      	; 0x15ce <DF_EraseBlock+0x46>
    15d6:	1f 91       	pop	r17
    15d8:	0f 91       	pop	r16
    15da:	08 95       	ret

000015dc <DF_CopyFlashPageToBuffer>:
    15dc:	0f 93       	push	r16
    15de:	1f 93       	push	r17
    15e0:	8c 01       	movw	r16, r24
    15e2:	80 e0       	ldi	r24, 0x00	; 0
    15e4:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    15e8:	00 00       	nop
    15ea:	81 e0       	ldi	r24, 0x01	; 1
    15ec:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    15f0:	e0 91 00 01 	lds	r30, 0x0100
    15f4:	f0 91 01 01 	lds	r31, 0x0101
    15f8:	83 e5       	ldi	r24, 0x53	; 83
    15fa:	09 95       	icall
    15fc:	8a b5       	in	r24, 0x2a	; 42
    15fe:	98 01       	movw	r18, r16
    1600:	02 c0       	rjmp	.+4      	; 0x1606 <DF_CopyFlashPageToBuffer+0x2a>
    1602:	36 95       	lsr	r19
    1604:	27 95       	ror	r18
    1606:	8a 95       	dec	r24
    1608:	e2 f7       	brpl	.-8      	; 0x1602 <DF_CopyFlashPageToBuffer+0x26>
    160a:	c9 01       	movw	r24, r18
    160c:	e0 91 00 01 	lds	r30, 0x0100
    1610:	f0 91 01 01 	lds	r31, 0x0101
    1614:	09 95       	icall
    1616:	8b b5       	in	r24, 0x2b	; 43
    1618:	02 c0       	rjmp	.+4      	; 0x161e <DF_CopyFlashPageToBuffer+0x42>
    161a:	00 0f       	add	r16, r16
    161c:	11 1f       	adc	r17, r17
    161e:	8a 95       	dec	r24
    1620:	e2 f7       	brpl	.-8      	; 0x161a <DF_CopyFlashPageToBuffer+0x3e>
    1622:	e0 91 00 01 	lds	r30, 0x0100
    1626:	f0 91 01 01 	lds	r31, 0x0101
    162a:	80 2f       	mov	r24, r16
    162c:	09 95       	icall
    162e:	e0 91 00 01 	lds	r30, 0x0100
    1632:	f0 91 01 01 	lds	r31, 0x0101
    1636:	80 e0       	ldi	r24, 0x00	; 0
    1638:	09 95       	icall
    163a:	0e 94 84 0a 	call	0x1508 <DF_GetChipCharacteristics>
    163e:	88 23       	and	r24, r24
    1640:	e4 f7       	brge	.-8      	; 0x163a <DF_CopyFlashPageToBuffer+0x5e>
    1642:	1f 91       	pop	r17
    1644:	0f 91       	pop	r16
    1646:	08 95       	ret

00001648 <DF_CopyBufferToFlashPage>:
    1648:	0f 93       	push	r16
    164a:	1f 93       	push	r17
    164c:	8c 01       	movw	r16, r24
    164e:	80 e0       	ldi	r24, 0x00	; 0
    1650:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    1654:	00 00       	nop
    1656:	81 e0       	ldi	r24, 0x01	; 1
    1658:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    165c:	e0 91 00 01 	lds	r30, 0x0100
    1660:	f0 91 01 01 	lds	r31, 0x0101
    1664:	83 e8       	ldi	r24, 0x83	; 131
    1666:	09 95       	icall
    1668:	8a b5       	in	r24, 0x2a	; 42
    166a:	98 01       	movw	r18, r16
    166c:	02 c0       	rjmp	.+4      	; 0x1672 <DF_CopyBufferToFlashPage+0x2a>
    166e:	36 95       	lsr	r19
    1670:	27 95       	ror	r18
    1672:	8a 95       	dec	r24
    1674:	e2 f7       	brpl	.-8      	; 0x166e <DF_CopyBufferToFlashPage+0x26>
    1676:	c9 01       	movw	r24, r18
    1678:	e0 91 00 01 	lds	r30, 0x0100
    167c:	f0 91 01 01 	lds	r31, 0x0101
    1680:	09 95       	icall
    1682:	8b b5       	in	r24, 0x2b	; 43
    1684:	02 c0       	rjmp	.+4      	; 0x168a <DF_CopyBufferToFlashPage+0x42>
    1686:	00 0f       	add	r16, r16
    1688:	11 1f       	adc	r17, r17
    168a:	8a 95       	dec	r24
    168c:	e2 f7       	brpl	.-8      	; 0x1686 <DF_CopyBufferToFlashPage+0x3e>
    168e:	e0 91 00 01 	lds	r30, 0x0100
    1692:	f0 91 01 01 	lds	r31, 0x0101
    1696:	80 2f       	mov	r24, r16
    1698:	09 95       	icall
    169a:	e0 91 00 01 	lds	r30, 0x0100
    169e:	f0 91 01 01 	lds	r31, 0x0101
    16a2:	80 e0       	ldi	r24, 0x00	; 0
    16a4:	09 95       	icall
    16a6:	0e 94 84 0a 	call	0x1508 <DF_GetChipCharacteristics>
    16aa:	88 23       	and	r24, r24
    16ac:	e4 f7       	brge	.-8      	; 0x16a6 <DF_CopyBufferToFlashPage+0x5e>
    16ae:	1f 91       	pop	r17
    16b0:	0f 91       	pop	r16
    16b2:	08 95       	ret

000016b4 <DF_CheckCorrectOnboardChip>:
    16b4:	0e 94 84 0a 	call	0x1508 <DF_GetChipCharacteristics>
    16b8:	80 91 86 02 	lds	r24, 0x0286
    16bc:	89 30       	cpi	r24, 0x09	; 9
    16be:	61 f0       	breq	.+24     	; 0x16d8 <DF_CheckCorrectOnboardChip+0x24>
    16c0:	80 91 64 00 	lds	r24, 0x0064
    16c4:	84 60       	ori	r24, 0x04	; 4
    16c6:	80 93 64 00 	sts	0x0064, r24
    16ca:	83 e8       	ldi	r24, 0x83	; 131
    16cc:	93 e0       	ldi	r25, 0x03	; 3
    16ce:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
    16d2:	80 e0       	ldi	r24, 0x00	; 0
    16d4:	90 e0       	ldi	r25, 0x00	; 0
    16d6:	08 95       	ret
    16d8:	81 e0       	ldi	r24, 0x01	; 1
    16da:	90 e0       	ldi	r25, 0x00	; 0
    16dc:	08 95       	ret

000016de <BUFF_InitialiseBuffer>:

// Routines:
void BUFF_InitialiseBuffer(void)
{
	StoreLoc    = (BuffType*)&RingBuffer[0]; // Set up the IN pointer to the start of the buffer
    16de:	8d e8       	ldi	r24, 0x8D	; 141
    16e0:	92 e0       	ldi	r25, 0x02	; 2
    16e2:	90 93 ce 02 	sts	0x02CE, r25
    16e6:	80 93 cd 02 	sts	0x02CD, r24
	RetrieveLoc = (BuffType*)&RingBuffer[0]; // Set up the OUT pointer to the start of the buffer
    16ea:	90 93 d0 02 	sts	0x02D0, r25
    16ee:	80 93 cf 02 	sts	0x02CF, r24

	BuffElements = 0;                     // Reset the buffer elements counter
    16f2:	10 92 d1 02 	sts	0x02D1, r1
    16f6:	08 95       	ret

000016f8 <BUFF_StoreBuffByte>:
}

void BUFF_StoreBuffByte(BuffType DataToStore)
{
    16f8:	98 2f       	mov	r25, r24
	if (BuffElements == BuffLen)          // Buffer full
    16fa:	80 91 d1 02 	lds	r24, 0x02D1
    16fe:	80 34       	cpi	r24, 0x40	; 64
    1700:	29 f4       	brne	.+10     	; 0x170c <BUFF_StoreBuffByte+0x14>
	{
		MAIN_ShowError(PSTR("BUFF OVERFLOW"));
    1702:	8b eb       	ldi	r24, 0xBB	; 187
    1704:	93 e0       	ldi	r25, 0x03	; 3
    1706:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
		return;
    170a:	08 95       	ret
	}
		
	*StoreLoc = DataToStore;              // Store the data
    170c:	e0 91 cd 02 	lds	r30, 0x02CD
    1710:	f0 91 ce 02 	lds	r31, 0x02CE
    1714:	90 83       	st	Z, r25

	StoreLoc++;                           // Increment the IN pointer to the next element
    1716:	40 91 cd 02 	lds	r20, 0x02CD
    171a:	50 91 ce 02 	lds	r21, 0x02CE
    171e:	9a 01       	movw	r18, r20
    1720:	2f 5f       	subi	r18, 0xFF	; 255
    1722:	3f 4f       	sbci	r19, 0xFF	; 255
    1724:	30 93 ce 02 	sts	0x02CE, r19
    1728:	20 93 cd 02 	sts	0x02CD, r18
	BuffElements++;                       // Increment the total elements variable
    172c:	80 91 d1 02 	lds	r24, 0x02D1
    1730:	8f 5f       	subi	r24, 0xFF	; 255
    1732:	80 93 d1 02 	sts	0x02D1, r24

	if (StoreLoc == (BuffType*)&RingBuffer[BuffLen])
    1736:	2d 5c       	subi	r18, 0xCD	; 205
    1738:	32 40       	sbci	r19, 0x02	; 2
    173a:	31 f4       	brne	.+12     	; 0x1748 <BUFF_StoreBuffByte+0x50>
		StoreLoc = (BuffType*)&RingBuffer[0]; // Wrap pointer if end of array reached
    173c:	4f 53       	subi	r20, 0x3F	; 63
    173e:	50 40       	sbci	r21, 0x00	; 0
    1740:	50 93 ce 02 	sts	0x02CE, r21
    1744:	40 93 cd 02 	sts	0x02CD, r20
    1748:	08 95       	ret

0000174a <BUFF_GetBuffByte>:
}	

BuffType BUFF_GetBuffByte(void)
{
	if (!(BuffElements))                  // No elements in the buffer
    174a:	80 91 d1 02 	lds	r24, 0x02D1
    174e:	88 23       	and	r24, r24
    1750:	19 f4       	brne	.+6      	; 0x1758 <BUFF_GetBuffByte+0xe>
		return 0;
    1752:	80 e0       	ldi	r24, 0x00	; 0
    1754:	90 e0       	ldi	r25, 0x00	; 0
    1756:	08 95       	ret

	BuffType RetrievedData = *RetrieveLoc; // Grab the stored byte into a temp variable
    1758:	20 91 cf 02 	lds	r18, 0x02CF
    175c:	30 91 d0 02 	lds	r19, 0x02D0
    1760:	f9 01       	movw	r30, r18
    1762:	91 91       	ld	r25, Z+

	RetrieveLoc++;                         // Increment the OUT pointer to the next element if flag set
    1764:	f0 93 d0 02 	sts	0x02D0, r31
    1768:	e0 93 cf 02 	sts	0x02CF, r30
	BuffElements--;                        // Decrement the total elements variable
    176c:	80 91 d1 02 	lds	r24, 0x02D1
    1770:	81 50       	subi	r24, 0x01	; 1
    1772:	80 93 d1 02 	sts	0x02D1, r24
	
	if (RetrieveLoc == (BuffType*)&RingBuffer[BuffLen])
    1776:	ed 5c       	subi	r30, 0xCD	; 205
    1778:	f2 40       	sbci	r31, 0x02	; 2
    177a:	31 f4       	brne	.+12     	; 0x1788 <BUFF_GetBuffByte+0x3e>
		RetrieveLoc = (BuffType*)&RingBuffer[0]; // Wrap pointer if end of array reached
    177c:	2f 53       	subi	r18, 0x3F	; 63
    177e:	30 40       	sbci	r19, 0x00	; 0
    1780:	30 93 d0 02 	sts	0x02D0, r19
    1784:	20 93 cf 02 	sts	0x02CF, r18
		
	return RetrievedData;                 // Return the retrieved data
    1788:	89 2f       	mov	r24, r25
    178a:	99 27       	eor	r25, r25
}
    178c:	08 95       	ret

0000178e <__vector_9>:
// ======================================================================================

// Timeout = ((F_CPU / 64) / (65535 * TIMEOUT_TICKSBEFORETIMEOUT)) per second
ISR(TIMER1_OVF_vect, ISR_NOBLOCK)
{
    178e:	78 94       	sei
    1790:	1f 92       	push	r1
    1792:	0f 92       	push	r0
    1794:	0f b6       	in	r0, 0x3f	; 63
    1796:	0f 92       	push	r0
    1798:	11 24       	eor	r1, r1
    179a:	8f 93       	push	r24
	if (Ticks++ == TIMEOUT_TICKSBEFORETIMEOUT)
    179c:	80 91 29 01 	lds	r24, 0x0129
    17a0:	8f 5f       	subi	r24, 0xFF	; 255
    17a2:	80 93 29 01 	sts	0x0129, r24
    17a6:	80 91 29 01 	lds	r24, 0x0129
    17aa:	87 30       	cpi	r24, 0x07	; 7
    17ac:	29 f4       	brne	.+10     	; 0x17b8 <__vector_9+0x2a>
	{
	   Ticks   = 0;
    17ae:	10 92 29 01 	sts	0x0129, r1
	   TimeOut = TRUE;
    17b2:	81 e0       	ldi	r24, 0x01	; 1
    17b4:	80 93 28 01 	sts	0x0128, r24
    17b8:	8f 91       	pop	r24
    17ba:	0f 90       	pop	r0
    17bc:	0f be       	out	0x3f, r0	; 63
    17be:	0f 90       	pop	r0
    17c0:	1f 90       	pop	r1
    17c2:	18 95       	reti

000017c4 <TIMEOUT_SetupTimeoutTimer>:
	}
}

// ======================================================================================

void TIMEOUT_SetupTimeoutTimer(void)
{
	TCCR1A = 0;
    17c4:	10 92 80 00 	sts	0x0080, r1
	TIMEOUT_TIMER_OFF();
    17c8:	10 92 81 00 	sts	0x0081, r1
    17cc:	10 92 29 01 	sts	0x0129, r1
    17d0:	10 92 85 00 	sts	0x0085, r1
    17d4:	10 92 84 00 	sts	0x0084, r1
	TCCR1C = 0;
    17d8:	10 92 82 00 	sts	0x0082, r1
	
	TIMSK1 = (1 << TOIE1); // Turn timer 1 overflow interrupt on
    17dc:	81 e0       	ldi	r24, 0x01	; 1
    17de:	80 93 6f 00 	sts	0x006F, r24
    17e2:	08 95       	ret

000017e4 <PD_SetupDFAddressCounters>:
}

void PD_SetupDFAddressCounters(void)
{
	uint32_t StartAddress = CurrAddress;
    17e4:	20 91 2b 01 	lds	r18, 0x012B
    17e8:	30 91 2c 01 	lds	r19, 0x012C
    17ec:	40 91 2d 01 	lds	r20, 0x012D
    17f0:	50 91 2e 01 	lds	r21, 0x012E

	CurrPageAddress = 0;
    17f4:	10 92 8c 02 	sts	0x028C, r1
    17f8:	10 92 8b 02 	sts	0x028B, r1

	while (StartAddress > DataflashInfo.PageSize)      // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DataflashInfo.PageSize;         // Subtract one page's worth of bytes from the desired address
		CurrPageAddress++;
    17fc:	80 91 87 02 	lds	r24, 0x0287
    1800:	90 91 88 02 	lds	r25, 0x0288
    1804:	aa 27       	eor	r26, r26
    1806:	bb 27       	eor	r27, r27
    1808:	82 17       	cp	r24, r18
    180a:	93 07       	cpc	r25, r19
    180c:	a4 07       	cpc	r26, r20
    180e:	b5 07       	cpc	r27, r21
    1810:	88 f4       	brcc	.+34     	; 0x1834 <PD_SetupDFAddressCounters+0x50>
    1812:	60 e0       	ldi	r22, 0x00	; 0
    1814:	70 e0       	ldi	r23, 0x00	; 0
    1816:	28 1b       	sub	r18, r24
    1818:	39 0b       	sbc	r19, r25
    181a:	4a 0b       	sbc	r20, r26
    181c:	5b 0b       	sbc	r21, r27
    181e:	6f 5f       	subi	r22, 0xFF	; 255
    1820:	7f 4f       	sbci	r23, 0xFF	; 255
    1822:	82 17       	cp	r24, r18
    1824:	93 07       	cpc	r25, r19
    1826:	a4 07       	cpc	r26, r20
    1828:	b5 07       	cpc	r27, r21
    182a:	a8 f3       	brcs	.-22     	; 0x1816 <PD_SetupDFAddressCounters+0x32>
    182c:	70 93 8c 02 	sts	0x028C, r23
    1830:	60 93 8b 02 	sts	0x028B, r22
	}
	
	CurrBuffByte = (uint16_t)StartAddress;              // The buffer byte is the remainder
    1834:	30 93 85 02 	sts	0x0285, r19
    1838:	20 93 84 02 	sts	0x0284, r18
    183c:	08 95       	ret

0000183e <PD_StoreDataflashByte>:
}

void PD_StoreDataflashByte(uint8_t Data)
{
    183e:	cf 93       	push	r28
    1840:	c8 2f       	mov	r28, r24
	if (CurrBuffByte == DataflashInfo.PageSize)
    1842:	20 91 84 02 	lds	r18, 0x0284
    1846:	30 91 85 02 	lds	r19, 0x0285
    184a:	80 91 87 02 	lds	r24, 0x0287
    184e:	90 91 88 02 	lds	r25, 0x0288
    1852:	28 17       	cp	r18, r24
    1854:	39 07       	cpc	r19, r25
    1856:	a9 f4       	brne	.+42     	; 0x1882 <PD_StoreDataflashByte+0x44>
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
    1858:	80 91 8b 02 	lds	r24, 0x028B
    185c:	90 91 8c 02 	lds	r25, 0x028C
    1860:	9c 01       	movw	r18, r24
    1862:	01 96       	adiw	r24, 0x01	; 1
    1864:	90 93 8c 02 	sts	0x028C, r25
    1868:	80 93 8b 02 	sts	0x028B, r24
    186c:	c9 01       	movw	r24, r18
    186e:	0e 94 24 0b 	call	0x1648 <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    1872:	80 e0       	ldi	r24, 0x00	; 0
    1874:	90 e0       	ldi	r25, 0x00	; 0
    1876:	0e 94 5e 0a 	call	0x14bc <DF_BufferWriteEnable>
		CurrBuffByte = 0;
    187a:	10 92 85 02 	sts	0x0285, r1
    187e:	10 92 84 02 	sts	0x0284, r1
	}
	
	USI_SPITransmit(Data);                                 // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    1882:	8c 2f       	mov	r24, r28
    1884:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
	CurrBuffByte++;
    1888:	80 91 84 02 	lds	r24, 0x0284
    188c:	90 91 85 02 	lds	r25, 0x0285
    1890:	01 96       	adiw	r24, 0x01	; 1
    1892:	90 93 85 02 	sts	0x0285, r25
    1896:	80 93 84 02 	sts	0x0284, r24
    189a:	cf 91       	pop	r28
    189c:	08 95       	ret

0000189e <PD_InterpretAVRISPPacket>:
    189e:	ef 92       	push	r14
    18a0:	ff 92       	push	r15
    18a2:	0f 93       	push	r16
    18a4:	1f 93       	push	r17
    18a6:	cf 93       	push	r28
    18a8:	df 93       	push	r29
    18aa:	80 91 34 01 	lds	r24, 0x0134
    18ae:	99 27       	eor	r25, r25
    18b0:	86 31       	cpi	r24, 0x16	; 22
    18b2:	91 05       	cpc	r25, r1
    18b4:	09 f4       	brne	.+2      	; 0x18b8 <PD_InterpretAVRISPPacket+0x1a>
    18b6:	09 c1       	rjmp	.+530    	; 0x1aca <PD_InterpretAVRISPPacket+0x22c>
    18b8:	87 31       	cpi	r24, 0x17	; 23
    18ba:	91 05       	cpc	r25, r1
    18bc:	b4 f4       	brge	.+44     	; 0x18ea <PD_InterpretAVRISPPacket+0x4c>
    18be:	82 31       	cpi	r24, 0x12	; 18
    18c0:	91 05       	cpc	r25, r1
    18c2:	09 f4       	brne	.+2      	; 0x18c6 <PD_InterpretAVRISPPacket+0x28>
    18c4:	69 c0       	rjmp	.+210    	; 0x1998 <PD_InterpretAVRISPPacket+0xfa>
    18c6:	83 31       	cpi	r24, 0x13	; 19
    18c8:	91 05       	cpc	r25, r1
    18ca:	3c f4       	brge	.+14     	; 0x18da <PD_InterpretAVRISPPacket+0x3c>
    18cc:	80 31       	cpi	r24, 0x10	; 16
    18ce:	91 05       	cpc	r25, r1
    18d0:	31 f1       	breq	.+76     	; 0x191e <PD_InterpretAVRISPPacket+0x80>
    18d2:	41 97       	sbiw	r24, 0x11	; 17
    18d4:	09 f4       	brne	.+2      	; 0x18d8 <PD_InterpretAVRISPPacket+0x3a>
    18d6:	46 c0       	rjmp	.+140    	; 0x1964 <PD_InterpretAVRISPPacket+0xc6>
    18d8:	49 c1       	rjmp	.+658    	; 0x1b6c <PD_InterpretAVRISPPacket+0x2ce>
    18da:	84 31       	cpi	r24, 0x14	; 20
    18dc:	91 05       	cpc	r25, r1
    18de:	09 f4       	brne	.+2      	; 0x18e2 <PD_InterpretAVRISPPacket+0x44>
    18e0:	95 c0       	rjmp	.+298    	; 0x1a0c <PD_InterpretAVRISPPacket+0x16e>
    18e2:	45 97       	sbiw	r24, 0x15	; 21
    18e4:	0c f0       	brlt	.+2      	; 0x18e8 <PD_InterpretAVRISPPacket+0x4a>
    18e6:	b8 c0       	rjmp	.+368    	; 0x1a58 <PD_InterpretAVRISPPacket+0x1ba>
    18e8:	8a c0       	rjmp	.+276    	; 0x19fe <PD_InterpretAVRISPPacket+0x160>
    18ea:	89 31       	cpi	r24, 0x19	; 25
    18ec:	91 05       	cpc	r25, r1
    18ee:	09 f4       	brne	.+2      	; 0x18f2 <PD_InterpretAVRISPPacket+0x54>
    18f0:	7b c0       	rjmp	.+246    	; 0x19e8 <PD_InterpretAVRISPPacket+0x14a>
    18f2:	8a 31       	cpi	r24, 0x1A	; 26
    18f4:	91 05       	cpc	r25, r1
    18f6:	44 f4       	brge	.+16     	; 0x1908 <PD_InterpretAVRISPPacket+0x6a>
    18f8:	87 31       	cpi	r24, 0x17	; 23
    18fa:	91 05       	cpc	r25, r1
    18fc:	09 f4       	brne	.+2      	; 0x1900 <PD_InterpretAVRISPPacket+0x62>
    18fe:	74 c0       	rjmp	.+232    	; 0x19e8 <PD_InterpretAVRISPPacket+0x14a>
    1900:	48 97       	sbiw	r24, 0x18	; 24
    1902:	09 f4       	brne	.+2      	; 0x1906 <PD_InterpretAVRISPPacket+0x68>
    1904:	63 c0       	rjmp	.+198    	; 0x19cc <PD_InterpretAVRISPPacket+0x12e>
    1906:	32 c1       	rjmp	.+612    	; 0x1b6c <PD_InterpretAVRISPPacket+0x2ce>
    1908:	8b 31       	cpi	r24, 0x1B	; 27
    190a:	91 05       	cpc	r25, r1
    190c:	d9 f1       	breq	.+118    	; 0x1984 <PD_InterpretAVRISPPacket+0xe6>
    190e:	8b 31       	cpi	r24, 0x1B	; 27
    1910:	91 05       	cpc	r25, r1
    1912:	0c f4       	brge	.+2      	; 0x1916 <PD_InterpretAVRISPPacket+0x78>
    1914:	5b c0       	rjmp	.+182    	; 0x19cc <PD_InterpretAVRISPPacket+0x12e>
    1916:	4c 97       	sbiw	r24, 0x1c	; 28
    1918:	09 f4       	brne	.+2      	; 0x191c <PD_InterpretAVRISPPacket+0x7e>
    191a:	58 c0       	rjmp	.+176    	; 0x19cc <PD_InterpretAVRISPPacket+0x12e>
    191c:	27 c1       	rjmp	.+590    	; 0x1b6c <PD_InterpretAVRISPPacket+0x2ce>
    191e:	82 e0       	ldi	r24, 0x02	; 2
    1920:	90 e0       	ldi	r25, 0x00	; 0
    1922:	90 93 31 01 	sts	0x0131, r25
    1926:	80 93 30 01 	sts	0x0130, r24
    192a:	81 e0       	ldi	r24, 0x01	; 1
    192c:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    1930:	0e 94 84 0a 	call	0x1508 <DF_GetChipCharacteristics>
    1934:	c0 91 86 02 	lds	r28, 0x0286
    1938:	cc 23       	and	r28, r28
    193a:	59 f0       	breq	.+22     	; 0x1952 <PD_InterpretAVRISPPacket+0xb4>
    193c:	89 ec       	ldi	r24, 0xC9	; 201
    193e:	93 e0       	ldi	r25, 0x03	; 3
    1940:	0e 94 ff 07 	call	0xffe <LCD_puts_f>
    1944:	81 e0       	ldi	r24, 0x01	; 1
    1946:	80 93 2f 01 	sts	0x012F, r24
    194a:	81 b3       	in	r24, 0x11	; 17
    194c:	8f 7c       	andi	r24, 0xCF	; 207
    194e:	80 62       	ori	r24, 0x20	; 32
    1950:	17 c0       	rjmp	.+46     	; 0x1980 <PD_InterpretAVRISPPacket+0xe2>
    1952:	83 e8       	ldi	r24, 0x83	; 131
    1954:	93 e0       	ldi	r25, 0x03	; 3
    1956:	0e 94 ff 07 	call	0xffe <LCD_puts_f>
    195a:	8c 2f       	mov	r24, r28
    195c:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    1960:	80 ec       	ldi	r24, 0xC0	; 192
    1962:	0b c1       	rjmp	.+534    	; 0x1b7a <PD_InterpretAVRISPPacket+0x2dc>
    1964:	82 e0       	ldi	r24, 0x02	; 2
    1966:	90 e0       	ldi	r25, 0x00	; 0
    1968:	90 93 31 01 	sts	0x0131, r25
    196c:	80 93 30 01 	sts	0x0130, r24
    1970:	10 92 2f 01 	sts	0x012F, r1
    1974:	80 e0       	ldi	r24, 0x00	; 0
    1976:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    197a:	81 b3       	in	r24, 0x11	; 17
    197c:	8f 7c       	andi	r24, 0xCF	; 207
    197e:	80 61       	ori	r24, 0x10	; 16
    1980:	81 bb       	out	0x11, r24	; 17
    1982:	a0 c0       	rjmp	.+320    	; 0x1ac4 <PD_InterpretAVRISPPacket+0x226>
    1984:	84 e0       	ldi	r24, 0x04	; 4
    1986:	90 e0       	ldi	r25, 0x00	; 0
    1988:	90 93 31 01 	sts	0x0131, r25
    198c:	80 93 30 01 	sts	0x0130, r24
    1990:	10 92 35 01 	sts	0x0135, r1
    1994:	82 e0       	ldi	r24, 0x02	; 2
    1996:	23 c0       	rjmp	.+70     	; 0x19de <PD_InterpretAVRISPPacket+0x140>
    1998:	82 e0       	ldi	r24, 0x02	; 2
    199a:	90 e0       	ldi	r25, 0x00	; 0
    199c:	90 93 31 01 	sts	0x0131, r25
    19a0:	80 93 30 01 	sts	0x0130, r24
    19a4:	c0 e0       	ldi	r28, 0x00	; 0
    19a6:	d0 e0       	ldi	r29, 0x00	; 0
    19a8:	80 91 89 02 	lds	r24, 0x0289
    19ac:	90 91 8a 02 	lds	r25, 0x028A
    19b0:	63 e0       	ldi	r22, 0x03	; 3
    19b2:	96 95       	lsr	r25
    19b4:	87 95       	ror	r24
    19b6:	6a 95       	dec	r22
    19b8:	e1 f7       	brne	.-8      	; 0x19b2 <PD_InterpretAVRISPPacket+0x114>
    19ba:	c8 17       	cp	r28, r24
    19bc:	d9 07       	cpc	r29, r25
    19be:	08 f0       	brcs	.+2      	; 0x19c2 <PD_InterpretAVRISPPacket+0x124>
    19c0:	81 c0       	rjmp	.+258    	; 0x1ac4 <PD_InterpretAVRISPPacket+0x226>
    19c2:	ce 01       	movw	r24, r28
    19c4:	0e 94 c4 0a 	call	0x1588 <DF_EraseBlock>
    19c8:	21 96       	adiw	r28, 0x01	; 1
    19ca:	ee cf       	rjmp	.-36     	; 0x19a8 <PD_InterpretAVRISPPacket+0x10a>
    19cc:	84 e0       	ldi	r24, 0x04	; 4
    19ce:	90 e0       	ldi	r25, 0x00	; 0
    19d0:	90 93 31 01 	sts	0x0131, r25
    19d4:	80 93 30 01 	sts	0x0130, r24
    19d8:	10 92 35 01 	sts	0x0135, r1
    19dc:	8f ef       	ldi	r24, 0xFF	; 255
    19de:	80 93 36 01 	sts	0x0136, r24
    19e2:	10 92 37 01 	sts	0x0137, r1
    19e6:	cb c0       	rjmp	.+406    	; 0x1b7e <PD_InterpretAVRISPPacket+0x2e0>
    19e8:	83 e0       	ldi	r24, 0x03	; 3
    19ea:	90 e0       	ldi	r25, 0x00	; 0
    19ec:	90 93 31 01 	sts	0x0131, r25
    19f0:	80 93 30 01 	sts	0x0130, r24
    19f4:	10 92 35 01 	sts	0x0135, r1
    19f8:	10 92 36 01 	sts	0x0136, r1
    19fc:	c0 c0       	rjmp	.+384    	; 0x1b7e <PD_InterpretAVRISPPacket+0x2e0>
    19fe:	82 e0       	ldi	r24, 0x02	; 2
    1a00:	90 e0       	ldi	r25, 0x00	; 0
    1a02:	90 93 31 01 	sts	0x0131, r25
    1a06:	80 93 30 01 	sts	0x0130, r24
    1a0a:	5c c0       	rjmp	.+184    	; 0x1ac4 <PD_InterpretAVRISPPacket+0x226>
    1a0c:	80 91 35 01 	lds	r24, 0x0135
    1a10:	99 27       	eor	r25, r25
    1a12:	38 2f       	mov	r19, r24
    1a14:	22 27       	eor	r18, r18
    1a16:	80 91 36 01 	lds	r24, 0x0136
    1a1a:	99 27       	eor	r25, r25
    1a1c:	28 2b       	or	r18, r24
    1a1e:	39 2b       	or	r19, r25
    1a20:	f9 01       	movw	r30, r18
    1a22:	33 96       	adiw	r30, 0x03	; 3
    1a24:	f0 93 31 01 	sts	0x0131, r31
    1a28:	e0 93 30 01 	sts	0x0130, r30
    1a2c:	10 92 35 01 	sts	0x0135, r1
    1a30:	ed 5c       	subi	r30, 0xCD	; 205
    1a32:	fe 4f       	sbci	r31, 0xFE	; 254
    1a34:	10 82       	st	Z, r1
    1a36:	81 e0       	ldi	r24, 0x01	; 1
    1a38:	90 e0       	ldi	r25, 0x00	; 0
    1a3a:	28 0f       	add	r18, r24
    1a3c:	39 1f       	adc	r19, r25
    1a3e:	82 17       	cp	r24, r18
    1a40:	93 07       	cpc	r25, r19
    1a42:	08 f0       	brcs	.+2      	; 0x1a46 <PD_InterpretAVRISPPacket+0x1a8>
    1a44:	9c c0       	rjmp	.+312    	; 0x1b7e <PD_InterpretAVRISPPacket+0x2e0>
    1a46:	4f ef       	ldi	r20, 0xFF	; 255
    1a48:	e5 e3       	ldi	r30, 0x35	; 53
    1a4a:	f1 e0       	ldi	r31, 0x01	; 1
    1a4c:	41 93       	st	Z+, r20
    1a4e:	01 96       	adiw	r24, 0x01	; 1
    1a50:	82 17       	cp	r24, r18
    1a52:	93 07       	cpc	r25, r19
    1a54:	d8 f3       	brcs	.-10     	; 0x1a4c <PD_InterpretAVRISPPacket+0x1ae>
    1a56:	93 c0       	rjmp	.+294    	; 0x1b7e <PD_InterpretAVRISPPacket+0x2e0>
    1a58:	0e 94 f2 0b 	call	0x17e4 <PD_SetupDFAddressCounters>
    1a5c:	80 91 8b 02 	lds	r24, 0x028B
    1a60:	90 91 8c 02 	lds	r25, 0x028C
    1a64:	0e 94 ee 0a 	call	0x15dc <DF_CopyFlashPageToBuffer>
    1a68:	80 91 84 02 	lds	r24, 0x0284
    1a6c:	90 91 85 02 	lds	r25, 0x0285
    1a70:	0e 94 5e 0a 	call	0x14bc <DF_BufferWriteEnable>
    1a74:	80 91 35 01 	lds	r24, 0x0135
    1a78:	99 27       	eor	r25, r25
    1a7a:	d8 2f       	mov	r29, r24
    1a7c:	cc 27       	eor	r28, r28
    1a7e:	80 91 36 01 	lds	r24, 0x0136
    1a82:	99 27       	eor	r25, r25
    1a84:	c8 2b       	or	r28, r24
    1a86:	d9 2b       	or	r29, r25
    1a88:	00 e0       	ldi	r16, 0x00	; 0
    1a8a:	10 e0       	ldi	r17, 0x00	; 0
    1a8c:	0c 17       	cp	r16, r28
    1a8e:	1d 07       	cpc	r17, r29
    1a90:	c8 f4       	brcc	.+50     	; 0x1ac4 <PD_InterpretAVRISPPacket+0x226>
    1a92:	3e e3       	ldi	r19, 0x3E	; 62
    1a94:	e3 2e       	mov	r14, r19
    1a96:	31 e0       	ldi	r19, 0x01	; 1
    1a98:	f3 2e       	mov	r15, r19
    1a9a:	f7 01       	movw	r30, r14
    1a9c:	81 91       	ld	r24, Z+
    1a9e:	7f 01       	movw	r14, r30
    1aa0:	0e 94 1f 0c 	call	0x183e <PD_StoreDataflashByte>
    1aa4:	80 91 84 02 	lds	r24, 0x0284
    1aa8:	90 91 85 02 	lds	r25, 0x0285
    1aac:	01 96       	adiw	r24, 0x01	; 1
    1aae:	90 93 85 02 	sts	0x0285, r25
    1ab2:	80 93 84 02 	sts	0x0284, r24
    1ab6:	0e 94 c3 0e 	call	0x1d86 <V2P_IncrementCurrAddress>
    1aba:	0f 5f       	subi	r16, 0xFF	; 255
    1abc:	1f 4f       	sbci	r17, 0xFF	; 255
    1abe:	0c 17       	cp	r16, r28
    1ac0:	1d 07       	cpc	r17, r29
    1ac2:	58 f3       	brcs	.-42     	; 0x1a9a <PD_InterpretAVRISPPacket+0x1fc>
    1ac4:	10 92 35 01 	sts	0x0135, r1
    1ac8:	5a c0       	rjmp	.+180    	; 0x1b7e <PD_InterpretAVRISPPacket+0x2e0>
    1aca:	0e 94 f2 0b 	call	0x17e4 <PD_SetupDFAddressCounters>
    1ace:	80 91 8b 02 	lds	r24, 0x028B
    1ad2:	90 91 8c 02 	lds	r25, 0x028C
    1ad6:	0e 94 ee 0a 	call	0x15dc <DF_CopyFlashPageToBuffer>
    1ada:	80 91 35 01 	lds	r24, 0x0135
    1ade:	99 27       	eor	r25, r25
    1ae0:	d8 2f       	mov	r29, r24
    1ae2:	cc 27       	eor	r28, r28
    1ae4:	80 91 36 01 	lds	r24, 0x0136
    1ae8:	99 27       	eor	r25, r25
    1aea:	c8 2b       	or	r28, r24
    1aec:	d9 2b       	or	r29, r25
    1aee:	00 e0       	ldi	r16, 0x00	; 0
    1af0:	10 e0       	ldi	r17, 0x00	; 0
    1af2:	0c 17       	cp	r16, r28
    1af4:	1d 07       	cpc	r17, r29
    1af6:	70 f5       	brcc	.+92     	; 0x1b54 <PD_InterpretAVRISPPacket+0x2b6>
    1af8:	86 e3       	ldi	r24, 0x36	; 54
    1afa:	e8 2e       	mov	r14, r24
    1afc:	81 e0       	ldi	r24, 0x01	; 1
    1afe:	f8 2e       	mov	r15, r24
    1b00:	20 91 84 02 	lds	r18, 0x0284
    1b04:	30 91 85 02 	lds	r19, 0x0285
    1b08:	80 91 87 02 	lds	r24, 0x0287
    1b0c:	90 91 88 02 	lds	r25, 0x0288
    1b10:	28 17       	cp	r18, r24
    1b12:	39 07       	cpc	r19, r25
    1b14:	41 f4       	brne	.+16     	; 0x1b26 <PD_InterpretAVRISPPacket+0x288>
    1b16:	0e 94 f2 0b 	call	0x17e4 <PD_SetupDFAddressCounters>
    1b1a:	80 91 8b 02 	lds	r24, 0x028B
    1b1e:	90 91 8c 02 	lds	r25, 0x028C
    1b22:	0e 94 ee 0a 	call	0x15dc <DF_CopyFlashPageToBuffer>
    1b26:	80 91 84 02 	lds	r24, 0x0284
    1b2a:	90 91 85 02 	lds	r25, 0x0285
    1b2e:	9c 01       	movw	r18, r24
    1b30:	01 96       	adiw	r24, 0x01	; 1
    1b32:	90 93 85 02 	sts	0x0285, r25
    1b36:	80 93 84 02 	sts	0x0284, r24
    1b3a:	c9 01       	movw	r24, r18
    1b3c:	0e 94 ee 09 	call	0x13dc <DF_ReadBufferByte>
    1b40:	f7 01       	movw	r30, r14
    1b42:	81 93       	st	Z+, r24
    1b44:	7f 01       	movw	r14, r30
    1b46:	0e 94 c3 0e 	call	0x1d86 <V2P_IncrementCurrAddress>
    1b4a:	0f 5f       	subi	r16, 0xFF	; 255
    1b4c:	1f 4f       	sbci	r17, 0xFF	; 255
    1b4e:	0c 17       	cp	r16, r28
    1b50:	1d 07       	cpc	r17, r29
    1b52:	b0 f2       	brcs	.-84     	; 0x1b00 <PD_InterpretAVRISPPacket+0x262>
    1b54:	23 96       	adiw	r28, 0x03	; 3
    1b56:	d0 93 31 01 	sts	0x0131, r29
    1b5a:	c0 93 30 01 	sts	0x0130, r28
    1b5e:	23 97       	sbiw	r28, 0x03	; 3
    1b60:	10 92 35 01 	sts	0x0135, r1
    1b64:	cc 5c       	subi	r28, 0xCC	; 204
    1b66:	de 4f       	sbci	r29, 0xFE	; 254
    1b68:	1a 82       	std	Y+2, r1	; 0x02
    1b6a:	09 c0       	rjmp	.+18     	; 0x1b7e <PD_InterpretAVRISPPacket+0x2e0>
    1b6c:	81 e0       	ldi	r24, 0x01	; 1
    1b6e:	90 e0       	ldi	r25, 0x00	; 0
    1b70:	90 93 31 01 	sts	0x0131, r25
    1b74:	80 93 30 01 	sts	0x0130, r24
    1b78:	89 ec       	ldi	r24, 0xC9	; 201
    1b7a:	80 93 35 01 	sts	0x0135, r24
    1b7e:	0e 94 e9 0d 	call	0x1bd2 <V2P_SendPacket>
    1b82:	df 91       	pop	r29
    1b84:	cf 91       	pop	r28
    1b86:	1f 91       	pop	r17
    1b88:	0f 91       	pop	r16
    1b8a:	ff 90       	pop	r15
    1b8c:	ef 90       	pop	r14
    1b8e:	08 95       	ret

00001b90 <V2P_GetChecksum>:
	
	/* Checksum for the V2 protocol is comprised of an XOR of all the packet 
      bytes, including the start, sequence number, size and token bytes.    */
	
	CheckSumByte  = MESSAGE_START;
    1b90:	6b e1       	ldi	r22, 0x1B	; 27
	CheckSumByte ^= SequenceNum;
    1b92:	80 91 32 01 	lds	r24, 0x0132
    1b96:	68 27       	eor	r22, r24
	CheckSumByte ^= (uint8_t)(MessageSize >> 8);
    1b98:	20 91 30 01 	lds	r18, 0x0130
    1b9c:	30 91 31 01 	lds	r19, 0x0131
    1ba0:	83 2f       	mov	r24, r19
    1ba2:	99 27       	eor	r25, r25
    1ba4:	68 27       	eor	r22, r24
	CheckSumByte ^= (uint8_t)(MessageSize);
    1ba6:	80 91 30 01 	lds	r24, 0x0130
    1baa:	68 27       	eor	r22, r24
	CheckSumByte ^= TOKEN;
    1bac:	8e e0       	ldi	r24, 0x0E	; 14
    1bae:	68 27       	eor	r22, r24
	
	for(uint16_t CByteIndex = 0; CByteIndex < MessageSize; CByteIndex++)
    1bb0:	40 e0       	ldi	r20, 0x00	; 0
    1bb2:	50 e0       	ldi	r21, 0x00	; 0
    1bb4:	42 17       	cp	r20, r18
    1bb6:	53 07       	cpc	r21, r19
    1bb8:	48 f4       	brcc	.+18     	; 0x1bcc <V2P_GetChecksum+0x3c>
    1bba:	e4 e3       	ldi	r30, 0x34	; 52
    1bbc:	f1 e0       	ldi	r31, 0x01	; 1
		CheckSumByte ^= PacketBytes[CByteIndex];
    1bbe:	81 91       	ld	r24, Z+
    1bc0:	68 27       	eor	r22, r24
    1bc2:	4f 5f       	subi	r20, 0xFF	; 255
    1bc4:	5f 4f       	sbci	r21, 0xFF	; 255
    1bc6:	42 17       	cp	r20, r18
    1bc8:	53 07       	cpc	r21, r19
    1bca:	c8 f3       	brcs	.-14     	; 0x1bbe <V2P_GetChecksum+0x2e>

	return CheckSumByte;
}
    1bcc:	86 2f       	mov	r24, r22
    1bce:	99 27       	eor	r25, r25
    1bd0:	08 95       	ret

00001bd2 <V2P_SendPacket>:
    1bd2:	0f 93       	push	r16
    1bd4:	1f 93       	push	r17
    1bd6:	cf 93       	push	r28
    1bd8:	df 93       	push	r29
    1bda:	8b e1       	ldi	r24, 0x1B	; 27
    1bdc:	0e 94 ef 08 	call	0x11de <USART_Tx>
    1be0:	80 91 32 01 	lds	r24, 0x0132
    1be4:	0e 94 ef 08 	call	0x11de <USART_Tx>
    1be8:	80 91 31 01 	lds	r24, 0x0131
    1bec:	0e 94 ef 08 	call	0x11de <USART_Tx>
    1bf0:	80 91 30 01 	lds	r24, 0x0130
    1bf4:	0e 94 ef 08 	call	0x11de <USART_Tx>
    1bf8:	8e e0       	ldi	r24, 0x0E	; 14
    1bfa:	0e 94 ef 08 	call	0x11de <USART_Tx>
    1bfe:	c0 e0       	ldi	r28, 0x00	; 0
    1c00:	d0 e0       	ldi	r29, 0x00	; 0
    1c02:	80 91 30 01 	lds	r24, 0x0130
    1c06:	90 91 31 01 	lds	r25, 0x0131
    1c0a:	c8 17       	cp	r28, r24
    1c0c:	d9 07       	cpc	r29, r25
    1c0e:	78 f4       	brcc	.+30     	; 0x1c2e <V2P_SendPacket+0x5c>
    1c10:	04 e3       	ldi	r16, 0x34	; 52
    1c12:	11 e0       	ldi	r17, 0x01	; 1
    1c14:	f8 01       	movw	r30, r16
    1c16:	81 91       	ld	r24, Z+
    1c18:	8f 01       	movw	r16, r30
    1c1a:	0e 94 ef 08 	call	0x11de <USART_Tx>
    1c1e:	21 96       	adiw	r28, 0x01	; 1
    1c20:	80 91 30 01 	lds	r24, 0x0130
    1c24:	90 91 31 01 	lds	r25, 0x0131
    1c28:	c8 17       	cp	r28, r24
    1c2a:	d9 07       	cpc	r29, r25
    1c2c:	98 f3       	brcs	.-26     	; 0x1c14 <V2P_SendPacket+0x42>
    1c2e:	0e 94 c8 0d 	call	0x1b90 <V2P_GetChecksum>
    1c32:	0e 94 ef 08 	call	0x11de <USART_Tx>
    1c36:	80 91 32 01 	lds	r24, 0x0132
    1c3a:	90 91 33 01 	lds	r25, 0x0133
    1c3e:	01 96       	adiw	r24, 0x01	; 1
    1c40:	90 93 33 01 	sts	0x0133, r25
    1c44:	80 93 32 01 	sts	0x0132, r24
    1c48:	df 91       	pop	r29
    1c4a:	cf 91       	pop	r28
    1c4c:	1f 91       	pop	r17
    1c4e:	0f 91       	pop	r16
    1c50:	08 95       	ret

00001c52 <V2P_GetSetParamater>:

void V2P_GetSetParamater(void)
{
	uint8_t Param_Name = PacketBytes[1];    // Save the parameter number
    1c52:	20 91 35 01 	lds	r18, 0x0135

	MessageSize = 3;                        // Set the default response message size to 3 bytes     
    1c56:	83 e0       	ldi	r24, 0x03	; 3
    1c58:	90 e0       	ldi	r25, 0x00	; 0
    1c5a:	90 93 31 01 	sts	0x0131, r25
    1c5e:	80 93 30 01 	sts	0x0130, r24
	PacketBytes[1] = STATUS_CMD_OK;         // Set the default response to OK
    1c62:	10 92 35 01 	sts	0x0135, r1

	switch (Param_Name)                    // Switch based on the recieved parameter byte
    1c66:	e2 2f       	mov	r30, r18
    1c68:	ff 27       	eor	r31, r31
    1c6a:	e8 39       	cpi	r30, 0x98	; 152
    1c6c:	f1 05       	cpc	r31, r1
    1c6e:	ac f4       	brge	.+42     	; 0x1c9a <V2P_GetSetParamater+0x48>
    1c70:	e6 39       	cpi	r30, 0x96	; 150
    1c72:	f1 05       	cpc	r31, r1
    1c74:	0c f0       	brlt	.+2      	; 0x1c78 <V2P_GetSetParamater+0x26>
    1c76:	6d c0       	rjmp	.+218    	; 0x1d52 <V2P_GetSetParamater+0x100>
    1c78:	e1 38       	cpi	r30, 0x81	; 129
    1c7a:	f1 05       	cpc	r31, r1
    1c7c:	f9 f0       	breq	.+62     	; 0x1cbc <V2P_GetSetParamater+0x6a>
    1c7e:	e2 38       	cpi	r30, 0x82	; 130
    1c80:	f1 05       	cpc	r31, r1
    1c82:	24 f4       	brge	.+8      	; 0x1c8c <V2P_GetSetParamater+0x3a>
    1c84:	e0 38       	cpi	r30, 0x80	; 128
    1c86:	f1 05       	cpc	r31, r1
    1c88:	b9 f0       	breq	.+46     	; 0x1cb8 <V2P_GetSetParamater+0x66>
    1c8a:	71 c0       	rjmp	.+226    	; 0x1d6e <V2P_GetSetParamater+0x11c>
    1c8c:	cf 01       	movw	r24, r30
    1c8e:	80 59       	subi	r24, 0x90	; 144
    1c90:	90 40       	sbci	r25, 0x00	; 0
    1c92:	03 97       	sbiw	r24, 0x03	; 3
    1c94:	08 f0       	brcs	.+2      	; 0x1c98 <V2P_GetSetParamater+0x46>
    1c96:	6b c0       	rjmp	.+214    	; 0x1d6e <V2P_GetSetParamater+0x11c>
    1c98:	13 c0       	rjmp	.+38     	; 0x1cc0 <V2P_GetSetParamater+0x6e>
    1c9a:	ee 39       	cpi	r30, 0x9E	; 158
    1c9c:	f1 05       	cpc	r31, r1
    1c9e:	09 f4       	brne	.+2      	; 0x1ca2 <V2P_GetSetParamater+0x50>
    1ca0:	3d c0       	rjmp	.+122    	; 0x1d1c <V2P_GetSetParamater+0xca>
    1ca2:	ef 39       	cpi	r30, 0x9F	; 159
    1ca4:	f1 05       	cpc	r31, r1
    1ca6:	24 f4       	brge	.+8      	; 0x1cb0 <V2P_GetSetParamater+0x5e>
    1ca8:	e8 39       	cpi	r30, 0x98	; 152
    1caa:	f1 05       	cpc	r31, r1
    1cac:	f9 f0       	breq	.+62     	; 0x1cec <V2P_GetSetParamater+0x9a>
    1cae:	5f c0       	rjmp	.+190    	; 0x1d6e <V2P_GetSetParamater+0x11c>
    1cb0:	ef 39       	cpi	r30, 0x9F	; 159
    1cb2:	f1 05       	cpc	r31, r1
    1cb4:	49 f0       	breq	.+18     	; 0x1cc8 <V2P_GetSetParamater+0x76>
    1cb6:	5b c0       	rjmp	.+182    	; 0x1d6e <V2P_GetSetParamater+0x11c>
	{
		case PARAM_BUILD_NUMBER_LOW:
			PacketBytes[2] = VERSION_MINOR;
    1cb8:	83 e0       	ldi	r24, 0x03	; 3
    1cba:	38 c0       	rjmp	.+112    	; 0x1d2c <V2P_GetSetParamater+0xda>

			break;
		case PARAM_BUILD_NUMBER_HIGH:
			PacketBytes[2] = VERSION_MAJOR;
    1cbc:	81 e0       	ldi	r24, 0x01	; 1
    1cbe:	36 c0       	rjmp	.+108    	; 0x1d2c <V2P_GetSetParamater+0xda>

			break;
		case PARAM_HARDWARE_VERSION:
		case PARAM_SW_MAJOR:
		case PARAM_SW_MINOR:
			PacketBytes[2] = pgm_read_byte(&VersionData[Param_Name - PARAM_HARDWARE_VERSION]);
    1cc0:	eb 5a       	subi	r30, 0xAB	; 171
    1cc2:	fc 4f       	sbci	r31, 0xFC	; 252
    1cc4:	84 91       	lpm	r24, Z
    1cc6:	32 c0       	rjmp	.+100    	; 0x1d2c <V2P_GetSetParamater+0xda>

			break;
		case PARAM_CONTROLLER_INIT:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1cc8:	80 91 34 01 	lds	r24, 0x0134
    1ccc:	83 30       	cpi	r24, 0x03	; 3
    1cce:	19 f4       	brne	.+6      	; 0x1cd6 <V2P_GetSetParamater+0x84>
			{
				PacketBytes[2] = Param_ControllerInit;
    1cd0:	80 91 2a 01 	lds	r24, 0x012A
    1cd4:	2b c0       	rjmp	.+86     	; 0x1d2c <V2P_GetSetParamater+0xda>
			}
			else
			{
				MessageSize = 2;
    1cd6:	82 e0       	ldi	r24, 0x02	; 2
    1cd8:	90 e0       	ldi	r25, 0x00	; 0
    1cda:	90 93 31 01 	sts	0x0131, r25
    1cde:	80 93 30 01 	sts	0x0130, r24
				Param_ControllerInit = PacketBytes[2];
    1ce2:	80 91 36 01 	lds	r24, 0x0136
    1ce6:	80 93 2a 01 	sts	0x012A, r24
			}
			
			break;
    1cea:	4a c0       	rjmp	.+148    	; 0x1d80 <V2P_GetSetParamater+0x12e>
		case PARAM_SCK_DURATION:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1cec:	80 91 34 01 	lds	r24, 0x0134
    1cf0:	83 30       	cpi	r24, 0x03	; 3
    1cf2:	19 f4       	brne	.+6      	; 0x1cfa <V2P_GetSetParamater+0xa8>
			{
				PacketBytes[2] = eeprom_read_byte_169(&Param_SCKDuration);
    1cf4:	80 e2       	ldi	r24, 0x20	; 32
    1cf6:	91 e0       	ldi	r25, 0x01	; 1
    1cf8:	17 c0       	rjmp	.+46     	; 0x1d28 <V2P_GetSetParamater+0xd6>
			}
			else
			{
				MessageSize = 2;
    1cfa:	82 e0       	ldi	r24, 0x02	; 2
    1cfc:	90 e0       	ldi	r25, 0x00	; 0
    1cfe:	90 93 31 01 	sts	0x0131, r25
    1d02:	80 93 30 01 	sts	0x0130, r24
				eeprom_write_byte_169(&Param_SCKDuration, PacketBytes[2]);
    1d06:	60 91 36 01 	lds	r22, 0x0136
    1d0a:	80 e2       	ldi	r24, 0x20	; 32
    1d0c:	91 e0       	ldi	r25, 0x01	; 1
    1d0e:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
				USI_SPISetSpeed(PacketBytes[2]); // Re-Initialise the USI system with the new frequency
    1d12:	80 91 36 01 	lds	r24, 0x0136
    1d16:	0e 94 72 09 	call	0x12e4 <USI_SPISetSpeed>
			}
					
			break;
    1d1a:	32 c0       	rjmp	.+100    	; 0x1d80 <V2P_GetSetParamater+0x12e>
		case PARAM_RESET_POLARITY:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1d1c:	80 91 34 01 	lds	r24, 0x0134
    1d20:	83 30       	cpi	r24, 0x03	; 3
    1d22:	39 f4       	brne	.+14     	; 0x1d32 <V2P_GetSetParamater+0xe0>
			{
				PacketBytes[2] = eeprom_read_byte_169(&Param_ResetPolarity);		
    1d24:	82 e2       	ldi	r24, 0x22	; 34
    1d26:	91 e0       	ldi	r25, 0x01	; 1
    1d28:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
    1d2c:	80 93 36 01 	sts	0x0136, r24
    1d30:	27 c0       	rjmp	.+78     	; 0x1d80 <V2P_GetSetParamater+0x12e>
			}
			else
			{
				MessageSize = 2;
    1d32:	82 e0       	ldi	r24, 0x02	; 2
    1d34:	90 e0       	ldi	r25, 0x00	; 0
    1d36:	90 93 31 01 	sts	0x0131, r25
    1d3a:	80 93 30 01 	sts	0x0130, r24
				eeprom_write_byte_169(&Param_ResetPolarity, PacketBytes[2]);
    1d3e:	60 91 36 01 	lds	r22, 0x0136
    1d42:	82 e2       	ldi	r24, 0x22	; 34
    1d44:	91 e0       	ldi	r25, 0x01	; 1
    1d46:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Change takes effect immediatly
    1d4a:	81 e0       	ldi	r24, 0x01	; 1
    1d4c:	0e 94 1b 03 	call	0x636 <MAIN_ResetCSLine>
			}
			
			break;
    1d50:	17 c0       	rjmp	.+46     	; 0x1d80 <V2P_GetSetParamater+0x12e>
		case PARAM_OSC_PSCALE:
		case PARAM_OSC_CMATCH:
			/* Despite not supporting these parameters (STK500 only), the AVR Studio programmer
			   sends them along with the SCK duration. A OK must be returned or the sequence will fail
			   and the SCK duration byte will not be sent.                                             */
		
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1d52:	80 91 34 01 	lds	r24, 0x0134
    1d56:	83 30       	cpi	r24, 0x03	; 3
    1d58:	19 f4       	brne	.+6      	; 0x1d60 <V2P_GetSetParamater+0x10e>
			{
			   PacketBytes[2] = 0;            // If the command is a read, return a 0 for both parameters
    1d5a:	10 92 36 01 	sts	0x0136, r1
    1d5e:	10 c0       	rjmp	.+32     	; 0x1d80 <V2P_GetSetParamater+0x12e>
			}
			else
			{
				MessageSize = 2;              // Otherwise just send back an OK if the command is a set		
    1d60:	82 e0       	ldi	r24, 0x02	; 2
    1d62:	90 e0       	ldi	r25, 0x00	; 0
    1d64:	90 93 31 01 	sts	0x0131, r25
    1d68:	80 93 30 01 	sts	0x0130, r24
			}
			
			break;
    1d6c:	09 c0       	rjmp	.+18     	; 0x1d80 <V2P_GetSetParamater+0x12e>
		default:                             // Unrecognised parameter
			MessageSize = 2;
    1d6e:	82 e0       	ldi	r24, 0x02	; 2
    1d70:	90 e0       	ldi	r25, 0x00	; 0
    1d72:	90 93 31 01 	sts	0x0131, r25
    1d76:	80 93 30 01 	sts	0x0130, r24
			PacketBytes[1] = STATUS_CMD_FAILED;			
    1d7a:	80 ec       	ldi	r24, 0xC0	; 192
    1d7c:	80 93 35 01 	sts	0x0135, r24
	}
	
	V2P_SendPacket();
    1d80:	0e 94 e9 0d 	call	0x1bd2 <V2P_SendPacket>
    1d84:	08 95       	ret

00001d86 <V2P_IncrementCurrAddress>:
}

void V2P_IncrementCurrAddress(void)
{
	// Incrementing a 32-bit unsigned variable takes a lot of code. Because much of the code is
	// not very time critical (much of it is waiting for the hardware), i've chosen to waste
	// a few extra cycles per increment and save a good 60 bytes or so of code space by putting
	// the incrmement inside a function.

	CurrAddress++;
    1d86:	80 91 2b 01 	lds	r24, 0x012B
    1d8a:	90 91 2c 01 	lds	r25, 0x012C
    1d8e:	a0 91 2d 01 	lds	r26, 0x012D
    1d92:	b0 91 2e 01 	lds	r27, 0x012E
    1d96:	01 96       	adiw	r24, 0x01	; 1
    1d98:	a1 1d       	adc	r26, r1
    1d9a:	b1 1d       	adc	r27, r1
    1d9c:	80 93 2b 01 	sts	0x012B, r24
    1da0:	90 93 2c 01 	sts	0x012C, r25
    1da4:	a0 93 2d 01 	sts	0x012D, r26
    1da8:	b0 93 2e 01 	sts	0x012E, r27
    1dac:	08 95       	ret

00001dae <V2P_CheckForExtendedAddress>:
}

void V2P_CheckForExtendedAddress(void)
{
	if (CurrAddress & (1UL << 31))                     // MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
    1dae:	80 91 2b 01 	lds	r24, 0x012B
    1db2:	90 91 2c 01 	lds	r25, 0x012C
    1db6:	a0 91 2d 01 	lds	r26, 0x012D
    1dba:	b0 91 2e 01 	lds	r27, 0x012E
    1dbe:	b7 ff       	sbrs	r27, 7
    1dc0:	1e c0       	rjmp	.+60     	; 0x1dfe <V2P_CheckForExtendedAddress+0x50>
	{
		USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);   // Load extended address command
    1dc2:	8d e4       	ldi	r24, 0x4D	; 77
    1dc4:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1dc8:	80 e0       	ldi	r24, 0x00	; 0
    1dca:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
		USI_SPITransmit((CurrAddress & 0x00FF0000) >> 16); // The 3rd byte of the long holds the extended address
    1dce:	80 91 2d 01 	lds	r24, 0x012D
    1dd2:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1dd6:	80 e0       	ldi	r24, 0x00	; 0
    1dd8:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
		
		CurrAddress &= ~(1UL << 31);                   // Clear the flag
    1ddc:	80 91 2b 01 	lds	r24, 0x012B
    1de0:	90 91 2c 01 	lds	r25, 0x012C
    1de4:	a0 91 2d 01 	lds	r26, 0x012D
    1de8:	b0 91 2e 01 	lds	r27, 0x012E
    1dec:	bf 77       	andi	r27, 0x7F	; 127
    1dee:	80 93 2b 01 	sts	0x012B, r24
    1df2:	90 93 2c 01 	sts	0x012C, r25
    1df6:	a0 93 2d 01 	sts	0x012D, r26
    1dfa:	b0 93 2e 01 	sts	0x012E, r27
    1dfe:	08 95       	ret

00001e00 <V2P_RunStateMachine>:
    1e00:	ef 92       	push	r14
    1e02:	ff 92       	push	r15
    1e04:	0f 93       	push	r16
    1e06:	1f 93       	push	r17
    1e08:	cf 93       	push	r28
    1e0a:	c0 e0       	ldi	r28, 0x00	; 0
    1e0c:	ee 24       	eor	r14, r14
    1e0e:	ff 24       	eor	r15, r15
    1e10:	80 91 c1 00 	lds	r24, 0x00C1
    1e14:	80 78       	andi	r24, 0x80	; 128
    1e16:	88 61       	ori	r24, 0x18	; 24
    1e18:	80 93 c1 00 	sts	0x00C1, r24
    1e1c:	0e 94 6f 0b 	call	0x16de <BUFF_InitialiseBuffer>
    1e20:	0e 94 e2 0b 	call	0x17c4 <TIMEOUT_SetupTimeoutTimer>
    1e24:	c0 93 2f 01 	sts	0x012F, r28
    1e28:	10 92 2b 01 	sts	0x012B, r1
    1e2c:	10 92 2c 01 	sts	0x012C, r1
    1e30:	10 92 2d 01 	sts	0x012D, r1
    1e34:	10 92 2e 01 	sts	0x012E, r1
    1e38:	80 91 28 01 	lds	r24, 0x0128
    1e3c:	81 30       	cpi	r24, 0x01	; 1
    1e3e:	11 f4       	brne	.+4      	; 0x1e44 <V2P_RunStateMachine+0x44>
    1e40:	c9 e0       	ldi	r28, 0x09	; 9
    1e42:	05 c0       	rjmp	.+10     	; 0x1e4e <V2P_RunStateMachine+0x4e>
    1e44:	cc 23       	and	r28, r28
    1e46:	19 f0       	breq	.+6      	; 0x1e4e <V2P_RunStateMachine+0x4e>
    1e48:	83 e0       	ldi	r24, 0x03	; 3
    1e4a:	80 93 81 00 	sts	0x0081, r24
    1e4e:	8c 2f       	mov	r24, r28
    1e50:	99 27       	eor	r25, r25
    1e52:	84 30       	cpi	r24, 0x04	; 4
    1e54:	91 05       	cpc	r25, r1
    1e56:	09 f4       	brne	.+2      	; 0x1e5a <V2P_RunStateMachine+0x5a>
    1e58:	6d c0       	rjmp	.+218    	; 0x1f34 <V2P_RunStateMachine+0x134>
    1e5a:	85 30       	cpi	r24, 0x05	; 5
    1e5c:	91 05       	cpc	r25, r1
    1e5e:	94 f4       	brge	.+36     	; 0x1e84 <V2P_RunStateMachine+0x84>
    1e60:	81 30       	cpi	r24, 0x01	; 1
    1e62:	91 05       	cpc	r25, r1
    1e64:	09 f4       	brne	.+2      	; 0x1e68 <V2P_RunStateMachine+0x68>
    1e66:	4c c0       	rjmp	.+152    	; 0x1f00 <V2P_RunStateMachine+0x100>
    1e68:	82 30       	cpi	r24, 0x02	; 2
    1e6a:	91 05       	cpc	r25, r1
    1e6c:	1c f4       	brge	.+6      	; 0x1e74 <V2P_RunStateMachine+0x74>
    1e6e:	89 2b       	or	r24, r25
    1e70:	b1 f1       	breq	.+108    	; 0x1ede <V2P_RunStateMachine+0xde>
    1e72:	e2 cf       	rjmp	.-60     	; 0x1e38 <V2P_RunStateMachine+0x38>
    1e74:	82 30       	cpi	r24, 0x02	; 2
    1e76:	91 05       	cpc	r25, r1
    1e78:	09 f4       	brne	.+2      	; 0x1e7c <V2P_RunStateMachine+0x7c>
    1e7a:	48 c0       	rjmp	.+144    	; 0x1f0c <V2P_RunStateMachine+0x10c>
    1e7c:	03 97       	sbiw	r24, 0x03	; 3
    1e7e:	09 f4       	brne	.+2      	; 0x1e82 <V2P_RunStateMachine+0x82>
    1e80:	4e c0       	rjmp	.+156    	; 0x1f1e <V2P_RunStateMachine+0x11e>
    1e82:	da cf       	rjmp	.-76     	; 0x1e38 <V2P_RunStateMachine+0x38>
    1e84:	87 30       	cpi	r24, 0x07	; 7
    1e86:	91 05       	cpc	r25, r1
    1e88:	09 f4       	brne	.+2      	; 0x1e8c <V2P_RunStateMachine+0x8c>
    1e8a:	85 c0       	rjmp	.+266    	; 0x1f96 <V2P_RunStateMachine+0x196>
    1e8c:	88 30       	cpi	r24, 0x08	; 8
    1e8e:	91 05       	cpc	r25, r1
    1e90:	44 f4       	brge	.+16     	; 0x1ea2 <V2P_RunStateMachine+0xa2>
    1e92:	85 30       	cpi	r24, 0x05	; 5
    1e94:	91 05       	cpc	r25, r1
    1e96:	09 f4       	brne	.+2      	; 0x1e9a <V2P_RunStateMachine+0x9a>
    1e98:	62 c0       	rjmp	.+196    	; 0x1f5e <V2P_RunStateMachine+0x15e>
    1e9a:	06 97       	sbiw	r24, 0x06	; 6
    1e9c:	09 f4       	brne	.+2      	; 0x1ea0 <V2P_RunStateMachine+0xa0>
    1e9e:	67 c0       	rjmp	.+206    	; 0x1f6e <V2P_RunStateMachine+0x16e>
    1ea0:	cb cf       	rjmp	.-106    	; 0x1e38 <V2P_RunStateMachine+0x38>
    1ea2:	88 30       	cpi	r24, 0x08	; 8
    1ea4:	91 05       	cpc	r25, r1
    1ea6:	79 f0       	breq	.+30     	; 0x1ec6 <V2P_RunStateMachine+0xc6>
    1ea8:	09 97       	sbiw	r24, 0x09	; 9
    1eaa:	31 f6       	brne	.-116    	; 0x1e38 <V2P_RunStateMachine+0x38>
    1eac:	82 e0       	ldi	r24, 0x02	; 2
    1eae:	90 e0       	ldi	r25, 0x00	; 0
    1eb0:	90 93 31 01 	sts	0x0131, r25
    1eb4:	80 93 30 01 	sts	0x0130, r24
    1eb8:	80 ec       	ldi	r24, 0xC0	; 192
    1eba:	80 93 35 01 	sts	0x0135, r24
    1ebe:	10 92 28 01 	sts	0x0128, r1
    1ec2:	0e 94 e9 0d 	call	0x1bd2 <V2P_SendPacket>
    1ec6:	0e 94 6f 0b 	call	0x16de <BUFF_InitialiseBuffer>
    1eca:	10 92 81 00 	sts	0x0081, r1
    1ece:	10 92 29 01 	sts	0x0129, r1
    1ed2:	10 92 85 00 	sts	0x0085, r1
    1ed6:	10 92 84 00 	sts	0x0084, r1
    1eda:	c0 e0       	ldi	r28, 0x00	; 0
    1edc:	ad cf       	rjmp	.-166    	; 0x1e38 <V2P_RunStateMachine+0x38>
    1ede:	80 91 d1 02 	lds	r24, 0x02D1
    1ee2:	81 11       	cpse	r24, r1
    1ee4:	c1 e0       	ldi	r28, 0x01	; 1
    1ee6:	f2 9b       	sbis	0x1e, 2	; 30
    1ee8:	a7 cf       	rjmp	.-178    	; 0x1e38 <V2P_RunStateMachine+0x38>
    1eea:	80 91 2f 01 	lds	r24, 0x012F
    1eee:	88 23       	and	r24, r24
    1ef0:	09 f0       	breq	.+2      	; 0x1ef4 <V2P_RunStateMachine+0xf4>
    1ef2:	a2 cf       	rjmp	.-188    	; 0x1e38 <V2P_RunStateMachine+0x38>
    1ef4:	80 91 c1 00 	lds	r24, 0x00C1
    1ef8:	80 78       	andi	r24, 0x80	; 128
    1efa:	80 93 c1 00 	sts	0x00C1, r24
    1efe:	fb c0       	rjmp	.+502    	; 0x20f6 <V2P_RunStateMachine+0x2f6>
    1f00:	0e 94 06 09 	call	0x120c <USART_Rx>
    1f04:	8b 31       	cpi	r24, 0x1B	; 27
    1f06:	89 f5       	brne	.+98     	; 0x1f6a <V2P_RunStateMachine+0x16a>
    1f08:	c2 e0       	ldi	r28, 0x02	; 2
    1f0a:	96 cf       	rjmp	.-212    	; 0x1e38 <V2P_RunStateMachine+0x38>
    1f0c:	0e 94 06 09 	call	0x120c <USART_Rx>
    1f10:	99 27       	eor	r25, r25
    1f12:	90 93 33 01 	sts	0x0133, r25
    1f16:	80 93 32 01 	sts	0x0132, r24
    1f1a:	c3 e0       	ldi	r28, 0x03	; 3
    1f1c:	8d cf       	rjmp	.-230    	; 0x1e38 <V2P_RunStateMachine+0x38>
    1f1e:	0e 94 06 09 	call	0x120c <USART_Rx>
    1f22:	99 27       	eor	r25, r25
    1f24:	98 2f       	mov	r25, r24
    1f26:	88 27       	eor	r24, r24
    1f28:	90 93 31 01 	sts	0x0131, r25
    1f2c:	80 93 30 01 	sts	0x0130, r24
    1f30:	c4 e0       	ldi	r28, 0x04	; 4
    1f32:	82 cf       	rjmp	.-252    	; 0x1e38 <V2P_RunStateMachine+0x38>
    1f34:	0e 94 06 09 	call	0x120c <USART_Rx>
    1f38:	28 2f       	mov	r18, r24
    1f3a:	33 27       	eor	r19, r19
    1f3c:	80 91 30 01 	lds	r24, 0x0130
    1f40:	90 91 31 01 	lds	r25, 0x0131
    1f44:	82 2b       	or	r24, r18
    1f46:	93 2b       	or	r25, r19
    1f48:	90 93 31 01 	sts	0x0131, r25
    1f4c:	80 93 30 01 	sts	0x0130, r24
    1f50:	83 51       	subi	r24, 0x13	; 19
    1f52:	91 40       	sbci	r25, 0x01	; 1
    1f54:	50 f4       	brcc	.+20     	; 0x1f6a <V2P_RunStateMachine+0x16a>
    1f56:	c5 e0       	ldi	r28, 0x05	; 5
    1f58:	ee 24       	eor	r14, r14
    1f5a:	ff 24       	eor	r15, r15
    1f5c:	6d cf       	rjmp	.-294    	; 0x1e38 <V2P_RunStateMachine+0x38>
    1f5e:	0e 94 06 09 	call	0x120c <USART_Rx>
    1f62:	8e 30       	cpi	r24, 0x0E	; 14
    1f64:	11 f4       	brne	.+4      	; 0x1f6a <V2P_RunStateMachine+0x16a>
    1f66:	c6 e0       	ldi	r28, 0x06	; 6
    1f68:	67 cf       	rjmp	.-306    	; 0x1e38 <V2P_RunStateMachine+0x38>
    1f6a:	c9 e0       	ldi	r28, 0x09	; 9
    1f6c:	65 cf       	rjmp	.-310    	; 0x1e38 <V2P_RunStateMachine+0x38>
    1f6e:	80 91 30 01 	lds	r24, 0x0130
    1f72:	90 91 31 01 	lds	r25, 0x0131
    1f76:	e8 16       	cp	r14, r24
    1f78:	f9 06       	cpc	r15, r25
    1f7a:	11 f4       	brne	.+4      	; 0x1f80 <V2P_RunStateMachine+0x180>
    1f7c:	c7 e0       	ldi	r28, 0x07	; 7
    1f7e:	5c cf       	rjmp	.-328    	; 0x1e38 <V2P_RunStateMachine+0x38>
    1f80:	87 01       	movw	r16, r14
    1f82:	0c 5c       	subi	r16, 0xCC	; 204
    1f84:	1e 4f       	sbci	r17, 0xFE	; 254
    1f86:	08 94       	sec
    1f88:	e1 1c       	adc	r14, r1
    1f8a:	f1 1c       	adc	r15, r1
    1f8c:	0e 94 06 09 	call	0x120c <USART_Rx>
    1f90:	f8 01       	movw	r30, r16
    1f92:	80 83       	st	Z, r24
    1f94:	51 cf       	rjmp	.-350    	; 0x1e38 <V2P_RunStateMachine+0x38>
    1f96:	0e 94 c8 0d 	call	0x1b90 <V2P_GetChecksum>
    1f9a:	18 2f       	mov	r17, r24
    1f9c:	0e 94 06 09 	call	0x120c <USART_Rx>
    1fa0:	18 17       	cp	r17, r24
    1fa2:	09 f0       	breq	.+2      	; 0x1fa6 <V2P_RunStateMachine+0x1a6>
    1fa4:	9b c0       	rjmp	.+310    	; 0x20dc <V2P_RunStateMachine+0x2dc>
    1fa6:	80 91 34 01 	lds	r24, 0x0134
    1faa:	99 27       	eor	r25, r25
    1fac:	84 30       	cpi	r24, 0x04	; 4
    1fae:	91 05       	cpc	r25, r1
    1fb0:	3c f4       	brge	.+14     	; 0x1fc0 <V2P_RunStateMachine+0x1c0>
    1fb2:	82 30       	cpi	r24, 0x02	; 2
    1fb4:	91 05       	cpc	r25, r1
    1fb6:	0c f0       	brlt	.+2      	; 0x1fba <V2P_RunStateMachine+0x1ba>
    1fb8:	88 c0       	rjmp	.+272    	; 0x20ca <V2P_RunStateMachine+0x2ca>
    1fba:	01 97       	sbiw	r24, 0x01	; 1
    1fbc:	39 f0       	breq	.+14     	; 0x1fcc <V2P_RunStateMachine+0x1cc>
    1fbe:	88 c0       	rjmp	.+272    	; 0x20d0 <V2P_RunStateMachine+0x2d0>
    1fc0:	86 30       	cpi	r24, 0x06	; 6
    1fc2:	91 05       	cpc	r25, r1
    1fc4:	e9 f0       	breq	.+58     	; 0x2000 <V2P_RunStateMachine+0x200>
    1fc6:	07 97       	sbiw	r24, 0x07	; 7
    1fc8:	99 f0       	breq	.+38     	; 0x1ff0 <V2P_RunStateMachine+0x1f0>
    1fca:	82 c0       	rjmp	.+260    	; 0x20d0 <V2P_RunStateMachine+0x2d0>
    1fcc:	8b e0       	ldi	r24, 0x0B	; 11
    1fce:	90 e0       	ldi	r25, 0x00	; 0
    1fd0:	90 93 31 01 	sts	0x0131, r25
    1fd4:	80 93 30 01 	sts	0x0130, r24
    1fd8:	a4 e3       	ldi	r26, 0x34	; 52
    1fda:	b1 e0       	ldi	r27, 0x01	; 1
    1fdc:	ea ed       	ldi	r30, 0xDA	; 218
    1fde:	f3 e0       	ldi	r31, 0x03	; 3
    1fe0:	9a e0       	ldi	r25, 0x0A	; 10
    1fe2:	84 91       	lpm	r24, Z
    1fe4:	8d 93       	st	X+, r24
    1fe6:	91 50       	subi	r25, 0x01	; 1
    1fe8:	31 96       	adiw	r30, 0x01	; 1
    1fea:	97 ff       	sbrs	r25, 7
    1fec:	fa cf       	rjmp	.-12     	; 0x1fe2 <V2P_RunStateMachine+0x1e2>
    1fee:	7f c0       	rjmp	.+254    	; 0x20ee <V2P_RunStateMachine+0x2ee>
    1ff0:	82 e0       	ldi	r24, 0x02	; 2
    1ff2:	90 e0       	ldi	r25, 0x00	; 0
    1ff4:	90 93 31 01 	sts	0x0131, r25
    1ff8:	80 93 30 01 	sts	0x0130, r24
    1ffc:	80 ec       	ldi	r24, 0xC0	; 192
    1ffe:	75 c0       	rjmp	.+234    	; 0x20ea <V2P_RunStateMachine+0x2ea>
    2000:	82 e0       	ldi	r24, 0x02	; 2
    2002:	90 e0       	ldi	r25, 0x00	; 0
    2004:	90 93 31 01 	sts	0x0131, r25
    2008:	80 93 30 01 	sts	0x0130, r24
    200c:	0e 94 d7 0e 	call	0x1dae <V2P_CheckForExtendedAddress>
    2010:	80 91 35 01 	lds	r24, 0x0135
    2014:	99 27       	eor	r25, r25
    2016:	aa 27       	eor	r26, r26
    2018:	bb 27       	eor	r27, r27
    201a:	b8 2f       	mov	r27, r24
    201c:	aa 27       	eor	r26, r26
    201e:	99 27       	eor	r25, r25
    2020:	88 27       	eor	r24, r24
    2022:	20 91 36 01 	lds	r18, 0x0136
    2026:	33 27       	eor	r19, r19
    2028:	44 27       	eor	r20, r20
    202a:	55 27       	eor	r21, r21
    202c:	a9 01       	movw	r20, r18
    202e:	33 27       	eor	r19, r19
    2030:	22 27       	eor	r18, r18
    2032:	82 2b       	or	r24, r18
    2034:	93 2b       	or	r25, r19
    2036:	a4 2b       	or	r26, r20
    2038:	b5 2b       	or	r27, r21
    203a:	20 91 37 01 	lds	r18, 0x0137
    203e:	33 27       	eor	r19, r19
    2040:	44 27       	eor	r20, r20
    2042:	55 27       	eor	r21, r21
    2044:	54 2f       	mov	r21, r20
    2046:	43 2f       	mov	r20, r19
    2048:	32 2f       	mov	r19, r18
    204a:	22 27       	eor	r18, r18
    204c:	82 2b       	or	r24, r18
    204e:	93 2b       	or	r25, r19
    2050:	a4 2b       	or	r26, r20
    2052:	b5 2b       	or	r27, r21
    2054:	20 91 38 01 	lds	r18, 0x0138
    2058:	33 27       	eor	r19, r19
    205a:	44 27       	eor	r20, r20
    205c:	55 27       	eor	r21, r21
    205e:	82 2b       	or	r24, r18
    2060:	93 2b       	or	r25, r19
    2062:	a4 2b       	or	r26, r20
    2064:	b5 2b       	or	r27, r21
    2066:	80 93 2b 01 	sts	0x012B, r24
    206a:	90 93 2c 01 	sts	0x012C, r25
    206e:	a0 93 2d 01 	sts	0x012D, r26
    2072:	b0 93 2e 01 	sts	0x012E, r27
    2076:	80 91 49 02 	lds	r24, 0x0249
    207a:	81 30       	cpi	r24, 0x01	; 1
    207c:	99 f4       	brne	.+38     	; 0x20a4 <V2P_RunStateMachine+0x2a4>
    207e:	80 91 8b 02 	lds	r24, 0x028B
    2082:	90 91 8c 02 	lds	r25, 0x028C
    2086:	0e 94 24 0b 	call	0x1648 <DF_CopyBufferToFlashPage>
    208a:	80 91 8b 02 	lds	r24, 0x028B
    208e:	90 91 8c 02 	lds	r25, 0x028C
    2092:	0e 94 ee 0a 	call	0x15dc <DF_CopyFlashPageToBuffer>
    2096:	80 91 84 02 	lds	r24, 0x0284
    209a:	90 91 85 02 	lds	r25, 0x0285
    209e:	0e 94 5e 0a 	call	0x14bc <DF_BufferWriteEnable>
    20a2:	10 c0       	rjmp	.+32     	; 0x20c4 <V2P_RunStateMachine+0x2c4>
    20a4:	82 30       	cpi	r24, 0x02	; 2
    20a6:	71 f4       	brne	.+28     	; 0x20c4 <V2P_RunStateMachine+0x2c4>
    20a8:	80 91 4a 02 	lds	r24, 0x024A
    20ac:	0e 94 f8 13 	call	0x27f0 <PM_SetupDFAddressCounters>
    20b0:	60 91 84 02 	lds	r22, 0x0284
    20b4:	70 91 85 02 	lds	r23, 0x0285
    20b8:	80 91 8b 02 	lds	r24, 0x028B
    20bc:	90 91 8c 02 	lds	r25, 0x028C
    20c0:	0e 94 1b 0a 	call	0x1436 <DF_ContinuousReadEnable>
    20c4:	10 92 35 01 	sts	0x0135, r1
    20c8:	12 c0       	rjmp	.+36     	; 0x20ee <V2P_RunStateMachine+0x2ee>
    20ca:	0e 94 29 0e 	call	0x1c52 <V2P_GetSetParamater>
    20ce:	11 c0       	rjmp	.+34     	; 0x20f2 <V2P_RunStateMachine+0x2f2>
    20d0:	e0 91 24 01 	lds	r30, 0x0124
    20d4:	f0 91 25 01 	lds	r31, 0x0125
    20d8:	09 95       	icall
    20da:	0b c0       	rjmp	.+22     	; 0x20f2 <V2P_RunStateMachine+0x2f2>
    20dc:	82 e0       	ldi	r24, 0x02	; 2
    20de:	90 e0       	ldi	r25, 0x00	; 0
    20e0:	90 93 31 01 	sts	0x0131, r25
    20e4:	80 93 30 01 	sts	0x0130, r24
    20e8:	81 ec       	ldi	r24, 0xC1	; 193
    20ea:	80 93 35 01 	sts	0x0135, r24
    20ee:	0e 94 e9 0d 	call	0x1bd2 <V2P_SendPacket>
    20f2:	c8 e0       	ldi	r28, 0x08	; 8
    20f4:	a1 ce       	rjmp	.-702    	; 0x1e38 <V2P_RunStateMachine+0x38>
    20f6:	cf 91       	pop	r28
    20f8:	1f 91       	pop	r17
    20fa:	0f 91       	pop	r16
    20fc:	ff 90       	pop	r15
    20fe:	ef 90       	pop	r14
    2100:	08 95       	ret

00002102 <ISPCC_EnterChipProgrammingMode>:

// ======================================================================================

void ISPCC_EnterChipProgrammingMode(void)
{
    2102:	0f 93       	push	r16
    2104:	1f 93       	push	r17
    2106:	cf 93       	push	r28
	uint8_t ByteDelay = PacketBytes[5];
    2108:	10 91 39 01 	lds	r17, 0x0139
	uint8_t Attempts  = PacketBytes[4];
    210c:	c0 91 38 01 	lds	r28, 0x0138
	uint8_t Response;

	MAIN_Delay1MS(PacketBytes[2]);         // Wait before continuing, amount specified in the packet
    2110:	80 91 36 01 	lds	r24, 0x0136
    2114:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>

	if ((!(Attempts)) || (Attempts > 100)) // Safety - if no attempts or too high a value is specified, a fixed number is chosen
    2118:	8c 2f       	mov	r24, r28
    211a:	81 50       	subi	r24, 0x01	; 1
    211c:	84 36       	cpi	r24, 0x64	; 100
    211e:	08 f0       	brcs	.+2      	; 0x2122 <ISPCC_EnterChipProgrammingMode+0x20>
	   Attempts = 24;
    2120:	c8 e1       	ldi	r28, 0x18	; 24
		
	while (Attempts--)
	{
		USI_SPITransmit(PacketBytes[8]);
		MAIN_Delay1MS(ByteDelay);
		USI_SPITransmit(PacketBytes[9]);
		MAIN_Delay1MS(ByteDelay);
			
		Response = USI_SPITransmit(PacketBytes[10]);
		MAIN_Delay1MS(ByteDelay);

		if(PacketBytes[7] == ISPCC_POLL_MODE_AVR)
		  USI_SPITransmit(PacketBytes[11]);
		else
		  Response = USI_SPITransmit(PacketBytes[11]);
				
		if(!(PacketBytes[7]) || (Response == PacketBytes[6])) // Polling disabled, or returned value matches expected poll value
		{
			MAIN_Delay1MS(ByteDelay);

			InProgrammingMode = TRUE;
			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = STATUS_CMD_OK;
			return;
		}
		
		MAIN_Delay1MS(ByteDelay);
		USI_SPIToggleClock();            // Out of sync, shift in one bit and try again
    2122:	c1 50       	subi	r28, 0x01	; 1
    2124:	cf 3f       	cpi	r28, 0xFF	; 255
    2126:	09 f4       	brne	.+2      	; 0x212a <ISPCC_EnterChipProgrammingMode+0x28>
    2128:	3f c0       	rjmp	.+126    	; 0x21a8 <ISPCC_EnterChipProgrammingMode+0xa6>
    212a:	80 91 3c 01 	lds	r24, 0x013C
    212e:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    2132:	81 2f       	mov	r24, r17
    2134:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    2138:	80 91 3d 01 	lds	r24, 0x013D
    213c:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    2140:	81 2f       	mov	r24, r17
    2142:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    2146:	80 91 3e 01 	lds	r24, 0x013E
    214a:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    214e:	08 2f       	mov	r16, r24
    2150:	81 2f       	mov	r24, r17
    2152:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    2156:	80 91 3b 01 	lds	r24, 0x013B
    215a:	83 30       	cpi	r24, 0x03	; 3
    215c:	29 f4       	brne	.+10     	; 0x2168 <ISPCC_EnterChipProgrammingMode+0x66>
    215e:	80 91 3f 01 	lds	r24, 0x013F
    2162:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    2166:	05 c0       	rjmp	.+10     	; 0x2172 <ISPCC_EnterChipProgrammingMode+0x70>
    2168:	80 91 3f 01 	lds	r24, 0x013F
    216c:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    2170:	08 2f       	mov	r16, r24
    2172:	80 91 3b 01 	lds	r24, 0x013B
    2176:	88 23       	and	r24, r24
    2178:	21 f0       	breq	.+8      	; 0x2182 <ISPCC_EnterChipProgrammingMode+0x80>
    217a:	80 91 3a 01 	lds	r24, 0x013A
    217e:	08 17       	cp	r16, r24
    2180:	69 f4       	brne	.+26     	; 0x219c <ISPCC_EnterChipProgrammingMode+0x9a>
    2182:	81 2f       	mov	r24, r17
    2184:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    2188:	81 e0       	ldi	r24, 0x01	; 1
    218a:	80 93 2f 01 	sts	0x012F, r24
    218e:	81 b3       	in	r24, 0x11	; 17
    2190:	8f 7c       	andi	r24, 0xCF	; 207
    2192:	80 62       	ori	r24, 0x20	; 32
    2194:	81 bb       	out	0x11, r24	; 17
    2196:	10 92 35 01 	sts	0x0135, r1
    219a:	0d c0       	rjmp	.+26     	; 0x21b6 <ISPCC_EnterChipProgrammingMode+0xb4>
    219c:	81 2f       	mov	r24, r17
    219e:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    21a2:	0e 94 c8 09 	call	0x1390 <USI_SPIToggleClock>
    21a6:	bd cf       	rjmp	.-134    	; 0x2122 <ISPCC_EnterChipProgrammingMode+0x20>
	}

	// If function hasn't returned by now, all the attempts have failed. Show this by
	// resetting the status leds to green (ready) and send a fail message.

	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
    21a8:	81 b3       	in	r24, 0x11	; 17
    21aa:	8f 7c       	andi	r24, 0xCF	; 207
    21ac:	80 61       	ori	r24, 0x10	; 16
    21ae:	81 bb       	out	0x11, r24	; 17
	PacketBytes[1] = STATUS_CMD_FAILED;
    21b0:	80 ec       	ldi	r24, 0xC0	; 192
    21b2:	80 93 35 01 	sts	0x0135, r24
    21b6:	cf 91       	pop	r28
    21b8:	1f 91       	pop	r17
    21ba:	0f 91       	pop	r16
    21bc:	08 95       	ret

000021be <ISPCC_PollForProgComplete>:
}

void ISPCC_ProgramChip(void)
{
	uint16_t PollAddress  = 0;
	uint8_t  ProgMode     = PacketBytes[3];
	uint8_t  WriteCommand = PacketBytes[5];
	uint16_t StartAddress = (uint16_t)CurrAddress;
	uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
	                      | PacketBytes[2];
	uint8_t  PollType;
	uint8_t  ByteToWrite;
			
	if (ProgMode & ISPCC_PROG_MODE_PAGE)                 // Page writing mode
	{
		for (uint16_t WriteByte = 0; WriteByte < BytesToWrite; WriteByte++) // Transmit the page bytes
		{
			ByteToWrite = PacketBytes[10 + WriteByte];
		
			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) // Flash write mode - word addresses so MSB/LSB masking 
			   USI_SPITransmit(WriteCommand | ((WriteByte & 0x01)? ISPCC_HIGH_BYTE_WRITE : ISPCC_LOW_BYTE_WRITE));
			else                                         // EEPROM write mode - byte addresses so no masking 
			   USI_SPITransmit(WriteCommand);

			USI_SPITransmitWord(CurrAddress & 0xFFFF);    // Only the LSW of the address should be sent
			USI_SPITransmit(ByteToWrite);                 // Send one of the new bytes to be written

			if (!(PollAddress))
			{
				if ((PacketBytes[8] != ByteToWrite)       // Can do polling
				   && ((PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) || ((PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP) && (PacketBytes[9] != ByteToWrite))))
				{
					PollAddress = (CurrAddress & 0xFFFF); // Save the current address
				
					if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
					   PollAddress = ((PollAddress << 1) + (WriteByte & 0x01));
				}
			}

			// Flash addresses are in words; only increment address on odd byte, OR if it's the EEPROM being programmed (byte addresses)
			if ((WriteByte & 0x01) || (PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP))
			   V2P_IncrementCurrAddress();
		}

		PollType = ProgMode;

		if (ProgMode & ISPCC_PROG_MODE_PAGEDONE)         // If this packet is the end of a page, we need to send the program page command
		{
			USI_SPITransmit(PacketBytes[6]);             // Send the write program memory page command
			USI_SPITransmitWord(StartAddress);           // Send the page address word
			USI_SPITransmit(0x00);

			if (!(PollAddress))                          // No polling address
			   PollType = ((ProgMode & ~ISPCC_PAGE_POLLTYPE_MASK) | ISPCC_PAGE_POLLTYPE_WAIT);

			ISPCC_PollForProgComplete(PollType, PollAddress);
		}
	}
	else                                                 // Flash Word writing mode or EEPROM byte writing mode
	{
		for (uint16_t WriteByte = 0; WriteByte < BytesToWrite; WriteByte++)
		{
			ByteToWrite = PacketBytes[10 + WriteByte];

			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
			   USI_SPITransmit(WriteCommand | ((WriteByte & 0x01)? ISPCC_HIGH_BYTE_WRITE : ISPCC_LOW_BYTE_WRITE));
			else
			   USI_SPITransmit(WriteCommand);					
					
			USI_SPITransmitWord(CurrAddress & 0xFFFF);    // Transmit the current address to the slave AVR
			USI_SPITransmit(ByteToWrite);                 // Send one of the new bytes to be written

			PollType = ProgMode;

			if ((PacketBytes[8] != ByteToWrite)           // Can do polling
			   && ((PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) || ((PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP) && (PacketBytes[9] != ByteToWrite))))
			{
				PollAddress = (CurrAddress & 0xFFFF);     // Save the current address;

				if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
				   PollAddress = ((PollAddress << 1) + (WriteByte & 0x01));
			}
			else
			{
				PollType = ((ProgMode & ~ISPCC_WORD_POLLTYPE_MASK) | ISPCC_WORD_POLLTYPE_WAIT);
			}					

			// Flash addresses are in words; only increment address on the odd byte, OR if it's the EEPROM being programmed (byte addresses)
			if ((WriteByte & 0x01) || (PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP))
			   V2P_IncrementCurrAddress();

			ISPCC_PollForProgComplete(PollType, PollAddress);
		}
	}
}

void ISPCC_PollForProgComplete(uint8_t PollData, uint16_t PollAddr)
{
    21be:	1f 93       	push	r17
    21c0:	cf 93       	push	r28
    21c2:	df 93       	push	r29
    21c4:	eb 01       	movw	r28, r22
	uint8_t PollType;
	uint8_t ProgCommand;

	if (PollData & ISPCC_PROG_MODE_PAGE)
    21c6:	99 27       	eor	r25, r25
    21c8:	80 ff       	sbrs	r24, 0
    21ca:	08 c0       	rjmp	.+16     	; 0x21dc <ISPCC_PollForProgComplete+0x1e>
	   PollType = ((PollData & ISPCC_PAGE_POLLTYPE_MASK) >> ISPCC_PAGE_POLLTYPE_MASKSHIFT);
    21cc:	80 77       	andi	r24, 0x70	; 112
    21ce:	90 70       	andi	r25, 0x00	; 0
    21d0:	34 e0       	ldi	r19, 0x04	; 4
    21d2:	95 95       	asr	r25
    21d4:	87 95       	ror	r24
    21d6:	3a 95       	dec	r19
    21d8:	e1 f7       	brne	.-8      	; 0x21d2 <ISPCC_PollForProgComplete+0x14>
    21da:	04 c0       	rjmp	.+8      	; 0x21e4 <ISPCC_PollForProgComplete+0x26>
	else
	   PollType = ((PollData & ISPCC_WORD_POLLTYPE_MASK) >> ISPCC_WORD_POLLTYPE_MASKSHIFT);	
    21dc:	8e 70       	andi	r24, 0x0E	; 14
    21de:	90 70       	andi	r25, 0x00	; 0
    21e0:	95 95       	asr	r25
    21e2:	87 95       	ror	r24

	switch (PollType & ISPCC_POLLTYPE_MASK)
    21e4:	99 27       	eor	r25, r25
    21e6:	87 70       	andi	r24, 0x07	; 7
    21e8:	90 70       	andi	r25, 0x00	; 0
    21ea:	82 30       	cpi	r24, 0x02	; 2
    21ec:	91 05       	cpc	r25, r1
    21ee:	19 f0       	breq	.+6      	; 0x21f6 <ISPCC_PollForProgComplete+0x38>
    21f0:	04 97       	sbiw	r24, 0x04	; 4
    21f2:	e1 f0       	breq	.+56     	; 0x222c <ISPCC_PollForProgComplete+0x6e>
    21f4:	26 c0       	rjmp	.+76     	; 0x2242 <ISPCC_PollForProgComplete+0x84>
	{
		case ISPCC_POLLTYPE_DATA:
			ProgCommand = PacketBytes[7];
    21f6:	10 91 3b 01 	lds	r17, 0x013B
			
			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) // Flash uses word addresses
    21fa:	80 91 34 01 	lds	r24, 0x0134
    21fe:	83 31       	cpi	r24, 0x13	; 19
    2200:	39 f4       	brne	.+14     	; 0x2210 <ISPCC_PollForProgComplete+0x52>
			{
				ProgCommand  |= ((PollAddr & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ);
    2202:	81 2f       	mov	r24, r17
    2204:	99 27       	eor	r25, r25
    2206:	c0 fd       	sbrc	r28, 0
    2208:	88 60       	ori	r24, 0x08	; 8
    220a:	18 2f       	mov	r17, r24
				PollAddr    >>= 1;
    220c:	d6 95       	lsr	r29
    220e:	c7 95       	ror	r28
			}

			do
			{
				USI_SPITransmit(ProgCommand);
    2210:	81 2f       	mov	r24, r17
    2212:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
				USI_SPITransmitWord(PollAddr);
    2216:	ce 01       	movw	r24, r28
    2218:	0e 94 ba 09 	call	0x1374 <USI_SPITransmitWord>
			}
    221c:	80 e0       	ldi	r24, 0x00	; 0
    221e:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    2222:	90 91 3c 01 	lds	r25, 0x013C
    2226:	89 17       	cp	r24, r25
    2228:	99 f3       	breq	.-26     	; 0x2210 <ISPCC_PollForProgComplete+0x52>
			while (USI_SPITransmit(0x00) == PacketBytes[8]);
						
			break;
    222a:	0f c0       	rjmp	.+30     	; 0x224a <ISPCC_PollForProgComplete+0x8c>
		case ISPCC_POLLTYPE_READY:
			do
			   USI_SPITransmitWord(0xF000);
    222c:	80 e0       	ldi	r24, 0x00	; 0
    222e:	90 ef       	ldi	r25, 0xF0	; 240
    2230:	0e 94 ba 09 	call	0x1374 <USI_SPITransmitWord>
    2234:	80 e0       	ldi	r24, 0x00	; 0
    2236:	90 e0       	ldi	r25, 0x00	; 0
    2238:	0e 94 ba 09 	call	0x1374 <USI_SPITransmitWord>
    223c:	80 fd       	sbrc	r24, 0
    223e:	f6 cf       	rjmp	.-20     	; 0x222c <ISPCC_PollForProgComplete+0x6e>
			while (USI_SPITransmitWord(0x0000) & ISPCC_POLL_BUSYFLAG);

			break;
    2240:	04 c0       	rjmp	.+8      	; 0x224a <ISPCC_PollForProgComplete+0x8c>
		default:                                      // Default is Wait polling
			MAIN_Delay1MS(PacketBytes[4]);	
    2242:	80 91 38 01 	lds	r24, 0x0138
    2246:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    224a:	df 91       	pop	r29
    224c:	cf 91       	pop	r28
    224e:	1f 91       	pop	r17
    2250:	08 95       	ret

00002252 <ISPCC_ProgramChip>:
    2252:	6f 92       	push	r6
    2254:	7f 92       	push	r7
    2256:	9f 92       	push	r9
    2258:	af 92       	push	r10
    225a:	bf 92       	push	r11
    225c:	cf 92       	push	r12
    225e:	df 92       	push	r13
    2260:	ef 92       	push	r14
    2262:	ff 92       	push	r15
    2264:	0f 93       	push	r16
    2266:	1f 93       	push	r17
    2268:	cf 93       	push	r28
    226a:	df 93       	push	r29
    226c:	00 e0       	ldi	r16, 0x00	; 0
    226e:	10 e0       	ldi	r17, 0x00	; 0
    2270:	90 90 37 01 	lds	r9, 0x0137
    2274:	c0 90 39 01 	lds	r12, 0x0139
    2278:	60 90 2b 01 	lds	r6, 0x012B
    227c:	70 90 2c 01 	lds	r7, 0x012C
    2280:	80 91 35 01 	lds	r24, 0x0135
    2284:	99 27       	eor	r25, r25
    2286:	b8 2e       	mov	r11, r24
    2288:	aa 24       	eor	r10, r10
    228a:	80 91 36 01 	lds	r24, 0x0136
    228e:	99 27       	eor	r25, r25
    2290:	a8 2a       	or	r10, r24
    2292:	b9 2a       	or	r11, r25
    2294:	90 fe       	sbrs	r9, 0
    2296:	62 c0       	rjmp	.+196    	; 0x235c <ISPCC_ProgramChip+0x10a>
    2298:	78 01       	movw	r14, r16
    229a:	0a 15       	cp	r16, r10
    229c:	1b 05       	cpc	r17, r11
    229e:	08 f0       	brcs	.+2      	; 0x22a2 <ISPCC_ProgramChip+0x50>
    22a0:	46 c0       	rjmp	.+140    	; 0x232e <ISPCC_ProgramChip+0xdc>
    22a2:	ce e3       	ldi	r28, 0x3E	; 62
    22a4:	d1 e0       	ldi	r29, 0x01	; 1
    22a6:	d9 90       	ld	r13, Y+
    22a8:	80 91 34 01 	lds	r24, 0x0134
    22ac:	83 31       	cpi	r24, 0x13	; 19
    22ae:	31 f4       	brne	.+12     	; 0x22bc <ISPCC_ProgramChip+0x6a>
    22b0:	8c 2d       	mov	r24, r12
    22b2:	99 27       	eor	r25, r25
    22b4:	e0 fe       	sbrs	r14, 0
    22b6:	03 c0       	rjmp	.+6      	; 0x22be <ISPCC_ProgramChip+0x6c>
    22b8:	88 60       	ori	r24, 0x08	; 8
    22ba:	01 c0       	rjmp	.+2      	; 0x22be <ISPCC_ProgramChip+0x6c>
    22bc:	8c 2d       	mov	r24, r12
    22be:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    22c2:	80 91 2b 01 	lds	r24, 0x012B
    22c6:	90 91 2c 01 	lds	r25, 0x012C
    22ca:	0e 94 ba 09 	call	0x1374 <USI_SPITransmitWord>
    22ce:	8d 2d       	mov	r24, r13
    22d0:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    22d4:	01 15       	cp	r16, r1
    22d6:	11 05       	cpc	r17, r1
    22d8:	d9 f4       	brne	.+54     	; 0x2310 <ISPCC_ProgramChip+0xbe>
    22da:	80 91 3c 01 	lds	r24, 0x013C
    22de:	8d 15       	cp	r24, r13
    22e0:	b9 f0       	breq	.+46     	; 0x2310 <ISPCC_ProgramChip+0xbe>
    22e2:	90 91 34 01 	lds	r25, 0x0134
    22e6:	93 31       	cpi	r25, 0x13	; 19
    22e8:	31 f0       	breq	.+12     	; 0x22f6 <ISPCC_ProgramChip+0xa4>
    22ea:	95 31       	cpi	r25, 0x15	; 21
    22ec:	89 f4       	brne	.+34     	; 0x2310 <ISPCC_ProgramChip+0xbe>
    22ee:	80 91 3d 01 	lds	r24, 0x013D
    22f2:	8d 15       	cp	r24, r13
    22f4:	69 f0       	breq	.+26     	; 0x2310 <ISPCC_ProgramChip+0xbe>
    22f6:	00 91 2b 01 	lds	r16, 0x012B
    22fa:	10 91 2c 01 	lds	r17, 0x012C
    22fe:	93 31       	cpi	r25, 0x13	; 19
    2300:	39 f4       	brne	.+14     	; 0x2310 <ISPCC_ProgramChip+0xbe>
    2302:	00 0f       	add	r16, r16
    2304:	11 1f       	adc	r17, r17
    2306:	c7 01       	movw	r24, r14
    2308:	81 70       	andi	r24, 0x01	; 1
    230a:	90 70       	andi	r25, 0x00	; 0
    230c:	08 0f       	add	r16, r24
    230e:	19 1f       	adc	r17, r25
    2310:	e0 fc       	sbrc	r14, 0
    2312:	04 c0       	rjmp	.+8      	; 0x231c <ISPCC_ProgramChip+0xca>
    2314:	80 91 34 01 	lds	r24, 0x0134
    2318:	85 31       	cpi	r24, 0x15	; 21
    231a:	11 f4       	brne	.+4      	; 0x2320 <ISPCC_ProgramChip+0xce>
    231c:	0e 94 c3 0e 	call	0x1d86 <V2P_IncrementCurrAddress>
    2320:	08 94       	sec
    2322:	e1 1c       	adc	r14, r1
    2324:	f1 1c       	adc	r15, r1
    2326:	ea 14       	cp	r14, r10
    2328:	fb 04       	cpc	r15, r11
    232a:	08 f4       	brcc	.+2      	; 0x232e <ISPCC_ProgramChip+0xdc>
    232c:	bc cf       	rjmp	.-136    	; 0x22a6 <ISPCC_ProgramChip+0x54>
    232e:	c9 2d       	mov	r28, r9
    2330:	97 fe       	sbrs	r9, 7
    2332:	69 c0       	rjmp	.+210    	; 0x2406 <ISPCC_ProgramChip+0x1b4>
    2334:	80 91 3a 01 	lds	r24, 0x013A
    2338:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    233c:	c3 01       	movw	r24, r6
    233e:	0e 94 ba 09 	call	0x1374 <USI_SPITransmitWord>
    2342:	80 e0       	ldi	r24, 0x00	; 0
    2344:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    2348:	01 15       	cp	r16, r1
    234a:	11 05       	cpc	r17, r1
    234c:	11 f4       	brne	.+4      	; 0x2352 <ISPCC_ProgramChip+0x100>
    234e:	cf 78       	andi	r28, 0x8F	; 143
    2350:	c0 61       	ori	r28, 0x10	; 16
    2352:	b8 01       	movw	r22, r16
    2354:	8c 2f       	mov	r24, r28
    2356:	0e 94 df 10 	call	0x21be <ISPCC_PollForProgComplete>
    235a:	55 c0       	rjmp	.+170    	; 0x2406 <ISPCC_ProgramChip+0x1b4>
    235c:	78 01       	movw	r14, r16
    235e:	0a 15       	cp	r16, r10
    2360:	1b 05       	cpc	r17, r11
    2362:	08 f0       	brcs	.+2      	; 0x2366 <ISPCC_ProgramChip+0x114>
    2364:	50 c0       	rjmp	.+160    	; 0x2406 <ISPCC_ProgramChip+0x1b4>
    2366:	5e e3       	ldi	r21, 0x3E	; 62
    2368:	65 2e       	mov	r6, r21
    236a:	51 e0       	ldi	r21, 0x01	; 1
    236c:	75 2e       	mov	r7, r21
    236e:	f3 01       	movw	r30, r6
    2370:	d1 90       	ld	r13, Z+
    2372:	3f 01       	movw	r6, r30
    2374:	80 91 34 01 	lds	r24, 0x0134
    2378:	83 31       	cpi	r24, 0x13	; 19
    237a:	31 f4       	brne	.+12     	; 0x2388 <ISPCC_ProgramChip+0x136>
    237c:	8c 2d       	mov	r24, r12
    237e:	99 27       	eor	r25, r25
    2380:	e0 fe       	sbrs	r14, 0
    2382:	03 c0       	rjmp	.+6      	; 0x238a <ISPCC_ProgramChip+0x138>
    2384:	88 60       	ori	r24, 0x08	; 8
    2386:	01 c0       	rjmp	.+2      	; 0x238a <ISPCC_ProgramChip+0x138>
    2388:	8c 2d       	mov	r24, r12
    238a:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    238e:	80 91 2b 01 	lds	r24, 0x012B
    2392:	90 91 2c 01 	lds	r25, 0x012C
    2396:	0e 94 ba 09 	call	0x1374 <USI_SPITransmitWord>
    239a:	8d 2d       	mov	r24, r13
    239c:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    23a0:	c9 2d       	mov	r28, r9
    23a2:	80 91 3c 01 	lds	r24, 0x013C
    23a6:	8d 15       	cp	r24, r13
    23a8:	c1 f0       	breq	.+48     	; 0x23da <ISPCC_ProgramChip+0x188>
    23aa:	90 91 34 01 	lds	r25, 0x0134
    23ae:	93 31       	cpi	r25, 0x13	; 19
    23b0:	31 f0       	breq	.+12     	; 0x23be <ISPCC_ProgramChip+0x16c>
    23b2:	95 31       	cpi	r25, 0x15	; 21
    23b4:	91 f4       	brne	.+36     	; 0x23da <ISPCC_ProgramChip+0x188>
    23b6:	80 91 3d 01 	lds	r24, 0x013D
    23ba:	8d 15       	cp	r24, r13
    23bc:	71 f0       	breq	.+28     	; 0x23da <ISPCC_ProgramChip+0x188>
    23be:	00 91 2b 01 	lds	r16, 0x012B
    23c2:	10 91 2c 01 	lds	r17, 0x012C
    23c6:	93 31       	cpi	r25, 0x13	; 19
    23c8:	59 f4       	brne	.+22     	; 0x23e0 <ISPCC_ProgramChip+0x18e>
    23ca:	00 0f       	add	r16, r16
    23cc:	11 1f       	adc	r17, r17
    23ce:	c7 01       	movw	r24, r14
    23d0:	81 70       	andi	r24, 0x01	; 1
    23d2:	90 70       	andi	r25, 0x00	; 0
    23d4:	08 0f       	add	r16, r24
    23d6:	19 1f       	adc	r17, r25
    23d8:	03 c0       	rjmp	.+6      	; 0x23e0 <ISPCC_ProgramChip+0x18e>
    23da:	c9 2d       	mov	r28, r9
    23dc:	c1 7f       	andi	r28, 0xF1	; 241
    23de:	c2 60       	ori	r28, 0x02	; 2
    23e0:	e0 fc       	sbrc	r14, 0
    23e2:	04 c0       	rjmp	.+8      	; 0x23ec <ISPCC_ProgramChip+0x19a>
    23e4:	80 91 34 01 	lds	r24, 0x0134
    23e8:	85 31       	cpi	r24, 0x15	; 21
    23ea:	11 f4       	brne	.+4      	; 0x23f0 <ISPCC_ProgramChip+0x19e>
    23ec:	0e 94 c3 0e 	call	0x1d86 <V2P_IncrementCurrAddress>
    23f0:	b8 01       	movw	r22, r16
    23f2:	8c 2f       	mov	r24, r28
    23f4:	0e 94 df 10 	call	0x21be <ISPCC_PollForProgComplete>
    23f8:	08 94       	sec
    23fa:	e1 1c       	adc	r14, r1
    23fc:	f1 1c       	adc	r15, r1
    23fe:	ea 14       	cp	r14, r10
    2400:	fb 04       	cpc	r15, r11
    2402:	08 f4       	brcc	.+2      	; 0x2406 <ISPCC_ProgramChip+0x1b4>
    2404:	b4 cf       	rjmp	.-152    	; 0x236e <ISPCC_ProgramChip+0x11c>
    2406:	df 91       	pop	r29
    2408:	cf 91       	pop	r28
    240a:	1f 91       	pop	r17
    240c:	0f 91       	pop	r16
    240e:	ff 90       	pop	r15
    2410:	ef 90       	pop	r14
    2412:	df 90       	pop	r13
    2414:	cf 90       	pop	r12
    2416:	bf 90       	pop	r11
    2418:	af 90       	pop	r10
    241a:	9f 90       	pop	r9
    241c:	7f 90       	pop	r7
    241e:	6f 90       	pop	r6
    2420:	08 95       	ret

00002422 <AICI_InterpretPacket>:

// ======================================================================================

void AICI_InterpretPacket(void)
{
    2422:	df 92       	push	r13
    2424:	ef 92       	push	r14
    2426:	ff 92       	push	r15
    2428:	0f 93       	push	r16
    242a:	1f 93       	push	r17
    242c:	cf 93       	push	r28
    242e:	df 93       	push	r29
	switch (PacketBytes[0])
    2430:	80 91 34 01 	lds	r24, 0x0134
    2434:	99 27       	eor	r25, r25
    2436:	86 31       	cpi	r24, 0x16	; 22
    2438:	91 05       	cpc	r25, r1
    243a:	09 f4       	brne	.+2      	; 0x243e <AICI_InterpretPacket+0x1c>
    243c:	fa c0       	rjmp	.+500    	; 0x2632 <AICI_InterpretPacket+0x210>
    243e:	87 31       	cpi	r24, 0x17	; 23
    2440:	91 05       	cpc	r25, r1
    2442:	94 f4       	brge	.+36     	; 0x2468 <AICI_InterpretPacket+0x46>
    2444:	82 31       	cpi	r24, 0x12	; 18
    2446:	91 05       	cpc	r25, r1
    2448:	09 f4       	brne	.+2      	; 0x244c <AICI_InterpretPacket+0x2a>
    244a:	5f c0       	rjmp	.+190    	; 0x250a <AICI_InterpretPacket+0xe8>
    244c:	83 31       	cpi	r24, 0x13	; 19
    244e:	91 05       	cpc	r25, r1
    2450:	3c f4       	brge	.+14     	; 0x2460 <AICI_InterpretPacket+0x3e>
    2452:	80 31       	cpi	r24, 0x10	; 16
    2454:	91 05       	cpc	r25, r1
    2456:	f9 f0       	breq	.+62     	; 0x2496 <AICI_InterpretPacket+0x74>
    2458:	41 97       	sbiw	r24, 0x11	; 17
    245a:	09 f4       	brne	.+2      	; 0x245e <AICI_InterpretPacket+0x3c>
    245c:	3c c0       	rjmp	.+120    	; 0x24d6 <AICI_InterpretPacket+0xb4>
    245e:	3d c1       	rjmp	.+634    	; 0x26da <AICI_InterpretPacket+0x2b8>
    2460:	44 97       	sbiw	r24, 0x14	; 20
    2462:	09 f4       	brne	.+2      	; 0x2466 <AICI_InterpretPacket+0x44>
    2464:	e6 c0       	rjmp	.+460    	; 0x2632 <AICI_InterpretPacket+0x210>
    2466:	2e c1       	rjmp	.+604    	; 0x26c4 <AICI_InterpretPacket+0x2a2>
    2468:	89 31       	cpi	r24, 0x19	; 25
    246a:	91 05       	cpc	r25, r1
    246c:	09 f4       	brne	.+2      	; 0x2470 <AICI_InterpretPacket+0x4e>
    246e:	cb c0       	rjmp	.+406    	; 0x2606 <AICI_InterpretPacket+0x1e4>
    2470:	8a 31       	cpi	r24, 0x1A	; 26
    2472:	91 05       	cpc	r25, r1
    2474:	44 f4       	brge	.+16     	; 0x2486 <AICI_InterpretPacket+0x64>
    2476:	87 31       	cpi	r24, 0x17	; 23
    2478:	91 05       	cpc	r25, r1
    247a:	09 f4       	brne	.+2      	; 0x247e <AICI_InterpretPacket+0x5c>
    247c:	c4 c0       	rjmp	.+392    	; 0x2606 <AICI_InterpretPacket+0x1e4>
    247e:	48 97       	sbiw	r24, 0x18	; 24
    2480:	09 f4       	brne	.+2      	; 0x2484 <AICI_InterpretPacket+0x62>
    2482:	a4 c0       	rjmp	.+328    	; 0x25cc <AICI_InterpretPacket+0x1aa>
    2484:	2a c1       	rjmp	.+596    	; 0x26da <AICI_InterpretPacket+0x2b8>
    2486:	8d 31       	cpi	r24, 0x1D	; 29
    2488:	91 05       	cpc	r25, r1
    248a:	0c f4       	brge	.+2      	; 0x248e <AICI_InterpretPacket+0x6c>
    248c:	9f c0       	rjmp	.+318    	; 0x25cc <AICI_InterpretPacket+0x1aa>
    248e:	4d 97       	sbiw	r24, 0x1d	; 29
    2490:	09 f4       	brne	.+2      	; 0x2494 <AICI_InterpretPacket+0x72>
    2492:	60 c0       	rjmp	.+192    	; 0x2554 <AICI_InterpretPacket+0x132>
    2494:	22 c1       	rjmp	.+580    	; 0x26da <AICI_InterpretPacket+0x2b8>
	{
		case CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
    2496:	82 e0       	ldi	r24, 0x02	; 2
    2498:	90 e0       	ldi	r25, 0x00	; 0
    249a:	90 93 31 01 	sts	0x0131, r25
    249e:	80 93 30 01 	sts	0x0130, r24
			
			USI_SPIInitMaster(eeprom_read_byte_169(&Param_SCKDuration));
    24a2:	80 e2       	ldi	r24, 0x20	; 32
    24a4:	91 e0       	ldi	r25, 0x01	; 1
    24a6:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
    24aa:	0e 94 8d 09 	call	0x131a <USI_SPIInitMaster>

			MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);  // Pull the slave AVR's RESET line to active
    24ae:	80 e0       	ldi	r24, 0x00	; 0
    24b0:	0e 94 1b 03 	call	0x636 <MAIN_ResetCSLine>
			MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE); // Orange = Busy
    24b4:	81 b3       	in	r24, 0x11	; 17
    24b6:	80 63       	ori	r24, 0x30	; 48
    24b8:	81 bb       	out	0x11, r24	; 17
			ISPCC_EnterChipProgrammingMode();       // Run the Enter Programming Mode routine
    24ba:	0e 94 81 10 	call	0x2102 <ISPCC_EnterChipProgrammingMode>

			if (InProgrammingMode)
    24be:	80 91 2f 01 	lds	r24, 0x012F
    24c2:	88 23       	and	r24, r24
    24c4:	19 f0       	breq	.+6      	; 0x24cc <AICI_InterpretPacket+0xaa>
			   LCD_puts_f(AVRISPModeMessage);
    24c6:	83 ef       	ldi	r24, 0xF3	; 243
    24c8:	93 e0       	ldi	r25, 0x03	; 3
    24ca:	02 c0       	rjmp	.+4      	; 0x24d0 <AICI_InterpretPacket+0xae>
			else
			   LCD_puts_f(SyncErrorMessage);
    24cc:	88 ee       	ldi	r24, 0xE8	; 232
    24ce:	93 e0       	ldi	r25, 0x03	; 3
    24d0:	0e 94 ff 07 	call	0xffe <LCD_puts_f>
			
			break;
    24d4:	0b c1       	rjmp	.+534    	; 0x26ec <AICI_InterpretPacket+0x2ca>
		case CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;
    24d6:	82 e0       	ldi	r24, 0x02	; 2
    24d8:	90 e0       	ldi	r25, 0x00	; 0
    24da:	90 93 31 01 	sts	0x0131, r25
    24de:	80 93 30 01 	sts	0x0130, r24

			MAIN_Delay1MS(PacketBytes[1]);           // Wait for the "PreDelay" amount specified in the packet
    24e2:	80 91 35 01 	lds	r24, 0x0135
    24e6:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Non programming mode = green status led
    24ea:	81 b3       	in	r24, 0x11	; 17
    24ec:	8f 7c       	andi	r24, 0xCF	; 207
    24ee:	80 61       	ori	r24, 0x10	; 16
    24f0:	81 bb       	out	0x11, r24	; 17
			InProgrammingMode = FALSE;
    24f2:	10 92 2f 01 	sts	0x012F, r1
			MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run
    24f6:	81 e0       	ldi	r24, 0x01	; 1
    24f8:	0e 94 1b 03 	call	0x636 <MAIN_ResetCSLine>
			MAIN_Delay1MS(PacketBytes[2]);           // Wait for the "PostDelay" amount specified in the packet
    24fc:	80 91 36 01 	lds	r24, 0x0136
    2500:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
			
			USI_SPIOff();
    2504:	0e 94 9d 09 	call	0x133a <USI_SPIOff>
    2508:	e5 c0       	rjmp	.+458    	; 0x26d4 <AICI_InterpretPacket+0x2b2>

			PacketBytes[1] = STATUS_CMD_OK;      // Return OK

			break;
		case CMD_CHIP_ERASE_ISP:
			MessageSize = 2;
    250a:	82 e0       	ldi	r24, 0x02	; 2
    250c:	90 e0       	ldi	r25, 0x00	; 0
    250e:	90 93 31 01 	sts	0x0131, r25
    2512:	80 93 30 01 	sts	0x0130, r24
			
			for (uint8_t PacketB = 3; PacketB <= 6; PacketB++) // Send the erase commands to the slave AVR
    2516:	c3 e0       	ldi	r28, 0x03	; 3
    2518:	07 e3       	ldi	r16, 0x37	; 55
    251a:	11 e0       	ldi	r17, 0x01	; 1
				USI_SPITransmit(PacketBytes[PacketB]);
    251c:	f8 01       	movw	r30, r16
    251e:	81 91       	ld	r24, Z+
    2520:	8f 01       	movw	r16, r30
    2522:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    2526:	c1 50       	subi	r28, 0x01	; 1
    2528:	c7 ff       	sbrs	r28, 7
    252a:	f8 cf       	rjmp	.-16     	; 0x251c <AICI_InterpretPacket+0xfa>

			if (PacketBytes[2])                  // Poll mode, value of 1 indicates a busy flag wait
    252c:	80 91 36 01 	lds	r24, 0x0136
    2530:	88 23       	and	r24, r24
    2532:	59 f0       	breq	.+22     	; 0x254a <AICI_InterpretPacket+0x128>
			{
				do
					USI_SPITransmitWord(0xF000);
    2534:	80 e0       	ldi	r24, 0x00	; 0
    2536:	90 ef       	ldi	r25, 0xF0	; 240
    2538:	0e 94 ba 09 	call	0x1374 <USI_SPITransmitWord>
    253c:	80 e0       	ldi	r24, 0x00	; 0
    253e:	90 e0       	ldi	r25, 0x00	; 0
    2540:	0e 94 ba 09 	call	0x1374 <USI_SPITransmitWord>
    2544:	80 fd       	sbrc	r24, 0
    2546:	f6 cf       	rjmp	.-20     	; 0x2534 <AICI_InterpretPacket+0x112>
    2548:	c5 c0       	rjmp	.+394    	; 0x26d4 <AICI_InterpretPacket+0x2b2>
				while (USI_SPITransmitWord(0x0000) & 0x01);
			}
			else                                // Poll mode flag of 0 indicates a predefined delay
			{
				MAIN_Delay1MS(PacketBytes[1]);   // Wait the specified interval to ensure erase complete
    254a:	80 91 35 01 	lds	r24, 0x0135
    254e:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    2552:	c0 c0       	rjmp	.+384    	; 0x26d4 <AICI_InterpretPacket+0x2b2>
			}
			
			PacketBytes[1] = STATUS_CMD_OK;      // Always return OK
			
			break;
		case CMD_SPI_MULTI:
				MessageSize = (3 + PacketBytes[2]);    // Number of recieved bytes, plus two OKs and the command byte
    2554:	e0 90 36 01 	lds	r14, 0x0136
    2558:	8e 2d       	mov	r24, r14
    255a:	99 27       	eor	r25, r25
    255c:	03 96       	adiw	r24, 0x03	; 3
    255e:	90 93 31 01 	sts	0x0131, r25
    2562:	80 93 30 01 	sts	0x0130, r24
		
				uint8_t TxBytes      = PacketBytes[1]; // \. The packet data is overwritten during the transfer. Because
    2566:	00 91 35 01 	lds	r16, 0x0135
				uint8_t RxStartByte  = PacketBytes[2]; // |  of this each data byte must be stored into temp variables
				uint8_t RxBytes      = PacketBytes[3]; // /  so that their contents are not lost.
    256a:	f0 90 37 01 	lds	r15, 0x0137
				uint8_t RxByteNum    = 1;
    256e:	c1 e0       	ldi	r28, 0x01	; 1
				uint8_t TxByteNum    = 1;
				uint8_t RecievedByte = 0;

				while (TxByteNum++ < TxBytes)          // Still bytes to transfer
				{
					RecievedByte = USI_SPITransmit(PacketBytes[3 + TxByteNum]); // Transmit the byte, store the answer

					if ((TxByteNum >= RxStartByte) && (RxByteNum < RxBytes))
					   PacketBytes[2 + RxByteNum++] = RecievedByte;
    2570:	12 e0       	ldi	r17, 0x02	; 2
    2572:	c0 17       	cp	r28, r16
    2574:	a8 f4       	brcc	.+42     	; 0x25a0 <AICI_InterpretPacket+0x17e>
    2576:	e1 2f       	mov	r30, r17
    2578:	ff 27       	eor	r31, r31
    257a:	ec 5c       	subi	r30, 0xCC	; 204
    257c:	fe 4f       	sbci	r31, 0xFE	; 254
    257e:	83 81       	ldd	r24, Z+3	; 0x03
    2580:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    2584:	1e 15       	cp	r17, r14
    2586:	40 f0       	brcs	.+16     	; 0x2598 <AICI_InterpretPacket+0x176>
    2588:	cf 15       	cp	r28, r15
    258a:	30 f4       	brcc	.+12     	; 0x2598 <AICI_InterpretPacket+0x176>
    258c:	ec 2f       	mov	r30, r28
    258e:	ff 27       	eor	r31, r31
    2590:	ec 5c       	subi	r30, 0xCC	; 204
    2592:	fe 4f       	sbci	r31, 0xFE	; 254
    2594:	82 83       	std	Z+2, r24	; 0x02
    2596:	cf 5f       	subi	r28, 0xFF	; 255
    2598:	81 2f       	mov	r24, r17
    259a:	1f 5f       	subi	r17, 0xFF	; 255
    259c:	80 17       	cp	r24, r16
    259e:	58 f3       	brcs	.-42     	; 0x2576 <AICI_InterpretPacket+0x154>
				}

				while (RxByteNum++ < RxBytes)                         // Still more bytes to recieve
				   PacketBytes[2 + RxByteNum] = USI_SPITransmit(0x00); // its answer to be recorded (or more bytes than sent need responses), send dummy bytes to fetch the response(s)
    25a0:	8c 2f       	mov	r24, r28
    25a2:	cf 5f       	subi	r28, 0xFF	; 255
    25a4:	8f 15       	cp	r24, r15
    25a6:	50 f4       	brcc	.+20     	; 0x25bc <AICI_InterpretPacket+0x19a>
    25a8:	0c 2f       	mov	r16, r28
    25aa:	11 27       	eor	r17, r17
    25ac:	0c 5c       	subi	r16, 0xCC	; 204
    25ae:	1e 4f       	sbci	r17, 0xFE	; 254
    25b0:	80 e0       	ldi	r24, 0x00	; 0
    25b2:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    25b6:	f8 01       	movw	r30, r16
    25b8:	82 83       	std	Z+2, r24	; 0x02
    25ba:	f2 cf       	rjmp	.-28     	; 0x25a0 <AICI_InterpretPacket+0x17e>

				PacketBytes[1]             = STATUS_CMD_OK; // Data should be encompassed
    25bc:	10 92 35 01 	sts	0x0135, r1
				PacketBytes[3 + RxByteNum] = STATUS_CMD_OK; //  by STATS_CMD_OKs
    25c0:	ec 2f       	mov	r30, r28
    25c2:	ff 27       	eor	r31, r31
    25c4:	ec 5c       	subi	r30, 0xCC	; 204
    25c6:	fe 4f       	sbci	r31, 0xFE	; 254
    25c8:	13 82       	std	Z+3, r1	; 0x03

				break;
    25ca:	90 c0       	rjmp	.+288    	; 0x26ec <AICI_InterpretPacket+0x2ca>
		case CMD_READ_SIGNATURE_ISP:
		case CMD_READ_FUSE_ISP:
		case CMD_READ_LOCK_ISP:
		case CMD_READ_OSCCAL_ISP:
			MessageSize = 4;
    25cc:	84 e0       	ldi	r24, 0x04	; 4
    25ce:	90 e0       	ldi	r25, 0x00	; 0
    25d0:	90 93 31 01 	sts	0x0131, r25
    25d4:	80 93 30 01 	sts	0x0130, r24
	
			for(uint8_t ByteNum = 1; ByteNum <= 4; ByteNum++)
    25d8:	c1 e0       	ldi	r28, 0x01	; 1
    25da:	06 e3       	ldi	r16, 0x36	; 54
    25dc:	11 e0       	ldi	r17, 0x01	; 1
			{
				uint8_t Response = USI_SPITransmit(PacketBytes[1 + ByteNum]); // Transmit the four signature request bytes
    25de:	f8 01       	movw	r30, r16
    25e0:	81 91       	ld	r24, Z+
    25e2:	8f 01       	movw	r16, r30
    25e4:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    25e8:	98 2f       	mov	r25, r24

				if (ByteNum == PacketBytes[1])         // If the current byte is the requested signature byte, save the reponse in the packet
    25ea:	80 91 35 01 	lds	r24, 0x0135
    25ee:	c8 17       	cp	r28, r24
    25f0:	11 f4       	brne	.+4      	; 0x25f6 <AICI_InterpretPacket+0x1d4>
					PacketBytes[2] = Response;
    25f2:	90 93 36 01 	sts	0x0136, r25
    25f6:	cf 5f       	subi	r28, 0xFF	; 255
    25f8:	c5 30       	cpi	r28, 0x05	; 5
    25fa:	88 f3       	brcs	.-30     	; 0x25de <AICI_InterpretPacket+0x1bc>
			}

			PacketBytes[1] = STATUS_CMD_OK;            // Data byte is encased in CMD_OKs
    25fc:	10 92 35 01 	sts	0x0135, r1
			PacketBytes[3] = STATUS_CMD_OK;            // Data byte is encased in CMD_OKs
    2600:	10 92 37 01 	sts	0x0137, r1

			break;
    2604:	73 c0       	rjmp	.+230    	; 0x26ec <AICI_InterpretPacket+0x2ca>
		case CMD_PROGRAM_FUSE_ISP:
		case CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;
    2606:	83 e0       	ldi	r24, 0x03	; 3
    2608:	90 e0       	ldi	r25, 0x00	; 0
    260a:	90 93 31 01 	sts	0x0131, r25
    260e:	80 93 30 01 	sts	0x0130, r24
    2612:	05 e3       	ldi	r16, 0x35	; 53
    2614:	11 e0       	ldi	r17, 0x01	; 1
    2616:	c3 e0       	ldi	r28, 0x03	; 3
			
			for (uint8_t PacketB = 1; PacketB <= 4; PacketB++) // Send the lock-byte values to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    2618:	f8 01       	movw	r30, r16
    261a:	81 91       	ld	r24, Z+
    261c:	8f 01       	movw	r16, r30
    261e:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    2622:	c1 50       	subi	r28, 0x01	; 1
    2624:	c7 ff       	sbrs	r28, 7
    2626:	f8 cf       	rjmp	.-16     	; 0x2618 <AICI_InterpretPacket+0x1f6>

			PacketBytes[1] = STATUS_CMD_OK;            // Two CMD_OKs are always returned
    2628:	10 92 35 01 	sts	0x0135, r1
			PacketBytes[2] = STATUS_CMD_OK;            // Two CMD_OKs are always returned
    262c:	10 92 36 01 	sts	0x0136, r1

			break;
    2630:	5d c0       	rjmp	.+186    	; 0x26ec <AICI_InterpretPacket+0x2ca>
		case CMD_READ_FLASH_ISP:
		case CMD_READ_EEPROM_ISP:
			MessageSize = 0;                           // Here to prevent compiler from complaining if a var dec appears straight after a case

			uint8_t  ReadCommand = PacketBytes[3];
    2632:	d0 90 37 01 	lds	r13, 0x0137
			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8) // Load in the number of bytes that is to
    2636:	80 91 35 01 	lds	r24, 0x0135
    263a:	99 27       	eor	r25, r25
    263c:	d8 2f       	mov	r29, r24
    263e:	cc 27       	eor	r28, r28
    2640:	80 91 36 01 	lds	r24, 0x0136
    2644:	99 27       	eor	r25, r25
    2646:	c8 2b       	or	r28, r24
    2648:	d9 2b       	or	r29, r25
			                     | PacketBytes[2];                 // be read into a temp variable (MSB first)

			MessageSize = BytesToRead + 3;
    264a:	23 96       	adiw	r28, 0x03	; 3
    264c:	d0 93 31 01 	sts	0x0131, r29
    2650:	c0 93 30 01 	sts	0x0130, r28
    2654:	23 97       	sbiw	r28, 0x03	; 3

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
    2656:	00 e0       	ldi	r16, 0x00	; 0
    2658:	10 e0       	ldi	r17, 0x00	; 0
    265a:	0c 17       	cp	r16, r28
    265c:	1d 07       	cpc	r17, r29
    265e:	60 f5       	brcc	.+88     	; 0x26b8 <AICI_InterpretPacket+0x296>
    2660:	86 e3       	ldi	r24, 0x36	; 54
    2662:	e8 2e       	mov	r14, r24
    2664:	81 e0       	ldi	r24, 0x01	; 1
    2666:	f8 2e       	mov	r15, r24
			{
				if (PacketBytes[0] == CMD_READ_FLASH_ISP)  // Flash read mode - word addresses so MSB/LSB masking nessesary
    2668:	80 91 34 01 	lds	r24, 0x0134
    266c:	84 31       	cpi	r24, 0x14	; 20
    266e:	31 f4       	brne	.+12     	; 0x267c <AICI_InterpretPacket+0x25a>
				{
					USI_SPITransmit(ReadCommand | ((ReadByte & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ));
    2670:	8d 2d       	mov	r24, r13
    2672:	99 27       	eor	r25, r25
    2674:	00 ff       	sbrs	r16, 0
    2676:	03 c0       	rjmp	.+6      	; 0x267e <AICI_InterpretPacket+0x25c>
    2678:	88 60       	ori	r24, 0x08	; 8
    267a:	01 c0       	rjmp	.+2      	; 0x267e <AICI_InterpretPacket+0x25c>
				}
				else                                       // EEPROM read mode, address is in bytes and so no masking nessesary
				{
					USI_SPITransmit(ReadCommand);
    267c:	8d 2d       	mov	r24, r13
    267e:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
				}
				
				USI_SPITransmitWord(CurrAddress);          // Transmit the current address to the slave AVR
    2682:	80 91 2b 01 	lds	r24, 0x012B
    2686:	90 91 2c 01 	lds	r25, 0x012C
    268a:	0e 94 ba 09 	call	0x1374 <USI_SPITransmitWord>

				PacketBytes[2 + ReadByte] = USI_SPITransmit(0x00); // Read in the byte stored at the requested location
    268e:	80 e0       	ldi	r24, 0x00	; 0
    2690:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    2694:	f7 01       	movw	r30, r14
    2696:	80 83       	st	Z, r24

				if ((ReadByte & 0x01) || (PacketBytes[0] == CMD_READ_EEPROM_ISP)) // Flash addresses are given in words; only increment on the odd byte if reading the flash.
    2698:	00 fd       	sbrc	r16, 0
    269a:	04 c0       	rjmp	.+8      	; 0x26a4 <AICI_InterpretPacket+0x282>
    269c:	80 91 34 01 	lds	r24, 0x0134
    26a0:	86 31       	cpi	r24, 0x16	; 22
    26a2:	11 f4       	brne	.+4      	; 0x26a8 <AICI_InterpretPacket+0x286>
				{
					V2P_IncrementCurrAddress();             // Increment the address counter
    26a4:	0e 94 c3 0e 	call	0x1d86 <V2P_IncrementCurrAddress>
    26a8:	0f 5f       	subi	r16, 0xFF	; 255
    26aa:	1f 4f       	sbci	r17, 0xFF	; 255
    26ac:	08 94       	sec
    26ae:	e1 1c       	adc	r14, r1
    26b0:	f1 1c       	adc	r15, r1
    26b2:	0c 17       	cp	r16, r28
    26b4:	1d 07       	cpc	r17, r29
    26b6:	c0 f2       	brcs	.-80     	; 0x2668 <AICI_InterpretPacket+0x246>
				}
				else
				{
					if ((CurrAddress & 0x00FF0000) & !(CurrAddress & 0x0000FFFF))
					{
						CurrAddress |= (1UL << 31);        // Set MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
						V2P_CheckForExtendedAddress();
					}
				}
			}
			
			PacketBytes[1]               = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    26b8:	10 92 35 01 	sts	0x0135, r1
			PacketBytes[2 + BytesToRead] = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    26bc:	cc 5c       	subi	r28, 0xCC	; 204
    26be:	de 4f       	sbci	r29, 0xFE	; 254
    26c0:	1a 82       	std	Y+2, r1	; 0x02

			break;
    26c2:	14 c0       	rjmp	.+40     	; 0x26ec <AICI_InterpretPacket+0x2ca>
		case CMD_PROGRAM_FLASH_ISP:
		case CMD_PROGRAM_EEPROM_ISP:
			ISPCC_ProgramChip();                          // Program the bytes into the chip
    26c4:	0e 94 29 11 	call	0x2252 <ISPCC_ProgramChip>
			
			MessageSize = 2;
    26c8:	82 e0       	ldi	r24, 0x02	; 2
    26ca:	90 e0       	ldi	r25, 0x00	; 0
    26cc:	90 93 31 01 	sts	0x0131, r25
    26d0:	80 93 30 01 	sts	0x0130, r24

			PacketBytes[1] = STATUS_CMD_OK;
    26d4:	10 92 35 01 	sts	0x0135, r1
			
			break;
    26d8:	09 c0       	rjmp	.+18     	; 0x26ec <AICI_InterpretPacket+0x2ca>
		default:                                        // Unknown command, return error
			MessageSize = 1;
    26da:	81 e0       	ldi	r24, 0x01	; 1
    26dc:	90 e0       	ldi	r25, 0x00	; 0
    26de:	90 93 31 01 	sts	0x0131, r25
    26e2:	80 93 30 01 	sts	0x0130, r24
			
			PacketBytes[1] = STATUS_CMD_UNKNOWN;
    26e6:	89 ec       	ldi	r24, 0xC9	; 201
    26e8:	80 93 35 01 	sts	0x0135, r24
	}

	V2P_SendPacket();                                   // Send the response packet
    26ec:	0e 94 e9 0d 	call	0x1bd2 <V2P_SendPacket>
    26f0:	df 91       	pop	r29
    26f2:	cf 91       	pop	r28
    26f4:	1f 91       	pop	r17
    26f6:	0f 91       	pop	r16
    26f8:	ff 90       	pop	r15
    26fa:	ef 90       	pop	r14
    26fc:	df 90       	pop	r13
    26fe:	08 95       	ret

00002700 <PM_GetStoredDataSize>:

// ======================================================================================

uint32_t PM_GetStoredDataSize(uint8_t Type)
{
    2700:	ef 92       	push	r14
    2702:	ff 92       	push	r15
    2704:	0f 93       	push	r16
    2706:	1f 93       	push	r17
    2708:	cf 93       	push	r28
    270a:	df 93       	push	r29
    270c:	cd b7       	in	r28, 0x3d	; 61
    270e:	de b7       	in	r29, 0x3e	; 62
    2710:	22 97       	sbiw	r28, 0x02	; 2
    2712:	0f b6       	in	r0, 0x3f	; 63
    2714:	f8 94       	cli
    2716:	de bf       	out	0x3e, r29	; 62
    2718:	0f be       	out	0x3f, r0	; 63
    271a:	cd bf       	out	0x3d, r28	; 61
	/* This take a **LOT** of code (202 bytes), and is accessed several times throughout
	   the program, so I've put it into a seperate function to save on flash.            */

	uint32_t ProgDataSize = 0;
	uint16_t EEPROMAddress;

	EEPROMAddress = ((Type == TYPE_FLASH)? Prog_DataSize : Prog_EEPROMSize);
    271c:	81 30       	cpi	r24, 0x01	; 1
    271e:	29 f4       	brne	.+10     	; 0x272a <PM_GetStoredDataSize+0x2a>
    2720:	80 91 16 01 	lds	r24, 0x0116
    2724:	90 91 17 01 	lds	r25, 0x0117
    2728:	04 c0       	rjmp	.+8      	; 0x2732 <PM_GetStoredDataSize+0x32>
    272a:	80 91 14 01 	lds	r24, 0x0114
    272e:	90 91 15 01 	lds	r25, 0x0115
    2732:	9a 83       	std	Y+2, r25	; 0x02
    2734:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize  = ((uint32_t)eeprom_read_byte_169(&EEPROMAddress) << 24);
    2736:	ce 01       	movw	r24, r28
    2738:	01 96       	adiw	r24, 0x01	; 1
    273a:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
    273e:	99 27       	eor	r25, r25
    2740:	aa 27       	eor	r26, r26
    2742:	bb 27       	eor	r27, r27
    2744:	18 2f       	mov	r17, r24
    2746:	00 27       	eor	r16, r16
    2748:	ff 24       	eor	r15, r15
    274a:	ee 24       	eor	r14, r14
	EEPROMAddress++;
    274c:	89 81       	ldd	r24, Y+1	; 0x01
    274e:	9a 81       	ldd	r25, Y+2	; 0x02
    2750:	01 96       	adiw	r24, 0x01	; 1
    2752:	9a 83       	std	Y+2, r25	; 0x02
    2754:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize |= ((uint32_t)eeprom_read_byte_169(&EEPROMAddress) << 16);
    2756:	ce 01       	movw	r24, r28
    2758:	01 96       	adiw	r24, 0x01	; 1
    275a:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
    275e:	99 27       	eor	r25, r25
    2760:	aa 27       	eor	r26, r26
    2762:	bb 27       	eor	r27, r27
    2764:	dc 01       	movw	r26, r24
    2766:	99 27       	eor	r25, r25
    2768:	88 27       	eor	r24, r24
    276a:	e8 2a       	or	r14, r24
    276c:	f9 2a       	or	r15, r25
    276e:	0a 2b       	or	r16, r26
    2770:	1b 2b       	or	r17, r27
	EEPROMAddress++;
    2772:	89 81       	ldd	r24, Y+1	; 0x01
    2774:	9a 81       	ldd	r25, Y+2	; 0x02
    2776:	01 96       	adiw	r24, 0x01	; 1
    2778:	9a 83       	std	Y+2, r25	; 0x02
    277a:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize |= ((uint32_t)eeprom_read_byte_169(&EEPROMAddress) << 8);
    277c:	ce 01       	movw	r24, r28
    277e:	01 96       	adiw	r24, 0x01	; 1
    2780:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
    2784:	99 27       	eor	r25, r25
    2786:	aa 27       	eor	r26, r26
    2788:	bb 27       	eor	r27, r27
    278a:	ba 2f       	mov	r27, r26
    278c:	a9 2f       	mov	r26, r25
    278e:	98 2f       	mov	r25, r24
    2790:	88 27       	eor	r24, r24
    2792:	e8 2a       	or	r14, r24
    2794:	f9 2a       	or	r15, r25
    2796:	0a 2b       	or	r16, r26
    2798:	1b 2b       	or	r17, r27
	EEPROMAddress++;
    279a:	89 81       	ldd	r24, Y+1	; 0x01
    279c:	9a 81       	ldd	r25, Y+2	; 0x02
    279e:	01 96       	adiw	r24, 0x01	; 1
    27a0:	9a 83       	std	Y+2, r25	; 0x02
    27a2:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize |= eeprom_read_byte_169(&EEPROMAddress);
    27a4:	ce 01       	movw	r24, r28
    27a6:	01 96       	adiw	r24, 0x01	; 1
    27a8:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
    27ac:	99 27       	eor	r25, r25
    27ae:	aa 27       	eor	r26, r26
    27b0:	bb 27       	eor	r27, r27
    27b2:	e8 2a       	or	r14, r24
    27b4:	f9 2a       	or	r15, r25
    27b6:	0a 2b       	or	r16, r26
    27b8:	1b 2b       	or	r17, r27

	if (ProgDataSize == 0xFFFFFFFF)                                      // Blank EEPROM, return a size  of 0 bytes
    27ba:	8f ef       	ldi	r24, 0xFF	; 255
    27bc:	e8 16       	cp	r14, r24
    27be:	8f ef       	ldi	r24, 0xFF	; 255
    27c0:	f8 06       	cpc	r15, r24
    27c2:	8f ef       	ldi	r24, 0xFF	; 255
    27c4:	08 07       	cpc	r16, r24
    27c6:	8f ef       	ldi	r24, 0xFF	; 255
    27c8:	18 07       	cpc	r17, r24
    27ca:	19 f4       	brne	.+6      	; 0x27d2 <PM_GetStoredDataSize+0xd2>
	   ProgDataSize = 0x00;
    27cc:	ee 24       	eor	r14, r14
    27ce:	ff 24       	eor	r15, r15
    27d0:	87 01       	movw	r16, r14

	return ProgDataSize;
}
    27d2:	c8 01       	movw	r24, r16
    27d4:	b7 01       	movw	r22, r14
    27d6:	22 96       	adiw	r28, 0x02	; 2
    27d8:	0f b6       	in	r0, 0x3f	; 63
    27da:	f8 94       	cli
    27dc:	de bf       	out	0x3e, r29	; 62
    27de:	0f be       	out	0x3f, r0	; 63
    27e0:	cd bf       	out	0x3d, r28	; 61
    27e2:	df 91       	pop	r29
    27e4:	cf 91       	pop	r28
    27e6:	1f 91       	pop	r17
    27e8:	0f 91       	pop	r16
    27ea:	ff 90       	pop	r15
    27ec:	ef 90       	pop	r14
    27ee:	08 95       	ret

000027f0 <PM_SetupDFAddressCounters>:

void PM_SetupDFAddressCounters(uint8_t Type)
{
	uint32_t StartAddress;
	
	MemoryType = Type;
    27f0:	80 93 4a 02 	sts	0x024A, r24
	GPageLength = 0;
    27f4:	10 92 48 02 	sts	0x0248, r1
    27f8:	10 92 47 02 	sts	0x0247, r1
    27fc:	20 91 2b 01 	lds	r18, 0x012B
    2800:	30 91 2c 01 	lds	r19, 0x012C
    2804:	40 91 2d 01 	lds	r20, 0x012D
    2808:	50 91 2e 01 	lds	r21, 0x012E

	if (Type == TYPE_FLASH)                                              // Type 1 = Flash
    280c:	81 30       	cpi	r24, 0x01	; 1
    280e:	39 f4       	brne	.+14     	; 0x281e <PM_SetupDFAddressCounters+0x2e>
		StartAddress = (CurrAddress << 1);                               // Convert flash word address to byte address
    2810:	da 01       	movw	r26, r20
    2812:	c9 01       	movw	r24, r18
    2814:	88 0f       	add	r24, r24
    2816:	99 1f       	adc	r25, r25
    2818:	aa 1f       	adc	r26, r26
    281a:	bb 1f       	adc	r27, r27
    281c:	06 c0       	rjmp	.+12     	; 0x282a <PM_SetupDFAddressCounters+0x3a>
	else
		StartAddress = CurrAddress + PM_EEPROM_OFFSET;                   // EEPROM uses byte addresses, and starts at the 257th kilobyte in Dataflash
    281e:	da 01       	movw	r26, r20
    2820:	c9 01       	movw	r24, r18
    2822:	80 50       	subi	r24, 0x00	; 0
    2824:	9c 4f       	sbci	r25, 0xFC	; 252
    2826:	ab 4f       	sbci	r26, 0xFB	; 251
    2828:	bf 4f       	sbci	r27, 0xFF	; 255
	
	CurrPageAddress = 0;
    282a:	10 92 8c 02 	sts	0x028C, r1
    282e:	10 92 8b 02 	sts	0x028B, r1

	while (StartAddress >= DF_INTERNALDF_BUFFBYTES)                      // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DF_INTERNALDF_BUFFBYTES;                         // Subtract one page's worth of bytes from the desired address
		CurrPageAddress++;
    2832:	88 30       	cpi	r24, 0x08	; 8
    2834:	21 e0       	ldi	r18, 0x01	; 1
    2836:	92 07       	cpc	r25, r18
    2838:	20 e0       	ldi	r18, 0x00	; 0
    283a:	a2 07       	cpc	r26, r18
    283c:	20 e0       	ldi	r18, 0x00	; 0
    283e:	b2 07       	cpc	r27, r18
    2840:	a0 f0       	brcs	.+40     	; 0x286a <PM_SetupDFAddressCounters+0x7a>
    2842:	20 e0       	ldi	r18, 0x00	; 0
    2844:	30 e0       	ldi	r19, 0x00	; 0
    2846:	88 50       	subi	r24, 0x08	; 8
    2848:	91 40       	sbci	r25, 0x01	; 1
    284a:	a0 40       	sbci	r26, 0x00	; 0
    284c:	b0 40       	sbci	r27, 0x00	; 0
    284e:	2f 5f       	subi	r18, 0xFF	; 255
    2850:	3f 4f       	sbci	r19, 0xFF	; 255
    2852:	88 30       	cpi	r24, 0x08	; 8
    2854:	41 e0       	ldi	r20, 0x01	; 1
    2856:	94 07       	cpc	r25, r20
    2858:	40 e0       	ldi	r20, 0x00	; 0
    285a:	a4 07       	cpc	r26, r20
    285c:	40 e0       	ldi	r20, 0x00	; 0
    285e:	b4 07       	cpc	r27, r20
    2860:	90 f7       	brcc	.-28     	; 0x2846 <PM_SetupDFAddressCounters+0x56>
    2862:	30 93 8c 02 	sts	0x028C, r19
    2866:	20 93 8b 02 	sts	0x028B, r18
	}
	
	CurrBuffByte = (uint16_t)StartAddress;                               // The buffer byte is the remainder
    286a:	90 93 85 02 	sts	0x0285, r25
    286e:	80 93 84 02 	sts	0x0284, r24
    2872:	08 95       	ret

00002874 <PM_StoreProgramByte>:
}

void PM_StoreProgramByte(uint8_t Data)
{
    2874:	cf 93       	push	r28
    2876:	c8 2f       	mov	r28, r24
	if (CurrBuffByte == DF_INTERNALDF_BUFFBYTES)
    2878:	80 91 84 02 	lds	r24, 0x0284
    287c:	90 91 85 02 	lds	r25, 0x0285
    2880:	88 50       	subi	r24, 0x08	; 8
    2882:	91 40       	sbci	r25, 0x01	; 1
    2884:	d9 f4       	brne	.+54     	; 0x28bc <PM_StoreProgramByte+0x48>
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
    2886:	80 91 8b 02 	lds	r24, 0x028B
    288a:	90 91 8c 02 	lds	r25, 0x028C
    288e:	9c 01       	movw	r18, r24
    2890:	01 96       	adiw	r24, 0x01	; 1
    2892:	90 93 8c 02 	sts	0x028C, r25
    2896:	80 93 8b 02 	sts	0x028B, r24
    289a:	c9 01       	movw	r24, r18
    289c:	0e 94 24 0b 	call	0x1648 <DF_CopyBufferToFlashPage>
		DF_CopyFlashPageToBuffer(CurrPageAddress);
    28a0:	80 91 8b 02 	lds	r24, 0x028B
    28a4:	90 91 8c 02 	lds	r25, 0x028C
    28a8:	0e 94 ee 0a 	call	0x15dc <DF_CopyFlashPageToBuffer>
		DF_BufferWriteEnable(0);
    28ac:	80 e0       	ldi	r24, 0x00	; 0
    28ae:	90 e0       	ldi	r25, 0x00	; 0
    28b0:	0e 94 5e 0a 	call	0x14bc <DF_BufferWriteEnable>
		CurrBuffByte = 0;
    28b4:	10 92 85 02 	sts	0x0285, r1
    28b8:	10 92 84 02 	sts	0x0284, r1
	}
	
	SPI_SPITransmit(Data);                                               // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    28bc:	8c 2f       	mov	r24, r28
    28be:	0e 94 42 09 	call	0x1284 <SPI_SPITransmit>
	CurrBuffByte++;
    28c2:	80 91 84 02 	lds	r24, 0x0284
    28c6:	90 91 85 02 	lds	r25, 0x0285
    28ca:	01 96       	adiw	r24, 0x01	; 1
    28cc:	90 93 85 02 	sts	0x0285, r25
    28d0:	80 93 84 02 	sts	0x0284, r24
	GPageLength++;
    28d4:	80 91 47 02 	lds	r24, 0x0247
    28d8:	90 91 48 02 	lds	r25, 0x0248
    28dc:	01 96       	adiw	r24, 0x01	; 1
    28de:	90 93 48 02 	sts	0x0248, r25
    28e2:	80 93 47 02 	sts	0x0247, r24
    28e6:	cf 91       	pop	r28
    28e8:	08 95       	ret

000028ea <PM_CheckEndOfProgramming>:
}

void PM_InterpretAVRISPPacket(void)
{
	uint16_t EEPROMAddress;

	switch (PacketBytes[0])
	{
		case CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
			
			EEPROMAddress = Prog_EnterProgMode;
			
			for (uint8_t PacketB = 0; PacketB <= 11; PacketB++)          // Save the enter programming mode command bytes
			{
				eeprom_write_byte_169(&EEPROMAddress, PacketBytes[PacketB]);
				EEPROMAddress++;
			}
			
			InProgrammingMode = TRUE;                                    // Set the flag, prevent the user from exiting the V2P state machine			
			CurrentMode = PM_NO_SETUP;                                   // Clear the current mode variable

			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = STATUS_CMD_OK;

			break;			
		case CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;

			PM_CheckEndOfProgramming();                                  // Check if the last command was a program - if so store the program length
			PM_CheckEndOfFuseLockStore();                                // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
			
			InProgrammingMode = FALSE;                                   // Clear the flag, allow the user to exit the V2P state machine

			DF_EnableDataflash(FALSE);

			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
			PacketBytes[1] = STATUS_CMD_OK;

			break;
		case CMD_READ_SIGNATURE_ISP:
			MessageSize = 4;

			PacketBytes[1] = STATUS_CMD_OK;                              // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x01;                                       // Signature bytes all return "01" in storage mode
			PacketBytes[3] = STATUS_CMD_OK;                              // Data byte is encased in CMD_OKs

			break;
		case CMD_CHIP_ERASE_ISP:
			MessageSize = 2;

			EEPROMAddress = Prog_EraseChip;                              // Program erase chip command start address
			
			for (uint8_t PacketB = 1; PacketB <= 6; PacketB++)          // Save the erase chip command bytes to EEPROM
			{
				eeprom_write_byte_169(&EEPROMAddress, PacketBytes[PacketB]);
				EEPROMAddress++;
			}

			EEPROMAddress = Prog_DataSize;
										
			for (uint8_t Byte = 0; Byte < 8; Byte++)                    // Clear the program and EEPROM size counters
			{
				if (Byte == 4)
				   EEPROMAddress = Prog_EEPROMSize;

				eeprom_write_byte_169(&EEPROMAddress, 0x00);
				EEPROMAddress++;						
			}
			
			uint8_t Block = 0xFF;
			while (Block--)
			   DF_EraseBlock(Block);
			
			eeprom_write_byte_169(&Prog_EraseCmdStored, TRUE);
			
			PacketBytes[1] = STATUS_CMD_OK;
			
			break;
		case CMD_READ_OSCCAL_ISP:
			MessageSize = 4;

			PacketBytes[1] = STATUS_CMD_OK;                             // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x00;                                      // Return 0x00 for the OSCCAL byte
			PacketBytes[3] = STATUS_CMD_OK;                             // Data byte is encased in CMD_OKs

			break;
		case CMD_READ_FUSE_ISP:
		case CMD_READ_LOCK_ISP:
			MessageSize = 4;
	
			if (CurrentMode != PM_LOCKFUSEBITS_READ)                    // First lock or fuse byte being read, set the EEPROM pointer
			{
				PM_CheckEndOfProgramming();                             // Check if the last command was a program - if so store the program length
				PM_CheckEndOfFuseLockStore();                           // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
				
				CurrBuffByte = 0;
				CurrentMode  = PM_LOCKFUSEBITS_READ;
			}
			
			EEPROMAddress = ((PacketBytes[0] == CMD_READ_FUSE_ISP)? Prog_TotalFuseBytes : Prog_TotalLockBytes);

			if (CurrBuffByte > eeprom_read_byte_169(&EEPROMAddress))    // Trying to read more fuse/lock bytes than are stored in memory
			{
				PacketBytes[2] = 0xFF;                                  // Return 0xFF for the fuse/lock byte
			}
			else
			{
				EEPROMAddress  = ((PacketBytes[0] == CMD_READ_FUSE_ISP)? Prog_FuseBytes : Prog_LockBytes) // Starting location
									+ (CurrBuffByte << 2) + (PacketBytes[1] - 1); // The start position of the actual fuse/lock byte to read (4 bytes each)

				PacketBytes[2] = eeprom_read_byte_169(&EEPROMAddress); // Return the fuse/lock byte
			}

			PacketBytes[1] = STATUS_CMD_OK;                            // Data byte is encased in CMD_OKs
			PacketBytes[3] = STATUS_CMD_OK;                            // Data byte is encased in CMD_OKs

			CurrBuffByte++;

			break;
		case CMD_PROGRAM_FUSE_ISP:
		case CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;

			if (CurrentMode != PM_LOCKFUSEBITS_WRITE)                  // First lock or fuse byte being written, set the EEPROM pointer
			{
				CurrentMode   = PM_LOCKFUSEBITS_WRITE;
				CurrBuffByte  = 0;                                     // CurrBuffByte is used to store the total fuse/lock bytes written
			}

			if (PacketBytes[0] == CMD_PROGRAM_FUSE_ISP)
			{
				EEPROMAddress = Prog_FuseBytes + (CurrBuffByte << 2);
				MemoryType    = TYPE_FUSE;
			}
			else
			{
				EEPROMAddress = Prog_LockBytes + (CurrBuffByte << 2);
				MemoryType    = TYPE_LOCK;
			}				
			
			if (CurrBuffByte < PM_MAX_FUSELOCKBITS)
			{
				for (uint8_t FLByte = 1; FLByte <= 4; FLByte++)
				{
					eeprom_write_byte_169(&EEPROMAddress, PacketBytes[FLByte]);
					EEPROMAddress++;
				}

				CurrBuffByte++;                                        // Increment the total fuse/lock bytes written counter
			}
			
			PacketBytes[1] = STATUS_CMD_OK;                            // Two CMD_OKs are always returned
			PacketBytes[2] = STATUS_CMD_OK;                            // Two CMD_OKs are always returned

			break;
		case CMD_PROGRAM_FLASH_ISP:
		case CMD_PROGRAM_EEPROM_ISP:
			MessageSize = 2;

			if (CurrentMode != PM_DATAFLASH_WRITE)                     // First programming packet
			{
				if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)           // Flash programming mode
				{
					EEPROMAddress = Prog_WriteProgram;                 // Set the eeprom address to the Program command bytes location
					PM_SetupDFAddressCounters(TYPE_FLASH);
				}
				else                                                  // EEPROM programming mode
				{
					EEPROMAddress = Prog_WriteEEPROM;                  // Set the eeprom address to the EEPROM command bytes location
					PM_SetupDFAddressCounters(TYPE_EEPROM);
				}
				
				DF_BufferWriteEnable(CurrBuffByte);
				CurrentMode = PM_DATAFLASH_WRITE;
				
				for (uint8_t B = 1; B <= 9; B++)                       // Save the command bytes
				{
					eeprom_write_byte_169(&EEPROMAddress, PacketBytes[B]);
					EEPROMAddress++;				
				}
			}

			uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
			                      | PacketBytes[2];

			for (uint16_t CurrByte = 0; CurrByte < BytesToWrite; CurrByte++)
				PM_StoreProgramByte(PacketBytes[10 + CurrByte]);

			if (!(GPageLength & PM_PAGELENGTH_FOUNDBIT) && (PacketBytes[3] & ISPCC_PROG_MODE_PAGEDONE) && GPageLength)
			{
				EEPROMAddress = ((MemoryType == TYPE_FLASH)? Prog_PageLength : Prog_EPageLength);
	
				eeprom_write_byte_169(&EEPROMAddress, (uint8_t)(GPageLength >> 8));
				EEPROMAddress++;
				eeprom_write_byte_169(&EEPROMAddress, (uint8_t)GPageLength);		
		
				GPageLength |= PM_PAGELENGTH_FOUNDBIT;                 // Bit 15 is used to indicate if the length has been found
			}

			PacketBytes[1] = STATUS_CMD_OK;
		
			break;
		case CMD_READ_FLASH_ISP:
		case CMD_READ_EEPROM_ISP:	
			if (CurrentMode != PM_DATAFLASH_READ)
			{
				PM_CheckEndOfProgramming();                           // Check if the last command was a program - if so store the program length
				PM_CheckEndOfFuseLockStore();                         // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
				
				PM_SetupDFAddressCounters((PacketBytes[0] == CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);
				DF_ContinuousReadEnable(CurrPageAddress, CurrBuffByte);
				
				CurrentMode = PM_DATAFLASH_READ;
				CurrAddress = 0;
			}

			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8)    // \. Load in the number of bytes that is to
			                     | PacketBytes[2];                    // /  be read into a temp variable (MSB first)
						
			uint16_t BytesInMem  = PM_GetStoredDataSize((PacketBytes[0] == CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
			   PacketBytes[2 + ReadByte] = ((CurrAddress < BytesInMem)? SPI_SPITransmit(0x00) : 0xFF); // Read in the next dataflash byte if present
			   V2P_IncrementCurrAddress();
			}
			
			MessageSize = BytesToRead + 3;

			PacketBytes[1]               = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
			PacketBytes[2 + BytesToRead] = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
		
			break;
		default:
			MessageSize = 1;
			
			PacketBytes[1] = STATUS_CMD_UNKNOWN;
	}

	V2P_SendPacket();                                   // Send the response packet
}

void PM_CheckEndOfProgramming(void)
{
    28ea:	ef 92       	push	r14
    28ec:	ff 92       	push	r15
    28ee:	0f 93       	push	r16
    28f0:	1f 93       	push	r17
    28f2:	cf 93       	push	r28
    28f4:	df 93       	push	r29
    28f6:	cd b7       	in	r28, 0x3d	; 61
    28f8:	de b7       	in	r29, 0x3e	; 62
    28fa:	22 97       	sbiw	r28, 0x02	; 2
    28fc:	0f b6       	in	r0, 0x3f	; 63
    28fe:	f8 94       	cli
    2900:	de bf       	out	0x3e, r29	; 62
    2902:	0f be       	out	0x3f, r0	; 63
    2904:	cd bf       	out	0x3d, r28	; 61
   uint16_t EEPROMAddress;

   if (CurrentMode == PM_DATAFLASH_WRITE)
    2906:	80 91 49 02 	lds	r24, 0x0249
    290a:	81 30       	cpi	r24, 0x01	; 1
    290c:	09 f0       	breq	.+2      	; 0x2910 <PM_CheckEndOfProgramming+0x26>
    290e:	6d c0       	rjmp	.+218    	; 0x29ea <PM_CheckEndOfProgramming+0x100>
   {
      if (CurrBuffByte)                               // Data in the dataflash buffer, pending to be written
    2910:	80 91 84 02 	lds	r24, 0x0284
    2914:	90 91 85 02 	lds	r25, 0x0285
    2918:	89 2b       	or	r24, r25
    291a:	31 f0       	breq	.+12     	; 0x2928 <PM_CheckEndOfProgramming+0x3e>
         DF_CopyBufferToFlashPage(CurrPageAddress);   // Save the buffer
    291c:	80 91 8b 02 	lds	r24, 0x028B
    2920:	90 91 8c 02 	lds	r25, 0x028C
    2924:	0e 94 24 0b 	call	0x1648 <DF_CopyBufferToFlashPage>

      uint32_t DataSize = ((uint32_t)CurrPageAddress * DF_INTERNALDF_BUFFBYTES) + CurrBuffByte;
    2928:	80 91 8b 02 	lds	r24, 0x028B
    292c:	90 91 8c 02 	lds	r25, 0x028C
    2930:	aa 27       	eor	r26, r26
    2932:	bb 27       	eor	r27, r27
    2934:	bc 01       	movw	r22, r24
    2936:	cd 01       	movw	r24, r26
    2938:	28 e0       	ldi	r18, 0x08	; 8
    293a:	31 e0       	ldi	r19, 0x01	; 1
    293c:	40 e0       	ldi	r20, 0x00	; 0
    293e:	50 e0       	ldi	r21, 0x00	; 0
    2940:	0e 94 84 1b 	call	0x3708 <__mulsi3>
    2944:	7b 01       	movw	r14, r22
    2946:	8c 01       	movw	r16, r24
    2948:	80 91 84 02 	lds	r24, 0x0284
    294c:	90 91 85 02 	lds	r25, 0x0285
    2950:	aa 27       	eor	r26, r26
    2952:	bb 27       	eor	r27, r27
    2954:	e8 0e       	add	r14, r24
    2956:	f9 1e       	adc	r15, r25
    2958:	0a 1f       	adc	r16, r26
    295a:	1b 1f       	adc	r17, r27

      if (MemoryType == TYPE_FLASH)
    295c:	80 91 4a 02 	lds	r24, 0x024A
    2960:	81 30       	cpi	r24, 0x01	; 1
    2962:	39 f4       	brne	.+14     	; 0x2972 <PM_CheckEndOfProgramming+0x88>
      {
         EEPROMAddress = Prog_DataSize;       
    2964:	80 91 16 01 	lds	r24, 0x0116
    2968:	90 91 17 01 	lds	r25, 0x0117
    296c:	9a 83       	std	Y+2, r25	; 0x02
    296e:	89 83       	std	Y+1, r24	; 0x01
    2970:	0e c0       	rjmp	.+28     	; 0x298e <PM_CheckEndOfProgramming+0xa4>
      }
      else
      {
         EEPROMAddress = Prog_EEPROMSize;
    2972:	80 91 14 01 	lds	r24, 0x0114
    2976:	90 91 15 01 	lds	r25, 0x0115
    297a:	9a 83       	std	Y+2, r25	; 0x02
    297c:	89 83       	std	Y+1, r24	; 0x01
         DataSize -= PM_EEPROM_OFFSET;                // Remove DataFlash starting offset
    297e:	80 e0       	ldi	r24, 0x00	; 0
    2980:	9c ef       	ldi	r25, 0xFC	; 252
    2982:	ab ef       	ldi	r26, 0xFB	; 251
    2984:	bf ef       	ldi	r27, 0xFF	; 255
    2986:	e8 0e       	add	r14, r24
    2988:	f9 1e       	adc	r15, r25
    298a:	0a 1f       	adc	r16, r26
    298c:	1b 1f       	adc	r17, r27
      }

      eeprom_write_byte_169(&EEPROMAddress, (DataSize >> 24));
    298e:	81 2f       	mov	r24, r17
    2990:	99 27       	eor	r25, r25
    2992:	aa 27       	eor	r26, r26
    2994:	bb 27       	eor	r27, r27
    2996:	68 2f       	mov	r22, r24
    2998:	ce 01       	movw	r24, r28
    299a:	01 96       	adiw	r24, 0x01	; 1
    299c:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
      EEPROMAddress++;
    29a0:	89 81       	ldd	r24, Y+1	; 0x01
    29a2:	9a 81       	ldd	r25, Y+2	; 0x02
    29a4:	01 96       	adiw	r24, 0x01	; 1
    29a6:	9a 83       	std	Y+2, r25	; 0x02
    29a8:	89 83       	std	Y+1, r24	; 0x01
      eeprom_write_byte_169(&EEPROMAddress, (DataSize >> 16));             
    29aa:	c8 01       	movw	r24, r16
    29ac:	aa 27       	eor	r26, r26
    29ae:	bb 27       	eor	r27, r27
    29b0:	68 2f       	mov	r22, r24
    29b2:	ce 01       	movw	r24, r28
    29b4:	01 96       	adiw	r24, 0x01	; 1
    29b6:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
      EEPROMAddress++;
    29ba:	89 81       	ldd	r24, Y+1	; 0x01
    29bc:	9a 81       	ldd	r25, Y+2	; 0x02
    29be:	01 96       	adiw	r24, 0x01	; 1
    29c0:	9a 83       	std	Y+2, r25	; 0x02
    29c2:	89 83       	std	Y+1, r24	; 0x01
      eeprom_write_byte_169(&EEPROMAddress, (DataSize >> 8));
    29c4:	bb 27       	eor	r27, r27
    29c6:	a1 2f       	mov	r26, r17
    29c8:	90 2f       	mov	r25, r16
    29ca:	8f 2d       	mov	r24, r15
    29cc:	68 2f       	mov	r22, r24
    29ce:	ce 01       	movw	r24, r28
    29d0:	01 96       	adiw	r24, 0x01	; 1
    29d2:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
      EEPROMAddress++;
    29d6:	89 81       	ldd	r24, Y+1	; 0x01
    29d8:	9a 81       	ldd	r25, Y+2	; 0x02
    29da:	01 96       	adiw	r24, 0x01	; 1
    29dc:	9a 83       	std	Y+2, r25	; 0x02
    29de:	89 83       	std	Y+1, r24	; 0x01
      eeprom_write_byte_169(&EEPROMAddress, DataSize);
    29e0:	6e 2d       	mov	r22, r14
    29e2:	ce 01       	movw	r24, r28
    29e4:	01 96       	adiw	r24, 0x01	; 1
    29e6:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
    29ea:	22 96       	adiw	r28, 0x02	; 2
    29ec:	0f b6       	in	r0, 0x3f	; 63
    29ee:	f8 94       	cli
    29f0:	de bf       	out	0x3e, r29	; 62
    29f2:	0f be       	out	0x3f, r0	; 63
    29f4:	cd bf       	out	0x3d, r28	; 61
    29f6:	df 91       	pop	r29
    29f8:	cf 91       	pop	r28
    29fa:	1f 91       	pop	r17
    29fc:	0f 91       	pop	r16
    29fe:	ff 90       	pop	r15
    2a00:	ef 90       	pop	r14
    2a02:	08 95       	ret

00002a04 <PM_CheckEndOfFuseLockStore>:
   }
}

void PM_CheckEndOfFuseLockStore(void)
{
    2a04:	cf 93       	push	r28
    2a06:	df 93       	push	r29
    2a08:	cd b7       	in	r28, 0x3d	; 61
    2a0a:	de b7       	in	r29, 0x3e	; 62
    2a0c:	22 97       	sbiw	r28, 0x02	; 2
    2a0e:	0f b6       	in	r0, 0x3f	; 63
    2a10:	f8 94       	cli
    2a12:	de bf       	out	0x3e, r29	; 62
    2a14:	0f be       	out	0x3f, r0	; 63
    2a16:	cd bf       	out	0x3d, r28	; 61
	uint16_t EEPROMAddress;

	if (CurrentMode == PM_LOCKFUSEBITS_WRITE)
    2a18:	80 91 49 02 	lds	r24, 0x0249
    2a1c:	83 30       	cpi	r24, 0x03	; 3
    2a1e:	a9 f4       	brne	.+42     	; 0x2a4a <PM_CheckEndOfFuseLockStore+0x46>
	{
		EEPROMAddress = ((MemoryType == TYPE_FUSE)? Prog_TotalFuseBytes : Prog_TotalLockBytes);
    2a20:	80 91 4a 02 	lds	r24, 0x024A
    2a24:	82 30       	cpi	r24, 0x02	; 2
    2a26:	29 f4       	brne	.+10     	; 0x2a32 <PM_CheckEndOfFuseLockStore+0x2e>
    2a28:	80 91 10 01 	lds	r24, 0x0110
    2a2c:	90 91 11 01 	lds	r25, 0x0111
    2a30:	04 c0       	rjmp	.+8      	; 0x2a3a <PM_CheckEndOfFuseLockStore+0x36>
    2a32:	80 91 0e 01 	lds	r24, 0x010E
    2a36:	90 91 0f 01 	lds	r25, 0x010F
    2a3a:	9a 83       	std	Y+2, r25	; 0x02
    2a3c:	89 83       	std	Y+1, r24	; 0x01
		
		eeprom_write_byte_169(&EEPROMAddress, CurrBuffByte); // CurrBuffByte stores the total number of fuse/lock bytes written in this case
    2a3e:	60 91 84 02 	lds	r22, 0x0284
    2a42:	ce 01       	movw	r24, r28
    2a44:	01 96       	adiw	r24, 0x01	; 1
    2a46:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
    2a4a:	22 96       	adiw	r28, 0x02	; 2
    2a4c:	0f b6       	in	r0, 0x3f	; 63
    2a4e:	f8 94       	cli
    2a50:	de bf       	out	0x3e, r29	; 62
    2a52:	0f be       	out	0x3f, r0	; 63
    2a54:	cd bf       	out	0x3d, r28	; 61
    2a56:	df 91       	pop	r29
    2a58:	cf 91       	pop	r28
    2a5a:	08 95       	ret

00002a5c <PM_InterpretAVRISPPacket>:
    2a5c:	af 92       	push	r10
    2a5e:	bf 92       	push	r11
    2a60:	cf 92       	push	r12
    2a62:	df 92       	push	r13
    2a64:	ef 92       	push	r14
    2a66:	ff 92       	push	r15
    2a68:	0f 93       	push	r16
    2a6a:	1f 93       	push	r17
    2a6c:	cf 93       	push	r28
    2a6e:	df 93       	push	r29
    2a70:	cd b7       	in	r28, 0x3d	; 61
    2a72:	de b7       	in	r29, 0x3e	; 62
    2a74:	22 97       	sbiw	r28, 0x02	; 2
    2a76:	0f b6       	in	r0, 0x3f	; 63
    2a78:	f8 94       	cli
    2a7a:	de bf       	out	0x3e, r29	; 62
    2a7c:	0f be       	out	0x3f, r0	; 63
    2a7e:	cd bf       	out	0x3d, r28	; 61
    2a80:	40 91 34 01 	lds	r20, 0x0134
    2a84:	84 2f       	mov	r24, r20
    2a86:	99 27       	eor	r25, r25
    2a88:	86 31       	cpi	r24, 0x16	; 22
    2a8a:	91 05       	cpc	r25, r1
    2a8c:	09 f4       	brne	.+2      	; 0x2a90 <PM_InterpretAVRISPPacket+0x34>
    2a8e:	21 c2       	rjmp	.+1090   	; 0x2ed2 <PM_InterpretAVRISPPacket+0x476>
    2a90:	87 31       	cpi	r24, 0x17	; 23
    2a92:	91 05       	cpc	r25, r1
    2a94:	94 f4       	brge	.+36     	; 0x2aba <PM_InterpretAVRISPPacket+0x5e>
    2a96:	82 31       	cpi	r24, 0x12	; 18
    2a98:	91 05       	cpc	r25, r1
    2a9a:	09 f4       	brne	.+2      	; 0x2a9e <PM_InterpretAVRISPPacket+0x42>
    2a9c:	72 c0       	rjmp	.+228    	; 0x2b82 <PM_InterpretAVRISPPacket+0x126>
    2a9e:	83 31       	cpi	r24, 0x13	; 19
    2aa0:	91 05       	cpc	r25, r1
    2aa2:	3c f4       	brge	.+14     	; 0x2ab2 <PM_InterpretAVRISPPacket+0x56>
    2aa4:	80 31       	cpi	r24, 0x10	; 16
    2aa6:	91 05       	cpc	r25, r1
    2aa8:	19 f1       	breq	.+70     	; 0x2af0 <PM_InterpretAVRISPPacket+0x94>
    2aaa:	41 97       	sbiw	r24, 0x11	; 17
    2aac:	09 f4       	brne	.+2      	; 0x2ab0 <PM_InterpretAVRISPPacket+0x54>
    2aae:	49 c0       	rjmp	.+146    	; 0x2b42 <PM_InterpretAVRISPPacket+0xe6>
    2ab0:	84 c2       	rjmp	.+1288   	; 0x2fba <PM_InterpretAVRISPPacket+0x55e>
    2ab2:	44 97       	sbiw	r24, 0x14	; 20
    2ab4:	09 f4       	brne	.+2      	; 0x2ab8 <PM_InterpretAVRISPPacket+0x5c>
    2ab6:	0d c2       	rjmp	.+1050   	; 0x2ed2 <PM_InterpretAVRISPPacket+0x476>
    2ab8:	7a c1       	rjmp	.+756    	; 0x2dae <PM_InterpretAVRISPPacket+0x352>
    2aba:	89 31       	cpi	r24, 0x19	; 25
    2abc:	91 05       	cpc	r25, r1
    2abe:	09 f4       	brne	.+2      	; 0x2ac2 <PM_InterpretAVRISPPacket+0x66>
    2ac0:	1a c1       	rjmp	.+564    	; 0x2cf6 <PM_InterpretAVRISPPacket+0x29a>
    2ac2:	8a 31       	cpi	r24, 0x1A	; 26
    2ac4:	91 05       	cpc	r25, r1
    2ac6:	44 f4       	brge	.+16     	; 0x2ad8 <PM_InterpretAVRISPPacket+0x7c>
    2ac8:	87 31       	cpi	r24, 0x17	; 23
    2aca:	91 05       	cpc	r25, r1
    2acc:	09 f4       	brne	.+2      	; 0x2ad0 <PM_InterpretAVRISPPacket+0x74>
    2ace:	13 c1       	rjmp	.+550    	; 0x2cf6 <PM_InterpretAVRISPPacket+0x29a>
    2ad0:	48 97       	sbiw	r24, 0x18	; 24
    2ad2:	09 f4       	brne	.+2      	; 0x2ad6 <PM_InterpretAVRISPPacket+0x7a>
    2ad4:	ac c0       	rjmp	.+344    	; 0x2c2e <PM_InterpretAVRISPPacket+0x1d2>
    2ad6:	71 c2       	rjmp	.+1250   	; 0x2fba <PM_InterpretAVRISPPacket+0x55e>
    2ad8:	8b 31       	cpi	r24, 0x1B	; 27
    2ada:	91 05       	cpc	r25, r1
    2adc:	09 f4       	brne	.+2      	; 0x2ae0 <PM_InterpretAVRISPPacket+0x84>
    2ade:	45 c0       	rjmp	.+138    	; 0x2b6a <PM_InterpretAVRISPPacket+0x10e>
    2ae0:	8b 31       	cpi	r24, 0x1B	; 27
    2ae2:	91 05       	cpc	r25, r1
    2ae4:	0c f4       	brge	.+2      	; 0x2ae8 <PM_InterpretAVRISPPacket+0x8c>
    2ae6:	a3 c0       	rjmp	.+326    	; 0x2c2e <PM_InterpretAVRISPPacket+0x1d2>
    2ae8:	4c 97       	sbiw	r24, 0x1c	; 28
    2aea:	09 f4       	brne	.+2      	; 0x2aee <PM_InterpretAVRISPPacket+0x92>
    2aec:	93 c0       	rjmp	.+294    	; 0x2c14 <PM_InterpretAVRISPPacket+0x1b8>
    2aee:	65 c2       	rjmp	.+1226   	; 0x2fba <PM_InterpretAVRISPPacket+0x55e>
    2af0:	82 e0       	ldi	r24, 0x02	; 2
    2af2:	90 e0       	ldi	r25, 0x00	; 0
    2af4:	90 93 31 01 	sts	0x0131, r25
    2af8:	80 93 30 01 	sts	0x0130, r24
    2afc:	80 91 12 01 	lds	r24, 0x0112
    2b00:	90 91 13 01 	lds	r25, 0x0113
    2b04:	9a 83       	std	Y+2, r25	; 0x02
    2b06:	89 83       	std	Y+1, r24	; 0x01
    2b08:	f4 e3       	ldi	r31, 0x34	; 52
    2b0a:	ef 2e       	mov	r14, r31
    2b0c:	f1 e0       	ldi	r31, 0x01	; 1
    2b0e:	ff 2e       	mov	r15, r31
    2b10:	1b e0       	ldi	r17, 0x0B	; 11
    2b12:	f7 01       	movw	r30, r14
    2b14:	61 91       	ld	r22, Z+
    2b16:	7f 01       	movw	r14, r30
    2b18:	ce 01       	movw	r24, r28
    2b1a:	01 96       	adiw	r24, 0x01	; 1
    2b1c:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
    2b20:	89 81       	ldd	r24, Y+1	; 0x01
    2b22:	9a 81       	ldd	r25, Y+2	; 0x02
    2b24:	01 96       	adiw	r24, 0x01	; 1
    2b26:	9a 83       	std	Y+2, r25	; 0x02
    2b28:	89 83       	std	Y+1, r24	; 0x01
    2b2a:	11 50       	subi	r17, 0x01	; 1
    2b2c:	17 ff       	sbrs	r17, 7
    2b2e:	f1 cf       	rjmp	.-30     	; 0x2b12 <PM_InterpretAVRISPPacket+0xb6>
    2b30:	81 e0       	ldi	r24, 0x01	; 1
    2b32:	80 93 2f 01 	sts	0x012F, r24
    2b36:	10 92 49 02 	sts	0x0249, r1
    2b3a:	81 b3       	in	r24, 0x11	; 17
    2b3c:	8f 7c       	andi	r24, 0xCF	; 207
    2b3e:	80 62       	ori	r24, 0x20	; 32
    2b40:	12 c0       	rjmp	.+36     	; 0x2b66 <PM_InterpretAVRISPPacket+0x10a>
    2b42:	82 e0       	ldi	r24, 0x02	; 2
    2b44:	90 e0       	ldi	r25, 0x00	; 0
    2b46:	90 93 31 01 	sts	0x0131, r25
    2b4a:	80 93 30 01 	sts	0x0130, r24
    2b4e:	0e 94 75 14 	call	0x28ea <PM_CheckEndOfProgramming>
    2b52:	0e 94 02 15 	call	0x2a04 <PM_CheckEndOfFuseLockStore>
    2b56:	10 92 2f 01 	sts	0x012F, r1
    2b5a:	80 e0       	ldi	r24, 0x00	; 0
    2b5c:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    2b60:	81 b3       	in	r24, 0x11	; 17
    2b62:	8f 7c       	andi	r24, 0xCF	; 207
    2b64:	80 61       	ori	r24, 0x10	; 16
    2b66:	81 bb       	out	0x11, r24	; 17
    2b68:	b1 c1       	rjmp	.+866    	; 0x2ecc <PM_InterpretAVRISPPacket+0x470>
    2b6a:	84 e0       	ldi	r24, 0x04	; 4
    2b6c:	90 e0       	ldi	r25, 0x00	; 0
    2b6e:	90 93 31 01 	sts	0x0131, r25
    2b72:	80 93 30 01 	sts	0x0130, r24
    2b76:	10 92 35 01 	sts	0x0135, r1
    2b7a:	81 e0       	ldi	r24, 0x01	; 1
    2b7c:	80 93 36 01 	sts	0x0136, r24
    2b80:	53 c0       	rjmp	.+166    	; 0x2c28 <PM_InterpretAVRISPPacket+0x1cc>
    2b82:	82 e0       	ldi	r24, 0x02	; 2
    2b84:	90 e0       	ldi	r25, 0x00	; 0
    2b86:	90 93 31 01 	sts	0x0131, r25
    2b8a:	80 93 30 01 	sts	0x0130, r24
    2b8e:	80 91 18 01 	lds	r24, 0x0118
    2b92:	90 91 19 01 	lds	r25, 0x0119
    2b96:	9a 83       	std	Y+2, r25	; 0x02
    2b98:	89 83       	std	Y+1, r24	; 0x01
    2b9a:	e5 e3       	ldi	r30, 0x35	; 53
    2b9c:	ee 2e       	mov	r14, r30
    2b9e:	e1 e0       	ldi	r30, 0x01	; 1
    2ba0:	fe 2e       	mov	r15, r30
    2ba2:	15 e0       	ldi	r17, 0x05	; 5
    2ba4:	f7 01       	movw	r30, r14
    2ba6:	61 91       	ld	r22, Z+
    2ba8:	7f 01       	movw	r14, r30
    2baa:	ce 01       	movw	r24, r28
    2bac:	01 96       	adiw	r24, 0x01	; 1
    2bae:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
    2bb2:	89 81       	ldd	r24, Y+1	; 0x01
    2bb4:	9a 81       	ldd	r25, Y+2	; 0x02
    2bb6:	01 96       	adiw	r24, 0x01	; 1
    2bb8:	9a 83       	std	Y+2, r25	; 0x02
    2bba:	89 83       	std	Y+1, r24	; 0x01
    2bbc:	11 50       	subi	r17, 0x01	; 1
    2bbe:	17 ff       	sbrs	r17, 7
    2bc0:	f1 cf       	rjmp	.-30     	; 0x2ba4 <PM_InterpretAVRISPPacket+0x148>
    2bc2:	80 91 16 01 	lds	r24, 0x0116
    2bc6:	90 91 17 01 	lds	r25, 0x0117
    2bca:	9a 83       	std	Y+2, r25	; 0x02
    2bcc:	89 83       	std	Y+1, r24	; 0x01
    2bce:	10 e0       	ldi	r17, 0x00	; 0
    2bd0:	14 30       	cpi	r17, 0x04	; 4
    2bd2:	31 f4       	brne	.+12     	; 0x2be0 <PM_InterpretAVRISPPacket+0x184>
    2bd4:	80 91 14 01 	lds	r24, 0x0114
    2bd8:	90 91 15 01 	lds	r25, 0x0115
    2bdc:	9a 83       	std	Y+2, r25	; 0x02
    2bde:	89 83       	std	Y+1, r24	; 0x01
    2be0:	60 e0       	ldi	r22, 0x00	; 0
    2be2:	ce 01       	movw	r24, r28
    2be4:	01 96       	adiw	r24, 0x01	; 1
    2be6:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
    2bea:	89 81       	ldd	r24, Y+1	; 0x01
    2bec:	9a 81       	ldd	r25, Y+2	; 0x02
    2bee:	01 96       	adiw	r24, 0x01	; 1
    2bf0:	9a 83       	std	Y+2, r25	; 0x02
    2bf2:	89 83       	std	Y+1, r24	; 0x01
    2bf4:	1f 5f       	subi	r17, 0xFF	; 255
    2bf6:	18 30       	cpi	r17, 0x08	; 8
    2bf8:	58 f3       	brcs	.-42     	; 0x2bd0 <PM_InterpretAVRISPPacket+0x174>
    2bfa:	1e ef       	ldi	r17, 0xFE	; 254
    2bfc:	81 2f       	mov	r24, r17
    2bfe:	99 27       	eor	r25, r25
    2c00:	0e 94 c4 0a 	call	0x1588 <DF_EraseBlock>
    2c04:	11 50       	subi	r17, 0x01	; 1
    2c06:	d0 f7       	brcc	.-12     	; 0x2bfc <PM_InterpretAVRISPPacket+0x1a0>
    2c08:	61 e0       	ldi	r22, 0x01	; 1
    2c0a:	8a e1       	ldi	r24, 0x1A	; 26
    2c0c:	91 e0       	ldi	r25, 0x01	; 1
    2c0e:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
    2c12:	5c c1       	rjmp	.+696    	; 0x2ecc <PM_InterpretAVRISPPacket+0x470>
    2c14:	84 e0       	ldi	r24, 0x04	; 4
    2c16:	90 e0       	ldi	r25, 0x00	; 0
    2c18:	90 93 31 01 	sts	0x0131, r25
    2c1c:	80 93 30 01 	sts	0x0130, r24
    2c20:	10 92 35 01 	sts	0x0135, r1
    2c24:	10 92 36 01 	sts	0x0136, r1
    2c28:	10 92 37 01 	sts	0x0137, r1
    2c2c:	cf c1       	rjmp	.+926    	; 0x2fcc <PM_InterpretAVRISPPacket+0x570>
    2c2e:	84 e0       	ldi	r24, 0x04	; 4
    2c30:	90 e0       	ldi	r25, 0x00	; 0
    2c32:	90 93 31 01 	sts	0x0131, r25
    2c36:	80 93 30 01 	sts	0x0130, r24
    2c3a:	80 91 49 02 	lds	r24, 0x0249
    2c3e:	84 30       	cpi	r24, 0x04	; 4
    2c40:	59 f0       	breq	.+22     	; 0x2c58 <PM_InterpretAVRISPPacket+0x1fc>
    2c42:	0e 94 75 14 	call	0x28ea <PM_CheckEndOfProgramming>
    2c46:	0e 94 02 15 	call	0x2a04 <PM_CheckEndOfFuseLockStore>
    2c4a:	10 92 85 02 	sts	0x0285, r1
    2c4e:	10 92 84 02 	sts	0x0284, r1
    2c52:	84 e0       	ldi	r24, 0x04	; 4
    2c54:	80 93 49 02 	sts	0x0249, r24
    2c58:	80 91 34 01 	lds	r24, 0x0134
    2c5c:	88 31       	cpi	r24, 0x18	; 24
    2c5e:	29 f4       	brne	.+10     	; 0x2c6a <PM_InterpretAVRISPPacket+0x20e>
    2c60:	80 91 10 01 	lds	r24, 0x0110
    2c64:	90 91 11 01 	lds	r25, 0x0111
    2c68:	04 c0       	rjmp	.+8      	; 0x2c72 <PM_InterpretAVRISPPacket+0x216>
    2c6a:	80 91 0e 01 	lds	r24, 0x010E
    2c6e:	90 91 0f 01 	lds	r25, 0x010F
    2c72:	9a 83       	std	Y+2, r25	; 0x02
    2c74:	89 83       	std	Y+1, r24	; 0x01
    2c76:	ce 01       	movw	r24, r28
    2c78:	01 96       	adiw	r24, 0x01	; 1
    2c7a:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
    2c7e:	99 27       	eor	r25, r25
    2c80:	20 91 84 02 	lds	r18, 0x0284
    2c84:	30 91 85 02 	lds	r19, 0x0285
    2c88:	82 17       	cp	r24, r18
    2c8a:	93 07       	cpc	r25, r19
    2c8c:	10 f4       	brcc	.+4      	; 0x2c92 <PM_InterpretAVRISPPacket+0x236>
    2c8e:	8f ef       	ldi	r24, 0xFF	; 255
    2c90:	22 c0       	rjmp	.+68     	; 0x2cd6 <PM_InterpretAVRISPPacket+0x27a>
    2c92:	a9 01       	movw	r20, r18
    2c94:	44 0f       	add	r20, r20
    2c96:	55 1f       	adc	r21, r21
    2c98:	44 0f       	add	r20, r20
    2c9a:	55 1f       	adc	r21, r21
    2c9c:	80 91 35 01 	lds	r24, 0x0135
    2ca0:	28 2f       	mov	r18, r24
    2ca2:	33 27       	eor	r19, r19
    2ca4:	21 50       	subi	r18, 0x01	; 1
    2ca6:	30 40       	sbci	r19, 0x00	; 0
    2ca8:	80 91 34 01 	lds	r24, 0x0134
    2cac:	88 31       	cpi	r24, 0x18	; 24
    2cae:	29 f4       	brne	.+10     	; 0x2cba <PM_InterpretAVRISPPacket+0x25e>
    2cb0:	80 91 0c 01 	lds	r24, 0x010C
    2cb4:	90 91 0d 01 	lds	r25, 0x010D
    2cb8:	04 c0       	rjmp	.+8      	; 0x2cc2 <PM_InterpretAVRISPPacket+0x266>
    2cba:	80 91 0a 01 	lds	r24, 0x010A
    2cbe:	90 91 0b 01 	lds	r25, 0x010B
    2cc2:	84 0f       	add	r24, r20
    2cc4:	95 1f       	adc	r25, r21
    2cc6:	82 0f       	add	r24, r18
    2cc8:	93 1f       	adc	r25, r19
    2cca:	9a 83       	std	Y+2, r25	; 0x02
    2ccc:	89 83       	std	Y+1, r24	; 0x01
    2cce:	ce 01       	movw	r24, r28
    2cd0:	01 96       	adiw	r24, 0x01	; 1
    2cd2:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
    2cd6:	80 93 36 01 	sts	0x0136, r24
    2cda:	10 92 35 01 	sts	0x0135, r1
    2cde:	10 92 37 01 	sts	0x0137, r1
    2ce2:	80 91 84 02 	lds	r24, 0x0284
    2ce6:	90 91 85 02 	lds	r25, 0x0285
    2cea:	01 96       	adiw	r24, 0x01	; 1
    2cec:	90 93 85 02 	sts	0x0285, r25
    2cf0:	80 93 84 02 	sts	0x0284, r24
    2cf4:	6b c1       	rjmp	.+726    	; 0x2fcc <PM_InterpretAVRISPPacket+0x570>
    2cf6:	83 e0       	ldi	r24, 0x03	; 3
    2cf8:	90 e0       	ldi	r25, 0x00	; 0
    2cfa:	90 93 31 01 	sts	0x0131, r25
    2cfe:	80 93 30 01 	sts	0x0130, r24
    2d02:	80 91 49 02 	lds	r24, 0x0249
    2d06:	83 30       	cpi	r24, 0x03	; 3
    2d08:	39 f0       	breq	.+14     	; 0x2d18 <PM_InterpretAVRISPPacket+0x2bc>
    2d0a:	83 e0       	ldi	r24, 0x03	; 3
    2d0c:	80 93 49 02 	sts	0x0249, r24
    2d10:	10 92 85 02 	sts	0x0285, r1
    2d14:	10 92 84 02 	sts	0x0284, r1
    2d18:	20 91 84 02 	lds	r18, 0x0284
    2d1c:	30 91 85 02 	lds	r19, 0x0285
    2d20:	47 31       	cpi	r20, 0x17	; 23
    2d22:	71 f4       	brne	.+28     	; 0x2d40 <PM_InterpretAVRISPPacket+0x2e4>
    2d24:	22 0f       	add	r18, r18
    2d26:	33 1f       	adc	r19, r19
    2d28:	22 0f       	add	r18, r18
    2d2a:	33 1f       	adc	r19, r19
    2d2c:	80 91 0c 01 	lds	r24, 0x010C
    2d30:	90 91 0d 01 	lds	r25, 0x010D
    2d34:	82 0f       	add	r24, r18
    2d36:	93 1f       	adc	r25, r19
    2d38:	9a 83       	std	Y+2, r25	; 0x02
    2d3a:	89 83       	std	Y+1, r24	; 0x01
    2d3c:	82 e0       	ldi	r24, 0x02	; 2
    2d3e:	0d c0       	rjmp	.+26     	; 0x2d5a <PM_InterpretAVRISPPacket+0x2fe>
    2d40:	22 0f       	add	r18, r18
    2d42:	33 1f       	adc	r19, r19
    2d44:	22 0f       	add	r18, r18
    2d46:	33 1f       	adc	r19, r19
    2d48:	80 91 0a 01 	lds	r24, 0x010A
    2d4c:	90 91 0b 01 	lds	r25, 0x010B
    2d50:	82 0f       	add	r24, r18
    2d52:	93 1f       	adc	r25, r19
    2d54:	9a 83       	std	Y+2, r25	; 0x02
    2d56:	89 83       	std	Y+1, r24	; 0x01
    2d58:	83 e0       	ldi	r24, 0x03	; 3
    2d5a:	80 93 4a 02 	sts	0x024A, r24
    2d5e:	80 91 84 02 	lds	r24, 0x0284
    2d62:	90 91 85 02 	lds	r25, 0x0285
    2d66:	0a 97       	sbiw	r24, 0x0a	; 10
    2d68:	e8 f4       	brcc	.+58     	; 0x2da4 <PM_InterpretAVRISPPacket+0x348>
    2d6a:	45 e3       	ldi	r20, 0x35	; 53
    2d6c:	e4 2e       	mov	r14, r20
    2d6e:	41 e0       	ldi	r20, 0x01	; 1
    2d70:	f4 2e       	mov	r15, r20
    2d72:	13 e0       	ldi	r17, 0x03	; 3
    2d74:	f7 01       	movw	r30, r14
    2d76:	61 91       	ld	r22, Z+
    2d78:	7f 01       	movw	r14, r30
    2d7a:	ce 01       	movw	r24, r28
    2d7c:	01 96       	adiw	r24, 0x01	; 1
    2d7e:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
    2d82:	89 81       	ldd	r24, Y+1	; 0x01
    2d84:	9a 81       	ldd	r25, Y+2	; 0x02
    2d86:	01 96       	adiw	r24, 0x01	; 1
    2d88:	9a 83       	std	Y+2, r25	; 0x02
    2d8a:	89 83       	std	Y+1, r24	; 0x01
    2d8c:	11 50       	subi	r17, 0x01	; 1
    2d8e:	17 ff       	sbrs	r17, 7
    2d90:	f1 cf       	rjmp	.-30     	; 0x2d74 <PM_InterpretAVRISPPacket+0x318>
    2d92:	80 91 84 02 	lds	r24, 0x0284
    2d96:	90 91 85 02 	lds	r25, 0x0285
    2d9a:	01 96       	adiw	r24, 0x01	; 1
    2d9c:	90 93 85 02 	sts	0x0285, r25
    2da0:	80 93 84 02 	sts	0x0284, r24
    2da4:	10 92 35 01 	sts	0x0135, r1
    2da8:	10 92 36 01 	sts	0x0136, r1
    2dac:	0f c1       	rjmp	.+542    	; 0x2fcc <PM_InterpretAVRISPPacket+0x570>
    2dae:	82 e0       	ldi	r24, 0x02	; 2
    2db0:	90 e0       	ldi	r25, 0x00	; 0
    2db2:	90 93 31 01 	sts	0x0131, r25
    2db6:	80 93 30 01 	sts	0x0130, r24
    2dba:	80 91 49 02 	lds	r24, 0x0249
    2dbe:	81 30       	cpi	r24, 0x01	; 1
    2dc0:	81 f1       	breq	.+96     	; 0x2e22 <PM_InterpretAVRISPPacket+0x3c6>
    2dc2:	43 31       	cpi	r20, 0x13	; 19
    2dc4:	41 f4       	brne	.+16     	; 0x2dd6 <PM_InterpretAVRISPPacket+0x37a>
    2dc6:	80 91 1e 01 	lds	r24, 0x011E
    2dca:	90 91 1f 01 	lds	r25, 0x011F
    2dce:	9a 83       	std	Y+2, r25	; 0x02
    2dd0:	89 83       	std	Y+1, r24	; 0x01
    2dd2:	81 e0       	ldi	r24, 0x01	; 1
    2dd4:	07 c0       	rjmp	.+14     	; 0x2de4 <PM_InterpretAVRISPPacket+0x388>
    2dd6:	80 91 1c 01 	lds	r24, 0x011C
    2dda:	90 91 1d 01 	lds	r25, 0x011D
    2dde:	9a 83       	std	Y+2, r25	; 0x02
    2de0:	89 83       	std	Y+1, r24	; 0x01
    2de2:	80 e0       	ldi	r24, 0x00	; 0
    2de4:	0e 94 f8 13 	call	0x27f0 <PM_SetupDFAddressCounters>
    2de8:	80 91 84 02 	lds	r24, 0x0284
    2dec:	90 91 85 02 	lds	r25, 0x0285
    2df0:	0e 94 5e 0a 	call	0x14bc <DF_BufferWriteEnable>
    2df4:	81 e0       	ldi	r24, 0x01	; 1
    2df6:	80 93 49 02 	sts	0x0249, r24
    2dfa:	35 e3       	ldi	r19, 0x35	; 53
    2dfc:	e3 2e       	mov	r14, r19
    2dfe:	31 e0       	ldi	r19, 0x01	; 1
    2e00:	f3 2e       	mov	r15, r19
    2e02:	18 e0       	ldi	r17, 0x08	; 8
    2e04:	f7 01       	movw	r30, r14
    2e06:	61 91       	ld	r22, Z+
    2e08:	7f 01       	movw	r14, r30
    2e0a:	ce 01       	movw	r24, r28
    2e0c:	01 96       	adiw	r24, 0x01	; 1
    2e0e:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
    2e12:	89 81       	ldd	r24, Y+1	; 0x01
    2e14:	9a 81       	ldd	r25, Y+2	; 0x02
    2e16:	01 96       	adiw	r24, 0x01	; 1
    2e18:	9a 83       	std	Y+2, r25	; 0x02
    2e1a:	89 83       	std	Y+1, r24	; 0x01
    2e1c:	11 50       	subi	r17, 0x01	; 1
    2e1e:	17 ff       	sbrs	r17, 7
    2e20:	f1 cf       	rjmp	.-30     	; 0x2e04 <PM_InterpretAVRISPPacket+0x3a8>
    2e22:	80 91 35 01 	lds	r24, 0x0135
    2e26:	99 27       	eor	r25, r25
    2e28:	18 2f       	mov	r17, r24
    2e2a:	00 27       	eor	r16, r16
    2e2c:	80 91 36 01 	lds	r24, 0x0136
    2e30:	99 27       	eor	r25, r25
    2e32:	08 2b       	or	r16, r24
    2e34:	19 2b       	or	r17, r25
    2e36:	ee 24       	eor	r14, r14
    2e38:	ff 24       	eor	r15, r15
    2e3a:	e0 16       	cp	r14, r16
    2e3c:	f1 06       	cpc	r15, r17
    2e3e:	78 f4       	brcc	.+30     	; 0x2e5e <PM_InterpretAVRISPPacket+0x402>
    2e40:	8e e3       	ldi	r24, 0x3E	; 62
    2e42:	c8 2e       	mov	r12, r24
    2e44:	81 e0       	ldi	r24, 0x01	; 1
    2e46:	d8 2e       	mov	r13, r24
    2e48:	f6 01       	movw	r30, r12
    2e4a:	81 91       	ld	r24, Z+
    2e4c:	6f 01       	movw	r12, r30
    2e4e:	0e 94 3a 14 	call	0x2874 <PM_StoreProgramByte>
    2e52:	08 94       	sec
    2e54:	e1 1c       	adc	r14, r1
    2e56:	f1 1c       	adc	r15, r1
    2e58:	e0 16       	cp	r14, r16
    2e5a:	f1 06       	cpc	r15, r17
    2e5c:	a8 f3       	brcs	.-22     	; 0x2e48 <PM_InterpretAVRISPPacket+0x3ec>
    2e5e:	40 91 47 02 	lds	r20, 0x0247
    2e62:	50 91 48 02 	lds	r21, 0x0248
    2e66:	57 fd       	sbrc	r21, 7
    2e68:	31 c0       	rjmp	.+98     	; 0x2ecc <PM_InterpretAVRISPPacket+0x470>
    2e6a:	80 91 37 01 	lds	r24, 0x0137
    2e6e:	87 ff       	sbrs	r24, 7
    2e70:	2d c0       	rjmp	.+90     	; 0x2ecc <PM_InterpretAVRISPPacket+0x470>
    2e72:	41 15       	cp	r20, r1
    2e74:	51 05       	cpc	r21, r1
    2e76:	51 f1       	breq	.+84     	; 0x2ecc <PM_InterpretAVRISPPacket+0x470>
    2e78:	80 91 4a 02 	lds	r24, 0x024A
    2e7c:	81 30       	cpi	r24, 0x01	; 1
    2e7e:	29 f4       	brne	.+10     	; 0x2e8a <PM_InterpretAVRISPPacket+0x42e>
    2e80:	20 91 08 01 	lds	r18, 0x0108
    2e84:	30 91 09 01 	lds	r19, 0x0109
    2e88:	04 c0       	rjmp	.+8      	; 0x2e92 <PM_InterpretAVRISPPacket+0x436>
    2e8a:	20 91 06 01 	lds	r18, 0x0106
    2e8e:	30 91 07 01 	lds	r19, 0x0107
    2e92:	3a 83       	std	Y+2, r19	; 0x02
    2e94:	29 83       	std	Y+1, r18	; 0x01
    2e96:	85 2f       	mov	r24, r21
    2e98:	99 27       	eor	r25, r25
    2e9a:	68 2f       	mov	r22, r24
    2e9c:	ce 01       	movw	r24, r28
    2e9e:	01 96       	adiw	r24, 0x01	; 1
    2ea0:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
    2ea4:	89 81       	ldd	r24, Y+1	; 0x01
    2ea6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ea8:	01 96       	adiw	r24, 0x01	; 1
    2eaa:	9a 83       	std	Y+2, r25	; 0x02
    2eac:	89 83       	std	Y+1, r24	; 0x01
    2eae:	60 91 47 02 	lds	r22, 0x0247
    2eb2:	ce 01       	movw	r24, r28
    2eb4:	01 96       	adiw	r24, 0x01	; 1
    2eb6:	0e 94 c4 08 	call	0x1188 <eeprom_write_byte_169>
    2eba:	80 91 47 02 	lds	r24, 0x0247
    2ebe:	90 91 48 02 	lds	r25, 0x0248
    2ec2:	90 68       	ori	r25, 0x80	; 128
    2ec4:	90 93 48 02 	sts	0x0248, r25
    2ec8:	80 93 47 02 	sts	0x0247, r24
    2ecc:	10 92 35 01 	sts	0x0135, r1
    2ed0:	7d c0       	rjmp	.+250    	; 0x2fcc <PM_InterpretAVRISPPacket+0x570>
    2ed2:	80 91 49 02 	lds	r24, 0x0249
    2ed6:	82 30       	cpi	r24, 0x02	; 2
    2ed8:	11 f1       	breq	.+68     	; 0x2f1e <PM_InterpretAVRISPPacket+0x4c2>
    2eda:	0e 94 75 14 	call	0x28ea <PM_CheckEndOfProgramming>
    2ede:	0e 94 02 15 	call	0x2a04 <PM_CheckEndOfFuseLockStore>
    2ee2:	90 e0       	ldi	r25, 0x00	; 0
    2ee4:	80 91 34 01 	lds	r24, 0x0134
    2ee8:	84 31       	cpi	r24, 0x14	; 20
    2eea:	09 f4       	brne	.+2      	; 0x2eee <PM_InterpretAVRISPPacket+0x492>
    2eec:	91 e0       	ldi	r25, 0x01	; 1
    2eee:	89 2f       	mov	r24, r25
    2ef0:	0e 94 f8 13 	call	0x27f0 <PM_SetupDFAddressCounters>
    2ef4:	60 91 84 02 	lds	r22, 0x0284
    2ef8:	70 91 85 02 	lds	r23, 0x0285
    2efc:	80 91 8b 02 	lds	r24, 0x028B
    2f00:	90 91 8c 02 	lds	r25, 0x028C
    2f04:	0e 94 1b 0a 	call	0x1436 <DF_ContinuousReadEnable>
    2f08:	82 e0       	ldi	r24, 0x02	; 2
    2f0a:	80 93 49 02 	sts	0x0249, r24
    2f0e:	10 92 2b 01 	sts	0x012B, r1
    2f12:	10 92 2c 01 	sts	0x012C, r1
    2f16:	10 92 2d 01 	sts	0x012D, r1
    2f1a:	10 92 2e 01 	sts	0x012E, r1
    2f1e:	80 91 35 01 	lds	r24, 0x0135
    2f22:	99 27       	eor	r25, r25
    2f24:	18 2f       	mov	r17, r24
    2f26:	00 27       	eor	r16, r16
    2f28:	80 91 36 01 	lds	r24, 0x0136
    2f2c:	99 27       	eor	r25, r25
    2f2e:	08 2b       	or	r16, r24
    2f30:	19 2b       	or	r17, r25
    2f32:	90 e0       	ldi	r25, 0x00	; 0
    2f34:	80 91 34 01 	lds	r24, 0x0134
    2f38:	84 31       	cpi	r24, 0x14	; 20
    2f3a:	09 f4       	brne	.+2      	; 0x2f3e <PM_InterpretAVRISPPacket+0x4e2>
    2f3c:	91 e0       	ldi	r25, 0x01	; 1
    2f3e:	89 2f       	mov	r24, r25
    2f40:	0e 94 80 13 	call	0x2700 <PM_GetStoredDataSize>
    2f44:	dc 01       	movw	r26, r24
    2f46:	cb 01       	movw	r24, r22
    2f48:	6c 01       	movw	r12, r24
    2f4a:	ee 24       	eor	r14, r14
    2f4c:	ff 24       	eor	r15, r15
    2f4e:	e0 16       	cp	r14, r16
    2f50:	f1 06       	cpc	r15, r17
    2f52:	20 f5       	brcc	.+72     	; 0x2f9c <PM_InterpretAVRISPPacket+0x540>
    2f54:	f6 e3       	ldi	r31, 0x36	; 54
    2f56:	af 2e       	mov	r10, r31
    2f58:	f1 e0       	ldi	r31, 0x01	; 1
    2f5a:	bf 2e       	mov	r11, r31
    2f5c:	96 01       	movw	r18, r12
    2f5e:	44 27       	eor	r20, r20
    2f60:	55 27       	eor	r21, r21
    2f62:	80 91 2b 01 	lds	r24, 0x012B
    2f66:	90 91 2c 01 	lds	r25, 0x012C
    2f6a:	a0 91 2d 01 	lds	r26, 0x012D
    2f6e:	b0 91 2e 01 	lds	r27, 0x012E
    2f72:	82 17       	cp	r24, r18
    2f74:	93 07       	cpc	r25, r19
    2f76:	a4 07       	cpc	r26, r20
    2f78:	b5 07       	cpc	r27, r21
    2f7a:	20 f4       	brcc	.+8      	; 0x2f84 <PM_InterpretAVRISPPacket+0x528>
    2f7c:	80 e0       	ldi	r24, 0x00	; 0
    2f7e:	0e 94 42 09 	call	0x1284 <SPI_SPITransmit>
    2f82:	01 c0       	rjmp	.+2      	; 0x2f86 <PM_InterpretAVRISPPacket+0x52a>
    2f84:	8f ef       	ldi	r24, 0xFF	; 255
    2f86:	f5 01       	movw	r30, r10
    2f88:	81 93       	st	Z+, r24
    2f8a:	5f 01       	movw	r10, r30
    2f8c:	0e 94 c3 0e 	call	0x1d86 <V2P_IncrementCurrAddress>
    2f90:	08 94       	sec
    2f92:	e1 1c       	adc	r14, r1
    2f94:	f1 1c       	adc	r15, r1
    2f96:	e0 16       	cp	r14, r16
    2f98:	f1 06       	cpc	r15, r17
    2f9a:	00 f3       	brcs	.-64     	; 0x2f5c <PM_InterpretAVRISPPacket+0x500>
    2f9c:	0d 5f       	subi	r16, 0xFD	; 253
    2f9e:	1f 4f       	sbci	r17, 0xFF	; 255
    2fa0:	10 93 31 01 	sts	0x0131, r17
    2fa4:	00 93 30 01 	sts	0x0130, r16
    2fa8:	03 50       	subi	r16, 0x03	; 3
    2faa:	10 40       	sbci	r17, 0x00	; 0
    2fac:	10 92 35 01 	sts	0x0135, r1
    2fb0:	0c 5c       	subi	r16, 0xCC	; 204
    2fb2:	1e 4f       	sbci	r17, 0xFE	; 254
    2fb4:	f8 01       	movw	r30, r16
    2fb6:	12 82       	std	Z+2, r1	; 0x02
    2fb8:	09 c0       	rjmp	.+18     	; 0x2fcc <PM_InterpretAVRISPPacket+0x570>
    2fba:	81 e0       	ldi	r24, 0x01	; 1
    2fbc:	90 e0       	ldi	r25, 0x00	; 0
    2fbe:	90 93 31 01 	sts	0x0131, r25
    2fc2:	80 93 30 01 	sts	0x0130, r24
    2fc6:	89 ec       	ldi	r24, 0xC9	; 201
    2fc8:	80 93 35 01 	sts	0x0135, r24
    2fcc:	0e 94 e9 0d 	call	0x1bd2 <V2P_SendPacket>
    2fd0:	22 96       	adiw	r28, 0x02	; 2
    2fd2:	0f b6       	in	r0, 0x3f	; 63
    2fd4:	f8 94       	cli
    2fd6:	de bf       	out	0x3e, r29	; 62
    2fd8:	0f be       	out	0x3f, r0	; 63
    2fda:	cd bf       	out	0x3d, r28	; 61
    2fdc:	df 91       	pop	r29
    2fde:	cf 91       	pop	r28
    2fe0:	1f 91       	pop	r17
    2fe2:	0f 91       	pop	r16
    2fe4:	ff 90       	pop	r15
    2fe6:	ef 90       	pop	r14
    2fe8:	df 90       	pop	r13
    2fea:	cf 90       	pop	r12
    2fec:	bf 90       	pop	r11
    2fee:	af 90       	pop	r10
    2ff0:	08 95       	ret

00002ff2 <PM_SendFuseLockBytes>:
	}
}

void PM_SendFuseLockBytes(uint8_t Type)
{
    2ff2:	0f 93       	push	r16
    2ff4:	1f 93       	push	r17
    2ff6:	cf 93       	push	r28
    2ff8:	df 93       	push	r29
    2ffa:	cd b7       	in	r28, 0x3d	; 61
    2ffc:	de b7       	in	r29, 0x3e	; 62
    2ffe:	22 97       	sbiw	r28, 0x02	; 2
    3000:	0f b6       	in	r0, 0x3f	; 63
    3002:	f8 94       	cli
    3004:	de bf       	out	0x3e, r29	; 62
    3006:	0f be       	out	0x3f, r0	; 63
    3008:	cd bf       	out	0x3d, r28	; 61
    300a:	08 2f       	mov	r16, r24
	uint16_t EEPROMAddress;
	uint8_t  TotalBytes;
	
	EEPROMAddress = ((Type == TYPE_FUSE)? Prog_TotalFuseBytes : Prog_TotalLockBytes);
    300c:	82 30       	cpi	r24, 0x02	; 2
    300e:	29 f4       	brne	.+10     	; 0x301a <PM_SendFuseLockBytes+0x28>
    3010:	80 91 10 01 	lds	r24, 0x0110
    3014:	90 91 11 01 	lds	r25, 0x0111
    3018:	04 c0       	rjmp	.+8      	; 0x3022 <PM_SendFuseLockBytes+0x30>
    301a:	80 91 0e 01 	lds	r24, 0x010E
    301e:	90 91 0f 01 	lds	r25, 0x010F
    3022:	9a 83       	std	Y+2, r25	; 0x02
    3024:	89 83       	std	Y+1, r24	; 0x01

	TotalBytes = eeprom_read_byte_169(&EEPROMAddress); // Get the total number of stored fuse/lock bytes
    3026:	ce 01       	movw	r24, r28
    3028:	01 96       	adiw	r24, 0x01	; 1
    302a:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
    302e:	18 2f       	mov	r17, r24
			
	EEPROMAddress = ((Type == TYPE_FUSE)? Prog_FuseBytes : Prog_LockBytes); // Set the EEPROM pointer to the fuse/lock bytes start (each fuse or lock byte takes four bytes in EEPROM)
    3030:	02 30       	cpi	r16, 0x02	; 2
    3032:	29 f4       	brne	.+10     	; 0x303e <PM_SendFuseLockBytes+0x4c>
    3034:	80 91 0c 01 	lds	r24, 0x010C
    3038:	90 91 0d 01 	lds	r25, 0x010D
    303c:	04 c0       	rjmp	.+8      	; 0x3046 <PM_SendFuseLockBytes+0x54>
    303e:	80 91 0a 01 	lds	r24, 0x010A
    3042:	90 91 0b 01 	lds	r25, 0x010B
    3046:	9a 83       	std	Y+2, r25	; 0x02
    3048:	89 83       	std	Y+1, r24	; 0x01

	while (TotalBytes--)                              // Write each of the fuse/lock bytes stored in memory to the slave AVR
	{
		for (uint8_t CommandByte = 0; CommandByte < 4; CommandByte++)      // Write each individual command byte
		{
			USI_SPITransmit(eeprom_read_byte_169(&EEPROMAddress));
			EEPROMAddress++;
		}
		
		// Add some delay before programming next byte, if there is one:
		if (TotalBytes)
		   MAIN_Delay10MS(5);
    304a:	11 50       	subi	r17, 0x01	; 1
    304c:	1f 3f       	cpi	r17, 0xFF	; 255
    304e:	b1 f0       	breq	.+44     	; 0x307c <PM_SendFuseLockBytes+0x8a>
    3050:	03 e0       	ldi	r16, 0x03	; 3
    3052:	ce 01       	movw	r24, r28
    3054:	01 96       	adiw	r24, 0x01	; 1
    3056:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
    305a:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    305e:	89 81       	ldd	r24, Y+1	; 0x01
    3060:	9a 81       	ldd	r25, Y+2	; 0x02
    3062:	01 96       	adiw	r24, 0x01	; 1
    3064:	9a 83       	std	Y+2, r25	; 0x02
    3066:	89 83       	std	Y+1, r24	; 0x01
    3068:	01 50       	subi	r16, 0x01	; 1
    306a:	07 ff       	sbrs	r16, 7
    306c:	f2 cf       	rjmp	.-28     	; 0x3052 <PM_SendFuseLockBytes+0x60>
    306e:	11 23       	and	r17, r17
    3070:	19 f0       	breq	.+6      	; 0x3078 <PM_SendFuseLockBytes+0x86>
    3072:	85 e0       	ldi	r24, 0x05	; 5
    3074:	0e 94 2f 02 	call	0x45e <MAIN_Delay10MS>
    3078:	11 50       	subi	r17, 0x01	; 1
    307a:	50 f7       	brcc	.-44     	; 0x3050 <PM_SendFuseLockBytes+0x5e>
    307c:	22 96       	adiw	r28, 0x02	; 2
    307e:	0f b6       	in	r0, 0x3f	; 63
    3080:	f8 94       	cli
    3082:	de bf       	out	0x3e, r29	; 62
    3084:	0f be       	out	0x3f, r0	; 63
    3086:	cd bf       	out	0x3d, r28	; 61
    3088:	df 91       	pop	r29
    308a:	cf 91       	pop	r28
    308c:	1f 91       	pop	r17
    308e:	0f 91       	pop	r16
    3090:	08 95       	ret

00003092 <PM_SendEraseCommand>:
	}
}

void PM_SendEraseCommand(void)
{
    3092:	0f 93       	push	r16
    3094:	1f 93       	push	r17
    3096:	cf 93       	push	r28
    3098:	df 93       	push	r29
    309a:	cd b7       	in	r28, 0x3d	; 61
    309c:	de b7       	in	r29, 0x3e	; 62
    309e:	22 97       	sbiw	r28, 0x02	; 2
    30a0:	0f b6       	in	r0, 0x3f	; 63
    30a2:	f8 94       	cli
    30a4:	de bf       	out	0x3e, r29	; 62
    30a6:	0f be       	out	0x3f, r0	; 63
    30a8:	cd bf       	out	0x3d, r28	; 61
	uint16_t EEPROMAddress;

	EEPROMAddress = Prog_EraseChip + 2;               // Start of the erase commands
    30aa:	80 91 18 01 	lds	r24, 0x0118
    30ae:	90 91 19 01 	lds	r25, 0x0119
    30b2:	02 96       	adiw	r24, 0x02	; 2
    30b4:	9a 83       	std	Y+2, r25	; 0x02
    30b6:	89 83       	std	Y+1, r24	; 0x01
    30b8:	13 e0       	ldi	r17, 0x03	; 3
			
	for (uint8_t B = 0; B < 4 ; B++)                  // Read out the erase chip command bytes
	{
		USI_SPITransmit(eeprom_read_byte_169(&EEPROMAddress)); // Send the erase chip commands
    30ba:	ce 01       	movw	r24, r28
    30bc:	01 96       	adiw	r24, 0x01	; 1
    30be:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
    30c2:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
		EEPROMAddress++;
    30c6:	89 81       	ldd	r24, Y+1	; 0x01
    30c8:	9a 81       	ldd	r25, Y+2	; 0x02
    30ca:	01 96       	adiw	r24, 0x01	; 1
    30cc:	9a 83       	std	Y+2, r25	; 0x02
    30ce:	89 83       	std	Y+1, r24	; 0x01
    30d0:	11 50       	subi	r17, 0x01	; 1
    30d2:	17 ff       	sbrs	r17, 7
    30d4:	f2 cf       	rjmp	.-28     	; 0x30ba <PM_SendEraseCommand+0x28>
	}
			
	EEPROMAddress = Prog_EraseChip + 1;               // Poll mode flag address
    30d6:	00 91 18 01 	lds	r16, 0x0118
    30da:	10 91 19 01 	lds	r17, 0x0119
    30de:	0f 5f       	subi	r16, 0xFF	; 255
    30e0:	1f 4f       	sbci	r17, 0xFF	; 255
    30e2:	1a 83       	std	Y+2, r17	; 0x02
    30e4:	09 83       	std	Y+1, r16	; 0x01
    30e6:	01 50       	subi	r16, 0x01	; 1
    30e8:	10 40       	sbci	r17, 0x00	; 0
	if (eeprom_read_byte_169(&EEPROMAddress))         // Value of 1 indicates a busy flag test
    30ea:	ce 01       	movw	r24, r28
    30ec:	01 96       	adiw	r24, 0x01	; 1
    30ee:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
    30f2:	88 23       	and	r24, r24
    30f4:	59 f0       	breq	.+22     	; 0x310c <PM_SendEraseCommand+0x7a>
	{
		do
			USI_SPITransmitWord(0xF000);
    30f6:	80 e0       	ldi	r24, 0x00	; 0
    30f8:	90 ef       	ldi	r25, 0xF0	; 240
    30fa:	0e 94 ba 09 	call	0x1374 <USI_SPITransmitWord>
    30fe:	80 e0       	ldi	r24, 0x00	; 0
    3100:	90 e0       	ldi	r25, 0x00	; 0
    3102:	0e 94 ba 09 	call	0x1374 <USI_SPITransmitWord>
    3106:	80 fd       	sbrc	r24, 0
    3108:	f6 cf       	rjmp	.-20     	; 0x30f6 <PM_SendEraseCommand+0x64>
    310a:	08 c0       	rjmp	.+16     	; 0x311c <PM_SendEraseCommand+0x8a>
		while (USI_SPITransmitWord(0x0000) & 0x01);
	}
	else                                              // Cleared flag means use a predefined delay
	{
		EEPROMAddress = Prog_EraseChip;               // Delay value address			
    310c:	1a 83       	std	Y+2, r17	; 0x02
    310e:	09 83       	std	Y+1, r16	; 0x01
		MAIN_Delay1MS(eeprom_read_byte_169(&EEPROMAddress)); // Wait the erase delay
    3110:	ce 01       	movw	r24, r28
    3112:	01 96       	adiw	r24, 0x01	; 1
    3114:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
    3118:	0e 94 09 03 	call	0x612 <MAIN_Delay1MS>
    311c:	22 96       	adiw	r28, 0x02	; 2
    311e:	0f b6       	in	r0, 0x3f	; 63
    3120:	f8 94       	cli
    3122:	de bf       	out	0x3e, r29	; 62
    3124:	0f be       	out	0x3f, r0	; 63
    3126:	cd bf       	out	0x3d, r28	; 61
    3128:	df 91       	pop	r29
    312a:	cf 91       	pop	r28
    312c:	1f 91       	pop	r17
    312e:	0f 91       	pop	r16
    3130:	08 95       	ret

00003132 <PM_CreateProgrammingPackets>:
	}
}

void PM_CreateProgrammingPackets(uint8_t Type)
{			
    3132:	2f 92       	push	r2
    3134:	3f 92       	push	r3
    3136:	4f 92       	push	r4
    3138:	5f 92       	push	r5
    313a:	6f 92       	push	r6
    313c:	7f 92       	push	r7
    313e:	8f 92       	push	r8
    3140:	9f 92       	push	r9
    3142:	af 92       	push	r10
    3144:	bf 92       	push	r11
    3146:	cf 92       	push	r12
    3148:	df 92       	push	r13
    314a:	ef 92       	push	r14
    314c:	ff 92       	push	r15
    314e:	0f 93       	push	r16
    3150:	1f 93       	push	r17
    3152:	cf 93       	push	r28
    3154:	df 93       	push	r29
    3156:	cd b7       	in	r28, 0x3d	; 61
    3158:	de b7       	in	r29, 0x3e	; 62
    315a:	23 97       	sbiw	r28, 0x03	; 3
    315c:	0f b6       	in	r0, 0x3f	; 63
    315e:	f8 94       	cli
    3160:	de bf       	out	0x3e, r29	; 62
    3162:	0f be       	out	0x3f, r0	; 63
    3164:	cd bf       	out	0x3d, r28	; 61
    3166:	18 2f       	mov	r17, r24
	uint32_t BytesRead       = 0;
    3168:	88 24       	eor	r8, r8
    316a:	99 24       	eor	r9, r9
    316c:	54 01       	movw	r10, r8
	uint32_t BytesToRead     = PM_GetStoredDataSize(Type);      // Get the byte size of the stored program
    316e:	0e 94 80 13 	call	0x2700 <PM_GetStoredDataSize>
    3172:	1b 01       	movw	r2, r22
    3174:	2c 01       	movw	r4, r24
	uint16_t BytesPerProgram;
	uint16_t EEPROMAddress;
	uint16_t PageLength;
	uint8_t  ContinuedPage   = FALSE;
    3176:	1b 82       	std	Y+3, r1	; 0x03

	EEPROMAddress = ((Type == TYPE_FLASH)? Prog_PageLength : Prog_EPageLength);
    3178:	11 30       	cpi	r17, 0x01	; 1
    317a:	29 f4       	brne	.+10     	; 0x3186 <PM_CreateProgrammingPackets+0x54>
    317c:	80 91 08 01 	lds	r24, 0x0108
    3180:	90 91 09 01 	lds	r25, 0x0109
    3184:	04 c0       	rjmp	.+8      	; 0x318e <PM_CreateProgrammingPackets+0x5c>
    3186:	80 91 06 01 	lds	r24, 0x0106
    318a:	90 91 07 01 	lds	r25, 0x0107
    318e:	9a 83       	std	Y+2, r25	; 0x02
    3190:	89 83       	std	Y+1, r24	; 0x01
	PageLength    = ((uint16_t)eeprom_read_byte_169(&EEPROMAddress) << 8);
    3192:	ce 01       	movw	r24, r28
    3194:	01 96       	adiw	r24, 0x01	; 1
    3196:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
    319a:	99 27       	eor	r25, r25
    319c:	78 2e       	mov	r7, r24
    319e:	66 24       	eor	r6, r6
	EEPROMAddress++;
    31a0:	89 81       	ldd	r24, Y+1	; 0x01
    31a2:	9a 81       	ldd	r25, Y+2	; 0x02
    31a4:	01 96       	adiw	r24, 0x01	; 1
    31a6:	9a 83       	std	Y+2, r25	; 0x02
    31a8:	89 83       	std	Y+1, r24	; 0x01
	PageLength   |= (eeprom_read_byte_169(&EEPROMAddress));
    31aa:	ce 01       	movw	r24, r28
    31ac:	01 96       	adiw	r24, 0x01	; 1
    31ae:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
    31b2:	99 27       	eor	r25, r25
    31b4:	68 2a       	or	r6, r24
    31b6:	79 2a       	or	r7, r25
	
	CurrAddress = 0;
    31b8:	10 92 2b 01 	sts	0x012B, r1
    31bc:	10 92 2c 01 	sts	0x012C, r1
    31c0:	10 92 2d 01 	sts	0x012D, r1
    31c4:	10 92 2e 01 	sts	0x012E, r1

	if (Type == TYPE_FLASH)
    31c8:	11 30       	cpi	r17, 0x01	; 1
    31ca:	69 f4       	brne	.+26     	; 0x31e6 <PM_CreateProgrammingPackets+0xb4>
	{
		EEPROMAddress = Prog_WriteProgram;             // Set the EEPROM pointer to the write flash command bytes location
    31cc:	80 91 1e 01 	lds	r24, 0x011E
    31d0:	90 91 1f 01 	lds	r25, 0x011F
    31d4:	9a 83       	std	Y+2, r25	; 0x02
    31d6:	89 83       	std	Y+1, r24	; 0x01
		DF_ContinuousReadEnable(0, 0);
    31d8:	60 e0       	ldi	r22, 0x00	; 0
    31da:	70 e0       	ldi	r23, 0x00	; 0
    31dc:	cb 01       	movw	r24, r22
    31de:	0e 94 1b 0a 	call	0x1436 <DF_ContinuousReadEnable>
		PacketBytes[0] = CMD_PROGRAM_FLASH_ISP;
    31e2:	83 e1       	ldi	r24, 0x13	; 19
    31e4:	0d c0       	rjmp	.+26     	; 0x3200 <PM_CreateProgrammingPackets+0xce>
	}
	else
	{
		EEPROMAddress = Prog_WriteEEPROM;              // Set the EEPROM pointer to the write EEPROM command bytes location
    31e6:	80 91 1c 01 	lds	r24, 0x011C
    31ea:	90 91 1d 01 	lds	r25, 0x011D
    31ee:	9a 83       	std	Y+2, r25	; 0x02
    31f0:	89 83       	std	Y+1, r24	; 0x01
		DF_ContinuousReadEnable(PM_EEPROM_OFFSET / DF_INTERNALDF_BUFFBYTES, PM_EEPROM_OFFSET % DF_INTERNALDF_BUFFBYTES); // Start read from the EEPROM offset location
    31f2:	60 ee       	ldi	r22, 0xE0	; 224
    31f4:	70 e0       	ldi	r23, 0x00	; 0
    31f6:	84 ee       	ldi	r24, 0xE4	; 228
    31f8:	93 e0       	ldi	r25, 0x03	; 3
    31fa:	0e 94 1b 0a 	call	0x1436 <DF_ContinuousReadEnable>
		PacketBytes[0] = CMD_PROGRAM_EEPROM_ISP;
    31fe:	85 e1       	ldi	r24, 0x15	; 21
    3200:	80 93 34 01 	sts	0x0134, r24
    3204:	f5 e3       	ldi	r31, 0x35	; 53
    3206:	ef 2e       	mov	r14, r31
    3208:	f1 e0       	ldi	r31, 0x01	; 1
    320a:	ff 2e       	mov	r15, r31
    320c:	18 e0       	ldi	r17, 0x08	; 8
	}

	for (uint8_t B = 1; B <= 9 ; B++)                 // Load in the write data command bytes
	{
		PacketBytes[B] = eeprom_read_byte_169(&EEPROMAddress); // Synthesise a write packet header
    320e:	ce 01       	movw	r24, r28
    3210:	01 96       	adiw	r24, 0x01	; 1
    3212:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
    3216:	f7 01       	movw	r30, r14
    3218:	81 93       	st	Z+, r24
    321a:	7f 01       	movw	r14, r30
		EEPROMAddress++;                               // Increment the EEPROM location counter
    321c:	89 81       	ldd	r24, Y+1	; 0x01
    321e:	9a 81       	ldd	r25, Y+2	; 0x02
    3220:	01 96       	adiw	r24, 0x01	; 1
    3222:	9a 83       	std	Y+2, r25	; 0x02
    3224:	89 83       	std	Y+1, r24	; 0x01
    3226:	11 50       	subi	r17, 0x01	; 1
    3228:	17 ff       	sbrs	r17, 7
    322a:	f1 cf       	rjmp	.-30     	; 0x320e <PM_CreateProgrammingPackets+0xdc>
	}
	
	BytesPerProgram = ((uint16_t)PacketBytes[1] << 8)
    322c:	80 91 35 01 	lds	r24, 0x0135
    3230:	99 27       	eor	r25, r25
    3232:	d8 2e       	mov	r13, r24
    3234:	cc 24       	eor	r12, r12
    3236:	80 91 36 01 	lds	r24, 0x0136
    323a:	99 27       	eor	r25, r25
    323c:	c8 2a       	or	r12, r24
    323e:	d9 2a       	or	r13, r25
	                | PacketBytes[2];

	while (BytesRead < BytesToRead)
	{
		if (PacketBytes[3] & ISPCC_PROG_MODE_PAGE)
		{
			if (PageLength > 160) // Max 160 bytes at a time
			{
				if (!(ContinuedPage))                      // Start of a new page, program in the first 150 bytes
				{
					BytesPerProgram = 160;
					PacketBytes[3] &= ~ISPCC_PROG_MODE_PAGEDONE;		
					ContinuedPage = TRUE;
				}
				else                                       // Middle of a page, program in the remainder
				{
					BytesPerProgram = PageLength - 160;
					PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
					ContinuedPage = FALSE;
				}
				
				for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page				

				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);
				PacketBytes[2] = (uint8_t)(BytesPerProgram);

				BytesRead += BytesPerProgram;                         // Increment the counter
			}
			else
			{
				for (uint16_t LoadB = 0; LoadB < PageLength; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page
			
				PacketBytes[1]  = (uint8_t)(PageLength >> 8);
				PacketBytes[2]  = (uint8_t)(PageLength);
				PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;

				BytesRead     += PageLength;                          // Increment the counter
			}
		}
		else
		{
			if ((BytesRead + BytesPerProgram) > BytesToRead)        // Less than a whole BytesPerProgram left of data to write
			{
				BytesPerProgram = BytesToRead - BytesRead;          // Next lot of bytes will be the remaining data length
				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);   // \. Save the new length
				PacketBytes[2] = (uint8_t)(BytesPerProgram);        // /  into the data packet
			}

			for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
				PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);    // Load in the page
			
			BytesRead += BytesPerProgram;                           // Increment the counter
		}
	
		if (!(BytesRead & 0xFFFF) && (BytesRead & 0x00FF0000))      // Extended address required
		{
			USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);            // Load extended address command
			USI_SPITransmit(0x00);
			USI_SPITransmit((BytesRead & 0x00FF0000) >> 16);        // The 3rd byte of the long holds the extended address
			USI_SPITransmit(0x00);
		}

		ISPCC_ProgramChip();                                        // Start the program cycle
    3240:	82 14       	cp	r8, r2
    3242:	93 04       	cpc	r9, r3
    3244:	a4 04       	cpc	r10, r4
    3246:	b5 04       	cpc	r11, r5
    3248:	08 f0       	brcs	.+2      	; 0x324c <PM_CreateProgrammingPackets+0x11a>
    324a:	b7 c0       	rjmp	.+366    	; 0x33ba <PM_CreateProgrammingPackets+0x288>
    324c:	20 91 37 01 	lds	r18, 0x0137
    3250:	82 2f       	mov	r24, r18
    3252:	99 27       	eor	r25, r25
    3254:	ac 01       	movw	r20, r24
    3256:	41 70       	andi	r20, 0x01	; 1
    3258:	50 70       	andi	r21, 0x00	; 0
    325a:	80 ff       	sbrs	r24, 0
    325c:	58 c0       	rjmp	.+176    	; 0x330e <PM_CreateProgrammingPackets+0x1dc>
    325e:	f1 ea       	ldi	r31, 0xA1	; 161
    3260:	6f 16       	cp	r6, r31
    3262:	71 04       	cpc	r7, r1
    3264:	88 f1       	brcs	.+98     	; 0x32c8 <PM_CreateProgrammingPackets+0x196>
    3266:	8b 81       	ldd	r24, Y+3	; 0x03
    3268:	88 23       	and	r24, r24
    326a:	49 f4       	brne	.+18     	; 0x327e <PM_CreateProgrammingPackets+0x14c>
    326c:	70 ea       	ldi	r23, 0xA0	; 160
    326e:	c7 2e       	mov	r12, r23
    3270:	d1 2c       	mov	r13, r1
    3272:	2f 77       	andi	r18, 0x7F	; 127
    3274:	20 93 37 01 	sts	0x0137, r18
    3278:	e1 e0       	ldi	r30, 0x01	; 1
    327a:	eb 83       	std	Y+3, r30	; 0x03
    327c:	0a c0       	rjmp	.+20     	; 0x3292 <PM_CreateProgrammingPackets+0x160>
    327e:	60 e6       	ldi	r22, 0x60	; 96
    3280:	c6 2e       	mov	r12, r22
    3282:	6f ef       	ldi	r22, 0xFF	; 255
    3284:	d6 2e       	mov	r13, r22
    3286:	c6 0c       	add	r12, r6
    3288:	d7 1c       	adc	r13, r7
    328a:	20 68       	ori	r18, 0x80	; 128
    328c:	20 93 37 01 	sts	0x0137, r18
    3290:	1b 82       	std	Y+3, r1	; 0x03
    3292:	00 e0       	ldi	r16, 0x00	; 0
    3294:	10 e0       	ldi	r17, 0x00	; 0
    3296:	0c 15       	cp	r16, r12
    3298:	1d 05       	cpc	r17, r13
    329a:	78 f4       	brcc	.+30     	; 0x32ba <PM_CreateProgrammingPackets+0x188>
    329c:	5e e3       	ldi	r21, 0x3E	; 62
    329e:	e5 2e       	mov	r14, r21
    32a0:	51 e0       	ldi	r21, 0x01	; 1
    32a2:	f5 2e       	mov	r15, r21
    32a4:	80 e0       	ldi	r24, 0x00	; 0
    32a6:	0e 94 42 09 	call	0x1284 <SPI_SPITransmit>
    32aa:	f7 01       	movw	r30, r14
    32ac:	81 93       	st	Z+, r24
    32ae:	7f 01       	movw	r14, r30
    32b0:	0f 5f       	subi	r16, 0xFF	; 255
    32b2:	1f 4f       	sbci	r17, 0xFF	; 255
    32b4:	0c 15       	cp	r16, r12
    32b6:	1d 05       	cpc	r17, r13
    32b8:	a8 f3       	brcs	.-22     	; 0x32a4 <PM_CreateProgrammingPackets+0x172>
    32ba:	8d 2d       	mov	r24, r13
    32bc:	99 27       	eor	r25, r25
    32be:	80 93 35 01 	sts	0x0135, r24
    32c2:	c0 92 36 01 	sts	0x0136, r12
    32c6:	4b c0       	rjmp	.+150    	; 0x335e <PM_CreateProgrammingPackets+0x22c>
    32c8:	00 e0       	ldi	r16, 0x00	; 0
    32ca:	10 e0       	ldi	r17, 0x00	; 0
    32cc:	06 15       	cp	r16, r6
    32ce:	17 05       	cpc	r17, r7
    32d0:	78 f4       	brcc	.+30     	; 0x32f0 <PM_CreateProgrammingPackets+0x1be>
    32d2:	3e e3       	ldi	r19, 0x3E	; 62
    32d4:	e3 2e       	mov	r14, r19
    32d6:	31 e0       	ldi	r19, 0x01	; 1
    32d8:	f3 2e       	mov	r15, r19
    32da:	80 e0       	ldi	r24, 0x00	; 0
    32dc:	0e 94 42 09 	call	0x1284 <SPI_SPITransmit>
    32e0:	f7 01       	movw	r30, r14
    32e2:	81 93       	st	Z+, r24
    32e4:	7f 01       	movw	r14, r30
    32e6:	0f 5f       	subi	r16, 0xFF	; 255
    32e8:	1f 4f       	sbci	r17, 0xFF	; 255
    32ea:	06 15       	cp	r16, r6
    32ec:	17 05       	cpc	r17, r7
    32ee:	a8 f3       	brcs	.-22     	; 0x32da <PM_CreateProgrammingPackets+0x1a8>
    32f0:	87 2d       	mov	r24, r7
    32f2:	99 27       	eor	r25, r25
    32f4:	80 93 35 01 	sts	0x0135, r24
    32f8:	60 92 36 01 	sts	0x0136, r6
    32fc:	80 91 37 01 	lds	r24, 0x0137
    3300:	80 68       	ori	r24, 0x80	; 128
    3302:	80 93 37 01 	sts	0x0137, r24
    3306:	c3 01       	movw	r24, r6
    3308:	aa 27       	eor	r26, r26
    330a:	bb 27       	eor	r27, r27
    330c:	2b c0       	rjmp	.+86     	; 0x3364 <PM_CreateProgrammingPackets+0x232>
    330e:	c6 01       	movw	r24, r12
    3310:	aa 27       	eor	r26, r26
    3312:	bb 27       	eor	r27, r27
    3314:	88 0d       	add	r24, r8
    3316:	99 1d       	adc	r25, r9
    3318:	aa 1d       	adc	r26, r10
    331a:	bb 1d       	adc	r27, r11
    331c:	28 16       	cp	r2, r24
    331e:	39 06       	cpc	r3, r25
    3320:	4a 06       	cpc	r4, r26
    3322:	5b 06       	cpc	r5, r27
    3324:	48 f4       	brcc	.+18     	; 0x3338 <PM_CreateProgrammingPackets+0x206>
    3326:	61 01       	movw	r12, r2
    3328:	c8 18       	sub	r12, r8
    332a:	d9 08       	sbc	r13, r9
    332c:	8d 2d       	mov	r24, r13
    332e:	99 27       	eor	r25, r25
    3330:	80 93 35 01 	sts	0x0135, r24
    3334:	c0 92 36 01 	sts	0x0136, r12
    3338:	8a 01       	movw	r16, r20
    333a:	4c 15       	cp	r20, r12
    333c:	5d 05       	cpc	r21, r13
    333e:	78 f4       	brcc	.+30     	; 0x335e <PM_CreateProgrammingPackets+0x22c>
    3340:	8e e3       	ldi	r24, 0x3E	; 62
    3342:	e8 2e       	mov	r14, r24
    3344:	81 e0       	ldi	r24, 0x01	; 1
    3346:	f8 2e       	mov	r15, r24
    3348:	80 e0       	ldi	r24, 0x00	; 0
    334a:	0e 94 42 09 	call	0x1284 <SPI_SPITransmit>
    334e:	f7 01       	movw	r30, r14
    3350:	81 93       	st	Z+, r24
    3352:	7f 01       	movw	r14, r30
    3354:	0f 5f       	subi	r16, 0xFF	; 255
    3356:	1f 4f       	sbci	r17, 0xFF	; 255
    3358:	0c 15       	cp	r16, r12
    335a:	1d 05       	cpc	r17, r13
    335c:	a8 f3       	brcs	.-22     	; 0x3348 <PM_CreateProgrammingPackets+0x216>
    335e:	c6 01       	movw	r24, r12
    3360:	aa 27       	eor	r26, r26
    3362:	bb 27       	eor	r27, r27
    3364:	88 0e       	add	r8, r24
    3366:	99 1e       	adc	r9, r25
    3368:	aa 1e       	adc	r10, r26
    336a:	bb 1e       	adc	r11, r27
    336c:	81 14       	cp	r8, r1
    336e:	91 04       	cpc	r9, r1
    3370:	e1 f4       	brne	.+56     	; 0x33aa <PM_CreateProgrammingPackets+0x278>
    3372:	e1 2c       	mov	r14, r1
    3374:	f1 2c       	mov	r15, r1
    3376:	bf ef       	ldi	r27, 0xFF	; 255
    3378:	0b 2f       	mov	r16, r27
    337a:	11 2d       	mov	r17, r1
    337c:	e8 20       	and	r14, r8
    337e:	f9 20       	and	r15, r9
    3380:	0a 21       	and	r16, r10
    3382:	1b 21       	and	r17, r11
    3384:	e1 14       	cp	r14, r1
    3386:	f1 04       	cpc	r15, r1
    3388:	01 05       	cpc	r16, r1
    338a:	11 05       	cpc	r17, r1
    338c:	71 f0       	breq	.+28     	; 0x33aa <PM_CreateProgrammingPackets+0x278>
    338e:	8d e4       	ldi	r24, 0x4D	; 77
    3390:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    3394:	80 e0       	ldi	r24, 0x00	; 0
    3396:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    339a:	c8 01       	movw	r24, r16
    339c:	aa 27       	eor	r26, r26
    339e:	bb 27       	eor	r27, r27
    33a0:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    33a4:	80 e0       	ldi	r24, 0x00	; 0
    33a6:	0e 94 a7 09 	call	0x134e <USI_SPITransmit>
    33aa:	0e 94 29 11 	call	0x2252 <ISPCC_ProgramChip>
    33ae:	82 14       	cp	r8, r2
    33b0:	93 04       	cpc	r9, r3
    33b2:	a4 04       	cpc	r10, r4
    33b4:	b5 04       	cpc	r11, r5
    33b6:	08 f4       	brcc	.+2      	; 0x33ba <PM_CreateProgrammingPackets+0x288>
    33b8:	49 cf       	rjmp	.-366    	; 0x324c <PM_CreateProgrammingPackets+0x11a>
    33ba:	23 96       	adiw	r28, 0x03	; 3
    33bc:	0f b6       	in	r0, 0x3f	; 63
    33be:	f8 94       	cli
    33c0:	de bf       	out	0x3e, r29	; 62
    33c2:	0f be       	out	0x3f, r0	; 63
    33c4:	cd bf       	out	0x3d, r28	; 61
    33c6:	df 91       	pop	r29
    33c8:	cf 91       	pop	r28
    33ca:	1f 91       	pop	r17
    33cc:	0f 91       	pop	r16
    33ce:	ff 90       	pop	r15
    33d0:	ef 90       	pop	r14
    33d2:	df 90       	pop	r13
    33d4:	cf 90       	pop	r12
    33d6:	bf 90       	pop	r11
    33d8:	af 90       	pop	r10
    33da:	9f 90       	pop	r9
    33dc:	8f 90       	pop	r8
    33de:	7f 90       	pop	r7
    33e0:	6f 90       	pop	r6
    33e2:	5f 90       	pop	r5
    33e4:	4f 90       	pop	r4
    33e6:	3f 90       	pop	r3
    33e8:	2f 90       	pop	r2
    33ea:	08 95       	ret

000033ec <PM_ShowStoredItemSizes>:
	}
}

void PM_ShowStoredItemSizes(void)
{
    33ec:	1f 93       	push	r17
    33ee:	cf 93       	push	r28
    33f0:	df 93       	push	r29
    33f2:	cd b7       	in	r28, 0x3d	; 61
    33f4:	de b7       	in	r29, 0x3e	; 62
    33f6:	2e 97       	sbiw	r28, 0x0e	; 14
    33f8:	0f b6       	in	r0, 0x3f	; 63
    33fa:	f8 94       	cli
    33fc:	de bf       	out	0x3e, r29	; 62
    33fe:	0f be       	out	0x3f, r0	; 63
    3400:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[14];
	uint8_t ItemInfoIndex = 0;
    3402:	10 e0       	ldi	r17, 0x00	; 0
	uint8_t TempB;
	
	JoyStatus = 1;
    3404:	81 e0       	ldi	r24, 0x01	; 1
    3406:	8e bb       	out	0x1e, r24	; 30
	
	while (1)
	{
		if (JoyStatus)                           // Joystick is in the non-center position
    3408:	8e b3       	in	r24, 0x1e	; 30
    340a:	88 23       	and	r24, r24
    340c:	e9 f3       	breq	.-6      	; 0x3408 <PM_ShowStoredItemSizes+0x1c>
		{
			if (JoyStatus & JOY_UP)              // Previous item
    340e:	f6 9b       	sbis	0x1e, 6	; 30
    3410:	06 c0       	rjmp	.+12     	; 0x341e <PM_ShowStoredItemSizes+0x32>
				(ItemInfoIndex == 0)? ItemInfoIndex = 3 : ItemInfoIndex--;
    3412:	11 23       	and	r17, r17
    3414:	11 f4       	brne	.+4      	; 0x341a <PM_ShowStoredItemSizes+0x2e>
    3416:	13 e0       	ldi	r17, 0x03	; 3
    3418:	0c c0       	rjmp	.+24     	; 0x3432 <PM_ShowStoredItemSizes+0x46>
    341a:	11 50       	subi	r17, 0x01	; 1
    341c:	0a c0       	rjmp	.+20     	; 0x3432 <PM_ShowStoredItemSizes+0x46>
			else if (JoyStatus & JOY_DOWN)      // Next item
    341e:	f7 9b       	sbis	0x1e, 7	; 30
    3420:	06 c0       	rjmp	.+12     	; 0x342e <PM_ShowStoredItemSizes+0x42>
				(ItemInfoIndex == 3)? ItemInfoIndex = 0 : ItemInfoIndex++;
    3422:	13 30       	cpi	r17, 0x03	; 3
    3424:	11 f4       	brne	.+4      	; 0x342a <PM_ShowStoredItemSizes+0x3e>
    3426:	10 e0       	ldi	r17, 0x00	; 0
    3428:	04 c0       	rjmp	.+8      	; 0x3432 <PM_ShowStoredItemSizes+0x46>
    342a:	1f 5f       	subi	r17, 0xFF	; 255
    342c:	02 c0       	rjmp	.+4      	; 0x3432 <PM_ShowStoredItemSizes+0x46>
			else if (JoyStatus & JOY_LEFT)
    342e:	f2 99       	sbic	0x1e, 2	; 30
    3430:	53 c0       	rjmp	.+166    	; 0x34d8 <PM_ShowStoredItemSizes+0xec>
				return;
		
			switch (ItemInfoIndex)
    3432:	81 2f       	mov	r24, r17
    3434:	99 27       	eor	r25, r25
    3436:	81 30       	cpi	r24, 0x01	; 1
    3438:	91 05       	cpc	r25, r1
    343a:	a1 f0       	breq	.+40     	; 0x3464 <PM_ShowStoredItemSizes+0x78>
    343c:	82 30       	cpi	r24, 0x02	; 2
    343e:	91 05       	cpc	r25, r1
    3440:	1c f4       	brge	.+6      	; 0x3448 <PM_ShowStoredItemSizes+0x5c>
    3442:	89 2b       	or	r24, r25
    3444:	39 f0       	breq	.+14     	; 0x3454 <PM_ShowStoredItemSizes+0x68>
    3446:	41 c0       	rjmp	.+130    	; 0x34ca <PM_ShowStoredItemSizes+0xde>
    3448:	82 30       	cpi	r24, 0x02	; 2
    344a:	91 05       	cpc	r25, r1
    344c:	01 f1       	breq	.+64     	; 0x348e <PM_ShowStoredItemSizes+0xa2>
    344e:	03 97       	sbiw	r24, 0x03	; 3
    3450:	39 f1       	breq	.+78     	; 0x34a0 <PM_ShowStoredItemSizes+0xb4>
    3452:	3b c0       	rjmp	.+118    	; 0x34ca <PM_ShowStoredItemSizes+0xde>
			{
				case 0:
					strcpy_P(Buffer, PSTR("DATA-"));
    3454:	63 e0       	ldi	r22, 0x03	; 3
    3456:	74 e0       	ldi	r23, 0x04	; 4
    3458:	ce 01       	movw	r24, r28
    345a:	01 96       	adiw	r24, 0x01	; 1
    345c:	0e 94 48 1b 	call	0x3690 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_FLASH), &Buffer[5], 10);
    3460:	81 e0       	ldi	r24, 0x01	; 1
    3462:	07 c0       	rjmp	.+14     	; 0x3472 <PM_ShowStoredItemSizes+0x86>
					break;
				case 1:
					strcpy_P(Buffer, PSTR("EPRM-"));
    3464:	69 e0       	ldi	r22, 0x09	; 9
    3466:	74 e0       	ldi	r23, 0x04	; 4
    3468:	ce 01       	movw	r24, r28
    346a:	01 96       	adiw	r24, 0x01	; 1
    346c:	0e 94 48 1b 	call	0x3690 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_EEPROM), &Buffer[5], 10);
    3470:	80 e0       	ldi	r24, 0x00	; 0
    3472:	0e 94 80 13 	call	0x2700 <PM_GetStoredDataSize>
    3476:	dc 01       	movw	r26, r24
    3478:	cb 01       	movw	r24, r22
    347a:	2a e0       	ldi	r18, 0x0A	; 10
    347c:	30 e0       	ldi	r19, 0x00	; 0
    347e:	ae 01       	movw	r20, r28
    3480:	4a 5f       	subi	r20, 0xFA	; 250
    3482:	5f 4f       	sbci	r21, 0xFF	; 255
    3484:	bc 01       	movw	r22, r24
    3486:	cd 01       	movw	r24, r26
    3488:	0e 94 4f 1b 	call	0x369e <ultoa>
					break;
    348c:	1e c0       	rjmp	.+60     	; 0x34ca <PM_ShowStoredItemSizes+0xde>
				case 2:
					strcpy_P(Buffer, PSTR("FUSE-"));
    348e:	6f e0       	ldi	r22, 0x0F	; 15
    3490:	74 e0       	ldi	r23, 0x04	; 4
    3492:	ce 01       	movw	r24, r28
    3494:	01 96       	adiw	r24, 0x01	; 1
    3496:	0e 94 48 1b 	call	0x3690 <strcpy_P>
					TempB = eeprom_read_byte_169(&Prog_TotalFuseBytes);
    349a:	80 e1       	ldi	r24, 0x10	; 16
    349c:	91 e0       	ldi	r25, 0x01	; 1
    349e:	08 c0       	rjmp	.+16     	; 0x34b0 <PM_ShowStoredItemSizes+0xc4>
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);
					break;
				case 3:
					strcpy_P(Buffer, PSTR("LOCK-"));
    34a0:	65 e1       	ldi	r22, 0x15	; 21
    34a2:	74 e0       	ldi	r23, 0x04	; 4
    34a4:	ce 01       	movw	r24, r28
    34a6:	01 96       	adiw	r24, 0x01	; 1
    34a8:	0e 94 48 1b 	call	0x3690 <strcpy_P>
					TempB = eeprom_read_byte_169(&Prog_TotalLockBytes);
    34ac:	8e e0       	ldi	r24, 0x0E	; 14
    34ae:	91 e0       	ldi	r25, 0x01	; 1
    34b0:	0e 94 b9 08 	call	0x1172 <eeprom_read_byte_169>
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);		
    34b4:	8f 3f       	cpi	r24, 0xFF	; 255
    34b6:	11 f0       	breq	.+4      	; 0x34bc <PM_ShowStoredItemSizes+0xd0>
    34b8:	99 27       	eor	r25, r25
    34ba:	02 c0       	rjmp	.+4      	; 0x34c0 <PM_ShowStoredItemSizes+0xd4>
    34bc:	80 e0       	ldi	r24, 0x00	; 0
    34be:	90 e0       	ldi	r25, 0x00	; 0
    34c0:	be 01       	movw	r22, r28
    34c2:	6a 5f       	subi	r22, 0xFA	; 250
    34c4:	7f 4f       	sbci	r23, 0xFF	; 255
    34c6:	0e 94 36 03 	call	0x66c <MAIN_IntToStr>
			}
	
			LCD_puts(Buffer);
    34ca:	ce 01       	movw	r24, r28
    34cc:	01 96       	adiw	r24, 0x01	; 1
    34ce:	0e 94 be 07 	call	0xf7c <LCD_puts>

			MAIN_WaitForJoyRelease();
    34d2:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
    34d6:	98 cf       	rjmp	.-208    	; 0x3408 <PM_ShowStoredItemSizes+0x1c>
    34d8:	2e 96       	adiw	r28, 0x0e	; 14
    34da:	0f b6       	in	r0, 0x3f	; 63
    34dc:	f8 94       	cli
    34de:	de bf       	out	0x3e, r29	; 62
    34e0:	0f be       	out	0x3f, r0	; 63
    34e2:	cd bf       	out	0x3d, r28	; 61
    34e4:	df 91       	pop	r29
    34e6:	cf 91       	pop	r28
    34e8:	1f 91       	pop	r17
    34ea:	08 95       	ret

000034ec <TM_FindNextTag>:
	DF_EnableDataflash(FALSE);
}

void TM_FindNextTag(void)
{
    34ec:	af 92       	push	r10
    34ee:	bf 92       	push	r11
    34f0:	df 92       	push	r13
    34f2:	ef 92       	push	r14
    34f4:	ff 92       	push	r15
    34f6:	0f 93       	push	r16
    34f8:	1f 93       	push	r17
    34fa:	cf 93       	push	r28
    34fc:	df 93       	push	r29
    34fe:	cd b7       	in	r28, 0x3d	; 61
    3500:	de b7       	in	r29, 0x3e	; 62
    3502:	69 97       	sbiw	r28, 0x19	; 25
    3504:	0f b6       	in	r0, 0x3f	; 63
    3506:	f8 94       	cli
    3508:	de bf       	out	0x3e, r29	; 62
    350a:	0f be       	out	0x3f, r0	; 63
    350c:	cd bf       	out	0x3d, r28	; 61
	uint8_t  Buffer[21];
	uint8_t  HeadBuff[4]      = BT_TAGHEADER;
    350e:	80 e4       	ldi	r24, 0x40	; 64
    3510:	8e 8b       	std	Y+22, r24	; 0x16
    3512:	86 e1       	ldi	r24, 0x16	; 22
    3514:	a8 2e       	mov	r10, r24
    3516:	b1 2c       	mov	r11, r1
    3518:	ac 0e       	add	r10, r28
    351a:	bd 1e       	adc	r11, r29
    351c:	88 e2       	ldi	r24, 0x28	; 40
    351e:	8f 8b       	std	Y+23, r24	; 0x17
    3520:	83 e2       	ldi	r24, 0x23	; 35
    3522:	88 8f       	std	Y+24, r24	; 0x18
    3524:	89 e2       	ldi	r24, 0x29	; 41
    3526:	89 8f       	std	Y+25, r24	; 0x19
	uint32_t ProgDataSize     = PM_GetStoredDataSize(TYPE_FLASH);
    3528:	81 e0       	ldi	r24, 0x01	; 1
    352a:	0e 94 80 13 	call	0x2700 <PM_GetStoredDataSize>
    352e:	7b 01       	movw	r14, r22
    3530:	8c 01       	movw	r16, r24
	uint8_t  TotalOkHeadBytes = 0;
    3532:	dd 24       	eor	r13, r13
	uint8_t  TagByte;
	uint8_t  BytesRead;
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);    // Orange = busy
    3534:	81 b3       	in	r24, 0x11	; 17
    3536:	80 63       	ori	r24, 0x30	; 48
    3538:	81 bb       	out	0x11, r24	; 17

	while (DFPos < ProgDataSize)
	{
		BytesRead = 1;
		
		if (SPI_SPITransmit(0x00) == HeadBuff[TotalOkHeadBytes++])
		{
			if (TotalOkHeadBytes == 4)
			{
				uint8_t HB;
			
				for (HB = 0; HB < 20; HB++)
				{
					TagByte = SPI_SPITransmit(0x00);
					Buffer[HB] = TagByte;
					
					if (TagByte == 0x00)
					  break;
				}
				
				Buffer[20] = '\0';             // Make sure string is null-terminated

				TagExists = TRUE;
				BytesRead = (HB + 2);

				LCD_puts(Buffer);
				MAIN_SETSTATUSLED(MAIN_STATLED_GREEN); // Green = ready
				return;
			}
		}
		else
		{
			TotalOkHeadBytes = 0;
		}

		DFPos += BytesRead;
    353a:	80 91 d2 02 	lds	r24, 0x02D2
    353e:	90 91 d3 02 	lds	r25, 0x02D3
    3542:	a0 91 d4 02 	lds	r26, 0x02D4
    3546:	b0 91 d5 02 	lds	r27, 0x02D5
    354a:	8e 15       	cp	r24, r14
    354c:	9f 05       	cpc	r25, r15
    354e:	a0 07       	cpc	r26, r16
    3550:	b1 07       	cpc	r27, r17
    3552:	08 f0       	brcs	.+2      	; 0x3556 <TM_FindNextTag+0x6a>
    3554:	43 c0       	rjmp	.+134    	; 0x35dc <TM_FindNextTag+0xf0>
    3556:	80 e0       	ldi	r24, 0x00	; 0
    3558:	0e 94 42 09 	call	0x1284 <SPI_SPITransmit>
    355c:	f5 01       	movw	r30, r10
    355e:	ed 0d       	add	r30, r13
    3560:	f1 1d       	adc	r31, r1
    3562:	d3 94       	inc	r13
    3564:	90 81       	ld	r25, Z
    3566:	89 17       	cp	r24, r25
    3568:	21 f5       	brne	.+72     	; 0x35b2 <TM_FindNextTag+0xc6>
    356a:	84 e0       	ldi	r24, 0x04	; 4
    356c:	d8 16       	cp	r13, r24
    356e:	11 f5       	brne	.+68     	; 0x35b4 <TM_FindNextTag+0xc8>
    3570:	ff 24       	eor	r15, r15
    3572:	00 e0       	ldi	r16, 0x00	; 0
    3574:	10 e0       	ldi	r17, 0x00	; 0
    3576:	80 e0       	ldi	r24, 0x00	; 0
    3578:	0e 94 42 09 	call	0x1284 <SPI_SPITransmit>
    357c:	9e 01       	movw	r18, r28
    357e:	2f 5f       	subi	r18, 0xFF	; 255
    3580:	3f 4f       	sbci	r19, 0xFF	; 255
    3582:	f8 01       	movw	r30, r16
    3584:	e2 0f       	add	r30, r18
    3586:	f3 1f       	adc	r31, r19
    3588:	80 83       	st	Z, r24
    358a:	88 23       	and	r24, r24
    358c:	31 f0       	breq	.+12     	; 0x359a <TM_FindNextTag+0xae>
    358e:	f3 94       	inc	r15
    3590:	0f 5f       	subi	r16, 0xFF	; 255
    3592:	1f 4f       	sbci	r17, 0xFF	; 255
    3594:	83 e1       	ldi	r24, 0x13	; 19
    3596:	8f 15       	cp	r24, r15
    3598:	70 f7       	brcc	.-36     	; 0x3576 <TM_FindNextTag+0x8a>
    359a:	1d 8a       	std	Y+21, r1	; 0x15
    359c:	81 e0       	ldi	r24, 0x01	; 1
    359e:	80 93 4b 02 	sts	0x024B, r24
    35a2:	c9 01       	movw	r24, r18
    35a4:	0e 94 be 07 	call	0xf7c <LCD_puts>
    35a8:	81 b3       	in	r24, 0x11	; 17
    35aa:	8f 7c       	andi	r24, 0xCF	; 207
    35ac:	80 61       	ori	r24, 0x10	; 16
    35ae:	81 bb       	out	0x11, r24	; 17
    35b0:	31 c0       	rjmp	.+98     	; 0x3614 <TM_FindNextTag+0x128>
    35b2:	dd 24       	eor	r13, r13
    35b4:	80 91 d2 02 	lds	r24, 0x02D2
    35b8:	90 91 d3 02 	lds	r25, 0x02D3
    35bc:	a0 91 d4 02 	lds	r26, 0x02D4
    35c0:	b0 91 d5 02 	lds	r27, 0x02D5
    35c4:	01 96       	adiw	r24, 0x01	; 1
    35c6:	a1 1d       	adc	r26, r1
    35c8:	b1 1d       	adc	r27, r1
    35ca:	80 93 d2 02 	sts	0x02D2, r24
    35ce:	90 93 d3 02 	sts	0x02D3, r25
    35d2:	a0 93 d4 02 	sts	0x02D4, r26
    35d6:	b0 93 d5 02 	sts	0x02D5, r27
    35da:	b7 cf       	rjmp	.-146    	; 0x354a <TM_FindNextTag+0x5e>
	}
	
	DF_ContinuousReadEnable(0, 0);
    35dc:	60 e0       	ldi	r22, 0x00	; 0
    35de:	70 e0       	ldi	r23, 0x00	; 0
    35e0:	cb 01       	movw	r24, r22
    35e2:	0e 94 1b 0a 	call	0x1436 <DF_ContinuousReadEnable>
	DFPos = 0;
    35e6:	10 92 d2 02 	sts	0x02D2, r1
    35ea:	10 92 d3 02 	sts	0x02D3, r1
    35ee:	10 92 d4 02 	sts	0x02D4, r1
    35f2:	10 92 d5 02 	sts	0x02D5, r1
	
	if (TagExists == FALSE)
    35f6:	80 91 4b 02 	lds	r24, 0x024B
    35fa:	88 23       	and	r24, r24
    35fc:	49 f4       	brne	.+18     	; 0x3610 <TM_FindNextTag+0x124>
	{
		MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);  // Green = ready
    35fe:	81 b3       	in	r24, 0x11	; 17
    3600:	8f 7c       	andi	r24, 0xCF	; 207
    3602:	80 61       	ori	r24, 0x10	; 16
    3604:	81 bb       	out	0x11, r24	; 17
		MAIN_ShowError(PSTR("NO TAGS"));
    3606:	8b e1       	ldi	r24, 0x1B	; 27
    3608:	94 e0       	ldi	r25, 0x04	; 4
    360a:	0e 94 70 03 	call	0x6e0 <MAIN_ShowError>
    360e:	02 c0       	rjmp	.+4      	; 0x3614 <TM_FindNextTag+0x128>
	}
	else
	{
		/* The following line _is_ recursion, but the function will only ever call itself
		   a maximum of one time. The function will call itself upon skipping from the last
		   tag stored in the program data to the first; to guard against infinite recursion
		   if no tags are present, the system will error out if the TagExists flag is empty
		   after a full data read. Once a tag has been read and displayed onto the LCD, the
           function returns to the main tag handling routine.                               */
		TM_FindNextTag();
    3610:	0e 94 76 1a 	call	0x34ec <TM_FindNextTag>
    3614:	69 96       	adiw	r28, 0x19	; 25
    3616:	0f b6       	in	r0, 0x3f	; 63
    3618:	f8 94       	cli
    361a:	de bf       	out	0x3e, r29	; 62
    361c:	0f be       	out	0x3f, r0	; 63
    361e:	cd bf       	out	0x3d, r28	; 61
    3620:	df 91       	pop	r29
    3622:	cf 91       	pop	r28
    3624:	1f 91       	pop	r17
    3626:	0f 91       	pop	r16
    3628:	ff 90       	pop	r15
    362a:	ef 90       	pop	r14
    362c:	df 90       	pop	r13
    362e:	bf 90       	pop	r11
    3630:	af 90       	pop	r10
    3632:	08 95       	ret

00003634 <TM_ShowTags>:
    3634:	60 e0       	ldi	r22, 0x00	; 0
    3636:	70 e0       	ldi	r23, 0x00	; 0
    3638:	cb 01       	movw	r24, r22
    363a:	0e 94 1b 0a 	call	0x1436 <DF_ContinuousReadEnable>
    363e:	10 92 4b 02 	sts	0x024B, r1
    3642:	10 92 d2 02 	sts	0x02D2, r1
    3646:	10 92 d3 02 	sts	0x02D3, r1
    364a:	10 92 d4 02 	sts	0x02D4, r1
    364e:	10 92 d5 02 	sts	0x02D5, r1
    3652:	0e 94 76 1a 	call	0x34ec <TM_FindNextTag>
    3656:	80 91 4b 02 	lds	r24, 0x024B
    365a:	88 23       	and	r24, r24
    365c:	71 f0       	breq	.+28     	; 0x367a <TM_ShowTags+0x46>
    365e:	8e b3       	in	r24, 0x1e	; 30
    3660:	88 23       	and	r24, r24
    3662:	e9 f3       	breq	.-6      	; 0x365e <TM_ShowTags+0x2a>
    3664:	f7 9b       	sbis	0x1e, 7	; 30
    3666:	03 c0       	rjmp	.+6      	; 0x366e <TM_ShowTags+0x3a>
    3668:	0e 94 76 1a 	call	0x34ec <TM_FindNextTag>
    366c:	02 c0       	rjmp	.+4      	; 0x3672 <TM_ShowTags+0x3e>
    366e:	f2 99       	sbic	0x1e, 2	; 30
    3670:	03 c0       	rjmp	.+6      	; 0x3678 <TM_ShowTags+0x44>
    3672:	0e 94 41 02 	call	0x482 <MAIN_WaitForJoyRelease>
    3676:	f3 cf       	rjmp	.-26     	; 0x365e <TM_ShowTags+0x2a>
    3678:	80 e0       	ldi	r24, 0x00	; 0
    367a:	0e 94 dc 09 	call	0x13b8 <DF_EnableDataflash>
    367e:	08 95       	ret

00003680 <__vector_2>:
.global PCINT0_vect             ; Pin change 0 (joystick)
.global PCINT1_vect             ; Pin change 1 (joystick)

PCINT0_vect:
  jmp PCINT1_vect
    3680:	0c 94 96 03 	jmp	0x72c <__vector_3>

00003684 <__vector_10>:

.global TIMER0_COMP_vect             ; Timer 0 compare

TIMER0_COMP_vect:
  push r24
    3684:	8f 93       	push	r24
  ldi r24, (USI_CONTROL_REG_FLAGS | (1<<USITC))
    3686:	8b e5       	ldi	r24, 0x5B	; 91
  sts _SFR_MEM_ADDR(USICR), r24
    3688:	80 93 b8 00 	sts	0x00B8, r24
  pop r24
    368c:	8f 91       	pop	r24
  reti
    368e:	18 95       	reti

00003690 <strcpy_P>:
    3690:	fb 01       	movw	r30, r22
    3692:	dc 01       	movw	r26, r24
    3694:	05 90       	lpm	r0, Z+
    3696:	0d 92       	st	X+, r0
    3698:	00 20       	and	r0, r0
    369a:	e1 f7       	brne	.-8      	; 0x3694 <strcpy_P+0x4>
    369c:	08 95       	ret

0000369e <ultoa>:
    369e:	fa 01       	movw	r30, r20
    36a0:	cf 93       	push	r28
    36a2:	ff 93       	push	r31
    36a4:	ef 93       	push	r30
    36a6:	22 30       	cpi	r18, 0x02	; 2
    36a8:	cc f0       	brlt	.+50     	; 0x36dc <ultoa+0x3e>
    36aa:	25 32       	cpi	r18, 0x25	; 37
    36ac:	bc f4       	brge	.+46     	; 0x36dc <ultoa+0x3e>
    36ae:	c2 2f       	mov	r28, r18
    36b0:	2c 2f       	mov	r18, r28
    36b2:	33 27       	eor	r19, r19
    36b4:	44 27       	eor	r20, r20
    36b6:	55 27       	eor	r21, r21
    36b8:	ff 93       	push	r31
    36ba:	ef 93       	push	r30
    36bc:	0e 94 a3 1b 	call	0x3746 <__udivmodsi4>
    36c0:	ef 91       	pop	r30
    36c2:	ff 91       	pop	r31
    36c4:	60 5d       	subi	r22, 0xD0	; 208
    36c6:	6a 33       	cpi	r22, 0x3A	; 58
    36c8:	0c f0       	brlt	.+2      	; 0x36cc <ultoa+0x2e>
    36ca:	69 5d       	subi	r22, 0xD9	; 217
    36cc:	61 93       	st	Z+, r22
    36ce:	b9 01       	movw	r22, r18
    36d0:	ca 01       	movw	r24, r20
    36d2:	60 50       	subi	r22, 0x00	; 0
    36d4:	70 40       	sbci	r23, 0x00	; 0
    36d6:	80 40       	sbci	r24, 0x00	; 0
    36d8:	90 40       	sbci	r25, 0x00	; 0
    36da:	51 f7       	brne	.-44     	; 0x36b0 <ultoa+0x12>
    36dc:	10 82       	st	Z, r1
    36de:	8f 91       	pop	r24
    36e0:	9f 91       	pop	r25
    36e2:	cf 91       	pop	r28
    36e4:	0c 94 74 1b 	jmp	0x36e8 <strrev>

000036e8 <strrev>:
    36e8:	dc 01       	movw	r26, r24
    36ea:	fc 01       	movw	r30, r24
    36ec:	01 90       	ld	r0, Z+
    36ee:	00 20       	and	r0, r0
    36f0:	e9 f7       	brne	.-6      	; 0x36ec <strrev+0x4>
    36f2:	32 97       	sbiw	r30, 0x02	; 2
    36f4:	ae 17       	cp	r26, r30
    36f6:	bf 07       	cpc	r27, r31
    36f8:	30 f4       	brcc	.+12     	; 0x3706 <strrev+0x1e>
    36fa:	7c 91       	ld	r23, X
    36fc:	60 81       	ld	r22, Z
    36fe:	70 83       	st	Z, r23
    3700:	31 97       	sbiw	r30, 0x01	; 1
    3702:	6d 93       	st	X+, r22
    3704:	f7 cf       	rjmp	.-18     	; 0x36f4 <strrev+0xc>
    3706:	08 95       	ret

00003708 <__mulsi3>:
    3708:	62 9f       	mul	r22, r18
    370a:	d0 01       	movw	r26, r0
    370c:	73 9f       	mul	r23, r19
    370e:	f0 01       	movw	r30, r0
    3710:	82 9f       	mul	r24, r18
    3712:	e0 0d       	add	r30, r0
    3714:	f1 1d       	adc	r31, r1
    3716:	64 9f       	mul	r22, r20
    3718:	e0 0d       	add	r30, r0
    371a:	f1 1d       	adc	r31, r1
    371c:	92 9f       	mul	r25, r18
    371e:	f0 0d       	add	r31, r0
    3720:	83 9f       	mul	r24, r19
    3722:	f0 0d       	add	r31, r0
    3724:	74 9f       	mul	r23, r20
    3726:	f0 0d       	add	r31, r0
    3728:	65 9f       	mul	r22, r21
    372a:	f0 0d       	add	r31, r0
    372c:	99 27       	eor	r25, r25
    372e:	72 9f       	mul	r23, r18
    3730:	b0 0d       	add	r27, r0
    3732:	e1 1d       	adc	r30, r1
    3734:	f9 1f       	adc	r31, r25
    3736:	63 9f       	mul	r22, r19
    3738:	b0 0d       	add	r27, r0
    373a:	e1 1d       	adc	r30, r1
    373c:	f9 1f       	adc	r31, r25
    373e:	bd 01       	movw	r22, r26
    3740:	cf 01       	movw	r24, r30
    3742:	11 24       	eor	r1, r1
    3744:	08 95       	ret

00003746 <__udivmodsi4>:
    3746:	a1 e2       	ldi	r26, 0x21	; 33
    3748:	1a 2e       	mov	r1, r26
    374a:	aa 1b       	sub	r26, r26
    374c:	bb 1b       	sub	r27, r27
    374e:	fd 01       	movw	r30, r26
    3750:	0d c0       	rjmp	.+26     	; 0x376c <__udivmodsi4_ep>

00003752 <__udivmodsi4_loop>:
    3752:	aa 1f       	adc	r26, r26
    3754:	bb 1f       	adc	r27, r27
    3756:	ee 1f       	adc	r30, r30
    3758:	ff 1f       	adc	r31, r31
    375a:	a2 17       	cp	r26, r18
    375c:	b3 07       	cpc	r27, r19
    375e:	e4 07       	cpc	r30, r20
    3760:	f5 07       	cpc	r31, r21
    3762:	20 f0       	brcs	.+8      	; 0x376c <__udivmodsi4_ep>
    3764:	a2 1b       	sub	r26, r18
    3766:	b3 0b       	sbc	r27, r19
    3768:	e4 0b       	sbc	r30, r20
    376a:	f5 0b       	sbc	r31, r21

0000376c <__udivmodsi4_ep>:
    376c:	66 1f       	adc	r22, r22
    376e:	77 1f       	adc	r23, r23
    3770:	88 1f       	adc	r24, r24
    3772:	99 1f       	adc	r25, r25
    3774:	1a 94       	dec	r1
    3776:	69 f7       	brne	.-38     	; 0x3752 <__udivmodsi4_loop>
    3778:	60 95       	com	r22
    377a:	70 95       	com	r23
    377c:	80 95       	com	r24
    377e:	90 95       	com	r25
    3780:	9b 01       	movw	r18, r22
    3782:	ac 01       	movw	r20, r24
    3784:	bd 01       	movw	r22, r26
    3786:	cf 01       	movw	r24, r30
    3788:	08 95       	ret
