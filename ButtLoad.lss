
ButtLoad.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000026  00800100  000037ce  00003862  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000037ce  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b0  00800126  00800126  00003888  2**0
                  ALLOC
  3 .noinit       00000000  008002d6  008002d6  00003888  2**0
                  CONTENTS
  4 .eeprom       00000000  00810000  00810000  00003888  2**0
                  CONTENTS
  5 .stab         00000030  00000000  00000000  00003888  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      0000003f  00000000  00000000  000038b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000140  00000000  00000000  000038f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000f75  00000000  00000000  00003a37  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000034d2  00000000  00000000  000049ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00000e45  00000000  00000000  00007e7e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000030bf  00000000  00000000  00008cc3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0000111d  00000000  00000000  0000bd82  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 0a 02 	jmp	0x414 <__init>
       4:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
       8:	0c 94 68 1b 	jmp	0x36d0 <__vector_2>
       c:	0c 94 90 03 	jmp	0x720 <__vector_3>
      10:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      14:	0c 94 88 07 	jmp	0xf10 <__vector_5>
      18:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      1c:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      20:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      24:	0c 94 1e 0c 	jmp	0x183c <__vector_9>
      28:	0c 94 54 09 	jmp	0x12a8 <__vector_10>
      2c:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      30:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      34:	0c 94 0f 09 	jmp	0x121e <__vector_13>
      38:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      3c:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      40:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      44:	0c 94 65 09 	jmp	0x12ca <__vector_17>
      48:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      4c:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      50:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      54:	0c 94 25 02 	jmp	0x44a <__bad_interrupt>
      58:	0c 94 45 08 	jmp	0x108a <__vector_22>

0000005c <SIFOOptionPtrs>:
      5c:	6f 00 60 00                                         o.`.

00000060 <SIFO_Tags>:
      60:	56 49 45 57 20 44 41 54 41 20 54 41 47 53 00        VIEW DATA TAGS.

0000006f <SIFO_Size>:
      6f:	53 54 4f 52 41 47 45 20 53 49 5a 45 53 00           STORAGE SIZES.

0000007d <USIPSNamePtrs>:
      7d:	a3 00 99 00 8f 00 85 00                             ........

00000085 <USI_Speed3>:
      85:	20 32 38 39 31 32 20 48 5a 00                        28912 HZ.

0000008f <USI_Speed2>:
      8f:	20 35 37 36 30 30 20 48 5a 00                        57600 HZ.

00000099 <USI_Speed1>:
      99:	20 38 36 37 33 38 20 48 5a 00                        86738 HZ.

000000a3 <USI_Speed0>:
      a3:	31 31 33 34 32 37 20 48 5a 00                       113427 HZ.

000000ad <ProgOptions>:
      ad:	16 01 0a 01 fa 00 ea 00 da 00 c6 00 bb 00           ..............

000000bb <PRG_C>:
      bb:	45 52 41 53 45 20 4f 4e 4c 59 00                    ERASE ONLY.

000000c6 <PRG_FL>:
      c6:	46 55 53 45 20 41 4e 44 20 4c 4f 43 4b 20 42 59     FUSE AND LOCK BY
      d6:	54 45 53 00                                         TES.

000000da <PRG_L>:
      da:	4c 4f 43 4b 20 42 59 54 45 53 20 4f 4e 4c 59 00     LOCK BYTES ONLY.

000000ea <PRG_F>:
      ea:	46 55 53 45 20 42 59 54 45 53 20 4f 4e 4c 59 00     FUSE BYTES ONLY.

000000fa <PRG_DE>:
      fa:	44 41 54 41 20 41 4e 44 20 45 45 50 52 4f 4d 00     DATA AND EEPROM.

0000010a <PRG_E>:
     10a:	45 45 50 52 4f 4d 20 4f 4e 4c 59 00                 EEPROM ONLY.

00000116 <PRG_D>:
     116:	44 41 54 41 20 4f 4e 4c 59 00                       DATA ONLY.

00000120 <SettingFunctionPtrs>:
     120:	33 06 7f 06 7d 05 d2 05 d9 05 27 07                 3...}.....'.

0000012c <SettingFunctionNames>:
     12c:	88 01 7a 01 6d 01 5e 01 4b 01 38 01                 ..z.m.^.K.8.

00000138 <SFunc_GOBOOTLOADER>:
     138:	4a 55 4d 50 20 54 4f 20 42 4f 4f 54 4c 4f 41 44     JUMP TO BOOTLOAD
     148:	45 52 00                                            ER.

0000014b <SFunc_MANCALIB>:
     14b:	4d 41 4e 55 41 4c 20 43 41 4c 49 42 52 41 54 49     MANUAL CALIBRATI
     15b:	4f 4e 00                                            ON.

0000015e <SFunc_AUTOCALIB>:
     15e:	41 55 54 4f 20 43 41 4c 49 42 52 41 54 45 00        AUTO CALIBRATE.

0000016d <SFunc_CLEARMEM>:
     16d:	43 4c 45 41 52 20 4d 45 4d 4f 52 59 00              CLEAR MEMORY.

0000017a <SFunc_SETSPISPEED>:
     17a:	53 45 54 20 53 50 49 20 53 50 45 45 44 00           SET SPI SPEED.

00000188 <SFunc_SETCONTRAST>:
     188:	53 45 54 20 43 4f 4e 54 52 41 53 54 00              SET CONTRAST.

00000195 <MainFunctionPtrs>:
     195:	e1 03 57 05 12 04 ee 03 ac 03 b4 06                 ..W.........

000001a1 <MainFunctionNames>:
     1a1:	ec 01 e1 01 d5 01 c1 01 b8 01 ad 01                 ............

000001ad <Func_SLEEP>:
     1ad:	53 4c 45 45 50 20 4d 4f 44 45 00                    SLEEP MODE.

000001b8 <Func_SETTINGS>:
     1b8:	53 45 54 54 49 4e 47 53 00                          SETTINGS.

000001c1 <Func_PRGMDATAFLASH>:
     1c1:	44 41 54 41 46 4c 41 53 48 20 50 52 47 4d 20 4d     DATAFLASH PRGM M
     1d1:	4f 44 45 00                                         ODE.

000001d5 <Func_PRGMAVR>:
     1d5:	50 52 4f 47 52 41 4d 20 41 56 52 00                 PROGRAM AVR.

000001e1 <Func_STOREPRGM>:
     1e1:	53 54 4f 52 45 20 50 52 47 4d 00                    STORE PRGM.

000001ec <Func_ISPPRGM>:
     1ec:	41 56 52 49 53 50 20 4d 4f 44 45 00                 AVRISP MODE.

000001f8 <AboutTextPtrs>:
     1f8:	23 02 1e 02 0f 02 00 02                             #.......

00000200 <CopyRight>:
     200:	3c 43 3e 20 32 30 30 36 20 2d 20 47 50 4c 00        <C> 2006 - GPL.

0000020f <AuthorName>:
     20f:	42 59 20 44 45 41 4e 20 43 41 4d 45 52 41 00        BY DEAN CAMERA.

0000021e <VersionInfo>:
     21e:	56 31 2d 32 00                                      V1-2.

00000223 <ProgrammerName>:
     223:	42 55 54 54 4c 4f 41 44 00                          BUTTLOAD.

0000022c <WaitText>:
     22c:	2a 57 41 49 54 2a 00                                *WAIT*.

00000233 <BUTTTAG_Author>:
     233:	40 28 23 29 42 59 20 44 45 41 4e 20 43 41 4d 45     @(#)BY DEAN CAME
     243:	52 41 00                                            RA.

00000246 <BUTTTAG_Name>:
     246:	40 28 23 29 42 55 54 54 4c 4f 41 44 20 41 56 52     @(#)BUTTLOAD AVR
     256:	49 53 50 00                                         ISP.

0000025a <__c.14>:
     25a:	50 52 47 3e 20 00                                   PRG> .

00000260 <__c.13>:
     260:	42 41 44 49 53 52 00                                BADISR.

00000267 <__c.6>:
     267:	4e 4f 20 45 52 41 53 45 20 43 4d 44 00              NO ERASE CMD.

00000274 <__c.7>:
     274:	4e 4f 20 44 41 54 41 00                             NO DATA.

0000027c <__c.8>:
     27c:	4e 4f 20 45 45 50 52 4f 4d 00                       NO EEPROM.

00000286 <__c.9>:
     286:	4e 4f 20 46 55 53 45 20 42 59 54 45 53 00           NO FUSE BYTES.

00000294 <__c.10>:
     294:	4e 4f 20 4c 4f 43 4b 20 42 59 54 45 53 00           NO LOCK BYTES.

000002a2 <__c.11>:
     2a2:	50 52 4f 47 52 41 4d 4d 49 4e 47 20 44 4f 4e 45     PROGRAMMING DONE
	...

000002b3 <__c.12>:
     2b3:	46 41 49 4c 45 44 00                                FAILED.

000002ba <__c.5>:
     2ba:	2a 53 54 4f 52 41 47 45 20 4d 4f 44 45 2a 00        *STORAGE MODE*.

000002c9 <__c.2>:
     2c9:	43 4f 4e 46 49 52 4d 00                             CONFIRM.

000002d1 <__c.3>:
     2d1:	3c 4e 20 59 3e 00                                   <N Y>.

000002d7 <__c.4>:
     2d7:	4d 45 4d 20 43 4c 45 41 52 45 44 00                 MEM CLEARED.

000002e3 <__c.1>:
     2e3:	4e 4f 20 53 54 4f 52 45 44 20 50 52 47 4d 00        NO STORED PRGM.

000002f2 <__c.0>:
     2f2:	2a 4a 54 41 47 20 4f 4e 2a 00                       *JTAG ON*.

000002fc <LCD_SegTable>:
     2fc:	a8 ea 80 2a 00 40 00 0a 51 0a 08 40 59 55 18 01     ...*.@..Q..@YU..
     30c:	11 1e 11 1b 50 0b 41 1b 41 1f 11 01 51 1f 51 1b     ....P.A.A...Q.Q.
     31c:	00 00 00 00 08 80 00 1a 20 40 00 00 00 00 51 0f     ........ @....Q.
     32c:	91 39 41 14 91 31 41 1e 41 0e 41 1d 50 0f 80 20     .9A..1A.A.A.P.. 
     33c:	10 15 48 86 40 14 78 05 70 85 51 15 51 0e 51 95     ..H.@.x.p.Q.Q.Q.
     34c:	51 8e 21 90 81 20 50 15 48 44 50 c5 28 c0 28 20     Q.!.. P.HDP.(.( 
     35c:	09 50 41 14 20 80 11 11 00 00 00 10                 .PA. .......

00000368 <USIPSValues>:
     368:	00 01 40 01 01 54 02 01 80 03 01 ff                 ..@..T......

00000374 <DataFlashError>:
     374:	44 41 54 41 46 4c 41 53 48 20 45 52 52 4f 52 00     DATAFLASH ERROR.

00000384 <DF_Pages>:
     384:	f9 00 f1 01 e1 03 10 3e 84 0f 84 0f 08 1f 08 1f     .......>........

00000394 <DF_PageSize>:
     394:	08 01 08 01 08 01 08 01 08 01 10 02 10 02 20 04     .............. .

000003a4 <DF_PageBits>:
     3a4:	09 09 09 09 09 0a 0a 0b                             ........

000003ac <__c.0>:
     3ac:	42 55 46 46 20 4f 56 45 52 46 4c 4f 57 00           BUFF OVERFLOW.

000003ba <DataFlashProgMode>:
     3ba:	2a 44 41 54 41 46 4c 41 53 48 20 4d 4f 44 45 2a     *DATAFLASH MODE*
	...

000003cb <SignonResponse>:
     3cb:	01 00 08 41 56 52 49 53 50 5f 32                    ...AVRISP_2

000003d6 <VersionData>:
     3d6:	02 02 04                                            ...

000003d9 <SyncErrorMessage>:
     3d9:	53 59 4e 43 20 45 52 52 4f 52 00                    SYNC ERROR.

000003e4 <AVRISPModeMessage>:
     3e4:	2a 41 54 41 56 52 49 53 50 20 4d 4f 44 45 2a 00     *ATAVRISP MODE*.

000003f4 <__c.0>:
     3f4:	44 41 54 41 2d 00                                   DATA-.

000003fa <__c.1>:
     3fa:	45 50 52 4d 2d 00                                   EPRM-.

00000400 <__c.2>:
     400:	46 55 53 45 2d 00                                   FUSE-.

00000406 <__c.3>:
     406:	4c 4f 43 4b 2d 00                                   LOCK-.

0000040c <__c.0>:
     40c:	4e 4f 20 54 41 47 53 00                             NO TAGS.

00000414 <__init>:
     414:	11 24       	eor	r1, r1
     416:	1f be       	out	0x3f, r1	; 63
     418:	cf ef       	ldi	r28, 0xFF	; 255
     41a:	d4 e0       	ldi	r29, 0x04	; 4
     41c:	de bf       	out	0x3e, r29	; 62
     41e:	cd bf       	out	0x3d, r28	; 61

00000420 <__do_copy_data>:
     420:	11 e0       	ldi	r17, 0x01	; 1
     422:	a0 e0       	ldi	r26, 0x00	; 0
     424:	b1 e0       	ldi	r27, 0x01	; 1
     426:	ee ec       	ldi	r30, 0xCE	; 206
     428:	f7 e3       	ldi	r31, 0x37	; 55
     42a:	02 c0       	rjmp	.+4      	; 0x430 <.do_copy_data_start>

0000042c <.do_copy_data_loop>:
     42c:	05 90       	lpm	r0, Z+
     42e:	0d 92       	st	X+, r0

00000430 <.do_copy_data_start>:
     430:	a6 32       	cpi	r26, 0x26	; 38
     432:	b1 07       	cpc	r27, r17
     434:	d9 f7       	brne	.-10     	; 0x42c <.do_copy_data_loop>

00000436 <__do_clear_bss>:
     436:	12 e0       	ldi	r17, 0x02	; 2
     438:	a6 e2       	ldi	r26, 0x26	; 38
     43a:	b1 e0       	ldi	r27, 0x01	; 1
     43c:	01 c0       	rjmp	.+2      	; 0x440 <.do_clear_bss_start>

0000043e <.do_clear_bss_loop>:
     43e:	1d 92       	st	X+, r1

00000440 <.do_clear_bss_start>:
     440:	a6 3d       	cpi	r26, 0xD6	; 214
     442:	b1 07       	cpc	r27, r17
     444:	e1 f7       	brne	.-8      	; 0x43e <.do_clear_bss_loop>
     446:	0c 94 6b 02 	jmp	0x4d6 <main>

0000044a <__bad_interrupt>:
     44a:	0c 94 a7 03 	jmp	0x74e <__vector_default>

0000044e <MAIN_Delay10MS>:

// ======================================================================================

void MAIN_Delay10MS(uint8_t loops)
{
     44e:	cf 93       	push	r28
     450:	df 93       	push	r29
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     452:	28 2f       	mov	r18, r24
     454:	21 50       	subi	r18, 0x01	; 1
     456:	2f 3f       	cpi	r18, 0xFF	; 255
     458:	49 f0       	breq	.+18     	; 0x46c <MAIN_Delay10MS+0x1e>
     45a:	a0 e0       	ldi	r26, 0x00	; 0
     45c:	b8 e4       	ldi	r27, 0x48	; 72
     45e:	c0 e0       	ldi	r28, 0x00	; 0
     460:	d0 e0       	ldi	r29, 0x00	; 0
     462:	cd 01       	movw	r24, r26
     464:	01 97       	sbiw	r24, 0x01	; 1
     466:	f1 f7       	brne	.-4      	; 0x464 <MAIN_Delay10MS+0x16>
     468:	21 50       	subi	r18, 0x01	; 1
     46a:	d8 f7       	brcc	.-10     	; 0x462 <MAIN_Delay10MS+0x14>
     46c:	df 91       	pop	r29
     46e:	cf 91       	pop	r28
     470:	08 95       	ret

00000472 <MAIN_WaitForJoyRelease>:
  /* Prevents the use of floating point libraries. Delaying in groups of
     10ms increases accuracy by reducing the time overhead for each loop
     interation of the while.                                            */

	while (loops--)
	  _delay_ms(10);
}

void MAIN_Delay1MS(uint8_t loops)
{
  /* Prevents the use of floating point libraries. Less accurate than the
     Delay10MS routine, but nessesary for many commands. The overhead required
     to call the routine is substantially less than the overhead required to
     calculate the float at compile time, so this actually saves execution time. */

	while (loops--)
	  _delay_ms(1);
}

void MAIN_ResetCSLine(uint8_t ActiveInactive)
{
  /* ActiveInactive controls the /Reset line to an AVR device or external dataflash
     /CS line. If the reset polarity parameter is a 0 then interfacing with AT89
	 devices which has an active high reset. Pins are tristated when inactive.      */
	
	switch (ActiveInactive)
	{
		case MAIN_RESETCS_ACTIVE:   // The target RESET line may be either active high or low.
			DDRF |= (1 << 6);
		
			if (!(eeprom_read_byte_169(&Param_ResetPolarity))) // Translate to correct logic level for target device type
			  PORTF |=  (1 << 6);
			else
			  PORTF &= ~(1 << 6);
		
			break;
		case MAIN_RESETCS_DFACTIVE: // Dataflashes are always active low.
			DDRF  |=  (1 << 6);
			PORTF &= ~(1 << 6);
			
			break;
		case MAIN_RESETCS_INACTIVE: // Both modes tristate the pins when inactive.
			DDRF  &= ~(1 << 6);
			PORTF &= ~(1 << 6);
	}
}

void MAIN_WaitForJoyRelease(void)
{
	while (1)
	{
		while (JoyStatus) {};                   // Wait until joystick released
     472:	8e b3       	in	r24, 0x1e	; 30
     474:	88 23       	and	r24, r24
     476:	e9 f7       	brne	.-6      	; 0x472 <MAIN_WaitForJoyRelease>

		MAIN_Delay10MS(1);
     478:	81 e0       	ldi	r24, 0x01	; 1
     47a:	0e 94 27 02 	call	0x44e <MAIN_Delay10MS>

		if (!(JoyStatus))                       // Joystick still released (not bouncing), return
     47e:	8e b3       	in	r24, 0x1e	; 30
     480:	88 23       	and	r24, r24
     482:	b9 f7       	brne	.-18     	; 0x472 <MAIN_WaitForJoyRelease>
     484:	08 95       	ret

00000486 <FUNCShowAbout>:
		  return;
	}
}

void MAIN_IntToStr(uint16_t IntV, uint8_t* Buff)
{
	// Shows leading zeros, unlike itoa.

	uint8_t Temp = 0;
	
	while (IntV >= 100)
	{
		Temp++;
		IntV -= 100;
	}

	*(Buff++) = '0' + Temp;
	
	Temp = 0;
	
	while (IntV >= 10)
	{
		Temp++;
		IntV -= 10;
	}
		
	*(Buff++) = '0' + Temp;
	*(Buff++) = '0' + IntV;
	*(Buff)   = '\0';
}

void MAIN_ShowProgType(uint8_t Letter)
{
	uint8_t ProgTypeBuffer[7];

	strcpy_P(ProgTypeBuffer, PSTR("PRG> "));
	ProgTypeBuffer[5] = Letter;
	ProgTypeBuffer[6] = '\0';
	
	LCD_puts(ProgTypeBuffer);
}

void MAIN_ShowError(const uint8_t *pFlashStr)
{
	uint8_t ErrorBuff[LCD_TEXTBUFFER_SIZE];       // New buffer, LCD text buffer size
	
	ErrorBuff[0] = 'E';
	ErrorBuff[1] = '>';

	strcpy_P(&ErrorBuff[2], pFlashStr);       // WARNING: If error text is larger than (TEXTBUFFER_SIZE - 2),
	                                          // this will overflow the buffer and probably crash the micro!
	LCD_puts(ErrorBuff);
	
	MAIN_WaitForJoyRelease();
	while (!(JoyStatus & JOY_PRESS)) {};
	MAIN_WaitForJoyRelease();
}

// ======================================================================================

ISR(PCINT1_vect, ISR_NOBLOCK)                 // Joystick routine; PCINT0_vect is bound to this also via JoystickInterrupt.S
{
	JoyStatus = (~PINB & JOY_BMASK)
	          | (~PINE & JOY_EMASK);
}

ISR(BADISR_vect, ISR_NAKED)                   // Bad ISR routine; should never be called, here for safety
{
	MAIN_ShowError(PSTR("BADISR"));
	while (1) {};
}

// ======================================================================================

void FUNCChangeSettings(void)
{
	uint8_t CurrSFunc = 0;
	
	JoyStatus = 1;

	while (1)
	{
		if (JoyStatus)                         // Joystick is in the non-center position
		{
			if (JoyStatus & JOY_UP)            // Previous function
			  (CurrSFunc == 0)? CurrSFunc = 5 : CurrSFunc--;
			else if (JoyStatus & JOY_DOWN)     // Next function
			  (CurrSFunc == 5)? CurrSFunc = 0 : CurrSFunc++;
			else if (JoyStatus & JOY_PRESS)    // Select current function
			  ((FuncPtr)pgm_read_word(&SettingFunctionPtrs[CurrSFunc]))(); // Run associated function
			else if (JoyStatus & JOY_LEFT)
			  return;
		
			// Show current function onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&SettingFunctionNames[CurrSFunc]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCShowAbout(void)
{
     486:	cf 93       	push	r28
	uint8_t InfoNum = 0;
     488:	c0 e0       	ldi	r28, 0x00	; 0
	
	JoyStatus = 1;
     48a:	81 e0       	ldi	r24, 0x01	; 1
     48c:	8e bb       	out	0x1e, r24	; 30
			
	while (1)
	{
		if (JoyStatus)
     48e:	8e b3       	in	r24, 0x1e	; 30
     490:	88 23       	and	r24, r24
     492:	e9 f3       	breq	.-6      	; 0x48e <FUNCShowAbout+0x8>
		{
			if (JoyStatus & JOY_UP)
     494:	f6 9b       	sbis	0x1e, 6	; 30
     496:	06 c0       	rjmp	.+12     	; 0x4a4 <FUNCShowAbout+0x1e>
			  (InfoNum == 0)? InfoNum = 3 : InfoNum--;
     498:	cc 23       	and	r28, r28
     49a:	11 f4       	brne	.+4      	; 0x4a0 <FUNCShowAbout+0x1a>
     49c:	c3 e0       	ldi	r28, 0x03	; 3
     49e:	0c c0       	rjmp	.+24     	; 0x4b8 <FUNCShowAbout+0x32>
     4a0:	c1 50       	subi	r28, 0x01	; 1
     4a2:	0a c0       	rjmp	.+20     	; 0x4b8 <FUNCShowAbout+0x32>
			else if (JoyStatus & JOY_DOWN)
     4a4:	f7 9b       	sbis	0x1e, 7	; 30
     4a6:	06 c0       	rjmp	.+12     	; 0x4b4 <FUNCShowAbout+0x2e>
			  (InfoNum == 3)? InfoNum = 0 : InfoNum++;
     4a8:	c3 30       	cpi	r28, 0x03	; 3
     4aa:	11 f4       	brne	.+4      	; 0x4b0 <FUNCShowAbout+0x2a>
     4ac:	c0 e0       	ldi	r28, 0x00	; 0
     4ae:	04 c0       	rjmp	.+8      	; 0x4b8 <FUNCShowAbout+0x32>
     4b0:	cf 5f       	subi	r28, 0xFF	; 255
     4b2:	02 c0       	rjmp	.+4      	; 0x4b8 <FUNCShowAbout+0x32>
			else if (JoyStatus & JOY_LEFT)
     4b4:	f2 99       	sbic	0x1e, 2	; 30
     4b6:	0d c0       	rjmp	.+26     	; 0x4d2 <FUNCShowAbout+0x4c>
			  return;

			LCD_puts_f((uint8_t*)pgm_read_word(&AboutTextPtrs[InfoNum]));
     4b8:	ec 2f       	mov	r30, r28
     4ba:	ff 27       	eor	r31, r31
     4bc:	ee 0f       	add	r30, r30
     4be:	ff 1f       	adc	r31, r31
     4c0:	e8 50       	subi	r30, 0x08	; 8
     4c2:	fe 4f       	sbci	r31, 0xFE	; 254
     4c4:	85 91       	lpm	r24, Z+
     4c6:	94 91       	lpm	r25, Z
     4c8:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     4cc:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     4d0:	de cf       	rjmp	.-68     	; 0x48e <FUNCShowAbout+0x8>
     4d2:	cf 91       	pop	r28
     4d4:	08 95       	ret

000004d6 <main>:
     4d6:	cd ef       	ldi	r28, 0xFD	; 253
     4d8:	d4 e0       	ldi	r29, 0x04	; 4
     4da:	de bf       	out	0x3e, r29	; 62
     4dc:	cd bf       	out	0x3d, r28	; 61
     4de:	10 e0       	ldi	r17, 0x00	; 0
     4e0:	80 e8       	ldi	r24, 0x80	; 128
     4e2:	85 bf       	out	0x35, r24	; 53
     4e4:	85 bf       	out	0x35, r24	; 53
     4e6:	80 bf       	out	0x30, r24	; 48
     4e8:	85 e0       	ldi	r24, 0x05	; 5
     4ea:	80 93 64 00 	sts	0x0064, r24
     4ee:	80 e3       	ldi	r24, 0x30	; 48
     4f0:	80 bb       	out	0x10, r24	; 16
     4f2:	87 e2       	ldi	r24, 0x27	; 39
     4f4:	84 b9       	out	0x04, r24	; 4
     4f6:	8f ed       	ldi	r24, 0xDF	; 223
     4f8:	85 b9       	out	0x05, r24	; 5
     4fa:	8c e0       	ldi	r24, 0x0C	; 12
     4fc:	8e b9       	out	0x0e, r24	; 14
     4fe:	80 93 6b 00 	sts	0x006B, r24
     502:	80 ed       	ldi	r24, 0xD0	; 208
     504:	80 93 6c 00 	sts	0x006C, r24
     508:	80 ec       	ldi	r24, 0xC0	; 192
     50a:	8d bb       	out	0x1d, r24	; 29
     50c:	8c bb       	out	0x1c, r24	; 28
     50e:	81 b3       	in	r24, 0x11	; 17
     510:	8f 7c       	andi	r24, 0xCF	; 207
     512:	80 62       	ori	r24, 0x20	; 32
     514:	81 bb       	out	0x11, r24	; 17
     516:	82 e0       	ldi	r24, 0x02	; 2
     518:	91 e0       	ldi	r25, 0x01	; 1
     51a:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
     51e:	8a 35       	cpi	r24, 0x5A	; 90
     520:	09 f1       	breq	.+66     	; 0x564 <__stack+0x65>
     522:	20 e0       	ldi	r18, 0x00	; 0
     524:	30 e0       	ldi	r19, 0x00	; 0
     526:	3a 83       	std	Y+2, r19	; 0x02
     528:	29 83       	std	Y+1, r18	; 0x01
     52a:	80 91 02 01 	lds	r24, 0x0102
     52e:	90 91 03 01 	lds	r25, 0x0103
     532:	28 17       	cp	r18, r24
     534:	39 07       	cpc	r19, r25
     536:	88 f4       	brcc	.+34     	; 0x55a <__stack+0x5b>
     538:	6f ef       	ldi	r22, 0xFF	; 255
     53a:	ce 01       	movw	r24, r28
     53c:	01 96       	adiw	r24, 0x01	; 1
     53e:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
     542:	89 81       	ldd	r24, Y+1	; 0x01
     544:	9a 81       	ldd	r25, Y+2	; 0x02
     546:	01 96       	adiw	r24, 0x01	; 1
     548:	9a 83       	std	Y+2, r25	; 0x02
     54a:	89 83       	std	Y+1, r24	; 0x01
     54c:	20 91 02 01 	lds	r18, 0x0102
     550:	30 91 03 01 	lds	r19, 0x0103
     554:	82 17       	cp	r24, r18
     556:	93 07       	cpc	r25, r19
     558:	78 f3       	brcs	.-34     	; 0x538 <__stack+0x39>
     55a:	6a e5       	ldi	r22, 0x5A	; 90
     55c:	82 e0       	ldi	r24, 0x02	; 2
     55e:	91 e0       	ldi	r25, 0x01	; 1
     560:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
     564:	0e 94 a9 07 	call	0xf52 <LCD_Init>
     568:	84 e0       	ldi	r24, 0x04	; 4
     56a:	91 e0       	ldi	r25, 0x01	; 1
     56c:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
     570:	8f 70       	andi	r24, 0x0F	; 15
     572:	80 93 e7 00 	sts	0x00E7, r24
     576:	78 94       	sei
     578:	8c e2       	ldi	r24, 0x2C	; 44
     57a:	92 e0       	ldi	r25, 0x02	; 2
     57c:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>
     580:	80 e0       	ldi	r24, 0x00	; 0
     582:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
     586:	81 b3       	in	r24, 0x11	; 17
     588:	80 63       	ori	r24, 0x30	; 48
     58a:	81 bb       	out	0x11, r24	; 17
     58c:	0e 94 37 07 	call	0xe6e <OSCCAL_Calibrate>
     590:	87 e0       	ldi	r24, 0x07	; 7
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	0e 94 d9 08 	call	0x11b2 <USART_Init>
     598:	81 b3       	in	r24, 0x11	; 17
     59a:	8f 7c       	andi	r24, 0xCF	; 207
     59c:	80 61       	ori	r24, 0x10	; 16
     59e:	81 bb       	out	0x11, r24	; 17
     5a0:	81 e0       	ldi	r24, 0x01	; 1
     5a2:	8e bb       	out	0x1e, r24	; 30
     5a4:	8e b3       	in	r24, 0x1e	; 30
     5a6:	88 23       	and	r24, r24
     5a8:	e9 f3       	breq	.-6      	; 0x5a4 <__stack+0xa5>
     5aa:	f6 9b       	sbis	0x1e, 6	; 30
     5ac:	06 c0       	rjmp	.+12     	; 0x5ba <__stack+0xbb>
     5ae:	11 23       	and	r17, r17
     5b0:	11 f4       	brne	.+4      	; 0x5b6 <__stack+0xb7>
     5b2:	15 e0       	ldi	r17, 0x05	; 5
     5b4:	1b c0       	rjmp	.+54     	; 0x5ec <__stack+0xed>
     5b6:	11 50       	subi	r17, 0x01	; 1
     5b8:	19 c0       	rjmp	.+50     	; 0x5ec <__stack+0xed>
     5ba:	f7 9b       	sbis	0x1e, 7	; 30
     5bc:	06 c0       	rjmp	.+12     	; 0x5ca <__stack+0xcb>
     5be:	15 30       	cpi	r17, 0x05	; 5
     5c0:	11 f4       	brne	.+4      	; 0x5c6 <__stack+0xc7>
     5c2:	10 e0       	ldi	r17, 0x00	; 0
     5c4:	13 c0       	rjmp	.+38     	; 0x5ec <__stack+0xed>
     5c6:	1f 5f       	subi	r17, 0xFF	; 255
     5c8:	11 c0       	rjmp	.+34     	; 0x5ec <__stack+0xed>
     5ca:	f4 9b       	sbis	0x1e, 4	; 30
     5cc:	0b c0       	rjmp	.+22     	; 0x5e4 <__stack+0xe5>
     5ce:	e1 2f       	mov	r30, r17
     5d0:	ff 27       	eor	r31, r31
     5d2:	ee 0f       	add	r30, r30
     5d4:	ff 1f       	adc	r31, r31
     5d6:	eb 56       	subi	r30, 0x6B	; 107
     5d8:	fe 4f       	sbci	r31, 0xFE	; 254
     5da:	85 91       	lpm	r24, Z+
     5dc:	94 91       	lpm	r25, Z
     5de:	fc 01       	movw	r30, r24
     5e0:	09 95       	icall
     5e2:	04 c0       	rjmp	.+8      	; 0x5ec <__stack+0xed>
     5e4:	f3 9b       	sbis	0x1e, 3	; 30
     5e6:	02 c0       	rjmp	.+4      	; 0x5ec <__stack+0xed>
     5e8:	0e 94 43 02 	call	0x486 <FUNCShowAbout>
     5ec:	e1 2f       	mov	r30, r17
     5ee:	ff 27       	eor	r31, r31
     5f0:	ee 0f       	add	r30, r30
     5f2:	ff 1f       	adc	r31, r31
     5f4:	ef 55       	subi	r30, 0x5F	; 95
     5f6:	fe 4f       	sbci	r31, 0xFE	; 254
     5f8:	85 91       	lpm	r24, Z+
     5fa:	94 91       	lpm	r25, Z
     5fc:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>
     600:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     604:	cf cf       	rjmp	.-98     	; 0x5a4 <__stack+0xa5>

00000606 <MAIN_Delay1MS>:
     606:	cf 93       	push	r28
     608:	df 93       	push	r29
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     60a:	28 2f       	mov	r18, r24
     60c:	21 50       	subi	r18, 0x01	; 1
     60e:	2f 3f       	cpi	r18, 0xFF	; 255
     610:	49 f0       	breq	.+18     	; 0x624 <MAIN_Delay1MS+0x1e>
     612:	a3 e3       	ldi	r26, 0x33	; 51
     614:	b7 e0       	ldi	r27, 0x07	; 7
     616:	c0 e0       	ldi	r28, 0x00	; 0
     618:	d0 e0       	ldi	r29, 0x00	; 0
     61a:	cd 01       	movw	r24, r26
     61c:	01 97       	sbiw	r24, 0x01	; 1
     61e:	f1 f7       	brne	.-4      	; 0x61c <MAIN_Delay1MS+0x16>
     620:	21 50       	subi	r18, 0x01	; 1
     622:	d8 f7       	brcc	.-10     	; 0x61a <MAIN_Delay1MS+0x14>
     624:	df 91       	pop	r29
     626:	cf 91       	pop	r28
     628:	08 95       	ret

0000062a <MAIN_ResetCSLine>:
     62a:	99 27       	eor	r25, r25
     62c:	81 30       	cpi	r24, 0x01	; 1
     62e:	91 05       	cpc	r25, r1
     630:	a9 f0       	breq	.+42     	; 0x65c <MAIN_ResetCSLine+0x32>
     632:	82 30       	cpi	r24, 0x02	; 2
     634:	91 05       	cpc	r25, r1
     636:	1c f4       	brge	.+6      	; 0x63e <MAIN_ResetCSLine+0x14>
     638:	89 2b       	or	r24, r25
     63a:	21 f0       	breq	.+8      	; 0x644 <MAIN_ResetCSLine+0x1a>
     63c:	08 95       	ret
     63e:	02 97       	sbiw	r24, 0x02	; 2
     640:	51 f0       	breq	.+20     	; 0x656 <MAIN_ResetCSLine+0x2c>
     642:	08 95       	ret
     644:	86 9a       	sbi	0x10, 6	; 16
     646:	82 e2       	ldi	r24, 0x22	; 34
     648:	91 e0       	ldi	r25, 0x01	; 1
     64a:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
     64e:	88 23       	and	r24, r24
     650:	19 f4       	brne	.+6      	; 0x658 <MAIN_ResetCSLine+0x2e>
     652:	8e 9a       	sbi	0x11, 6	; 17
     654:	08 95       	ret
     656:	86 9a       	sbi	0x10, 6	; 16
     658:	8e 98       	cbi	0x11, 6	; 17
     65a:	08 95       	ret
     65c:	86 98       	cbi	0x10, 6	; 16
     65e:	fc cf       	rjmp	.-8      	; 0x658 <MAIN_ResetCSLine+0x2e>

00000660 <MAIN_IntToStr>:
     660:	fb 01       	movw	r30, r22
     662:	20 e0       	ldi	r18, 0x00	; 0
     664:	84 36       	cpi	r24, 0x64	; 100
     666:	91 05       	cpc	r25, r1
     668:	20 f0       	brcs	.+8      	; 0x672 <MAIN_IntToStr+0x12>
     66a:	2f 5f       	subi	r18, 0xFF	; 255
     66c:	84 56       	subi	r24, 0x64	; 100
     66e:	90 40       	sbci	r25, 0x00	; 0
     670:	f9 cf       	rjmp	.-14     	; 0x664 <MAIN_IntToStr+0x4>
     672:	20 5d       	subi	r18, 0xD0	; 208
     674:	21 93       	st	Z+, r18
     676:	20 e0       	ldi	r18, 0x00	; 0
     678:	8a 30       	cpi	r24, 0x0A	; 10
     67a:	91 05       	cpc	r25, r1
     67c:	18 f0       	brcs	.+6      	; 0x684 <MAIN_IntToStr+0x24>
     67e:	2f 5f       	subi	r18, 0xFF	; 255
     680:	0a 97       	sbiw	r24, 0x0a	; 10
     682:	fa cf       	rjmp	.-12     	; 0x678 <MAIN_IntToStr+0x18>
     684:	20 5d       	subi	r18, 0xD0	; 208
     686:	21 93       	st	Z+, r18
     688:	80 5d       	subi	r24, 0xD0	; 208
     68a:	81 93       	st	Z+, r24
     68c:	10 82       	st	Z, r1
     68e:	08 95       	ret

00000690 <MAIN_ShowProgType>:
     690:	1f 93       	push	r17
     692:	cf 93       	push	r28
     694:	df 93       	push	r29
     696:	cd b7       	in	r28, 0x3d	; 61
     698:	de b7       	in	r29, 0x3e	; 62
     69a:	27 97       	sbiw	r28, 0x07	; 7
     69c:	0f b6       	in	r0, 0x3f	; 63
     69e:	f8 94       	cli
     6a0:	de bf       	out	0x3e, r29	; 62
     6a2:	0f be       	out	0x3f, r0	; 63
     6a4:	cd bf       	out	0x3d, r28	; 61
     6a6:	18 2f       	mov	r17, r24
     6a8:	6a e5       	ldi	r22, 0x5A	; 90
     6aa:	72 e0       	ldi	r23, 0x02	; 2
     6ac:	ce 01       	movw	r24, r28
     6ae:	01 96       	adiw	r24, 0x01	; 1
     6b0:	0e 94 6a 1b 	call	0x36d4 <strcpy_P>
     6b4:	1e 83       	std	Y+6, r17	; 0x06
     6b6:	1f 82       	std	Y+7, r1	; 0x07
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	0e 94 bb 07 	call	0xf76 <LCD_puts>
     6c0:	27 96       	adiw	r28, 0x07	; 7
     6c2:	0f b6       	in	r0, 0x3f	; 63
     6c4:	f8 94       	cli
     6c6:	de bf       	out	0x3e, r29	; 62
     6c8:	0f be       	out	0x3f, r0	; 63
     6ca:	cd bf       	out	0x3d, r28	; 61
     6cc:	df 91       	pop	r29
     6ce:	cf 91       	pop	r28
     6d0:	1f 91       	pop	r17
     6d2:	08 95       	ret

000006d4 <MAIN_ShowError>:
     6d4:	cf 93       	push	r28
     6d6:	df 93       	push	r29
     6d8:	cd b7       	in	r28, 0x3d	; 61
     6da:	de b7       	in	r29, 0x3e	; 62
     6dc:	64 97       	sbiw	r28, 0x14	; 20
     6de:	0f b6       	in	r0, 0x3f	; 63
     6e0:	f8 94       	cli
     6e2:	de bf       	out	0x3e, r29	; 62
     6e4:	0f be       	out	0x3f, r0	; 63
     6e6:	cd bf       	out	0x3d, r28	; 61
     6e8:	25 e4       	ldi	r18, 0x45	; 69
     6ea:	29 83       	std	Y+1, r18	; 0x01
     6ec:	2e e3       	ldi	r18, 0x3E	; 62
     6ee:	2a 83       	std	Y+2, r18	; 0x02
     6f0:	bc 01       	movw	r22, r24
     6f2:	ce 01       	movw	r24, r28
     6f4:	03 96       	adiw	r24, 0x03	; 3
     6f6:	0e 94 6a 1b 	call	0x36d4 <strcpy_P>
     6fa:	ce 01       	movw	r24, r28
     6fc:	01 96       	adiw	r24, 0x01	; 1
     6fe:	0e 94 bb 07 	call	0xf76 <LCD_puts>
     702:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     706:	f4 9b       	sbis	0x1e, 4	; 30
     708:	fe cf       	rjmp	.-4      	; 0x706 <MAIN_ShowError+0x32>
     70a:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     70e:	64 96       	adiw	r28, 0x14	; 20
     710:	0f b6       	in	r0, 0x3f	; 63
     712:	f8 94       	cli
     714:	de bf       	out	0x3e, r29	; 62
     716:	0f be       	out	0x3f, r0	; 63
     718:	cd bf       	out	0x3d, r28	; 61
     71a:	df 91       	pop	r29
     71c:	cf 91       	pop	r28
     71e:	08 95       	ret

00000720 <__vector_3>:
     720:	78 94       	sei
     722:	1f 92       	push	r1
     724:	0f 92       	push	r0
     726:	0f b6       	in	r0, 0x3f	; 63
     728:	0f 92       	push	r0
     72a:	11 24       	eor	r1, r1
     72c:	8f 93       	push	r24
     72e:	9f 93       	push	r25
     730:	93 b1       	in	r25, 0x03	; 3
     732:	90 95       	com	r25
     734:	90 7d       	andi	r25, 0xD0	; 208
     736:	8c b1       	in	r24, 0x0c	; 12
     738:	80 95       	com	r24
     73a:	8c 70       	andi	r24, 0x0C	; 12
     73c:	98 2b       	or	r25, r24
     73e:	9e bb       	out	0x1e, r25	; 30
     740:	9f 91       	pop	r25
     742:	8f 91       	pop	r24
     744:	0f 90       	pop	r0
     746:	0f be       	out	0x3f, r0	; 63
     748:	0f 90       	pop	r0
     74a:	1f 90       	pop	r1
     74c:	18 95       	reti

0000074e <__vector_default>:
     74e:	80 e6       	ldi	r24, 0x60	; 96
     750:	92 e0       	ldi	r25, 0x02	; 2
     752:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
     756:	ff cf       	rjmp	.-2      	; 0x756 <__vector_default+0x8>

00000758 <FUNCChangeSettings>:
     758:	cf 93       	push	r28
     75a:	c0 e0       	ldi	r28, 0x00	; 0
     75c:	81 e0       	ldi	r24, 0x01	; 1
     75e:	8e bb       	out	0x1e, r24	; 30
     760:	8e b3       	in	r24, 0x1e	; 30
     762:	88 23       	and	r24, r24
     764:	e9 f3       	breq	.-6      	; 0x760 <FUNCChangeSettings+0x8>
     766:	f6 9b       	sbis	0x1e, 6	; 30
     768:	06 c0       	rjmp	.+12     	; 0x776 <FUNCChangeSettings+0x1e>
     76a:	cc 23       	and	r28, r28
     76c:	11 f4       	brne	.+4      	; 0x772 <FUNCChangeSettings+0x1a>
     76e:	c5 e0       	ldi	r28, 0x05	; 5
     770:	19 c0       	rjmp	.+50     	; 0x7a4 <FUNCChangeSettings+0x4c>
     772:	c1 50       	subi	r28, 0x01	; 1
     774:	17 c0       	rjmp	.+46     	; 0x7a4 <FUNCChangeSettings+0x4c>
     776:	f7 9b       	sbis	0x1e, 7	; 30
     778:	06 c0       	rjmp	.+12     	; 0x786 <FUNCChangeSettings+0x2e>
     77a:	c5 30       	cpi	r28, 0x05	; 5
     77c:	11 f4       	brne	.+4      	; 0x782 <FUNCChangeSettings+0x2a>
     77e:	c0 e0       	ldi	r28, 0x00	; 0
     780:	11 c0       	rjmp	.+34     	; 0x7a4 <FUNCChangeSettings+0x4c>
     782:	cf 5f       	subi	r28, 0xFF	; 255
     784:	0f c0       	rjmp	.+30     	; 0x7a4 <FUNCChangeSettings+0x4c>
     786:	f4 9b       	sbis	0x1e, 4	; 30
     788:	0b c0       	rjmp	.+22     	; 0x7a0 <FUNCChangeSettings+0x48>
     78a:	ec 2f       	mov	r30, r28
     78c:	ff 27       	eor	r31, r31
     78e:	ee 0f       	add	r30, r30
     790:	ff 1f       	adc	r31, r31
     792:	e0 5e       	subi	r30, 0xE0	; 224
     794:	fe 4f       	sbci	r31, 0xFE	; 254
     796:	85 91       	lpm	r24, Z+
     798:	94 91       	lpm	r25, Z
     79a:	fc 01       	movw	r30, r24
     79c:	09 95       	icall
     79e:	02 c0       	rjmp	.+4      	; 0x7a4 <FUNCChangeSettings+0x4c>
     7a0:	f2 99       	sbic	0x1e, 2	; 30
     7a2:	0d c0       	rjmp	.+26     	; 0x7be <FUNCChangeSettings+0x66>
     7a4:	ec 2f       	mov	r30, r28
     7a6:	ff 27       	eor	r31, r31
     7a8:	ee 0f       	add	r30, r30
     7aa:	ff 1f       	adc	r31, r31
     7ac:	e4 5d       	subi	r30, 0xD4	; 212
     7ae:	fe 4f       	sbci	r31, 0xFE	; 254
     7b0:	85 91       	lpm	r24, Z+
     7b2:	94 91       	lpm	r25, Z
     7b4:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>
     7b8:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     7bc:	d1 cf       	rjmp	.-94     	; 0x760 <FUNCChangeSettings+0x8>
     7be:	cf 91       	pop	r28
     7c0:	08 95       	ret

000007c2 <FUNCAVRISPMode>:
		}
	}
}

void FUNCAVRISPMode(void)
{
	LCD_puts_f(AVRISPModeMessage);
     7c2:	84 ee       	ldi	r24, 0xE4	; 228
     7c4:	93 e0       	ldi	r25, 0x03	; 3
     7c6:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>
	
	InterpretPacketRoutine = (FuncPtr)AICI_InterpretPacket;
     7ca:	88 e4       	ldi	r24, 0x48	; 72
     7cc:	92 e1       	ldi	r25, 0x12	; 18
     7ce:	90 93 25 01 	sts	0x0125, r25
     7d2:	80 93 24 01 	sts	0x0124, r24
	V2P_RunStateMachine();
     7d6:	0e 94 52 0f 	call	0x1ea4 <V2P_RunStateMachine>
     7da:	08 95       	ret

000007dc <FUNCProgramDataflash>:
}

void FUNCProgramDataflash(void)
{
	USI_SPIInitMaster(eeprom_read_byte_169(&Param_SCKDuration));
     7dc:	80 e2       	ldi	r24, 0x20	; 32
     7de:	91 e0       	ldi	r25, 0x01	; 1
     7e0:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
     7e4:	0e 94 a3 09 	call	0x1346 <USI_SPIInitMaster>
	UseExernalDF = TRUE;
     7e8:	81 e0       	ldi	r24, 0x01	; 1
     7ea:	80 93 83 02 	sts	0x0283, r24
	DFSPIRoutinePointer = USI_SPITransmit;
     7ee:	85 ec       	ldi	r24, 0xC5	; 197
     7f0:	99 e0       	ldi	r25, 0x09	; 9
     7f2:	90 93 01 01 	sts	0x0101, r25
     7f6:	80 93 00 01 	sts	0x0100, r24
	
	LCD_puts_f(DataFlashProgMode);
     7fa:	8a eb       	ldi	r24, 0xBA	; 186
     7fc:	93 e0       	ldi	r25, 0x03	; 3
     7fe:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>

	InterpretPacketRoutine = PD_InterpretAVRISPPacket;
     802:	86 ea       	ldi	r24, 0xA6	; 166
     804:	9c e0       	ldi	r25, 0x0C	; 12
     806:	90 93 25 01 	sts	0x0125, r25
     80a:	80 93 24 01 	sts	0x0124, r24
	V2P_RunStateMachine();
     80e:	0e 94 52 0f 	call	0x1ea4 <V2P_RunStateMachine>
	   
	DF_EnableDataflash(FALSE);
     812:	80 e0       	ldi	r24, 0x00	; 0
     814:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
	SPI_SPIOFF();
     818:	80 91 64 00 	lds	r24, 0x0064
     81c:	84 60       	ori	r24, 0x04	; 4
     81e:	80 93 64 00 	sts	0x0064, r24
     822:	08 95       	ret

00000824 <FUNCProgramAVR>:
}

void FUNCProgramAVR(void)
{
     824:	df 92       	push	r13
     826:	ef 92       	push	r14
     828:	ff 92       	push	r15
     82a:	0f 93       	push	r16
     82c:	1f 93       	push	r17
     82e:	cf 93       	push	r28
     830:	df 93       	push	r29
     832:	cd b7       	in	r28, 0x3d	; 61
     834:	de b7       	in	r29, 0x3e	; 62
     836:	65 97       	sbiw	r28, 0x15	; 21
     838:	0f b6       	in	r0, 0x3f	; 63
     83a:	f8 94       	cli
     83c:	de bf       	out	0x3e, r29	; 62
     83e:	0f be       	out	0x3f, r0	; 63
     840:	cd bf       	out	0x3d, r28	; 61
	uint8_t  DoneFailMessageBuff[19];
	uint16_t EEPROMAddress;
	uint8_t  Fault = ISPCC_NO_FAULT;
     842:	dd 24       	eor	r13, r13
	uint8_t  ProgMode = 0;
     844:	0d 2d       	mov	r16, r13

	SPI_SPIInit();
     846:	0e 94 35 09 	call	0x126a <SPI_SPIInit>
	UseExernalDF = FALSE;
     84a:	d0 92 83 02 	sts	0x0283, r13
	DFSPIRoutinePointer = SPI_SPITransmit;
     84e:	8f e3       	ldi	r24, 0x3F	; 63
     850:	99 e0       	ldi	r25, 0x09	; 9
     852:	90 93 01 01 	sts	0x0101, r25
     856:	80 93 00 01 	sts	0x0100, r24
	
	if (!(DF_CheckCorrectOnboardChip()))
     85a:	0e 94 b1 0b 	call	0x1762 <DF_CheckCorrectOnboardChip>
     85e:	88 23       	and	r24, r24
     860:	09 f4       	brne	.+2      	; 0x864 <FUNCProgramAVR+0x40>
     862:	17 c1       	rjmp	.+558    	; 0xa92 <FUNCProgramAVR+0x26e>
	  return;

	MAIN_WaitForJoyRelease();
     864:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
	
	JoyStatus = 1;                            // Use an invalid joystick value to force the program to write the
     868:	81 e0       	ldi	r24, 0x01	; 1
     86a:	8e bb       	out	0x1e, r24	; 30
	                                          // name of the default command onto the LCD
	while (1)
	{
		if (JoyStatus)
     86c:	8e b3       	in	r24, 0x1e	; 30
     86e:	88 23       	and	r24, r24
     870:	e9 f3       	breq	.-6      	; 0x86c <FUNCProgramAVR+0x48>
		{
			if (JoyStatus & JOY_LEFT)
     872:	f2 99       	sbic	0x1e, 2	; 30
     874:	0e c1       	rjmp	.+540    	; 0xa92 <FUNCProgramAVR+0x26e>
			  return;
			else if (JoyStatus & JOY_PRESS)
     876:	f4 99       	sbic	0x1e, 4	; 30
     878:	1c c0       	rjmp	.+56     	; 0x8b2 <FUNCProgramAVR+0x8e>
			  break;
			else if (JoyStatus & JOY_UP)
     87a:	f6 9b       	sbis	0x1e, 6	; 30
     87c:	06 c0       	rjmp	.+12     	; 0x88a <FUNCProgramAVR+0x66>
			  (ProgMode == 0)? ProgMode = 6 : ProgMode--;
     87e:	00 23       	and	r16, r16
     880:	11 f4       	brne	.+4      	; 0x886 <FUNCProgramAVR+0x62>
     882:	06 e0       	ldi	r16, 0x06	; 6
     884:	09 c0       	rjmp	.+18     	; 0x898 <FUNCProgramAVR+0x74>
     886:	01 50       	subi	r16, 0x01	; 1
     888:	07 c0       	rjmp	.+14     	; 0x898 <FUNCProgramAVR+0x74>
			else if (JoyStatus & JOY_DOWN)
     88a:	f7 9b       	sbis	0x1e, 7	; 30
     88c:	05 c0       	rjmp	.+10     	; 0x898 <FUNCProgramAVR+0x74>
			  (ProgMode == 6)? ProgMode = 0 : ProgMode++;
     88e:	06 30       	cpi	r16, 0x06	; 6
     890:	11 f4       	brne	.+4      	; 0x896 <FUNCProgramAVR+0x72>
     892:	00 e0       	ldi	r16, 0x00	; 0
     894:	01 c0       	rjmp	.+2      	; 0x898 <FUNCProgramAVR+0x74>
     896:	0f 5f       	subi	r16, 0xFF	; 255

			LCD_puts_f((uint8_t*)pgm_read_word(&ProgOptions[ProgMode])); // Show current function onto the LCD
     898:	e0 2f       	mov	r30, r16
     89a:	ff 27       	eor	r31, r31
     89c:	ee 0f       	add	r30, r30
     89e:	ff 1f       	adc	r31, r31
     8a0:	e3 55       	subi	r30, 0x53	; 83
     8a2:	ff 4f       	sbci	r31, 0xFF	; 255
     8a4:	85 91       	lpm	r24, Z+
     8a6:	94 91       	lpm	r25, Z
     8a8:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     8ac:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     8b0:	dd cf       	rjmp	.-70     	; 0x86c <FUNCProgramAVR+0x48>
		}
	}

	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);                // Orange = busy
     8b2:	81 b3       	in	r24, 0x11	; 17
     8b4:	80 63       	ori	r24, 0x30	; 48
     8b6:	81 bb       	out	0x11, r24	; 17
	LCD_puts_f(WaitText);
     8b8:	8c e2       	ldi	r24, 0x2C	; 44
     8ba:	92 e0       	ldi	r25, 0x02	; 2
     8bc:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>

	USI_SPIInitMaster(eeprom_read_byte_169(&Param_SCKDuration));
     8c0:	80 e2       	ldi	r24, 0x20	; 32
     8c2:	91 e0       	ldi	r25, 0x01	; 1
     8c4:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
     8c8:	0e 94 a3 09 	call	0x1346 <USI_SPIInitMaster>
	MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE); // Capture the RESET line of the slave AVR
     8cc:	80 e0       	ldi	r24, 0x00	; 0
     8ce:	0e 94 15 03 	call	0x62a <MAIN_ResetCSLine>

	EEPROMAddress = Prog_EnterProgMode;
     8d2:	80 91 12 01 	lds	r24, 0x0112
     8d6:	90 91 13 01 	lds	r25, 0x0113
     8da:	9d 8b       	std	Y+21, r25	; 0x15
     8dc:	8c 8b       	std	Y+20, r24	; 0x14
     8de:	56 e3       	ldi	r21, 0x36	; 54
     8e0:	e5 2e       	mov	r14, r21
     8e2:	51 e0       	ldi	r21, 0x01	; 1
     8e4:	f5 2e       	mov	r15, r21
     8e6:	1b e0       	ldi	r17, 0x0B	; 11
			
	for (uint8_t PacketB = 0; PacketB <= 11; PacketB++) // Read the enter programming mode command bytes
	{
		PacketBytes[PacketB] = eeprom_read_byte_169(&EEPROMAddress);
     8e8:	ce 01       	movw	r24, r28
     8ea:	44 96       	adiw	r24, 0x14	; 20
     8ec:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
     8f0:	f7 01       	movw	r30, r14
     8f2:	81 93       	st	Z+, r24
     8f4:	7f 01       	movw	r14, r30
		EEPROMAddress++;
     8f6:	8c 89       	ldd	r24, Y+20	; 0x14
     8f8:	9d 89       	ldd	r25, Y+21	; 0x15
     8fa:	01 96       	adiw	r24, 0x01	; 1
     8fc:	9d 8b       	std	Y+21, r25	; 0x15
     8fe:	8c 8b       	std	Y+20, r24	; 0x14
     900:	11 50       	subi	r17, 0x01	; 1
     902:	17 ff       	sbrs	r17, 7
     904:	f1 cf       	rjmp	.-30     	; 0x8e8 <FUNCProgramAVR+0xc4>
	}
	
	ISPCC_EnterChipProgrammingMode();    // Try to sync with the slave AVR
     906:	0e 94 b2 10 	call	0x2164 <ISPCC_EnterChipProgrammingMode>

	CurrAddress = 0;
     90a:	10 92 2d 01 	sts	0x012D, r1
     90e:	10 92 2e 01 	sts	0x012E, r1
     912:	10 92 2f 01 	sts	0x012F, r1
     916:	10 92 30 01 	sts	0x0130, r1

	if (PacketBytes[1] == STATUS_CMD_OK) // ISPCC_EnterChipProgrammingMode alters the PacketBytes buffer rather than returning a value
     91a:	80 91 37 01 	lds	r24, 0x0137
     91e:	88 23       	and	r24, r24
     920:	09 f0       	breq	.+2      	; 0x924 <FUNCProgramAVR+0x100>
     922:	a2 c0       	rjmp	.+324    	; 0xa68 <FUNCProgramAVR+0x244>
	{						
		if ((ProgMode == 6) || (ProgMode == 0) || (ProgMode == 2)) // Erase chip, or program flash mode
     924:	06 30       	cpi	r16, 0x06	; 6
     926:	21 f0       	breq	.+8      	; 0x930 <FUNCProgramAVR+0x10c>
     928:	00 23       	and	r16, r16
     92a:	11 f0       	breq	.+4      	; 0x930 <FUNCProgramAVR+0x10c>
     92c:	02 30       	cpi	r16, 0x02	; 2
     92e:	91 f4       	brne	.+36     	; 0x954 <FUNCProgramAVR+0x130>
		{
			MAIN_ShowProgType('C');
     930:	83 e4       	ldi	r24, 0x43	; 67
     932:	0e 94 48 03 	call	0x690 <MAIN_ShowProgType>
			
			if (!(eeprom_read_byte_169(&Prog_EraseCmdStored) == TRUE))
     936:	8a e1       	ldi	r24, 0x1A	; 26
     938:	91 e0       	ldi	r25, 0x01	; 1
     93a:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
     93e:	81 30       	cpi	r24, 0x01	; 1
     940:	39 f0       	breq	.+14     	; 0x950 <FUNCProgramAVR+0x12c>
			{
				Fault = ISPCC_FAULT_NOERASE;
     942:	42 e0       	ldi	r20, 0x02	; 2
     944:	d4 2e       	mov	r13, r20
				MAIN_ShowError(PSTR("NO ERASE CMD"));
     946:	87 e6       	ldi	r24, 0x67	; 103
     948:	92 e0       	ldi	r25, 0x02	; 2
     94a:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
     94e:	02 c0       	rjmp	.+4      	; 0x954 <FUNCProgramAVR+0x130>
			}
			else
			{
				PM_SendEraseCommand();
     950:	0e 94 71 18 	call	0x30e2 <PM_SendEraseCommand>
			}
		}

		if (((ProgMode == 0) || (ProgMode == 2)) && (Fault == ISPCC_NO_FAULT)) // Program flash
     954:	00 23       	and	r16, r16
     956:	11 f0       	breq	.+4      	; 0x95c <FUNCProgramAVR+0x138>
     958:	02 30       	cpi	r16, 0x02	; 2
     95a:	c1 f4       	brne	.+48     	; 0x98c <FUNCProgramAVR+0x168>
     95c:	dd 20       	and	r13, r13
     95e:	b1 f4       	brne	.+44     	; 0x98c <FUNCProgramAVR+0x168>
		{
			MAIN_ShowProgType('D');
     960:	84 e4       	ldi	r24, 0x44	; 68
     962:	0e 94 48 03 	call	0x690 <MAIN_ShowProgType>

			if (!(PM_GetStoredDataSize(TYPE_FLASH))) // Check to make sure a program is present in memory
     966:	81 e0       	ldi	r24, 0x01	; 1
     968:	0e 94 b7 13 	call	0x276e <PM_GetStoredDataSize>
     96c:	dc 01       	movw	r26, r24
     96e:	cb 01       	movw	r24, r22
     970:	00 97       	sbiw	r24, 0x00	; 0
     972:	a1 05       	cpc	r26, r1
     974:	b1 05       	cpc	r27, r1
     976:	39 f4       	brne	.+14     	; 0x986 <FUNCProgramAVR+0x162>
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
     978:	33 e0       	ldi	r19, 0x03	; 3
     97a:	d3 2e       	mov	r13, r19
				MAIN_ShowError(PSTR("NO DATA"));
     97c:	84 e7       	ldi	r24, 0x74	; 116
     97e:	92 e0       	ldi	r25, 0x02	; 2
     980:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
     984:	03 c0       	rjmp	.+6      	; 0x98c <FUNCProgramAVR+0x168>
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_FLASH);
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	0e 94 c1 18 	call	0x3182 <PM_CreateProgrammingPackets>
			}
		}
	
		if ((ProgMode == 1) || (ProgMode == 2)) // Program EEPROM
     98c:	80 2f       	mov	r24, r16
     98e:	81 50       	subi	r24, 0x01	; 1
     990:	82 30       	cpi	r24, 0x02	; 2
     992:	b0 f4       	brcc	.+44     	; 0x9c0 <FUNCProgramAVR+0x19c>
		{
			MAIN_ShowProgType('E');
     994:	85 e4       	ldi	r24, 0x45	; 69
     996:	0e 94 48 03 	call	0x690 <MAIN_ShowProgType>
				
			if (!(PM_GetStoredDataSize(TYPE_EEPROM))) // Check to make sure EEPROM data is present in memory
     99a:	80 e0       	ldi	r24, 0x00	; 0
     99c:	0e 94 b7 13 	call	0x276e <PM_GetStoredDataSize>
     9a0:	dc 01       	movw	r26, r24
     9a2:	cb 01       	movw	r24, r22
     9a4:	00 97       	sbiw	r24, 0x00	; 0
     9a6:	a1 05       	cpc	r26, r1
     9a8:	b1 05       	cpc	r27, r1
     9aa:	39 f4       	brne	.+14     	; 0x9ba <FUNCProgramAVR+0x196>
			{
				Fault = ISPCC_FAULT_NODATATYPE;
     9ac:	23 e0       	ldi	r18, 0x03	; 3
     9ae:	d2 2e       	mov	r13, r18
				MAIN_ShowError(PSTR("NO EEPROM"));
     9b0:	8c e7       	ldi	r24, 0x7C	; 124
     9b2:	92 e0       	ldi	r25, 0x02	; 2
     9b4:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
     9b8:	03 c0       	rjmp	.+6      	; 0x9c0 <FUNCProgramAVR+0x19c>
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_EEPROM);
     9ba:	80 e0       	ldi	r24, 0x00	; 0
     9bc:	0e 94 c1 18 	call	0x3182 <PM_CreateProgrammingPackets>
			}
		}

		if ((ProgMode == 3) || (ProgMode == 5)) // Program Fuse bytes
     9c0:	03 30       	cpi	r16, 0x03	; 3
     9c2:	11 f0       	breq	.+4      	; 0x9c8 <FUNCProgramAVR+0x1a4>
     9c4:	05 30       	cpi	r16, 0x05	; 5
     9c6:	99 f4       	brne	.+38     	; 0x9ee <FUNCProgramAVR+0x1ca>
		{
			MAIN_ShowProgType('F');
     9c8:	86 e4       	ldi	r24, 0x46	; 70
     9ca:	0e 94 48 03 	call	0x690 <MAIN_ShowProgType>
			
			if (!(eeprom_read_byte_169(&Prog_TotalFuseBytes)))
     9ce:	80 e1       	ldi	r24, 0x10	; 16
     9d0:	91 e0       	ldi	r25, 0x01	; 1
     9d2:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
     9d6:	88 23       	and	r24, r24
     9d8:	39 f4       	brne	.+14     	; 0x9e8 <FUNCProgramAVR+0x1c4>
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
     9da:	93 e0       	ldi	r25, 0x03	; 3
     9dc:	d9 2e       	mov	r13, r25
				MAIN_ShowError(PSTR("NO FUSE BYTES"));
     9de:	86 e8       	ldi	r24, 0x86	; 134
     9e0:	92 e0       	ldi	r25, 0x02	; 2
     9e2:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
     9e6:	03 c0       	rjmp	.+6      	; 0x9ee <FUNCProgramAVR+0x1ca>
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_FUSE);
     9e8:	82 e0       	ldi	r24, 0x02	; 2
     9ea:	0e 94 21 18 	call	0x3042 <PM_SendFuseLockBytes>
			}
		}

		if ((ProgMode == 4) || (ProgMode == 5)) // Program Lock bytes
     9ee:	80 2f       	mov	r24, r16
     9f0:	84 50       	subi	r24, 0x04	; 4
     9f2:	82 30       	cpi	r24, 0x02	; 2
     9f4:	00 f5       	brcc	.+64     	; 0xa36 <FUNCProgramAVR+0x212>
		{
			if (ProgMode == 5)                    // If fusebytes have already been written, we need to reenter programming mode to latch them
     9f6:	05 30       	cpi	r16, 0x05	; 5
     9f8:	59 f4       	brne	.+22     	; 0xa10 <FUNCProgramAVR+0x1ec>
			{
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line of the slave AVR
     9fa:	81 e0       	ldi	r24, 0x01	; 1
     9fc:	0e 94 15 03 	call	0x62a <MAIN_ResetCSLine>
				MAIN_Delay10MS(1);
     a00:	81 e0       	ldi	r24, 0x01	; 1
     a02:	0e 94 27 02 	call	0x44e <MAIN_Delay10MS>
				MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE); // Capture the RESET line of the slave AVR
     a06:	80 e0       	ldi	r24, 0x00	; 0
     a08:	0e 94 15 03 	call	0x62a <MAIN_ResetCSLine>
				ISPCC_EnterChipProgrammingMode(); // Try to sync with the slave AVR
     a0c:	0e 94 b2 10 	call	0x2164 <ISPCC_EnterChipProgrammingMode>
			}

			MAIN_ShowProgType('L');
     a10:	8c e4       	ldi	r24, 0x4C	; 76
     a12:	0e 94 48 03 	call	0x690 <MAIN_ShowProgType>
		
			if (!(eeprom_read_byte_169(&Prog_TotalLockBytes)))
     a16:	8e e0       	ldi	r24, 0x0E	; 14
     a18:	91 e0       	ldi	r25, 0x01	; 1
     a1a:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
     a1e:	88 23       	and	r24, r24
     a20:	39 f4       	brne	.+14     	; 0xa30 <FUNCProgramAVR+0x20c>
			{
				Fault = ISPCC_FAULT_NODATATYPE;
     a22:	83 e0       	ldi	r24, 0x03	; 3
     a24:	d8 2e       	mov	r13, r24
				MAIN_ShowError(PSTR("NO LOCK BYTES"));
     a26:	84 e9       	ldi	r24, 0x94	; 148
     a28:	92 e0       	ldi	r25, 0x02	; 2
     a2a:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
     a2e:	03 c0       	rjmp	.+6      	; 0xa36 <FUNCProgramAVR+0x212>
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_LOCK);
     a30:	83 e0       	ldi	r24, 0x03	; 3
     a32:	0e 94 21 18 	call	0x3042 <PM_SendFuseLockBytes>
			}
		}

		strcpy_P(DoneFailMessageBuff, PSTR("PROGRAMMING DONE"));
     a36:	62 ea       	ldi	r22, 0xA2	; 162
     a38:	72 e0       	ldi	r23, 0x02	; 2
     a3a:	ce 01       	movw	r24, r28
     a3c:	01 96       	adiw	r24, 0x01	; 1
     a3e:	0e 94 6a 1b 	call	0x36d4 <strcpy_P>

		if (Fault != ISPCC_NO_FAULT)         // Takes less code to just overwrite part of the string on fail
     a42:	dd 20       	and	r13, r13
     a44:	31 f0       	breq	.+12     	; 0xa52 <FUNCProgramAVR+0x22e>
		  strcpy_P(&DoneFailMessageBuff[12], PSTR("FAILED"));
     a46:	63 eb       	ldi	r22, 0xB3	; 179
     a48:	72 e0       	ldi	r23, 0x02	; 2
     a4a:	ce 01       	movw	r24, r28
     a4c:	0d 96       	adiw	r24, 0x0d	; 13
     a4e:	0e 94 6a 1b 	call	0x36d4 <strcpy_P>

		LCD_puts(DoneFailMessageBuff);
     a52:	ce 01       	movw	r24, r28
     a54:	01 96       	adiw	r24, 0x01	; 1
     a56:	0e 94 bb 07 	call	0xf76 <LCD_puts>

		MAIN_Delay10MS(255);
     a5a:	8f ef       	ldi	r24, 0xFF	; 255
     a5c:	0e 94 27 02 	call	0x44e <MAIN_Delay10MS>
		MAIN_Delay10MS(100);
     a60:	84 e6       	ldi	r24, 0x64	; 100
     a62:	0e 94 27 02 	call	0x44e <MAIN_Delay10MS>
     a66:	04 c0       	rjmp	.+8      	; 0xa70 <FUNCProgramAVR+0x24c>
	}
	else
	{
		MAIN_ShowError(SyncErrorMessage);
     a68:	89 ed       	ldi	r24, 0xD9	; 217
     a6a:	93 e0       	ldi	r25, 0x03	; 3
     a6c:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
	}
	
	MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run	
     a70:	81 e0       	ldi	r24, 0x01	; 1
     a72:	0e 94 15 03 	call	0x62a <MAIN_ResetCSLine>
	USI_SPIOff();
     a76:	0e 94 bb 09 	call	0x1376 <USI_SPIOff>
	DF_EnableDataflash(FALSE);
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
	SPI_SPIOFF();
     a80:	80 91 64 00 	lds	r24, 0x0064
     a84:	84 60       	ori	r24, 0x04	; 4
     a86:	80 93 64 00 	sts	0x0064, r24
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Green = ready
     a8a:	81 b3       	in	r24, 0x11	; 17
     a8c:	8f 7c       	andi	r24, 0xCF	; 207
     a8e:	80 61       	ori	r24, 0x10	; 16
     a90:	81 bb       	out	0x11, r24	; 17
     a92:	65 96       	adiw	r28, 0x15	; 21
     a94:	0f b6       	in	r0, 0x3f	; 63
     a96:	f8 94       	cli
     a98:	de bf       	out	0x3e, r29	; 62
     a9a:	0f be       	out	0x3f, r0	; 63
     a9c:	cd bf       	out	0x3d, r28	; 61
     a9e:	df 91       	pop	r29
     aa0:	cf 91       	pop	r28
     aa2:	1f 91       	pop	r17
     aa4:	0f 91       	pop	r16
     aa6:	ff 90       	pop	r15
     aa8:	ef 90       	pop	r14
     aaa:	df 90       	pop	r13
     aac:	08 95       	ret

00000aae <FUNCStoreProgram>:
}

void FUNCStoreProgram(void)
{
	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
     aae:	8f e3       	ldi	r24, 0x3F	; 63
     ab0:	99 e0       	ldi	r25, 0x09	; 9
     ab2:	90 93 01 01 	sts	0x0101, r25
     ab6:	80 93 00 01 	sts	0x0100, r24
	SPI_SPIInit();
     aba:	0e 94 35 09 	call	0x126a <SPI_SPIInit>
	UseExernalDF = FALSE;
     abe:	10 92 83 02 	sts	0x0283, r1
	DF_EnableDataflash(TRUE);
     ac2:	81 e0       	ldi	r24, 0x01	; 1
     ac4:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>

	if (!(DF_CheckCorrectOnboardChip()))
     ac8:	0e 94 b1 0b 	call	0x1762 <DF_CheckCorrectOnboardChip>
     acc:	88 23       	and	r24, r24
     ace:	a1 f0       	breq	.+40     	; 0xaf8 <FUNCStoreProgram+0x4a>
	  return;
			
	LCD_puts_f(PSTR("*STORAGE MODE*"));
     ad0:	8a eb       	ldi	r24, 0xBA	; 186
     ad2:	92 e0       	ldi	r25, 0x02	; 2
     ad4:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>

	InterpretPacketRoutine = (FuncPtr)PM_InterpretAVRISPPacket;
     ad8:	8f e5       	ldi	r24, 0x5F	; 95
     ada:	95 e1       	ldi	r25, 0x15	; 21
     adc:	90 93 25 01 	sts	0x0125, r25
     ae0:	80 93 24 01 	sts	0x0124, r24
	V2P_RunStateMachine();
     ae4:	0e 94 52 0f 	call	0x1ea4 <V2P_RunStateMachine>
	DF_EnableDataflash(FALSE);
     ae8:	80 e0       	ldi	r24, 0x00	; 0
     aea:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
	SPI_SPIOFF();
     aee:	80 91 64 00 	lds	r24, 0x0064
     af2:	84 60       	ori	r24, 0x04	; 4
     af4:	80 93 64 00 	sts	0x0064, r24
     af8:	08 95       	ret

00000afa <FUNCClearMem>:
}

void FUNCClearMem(void)
{
     afa:	0f 93       	push	r16
     afc:	1f 93       	push	r17
     afe:	cf 93       	push	r28
     b00:	df 93       	push	r29
     b02:	cd b7       	in	r28, 0x3d	; 61
     b04:	de b7       	in	r29, 0x3e	; 62
     b06:	22 97       	sbiw	r28, 0x02	; 2
     b08:	0f b6       	in	r0, 0x3f	; 63
     b0a:	f8 94       	cli
     b0c:	de bf       	out	0x3e, r29	; 62
     b0e:	0f be       	out	0x3f, r0	; 63
     b10:	cd bf       	out	0x3d, r28	; 61
	LCD_puts_f(PSTR("CONFIRM"));
     b12:	89 ec       	ldi	r24, 0xC9	; 201
     b14:	92 e0       	ldi	r25, 0x02	; 2
     b16:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>
	MAIN_Delay10MS(180);
     b1a:	84 eb       	ldi	r24, 0xB4	; 180
     b1c:	0e 94 27 02 	call	0x44e <MAIN_Delay10MS>

	LCD_puts_f(PSTR("<N Y>"));
     b20:	81 ed       	ldi	r24, 0xD1	; 209
     b22:	92 e0       	ldi	r25, 0x02	; 2
     b24:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>

	while (1)
	{
		if (JoyStatus)
     b28:	8e b3       	in	r24, 0x1e	; 30
     b2a:	88 23       	and	r24, r24
     b2c:	e9 f3       	breq	.-6      	; 0xb28 <FUNCClearMem+0x2e>
		{
			if (JoyStatus & JOY_LEFT)
     b2e:	8e b3       	in	r24, 0x1e	; 30
     b30:	99 27       	eor	r25, r25
     b32:	8c 01       	movw	r16, r24
     b34:	04 70       	andi	r16, 0x04	; 4
     b36:	10 70       	andi	r17, 0x00	; 0
     b38:	82 fd       	sbrc	r24, 2
     b3a:	29 c0       	rjmp	.+82     	; 0xb8e <FUNCClearMem+0x94>
			  return;
			else if (JoyStatus & JOY_RIGHT)
     b3c:	f3 9b       	sbis	0x1e, 3	; 30
     b3e:	f4 cf       	rjmp	.-24     	; 0xb28 <FUNCClearMem+0x2e>
			  break;
		}
	}

	MAIN_WaitForJoyRelease();
     b40:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>

	LCD_puts_f(WaitText);
     b44:	8c e2       	ldi	r24, 0x2C	; 44
     b46:	92 e0       	ldi	r25, 0x02	; 2
     b48:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>

	for (uint16_t EAddr = 0; EAddr < Sys_MagicNumber; EAddr++)
     b4c:	1a 83       	std	Y+2, r17	; 0x02
     b4e:	09 83       	std	Y+1, r16	; 0x01
     b50:	80 91 02 01 	lds	r24, 0x0102
     b54:	90 91 03 01 	lds	r25, 0x0103
     b58:	08 17       	cp	r16, r24
     b5a:	19 07       	cpc	r17, r25
     b5c:	88 f4       	brcc	.+34     	; 0xb80 <FUNCClearMem+0x86>
	  eeprom_write_byte_169(&EAddr, 0xFF);
     b5e:	6f ef       	ldi	r22, 0xFF	; 255
     b60:	ce 01       	movw	r24, r28
     b62:	01 96       	adiw	r24, 0x01	; 1
     b64:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
     b68:	89 81       	ldd	r24, Y+1	; 0x01
     b6a:	9a 81       	ldd	r25, Y+2	; 0x02
     b6c:	01 96       	adiw	r24, 0x01	; 1
     b6e:	9a 83       	std	Y+2, r25	; 0x02
     b70:	89 83       	std	Y+1, r24	; 0x01
     b72:	20 91 02 01 	lds	r18, 0x0102
     b76:	30 91 03 01 	lds	r19, 0x0103
     b7a:	82 17       	cp	r24, r18
     b7c:	93 07       	cpc	r25, r19
     b7e:	78 f3       	brcs	.-34     	; 0xb5e <FUNCClearMem+0x64>

	LCD_puts_f(PSTR("MEM CLEARED"));
     b80:	87 ed       	ldi	r24, 0xD7	; 215
     b82:	92 e0       	ldi	r25, 0x02	; 2
     b84:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>
	MAIN_Delay10MS(255);
     b88:	8f ef       	ldi	r24, 0xFF	; 255
     b8a:	0e 94 27 02 	call	0x44e <MAIN_Delay10MS>
     b8e:	22 96       	adiw	r28, 0x02	; 2
     b90:	0f b6       	in	r0, 0x3f	; 63
     b92:	f8 94       	cli
     b94:	de bf       	out	0x3e, r29	; 62
     b96:	0f be       	out	0x3f, r0	; 63
     b98:	cd bf       	out	0x3d, r28	; 61
     b9a:	df 91       	pop	r29
     b9c:	cf 91       	pop	r28
     b9e:	1f 91       	pop	r17
     ba0:	0f 91       	pop	r16
     ba2:	08 95       	ret

00000ba4 <FUNCAutoCalib>:
}

void FUNCAutoCalib(void)
{
	LCD_puts_f(WaitText);
     ba4:	8c e2       	ldi	r24, 0x2C	; 44
     ba6:	92 e0       	ldi	r25, 0x02	; 2
     ba8:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>
	OSCCAL_Calibrate();
     bac:	0e 94 37 07 	call	0xe6e <OSCCAL_Calibrate>
     bb0:	08 95       	ret

00000bb2 <FUNCManCalib>:
}

void FUNCManCalib(void)
{
     bb2:	cf 93       	push	r28
     bb4:	df 93       	push	r29
     bb6:	cd b7       	in	r28, 0x3d	; 61
     bb8:	de b7       	in	r29, 0x3e	; 62
     bba:	29 97       	sbiw	r28, 0x09	; 9
     bbc:	0f b6       	in	r0, 0x3f	; 63
     bbe:	f8 94       	cli
     bc0:	de bf       	out	0x3e, r29	; 62
     bc2:	0f be       	out	0x3f, r0	; 63
     bc4:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[9];

	JoyStatus = 1;                           // Invalid value to force the LCD to update
     bc6:	81 e0       	ldi	r24, 0x01	; 1
     bc8:	8e bb       	out	0x1e, r24	; 30
	
	USART_ENABLE(USART_TX_ON, USART_RX_OFF);
     bca:	80 91 c1 00 	lds	r24, 0x00C1
     bce:	80 78       	andi	r24, 0x80	; 128
     bd0:	88 60       	ori	r24, 0x08	; 8
     bd2:	80 93 c1 00 	sts	0x00C1, r24

	while (1)
	{
		if (BuffElements)                    // Routine will also echo send chars (directly accesses the ringbuffer count var)
     bd6:	80 91 d1 02 	lds	r24, 0x02D1
     bda:	88 23       	and	r24, r24
     bdc:	21 f0       	breq	.+8      	; 0xbe6 <FUNCManCalib+0x34>
		   USART_Tx(BUFF_GetBuffByte());
     bde:	0e 94 fc 0b 	call	0x17f8 <BUFF_GetBuffByte>
     be2:	0e 94 ec 08 	call	0x11d8 <USART_Tx>
	
		if (JoyStatus)
     be6:	8e b3       	in	r24, 0x1e	; 30
     be8:	88 23       	and	r24, r24
     bea:	a9 f3       	breq	.-22     	; 0xbd6 <FUNCManCalib+0x24>
		{
			if (JoyStatus & JOY_UP)
     bec:	f6 9b       	sbis	0x1e, 6	; 30
     bee:	04 c0       	rjmp	.+8      	; 0xbf8 <FUNCManCalib+0x46>
			  OSCCAL++;
     bf0:	80 91 66 00 	lds	r24, 0x0066
     bf4:	8f 5f       	subi	r24, 0xFF	; 255
     bf6:	05 c0       	rjmp	.+10     	; 0xc02 <FUNCManCalib+0x50>
			else if (JoyStatus & JOY_DOWN)
     bf8:	f7 9b       	sbis	0x1e, 7	; 30
     bfa:	06 c0       	rjmp	.+12     	; 0xc08 <FUNCManCalib+0x56>
			  OSCCAL--;
     bfc:	80 91 66 00 	lds	r24, 0x0066
     c00:	81 50       	subi	r24, 0x01	; 1
     c02:	80 93 66 00 	sts	0x0066, r24
     c06:	02 c0       	rjmp	.+4      	; 0xc0c <FUNCManCalib+0x5a>
			else if (JoyStatus & JOY_LEFT)
     c08:	f2 99       	sbic	0x1e, 2	; 30
     c0a:	1f c0       	rjmp	.+62     	; 0xc4a <FUNCManCalib+0x98>
			  break;
					
			// Copy the programmer name out of memory and transmit it via the USART:
			strcpy_P(Buffer, ProgrammerName);
     c0c:	63 e2       	ldi	r22, 0x23	; 35
     c0e:	72 e0       	ldi	r23, 0x02	; 2
     c10:	ce 01       	movw	r24, r28
     c12:	01 96       	adiw	r24, 0x01	; 1
     c14:	0e 94 6a 1b 	call	0x36d4 <strcpy_P>
			USART_TxString(Buffer);
     c18:	ce 01       	movw	r24, r28
     c1a:	01 96       	adiw	r24, 0x01	; 1
     c1c:	0e 94 f4 08 	call	0x11e8 <USART_TxString>

			Buffer[0] = 'C';
     c20:	83 e4       	ldi	r24, 0x43	; 67
     c22:	89 83       	std	Y+1, r24	; 0x01
			Buffer[1] = 'V';
     c24:	86 e5       	ldi	r24, 0x56	; 86
     c26:	8a 83       	std	Y+2, r24	; 0x02
			Buffer[2] = ' ';
     c28:	80 e2       	ldi	r24, 0x20	; 32
     c2a:	8b 83       	std	Y+3, r24	; 0x03

			MAIN_IntToStr(OSCCAL, &Buffer[3]);
     c2c:	80 91 66 00 	lds	r24, 0x0066
     c30:	be 01       	movw	r22, r28
     c32:	6c 5f       	subi	r22, 0xFC	; 252
     c34:	7f 4f       	sbci	r23, 0xFF	; 255
     c36:	99 27       	eor	r25, r25
     c38:	0e 94 30 03 	call	0x660 <MAIN_IntToStr>
			LCD_puts(Buffer);
     c3c:	ce 01       	movw	r24, r28
     c3e:	01 96       	adiw	r24, 0x01	; 1
     c40:	0e 94 bb 07 	call	0xf76 <LCD_puts>

			MAIN_WaitForJoyRelease();
     c44:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     c48:	c6 cf       	rjmp	.-116    	; 0xbd6 <FUNCManCalib+0x24>
		}
	}
	
	USART_ENABLE(USART_TX_OFF, USART_RX_OFF);
     c4a:	80 91 c1 00 	lds	r24, 0x00C1
     c4e:	80 78       	andi	r24, 0x80	; 128
     c50:	80 93 c1 00 	sts	0x00C1, r24
     c54:	29 96       	adiw	r28, 0x09	; 9
     c56:	0f b6       	in	r0, 0x3f	; 63
     c58:	f8 94       	cli
     c5a:	de bf       	out	0x3e, r29	; 62
     c5c:	0f be       	out	0x3f, r0	; 63
     c5e:	cd bf       	out	0x3d, r28	; 61
     c60:	df 91       	pop	r29
     c62:	cf 91       	pop	r28
     c64:	08 95       	ret

00000c66 <FUNCSetContrast>:
}

void FUNCSetContrast(void)
{
     c66:	1f 93       	push	r17
     c68:	cf 93       	push	r28
     c6a:	df 93       	push	r29
     c6c:	cd b7       	in	r28, 0x3d	; 61
     c6e:	de b7       	in	r29, 0x3e	; 62
     c70:	26 97       	sbiw	r28, 0x06	; 6
     c72:	0f b6       	in	r0, 0x3f	; 63
     c74:	f8 94       	cli
     c76:	de bf       	out	0x3e, r29	; 62
     c78:	0f be       	out	0x3f, r0	; 63
     c7a:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[6];
	uint8_t Contrast = (eeprom_read_byte_169(&Sys_LCDContrast) & 0x0F); // Ranges from 0-15 so mask retuns 15 on blank EEPROM (0xFF)
     c7c:	84 e0       	ldi	r24, 0x04	; 4
     c7e:	91 e0       	ldi	r25, 0x01	; 1
     c80:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
     c84:	18 2f       	mov	r17, r24
     c86:	1f 70       	andi	r17, 0x0F	; 15
	
	JoyStatus = 1;                          // Invalid value to force the LCD to update
     c88:	81 e0       	ldi	r24, 0x01	; 1
     c8a:	8e bb       	out	0x1e, r24	; 30
	
	while (1)
	{
		if (JoyStatus)
     c8c:	8e b3       	in	r24, 0x1e	; 30
     c8e:	88 23       	and	r24, r24
     c90:	e9 f3       	breq	.-6      	; 0xc8c <FUNCSetContrast+0x26>
		{
			if (JoyStatus & JOY_UP)
     c92:	f6 9b       	sbis	0x1e, 6	; 30
     c94:	04 c0       	rjmp	.+8      	; 0xc9e <FUNCSetContrast+0x38>
			{
				if (Contrast < 15)
     c96:	1f 30       	cpi	r17, 0x0F	; 15
     c98:	80 f4       	brcc	.+32     	; 0xcba <FUNCSetContrast+0x54>
				  Contrast++;
     c9a:	1f 5f       	subi	r17, 0xFF	; 255
     c9c:	0e c0       	rjmp	.+28     	; 0xcba <FUNCSetContrast+0x54>
			}
			else if (JoyStatus & JOY_DOWN)
     c9e:	f7 9b       	sbis	0x1e, 7	; 30
     ca0:	04 c0       	rjmp	.+8      	; 0xcaa <FUNCSetContrast+0x44>
			{
				if (Contrast > 1)          // Zero is non-visible, so 1 is the minimum
     ca2:	12 30       	cpi	r17, 0x02	; 2
     ca4:	50 f0       	brcs	.+20     	; 0xcba <FUNCSetContrast+0x54>
				  Contrast--;
     ca6:	11 50       	subi	r17, 0x01	; 1
     ca8:	08 c0       	rjmp	.+16     	; 0xcba <FUNCSetContrast+0x54>
			}
			else if (JoyStatus & JOY_LEFT)
     caa:	f2 9b       	sbis	0x1e, 2	; 30
     cac:	06 c0       	rjmp	.+12     	; 0xcba <FUNCSetContrast+0x54>
			{
				eeprom_write_byte_169(&Sys_LCDContrast, Contrast);
     cae:	61 2f       	mov	r22, r17
     cb0:	84 e0       	ldi	r24, 0x04	; 4
     cb2:	91 e0       	ldi	r25, 0x01	; 1
     cb4:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
				return;
     cb8:	18 c0       	rjmp	.+48     	; 0xcea <FUNCSetContrast+0x84>
			}
					
			Buffer[0] = 'C';
     cba:	83 e4       	ldi	r24, 0x43	; 67
     cbc:	89 83       	std	Y+1, r24	; 0x01
			Buffer[1] = 'T';
     cbe:	84 e5       	ldi	r24, 0x54	; 84
     cc0:	8a 83       	std	Y+2, r24	; 0x02
			Buffer[2] = ' ';
     cc2:	80 e2       	ldi	r24, 0x20	; 32
     cc4:	8b 83       	std	Y+3, r24	; 0x03

			MAIN_IntToStr((uint16_t)Contrast, &Buffer[3]);
     cc6:	be 01       	movw	r22, r28
     cc8:	6c 5f       	subi	r22, 0xFC	; 252
     cca:	7f 4f       	sbci	r23, 0xFF	; 255
     ccc:	81 2f       	mov	r24, r17
     cce:	99 27       	eor	r25, r25
     cd0:	0e 94 30 03 	call	0x660 <MAIN_IntToStr>
			LCD_puts(Buffer);
     cd4:	ce 01       	movw	r24, r28
     cd6:	01 96       	adiw	r24, 0x01	; 1
     cd8:	0e 94 bb 07 	call	0xf76 <LCD_puts>

			LCD_CONTRAST_LEVEL(Contrast);
     cdc:	81 2f       	mov	r24, r17
     cde:	8f 70       	andi	r24, 0x0F	; 15
     ce0:	80 93 e7 00 	sts	0x00E7, r24

			MAIN_WaitForJoyRelease();
     ce4:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     ce8:	d1 cf       	rjmp	.-94     	; 0xc8c <FUNCSetContrast+0x26>
     cea:	26 96       	adiw	r28, 0x06	; 6
     cec:	0f b6       	in	r0, 0x3f	; 63
     cee:	f8 94       	cli
     cf0:	de bf       	out	0x3e, r29	; 62
     cf2:	0f be       	out	0x3f, r0	; 63
     cf4:	cd bf       	out	0x3d, r28	; 61
     cf6:	df 91       	pop	r29
     cf8:	cf 91       	pop	r28
     cfa:	1f 91       	pop	r17
     cfc:	08 95       	ret

00000cfe <FUNCSetISPSpeed>:
		}
	}
}

void FUNCSetISPSpeed(void)
{
     cfe:	cf 93       	push	r28
	JoyStatus = 1;                         // Invalid value to force the LCD to update
     d00:	81 e0       	ldi	r24, 0x01	; 1
     d02:	8e bb       	out	0x1e, r24	; 30

	uint8_t CurrSpeed = eeprom_read_byte_169(&Param_SCKDuration);
     d04:	80 e2       	ldi	r24, 0x20	; 32
     d06:	91 e0       	ldi	r25, 0x01	; 1
     d08:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
     d0c:	c8 2f       	mov	r28, r24

	if (CurrSpeed > (USI_PRESET_SPEEDS - 1)) CurrSpeed = 0; // Protection against blank EEPROM
     d0e:	84 30       	cpi	r24, 0x04	; 4
     d10:	08 f0       	brcs	.+2      	; 0xd14 <FUNCSetISPSpeed+0x16>
     d12:	c0 e0       	ldi	r28, 0x00	; 0

	while (1)
	{
		if (JoyStatus)
     d14:	8e b3       	in	r24, 0x1e	; 30
     d16:	88 23       	and	r24, r24
     d18:	e9 f3       	breq	.-6      	; 0xd14 <FUNCSetISPSpeed+0x16>
		{
			if (JoyStatus & JOY_UP)
     d1a:	f6 9b       	sbis	0x1e, 6	; 30
     d1c:	06 c0       	rjmp	.+12     	; 0xd2a <FUNCSetISPSpeed+0x2c>
			{
				(CurrSpeed == 0)? CurrSpeed = (USI_PRESET_SPEEDS - 1) : CurrSpeed--;
     d1e:	cc 23       	and	r28, r28
     d20:	11 f4       	brne	.+4      	; 0xd26 <FUNCSetISPSpeed+0x28>
     d22:	c3 e0       	ldi	r28, 0x03	; 3
     d24:	12 c0       	rjmp	.+36     	; 0xd4a <FUNCSetISPSpeed+0x4c>
     d26:	c1 50       	subi	r28, 0x01	; 1
     d28:	10 c0       	rjmp	.+32     	; 0xd4a <FUNCSetISPSpeed+0x4c>
			}
			else if (JoyStatus & JOY_DOWN)
     d2a:	f7 9b       	sbis	0x1e, 7	; 30
     d2c:	06 c0       	rjmp	.+12     	; 0xd3a <FUNCSetISPSpeed+0x3c>
			{
				(CurrSpeed == (USI_PRESET_SPEEDS - 1))? CurrSpeed = 0 : CurrSpeed++;
     d2e:	c3 30       	cpi	r28, 0x03	; 3
     d30:	11 f4       	brne	.+4      	; 0xd36 <FUNCSetISPSpeed+0x38>
     d32:	c0 e0       	ldi	r28, 0x00	; 0
     d34:	0a c0       	rjmp	.+20     	; 0xd4a <FUNCSetISPSpeed+0x4c>
     d36:	cf 5f       	subi	r28, 0xFF	; 255
     d38:	08 c0       	rjmp	.+16     	; 0xd4a <FUNCSetISPSpeed+0x4c>
			}
			else if (JoyStatus & JOY_LEFT)
     d3a:	f2 9b       	sbis	0x1e, 2	; 30
     d3c:	06 c0       	rjmp	.+12     	; 0xd4a <FUNCSetISPSpeed+0x4c>
			{
				eeprom_write_byte_169(&Param_SCKDuration, CurrSpeed);
     d3e:	6c 2f       	mov	r22, r28
     d40:	80 e2       	ldi	r24, 0x20	; 32
     d42:	91 e0       	ldi	r25, 0x01	; 1
     d44:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
				return;
     d48:	0d c0       	rjmp	.+26     	; 0xd64 <FUNCSetISPSpeed+0x66>
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&USIPSNamePtrs[CurrSpeed]));
     d4a:	ec 2f       	mov	r30, r28
     d4c:	ff 27       	eor	r31, r31
     d4e:	ee 0f       	add	r30, r30
     d50:	ff 1f       	adc	r31, r31
     d52:	e3 58       	subi	r30, 0x83	; 131
     d54:	ff 4f       	sbci	r31, 0xFF	; 255
     d56:	85 91       	lpm	r24, Z+
     d58:	94 91       	lpm	r25, Z
     d5a:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     d5e:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     d62:	d8 cf       	rjmp	.-80     	; 0xd14 <FUNCSetISPSpeed+0x16>
     d64:	cf 91       	pop	r28
     d66:	08 95       	ret

00000d68 <FUNCSleepMode>:
		}
	}
}

void FUNCSleepMode(void)
{
	SMCR    = ((1 << SM1) | (1 << SE));   // Power down sleep mode
     d68:	85 e0       	ldi	r24, 0x05	; 5
     d6a:	83 bf       	out	0x33, r24	; 51
	LCDCRA &= ~(1 << LCDEN); 
     d6c:	80 91 e4 00 	lds	r24, 0x00E4
     d70:	8f 77       	andi	r24, 0x7F	; 127
     d72:	80 93 e4 00 	sts	0x00E4, r24
	
	while (!(JoyStatus & JOY_UP))        // Joystick interrupt wakes the micro
	  SLEEP();
     d76:	f6 99       	sbic	0x1e, 6	; 30
     d78:	03 c0       	rjmp	.+6      	; 0xd80 <FUNCSleepMode+0x18>
     d7a:	88 95       	sleep
     d7c:	f6 9b       	sbis	0x1e, 6	; 30
     d7e:	fd cf       	rjmp	.-6      	; 0xd7a <FUNCSleepMode+0x12>
	   
	LCDCRA |= (1 << LCDEN);
     d80:	80 91 e4 00 	lds	r24, 0x00E4
     d84:	80 68       	ori	r24, 0x80	; 128
     d86:	80 93 e4 00 	sts	0x00E4, r24

	LCD_puts_f(WaitText);
     d8a:	8c e2       	ldi	r24, 0x2C	; 44
     d8c:	92 e0       	ldi	r25, 0x02	; 2
     d8e:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>
	OSCCAL_Calibrate();	
     d92:	0e 94 37 07 	call	0xe6e <OSCCAL_Calibrate>
	
	MAIN_WaitForJoyRelease();
     d96:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     d9a:	08 95       	ret

00000d9c <FUNCStorageInfo>:
}

void FUNCStorageInfo(void)
{
     d9c:	1f 93       	push	r17
     d9e:	cf 93       	push	r28
	uint8_t SelectedItem = 0;
     da0:	10 e0       	ldi	r17, 0x00	; 0

	MAIN_WaitForJoyRelease();
     da2:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>

	JoyStatus = 1;                         // Invalid value to force the LCD to update
     da6:	81 e0       	ldi	r24, 0x01	; 1
     da8:	8e bb       	out	0x1e, r24	; 30

	while (1)
	{
		if (JoyStatus)
     daa:	8e b3       	in	r24, 0x1e	; 30
     dac:	88 23       	and	r24, r24
     dae:	e9 f3       	breq	.-6      	; 0xdaa <FUNCStorageInfo+0xe>
		{
			if ((JoyStatus & JOY_UP) || (JoyStatus & JOY_DOWN))
     db0:	f6 99       	sbic	0x1e, 6	; 30
     db2:	02 c0       	rjmp	.+4      	; 0xdb8 <FUNCStorageInfo+0x1c>
     db4:	f7 9b       	sbis	0x1e, 7	; 30
     db6:	03 c0       	rjmp	.+6      	; 0xdbe <FUNCStorageInfo+0x22>
			{
				SelectedItem ^= 1;
     db8:	81 e0       	ldi	r24, 0x01	; 1
     dba:	18 27       	eor	r17, r24
     dbc:	38 c0       	rjmp	.+112    	; 0xe2e <FUNCStorageInfo+0x92>
			}
			else if (JoyStatus & JOY_LEFT)
     dbe:	f2 99       	sbic	0x1e, 2	; 30
     dc0:	43 c0       	rjmp	.+134    	; 0xe48 <FUNCStorageInfo+0xac>
			{
				return;
			}
			else if (JoyStatus & JOY_PRESS)
     dc2:	f4 9b       	sbis	0x1e, 4	; 30
     dc4:	34 c0       	rjmp	.+104    	; 0xe2e <FUNCStorageInfo+0x92>
			{
				if (SelectedItem == 1)    // View storage tags
     dc6:	11 30       	cpi	r17, 0x01	; 1
     dc8:	81 f5       	brne	.+96     	; 0xe2a <FUNCStorageInfo+0x8e>
				{
					DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
     dca:	8f e3       	ldi	r24, 0x3F	; 63
     dcc:	99 e0       	ldi	r25, 0x09	; 9
     dce:	90 93 01 01 	sts	0x0101, r25
     dd2:	80 93 00 01 	sts	0x0100, r24
					SPI_SPIInit();
     dd6:	0e 94 35 09 	call	0x126a <SPI_SPIInit>
					UseExernalDF = FALSE;
     dda:	10 92 83 02 	sts	0x0283, r1
					DF_EnableDataflash(TRUE);
     dde:	81 2f       	mov	r24, r17
     de0:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>

					if (DF_CheckCorrectOnboardChip())
     de4:	0e 94 b1 0b 	call	0x1762 <DF_CheckCorrectOnboardChip>
     de8:	c8 2f       	mov	r28, r24
     dea:	88 23       	and	r24, r24
     dec:	41 f0       	breq	.+16     	; 0xdfe <FUNCStorageInfo+0x62>
					{
						TM_ShowTags();
     dee:	0e 94 42 1b 	call	0x3684 <TM_ShowTags>
						SPI_SPIOFF();
     df2:	80 91 64 00 	lds	r24, 0x0064
     df6:	84 60       	ori	r24, 0x04	; 4
     df8:	80 93 64 00 	sts	0x0064, r24
     dfc:	18 c0       	rjmp	.+48     	; 0xe2e <FUNCStorageInfo+0x92>
					}
					else if (!(PM_GetStoredDataSize(TYPE_FLASH)))
     dfe:	81 2f       	mov	r24, r17
     e00:	0e 94 b7 13 	call	0x276e <PM_GetStoredDataSize>
     e04:	dc 01       	movw	r26, r24
     e06:	cb 01       	movw	r24, r22
     e08:	00 97       	sbiw	r24, 0x00	; 0
     e0a:	a1 05       	cpc	r26, r1
     e0c:	b1 05       	cpc	r27, r1
     e0e:	79 f4       	brne	.+30     	; 0xe2e <FUNCStorageInfo+0x92>
					{
						DF_EnableDataflash(FALSE);
     e10:	8c 2f       	mov	r24, r28
     e12:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
						SPI_SPIOFF();
     e16:	80 91 64 00 	lds	r24, 0x0064
     e1a:	84 60       	ori	r24, 0x04	; 4
     e1c:	80 93 64 00 	sts	0x0064, r24

						MAIN_ShowError(PSTR("NO STORED PRGM"));
     e20:	83 ee       	ldi	r24, 0xE3	; 227
     e22:	92 e0       	ldi	r25, 0x02	; 2
     e24:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
     e28:	02 c0       	rjmp	.+4      	; 0xe2e <FUNCStorageInfo+0x92>
					}	
				}
				else                  // View stored data sizes
				{
					PM_ShowStoredItemSizes();
     e2a:	0e 94 1e 1a 	call	0x343c <PM_ShowStoredItemSizes>
				}
			}
			
			LCD_puts_f((uint8_t*)pgm_read_word(&SIFOOptionPtrs[SelectedItem]));
     e2e:	e1 2f       	mov	r30, r17
     e30:	ff 27       	eor	r31, r31
     e32:	ee 0f       	add	r30, r30
     e34:	ff 1f       	adc	r31, r31
     e36:	e4 5a       	subi	r30, 0xA4	; 164
     e38:	ff 4f       	sbci	r31, 0xFF	; 255
     e3a:	85 91       	lpm	r24, Z+
     e3c:	94 91       	lpm	r25, Z
     e3e:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>

			MAIN_WaitForJoyRelease();
     e42:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
     e46:	b1 cf       	rjmp	.-158    	; 0xdaa <FUNCStorageInfo+0xe>
     e48:	cf 91       	pop	r28
     e4a:	1f 91       	pop	r17
     e4c:	08 95       	ret

00000e4e <FUNCGoBootloader>:
		}
	}
}

void FUNCGoBootloader(void)
{
	MCUCR &= ~(1 << JTD);           // Turn on JTAG via code
     e4e:	85 b7       	in	r24, 0x35	; 53
     e50:	8f 77       	andi	r24, 0x7F	; 127
     e52:	85 bf       	out	0x35, r24	; 53
	MCUCR &= ~(1 << JTD);           // Twice as specified in datasheet
     e54:	85 b7       	in	r24, 0x35	; 53
     e56:	8f 77       	andi	r24, 0x7F	; 127
     e58:	85 bf       	out	0x35, r24	; 53
	
	LCD_puts_f(PSTR("*JTAG ON*"));
     e5a:	82 ef       	ldi	r24, 0xF2	; 242
     e5c:	92 e0       	ldi	r25, 0x02	; 2
     e5e:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>
	
	MAIN_WaitForJoyRelease();
     e62:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
	
	WDTCR = ((1<<WDCE) | (1<<WDE)); // Enable Watchdog Timer to give reset after minimum timeout
     e66:	88 e1       	ldi	r24, 0x18	; 24
     e68:	80 93 60 00 	sts	0x0060, r24
	while (1) {};                  // Eternal loop - when watchdog resets the AVR it will enter the bootloader
     e6c:	ff cf       	rjmp	.-2      	; 0xe6c <FUNCGoBootloader+0x1e>

00000e6e <OSCCAL_Calibrate>:
	unsigned char SREG_Backup;
	unsigned char LoopCount = 64; // Maximum range is 128, and starts from the middle, so 64 is the max number of iterations required
   
	// Make sure all clock division is turned off (8Mhz RC clock)
	CLKPR = (1 << CLKPCE);
     e6e:	80 e8       	ldi	r24, 0x80	; 128
     e70:	80 93 61 00 	sts	0x0061, r24
	CLKPR = 0;
     e74:	10 92 61 00 	sts	0x0061, r1

	// Inital OSCCAL of half its maximum for speed
	OSCCAL = (0x7F / 2);
     e78:	8f e3       	ldi	r24, 0x3F	; 63
     e7a:	80 93 66 00 	sts	0x0066, r24

	//Save the SREG
	SREG_Backup = SREG;
     e7e:	3f b7       	in	r19, 0x3f	; 63
    
	// Disable all timer 1 interrupts
	TIMSK1 = 0;
     e80:	10 92 6f 00 	sts	0x006F, r1
        
	// Set timer 2 to asyncronous mode (32.768KHz crystal)
	ASSR  = (1 << AS2);
     e84:	88 e0       	ldi	r24, 0x08	; 8
     e86:	80 93 b6 00 	sts	0x00B6, r24
        
	// Timer 2 overflow interrupt enable
	TIMSK2 = (1 << TOIE2);
     e8a:	81 e0       	ldi	r24, 0x01	; 1
     e8c:	80 93 70 00 	sts	0x0070, r24

	//Enable interrupts
	sei();
     e90:	78 94       	sei

	// Start both counters with no prescaling
	TCCR1B = (1 << CS10);
     e92:	80 93 81 00 	sts	0x0081, r24
	TCCR2A = (1 << CS20);
     e96:	80 93 b0 00 	sts	0x00B0, r24
	 	 
	// Wait until timer 2's external 32.768KHz crystal is stable
	while (ASSR & ((1 << TCN2UB) | (1 << TCR2UB) | (1 << OCR2UB)));
     e9a:	80 91 b6 00 	lds	r24, 0x00B6
     e9e:	99 27       	eor	r25, r25
     ea0:	87 70       	andi	r24, 0x07	; 7
     ea2:	90 70       	andi	r25, 0x00	; 0
     ea4:	00 97       	sbiw	r24, 0x00	; 0
     ea6:	c9 f7       	brne	.-14     	; 0xe9a <OSCCAL_Calibrate+0x2c>
    
	// Clear the timer values
	TCNT1 = 0;
     ea8:	90 93 85 00 	sts	0x0085, r25
     eac:	80 93 84 00 	sts	0x0084, r24
	TCNT2 = 0;
     eb0:	10 92 b2 00 	sts	0x00B2, r1
    
	while (LoopCount--)
	{
		// Let it take a few readings (60ms, approx 7 readings)
		_delay_ms(60);
        
		if (ActualCount > (TARGETCOUNT + 5))		    // Clock is running too fast
		{
			// Bit 7 selects low or high range - only low range is nessesary
			OSCCAL = ((OSCCAL - 1) & ~(1 << 7));
		}
		else if (ActualCount < (TARGETCOUNT - 5))		// Clock is running too slow
		{
			// Bit 7 selects low or high range - only low range is nessesary
			OSCCAL = ((OSCCAL + 1) & ~(1 << 7));
		}
		else		                                    // Clock is just right
		{
			break;
     eb4:	2f e3       	ldi	r18, 0x3F	; 63
     eb6:	fc 01       	movw	r30, r24
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     eb8:	cf 01       	movw	r24, r30
     eba:	01 97       	sbiw	r24, 0x01	; 1
     ebc:	f1 f7       	brne	.-4      	; 0xeba <OSCCAL_Calibrate+0x4c>
     ebe:	80 91 26 01 	lds	r24, 0x0126
     ec2:	90 91 27 01 	lds	r25, 0x0127
     ec6:	81 50       	subi	r24, 0x01	; 1
     ec8:	91 4e       	sbci	r25, 0xE1	; 225
     eca:	20 f0       	brcs	.+8      	; 0xed4 <OSCCAL_Calibrate+0x66>
     ecc:	80 91 66 00 	lds	r24, 0x0066
     ed0:	81 50       	subi	r24, 0x01	; 1
     ed2:	0a c0       	rjmp	.+20     	; 0xee8 <OSCCAL_Calibrate+0x7a>
     ed4:	80 91 26 01 	lds	r24, 0x0126
     ed8:	90 91 27 01 	lds	r25, 0x0127
     edc:	86 5f       	subi	r24, 0xF6	; 246
     ede:	90 4e       	sbci	r25, 0xE0	; 224
     ee0:	40 f4       	brcc	.+16     	; 0xef2 <OSCCAL_Calibrate+0x84>
     ee2:	80 91 66 00 	lds	r24, 0x0066
     ee6:	8f 5f       	subi	r24, 0xFF	; 255
     ee8:	8f 77       	andi	r24, 0x7F	; 127
     eea:	80 93 66 00 	sts	0x0066, r24
     eee:	21 50       	subi	r18, 0x01	; 1
     ef0:	18 f7       	brcc	.-58     	; 0xeb8 <OSCCAL_Calibrate+0x4a>
		}		
	}
            
	// Disable all timer interrupts
	TIMSK1 = 0;
     ef2:	10 92 6f 00 	sts	0x006F, r1
	TIMSK2 = 0;
     ef6:	10 92 70 00 	sts	0x0070, r1
    
	// Stop the timers
	TCCR1B = 0x00;
     efa:	10 92 81 00 	sts	0x0081, r1
	TCCR2A = 0x00;
     efe:	10 92 b0 00 	sts	0x00B0, r1

	// Turn off timer 2 asynchronous mode
	ASSR  &= ~(1 << AS2);
     f02:	80 91 b6 00 	lds	r24, 0x00B6
     f06:	87 7f       	andi	r24, 0xF7	; 247
     f08:	80 93 b6 00 	sts	0x00B6, r24

	// Restore SREG
	SREG = SREG_Backup;
     f0c:	3f bf       	out	0x3f, r19	; 63
     f0e:	08 95       	ret

00000f10 <__vector_5>:
        
	return;
}

ISR(TIMER2_OVF_vect, ISR_BLOCK) // Occurs 32768/256 timers per second, or 128Hz
{
     f10:	1f 92       	push	r1
     f12:	0f 92       	push	r0
     f14:	0f b6       	in	r0, 0x3f	; 63
     f16:	0f 92       	push	r0
     f18:	11 24       	eor	r1, r1
     f1a:	8f 93       	push	r24
     f1c:	9f 93       	push	r25
	// Stop timer 1 so it can be read
	TCCR1B = 0x00;
     f1e:	10 92 81 00 	sts	0x0081, r1
    
	// Record timer 1's value
	ActualCount = TCNT1;
     f22:	80 91 84 00 	lds	r24, 0x0084
     f26:	90 91 85 00 	lds	r25, 0x0085
     f2a:	90 93 27 01 	sts	0x0127, r25
     f2e:	80 93 26 01 	sts	0x0126, r24
	     
	// Reset counters and restart timer 1
	TCNT1  = 0;
     f32:	10 92 85 00 	sts	0x0085, r1
     f36:	10 92 84 00 	sts	0x0084, r1
	TCNT2  = 0;
     f3a:	10 92 b2 00 	sts	0x00B2, r1
	TCCR1B = (1 << CS10);
     f3e:	81 e0       	ldi	r24, 0x01	; 1
     f40:	80 93 81 00 	sts	0x0081, r24
     f44:	9f 91       	pop	r25
     f46:	8f 91       	pop	r24
     f48:	0f 90       	pop	r0
     f4a:	0f be       	out	0x3f, r0	; 63
     f4c:	0f 90       	pop	r0
     f4e:	1f 90       	pop	r1
     f50:	18 95       	reti

00000f52 <LCD_Init>:
// ======================================================================================

void LCD_Init(void)
{
	LCDCCR = 0x0F;
     f52:	8f e0       	ldi	r24, 0x0F	; 15
     f54:	80 93 e7 00 	sts	0x00E7, r24

    // Select asynchronous clock source, enable all COM pins and enable all segment pins.
    LCDCRB  = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
     f58:	87 eb       	ldi	r24, 0xB7	; 183
     f5a:	80 93 e5 00 	sts	0x00E5, r24

    // Set LCD prescaler to give a framerate of 32,0 Hz
    LCDFRR  = (0<<LCDPS0) | (7<<LCDCD0);    
     f5e:	87 e0       	ldi	r24, 0x07	; 7
     f60:	80 93 e6 00 	sts	0x00E6, r24

	// Enable LCD and set low power waveform
    LCDCRA  = (1<<LCDEN) | (1<<LCDAB); 
     f64:	80 ec       	ldi	r24, 0xC0	; 192
     f66:	80 93 e4 00 	sts	0x00E4, r24

    //Enable LCD start of frame interrupt
    LCDCRA |= (1<<LCDIE);
     f6a:	80 91 e4 00 	lds	r24, 0x00E4
     f6e:	88 60       	ori	r24, 0x08	; 8
     f70:	80 93 e4 00 	sts	0x00E4, r24
     f74:	08 95       	ret

00000f76 <LCD_puts>:
}

void LCD_puts_f(const uint8_t *FlashData)
{
	uint8_t StrBuff[LCD_TEXTBUFFER_SIZE];

	strcpy_P(StrBuff, FlashData);
	LCD_puts(StrBuff);
}

void LCD_puts(uint8_t *Data)
{
     f76:	cf 93       	push	r28
     f78:	df 93       	push	r29
     f7a:	ec 01       	movw	r28, r24
	uint8_t LoadB;
	
	for (LoadB = 0; LoadB < 20; LoadB++)
     f7c:	20 e0       	ldi	r18, 0x00	; 0
     f7e:	3f ef       	ldi	r19, 0xFF	; 255
     f80:	e1 e5       	ldi	r30, 0x51	; 81
     f82:	f2 e0       	ldi	r31, 0x02	; 2
     f84:	df 01       	movw	r26, r30
	{
		uint8_t CByte = *(Data++);
     f86:	89 91       	ld	r24, Y+
	
		if ((CByte >= '*') && (CByte <= 'z'))
     f88:	98 2f       	mov	r25, r24
     f8a:	9a 52       	subi	r25, 0x2A	; 42
     f8c:	91 35       	cpi	r25, 0x51	; 81
     f8e:	38 f4       	brcc	.+14     	; 0xf9e <LCD_puts+0x28>
		  TextBuffer[LoadB] = ((CByte == ' ')? 0xFF : (CByte - '*'));
     f90:	80 32       	cpi	r24, 0x20	; 32
     f92:	11 f0       	breq	.+4      	; 0xf98 <LCD_puts+0x22>
     f94:	89 2f       	mov	r24, r25
     f96:	01 c0       	rjmp	.+2      	; 0xf9a <LCD_puts+0x24>
     f98:	8f ef       	ldi	r24, 0xFF	; 255
     f9a:	8c 93       	st	X, r24
     f9c:	03 c0       	rjmp	.+6      	; 0xfa4 <LCD_puts+0x2e>
		else if (CByte == 0x00)
     f9e:	88 23       	and	r24, r24
     fa0:	31 f0       	breq	.+12     	; 0xfae <LCD_puts+0x38>
		  break;
		else
		  TextBuffer[LoadB] = 0xFF;		
     fa2:	30 83       	st	Z, r19
     fa4:	2f 5f       	subi	r18, 0xFF	; 255
     fa6:	11 96       	adiw	r26, 0x01	; 1
     fa8:	31 96       	adiw	r30, 0x01	; 1
     faa:	24 31       	cpi	r18, 0x14	; 20
     fac:	60 f3       	brcs	.-40     	; 0xf86 <LCD_puts+0x10>
	}

	ScrollMode  = ((LoadB > 6)? TRUE : FALSE);
     fae:	80 e0       	ldi	r24, 0x00	; 0
     fb0:	27 30       	cpi	r18, 0x07	; 7
     fb2:	08 f0       	brcs	.+2      	; 0xfb6 <LCD_puts+0x40>
     fb4:	81 e0       	ldi	r24, 0x01	; 1
     fb6:	80 93 81 02 	sts	0x0281, r24
	ScrollCount = 0;
     fba:	10 92 4f 02 	sts	0x024F, r1
     fbe:	9f ef       	ldi	r25, 0xFF	; 255
     fc0:	86 e0       	ldi	r24, 0x06	; 6

	for (uint8_t Nulls = 0; Nulls < 7; Nulls++)
		TextBuffer[LoadB++] = 0xFF;
     fc2:	e2 2f       	mov	r30, r18
     fc4:	ff 27       	eor	r31, r31
     fc6:	ef 5a       	subi	r30, 0xAF	; 175
     fc8:	fd 4f       	sbci	r31, 0xFD	; 253
     fca:	90 83       	st	Z, r25
     fcc:	2f 5f       	subi	r18, 0xFF	; 255
     fce:	81 50       	subi	r24, 0x01	; 1
     fd0:	87 ff       	sbrs	r24, 7
     fd2:	f7 cf       	rjmp	.-18     	; 0xfc2 <LCD_puts+0x4c>
	
	TextBuffer[LoadB] = 0x00;
     fd4:	e2 2f       	mov	r30, r18
     fd6:	ff 27       	eor	r31, r31
     fd8:	ef 5a       	subi	r30, 0xAF	; 175
     fda:	fd 4f       	sbci	r31, 0xFD	; 253
     fdc:	10 82       	st	Z, r1
	StrStart   = 0;
     fde:	10 92 50 02 	sts	0x0250, r1
	StrEnd     = LoadB;	
     fe2:	20 93 4e 02 	sts	0x024E, r18
	DelayCount = LCD_DELAYCOUNT_DEFAULT;
     fe6:	8a e0       	ldi	r24, 0x0A	; 10
     fe8:	80 93 82 02 	sts	0x0282, r24

	UpdateLCD  = TRUE;
     fec:	81 e0       	ldi	r24, 0x01	; 1
     fee:	80 93 6c 02 	sts	0x026C, r24
     ff2:	df 91       	pop	r29
     ff4:	cf 91       	pop	r28
     ff6:	08 95       	ret

00000ff8 <LCD_puts_f>:
     ff8:	cf 93       	push	r28
     ffa:	df 93       	push	r29
     ffc:	cd b7       	in	r28, 0x3d	; 61
     ffe:	de b7       	in	r29, 0x3e	; 62
    1000:	64 97       	sbiw	r28, 0x14	; 20
    1002:	0f b6       	in	r0, 0x3f	; 63
    1004:	f8 94       	cli
    1006:	de bf       	out	0x3e, r29	; 62
    1008:	0f be       	out	0x3f, r0	; 63
    100a:	cd bf       	out	0x3d, r28	; 61
    100c:	bc 01       	movw	r22, r24
    100e:	ce 01       	movw	r24, r28
    1010:	01 96       	adiw	r24, 0x01	; 1
    1012:	0e 94 6a 1b 	call	0x36d4 <strcpy_P>
    1016:	ce 01       	movw	r24, r28
    1018:	01 96       	adiw	r24, 0x01	; 1
    101a:	0e 94 bb 07 	call	0xf76 <LCD_puts>
    101e:	64 96       	adiw	r28, 0x14	; 20
    1020:	0f b6       	in	r0, 0x3f	; 63
    1022:	f8 94       	cli
    1024:	de bf       	out	0x3e, r29	; 62
    1026:	0f be       	out	0x3f, r0	; 63
    1028:	cd bf       	out	0x3d, r28	; 61
    102a:	df 91       	pop	r29
    102c:	cf 91       	pop	r28
    102e:	08 95       	ret

00001030 <LCD_WriteChar>:
}

void LCD_WriteChar(uint8_t Byte, uint8_t Digit)
{
    1030:	e8 2f       	mov	r30, r24
	uint16_t SegData  = 0x00;
    1032:	20 e0       	ldi	r18, 0x00	; 0
    1034:	30 e0       	ldi	r19, 0x00	; 0
	uint8_t  *BuffPtr = (&SegBuffer[0] + (Digit >> 1));
    1036:	86 2f       	mov	r24, r22
    1038:	86 95       	lsr	r24
    103a:	a8 2f       	mov	r26, r24
    103c:	bb 27       	eor	r27, r27
    103e:	a3 59       	subi	r26, 0x93	; 147
    1040:	bd 4f       	sbci	r27, 0xFD	; 253

	if (Byte != 0xFF)
    1042:	ef 3f       	cpi	r30, 0xFF	; 255
    1044:	39 f0       	breq	.+14     	; 0x1054 <LCD_WriteChar+0x24>
	  SegData = pgm_read_word(&LCD_SegTable[Byte]);	
    1046:	ff 27       	eor	r31, r31
    1048:	ee 0f       	add	r30, r30
    104a:	ff 1f       	adc	r31, r31
    104c:	e4 50       	subi	r30, 0x04	; 4
    104e:	fd 4f       	sbci	r31, 0xFD	; 253
    1050:	25 91       	lpm	r18, Z+
    1052:	34 91       	lpm	r19, Z
    1054:	77 27       	eor	r23, r23
    1056:	61 70       	andi	r22, 0x01	; 1
    1058:	70 70       	andi	r23, 0x00	; 0
    105a:	43 e0       	ldi	r20, 0x03	; 3

	for (uint8_t BNib = 0; BNib < 4; BNib++)
	{
		uint8_t Mask          = 0xF0;
    105c:	50 ef       	ldi	r21, 0xF0	; 240
		uint8_t MaskedSegData = (SegData & 0x0000F);
    105e:	92 2f       	mov	r25, r18
    1060:	9f 70       	andi	r25, 0x0F	; 15
	
		if (Digit & 0x01)
    1062:	61 15       	cp	r22, r1
    1064:	71 05       	cpc	r23, r1
    1066:	19 f0       	breq	.+6      	; 0x106e <LCD_WriteChar+0x3e>
		{
			Mask = 0x0F;
    1068:	5f e0       	ldi	r21, 0x0F	; 15
			MaskedSegData <<= 4;
    106a:	92 95       	swap	r25
    106c:	90 7f       	andi	r25, 0xF0	; 240
		}
		
		*BuffPtr = ((*BuffPtr & Mask) | MaskedSegData);
    106e:	8c 91       	ld	r24, X
    1070:	85 23       	and	r24, r21
    1072:	89 2b       	or	r24, r25
    1074:	8c 93       	st	X, r24

		SegData >>= 4;
    1076:	84 e0       	ldi	r24, 0x04	; 4
    1078:	36 95       	lsr	r19
    107a:	27 95       	ror	r18
    107c:	8a 95       	dec	r24
    107e:	e1 f7       	brne	.-8      	; 0x1078 <LCD_WriteChar+0x48>
		BuffPtr  += 5;
    1080:	15 96       	adiw	r26, 0x05	; 5
    1082:	41 50       	subi	r20, 0x01	; 1
    1084:	47 ff       	sbrs	r20, 7
    1086:	ea cf       	rjmp	.-44     	; 0x105c <LCD_WriteChar+0x2c>
    1088:	08 95       	ret

0000108a <__vector_22>:
	}
}

ISR(LCD_vect, ISR_NOBLOCK)
{
    108a:	78 94       	sei
    108c:	1f 92       	push	r1
    108e:	0f 92       	push	r0
    1090:	0f b6       	in	r0, 0x3f	; 63
    1092:	0f 92       	push	r0
    1094:	11 24       	eor	r1, r1
    1096:	2f 93       	push	r18
    1098:	3f 93       	push	r19
    109a:	4f 93       	push	r20
    109c:	5f 93       	push	r21
    109e:	6f 93       	push	r22
    10a0:	7f 93       	push	r23
    10a2:	8f 93       	push	r24
    10a4:	9f 93       	push	r25
    10a6:	af 93       	push	r26
    10a8:	bf 93       	push	r27
    10aa:	cf 93       	push	r28
    10ac:	ef 93       	push	r30
    10ae:	ff 93       	push	r31
	if (ScrollMode)
    10b0:	80 91 81 02 	lds	r24, 0x0281
    10b4:	88 23       	and	r24, r24
    10b6:	99 f0       	breq	.+38     	; 0x10de <__vector_22+0x54>
	{
		if (DelayCount)
    10b8:	80 91 82 02 	lds	r24, 0x0282
    10bc:	88 23       	and	r24, r24
    10be:	21 f0       	breq	.+8      	; 0x10c8 <__vector_22+0x3e>
		{
			DelayCount--;
    10c0:	81 50       	subi	r24, 0x01	; 1
    10c2:	80 93 82 02 	sts	0x0282, r24
    10c6:	0b c0       	rjmp	.+22     	; 0x10de <__vector_22+0x54>
		}
		else
		{
			if (!(ScrollCount))
    10c8:	80 91 4f 02 	lds	r24, 0x024F
    10cc:	88 23       	and	r24, r24
    10ce:	21 f4       	brne	.+8      	; 0x10d8 <__vector_22+0x4e>
			  UpdateLCD = TRUE;
    10d0:	81 e0       	ldi	r24, 0x01	; 1
    10d2:	80 93 6c 02 	sts	0x026C, r24
    10d6:	03 c0       	rjmp	.+6      	; 0x10de <__vector_22+0x54>
			else
			  ScrollCount--;
    10d8:	81 50       	subi	r24, 0x01	; 1
    10da:	80 93 4f 02 	sts	0x024F, r24
		}
	}

	if (UpdateLCD)
    10de:	80 91 6c 02 	lds	r24, 0x026C
    10e2:	88 23       	and	r24, r24
    10e4:	39 f1       	breq	.+78     	; 0x1134 <__vector_22+0xaa>
	{
		for (uint8_t Character = 0; Character < 6; Character++)
    10e6:	c0 e0       	ldi	r28, 0x00	; 0
		{
			uint8_t Byte = (StrStart + Character);
    10e8:	80 91 50 02 	lds	r24, 0x0250
    10ec:	8c 0f       	add	r24, r28

			if (Byte >= StrEnd)
    10ee:	90 91 4e 02 	lds	r25, 0x024E
    10f2:	e8 2f       	mov	r30, r24
    10f4:	ff 27       	eor	r31, r31
    10f6:	89 17       	cp	r24, r25
    10f8:	10 f0       	brcs	.+4      	; 0x10fe <__vector_22+0x74>
			  Byte = TextBuffer[Byte - StrEnd];
    10fa:	e9 1b       	sub	r30, r25
    10fc:	f1 09       	sbc	r31, r1
			else
			  Byte = TextBuffer[Byte];
    10fe:	ef 5a       	subi	r30, 0xAF	; 175
    1100:	fd 4f       	sbci	r31, 0xFD	; 253
    1102:	80 81       	ld	r24, Z
			
			LCD_WriteChar(Byte, Character);
    1104:	6c 2f       	mov	r22, r28
    1106:	0e 94 18 08 	call	0x1030 <LCD_WriteChar>
    110a:	cf 5f       	subi	r28, 0xFF	; 255
    110c:	c6 30       	cpi	r28, 0x06	; 6
    110e:	60 f3       	brcs	.-40     	; 0x10e8 <__vector_22+0x5e>
		}
		
		if (StrStart++ == StrEnd)
    1110:	80 91 50 02 	lds	r24, 0x0250
    1114:	98 2f       	mov	r25, r24
    1116:	8f 5f       	subi	r24, 0xFF	; 255
    1118:	80 93 50 02 	sts	0x0250, r24
    111c:	80 91 4e 02 	lds	r24, 0x024E
    1120:	98 17       	cp	r25, r24
    1122:	19 f4       	brne	.+6      	; 0x112a <__vector_22+0xa0>
		  StrStart = 1;
    1124:	81 e0       	ldi	r24, 0x01	; 1
    1126:	80 93 50 02 	sts	0x0250, r24
		
		ScrollCount = LCD_SCROLLCOUNT_DEFAULT;
    112a:	83 e0       	ldi	r24, 0x03	; 3
    112c:	80 93 4f 02 	sts	0x024F, r24
		UpdateLCD = FALSE;
    1130:	10 92 6c 02 	sts	0x026C, r1
    1134:	ac ee       	ldi	r26, 0xEC	; 236
    1136:	b0 e0       	ldi	r27, 0x00	; 0
    1138:	ed e6       	ldi	r30, 0x6D	; 109
    113a:	f2 e0       	ldi	r31, 0x02	; 2
    113c:	93 e1       	ldi	r25, 0x13	; 19
	}

	for (uint8_t LCDChar = 0; LCDChar < LCD_SEGBUFFER_SIZE; LCDChar++)
	  *(pLCDREG + LCDChar) = SegBuffer[LCDChar];
    113e:	81 91       	ld	r24, Z+
    1140:	8d 93       	st	X+, r24
    1142:	91 50       	subi	r25, 0x01	; 1
    1144:	97 ff       	sbrs	r25, 7
    1146:	fb cf       	rjmp	.-10     	; 0x113e <__vector_22+0xb4>
    1148:	ff 91       	pop	r31
    114a:	ef 91       	pop	r30
    114c:	cf 91       	pop	r28
    114e:	bf 91       	pop	r27
    1150:	af 91       	pop	r26
    1152:	9f 91       	pop	r25
    1154:	8f 91       	pop	r24
    1156:	7f 91       	pop	r23
    1158:	6f 91       	pop	r22
    115a:	5f 91       	pop	r21
    115c:	4f 91       	pop	r20
    115e:	3f 91       	pop	r19
    1160:	2f 91       	pop	r18
    1162:	0f 90       	pop	r0
    1164:	0f be       	out	0x3f, r0	; 63
    1166:	0f 90       	pop	r0
    1168:	1f 90       	pop	r1
    116a:	18 95       	reti

0000116c <eeprom_read_byte_169>:
#include <avr/interrupt.h>
#include "eeprom169.h"

uint8_t eeprom_read_byte_169(const uint16_t *addr)
{
    116c:	fc 01       	movw	r30, r24
	cli();
    116e:	f8 94       	cli
	/* Set up address register */
	EEAR = *addr;
    1170:	80 81       	ld	r24, Z
    1172:	91 81       	ldd	r25, Z+1	; 0x01
    1174:	92 bd       	out	0x22, r25	; 34
    1176:	81 bd       	out	0x21, r24	; 33
	/* Start eeprom read by writing EERE */
	EECR |= (1<<EERE);
    1178:	f8 9a       	sbi	0x1f, 0	; 31
	sei();
    117a:	78 94       	sei
	/* Return data from Data Register */
	return EEDR;
    117c:	80 b5       	in	r24, 0x20	; 32
}
    117e:	99 27       	eor	r25, r25
    1180:	08 95       	ret

00001182 <eeprom_write_byte_169>:

void eeprom_write_byte_169(const uint16_t *addr, uint8_t val) 
{
    1182:	1f 93       	push	r17
    1184:	cf 93       	push	r28
    1186:	df 93       	push	r29
    1188:	ec 01       	movw	r28, r24
    118a:	16 2f       	mov	r17, r22
	if(eeprom_read_byte_169(addr) == val) // Compare stored value with new value for match
    118c:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
    1190:	81 17       	cp	r24, r17
    1192:	59 f0       	breq	.+22     	; 0x11aa <eeprom_write_byte_169+0x28>
		return; // Don't re-write the same value and waste EEPROM life

	cli();
    1194:	f8 94       	cli
	/* Set up address and Data Registers */
	EEAR = *addr;
    1196:	88 81       	ld	r24, Y
    1198:	99 81       	ldd	r25, Y+1	; 0x01
    119a:	92 bd       	out	0x22, r25	; 34
    119c:	81 bd       	out	0x21, r24	; 33
	EEDR = val;
    119e:	10 bd       	out	0x20, r17	; 32
	/* Write logical one to EEMWE */
	EECR |= (1<<EEMWE);
    11a0:	fa 9a       	sbi	0x1f, 2	; 31
	/* Start eeprom write by setting EEWE */
	EECR |= (1<<EEWE);
    11a2:	f9 9a       	sbi	0x1f, 1	; 31
	sei();
    11a4:	78 94       	sei
	/* Wait for completion */
	while(EECR & (1<<EEWE));
    11a6:	f9 99       	sbic	0x1f, 1	; 31
    11a8:	fe cf       	rjmp	.-4      	; 0x11a6 <eeprom_write_byte_169+0x24>
    11aa:	df 91       	pop	r29
    11ac:	cf 91       	pop	r28
    11ae:	1f 91       	pop	r17
    11b0:	08 95       	ret

000011b2 <USART_Init>:
*   Purpose :       Initialize the USART
*
*****************************************************************************/
void USART_Init(unsigned int baudrate)
{
    11b2:	9c 01       	movw	r18, r24
    // Set baud rate
    UBRRH = (unsigned char)(baudrate>>8);
    11b4:	83 2f       	mov	r24, r19
    11b6:	99 27       	eor	r25, r25
    11b8:	80 93 c5 00 	sts	0x00C5, r24
    UBRRL = (unsigned char)(baudrate);
    11bc:	20 93 c4 00 	sts	0x00C4, r18

    // Double speed
	UCSRA = (USART_DOUBLESPEED << U2X);
    11c0:	82 e0       	ldi	r24, 0x02	; 2
    11c2:	80 93 c0 00 	sts	0x00C0, r24

    // Enable recieve complete interrupt
	UCSRB = (1 << RXCIE);
    11c6:	80 e8       	ldi	r24, 0x80	; 128
    11c8:	80 93 c1 00 	sts	0x00C1, r24
	 
    // Async. mode, 8N1
    UCSRC = (3 << UCSZ0);
    11cc:	86 e0       	ldi	r24, 0x06	; 6
    11ce:	80 93 c2 00 	sts	0x00C2, r24
	 
	 // Initalise ringbuffer
	BUFF_InitialiseBuffer();
    11d2:	0e 94 c6 0b 	call	0x178c <BUFF_InitialiseBuffer>
    11d6:	08 95       	ret

000011d8 <USART_Tx>:
}

/*****************************************************************************
*
*   Function name : Usart_Tx
*
*   Returns :       None
*
*   Parameters :    char data: byte to send
*
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_Tx(char data)
{
    11d8:	98 2f       	mov	r25, r24
    while (!(UCSRA & (1<<UDRE)));
    11da:	80 91 c0 00 	lds	r24, 0x00C0
    11de:	85 ff       	sbrs	r24, 5
    11e0:	fc cf       	rjmp	.-8      	; 0x11da <USART_Tx+0x2>
    UDR = data;
    11e2:	90 93 c6 00 	sts	0x00C6, r25
    11e6:	08 95       	ret

000011e8 <USART_TxString>:
}

/*****************************************************************************
*
*   Function name : Usart_Tx
*
*   Returns :       None
*
*   Parameters :    char data: byte to send
*
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_TxString(char *data)
{
    11e8:	cf 93       	push	r28
    11ea:	df 93       	push	r29
    11ec:	ec 01       	movw	r28, r24
	while (*data != '\0')
		USART_Tx(*data++);
    11ee:	88 81       	ld	r24, Y
    11f0:	88 23       	and	r24, r24
    11f2:	31 f0       	breq	.+12     	; 0x1200 <USART_TxString+0x18>
    11f4:	89 91       	ld	r24, Y+
    11f6:	0e 94 ec 08 	call	0x11d8 <USART_Tx>
    11fa:	88 81       	ld	r24, Y
    11fc:	88 23       	and	r24, r24
    11fe:	d1 f7       	brne	.-12     	; 0x11f4 <USART_TxString+0xc>
    1200:	df 91       	pop	r29
    1202:	cf 91       	pop	r28
    1204:	08 95       	ret

00001206 <USART_Rx>:
}

/*****************************************************************************
*
*   Function name : Usart_Rx
*
*   Returns :       char: byte received
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART
*
*****************************************************************************/
char USART_Rx(void)
{
    while (!(BuffElements) && !(TimeOut)) {};
    1206:	80 91 d1 02 	lds	r24, 0x02D1
    120a:	88 23       	and	r24, r24
    120c:	21 f4       	brne	.+8      	; 0x1216 <USART_Rx+0x10>
    120e:	80 91 2a 01 	lds	r24, 0x012A
    1212:	88 23       	and	r24, r24
    1214:	c1 f3       	breq	.-16     	; 0x1206 <USART_Rx>
    return BUFF_GetBuffByte();
    1216:	0e 94 fc 0b 	call	0x17f8 <BUFF_GetBuffByte>
}
    121a:	99 27       	eor	r25, r25
    121c:	08 95       	ret

0000121e <__vector_13>:

/*****************************************************************************
*
*   Function name : Usart_Rx Interrupt
*
*   Returns :       N/A
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART and stores it into the buffer
*
*****************************************************************************/

ISR(USART0_RX_vect, ISR_BLOCK)
{
    121e:	1f 92       	push	r1
    1220:	0f 92       	push	r0
    1222:	0f b6       	in	r0, 0x3f	; 63
    1224:	0f 92       	push	r0
    1226:	11 24       	eor	r1, r1
    1228:	2f 93       	push	r18
    122a:	3f 93       	push	r19
    122c:	4f 93       	push	r20
    122e:	5f 93       	push	r21
    1230:	6f 93       	push	r22
    1232:	7f 93       	push	r23
    1234:	8f 93       	push	r24
    1236:	9f 93       	push	r25
    1238:	af 93       	push	r26
    123a:	bf 93       	push	r27
    123c:	ef 93       	push	r30
    123e:	ff 93       	push	r31
	BUFF_StoreBuffByte(UDR);
    1240:	80 91 c6 00 	lds	r24, 0x00C6
    1244:	0e 94 d3 0b 	call	0x17a6 <BUFF_StoreBuffByte>
    1248:	ff 91       	pop	r31
    124a:	ef 91       	pop	r30
    124c:	bf 91       	pop	r27
    124e:	af 91       	pop	r26
    1250:	9f 91       	pop	r25
    1252:	8f 91       	pop	r24
    1254:	7f 91       	pop	r23
    1256:	6f 91       	pop	r22
    1258:	5f 91       	pop	r21
    125a:	4f 91       	pop	r20
    125c:	3f 91       	pop	r19
    125e:	2f 91       	pop	r18
    1260:	0f 90       	pop	r0
    1262:	0f be       	out	0x3f, r0	; 63
    1264:	0f 90       	pop	r0
    1266:	1f 90       	pop	r1
    1268:	18 95       	reti

0000126a <SPI_SPIInit>:
// ======================================================================================

void SPI_SPIInit(void)
{
	PRR &= ~(1 << PRSPI);              // Enable the SPI system by clearing the power save register SPI disable bit
    126a:	80 91 64 00 	lds	r24, 0x0064
    126e:	8b 7f       	andi	r24, 0xFB	; 251
    1270:	80 93 64 00 	sts	0x0064, r24

	// Master, Sample falling edge (setup rising), Fosc/32 speed (8Mhz/32 = 125Khz)
	SPSR = (1 << SPI2X);
    1274:	81 e0       	ldi	r24, 0x01	; 1
    1276:	8d bd       	out	0x2d, r24	; 45
	SPCR = ((1 << SPE) | (1 << MSTR) | (1 << CPHA) | (1 << CPOL) | (1 << SPR1));
    1278:	8e e5       	ldi	r24, 0x5E	; 94
    127a:	8c bd       	out	0x2c, r24	; 44
    127c:	08 95       	ret

0000127e <SPI_SPITransmit>:
}

uint8_t SPI_SPITransmit(uint8_t Data)
{
	SPDR = Data;                       // Loading a byte into the register starts the transmission
    127e:	8e bd       	out	0x2e, r24	; 46
	while (!(SPSR & (1 << SPIF)));    // Wait until transmission completed
    1280:	0d b4       	in	r0, 0x2d	; 45
    1282:	07 fe       	sbrs	r0, 7
    1284:	fd cf       	rjmp	.-6      	; 0x1280 <SPI_SPITransmit+0x2>
	return SPDR;
    1286:	8e b5       	in	r24, 0x2e	; 46
}
    1288:	99 27       	eor	r25, r25
    128a:	08 95       	ret

0000128c <SPI_SPITransmitWord>:

uint8_t SPI_SPITransmitWord(uint16_t Data)
{
    128c:	0f 93       	push	r16
    128e:	1f 93       	push	r17
    1290:	8c 01       	movw	r16, r24
	SPI_SPITransmit((uint8_t)(Data >> 8));
    1292:	81 2f       	mov	r24, r17
    1294:	99 27       	eor	r25, r25
    1296:	0e 94 3f 09 	call	0x127e <SPI_SPITransmit>
	return SPI_SPITransmit((uint8_t)Data);
    129a:	80 2f       	mov	r24, r16
    129c:	0e 94 3f 09 	call	0x127e <SPI_SPITransmit>
}
    12a0:	99 27       	eor	r25, r25
    12a2:	1f 91       	pop	r17
    12a4:	0f 91       	pop	r16
    12a6:	08 95       	ret

000012a8 <__vector_10>:
 *  in master mode. It toggles the USI clock pin, i.e. two interrupts
 *  results in one clock period on the clock pin and for the USI counter.
 */
ISR(TIMER0_COMP_vect, ISR_BLOCK)
{
    12a8:	1f 92       	push	r1
    12aa:	0f 92       	push	r0
    12ac:	0f b6       	in	r0, 0x3f	; 63
    12ae:	0f 92       	push	r0
    12b0:	11 24       	eor	r1, r1
    12b2:	8f 93       	push	r24
	USICR |= (1<<USITC);	// Toggle clock output pin.
    12b4:	80 91 b8 00 	lds	r24, 0x00B8
    12b8:	81 60       	ori	r24, 0x01	; 1
    12ba:	80 93 b8 00 	sts	0x00B8, r24
    12be:	8f 91       	pop	r24
    12c0:	0f 90       	pop	r0
    12c2:	0f be       	out	0x3f, r0	; 63
    12c4:	0f 90       	pop	r0
    12c6:	1f 90       	pop	r1
    12c8:	18 95       	reti

000012ca <__vector_17>:
}



/*! \brief  USI Timer Overflow Interrupt handler.
 *
 *  This handler disables the compare match interrupt if in master mode.
 *  When the USI counter overflows, a byte has been transferred, and we
 *  have to stop the timer tick.
 *  For all modes the USIDR contents are stored and flags are updated.
 */
ISR(USI_OVERFLOW_vect, ISR_BLOCK)
{
    12ca:	1f 92       	push	r1
    12cc:	0f 92       	push	r0
    12ce:	0f b6       	in	r0, 0x3f	; 63
    12d0:	0f 92       	push	r0
    12d2:	11 24       	eor	r1, r1
    12d4:	8f 93       	push	r24
	// Master must now disable the compare match interrupt
	// to prevent more USI counter clocks.
	TIMSK0 &= ~(1<<OCIE0A);
    12d6:	80 91 6e 00 	lds	r24, 0x006E
    12da:	8d 7f       	andi	r24, 0xFD	; 253
    12dc:	80 93 6e 00 	sts	0x006E, r24
	
	// Update flags and clear USI counter
	USISR = (1<<USIOIF);
    12e0:	80 e4       	ldi	r24, 0x40	; 64
    12e2:	80 93 b9 00 	sts	0x00B9, r24
	USI_status.transferComplete = 1;
    12e6:	80 91 29 01 	lds	r24, 0x0129
    12ea:	81 60       	ori	r24, 0x01	; 1
    12ec:	80 93 29 01 	sts	0x0129, r24

	// Copy USIDR to buffer to prevent overwrite on next transfer.
	storedUSIDR = USIDR;
    12f0:	80 91 ba 00 	lds	r24, 0x00BA
    12f4:	80 93 28 01 	sts	0x0128, r24
    12f8:	8f 91       	pop	r24
    12fa:	0f 90       	pop	r0
    12fc:	0f be       	out	0x3f, r0	; 63
    12fe:	0f 90       	pop	r0
    1300:	1f 90       	pop	r1
    1302:	18 95       	reti

00001304 <USI_SPISetSpeed>:
}



/*! \brief  Initialize USI as SPI master.
 *
 *  This function sets up all pin directions and module configurations.
 *  Use this function initially or when changing from slave to master mode.
 *  Note that the stored USIDR value is cleared.
 *
 *  \param spi_mode  Required SPI mode, must be 0 or 1.
 */
void USI_SPIInitMaster(char Freq)
{
	// Configure port directions.
 	USI_DIR_REG |= (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN);  // Outputs.
	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN);                       // Inputs.
	USI_OUT_REG |= (1<<USI_DATAIN_PIN);                        // Pull-ups.
	USI_OUT_REG &= ~(1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN); // Pull-ups.
	
	// Configure USI to 3-wire master mode with overflow interrupt.
	USICR = (1<<USIOIE) | (1<<USIWM0) |
	        (1<<USICS1) | (SPI_SAMPLE_LEADING<<USICS0) |
	        (1<<USICLK);

	// Set the compare and prescaler for the requested frequency:
	USI_SPISetSpeed(Freq);
	
	// Init driver status register.
	USI_status.transferComplete = 0;
	USI_status.writeCollision   = 0;
	
	storedUSIDR = 0;
}

void USI_SPIOff( void )
{
	USI_DIR_REG &= ~((1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN));                        // Inputs.
	USI_OUT_REG &= ~((1<<USI_DATAIN_PIN)  | (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN)); // Pull-ups.
	DDRF  &= ~(1 << 6);
	PORTF &= ~(1 << 6);
	
	USI_STOPUSITIMER();
}

/*! \brief  Put one byte on bus.
 *
 *  Use this function like you would write to the SPDR register in the native SPI module.
 *  Calling this function in master mode starts a transfer, while in slave mode, a
 *  byte will be prepared for the next transfer initiated by the master device.
 *  If a transfer is in progress, this function will set the write collision flag
 *  and return without altering the data registers.
 *
 *  \returns  0 if a write collision occurred, 1 otherwise.
 */
uint8_t USI_SPITransmit( unsigned char val )
{
	// Check if transmission in progress,
	// i.e. USI counter unequal to zero.
	if( (USISR & 0x0F) != 0 ) {
		// Indicate write collision and return.
		USI_status.writeCollision = 1;
		return 0;
	}
	
	// Reinit flags.
	USI_status.transferComplete = 0;
	USI_status.writeCollision = 0;

	// Put data in USI data register.
	USIDR = val;
	
	TIFR0  |= (1<<OCF0A);  // Clear compare match flag.
	TIMSK0 |= (1<<OCIE0A); // Enable compare match interrupt.

	// Clear the timer 0 value
	TCNT0 = 0;

	do {} while( USI_status.transferComplete == 0 );

	return storedUSIDR;
}

uint8_t USI_SPITransmitWord( unsigned int val )
{
	USI_SPITransmit((uint8_t)(val >> 8));
	return USI_SPITransmit((uint8_t)val);
}

void USI_SPIToggleClock(void)
{
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);	
}

void USI_SPISetSpeed(uint8_t Freq)
{
    1304:	98 2f       	mov	r25, r24
	if (Freq == 0xFF) // Blank EEPROM, default to fastest setting
    1306:	8f 3f       	cpi	r24, 0xFF	; 255
    1308:	09 f4       	brne	.+2      	; 0x130c <USI_SPISetSpeed+0x8>
	   Freq = SPI_SPEED_921600Hz;
    130a:	90 e0       	ldi	r25, 0x00	; 0

	for (uint8_t MatchIndex = 0; MatchIndex < USI_PRESET_SPEEDS; MatchIndex++)
    130c:	40 e0       	ldi	r20, 0x00	; 0
    130e:	20 e0       	ldi	r18, 0x00	; 0
    1310:	30 e0       	ldi	r19, 0x00	; 0
	{
		if ((pgm_read_byte(&USIPSValues[MatchIndex][0]) == Freq) || (MatchIndex == (USI_PRESET_SPEEDS - 1)))
    1312:	f9 01       	movw	r30, r18
    1314:	e8 59       	subi	r30, 0x98	; 152
    1316:	fc 4f       	sbci	r31, 0xFC	; 252
    1318:	84 91       	lpm	r24, Z
    131a:	89 17       	cp	r24, r25
    131c:	11 f0       	breq	.+4      	; 0x1322 <USI_SPISetSpeed+0x1e>
    131e:	43 30       	cpi	r20, 0x03	; 3
    1320:	61 f4       	brne	.+24     	; 0x133a <USI_SPISetSpeed+0x36>
		{
			// Init Output Compare Register.
			OCR0A = pgm_read_byte(&USIPSValues[MatchIndex][2]);
    1322:	f9 01       	movw	r30, r18
    1324:	e6 59       	subi	r30, 0x96	; 150
    1326:	fc 4f       	sbci	r31, 0xFC	; 252
    1328:	84 91       	lpm	r24, Z
    132a:	87 bd       	out	0x27, r24	; 39

			// Enable 'Clear Timer on Compare match' and set prescaler, which starts the timer
			TCCR0A = ((1<<WGM01) | pgm_read_byte(&USIPSValues[MatchIndex][1]));
    132c:	27 59       	subi	r18, 0x97	; 151
    132e:	3c 4f       	sbci	r19, 0xFC	; 252
    1330:	f9 01       	movw	r30, r18
    1332:	84 91       	lpm	r24, Z
    1334:	88 60       	ori	r24, 0x08	; 8
    1336:	84 bd       	out	0x24, r24	; 36
				
			return;
    1338:	08 95       	ret
    133a:	4f 5f       	subi	r20, 0xFF	; 255
    133c:	2d 5f       	subi	r18, 0xFD	; 253
    133e:	3f 4f       	sbci	r19, 0xFF	; 255
    1340:	44 30       	cpi	r20, 0x04	; 4
    1342:	38 f3       	brcs	.-50     	; 0x1312 <USI_SPISetSpeed+0xe>
    1344:	08 95       	ret

00001346 <USI_SPIInitMaster>:
    1346:	9d b1       	in	r25, 0x0d	; 13
    1348:	90 65       	ori	r25, 0x50	; 80
    134a:	9d b9       	out	0x0d, r25	; 13
    134c:	6d 98       	cbi	0x0d, 5	; 13
    134e:	75 9a       	sbi	0x0e, 5	; 14
    1350:	76 98       	cbi	0x0e, 6	; 14
    1352:	9a e5       	ldi	r25, 0x5A	; 90
    1354:	90 93 b8 00 	sts	0x00B8, r25
    1358:	0e 94 82 09 	call	0x1304 <USI_SPISetSpeed>
    135c:	80 91 29 01 	lds	r24, 0x0129
    1360:	8e 7f       	andi	r24, 0xFE	; 254
    1362:	80 93 29 01 	sts	0x0129, r24
    1366:	80 91 29 01 	lds	r24, 0x0129
    136a:	8d 7f       	andi	r24, 0xFD	; 253
    136c:	80 93 29 01 	sts	0x0129, r24
    1370:	10 92 28 01 	sts	0x0128, r1
    1374:	08 95       	ret

00001376 <USI_SPIOff>:
    1376:	8d b1       	in	r24, 0x0d	; 13
    1378:	8f 7a       	andi	r24, 0xAF	; 175
    137a:	8d b9       	out	0x0d, r24	; 13
    137c:	8e b1       	in	r24, 0x0e	; 14
    137e:	8f 78       	andi	r24, 0x8F	; 143
    1380:	8e b9       	out	0x0e, r24	; 14
    1382:	86 98       	cbi	0x10, 6	; 16
    1384:	8e 98       	cbi	0x11, 6	; 17
    1386:	14 bc       	out	0x24, r1	; 36
    1388:	08 95       	ret

0000138a <USI_SPITransmit>:
    138a:	28 2f       	mov	r18, r24
    138c:	80 91 b9 00 	lds	r24, 0x00B9
    1390:	99 27       	eor	r25, r25
    1392:	8f 70       	andi	r24, 0x0F	; 15
    1394:	90 70       	andi	r25, 0x00	; 0
    1396:	89 2b       	or	r24, r25
    1398:	41 f0       	breq	.+16     	; 0x13aa <USI_SPITransmit+0x20>
    139a:	80 91 29 01 	lds	r24, 0x0129
    139e:	82 60       	ori	r24, 0x02	; 2
    13a0:	80 93 29 01 	sts	0x0129, r24
    13a4:	80 e0       	ldi	r24, 0x00	; 0
    13a6:	90 e0       	ldi	r25, 0x00	; 0
    13a8:	08 95       	ret
    13aa:	80 91 29 01 	lds	r24, 0x0129
    13ae:	8e 7f       	andi	r24, 0xFE	; 254
    13b0:	80 93 29 01 	sts	0x0129, r24
    13b4:	80 91 29 01 	lds	r24, 0x0129
    13b8:	8d 7f       	andi	r24, 0xFD	; 253
    13ba:	80 93 29 01 	sts	0x0129, r24
    13be:	20 93 ba 00 	sts	0x00BA, r18
    13c2:	a9 9a       	sbi	0x15, 1	; 21
    13c4:	80 91 6e 00 	lds	r24, 0x006E
    13c8:	82 60       	ori	r24, 0x02	; 2
    13ca:	80 93 6e 00 	sts	0x006E, r24
    13ce:	16 bc       	out	0x26, r1	; 38
    13d0:	80 91 29 01 	lds	r24, 0x0129
    13d4:	80 ff       	sbrs	r24, 0
    13d6:	fc cf       	rjmp	.-8      	; 0x13d0 <USI_SPITransmit+0x46>
    13d8:	80 91 28 01 	lds	r24, 0x0128
    13dc:	99 27       	eor	r25, r25
    13de:	08 95       	ret

000013e0 <USI_SPITransmitWord>:
    13e0:	0f 93       	push	r16
    13e2:	1f 93       	push	r17
    13e4:	8c 01       	movw	r16, r24
    13e6:	81 2f       	mov	r24, r17
    13e8:	99 27       	eor	r25, r25
    13ea:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    13ee:	80 2f       	mov	r24, r16
    13f0:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    13f4:	99 27       	eor	r25, r25
    13f6:	1f 91       	pop	r17
    13f8:	0f 91       	pop	r16
    13fa:	08 95       	ret

000013fc <USI_SPIToggleClock>:
    13fc:	81 e0       	ldi	r24, 0x01	; 1
    13fe:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    1402:	80 91 b8 00 	lds	r24, 0x00B8
    1406:	81 60       	ori	r24, 0x01	; 1
    1408:	80 93 b8 00 	sts	0x00B8, r24
    140c:	81 e0       	ldi	r24, 0x01	; 1
    140e:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    1412:	80 91 b8 00 	lds	r24, 0x00B8
    1416:	81 60       	ori	r24, 0x01	; 1
    1418:	80 93 b8 00 	sts	0x00B8, r24
    141c:	81 e0       	ldi	r24, 0x01	; 1
    141e:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    1422:	08 95       	ret

00001424 <DF_EnableDataflash>:
	while(DF_BUSY());
}

void DF_EnableDataflash(uint8_t Enabled)
{
    1424:	90 91 83 02 	lds	r25, 0x0283
	if (Enabled == TRUE)
    1428:	81 30       	cpi	r24, 0x01	; 1
    142a:	31 f4       	brne	.+12     	; 0x1438 <DF_EnableDataflash+0x14>
	{
		if (UseExernalDF == TRUE)
    142c:	91 30       	cpi	r25, 0x01	; 1
    142e:	11 f4       	brne	.+4      	; 0x1434 <DF_EnableDataflash+0x10>
		  MAIN_ResetCSLine(MAIN_RESETCS_DFACTIVE);
    1430:	82 e0       	ldi	r24, 0x02	; 2
    1432:	05 c0       	rjmp	.+10     	; 0x143e <DF_EnableDataflash+0x1a>
		else
		  PORTB &= ~(1 << 0);
    1434:	28 98       	cbi	0x05, 0	; 5
    1436:	08 95       	ret
	}
	else
	{
		if (UseExernalDF == TRUE)
    1438:	91 30       	cpi	r25, 0x01	; 1
    143a:	21 f4       	brne	.+8      	; 0x1444 <DF_EnableDataflash+0x20>
		  MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);
    143c:	89 2f       	mov	r24, r25
    143e:	0e 94 15 03 	call	0x62a <MAIN_ResetCSLine>
    1442:	08 95       	ret
		else
		  PORTB |= (1 << 0);
    1444:	28 9a       	sbi	0x05, 0	; 5
    1446:	08 95       	ret

00001448 <DF_ReadBufferByte>:
    1448:	0f 93       	push	r16
    144a:	1f 93       	push	r17
    144c:	8c 01       	movw	r16, r24
    144e:	80 e0       	ldi	r24, 0x00	; 0
    1450:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    1454:	00 00       	nop
    1456:	81 e0       	ldi	r24, 0x01	; 1
    1458:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    145c:	e0 91 00 01 	lds	r30, 0x0100
    1460:	f0 91 01 01 	lds	r31, 0x0101
    1464:	84 e5       	ldi	r24, 0x54	; 84
    1466:	09 95       	icall
    1468:	81 2f       	mov	r24, r17
    146a:	99 27       	eor	r25, r25
    146c:	e0 91 00 01 	lds	r30, 0x0100
    1470:	f0 91 01 01 	lds	r31, 0x0101
    1474:	09 95       	icall
    1476:	e0 91 00 01 	lds	r30, 0x0100
    147a:	f0 91 01 01 	lds	r31, 0x0101
    147e:	80 2f       	mov	r24, r16
    1480:	09 95       	icall
    1482:	e0 91 00 01 	lds	r30, 0x0100
    1486:	f0 91 01 01 	lds	r31, 0x0101
    148a:	80 e0       	ldi	r24, 0x00	; 0
    148c:	09 95       	icall
    148e:	e0 91 00 01 	lds	r30, 0x0100
    1492:	f0 91 01 01 	lds	r31, 0x0101
    1496:	80 e0       	ldi	r24, 0x00	; 0
    1498:	09 95       	icall
    149a:	99 27       	eor	r25, r25
    149c:	1f 91       	pop	r17
    149e:	0f 91       	pop	r16
    14a0:	08 95       	ret

000014a2 <DF_ContinuousReadEnable>:
    14a2:	ef 92       	push	r14
    14a4:	ff 92       	push	r15
    14a6:	0f 93       	push	r16
    14a8:	1f 93       	push	r17
    14aa:	8c 01       	movw	r16, r24
    14ac:	7b 01       	movw	r14, r22
    14ae:	80 e0       	ldi	r24, 0x00	; 0
    14b0:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    14b4:	00 00       	nop
    14b6:	81 e0       	ldi	r24, 0x01	; 1
    14b8:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    14bc:	e0 91 00 01 	lds	r30, 0x0100
    14c0:	f0 91 01 01 	lds	r31, 0x0101
    14c4:	88 e6       	ldi	r24, 0x68	; 104
    14c6:	09 95       	icall
    14c8:	8a b5       	in	r24, 0x2a	; 42
    14ca:	98 01       	movw	r18, r16
    14cc:	02 c0       	rjmp	.+4      	; 0x14d2 <DF_ContinuousReadEnable+0x30>
    14ce:	36 95       	lsr	r19
    14d0:	27 95       	ror	r18
    14d2:	8a 95       	dec	r24
    14d4:	e2 f7       	brpl	.-8      	; 0x14ce <DF_ContinuousReadEnable+0x2c>
    14d6:	c9 01       	movw	r24, r18
    14d8:	e0 91 00 01 	lds	r30, 0x0100
    14dc:	f0 91 01 01 	lds	r31, 0x0101
    14e0:	09 95       	icall
    14e2:	8b b5       	in	r24, 0x2b	; 43
    14e4:	02 c0       	rjmp	.+4      	; 0x14ea <DF_ContinuousReadEnable+0x48>
    14e6:	00 0f       	add	r16, r16
    14e8:	11 1f       	adc	r17, r17
    14ea:	8a 95       	dec	r24
    14ec:	e2 f7       	brpl	.-8      	; 0x14e6 <DF_ContinuousReadEnable+0x44>
    14ee:	8f 2d       	mov	r24, r15
    14f0:	99 27       	eor	r25, r25
    14f2:	e0 91 00 01 	lds	r30, 0x0100
    14f6:	f0 91 01 01 	lds	r31, 0x0101
    14fa:	80 0f       	add	r24, r16
    14fc:	09 95       	icall
    14fe:	e0 91 00 01 	lds	r30, 0x0100
    1502:	f0 91 01 01 	lds	r31, 0x0101
    1506:	8e 2d       	mov	r24, r14
    1508:	09 95       	icall
    150a:	03 e0       	ldi	r16, 0x03	; 3
    150c:	e0 91 00 01 	lds	r30, 0x0100
    1510:	f0 91 01 01 	lds	r31, 0x0101
    1514:	80 e0       	ldi	r24, 0x00	; 0
    1516:	09 95       	icall
    1518:	01 50       	subi	r16, 0x01	; 1
    151a:	07 ff       	sbrs	r16, 7
    151c:	f7 cf       	rjmp	.-18     	; 0x150c <DF_ContinuousReadEnable+0x6a>
    151e:	1f 91       	pop	r17
    1520:	0f 91       	pop	r16
    1522:	ff 90       	pop	r15
    1524:	ef 90       	pop	r14
    1526:	08 95       	ret

00001528 <DF_BufferWriteEnable>:
    1528:	0f 93       	push	r16
    152a:	1f 93       	push	r17
    152c:	8c 01       	movw	r16, r24
    152e:	80 e0       	ldi	r24, 0x00	; 0
    1530:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    1534:	00 00       	nop
    1536:	81 e0       	ldi	r24, 0x01	; 1
    1538:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    153c:	e0 91 00 01 	lds	r30, 0x0100
    1540:	f0 91 01 01 	lds	r31, 0x0101
    1544:	84 e8       	ldi	r24, 0x84	; 132
    1546:	09 95       	icall
    1548:	e0 91 00 01 	lds	r30, 0x0100
    154c:	f0 91 01 01 	lds	r31, 0x0101
    1550:	80 e0       	ldi	r24, 0x00	; 0
    1552:	09 95       	icall
    1554:	81 2f       	mov	r24, r17
    1556:	99 27       	eor	r25, r25
    1558:	e0 91 00 01 	lds	r30, 0x0100
    155c:	f0 91 01 01 	lds	r31, 0x0101
    1560:	09 95       	icall
    1562:	e0 91 00 01 	lds	r30, 0x0100
    1566:	f0 91 01 01 	lds	r31, 0x0101
    156a:	80 2f       	mov	r24, r16
    156c:	09 95       	icall
    156e:	1f 91       	pop	r17
    1570:	0f 91       	pop	r16
    1572:	08 95       	ret

00001574 <DF_GetChipCharacteristics>:
    1574:	80 e0       	ldi	r24, 0x00	; 0
    1576:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    157a:	00 00       	nop
    157c:	81 e0       	ldi	r24, 0x01	; 1
    157e:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    1582:	e0 91 00 01 	lds	r30, 0x0100
    1586:	f0 91 01 01 	lds	r31, 0x0101
    158a:	87 e5       	ldi	r24, 0x57	; 87
    158c:	09 95       	icall
    158e:	e0 91 00 01 	lds	r30, 0x0100
    1592:	f0 91 01 01 	lds	r31, 0x0101
    1596:	80 e0       	ldi	r24, 0x00	; 0
    1598:	09 95       	icall
    159a:	68 2f       	mov	r22, r24
    159c:	77 27       	eor	r23, r23
    159e:	cb 01       	movw	r24, r22
    15a0:	88 73       	andi	r24, 0x38	; 56
    15a2:	90 70       	andi	r25, 0x00	; 0
    15a4:	33 e0       	ldi	r19, 0x03	; 3
    15a6:	95 95       	asr	r25
    15a8:	87 95       	ror	r24
    15aa:	3a 95       	dec	r19
    15ac:	e1 f7       	brne	.-8      	; 0x15a6 <DF_GetChipCharacteristics+0x32>
    15ae:	99 27       	eor	r25, r25
    15b0:	fc 01       	movw	r30, r24
    15b2:	ec 55       	subi	r30, 0x5C	; 92
    15b4:	fc 4f       	sbci	r31, 0xFC	; 252
    15b6:	44 91       	lpm	r20, Z
    15b8:	40 93 86 02 	sts	0x0286, r20
    15bc:	9c 01       	movw	r18, r24
    15be:	28 0f       	add	r18, r24
    15c0:	39 1f       	adc	r19, r25
    15c2:	f9 01       	movw	r30, r18
    15c4:	ec 56       	subi	r30, 0x6C	; 108
    15c6:	fc 4f       	sbci	r31, 0xFC	; 252
    15c8:	85 91       	lpm	r24, Z+
    15ca:	94 91       	lpm	r25, Z
    15cc:	90 93 88 02 	sts	0x0288, r25
    15d0:	80 93 87 02 	sts	0x0287, r24
    15d4:	f9 01       	movw	r30, r18
    15d6:	ec 57       	subi	r30, 0x7C	; 124
    15d8:	fc 4f       	sbci	r31, 0xFC	; 252
    15da:	85 91       	lpm	r24, Z+
    15dc:	94 91       	lpm	r25, Z
    15de:	90 93 8a 02 	sts	0x028A, r25
    15e2:	80 93 89 02 	sts	0x0289, r24
    15e6:	80 e1       	ldi	r24, 0x10	; 16
    15e8:	84 1b       	sub	r24, r20
    15ea:	8a bd       	out	0x2a, r24	; 42
    15ec:	48 50       	subi	r20, 0x08	; 8
    15ee:	4b bd       	out	0x2b, r20	; 43
    15f0:	cb 01       	movw	r24, r22
    15f2:	08 95       	ret

000015f4 <DF_ErasePage>:
    15f4:	0f 93       	push	r16
    15f6:	1f 93       	push	r17
    15f8:	8c 01       	movw	r16, r24
    15fa:	80 e0       	ldi	r24, 0x00	; 0
    15fc:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    1600:	00 00       	nop
    1602:	81 e0       	ldi	r24, 0x01	; 1
    1604:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    1608:	e0 91 00 01 	lds	r30, 0x0100
    160c:	f0 91 01 01 	lds	r31, 0x0101
    1610:	81 e8       	ldi	r24, 0x81	; 129
    1612:	09 95       	icall
    1614:	8a b5       	in	r24, 0x2a	; 42
    1616:	98 01       	movw	r18, r16
    1618:	02 c0       	rjmp	.+4      	; 0x161e <DF_ErasePage+0x2a>
    161a:	36 95       	lsr	r19
    161c:	27 95       	ror	r18
    161e:	8a 95       	dec	r24
    1620:	e2 f7       	brpl	.-8      	; 0x161a <DF_ErasePage+0x26>
    1622:	c9 01       	movw	r24, r18
    1624:	e0 91 00 01 	lds	r30, 0x0100
    1628:	f0 91 01 01 	lds	r31, 0x0101
    162c:	09 95       	icall
    162e:	8b b5       	in	r24, 0x2b	; 43
    1630:	02 c0       	rjmp	.+4      	; 0x1636 <DF_ErasePage+0x42>
    1632:	00 0f       	add	r16, r16
    1634:	11 1f       	adc	r17, r17
    1636:	8a 95       	dec	r24
    1638:	e2 f7       	brpl	.-8      	; 0x1632 <DF_ErasePage+0x3e>
    163a:	e0 91 00 01 	lds	r30, 0x0100
    163e:	f0 91 01 01 	lds	r31, 0x0101
    1642:	80 2f       	mov	r24, r16
    1644:	09 95       	icall
    1646:	e0 91 00 01 	lds	r30, 0x0100
    164a:	f0 91 01 01 	lds	r31, 0x0101
    164e:	80 e0       	ldi	r24, 0x00	; 0
    1650:	09 95       	icall
    1652:	80 e0       	ldi	r24, 0x00	; 0
    1654:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    1658:	00 00       	nop
    165a:	81 e0       	ldi	r24, 0x01	; 1
    165c:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    1660:	0e 94 ba 0a 	call	0x1574 <DF_GetChipCharacteristics>
    1664:	88 23       	and	r24, r24
    1666:	e4 f7       	brge	.-8      	; 0x1660 <DF_ErasePage+0x6c>
    1668:	1f 91       	pop	r17
    166a:	0f 91       	pop	r16
    166c:	08 95       	ret

0000166e <DF_CopyFlashPageToBuffer>:
    166e:	0f 93       	push	r16
    1670:	1f 93       	push	r17
    1672:	8c 01       	movw	r16, r24
    1674:	80 e0       	ldi	r24, 0x00	; 0
    1676:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    167a:	00 00       	nop
    167c:	81 e0       	ldi	r24, 0x01	; 1
    167e:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    1682:	e0 91 00 01 	lds	r30, 0x0100
    1686:	f0 91 01 01 	lds	r31, 0x0101
    168a:	83 e5       	ldi	r24, 0x53	; 83
    168c:	09 95       	icall
    168e:	8a b5       	in	r24, 0x2a	; 42
    1690:	98 01       	movw	r18, r16
    1692:	02 c0       	rjmp	.+4      	; 0x1698 <DF_CopyFlashPageToBuffer+0x2a>
    1694:	36 95       	lsr	r19
    1696:	27 95       	ror	r18
    1698:	8a 95       	dec	r24
    169a:	e2 f7       	brpl	.-8      	; 0x1694 <DF_CopyFlashPageToBuffer+0x26>
    169c:	c9 01       	movw	r24, r18
    169e:	e0 91 00 01 	lds	r30, 0x0100
    16a2:	f0 91 01 01 	lds	r31, 0x0101
    16a6:	09 95       	icall
    16a8:	8b b5       	in	r24, 0x2b	; 43
    16aa:	02 c0       	rjmp	.+4      	; 0x16b0 <DF_CopyFlashPageToBuffer+0x42>
    16ac:	00 0f       	add	r16, r16
    16ae:	11 1f       	adc	r17, r17
    16b0:	8a 95       	dec	r24
    16b2:	e2 f7       	brpl	.-8      	; 0x16ac <DF_CopyFlashPageToBuffer+0x3e>
    16b4:	e0 91 00 01 	lds	r30, 0x0100
    16b8:	f0 91 01 01 	lds	r31, 0x0101
    16bc:	80 2f       	mov	r24, r16
    16be:	09 95       	icall
    16c0:	e0 91 00 01 	lds	r30, 0x0100
    16c4:	f0 91 01 01 	lds	r31, 0x0101
    16c8:	80 e0       	ldi	r24, 0x00	; 0
    16ca:	09 95       	icall
    16cc:	80 e0       	ldi	r24, 0x00	; 0
    16ce:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    16d2:	00 00       	nop
    16d4:	81 e0       	ldi	r24, 0x01	; 1
    16d6:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    16da:	0e 94 ba 0a 	call	0x1574 <DF_GetChipCharacteristics>
    16de:	88 23       	and	r24, r24
    16e0:	e4 f7       	brge	.-8      	; 0x16da <DF_CopyFlashPageToBuffer+0x6c>
    16e2:	1f 91       	pop	r17
    16e4:	0f 91       	pop	r16
    16e6:	08 95       	ret

000016e8 <DF_CopyBufferToFlashPage>:
    16e8:	0f 93       	push	r16
    16ea:	1f 93       	push	r17
    16ec:	8c 01       	movw	r16, r24
    16ee:	80 e0       	ldi	r24, 0x00	; 0
    16f0:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    16f4:	00 00       	nop
    16f6:	81 e0       	ldi	r24, 0x01	; 1
    16f8:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    16fc:	e0 91 00 01 	lds	r30, 0x0100
    1700:	f0 91 01 01 	lds	r31, 0x0101
    1704:	83 e8       	ldi	r24, 0x83	; 131
    1706:	09 95       	icall
    1708:	8a b5       	in	r24, 0x2a	; 42
    170a:	98 01       	movw	r18, r16
    170c:	02 c0       	rjmp	.+4      	; 0x1712 <DF_CopyBufferToFlashPage+0x2a>
    170e:	36 95       	lsr	r19
    1710:	27 95       	ror	r18
    1712:	8a 95       	dec	r24
    1714:	e2 f7       	brpl	.-8      	; 0x170e <DF_CopyBufferToFlashPage+0x26>
    1716:	c9 01       	movw	r24, r18
    1718:	e0 91 00 01 	lds	r30, 0x0100
    171c:	f0 91 01 01 	lds	r31, 0x0101
    1720:	09 95       	icall
    1722:	8b b5       	in	r24, 0x2b	; 43
    1724:	02 c0       	rjmp	.+4      	; 0x172a <DF_CopyBufferToFlashPage+0x42>
    1726:	00 0f       	add	r16, r16
    1728:	11 1f       	adc	r17, r17
    172a:	8a 95       	dec	r24
    172c:	e2 f7       	brpl	.-8      	; 0x1726 <DF_CopyBufferToFlashPage+0x3e>
    172e:	e0 91 00 01 	lds	r30, 0x0100
    1732:	f0 91 01 01 	lds	r31, 0x0101
    1736:	80 2f       	mov	r24, r16
    1738:	09 95       	icall
    173a:	e0 91 00 01 	lds	r30, 0x0100
    173e:	f0 91 01 01 	lds	r31, 0x0101
    1742:	80 e0       	ldi	r24, 0x00	; 0
    1744:	09 95       	icall
    1746:	80 e0       	ldi	r24, 0x00	; 0
    1748:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    174c:	00 00       	nop
    174e:	81 e0       	ldi	r24, 0x01	; 1
    1750:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    1754:	0e 94 ba 0a 	call	0x1574 <DF_GetChipCharacteristics>
    1758:	88 23       	and	r24, r24
    175a:	e4 f7       	brge	.-8      	; 0x1754 <DF_CopyBufferToFlashPage+0x6c>
    175c:	1f 91       	pop	r17
    175e:	0f 91       	pop	r16
    1760:	08 95       	ret

00001762 <DF_CheckCorrectOnboardChip>:
    1762:	0e 94 ba 0a 	call	0x1574 <DF_GetChipCharacteristics>
    1766:	80 91 86 02 	lds	r24, 0x0286
    176a:	89 30       	cpi	r24, 0x09	; 9
    176c:	61 f0       	breq	.+24     	; 0x1786 <DF_CheckCorrectOnboardChip+0x24>
    176e:	80 91 64 00 	lds	r24, 0x0064
    1772:	84 60       	ori	r24, 0x04	; 4
    1774:	80 93 64 00 	sts	0x0064, r24
    1778:	84 e7       	ldi	r24, 0x74	; 116
    177a:	93 e0       	ldi	r25, 0x03	; 3
    177c:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
    1780:	80 e0       	ldi	r24, 0x00	; 0
    1782:	90 e0       	ldi	r25, 0x00	; 0
    1784:	08 95       	ret
    1786:	81 e0       	ldi	r24, 0x01	; 1
    1788:	90 e0       	ldi	r25, 0x00	; 0
    178a:	08 95       	ret

0000178c <BUFF_InitialiseBuffer>:

// Routines:
void BUFF_InitialiseBuffer(void)
{
	StoreLoc    = (BuffType*)&RingBuffer[0]; // Set up the IN pointer to the start of the buffer
    178c:	8d e8       	ldi	r24, 0x8D	; 141
    178e:	92 e0       	ldi	r25, 0x02	; 2
    1790:	90 93 ce 02 	sts	0x02CE, r25
    1794:	80 93 cd 02 	sts	0x02CD, r24
	RetrieveLoc = (BuffType*)&RingBuffer[0]; // Set up the OUT pointer to the start of the buffer
    1798:	90 93 d0 02 	sts	0x02D0, r25
    179c:	80 93 cf 02 	sts	0x02CF, r24

	BuffElements = 0;                     // Reset the buffer elements counter
    17a0:	10 92 d1 02 	sts	0x02D1, r1
    17a4:	08 95       	ret

000017a6 <BUFF_StoreBuffByte>:
}

void BUFF_StoreBuffByte(BuffType DataToStore)
{
    17a6:	98 2f       	mov	r25, r24
	if (BuffElements == BuffLen)          // Buffer full
    17a8:	80 91 d1 02 	lds	r24, 0x02D1
    17ac:	80 34       	cpi	r24, 0x40	; 64
    17ae:	29 f4       	brne	.+10     	; 0x17ba <BUFF_StoreBuffByte+0x14>
	{
		MAIN_ShowError(PSTR("BUFF OVERFLOW"));
    17b0:	8c ea       	ldi	r24, 0xAC	; 172
    17b2:	93 e0       	ldi	r25, 0x03	; 3
    17b4:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
		return;
    17b8:	08 95       	ret
	}
		
	*StoreLoc = DataToStore;              // Store the data
    17ba:	e0 91 cd 02 	lds	r30, 0x02CD
    17be:	f0 91 ce 02 	lds	r31, 0x02CE
    17c2:	90 83       	st	Z, r25

	StoreLoc++;                           // Increment the IN pointer to the next element
    17c4:	40 91 cd 02 	lds	r20, 0x02CD
    17c8:	50 91 ce 02 	lds	r21, 0x02CE
    17cc:	9a 01       	movw	r18, r20
    17ce:	2f 5f       	subi	r18, 0xFF	; 255
    17d0:	3f 4f       	sbci	r19, 0xFF	; 255
    17d2:	30 93 ce 02 	sts	0x02CE, r19
    17d6:	20 93 cd 02 	sts	0x02CD, r18
	BuffElements++;                       // Increment the total elements variable
    17da:	80 91 d1 02 	lds	r24, 0x02D1
    17de:	8f 5f       	subi	r24, 0xFF	; 255
    17e0:	80 93 d1 02 	sts	0x02D1, r24

	if (StoreLoc == (BuffType*)&RingBuffer[BuffLen])
    17e4:	2d 5c       	subi	r18, 0xCD	; 205
    17e6:	32 40       	sbci	r19, 0x02	; 2
    17e8:	31 f4       	brne	.+12     	; 0x17f6 <BUFF_StoreBuffByte+0x50>
		StoreLoc = (BuffType*)&RingBuffer[0]; // Wrap pointer if end of array reached
    17ea:	4f 53       	subi	r20, 0x3F	; 63
    17ec:	50 40       	sbci	r21, 0x00	; 0
    17ee:	50 93 ce 02 	sts	0x02CE, r21
    17f2:	40 93 cd 02 	sts	0x02CD, r20
    17f6:	08 95       	ret

000017f8 <BUFF_GetBuffByte>:
}	

BuffType BUFF_GetBuffByte(void)
{
	if (!(BuffElements))                  // No elements in the buffer
    17f8:	80 91 d1 02 	lds	r24, 0x02D1
    17fc:	88 23       	and	r24, r24
    17fe:	19 f4       	brne	.+6      	; 0x1806 <BUFF_GetBuffByte+0xe>
		return 0;
    1800:	80 e0       	ldi	r24, 0x00	; 0
    1802:	90 e0       	ldi	r25, 0x00	; 0
    1804:	08 95       	ret

	BuffType RetrievedData = *RetrieveLoc; // Grab the stored byte into a temp variable
    1806:	20 91 cf 02 	lds	r18, 0x02CF
    180a:	30 91 d0 02 	lds	r19, 0x02D0
    180e:	f9 01       	movw	r30, r18
    1810:	91 91       	ld	r25, Z+

	RetrieveLoc++;                         // Increment the OUT pointer to the next element if flag set
    1812:	f0 93 d0 02 	sts	0x02D0, r31
    1816:	e0 93 cf 02 	sts	0x02CF, r30
	BuffElements--;                        // Decrement the total elements variable
    181a:	80 91 d1 02 	lds	r24, 0x02D1
    181e:	81 50       	subi	r24, 0x01	; 1
    1820:	80 93 d1 02 	sts	0x02D1, r24
	
	if (RetrieveLoc == (BuffType*)&RingBuffer[BuffLen])
    1824:	ed 5c       	subi	r30, 0xCD	; 205
    1826:	f2 40       	sbci	r31, 0x02	; 2
    1828:	31 f4       	brne	.+12     	; 0x1836 <BUFF_GetBuffByte+0x3e>
		RetrieveLoc = (BuffType*)&RingBuffer[0]; // Wrap pointer if end of array reached
    182a:	2f 53       	subi	r18, 0x3F	; 63
    182c:	30 40       	sbci	r19, 0x00	; 0
    182e:	30 93 d0 02 	sts	0x02D0, r19
    1832:	20 93 cf 02 	sts	0x02CF, r18
		
	return RetrievedData;                 // Return the retrieved data
    1836:	89 2f       	mov	r24, r25
    1838:	99 27       	eor	r25, r25
}
    183a:	08 95       	ret

0000183c <__vector_9>:
// ======================================================================================

// Timeout = ((F_CPU / 64) / (65535 * TIMEOUT_TICKSBEFORETIMEOUT)) per second
ISR(TIMER1_OVF_vect, ISR_NOBLOCK)
{
    183c:	78 94       	sei
    183e:	1f 92       	push	r1
    1840:	0f 92       	push	r0
    1842:	0f b6       	in	r0, 0x3f	; 63
    1844:	0f 92       	push	r0
    1846:	11 24       	eor	r1, r1
    1848:	8f 93       	push	r24
	if (Ticks++ == TIMEOUT_TICKSBEFORETIMEOUT)
    184a:	80 91 2b 01 	lds	r24, 0x012B
    184e:	8f 5f       	subi	r24, 0xFF	; 255
    1850:	80 93 2b 01 	sts	0x012B, r24
    1854:	80 91 2b 01 	lds	r24, 0x012B
    1858:	87 30       	cpi	r24, 0x07	; 7
    185a:	29 f4       	brne	.+10     	; 0x1866 <__vector_9+0x2a>
	{
	   Ticks   = 0;
    185c:	10 92 2b 01 	sts	0x012B, r1
	   TimeOut = TRUE;
    1860:	81 e0       	ldi	r24, 0x01	; 1
    1862:	80 93 2a 01 	sts	0x012A, r24
    1866:	8f 91       	pop	r24
    1868:	0f 90       	pop	r0
    186a:	0f be       	out	0x3f, r0	; 63
    186c:	0f 90       	pop	r0
    186e:	1f 90       	pop	r1
    1870:	18 95       	reti

00001872 <TIMEOUT_SetupTimeoutTimer>:
	}
}

// ======================================================================================

void TIMEOUT_SetupTimeoutTimer(void)
{
	TCCR1A = 0;
    1872:	10 92 80 00 	sts	0x0080, r1
	TIMEOUT_TIMER_OFF();
    1876:	10 92 81 00 	sts	0x0081, r1
    187a:	10 92 2b 01 	sts	0x012B, r1
    187e:	10 92 85 00 	sts	0x0085, r1
    1882:	10 92 84 00 	sts	0x0084, r1
	TCCR1C = 0;
    1886:	10 92 82 00 	sts	0x0082, r1
	
	TIMSK1 = (1 << TOIE1); // Turn timer 1 overflow interrupt on
    188a:	81 e0       	ldi	r24, 0x01	; 1
    188c:	80 93 6f 00 	sts	0x006F, r24
    1890:	08 95       	ret

00001892 <PD_SetupDFAddressCounters>:
}

void PD_SetupDFAddressCounters(void)
{
	uint32_t StartAddress = CurrAddress;
    1892:	20 91 2d 01 	lds	r18, 0x012D
    1896:	30 91 2e 01 	lds	r19, 0x012E
    189a:	40 91 2f 01 	lds	r20, 0x012F
    189e:	50 91 30 01 	lds	r21, 0x0130

	CurrPageAddress = 0;
    18a2:	10 92 8c 02 	sts	0x028C, r1
    18a6:	10 92 8b 02 	sts	0x028B, r1

	while (StartAddress > DataflashInfo.PageSize)      // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DataflashInfo.PageSize;         // Subtract one page's worth of bytes from the desired address
		CurrPageAddress++;
    18aa:	80 91 87 02 	lds	r24, 0x0287
    18ae:	90 91 88 02 	lds	r25, 0x0288
    18b2:	aa 27       	eor	r26, r26
    18b4:	bb 27       	eor	r27, r27
    18b6:	82 17       	cp	r24, r18
    18b8:	93 07       	cpc	r25, r19
    18ba:	a4 07       	cpc	r26, r20
    18bc:	b5 07       	cpc	r27, r21
    18be:	88 f4       	brcc	.+34     	; 0x18e2 <PD_SetupDFAddressCounters+0x50>
    18c0:	60 e0       	ldi	r22, 0x00	; 0
    18c2:	70 e0       	ldi	r23, 0x00	; 0
    18c4:	28 1b       	sub	r18, r24
    18c6:	39 0b       	sbc	r19, r25
    18c8:	4a 0b       	sbc	r20, r26
    18ca:	5b 0b       	sbc	r21, r27
    18cc:	6f 5f       	subi	r22, 0xFF	; 255
    18ce:	7f 4f       	sbci	r23, 0xFF	; 255
    18d0:	82 17       	cp	r24, r18
    18d2:	93 07       	cpc	r25, r19
    18d4:	a4 07       	cpc	r26, r20
    18d6:	b5 07       	cpc	r27, r21
    18d8:	a8 f3       	brcs	.-22     	; 0x18c4 <PD_SetupDFAddressCounters+0x32>
    18da:	70 93 8c 02 	sts	0x028C, r23
    18de:	60 93 8b 02 	sts	0x028B, r22
	}
	
	CurrBuffByte = (uint16_t)StartAddress;              // The buffer byte is the remainder
    18e2:	30 93 85 02 	sts	0x0285, r19
    18e6:	20 93 84 02 	sts	0x0284, r18
    18ea:	08 95       	ret

000018ec <DF_StoreDataflashByte>:
}

void DF_StoreDataflashByte(uint8_t Data)
{
    18ec:	cf 93       	push	r28
    18ee:	c8 2f       	mov	r28, r24
	if (CurrBuffByte == DataflashInfo.PageSize)
    18f0:	20 91 84 02 	lds	r18, 0x0284
    18f4:	30 91 85 02 	lds	r19, 0x0285
    18f8:	80 91 87 02 	lds	r24, 0x0287
    18fc:	90 91 88 02 	lds	r25, 0x0288
    1900:	28 17       	cp	r18, r24
    1902:	39 07       	cpc	r19, r25
    1904:	a9 f4       	brne	.+42     	; 0x1930 <DF_StoreDataflashByte+0x44>
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
    1906:	80 91 8b 02 	lds	r24, 0x028B
    190a:	90 91 8c 02 	lds	r25, 0x028C
    190e:	9c 01       	movw	r18, r24
    1910:	01 96       	adiw	r24, 0x01	; 1
    1912:	90 93 8c 02 	sts	0x028C, r25
    1916:	80 93 8b 02 	sts	0x028B, r24
    191a:	c9 01       	movw	r24, r18
    191c:	0e 94 74 0b 	call	0x16e8 <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    1920:	80 e0       	ldi	r24, 0x00	; 0
    1922:	90 e0       	ldi	r25, 0x00	; 0
    1924:	0e 94 94 0a 	call	0x1528 <DF_BufferWriteEnable>
		CurrBuffByte = 0;
    1928:	10 92 85 02 	sts	0x0285, r1
    192c:	10 92 84 02 	sts	0x0284, r1
	}
	
	USI_SPITransmit(Data);                                 // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    1930:	8c 2f       	mov	r24, r28
    1932:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
	CurrBuffByte++;
    1936:	80 91 84 02 	lds	r24, 0x0284
    193a:	90 91 85 02 	lds	r25, 0x0285
    193e:	01 96       	adiw	r24, 0x01	; 1
    1940:	90 93 85 02 	sts	0x0285, r25
    1944:	80 93 84 02 	sts	0x0284, r24
    1948:	cf 91       	pop	r28
    194a:	08 95       	ret

0000194c <PD_InterpretAVRISPPacket>:
    194c:	ef 92       	push	r14
    194e:	ff 92       	push	r15
    1950:	0f 93       	push	r16
    1952:	1f 93       	push	r17
    1954:	cf 93       	push	r28
    1956:	df 93       	push	r29
    1958:	80 91 36 01 	lds	r24, 0x0136
    195c:	99 27       	eor	r25, r25
    195e:	86 31       	cpi	r24, 0x16	; 22
    1960:	91 05       	cpc	r25, r1
    1962:	09 f4       	brne	.+2      	; 0x1966 <PD_InterpretAVRISPPacket+0x1a>
    1964:	04 c1       	rjmp	.+520    	; 0x1b6e <PD_InterpretAVRISPPacket+0x222>
    1966:	87 31       	cpi	r24, 0x17	; 23
    1968:	91 05       	cpc	r25, r1
    196a:	b4 f4       	brge	.+44     	; 0x1998 <PD_InterpretAVRISPPacket+0x4c>
    196c:	82 31       	cpi	r24, 0x12	; 18
    196e:	91 05       	cpc	r25, r1
    1970:	09 f4       	brne	.+2      	; 0x1974 <PD_InterpretAVRISPPacket+0x28>
    1972:	69 c0       	rjmp	.+210    	; 0x1a46 <PD_InterpretAVRISPPacket+0xfa>
    1974:	83 31       	cpi	r24, 0x13	; 19
    1976:	91 05       	cpc	r25, r1
    1978:	3c f4       	brge	.+14     	; 0x1988 <PD_InterpretAVRISPPacket+0x3c>
    197a:	80 31       	cpi	r24, 0x10	; 16
    197c:	91 05       	cpc	r25, r1
    197e:	31 f1       	breq	.+76     	; 0x19cc <PD_InterpretAVRISPPacket+0x80>
    1980:	41 97       	sbiw	r24, 0x11	; 17
    1982:	09 f4       	brne	.+2      	; 0x1986 <PD_InterpretAVRISPPacket+0x3a>
    1984:	46 c0       	rjmp	.+140    	; 0x1a12 <PD_InterpretAVRISPPacket+0xc6>
    1986:	44 c1       	rjmp	.+648    	; 0x1c10 <PD_InterpretAVRISPPacket+0x2c4>
    1988:	84 31       	cpi	r24, 0x14	; 20
    198a:	91 05       	cpc	r25, r1
    198c:	09 f4       	brne	.+2      	; 0x1990 <PD_InterpretAVRISPPacket+0x44>
    198e:	90 c0       	rjmp	.+288    	; 0x1ab0 <PD_InterpretAVRISPPacket+0x164>
    1990:	45 97       	sbiw	r24, 0x15	; 21
    1992:	0c f0       	brlt	.+2      	; 0x1996 <PD_InterpretAVRISPPacket+0x4a>
    1994:	b3 c0       	rjmp	.+358    	; 0x1afc <PD_InterpretAVRISPPacket+0x1b0>
    1996:	85 c0       	rjmp	.+266    	; 0x1aa2 <PD_InterpretAVRISPPacket+0x156>
    1998:	89 31       	cpi	r24, 0x19	; 25
    199a:	91 05       	cpc	r25, r1
    199c:	09 f4       	brne	.+2      	; 0x19a0 <PD_InterpretAVRISPPacket+0x54>
    199e:	76 c0       	rjmp	.+236    	; 0x1a8c <PD_InterpretAVRISPPacket+0x140>
    19a0:	8a 31       	cpi	r24, 0x1A	; 26
    19a2:	91 05       	cpc	r25, r1
    19a4:	44 f4       	brge	.+16     	; 0x19b6 <PD_InterpretAVRISPPacket+0x6a>
    19a6:	87 31       	cpi	r24, 0x17	; 23
    19a8:	91 05       	cpc	r25, r1
    19aa:	09 f4       	brne	.+2      	; 0x19ae <PD_InterpretAVRISPPacket+0x62>
    19ac:	6f c0       	rjmp	.+222    	; 0x1a8c <PD_InterpretAVRISPPacket+0x140>
    19ae:	48 97       	sbiw	r24, 0x18	; 24
    19b0:	09 f4       	brne	.+2      	; 0x19b4 <PD_InterpretAVRISPPacket+0x68>
    19b2:	5e c0       	rjmp	.+188    	; 0x1a70 <PD_InterpretAVRISPPacket+0x124>
    19b4:	2d c1       	rjmp	.+602    	; 0x1c10 <PD_InterpretAVRISPPacket+0x2c4>
    19b6:	8b 31       	cpi	r24, 0x1B	; 27
    19b8:	91 05       	cpc	r25, r1
    19ba:	d9 f1       	breq	.+118    	; 0x1a32 <PD_InterpretAVRISPPacket+0xe6>
    19bc:	8b 31       	cpi	r24, 0x1B	; 27
    19be:	91 05       	cpc	r25, r1
    19c0:	0c f4       	brge	.+2      	; 0x19c4 <PD_InterpretAVRISPPacket+0x78>
    19c2:	56 c0       	rjmp	.+172    	; 0x1a70 <PD_InterpretAVRISPPacket+0x124>
    19c4:	4c 97       	sbiw	r24, 0x1c	; 28
    19c6:	09 f4       	brne	.+2      	; 0x19ca <PD_InterpretAVRISPPacket+0x7e>
    19c8:	53 c0       	rjmp	.+166    	; 0x1a70 <PD_InterpretAVRISPPacket+0x124>
    19ca:	22 c1       	rjmp	.+580    	; 0x1c10 <PD_InterpretAVRISPPacket+0x2c4>
    19cc:	82 e0       	ldi	r24, 0x02	; 2
    19ce:	90 e0       	ldi	r25, 0x00	; 0
    19d0:	90 93 33 01 	sts	0x0133, r25
    19d4:	80 93 32 01 	sts	0x0132, r24
    19d8:	81 e0       	ldi	r24, 0x01	; 1
    19da:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    19de:	0e 94 ba 0a 	call	0x1574 <DF_GetChipCharacteristics>
    19e2:	c0 91 86 02 	lds	r28, 0x0286
    19e6:	cc 23       	and	r28, r28
    19e8:	59 f0       	breq	.+22     	; 0x1a00 <PD_InterpretAVRISPPacket+0xb4>
    19ea:	8a eb       	ldi	r24, 0xBA	; 186
    19ec:	93 e0       	ldi	r25, 0x03	; 3
    19ee:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>
    19f2:	81 e0       	ldi	r24, 0x01	; 1
    19f4:	80 93 31 01 	sts	0x0131, r24
    19f8:	81 b3       	in	r24, 0x11	; 17
    19fa:	8f 7c       	andi	r24, 0xCF	; 207
    19fc:	80 62       	ori	r24, 0x20	; 32
    19fe:	17 c0       	rjmp	.+46     	; 0x1a2e <PD_InterpretAVRISPPacket+0xe2>
    1a00:	84 e7       	ldi	r24, 0x74	; 116
    1a02:	93 e0       	ldi	r25, 0x03	; 3
    1a04:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>
    1a08:	8c 2f       	mov	r24, r28
    1a0a:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    1a0e:	80 ec       	ldi	r24, 0xC0	; 192
    1a10:	06 c1       	rjmp	.+524    	; 0x1c1e <PD_InterpretAVRISPPacket+0x2d2>
    1a12:	82 e0       	ldi	r24, 0x02	; 2
    1a14:	90 e0       	ldi	r25, 0x00	; 0
    1a16:	90 93 33 01 	sts	0x0133, r25
    1a1a:	80 93 32 01 	sts	0x0132, r24
    1a1e:	10 92 31 01 	sts	0x0131, r1
    1a22:	80 e0       	ldi	r24, 0x00	; 0
    1a24:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    1a28:	81 b3       	in	r24, 0x11	; 17
    1a2a:	8f 7c       	andi	r24, 0xCF	; 207
    1a2c:	80 61       	ori	r24, 0x10	; 16
    1a2e:	81 bb       	out	0x11, r24	; 17
    1a30:	9b c0       	rjmp	.+310    	; 0x1b68 <PD_InterpretAVRISPPacket+0x21c>
    1a32:	84 e0       	ldi	r24, 0x04	; 4
    1a34:	90 e0       	ldi	r25, 0x00	; 0
    1a36:	90 93 33 01 	sts	0x0133, r25
    1a3a:	80 93 32 01 	sts	0x0132, r24
    1a3e:	10 92 37 01 	sts	0x0137, r1
    1a42:	82 e0       	ldi	r24, 0x02	; 2
    1a44:	1e c0       	rjmp	.+60     	; 0x1a82 <PD_InterpretAVRISPPacket+0x136>
    1a46:	82 e0       	ldi	r24, 0x02	; 2
    1a48:	90 e0       	ldi	r25, 0x00	; 0
    1a4a:	90 93 33 01 	sts	0x0133, r25
    1a4e:	80 93 32 01 	sts	0x0132, r24
    1a52:	c0 e0       	ldi	r28, 0x00	; 0
    1a54:	d0 e0       	ldi	r29, 0x00	; 0
    1a56:	80 91 89 02 	lds	r24, 0x0289
    1a5a:	90 91 8a 02 	lds	r25, 0x028A
    1a5e:	c8 17       	cp	r28, r24
    1a60:	d9 07       	cpc	r29, r25
    1a62:	08 f0       	brcs	.+2      	; 0x1a66 <PD_InterpretAVRISPPacket+0x11a>
    1a64:	81 c0       	rjmp	.+258    	; 0x1b68 <PD_InterpretAVRISPPacket+0x21c>
    1a66:	ce 01       	movw	r24, r28
    1a68:	0e 94 fa 0a 	call	0x15f4 <DF_ErasePage>
    1a6c:	21 96       	adiw	r28, 0x01	; 1
    1a6e:	f3 cf       	rjmp	.-26     	; 0x1a56 <PD_InterpretAVRISPPacket+0x10a>
    1a70:	84 e0       	ldi	r24, 0x04	; 4
    1a72:	90 e0       	ldi	r25, 0x00	; 0
    1a74:	90 93 33 01 	sts	0x0133, r25
    1a78:	80 93 32 01 	sts	0x0132, r24
    1a7c:	10 92 37 01 	sts	0x0137, r1
    1a80:	8f ef       	ldi	r24, 0xFF	; 255
    1a82:	80 93 38 01 	sts	0x0138, r24
    1a86:	10 92 39 01 	sts	0x0139, r1
    1a8a:	cb c0       	rjmp	.+406    	; 0x1c22 <PD_InterpretAVRISPPacket+0x2d6>
    1a8c:	83 e0       	ldi	r24, 0x03	; 3
    1a8e:	90 e0       	ldi	r25, 0x00	; 0
    1a90:	90 93 33 01 	sts	0x0133, r25
    1a94:	80 93 32 01 	sts	0x0132, r24
    1a98:	10 92 37 01 	sts	0x0137, r1
    1a9c:	10 92 38 01 	sts	0x0138, r1
    1aa0:	c0 c0       	rjmp	.+384    	; 0x1c22 <PD_InterpretAVRISPPacket+0x2d6>
    1aa2:	82 e0       	ldi	r24, 0x02	; 2
    1aa4:	90 e0       	ldi	r25, 0x00	; 0
    1aa6:	90 93 33 01 	sts	0x0133, r25
    1aaa:	80 93 32 01 	sts	0x0132, r24
    1aae:	5c c0       	rjmp	.+184    	; 0x1b68 <PD_InterpretAVRISPPacket+0x21c>
    1ab0:	80 91 37 01 	lds	r24, 0x0137
    1ab4:	99 27       	eor	r25, r25
    1ab6:	38 2f       	mov	r19, r24
    1ab8:	22 27       	eor	r18, r18
    1aba:	80 91 38 01 	lds	r24, 0x0138
    1abe:	99 27       	eor	r25, r25
    1ac0:	28 2b       	or	r18, r24
    1ac2:	39 2b       	or	r19, r25
    1ac4:	f9 01       	movw	r30, r18
    1ac6:	33 96       	adiw	r30, 0x03	; 3
    1ac8:	f0 93 33 01 	sts	0x0133, r31
    1acc:	e0 93 32 01 	sts	0x0132, r30
    1ad0:	10 92 37 01 	sts	0x0137, r1
    1ad4:	eb 5c       	subi	r30, 0xCB	; 203
    1ad6:	fe 4f       	sbci	r31, 0xFE	; 254
    1ad8:	10 82       	st	Z, r1
    1ada:	81 e0       	ldi	r24, 0x01	; 1
    1adc:	90 e0       	ldi	r25, 0x00	; 0
    1ade:	28 0f       	add	r18, r24
    1ae0:	39 1f       	adc	r19, r25
    1ae2:	82 17       	cp	r24, r18
    1ae4:	93 07       	cpc	r25, r19
    1ae6:	08 f0       	brcs	.+2      	; 0x1aea <PD_InterpretAVRISPPacket+0x19e>
    1ae8:	9c c0       	rjmp	.+312    	; 0x1c22 <PD_InterpretAVRISPPacket+0x2d6>
    1aea:	4f ef       	ldi	r20, 0xFF	; 255
    1aec:	e7 e3       	ldi	r30, 0x37	; 55
    1aee:	f1 e0       	ldi	r31, 0x01	; 1
    1af0:	41 93       	st	Z+, r20
    1af2:	01 96       	adiw	r24, 0x01	; 1
    1af4:	82 17       	cp	r24, r18
    1af6:	93 07       	cpc	r25, r19
    1af8:	d8 f3       	brcs	.-10     	; 0x1af0 <PD_InterpretAVRISPPacket+0x1a4>
    1afa:	93 c0       	rjmp	.+294    	; 0x1c22 <PD_InterpretAVRISPPacket+0x2d6>
    1afc:	0e 94 49 0c 	call	0x1892 <PD_SetupDFAddressCounters>
    1b00:	80 91 8b 02 	lds	r24, 0x028B
    1b04:	90 91 8c 02 	lds	r25, 0x028C
    1b08:	0e 94 37 0b 	call	0x166e <DF_CopyFlashPageToBuffer>
    1b0c:	80 91 84 02 	lds	r24, 0x0284
    1b10:	90 91 85 02 	lds	r25, 0x0285
    1b14:	0e 94 94 0a 	call	0x1528 <DF_BufferWriteEnable>
    1b18:	80 91 37 01 	lds	r24, 0x0137
    1b1c:	99 27       	eor	r25, r25
    1b1e:	d8 2f       	mov	r29, r24
    1b20:	cc 27       	eor	r28, r28
    1b22:	80 91 38 01 	lds	r24, 0x0138
    1b26:	99 27       	eor	r25, r25
    1b28:	c8 2b       	or	r28, r24
    1b2a:	d9 2b       	or	r29, r25
    1b2c:	00 e0       	ldi	r16, 0x00	; 0
    1b2e:	10 e0       	ldi	r17, 0x00	; 0
    1b30:	0c 17       	cp	r16, r28
    1b32:	1d 07       	cpc	r17, r29
    1b34:	c8 f4       	brcc	.+50     	; 0x1b68 <PD_InterpretAVRISPPacket+0x21c>
    1b36:	30 e4       	ldi	r19, 0x40	; 64
    1b38:	e3 2e       	mov	r14, r19
    1b3a:	31 e0       	ldi	r19, 0x01	; 1
    1b3c:	f3 2e       	mov	r15, r19
    1b3e:	f7 01       	movw	r30, r14
    1b40:	81 91       	ld	r24, Z+
    1b42:	7f 01       	movw	r14, r30
    1b44:	0e 94 76 0c 	call	0x18ec <DF_StoreDataflashByte>
    1b48:	80 91 84 02 	lds	r24, 0x0284
    1b4c:	90 91 85 02 	lds	r25, 0x0285
    1b50:	01 96       	adiw	r24, 0x01	; 1
    1b52:	90 93 85 02 	sts	0x0285, r25
    1b56:	80 93 84 02 	sts	0x0284, r24
    1b5a:	0e 94 15 0f 	call	0x1e2a <V2P_IncrementCurrAddress>
    1b5e:	0f 5f       	subi	r16, 0xFF	; 255
    1b60:	1f 4f       	sbci	r17, 0xFF	; 255
    1b62:	0c 17       	cp	r16, r28
    1b64:	1d 07       	cpc	r17, r29
    1b66:	58 f3       	brcs	.-42     	; 0x1b3e <PD_InterpretAVRISPPacket+0x1f2>
    1b68:	10 92 37 01 	sts	0x0137, r1
    1b6c:	5a c0       	rjmp	.+180    	; 0x1c22 <PD_InterpretAVRISPPacket+0x2d6>
    1b6e:	0e 94 49 0c 	call	0x1892 <PD_SetupDFAddressCounters>
    1b72:	80 91 8b 02 	lds	r24, 0x028B
    1b76:	90 91 8c 02 	lds	r25, 0x028C
    1b7a:	0e 94 37 0b 	call	0x166e <DF_CopyFlashPageToBuffer>
    1b7e:	80 91 37 01 	lds	r24, 0x0137
    1b82:	99 27       	eor	r25, r25
    1b84:	d8 2f       	mov	r29, r24
    1b86:	cc 27       	eor	r28, r28
    1b88:	80 91 38 01 	lds	r24, 0x0138
    1b8c:	99 27       	eor	r25, r25
    1b8e:	c8 2b       	or	r28, r24
    1b90:	d9 2b       	or	r29, r25
    1b92:	00 e0       	ldi	r16, 0x00	; 0
    1b94:	10 e0       	ldi	r17, 0x00	; 0
    1b96:	0c 17       	cp	r16, r28
    1b98:	1d 07       	cpc	r17, r29
    1b9a:	70 f5       	brcc	.+92     	; 0x1bf8 <PD_InterpretAVRISPPacket+0x2ac>
    1b9c:	88 e3       	ldi	r24, 0x38	; 56
    1b9e:	e8 2e       	mov	r14, r24
    1ba0:	81 e0       	ldi	r24, 0x01	; 1
    1ba2:	f8 2e       	mov	r15, r24
    1ba4:	20 91 84 02 	lds	r18, 0x0284
    1ba8:	30 91 85 02 	lds	r19, 0x0285
    1bac:	80 91 87 02 	lds	r24, 0x0287
    1bb0:	90 91 88 02 	lds	r25, 0x0288
    1bb4:	28 17       	cp	r18, r24
    1bb6:	39 07       	cpc	r19, r25
    1bb8:	41 f4       	brne	.+16     	; 0x1bca <PD_InterpretAVRISPPacket+0x27e>
    1bba:	0e 94 49 0c 	call	0x1892 <PD_SetupDFAddressCounters>
    1bbe:	80 91 8b 02 	lds	r24, 0x028B
    1bc2:	90 91 8c 02 	lds	r25, 0x028C
    1bc6:	0e 94 37 0b 	call	0x166e <DF_CopyFlashPageToBuffer>
    1bca:	80 91 84 02 	lds	r24, 0x0284
    1bce:	90 91 85 02 	lds	r25, 0x0285
    1bd2:	9c 01       	movw	r18, r24
    1bd4:	01 96       	adiw	r24, 0x01	; 1
    1bd6:	90 93 85 02 	sts	0x0285, r25
    1bda:	80 93 84 02 	sts	0x0284, r24
    1bde:	c9 01       	movw	r24, r18
    1be0:	0e 94 24 0a 	call	0x1448 <DF_ReadBufferByte>
    1be4:	f7 01       	movw	r30, r14
    1be6:	81 93       	st	Z+, r24
    1be8:	7f 01       	movw	r14, r30
    1bea:	0e 94 15 0f 	call	0x1e2a <V2P_IncrementCurrAddress>
    1bee:	0f 5f       	subi	r16, 0xFF	; 255
    1bf0:	1f 4f       	sbci	r17, 0xFF	; 255
    1bf2:	0c 17       	cp	r16, r28
    1bf4:	1d 07       	cpc	r17, r29
    1bf6:	b0 f2       	brcs	.-84     	; 0x1ba4 <PD_InterpretAVRISPPacket+0x258>
    1bf8:	23 96       	adiw	r28, 0x03	; 3
    1bfa:	d0 93 33 01 	sts	0x0133, r29
    1bfe:	c0 93 32 01 	sts	0x0132, r28
    1c02:	23 97       	sbiw	r28, 0x03	; 3
    1c04:	10 92 37 01 	sts	0x0137, r1
    1c08:	ca 5c       	subi	r28, 0xCA	; 202
    1c0a:	de 4f       	sbci	r29, 0xFE	; 254
    1c0c:	1a 82       	std	Y+2, r1	; 0x02
    1c0e:	09 c0       	rjmp	.+18     	; 0x1c22 <PD_InterpretAVRISPPacket+0x2d6>
    1c10:	81 e0       	ldi	r24, 0x01	; 1
    1c12:	90 e0       	ldi	r25, 0x00	; 0
    1c14:	90 93 33 01 	sts	0x0133, r25
    1c18:	80 93 32 01 	sts	0x0132, r24
    1c1c:	89 ec       	ldi	r24, 0xC9	; 201
    1c1e:	80 93 37 01 	sts	0x0137, r24
    1c22:	0e 94 3b 0e 	call	0x1c76 <V2P_SendPacket>
    1c26:	df 91       	pop	r29
    1c28:	cf 91       	pop	r28
    1c2a:	1f 91       	pop	r17
    1c2c:	0f 91       	pop	r16
    1c2e:	ff 90       	pop	r15
    1c30:	ef 90       	pop	r14
    1c32:	08 95       	ret

00001c34 <V2P_GetChecksum>:
	
	/* Checksum for the V2 protocol is comprised of an XOR of all the packet 
      bytes, including the start, sequence number, size and token bytes.    */
	
	CheckSumByte  = MESSAGE_START;
    1c34:	6b e1       	ldi	r22, 0x1B	; 27
	CheckSumByte ^= SequenceNum;
    1c36:	80 91 34 01 	lds	r24, 0x0134
    1c3a:	68 27       	eor	r22, r24
	CheckSumByte ^= (uint8_t)(MessageSize >> 8);
    1c3c:	20 91 32 01 	lds	r18, 0x0132
    1c40:	30 91 33 01 	lds	r19, 0x0133
    1c44:	83 2f       	mov	r24, r19
    1c46:	99 27       	eor	r25, r25
    1c48:	68 27       	eor	r22, r24
	CheckSumByte ^= (uint8_t)(MessageSize);
    1c4a:	80 91 32 01 	lds	r24, 0x0132
    1c4e:	68 27       	eor	r22, r24
	CheckSumByte ^= TOKEN;
    1c50:	8e e0       	ldi	r24, 0x0E	; 14
    1c52:	68 27       	eor	r22, r24
	
	for(uint16_t CByteIndex = 0; CByteIndex < MessageSize; CByteIndex++)
    1c54:	40 e0       	ldi	r20, 0x00	; 0
    1c56:	50 e0       	ldi	r21, 0x00	; 0
    1c58:	42 17       	cp	r20, r18
    1c5a:	53 07       	cpc	r21, r19
    1c5c:	48 f4       	brcc	.+18     	; 0x1c70 <V2P_GetChecksum+0x3c>
    1c5e:	e6 e3       	ldi	r30, 0x36	; 54
    1c60:	f1 e0       	ldi	r31, 0x01	; 1
		CheckSumByte ^= PacketBytes[CByteIndex];
    1c62:	81 91       	ld	r24, Z+
    1c64:	68 27       	eor	r22, r24
    1c66:	4f 5f       	subi	r20, 0xFF	; 255
    1c68:	5f 4f       	sbci	r21, 0xFF	; 255
    1c6a:	42 17       	cp	r20, r18
    1c6c:	53 07       	cpc	r21, r19
    1c6e:	c8 f3       	brcs	.-14     	; 0x1c62 <V2P_GetChecksum+0x2e>

	return CheckSumByte;
}
    1c70:	86 2f       	mov	r24, r22
    1c72:	99 27       	eor	r25, r25
    1c74:	08 95       	ret

00001c76 <V2P_SendPacket>:
    1c76:	0f 93       	push	r16
    1c78:	1f 93       	push	r17
    1c7a:	cf 93       	push	r28
    1c7c:	df 93       	push	r29
    1c7e:	8b e1       	ldi	r24, 0x1B	; 27
    1c80:	0e 94 ec 08 	call	0x11d8 <USART_Tx>
    1c84:	80 91 34 01 	lds	r24, 0x0134
    1c88:	0e 94 ec 08 	call	0x11d8 <USART_Tx>
    1c8c:	80 91 33 01 	lds	r24, 0x0133
    1c90:	0e 94 ec 08 	call	0x11d8 <USART_Tx>
    1c94:	80 91 32 01 	lds	r24, 0x0132
    1c98:	0e 94 ec 08 	call	0x11d8 <USART_Tx>
    1c9c:	8e e0       	ldi	r24, 0x0E	; 14
    1c9e:	0e 94 ec 08 	call	0x11d8 <USART_Tx>
    1ca2:	c0 e0       	ldi	r28, 0x00	; 0
    1ca4:	d0 e0       	ldi	r29, 0x00	; 0
    1ca6:	80 91 32 01 	lds	r24, 0x0132
    1caa:	90 91 33 01 	lds	r25, 0x0133
    1cae:	c8 17       	cp	r28, r24
    1cb0:	d9 07       	cpc	r29, r25
    1cb2:	78 f4       	brcc	.+30     	; 0x1cd2 <V2P_SendPacket+0x5c>
    1cb4:	06 e3       	ldi	r16, 0x36	; 54
    1cb6:	11 e0       	ldi	r17, 0x01	; 1
    1cb8:	f8 01       	movw	r30, r16
    1cba:	81 91       	ld	r24, Z+
    1cbc:	8f 01       	movw	r16, r30
    1cbe:	0e 94 ec 08 	call	0x11d8 <USART_Tx>
    1cc2:	21 96       	adiw	r28, 0x01	; 1
    1cc4:	80 91 32 01 	lds	r24, 0x0132
    1cc8:	90 91 33 01 	lds	r25, 0x0133
    1ccc:	c8 17       	cp	r28, r24
    1cce:	d9 07       	cpc	r29, r25
    1cd0:	98 f3       	brcs	.-26     	; 0x1cb8 <V2P_SendPacket+0x42>
    1cd2:	0e 94 1a 0e 	call	0x1c34 <V2P_GetChecksum>
    1cd6:	0e 94 ec 08 	call	0x11d8 <USART_Tx>
    1cda:	80 91 34 01 	lds	r24, 0x0134
    1cde:	90 91 35 01 	lds	r25, 0x0135
    1ce2:	01 96       	adiw	r24, 0x01	; 1
    1ce4:	90 93 35 01 	sts	0x0135, r25
    1ce8:	80 93 34 01 	sts	0x0134, r24
    1cec:	df 91       	pop	r29
    1cee:	cf 91       	pop	r28
    1cf0:	1f 91       	pop	r17
    1cf2:	0f 91       	pop	r16
    1cf4:	08 95       	ret

00001cf6 <V2P_GetSetParamater>:

void V2P_GetSetParamater(void)
{
	uint8_t Param_Name = PacketBytes[1];    // Save the parameter number
    1cf6:	20 91 37 01 	lds	r18, 0x0137

	MessageSize = 3;                        // Set the default response message size to 3 bytes     
    1cfa:	83 e0       	ldi	r24, 0x03	; 3
    1cfc:	90 e0       	ldi	r25, 0x00	; 0
    1cfe:	90 93 33 01 	sts	0x0133, r25
    1d02:	80 93 32 01 	sts	0x0132, r24
	PacketBytes[1] = STATUS_CMD_OK;         // Set the default response to OK
    1d06:	10 92 37 01 	sts	0x0137, r1

	switch (Param_Name)                    // Switch based on the recieved parameter byte
    1d0a:	e2 2f       	mov	r30, r18
    1d0c:	ff 27       	eor	r31, r31
    1d0e:	e8 39       	cpi	r30, 0x98	; 152
    1d10:	f1 05       	cpc	r31, r1
    1d12:	ac f4       	brge	.+42     	; 0x1d3e <V2P_GetSetParamater+0x48>
    1d14:	e6 39       	cpi	r30, 0x96	; 150
    1d16:	f1 05       	cpc	r31, r1
    1d18:	0c f0       	brlt	.+2      	; 0x1d1c <V2P_GetSetParamater+0x26>
    1d1a:	6d c0       	rjmp	.+218    	; 0x1df6 <V2P_GetSetParamater+0x100>
    1d1c:	e1 38       	cpi	r30, 0x81	; 129
    1d1e:	f1 05       	cpc	r31, r1
    1d20:	f9 f0       	breq	.+62     	; 0x1d60 <V2P_GetSetParamater+0x6a>
    1d22:	e2 38       	cpi	r30, 0x82	; 130
    1d24:	f1 05       	cpc	r31, r1
    1d26:	24 f4       	brge	.+8      	; 0x1d30 <V2P_GetSetParamater+0x3a>
    1d28:	e0 38       	cpi	r30, 0x80	; 128
    1d2a:	f1 05       	cpc	r31, r1
    1d2c:	b9 f0       	breq	.+46     	; 0x1d5c <V2P_GetSetParamater+0x66>
    1d2e:	71 c0       	rjmp	.+226    	; 0x1e12 <V2P_GetSetParamater+0x11c>
    1d30:	cf 01       	movw	r24, r30
    1d32:	80 59       	subi	r24, 0x90	; 144
    1d34:	90 40       	sbci	r25, 0x00	; 0
    1d36:	03 97       	sbiw	r24, 0x03	; 3
    1d38:	08 f0       	brcs	.+2      	; 0x1d3c <V2P_GetSetParamater+0x46>
    1d3a:	6b c0       	rjmp	.+214    	; 0x1e12 <V2P_GetSetParamater+0x11c>
    1d3c:	13 c0       	rjmp	.+38     	; 0x1d64 <V2P_GetSetParamater+0x6e>
    1d3e:	ee 39       	cpi	r30, 0x9E	; 158
    1d40:	f1 05       	cpc	r31, r1
    1d42:	09 f4       	brne	.+2      	; 0x1d46 <V2P_GetSetParamater+0x50>
    1d44:	3d c0       	rjmp	.+122    	; 0x1dc0 <V2P_GetSetParamater+0xca>
    1d46:	ef 39       	cpi	r30, 0x9F	; 159
    1d48:	f1 05       	cpc	r31, r1
    1d4a:	24 f4       	brge	.+8      	; 0x1d54 <V2P_GetSetParamater+0x5e>
    1d4c:	e8 39       	cpi	r30, 0x98	; 152
    1d4e:	f1 05       	cpc	r31, r1
    1d50:	f9 f0       	breq	.+62     	; 0x1d90 <V2P_GetSetParamater+0x9a>
    1d52:	5f c0       	rjmp	.+190    	; 0x1e12 <V2P_GetSetParamater+0x11c>
    1d54:	ef 39       	cpi	r30, 0x9F	; 159
    1d56:	f1 05       	cpc	r31, r1
    1d58:	49 f0       	breq	.+18     	; 0x1d6c <V2P_GetSetParamater+0x76>
    1d5a:	5b c0       	rjmp	.+182    	; 0x1e12 <V2P_GetSetParamater+0x11c>
	{
		case PARAM_BUILD_NUMBER_LOW:
			PacketBytes[2] = VERSION_MINOR;
    1d5c:	82 e0       	ldi	r24, 0x02	; 2
    1d5e:	38 c0       	rjmp	.+112    	; 0x1dd0 <V2P_GetSetParamater+0xda>

			break;
		case PARAM_BUILD_NUMBER_HIGH:
			PacketBytes[2] = VERSION_MAJOR;
    1d60:	81 e0       	ldi	r24, 0x01	; 1
    1d62:	36 c0       	rjmp	.+108    	; 0x1dd0 <V2P_GetSetParamater+0xda>

			break;
		case PARAM_HARDWARE_VERSION:
		case PARAM_SW_MAJOR:
		case PARAM_SW_MINOR:
			PacketBytes[2] = pgm_read_byte(&VersionData[Param_Name - PARAM_HARDWARE_VERSION]);
    1d64:	ea 5b       	subi	r30, 0xBA	; 186
    1d66:	fc 4f       	sbci	r31, 0xFC	; 252
    1d68:	84 91       	lpm	r24, Z
    1d6a:	32 c0       	rjmp	.+100    	; 0x1dd0 <V2P_GetSetParamater+0xda>

			break;
		case PARAM_CONTROLLER_INIT:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1d6c:	80 91 36 01 	lds	r24, 0x0136
    1d70:	83 30       	cpi	r24, 0x03	; 3
    1d72:	19 f4       	brne	.+6      	; 0x1d7a <V2P_GetSetParamater+0x84>
			{
				PacketBytes[2] = Param_ControllerInit;
    1d74:	80 91 2c 01 	lds	r24, 0x012C
    1d78:	2b c0       	rjmp	.+86     	; 0x1dd0 <V2P_GetSetParamater+0xda>
			}
			else
			{
				MessageSize = 2;
    1d7a:	82 e0       	ldi	r24, 0x02	; 2
    1d7c:	90 e0       	ldi	r25, 0x00	; 0
    1d7e:	90 93 33 01 	sts	0x0133, r25
    1d82:	80 93 32 01 	sts	0x0132, r24
				Param_ControllerInit = PacketBytes[2];
    1d86:	80 91 38 01 	lds	r24, 0x0138
    1d8a:	80 93 2c 01 	sts	0x012C, r24
			}
			
			break;
    1d8e:	4a c0       	rjmp	.+148    	; 0x1e24 <V2P_GetSetParamater+0x12e>
		case PARAM_SCK_DURATION:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1d90:	80 91 36 01 	lds	r24, 0x0136
    1d94:	83 30       	cpi	r24, 0x03	; 3
    1d96:	19 f4       	brne	.+6      	; 0x1d9e <V2P_GetSetParamater+0xa8>
			{
				PacketBytes[2] = eeprom_read_byte_169(&Param_SCKDuration);
    1d98:	80 e2       	ldi	r24, 0x20	; 32
    1d9a:	91 e0       	ldi	r25, 0x01	; 1
    1d9c:	17 c0       	rjmp	.+46     	; 0x1dcc <V2P_GetSetParamater+0xd6>
			}
			else
			{
				MessageSize = 2;
    1d9e:	82 e0       	ldi	r24, 0x02	; 2
    1da0:	90 e0       	ldi	r25, 0x00	; 0
    1da2:	90 93 33 01 	sts	0x0133, r25
    1da6:	80 93 32 01 	sts	0x0132, r24
				eeprom_write_byte_169(&Param_SCKDuration, PacketBytes[2]);
    1daa:	60 91 38 01 	lds	r22, 0x0138
    1dae:	80 e2       	ldi	r24, 0x20	; 32
    1db0:	91 e0       	ldi	r25, 0x01	; 1
    1db2:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
				USI_SPISetSpeed(PacketBytes[2]); // Re-Initialise the USI system with the new frequency
    1db6:	80 91 38 01 	lds	r24, 0x0138
    1dba:	0e 94 82 09 	call	0x1304 <USI_SPISetSpeed>
			}
					
			break;
    1dbe:	32 c0       	rjmp	.+100    	; 0x1e24 <V2P_GetSetParamater+0x12e>
		case PARAM_RESET_POLARITY:
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1dc0:	80 91 36 01 	lds	r24, 0x0136
    1dc4:	83 30       	cpi	r24, 0x03	; 3
    1dc6:	39 f4       	brne	.+14     	; 0x1dd6 <V2P_GetSetParamater+0xe0>
			{
				PacketBytes[2] = eeprom_read_byte_169(&Param_ResetPolarity);		
    1dc8:	82 e2       	ldi	r24, 0x22	; 34
    1dca:	91 e0       	ldi	r25, 0x01	; 1
    1dcc:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
    1dd0:	80 93 38 01 	sts	0x0138, r24
    1dd4:	27 c0       	rjmp	.+78     	; 0x1e24 <V2P_GetSetParamater+0x12e>
			}
			else
			{
				MessageSize = 2;
    1dd6:	82 e0       	ldi	r24, 0x02	; 2
    1dd8:	90 e0       	ldi	r25, 0x00	; 0
    1dda:	90 93 33 01 	sts	0x0133, r25
    1dde:	80 93 32 01 	sts	0x0132, r24
				eeprom_write_byte_169(&Param_ResetPolarity, PacketBytes[2]);
    1de2:	60 91 38 01 	lds	r22, 0x0138
    1de6:	82 e2       	ldi	r24, 0x22	; 34
    1de8:	91 e0       	ldi	r25, 0x01	; 1
    1dea:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Change takes effect immediatly
    1dee:	81 e0       	ldi	r24, 0x01	; 1
    1df0:	0e 94 15 03 	call	0x62a <MAIN_ResetCSLine>
			}
			
			break;
    1df4:	17 c0       	rjmp	.+46     	; 0x1e24 <V2P_GetSetParamater+0x12e>
		case PARAM_OSC_PSCALE:
		case PARAM_OSC_CMATCH:
			/* Despite not supporting these parameters (STK500 only), the AVR Studio programmer
			   sends them along with the SCK duration. A OK must be returned or the sequence will fail
			   and the SCK duration byte will not be sent.                                             */
		
			if (PacketBytes[0] == CMD_GET_PARAMETER)
    1df6:	80 91 36 01 	lds	r24, 0x0136
    1dfa:	83 30       	cpi	r24, 0x03	; 3
    1dfc:	19 f4       	brne	.+6      	; 0x1e04 <V2P_GetSetParamater+0x10e>
			{
			   PacketBytes[2] = 0;            // If the command is a read, return a 0 for both parameters
    1dfe:	10 92 38 01 	sts	0x0138, r1
    1e02:	10 c0       	rjmp	.+32     	; 0x1e24 <V2P_GetSetParamater+0x12e>
			}
			else
			{
				MessageSize = 2;              // Otherwise just send back an OK if the command is a set		
    1e04:	82 e0       	ldi	r24, 0x02	; 2
    1e06:	90 e0       	ldi	r25, 0x00	; 0
    1e08:	90 93 33 01 	sts	0x0133, r25
    1e0c:	80 93 32 01 	sts	0x0132, r24
			}
			
			break;
    1e10:	09 c0       	rjmp	.+18     	; 0x1e24 <V2P_GetSetParamater+0x12e>
		default:                             // Unrecognised parameter
			MessageSize = 2;
    1e12:	82 e0       	ldi	r24, 0x02	; 2
    1e14:	90 e0       	ldi	r25, 0x00	; 0
    1e16:	90 93 33 01 	sts	0x0133, r25
    1e1a:	80 93 32 01 	sts	0x0132, r24
			PacketBytes[1] = STATUS_CMD_FAILED;			
    1e1e:	80 ec       	ldi	r24, 0xC0	; 192
    1e20:	80 93 37 01 	sts	0x0137, r24
	}
	
	V2P_SendPacket();
    1e24:	0e 94 3b 0e 	call	0x1c76 <V2P_SendPacket>
    1e28:	08 95       	ret

00001e2a <V2P_IncrementCurrAddress>:
}

void V2P_IncrementCurrAddress(void)
{
	// Incrementing a 32-bit unsigned variable takes a lot of code. Because much of the code is
	// not very time critical (much of it is waiting for the hardware), i've chosen to waste
	// a few extra cycles per increment and save a good 60 bytes or so of code space by putting
	// the incrmement inside a function.

	CurrAddress++;
    1e2a:	80 91 2d 01 	lds	r24, 0x012D
    1e2e:	90 91 2e 01 	lds	r25, 0x012E
    1e32:	a0 91 2f 01 	lds	r26, 0x012F
    1e36:	b0 91 30 01 	lds	r27, 0x0130
    1e3a:	01 96       	adiw	r24, 0x01	; 1
    1e3c:	a1 1d       	adc	r26, r1
    1e3e:	b1 1d       	adc	r27, r1
    1e40:	80 93 2d 01 	sts	0x012D, r24
    1e44:	90 93 2e 01 	sts	0x012E, r25
    1e48:	a0 93 2f 01 	sts	0x012F, r26
    1e4c:	b0 93 30 01 	sts	0x0130, r27
    1e50:	08 95       	ret

00001e52 <V2P_CheckForExtendedAddress>:
}

void V2P_CheckForExtendedAddress(void)
{
	if (CurrAddress & (1UL << 31))                     // MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
    1e52:	80 91 2d 01 	lds	r24, 0x012D
    1e56:	90 91 2e 01 	lds	r25, 0x012E
    1e5a:	a0 91 2f 01 	lds	r26, 0x012F
    1e5e:	b0 91 30 01 	lds	r27, 0x0130
    1e62:	b7 ff       	sbrs	r27, 7
    1e64:	1e c0       	rjmp	.+60     	; 0x1ea2 <V2P_CheckForExtendedAddress+0x50>
	{
		USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);   // Load extended address command
    1e66:	8d e4       	ldi	r24, 0x4D	; 77
    1e68:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1e6c:	80 e0       	ldi	r24, 0x00	; 0
    1e6e:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
		USI_SPITransmit((CurrAddress & 0x00FF0000) >> 16); // The 3rd byte of the long holds the extended address
    1e72:	80 91 2f 01 	lds	r24, 0x012F
    1e76:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1e7a:	80 e0       	ldi	r24, 0x00	; 0
    1e7c:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
		
		CurrAddress &= ~(1UL << 31);                   // Clear the flag
    1e80:	80 91 2d 01 	lds	r24, 0x012D
    1e84:	90 91 2e 01 	lds	r25, 0x012E
    1e88:	a0 91 2f 01 	lds	r26, 0x012F
    1e8c:	b0 91 30 01 	lds	r27, 0x0130
    1e90:	bf 77       	andi	r27, 0x7F	; 127
    1e92:	80 93 2d 01 	sts	0x012D, r24
    1e96:	90 93 2e 01 	sts	0x012E, r25
    1e9a:	a0 93 2f 01 	sts	0x012F, r26
    1e9e:	b0 93 30 01 	sts	0x0130, r27
    1ea2:	08 95       	ret

00001ea4 <V2P_RunStateMachine>:
    1ea4:	ef 92       	push	r14
    1ea6:	ff 92       	push	r15
    1ea8:	0f 93       	push	r16
    1eaa:	1f 93       	push	r17
    1eac:	cf 93       	push	r28
    1eae:	c0 e0       	ldi	r28, 0x00	; 0
    1eb0:	ee 24       	eor	r14, r14
    1eb2:	ff 24       	eor	r15, r15
    1eb4:	80 91 c1 00 	lds	r24, 0x00C1
    1eb8:	80 78       	andi	r24, 0x80	; 128
    1eba:	88 61       	ori	r24, 0x18	; 24
    1ebc:	80 93 c1 00 	sts	0x00C1, r24
    1ec0:	0e 94 c6 0b 	call	0x178c <BUFF_InitialiseBuffer>
    1ec4:	0e 94 39 0c 	call	0x1872 <TIMEOUT_SetupTimeoutTimer>
    1ec8:	c0 93 31 01 	sts	0x0131, r28
    1ecc:	81 e0       	ldi	r24, 0x01	; 1
    1ece:	90 e0       	ldi	r25, 0x00	; 0
    1ed0:	90 93 35 01 	sts	0x0135, r25
    1ed4:	80 93 34 01 	sts	0x0134, r24
    1ed8:	10 92 2d 01 	sts	0x012D, r1
    1edc:	10 92 2e 01 	sts	0x012E, r1
    1ee0:	10 92 2f 01 	sts	0x012F, r1
    1ee4:	10 92 30 01 	sts	0x0130, r1
    1ee8:	80 91 2a 01 	lds	r24, 0x012A
    1eec:	81 30       	cpi	r24, 0x01	; 1
    1eee:	11 f4       	brne	.+4      	; 0x1ef4 <V2P_RunStateMachine+0x50>
    1ef0:	c9 e0       	ldi	r28, 0x09	; 9
    1ef2:	05 c0       	rjmp	.+10     	; 0x1efe <V2P_RunStateMachine+0x5a>
    1ef4:	cc 23       	and	r28, r28
    1ef6:	19 f0       	breq	.+6      	; 0x1efe <V2P_RunStateMachine+0x5a>
    1ef8:	83 e0       	ldi	r24, 0x03	; 3
    1efa:	80 93 81 00 	sts	0x0081, r24
    1efe:	8c 2f       	mov	r24, r28
    1f00:	99 27       	eor	r25, r25
    1f02:	84 30       	cpi	r24, 0x04	; 4
    1f04:	91 05       	cpc	r25, r1
    1f06:	09 f4       	brne	.+2      	; 0x1f0a <V2P_RunStateMachine+0x66>
    1f08:	6d c0       	rjmp	.+218    	; 0x1fe4 <V2P_RunStateMachine+0x140>
    1f0a:	85 30       	cpi	r24, 0x05	; 5
    1f0c:	91 05       	cpc	r25, r1
    1f0e:	94 f4       	brge	.+36     	; 0x1f34 <V2P_RunStateMachine+0x90>
    1f10:	81 30       	cpi	r24, 0x01	; 1
    1f12:	91 05       	cpc	r25, r1
    1f14:	09 f4       	brne	.+2      	; 0x1f18 <V2P_RunStateMachine+0x74>
    1f16:	4c c0       	rjmp	.+152    	; 0x1fb0 <V2P_RunStateMachine+0x10c>
    1f18:	82 30       	cpi	r24, 0x02	; 2
    1f1a:	91 05       	cpc	r25, r1
    1f1c:	1c f4       	brge	.+6      	; 0x1f24 <V2P_RunStateMachine+0x80>
    1f1e:	89 2b       	or	r24, r25
    1f20:	b1 f1       	breq	.+108    	; 0x1f8e <V2P_RunStateMachine+0xea>
    1f22:	e2 cf       	rjmp	.-60     	; 0x1ee8 <V2P_RunStateMachine+0x44>
    1f24:	82 30       	cpi	r24, 0x02	; 2
    1f26:	91 05       	cpc	r25, r1
    1f28:	09 f4       	brne	.+2      	; 0x1f2c <V2P_RunStateMachine+0x88>
    1f2a:	48 c0       	rjmp	.+144    	; 0x1fbc <V2P_RunStateMachine+0x118>
    1f2c:	03 97       	sbiw	r24, 0x03	; 3
    1f2e:	09 f4       	brne	.+2      	; 0x1f32 <V2P_RunStateMachine+0x8e>
    1f30:	4e c0       	rjmp	.+156    	; 0x1fce <V2P_RunStateMachine+0x12a>
    1f32:	da cf       	rjmp	.-76     	; 0x1ee8 <V2P_RunStateMachine+0x44>
    1f34:	87 30       	cpi	r24, 0x07	; 7
    1f36:	91 05       	cpc	r25, r1
    1f38:	09 f4       	brne	.+2      	; 0x1f3c <V2P_RunStateMachine+0x98>
    1f3a:	85 c0       	rjmp	.+266    	; 0x2046 <V2P_RunStateMachine+0x1a2>
    1f3c:	88 30       	cpi	r24, 0x08	; 8
    1f3e:	91 05       	cpc	r25, r1
    1f40:	44 f4       	brge	.+16     	; 0x1f52 <V2P_RunStateMachine+0xae>
    1f42:	85 30       	cpi	r24, 0x05	; 5
    1f44:	91 05       	cpc	r25, r1
    1f46:	09 f4       	brne	.+2      	; 0x1f4a <V2P_RunStateMachine+0xa6>
    1f48:	62 c0       	rjmp	.+196    	; 0x200e <V2P_RunStateMachine+0x16a>
    1f4a:	06 97       	sbiw	r24, 0x06	; 6
    1f4c:	09 f4       	brne	.+2      	; 0x1f50 <V2P_RunStateMachine+0xac>
    1f4e:	67 c0       	rjmp	.+206    	; 0x201e <V2P_RunStateMachine+0x17a>
    1f50:	cb cf       	rjmp	.-106    	; 0x1ee8 <V2P_RunStateMachine+0x44>
    1f52:	88 30       	cpi	r24, 0x08	; 8
    1f54:	91 05       	cpc	r25, r1
    1f56:	79 f0       	breq	.+30     	; 0x1f76 <V2P_RunStateMachine+0xd2>
    1f58:	09 97       	sbiw	r24, 0x09	; 9
    1f5a:	31 f6       	brne	.-116    	; 0x1ee8 <V2P_RunStateMachine+0x44>
    1f5c:	82 e0       	ldi	r24, 0x02	; 2
    1f5e:	90 e0       	ldi	r25, 0x00	; 0
    1f60:	90 93 33 01 	sts	0x0133, r25
    1f64:	80 93 32 01 	sts	0x0132, r24
    1f68:	80 ec       	ldi	r24, 0xC0	; 192
    1f6a:	80 93 37 01 	sts	0x0137, r24
    1f6e:	10 92 2a 01 	sts	0x012A, r1
    1f72:	0e 94 3b 0e 	call	0x1c76 <V2P_SendPacket>
    1f76:	0e 94 c6 0b 	call	0x178c <BUFF_InitialiseBuffer>
    1f7a:	10 92 81 00 	sts	0x0081, r1
    1f7e:	10 92 2b 01 	sts	0x012B, r1
    1f82:	10 92 85 00 	sts	0x0085, r1
    1f86:	10 92 84 00 	sts	0x0084, r1
    1f8a:	c0 e0       	ldi	r28, 0x00	; 0
    1f8c:	ad cf       	rjmp	.-166    	; 0x1ee8 <V2P_RunStateMachine+0x44>
    1f8e:	80 91 d1 02 	lds	r24, 0x02D1
    1f92:	81 11       	cpse	r24, r1
    1f94:	c1 e0       	ldi	r28, 0x01	; 1
    1f96:	f2 9b       	sbis	0x1e, 2	; 30
    1f98:	a7 cf       	rjmp	.-178    	; 0x1ee8 <V2P_RunStateMachine+0x44>
    1f9a:	80 91 31 01 	lds	r24, 0x0131
    1f9e:	88 23       	and	r24, r24
    1fa0:	09 f0       	breq	.+2      	; 0x1fa4 <V2P_RunStateMachine+0x100>
    1fa2:	a2 cf       	rjmp	.-188    	; 0x1ee8 <V2P_RunStateMachine+0x44>
    1fa4:	80 91 c1 00 	lds	r24, 0x00C1
    1fa8:	80 78       	andi	r24, 0x80	; 128
    1faa:	80 93 c1 00 	sts	0x00C1, r24
    1fae:	d4 c0       	rjmp	.+424    	; 0x2158 <V2P_RunStateMachine+0x2b4>
    1fb0:	0e 94 03 09 	call	0x1206 <USART_Rx>
    1fb4:	8b 31       	cpi	r24, 0x1B	; 27
    1fb6:	89 f5       	brne	.+98     	; 0x201a <V2P_RunStateMachine+0x176>
    1fb8:	c2 e0       	ldi	r28, 0x02	; 2
    1fba:	96 cf       	rjmp	.-212    	; 0x1ee8 <V2P_RunStateMachine+0x44>
    1fbc:	0e 94 03 09 	call	0x1206 <USART_Rx>
    1fc0:	99 27       	eor	r25, r25
    1fc2:	90 93 35 01 	sts	0x0135, r25
    1fc6:	80 93 34 01 	sts	0x0134, r24
    1fca:	c3 e0       	ldi	r28, 0x03	; 3
    1fcc:	8d cf       	rjmp	.-230    	; 0x1ee8 <V2P_RunStateMachine+0x44>
    1fce:	0e 94 03 09 	call	0x1206 <USART_Rx>
    1fd2:	99 27       	eor	r25, r25
    1fd4:	98 2f       	mov	r25, r24
    1fd6:	88 27       	eor	r24, r24
    1fd8:	90 93 33 01 	sts	0x0133, r25
    1fdc:	80 93 32 01 	sts	0x0132, r24
    1fe0:	c4 e0       	ldi	r28, 0x04	; 4
    1fe2:	82 cf       	rjmp	.-252    	; 0x1ee8 <V2P_RunStateMachine+0x44>
    1fe4:	0e 94 03 09 	call	0x1206 <USART_Rx>
    1fe8:	28 2f       	mov	r18, r24
    1fea:	33 27       	eor	r19, r19
    1fec:	80 91 32 01 	lds	r24, 0x0132
    1ff0:	90 91 33 01 	lds	r25, 0x0133
    1ff4:	82 2b       	or	r24, r18
    1ff6:	93 2b       	or	r25, r19
    1ff8:	90 93 33 01 	sts	0x0133, r25
    1ffc:	80 93 32 01 	sts	0x0132, r24
    2000:	83 51       	subi	r24, 0x13	; 19
    2002:	91 40       	sbci	r25, 0x01	; 1
    2004:	50 f4       	brcc	.+20     	; 0x201a <V2P_RunStateMachine+0x176>
    2006:	c5 e0       	ldi	r28, 0x05	; 5
    2008:	ee 24       	eor	r14, r14
    200a:	ff 24       	eor	r15, r15
    200c:	6d cf       	rjmp	.-294    	; 0x1ee8 <V2P_RunStateMachine+0x44>
    200e:	0e 94 03 09 	call	0x1206 <USART_Rx>
    2012:	8e 30       	cpi	r24, 0x0E	; 14
    2014:	11 f4       	brne	.+4      	; 0x201a <V2P_RunStateMachine+0x176>
    2016:	c6 e0       	ldi	r28, 0x06	; 6
    2018:	67 cf       	rjmp	.-306    	; 0x1ee8 <V2P_RunStateMachine+0x44>
    201a:	c9 e0       	ldi	r28, 0x09	; 9
    201c:	65 cf       	rjmp	.-310    	; 0x1ee8 <V2P_RunStateMachine+0x44>
    201e:	80 91 32 01 	lds	r24, 0x0132
    2022:	90 91 33 01 	lds	r25, 0x0133
    2026:	e8 16       	cp	r14, r24
    2028:	f9 06       	cpc	r15, r25
    202a:	11 f4       	brne	.+4      	; 0x2030 <V2P_RunStateMachine+0x18c>
    202c:	c7 e0       	ldi	r28, 0x07	; 7
    202e:	5c cf       	rjmp	.-328    	; 0x1ee8 <V2P_RunStateMachine+0x44>
    2030:	87 01       	movw	r16, r14
    2032:	0a 5c       	subi	r16, 0xCA	; 202
    2034:	1e 4f       	sbci	r17, 0xFE	; 254
    2036:	08 94       	sec
    2038:	e1 1c       	adc	r14, r1
    203a:	f1 1c       	adc	r15, r1
    203c:	0e 94 03 09 	call	0x1206 <USART_Rx>
    2040:	f8 01       	movw	r30, r16
    2042:	80 83       	st	Z, r24
    2044:	51 cf       	rjmp	.-350    	; 0x1ee8 <V2P_RunStateMachine+0x44>
    2046:	0e 94 1a 0e 	call	0x1c34 <V2P_GetChecksum>
    204a:	18 2f       	mov	r17, r24
    204c:	0e 94 03 09 	call	0x1206 <USART_Rx>
    2050:	18 17       	cp	r17, r24
    2052:	09 f0       	breq	.+2      	; 0x2056 <V2P_RunStateMachine+0x1b2>
    2054:	74 c0       	rjmp	.+232    	; 0x213e <V2P_RunStateMachine+0x29a>
    2056:	80 91 36 01 	lds	r24, 0x0136
    205a:	99 27       	eor	r25, r25
    205c:	84 30       	cpi	r24, 0x04	; 4
    205e:	91 05       	cpc	r25, r1
    2060:	3c f4       	brge	.+14     	; 0x2070 <V2P_RunStateMachine+0x1cc>
    2062:	82 30       	cpi	r24, 0x02	; 2
    2064:	91 05       	cpc	r25, r1
    2066:	0c f0       	brlt	.+2      	; 0x206a <V2P_RunStateMachine+0x1c6>
    2068:	61 c0       	rjmp	.+194    	; 0x212c <V2P_RunStateMachine+0x288>
    206a:	01 97       	sbiw	r24, 0x01	; 1
    206c:	39 f0       	breq	.+14     	; 0x207c <V2P_RunStateMachine+0x1d8>
    206e:	61 c0       	rjmp	.+194    	; 0x2132 <V2P_RunStateMachine+0x28e>
    2070:	86 30       	cpi	r24, 0x06	; 6
    2072:	91 05       	cpc	r25, r1
    2074:	e9 f0       	breq	.+58     	; 0x20b0 <V2P_RunStateMachine+0x20c>
    2076:	07 97       	sbiw	r24, 0x07	; 7
    2078:	99 f0       	breq	.+38     	; 0x20a0 <V2P_RunStateMachine+0x1fc>
    207a:	5b c0       	rjmp	.+182    	; 0x2132 <V2P_RunStateMachine+0x28e>
    207c:	8b e0       	ldi	r24, 0x0B	; 11
    207e:	90 e0       	ldi	r25, 0x00	; 0
    2080:	90 93 33 01 	sts	0x0133, r25
    2084:	80 93 32 01 	sts	0x0132, r24
    2088:	a6 e3       	ldi	r26, 0x36	; 54
    208a:	b1 e0       	ldi	r27, 0x01	; 1
    208c:	eb ec       	ldi	r30, 0xCB	; 203
    208e:	f3 e0       	ldi	r31, 0x03	; 3
    2090:	9a e0       	ldi	r25, 0x0A	; 10
    2092:	84 91       	lpm	r24, Z
    2094:	8d 93       	st	X+, r24
    2096:	91 50       	subi	r25, 0x01	; 1
    2098:	31 96       	adiw	r30, 0x01	; 1
    209a:	97 ff       	sbrs	r25, 7
    209c:	fa cf       	rjmp	.-12     	; 0x2092 <V2P_RunStateMachine+0x1ee>
    209e:	58 c0       	rjmp	.+176    	; 0x2150 <V2P_RunStateMachine+0x2ac>
    20a0:	82 e0       	ldi	r24, 0x02	; 2
    20a2:	90 e0       	ldi	r25, 0x00	; 0
    20a4:	90 93 33 01 	sts	0x0133, r25
    20a8:	80 93 32 01 	sts	0x0132, r24
    20ac:	80 ec       	ldi	r24, 0xC0	; 192
    20ae:	4e c0       	rjmp	.+156    	; 0x214c <V2P_RunStateMachine+0x2a8>
    20b0:	82 e0       	ldi	r24, 0x02	; 2
    20b2:	90 e0       	ldi	r25, 0x00	; 0
    20b4:	90 93 33 01 	sts	0x0133, r25
    20b8:	80 93 32 01 	sts	0x0132, r24
    20bc:	0e 94 29 0f 	call	0x1e52 <V2P_CheckForExtendedAddress>
    20c0:	80 91 37 01 	lds	r24, 0x0137
    20c4:	99 27       	eor	r25, r25
    20c6:	aa 27       	eor	r26, r26
    20c8:	bb 27       	eor	r27, r27
    20ca:	b8 2f       	mov	r27, r24
    20cc:	aa 27       	eor	r26, r26
    20ce:	99 27       	eor	r25, r25
    20d0:	88 27       	eor	r24, r24
    20d2:	20 91 38 01 	lds	r18, 0x0138
    20d6:	33 27       	eor	r19, r19
    20d8:	44 27       	eor	r20, r20
    20da:	55 27       	eor	r21, r21
    20dc:	a9 01       	movw	r20, r18
    20de:	33 27       	eor	r19, r19
    20e0:	22 27       	eor	r18, r18
    20e2:	82 2b       	or	r24, r18
    20e4:	93 2b       	or	r25, r19
    20e6:	a4 2b       	or	r26, r20
    20e8:	b5 2b       	or	r27, r21
    20ea:	20 91 39 01 	lds	r18, 0x0139
    20ee:	33 27       	eor	r19, r19
    20f0:	44 27       	eor	r20, r20
    20f2:	55 27       	eor	r21, r21
    20f4:	54 2f       	mov	r21, r20
    20f6:	43 2f       	mov	r20, r19
    20f8:	32 2f       	mov	r19, r18
    20fa:	22 27       	eor	r18, r18
    20fc:	82 2b       	or	r24, r18
    20fe:	93 2b       	or	r25, r19
    2100:	a4 2b       	or	r26, r20
    2102:	b5 2b       	or	r27, r21
    2104:	20 91 3a 01 	lds	r18, 0x013A
    2108:	33 27       	eor	r19, r19
    210a:	44 27       	eor	r20, r20
    210c:	55 27       	eor	r21, r21
    210e:	82 2b       	or	r24, r18
    2110:	93 2b       	or	r25, r19
    2112:	a4 2b       	or	r26, r20
    2114:	b5 2b       	or	r27, r21
    2116:	80 93 2d 01 	sts	0x012D, r24
    211a:	90 93 2e 01 	sts	0x012E, r25
    211e:	a0 93 2f 01 	sts	0x012F, r26
    2122:	b0 93 30 01 	sts	0x0130, r27
    2126:	10 92 37 01 	sts	0x0137, r1
    212a:	12 c0       	rjmp	.+36     	; 0x2150 <V2P_RunStateMachine+0x2ac>
    212c:	0e 94 7b 0e 	call	0x1cf6 <V2P_GetSetParamater>
    2130:	11 c0       	rjmp	.+34     	; 0x2154 <V2P_RunStateMachine+0x2b0>
    2132:	e0 91 24 01 	lds	r30, 0x0124
    2136:	f0 91 25 01 	lds	r31, 0x0125
    213a:	09 95       	icall
    213c:	0b c0       	rjmp	.+22     	; 0x2154 <V2P_RunStateMachine+0x2b0>
    213e:	82 e0       	ldi	r24, 0x02	; 2
    2140:	90 e0       	ldi	r25, 0x00	; 0
    2142:	90 93 33 01 	sts	0x0133, r25
    2146:	80 93 32 01 	sts	0x0132, r24
    214a:	81 ec       	ldi	r24, 0xC1	; 193
    214c:	80 93 37 01 	sts	0x0137, r24
    2150:	0e 94 3b 0e 	call	0x1c76 <V2P_SendPacket>
    2154:	c8 e0       	ldi	r28, 0x08	; 8
    2156:	c8 ce       	rjmp	.-624    	; 0x1ee8 <V2P_RunStateMachine+0x44>
    2158:	cf 91       	pop	r28
    215a:	1f 91       	pop	r17
    215c:	0f 91       	pop	r16
    215e:	ff 90       	pop	r15
    2160:	ef 90       	pop	r14
    2162:	08 95       	ret

00002164 <ISPCC_EnterChipProgrammingMode>:

// ======================================================================================

void ISPCC_EnterChipProgrammingMode(void)
{
    2164:	0f 93       	push	r16
    2166:	1f 93       	push	r17
    2168:	cf 93       	push	r28
	uint8_t ByteDelay = PacketBytes[5];
    216a:	10 91 3b 01 	lds	r17, 0x013B
	uint8_t Attempts  = PacketBytes[4];
    216e:	c0 91 3a 01 	lds	r28, 0x013A
	uint8_t Response;

	MAIN_Delay1MS(PacketBytes[2]);         // Wait before continuing, amount specified in the packet
    2172:	80 91 38 01 	lds	r24, 0x0138
    2176:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>

	if ((!(Attempts)) || (Attempts > 100)) // Safety - if no attempts or too high a value is specified, a fixed number is chosen
    217a:	8c 2f       	mov	r24, r28
    217c:	81 50       	subi	r24, 0x01	; 1
    217e:	84 36       	cpi	r24, 0x64	; 100
    2180:	08 f0       	brcs	.+2      	; 0x2184 <ISPCC_EnterChipProgrammingMode+0x20>
	   Attempts = 24;
    2182:	c8 e1       	ldi	r28, 0x18	; 24
		
	while (Attempts--)
	{
		USI_SPITransmit(PacketBytes[8]);
		MAIN_Delay1MS(ByteDelay);
		USI_SPITransmit(PacketBytes[9]);
		MAIN_Delay1MS(ByteDelay);
			
		Response = USI_SPITransmit(PacketBytes[10]);
		MAIN_Delay1MS(ByteDelay);

		if(PacketBytes[7] == ISPCC_POLL_MODE_AVR)
		  USI_SPITransmit(PacketBytes[11]);
		else
		  Response = USI_SPITransmit(PacketBytes[11]);
				
		if(!(PacketBytes[7]) || (Response == PacketBytes[6])) // Polling disabled, or returned value matches expected poll value
		{
			MAIN_Delay1MS(ByteDelay);

			InProgrammingMode = TRUE;
			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = STATUS_CMD_OK;
			return;
		}
		
		MAIN_Delay1MS(ByteDelay);
		USI_SPIToggleClock();            // Out of sync, shift in one bit and try again
    2184:	c1 50       	subi	r28, 0x01	; 1
    2186:	cf 3f       	cpi	r28, 0xFF	; 255
    2188:	09 f4       	brne	.+2      	; 0x218c <ISPCC_EnterChipProgrammingMode+0x28>
    218a:	3f c0       	rjmp	.+126    	; 0x220a <ISPCC_EnterChipProgrammingMode+0xa6>
    218c:	80 91 3e 01 	lds	r24, 0x013E
    2190:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    2194:	81 2f       	mov	r24, r17
    2196:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    219a:	80 91 3f 01 	lds	r24, 0x013F
    219e:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    21a2:	81 2f       	mov	r24, r17
    21a4:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    21a8:	80 91 40 01 	lds	r24, 0x0140
    21ac:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    21b0:	08 2f       	mov	r16, r24
    21b2:	81 2f       	mov	r24, r17
    21b4:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    21b8:	80 91 3d 01 	lds	r24, 0x013D
    21bc:	83 30       	cpi	r24, 0x03	; 3
    21be:	29 f4       	brne	.+10     	; 0x21ca <ISPCC_EnterChipProgrammingMode+0x66>
    21c0:	80 91 41 01 	lds	r24, 0x0141
    21c4:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    21c8:	05 c0       	rjmp	.+10     	; 0x21d4 <ISPCC_EnterChipProgrammingMode+0x70>
    21ca:	80 91 41 01 	lds	r24, 0x0141
    21ce:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    21d2:	08 2f       	mov	r16, r24
    21d4:	80 91 3d 01 	lds	r24, 0x013D
    21d8:	88 23       	and	r24, r24
    21da:	21 f0       	breq	.+8      	; 0x21e4 <ISPCC_EnterChipProgrammingMode+0x80>
    21dc:	80 91 3c 01 	lds	r24, 0x013C
    21e0:	08 17       	cp	r16, r24
    21e2:	69 f4       	brne	.+26     	; 0x21fe <ISPCC_EnterChipProgrammingMode+0x9a>
    21e4:	81 2f       	mov	r24, r17
    21e6:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    21ea:	81 e0       	ldi	r24, 0x01	; 1
    21ec:	80 93 31 01 	sts	0x0131, r24
    21f0:	81 b3       	in	r24, 0x11	; 17
    21f2:	8f 7c       	andi	r24, 0xCF	; 207
    21f4:	80 62       	ori	r24, 0x20	; 32
    21f6:	81 bb       	out	0x11, r24	; 17
    21f8:	10 92 37 01 	sts	0x0137, r1
    21fc:	0d c0       	rjmp	.+26     	; 0x2218 <ISPCC_EnterChipProgrammingMode+0xb4>
    21fe:	81 2f       	mov	r24, r17
    2200:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    2204:	0e 94 fe 09 	call	0x13fc <USI_SPIToggleClock>
    2208:	bd cf       	rjmp	.-134    	; 0x2184 <ISPCC_EnterChipProgrammingMode+0x20>
	}

	// If function hasn't returned by now, all the attempts have failed. Show this by
	// resetting the status leds to green (ready) and send a fail message.

	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
    220a:	81 b3       	in	r24, 0x11	; 17
    220c:	8f 7c       	andi	r24, 0xCF	; 207
    220e:	80 61       	ori	r24, 0x10	; 16
    2210:	81 bb       	out	0x11, r24	; 17
	PacketBytes[1] = STATUS_CMD_FAILED;
    2212:	80 ec       	ldi	r24, 0xC0	; 192
    2214:	80 93 37 01 	sts	0x0137, r24
    2218:	cf 91       	pop	r28
    221a:	1f 91       	pop	r17
    221c:	0f 91       	pop	r16
    221e:	08 95       	ret

00002220 <ISPCC_PollForProgComplete>:
}

void ISPCC_ProgramChip(void)
{
	uint16_t PollAddress  = 0;
	uint8_t  ProgMode     = PacketBytes[3];
	uint8_t  WriteCommand = PacketBytes[5];
	uint16_t StartAddress = (uint16_t)CurrAddress;
	uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
	                      | PacketBytes[2];
	uint8_t  PollType;
			
	if (ProgMode & ISPCC_PROG_MODE_PAGE)                 // Page writing mode
	{
		for (uint16_t WriteByte = 0; WriteByte < BytesToWrite; WriteByte++) // Transmit the page bytes
		{
			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) // Flash write mode - word addresses so MSB/LSB masking 
			   USI_SPITransmit(WriteCommand | ((WriteByte & 0x01)? ISPCC_HIGH_BYTE_WRITE : ISPCC_LOW_BYTE_WRITE));
			else                                         // EEPROM write mode - byte addresses so no masking 
			   USI_SPITransmit(WriteCommand);

			USI_SPITransmitWord(CurrAddress & 0xFFFF);    // Only the LSW of the address should be sent
			USI_SPITransmit(PacketBytes[10 + WriteByte]); // Send one of the new bytes to be written

			if (!(PollAddress))
			{
				if ((PacketBytes[8] != PacketBytes[10 + WriteByte]) // Can do polling
				   && ((PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) || ((PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP) && (PacketBytes[9] != PacketBytes[10 + BytesToWrite]))))
				{
					PollAddress = (CurrAddress & 0xFFFF);    // Save the current address
				
					if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
					   PollAddress = ((PollAddress << 1) + (WriteByte & 0x01));
				}
			}

			// Flash addresses are in words; only increment address on odd byte, OR if it's the EEPROM being programmed (byte addresses)
			if ((WriteByte & 0x01) || (PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP))
			   V2P_IncrementCurrAddress();
		}

		PollType = ProgMode;

		if (ProgMode & ISPCC_PROG_MODE_PAGEDONE)         // If this packet is the end of a page, we need to send the program page command
		{
			USI_SPITransmit(PacketBytes[6]);             // Send the write program memory page command
			USI_SPITransmitWord(StartAddress);           // Send the page address word
			USI_SPITransmit(0x00);

			if (!(PollAddress))                          // No polling address
			   PollType = ((ProgMode & ~ISPCC_PAGE_POLLTYPE_MASK) | ISPCC_PAGE_POLLTYPE_WAIT);

			ISPCC_PollForProgComplete(PollType, PollAddress);
		}
	}
	else                                                 // Flash Word writing mode or EEPROM byte writing mode
	{
		for (uint16_t WriteByte = 0; WriteByte < BytesToWrite; WriteByte++)
		{
			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
			   USI_SPITransmit(WriteCommand | ((WriteByte & 0x01)? ISPCC_HIGH_BYTE_WRITE : ISPCC_LOW_BYTE_WRITE));
			else
			   USI_SPITransmit(WriteCommand);					
					
			USI_SPITransmitWord(CurrAddress & 0xFFFF);    // Transmit the current address to the slave AVR
			USI_SPITransmit(PacketBytes[10 + WriteByte]); // Send one of the new bytes to be written

			PollType = ProgMode;

			if ((PacketBytes[8] != PacketBytes[10 + WriteByte]) // Can do polling
			   && ((PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) || ((PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP) && (PacketBytes[9] != PacketBytes[10 + WriteByte]))))
			{
				PollAddress = (CurrAddress & 0xFFFF);     // Save the current address;

				if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)
				   PollAddress = ((PollAddress << 1) + (WriteByte & 0x01));
			}
			else
			{
				PollType = ((ProgMode & ~ISPCC_WORD_POLLTYPE_MASK) | ISPCC_WORD_POLLTYPE_WAIT);
			}					

			// Flash addresses are in words; only increment address on the odd byte, OR if it's the EEPROM being programmed (byte addresses)
			if ((WriteByte & 0x01) || (PacketBytes[0] == CMD_PROGRAM_EEPROM_ISP))
			   V2P_IncrementCurrAddress();

			ISPCC_PollForProgComplete(PollType, PollAddress);
		}
	}
}

void ISPCC_PollForProgComplete(uint8_t PollData, uint16_t PollAddr)
{
    2220:	1f 93       	push	r17
    2222:	cf 93       	push	r28
    2224:	df 93       	push	r29
    2226:	eb 01       	movw	r28, r22
	uint8_t PollType;
	uint8_t ProgCommand;

	if (PollData & ISPCC_PROG_MODE_PAGE)
    2228:	99 27       	eor	r25, r25
    222a:	80 ff       	sbrs	r24, 0
    222c:	08 c0       	rjmp	.+16     	; 0x223e <ISPCC_PollForProgComplete+0x1e>
	   PollType = ((PollData & ISPCC_PAGE_POLLTYPE_MASK) >> ISPCC_PAGE_POLLTYPE_MASKSHIFT);
    222e:	80 77       	andi	r24, 0x70	; 112
    2230:	90 70       	andi	r25, 0x00	; 0
    2232:	34 e0       	ldi	r19, 0x04	; 4
    2234:	95 95       	asr	r25
    2236:	87 95       	ror	r24
    2238:	3a 95       	dec	r19
    223a:	e1 f7       	brne	.-8      	; 0x2234 <ISPCC_PollForProgComplete+0x14>
    223c:	04 c0       	rjmp	.+8      	; 0x2246 <ISPCC_PollForProgComplete+0x26>
	else
	   PollType = ((PollData & ISPCC_WORD_POLLTYPE_MASK) >> ISPCC_WORD_POLLTYPE_MASKSHIFT);	
    223e:	8e 70       	andi	r24, 0x0E	; 14
    2240:	90 70       	andi	r25, 0x00	; 0
    2242:	95 95       	asr	r25
    2244:	87 95       	ror	r24

	switch (PollType & ISPCC_POLLTYPE_MASK)
    2246:	99 27       	eor	r25, r25
    2248:	87 70       	andi	r24, 0x07	; 7
    224a:	90 70       	andi	r25, 0x00	; 0
    224c:	82 30       	cpi	r24, 0x02	; 2
    224e:	91 05       	cpc	r25, r1
    2250:	19 f0       	breq	.+6      	; 0x2258 <ISPCC_PollForProgComplete+0x38>
    2252:	04 97       	sbiw	r24, 0x04	; 4
    2254:	e1 f0       	breq	.+56     	; 0x228e <ISPCC_PollForProgComplete+0x6e>
    2256:	26 c0       	rjmp	.+76     	; 0x22a4 <ISPCC_PollForProgComplete+0x84>
	{
		case ISPCC_POLLTYPE_DATA:
			ProgCommand = PacketBytes[7];
    2258:	10 91 3d 01 	lds	r17, 0x013D
			
			if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP) // Flash uses word addresses
    225c:	80 91 36 01 	lds	r24, 0x0136
    2260:	83 31       	cpi	r24, 0x13	; 19
    2262:	39 f4       	brne	.+14     	; 0x2272 <ISPCC_PollForProgComplete+0x52>
			{
				ProgCommand  |= ((PollAddr & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ);
    2264:	81 2f       	mov	r24, r17
    2266:	99 27       	eor	r25, r25
    2268:	c0 fd       	sbrc	r28, 0
    226a:	88 60       	ori	r24, 0x08	; 8
    226c:	18 2f       	mov	r17, r24
				PollAddr    >>= 1;
    226e:	d6 95       	lsr	r29
    2270:	c7 95       	ror	r28
			}

			do
			{
				USI_SPITransmit(ProgCommand);
    2272:	81 2f       	mov	r24, r17
    2274:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
				USI_SPITransmitWord(PollAddr);
    2278:	ce 01       	movw	r24, r28
    227a:	0e 94 f0 09 	call	0x13e0 <USI_SPITransmitWord>
			}
    227e:	80 e0       	ldi	r24, 0x00	; 0
    2280:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    2284:	90 91 3e 01 	lds	r25, 0x013E
    2288:	89 17       	cp	r24, r25
    228a:	99 f3       	breq	.-26     	; 0x2272 <ISPCC_PollForProgComplete+0x52>
			while (USI_SPITransmit(0x00) == PacketBytes[8]);
						
			break;
    228c:	0f c0       	rjmp	.+30     	; 0x22ac <ISPCC_PollForProgComplete+0x8c>
		case ISPCC_POLLTYPE_READY:
			do
			   USI_SPITransmitWord(0xF000);
    228e:	80 e0       	ldi	r24, 0x00	; 0
    2290:	90 ef       	ldi	r25, 0xF0	; 240
    2292:	0e 94 f0 09 	call	0x13e0 <USI_SPITransmitWord>
    2296:	80 e0       	ldi	r24, 0x00	; 0
    2298:	90 e0       	ldi	r25, 0x00	; 0
    229a:	0e 94 f0 09 	call	0x13e0 <USI_SPITransmitWord>
    229e:	80 fd       	sbrc	r24, 0
    22a0:	f6 cf       	rjmp	.-20     	; 0x228e <ISPCC_PollForProgComplete+0x6e>
			while (USI_SPITransmitWord(0x0000) & ISPCC_POLL_BUSYFLAG);

			break;
    22a2:	04 c0       	rjmp	.+8      	; 0x22ac <ISPCC_PollForProgComplete+0x8c>
		default:                                      // Default is Wait polling
			MAIN_Delay1MS(PacketBytes[4]);	
    22a4:	80 91 3a 01 	lds	r24, 0x013A
    22a8:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    22ac:	df 91       	pop	r29
    22ae:	cf 91       	pop	r28
    22b0:	1f 91       	pop	r17
    22b2:	08 95       	ret

000022b4 <ISPCC_ProgramChip>:
    22b4:	8f 92       	push	r8
    22b6:	9f 92       	push	r9
    22b8:	af 92       	push	r10
    22ba:	bf 92       	push	r11
    22bc:	cf 92       	push	r12
    22be:	df 92       	push	r13
    22c0:	ef 92       	push	r14
    22c2:	ff 92       	push	r15
    22c4:	0f 93       	push	r16
    22c6:	1f 93       	push	r17
    22c8:	cf 93       	push	r28
    22ca:	df 93       	push	r29
    22cc:	00 e0       	ldi	r16, 0x00	; 0
    22ce:	10 e0       	ldi	r17, 0x00	; 0
    22d0:	80 90 39 01 	lds	r8, 0x0139
    22d4:	90 90 3b 01 	lds	r9, 0x013B
    22d8:	a0 90 2d 01 	lds	r10, 0x012D
    22dc:	b0 90 2e 01 	lds	r11, 0x012E
    22e0:	80 91 37 01 	lds	r24, 0x0137
    22e4:	99 27       	eor	r25, r25
    22e6:	d8 2e       	mov	r13, r24
    22e8:	cc 24       	eor	r12, r12
    22ea:	80 91 38 01 	lds	r24, 0x0138
    22ee:	99 27       	eor	r25, r25
    22f0:	c8 2a       	or	r12, r24
    22f2:	d9 2a       	or	r13, r25
    22f4:	80 fe       	sbrs	r8, 0
    22f6:	67 c0       	rjmp	.+206    	; 0x23c6 <ISPCC_ProgramChip+0x112>
    22f8:	78 01       	movw	r14, r16
    22fa:	0c 15       	cp	r16, r12
    22fc:	1d 05       	cpc	r17, r13
    22fe:	08 f0       	brcs	.+2      	; 0x2302 <ISPCC_ProgramChip+0x4e>
    2300:	4b c0       	rjmp	.+150    	; 0x2398 <ISPCC_ProgramChip+0xe4>
    2302:	c6 e3       	ldi	r28, 0x36	; 54
    2304:	d1 e0       	ldi	r29, 0x01	; 1
    2306:	80 91 36 01 	lds	r24, 0x0136
    230a:	83 31       	cpi	r24, 0x13	; 19
    230c:	31 f4       	brne	.+12     	; 0x231a <ISPCC_ProgramChip+0x66>
    230e:	89 2d       	mov	r24, r9
    2310:	99 27       	eor	r25, r25
    2312:	e0 fe       	sbrs	r14, 0
    2314:	03 c0       	rjmp	.+6      	; 0x231c <ISPCC_ProgramChip+0x68>
    2316:	88 60       	ori	r24, 0x08	; 8
    2318:	01 c0       	rjmp	.+2      	; 0x231c <ISPCC_ProgramChip+0x68>
    231a:	89 2d       	mov	r24, r9
    231c:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    2320:	80 91 2d 01 	lds	r24, 0x012D
    2324:	90 91 2e 01 	lds	r25, 0x012E
    2328:	0e 94 f0 09 	call	0x13e0 <USI_SPITransmitWord>
    232c:	8a 85       	ldd	r24, Y+10	; 0x0a
    232e:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    2332:	01 15       	cp	r16, r1
    2334:	11 05       	cpc	r17, r1
    2336:	01 f5       	brne	.+64     	; 0x2378 <ISPCC_ProgramChip+0xc4>
    2338:	90 91 3e 01 	lds	r25, 0x013E
    233c:	8a 85       	ldd	r24, Y+10	; 0x0a
    233e:	98 17       	cp	r25, r24
    2340:	d9 f0       	breq	.+54     	; 0x2378 <ISPCC_ProgramChip+0xc4>
    2342:	20 91 36 01 	lds	r18, 0x0136
    2346:	23 31       	cpi	r18, 0x13	; 19
    2348:	51 f0       	breq	.+20     	; 0x235e <ISPCC_ProgramChip+0xaa>
    234a:	25 31       	cpi	r18, 0x15	; 21
    234c:	a9 f4       	brne	.+42     	; 0x2378 <ISPCC_ProgramChip+0xc4>
    234e:	f6 01       	movw	r30, r12
    2350:	ea 5c       	subi	r30, 0xCA	; 202
    2352:	fe 4f       	sbci	r31, 0xFE	; 254
    2354:	90 91 3f 01 	lds	r25, 0x013F
    2358:	82 85       	ldd	r24, Z+10	; 0x0a
    235a:	98 17       	cp	r25, r24
    235c:	69 f0       	breq	.+26     	; 0x2378 <ISPCC_ProgramChip+0xc4>
    235e:	00 91 2d 01 	lds	r16, 0x012D
    2362:	10 91 2e 01 	lds	r17, 0x012E
    2366:	23 31       	cpi	r18, 0x13	; 19
    2368:	39 f4       	brne	.+14     	; 0x2378 <ISPCC_ProgramChip+0xc4>
    236a:	00 0f       	add	r16, r16
    236c:	11 1f       	adc	r17, r17
    236e:	c7 01       	movw	r24, r14
    2370:	81 70       	andi	r24, 0x01	; 1
    2372:	90 70       	andi	r25, 0x00	; 0
    2374:	08 0f       	add	r16, r24
    2376:	19 1f       	adc	r17, r25
    2378:	e0 fc       	sbrc	r14, 0
    237a:	04 c0       	rjmp	.+8      	; 0x2384 <ISPCC_ProgramChip+0xd0>
    237c:	80 91 36 01 	lds	r24, 0x0136
    2380:	85 31       	cpi	r24, 0x15	; 21
    2382:	11 f4       	brne	.+4      	; 0x2388 <ISPCC_ProgramChip+0xd4>
    2384:	0e 94 15 0f 	call	0x1e2a <V2P_IncrementCurrAddress>
    2388:	08 94       	sec
    238a:	e1 1c       	adc	r14, r1
    238c:	f1 1c       	adc	r15, r1
    238e:	21 96       	adiw	r28, 0x01	; 1
    2390:	ec 14       	cp	r14, r12
    2392:	fd 04       	cpc	r15, r13
    2394:	08 f4       	brcc	.+2      	; 0x2398 <ISPCC_ProgramChip+0xe4>
    2396:	b7 cf       	rjmp	.-146    	; 0x2306 <ISPCC_ProgramChip+0x52>
    2398:	c8 2d       	mov	r28, r8
    239a:	87 fe       	sbrs	r8, 7
    239c:	6c c0       	rjmp	.+216    	; 0x2476 <ISPCC_ProgramChip+0x1c2>
    239e:	80 91 3c 01 	lds	r24, 0x013C
    23a2:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    23a6:	c5 01       	movw	r24, r10
    23a8:	0e 94 f0 09 	call	0x13e0 <USI_SPITransmitWord>
    23ac:	80 e0       	ldi	r24, 0x00	; 0
    23ae:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    23b2:	01 15       	cp	r16, r1
    23b4:	11 05       	cpc	r17, r1
    23b6:	11 f4       	brne	.+4      	; 0x23bc <ISPCC_ProgramChip+0x108>
    23b8:	cf 78       	andi	r28, 0x8F	; 143
    23ba:	c0 61       	ori	r28, 0x10	; 16
    23bc:	b8 01       	movw	r22, r16
    23be:	8c 2f       	mov	r24, r28
    23c0:	0e 94 10 11 	call	0x2220 <ISPCC_PollForProgComplete>
    23c4:	58 c0       	rjmp	.+176    	; 0x2476 <ISPCC_ProgramChip+0x1c2>
    23c6:	78 01       	movw	r14, r16
    23c8:	0c 15       	cp	r16, r12
    23ca:	1d 05       	cpc	r17, r13
    23cc:	08 f0       	brcs	.+2      	; 0x23d0 <ISPCC_ProgramChip+0x11c>
    23ce:	53 c0       	rjmp	.+166    	; 0x2476 <ISPCC_ProgramChip+0x1c2>
    23d0:	56 e3       	ldi	r21, 0x36	; 54
    23d2:	a5 2e       	mov	r10, r21
    23d4:	51 e0       	ldi	r21, 0x01	; 1
    23d6:	b5 2e       	mov	r11, r21
    23d8:	80 91 36 01 	lds	r24, 0x0136
    23dc:	83 31       	cpi	r24, 0x13	; 19
    23de:	31 f4       	brne	.+12     	; 0x23ec <ISPCC_ProgramChip+0x138>
    23e0:	89 2d       	mov	r24, r9
    23e2:	99 27       	eor	r25, r25
    23e4:	e0 fe       	sbrs	r14, 0
    23e6:	03 c0       	rjmp	.+6      	; 0x23ee <ISPCC_ProgramChip+0x13a>
    23e8:	88 60       	ori	r24, 0x08	; 8
    23ea:	01 c0       	rjmp	.+2      	; 0x23ee <ISPCC_ProgramChip+0x13a>
    23ec:	89 2d       	mov	r24, r9
    23ee:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    23f2:	80 91 2d 01 	lds	r24, 0x012D
    23f6:	90 91 2e 01 	lds	r25, 0x012E
    23fa:	0e 94 f0 09 	call	0x13e0 <USI_SPITransmitWord>
    23fe:	f5 01       	movw	r30, r10
    2400:	82 85       	ldd	r24, Z+10	; 0x0a
    2402:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    2406:	c8 2d       	mov	r28, r8
    2408:	80 91 3e 01 	lds	r24, 0x013E
    240c:	f5 01       	movw	r30, r10
    240e:	22 85       	ldd	r18, Z+10	; 0x0a
    2410:	82 17       	cp	r24, r18
    2412:	c1 f0       	breq	.+48     	; 0x2444 <ISPCC_ProgramChip+0x190>
    2414:	90 91 36 01 	lds	r25, 0x0136
    2418:	93 31       	cpi	r25, 0x13	; 19
    241a:	31 f0       	breq	.+12     	; 0x2428 <ISPCC_ProgramChip+0x174>
    241c:	95 31       	cpi	r25, 0x15	; 21
    241e:	91 f4       	brne	.+36     	; 0x2444 <ISPCC_ProgramChip+0x190>
    2420:	80 91 3f 01 	lds	r24, 0x013F
    2424:	82 17       	cp	r24, r18
    2426:	71 f0       	breq	.+28     	; 0x2444 <ISPCC_ProgramChip+0x190>
    2428:	00 91 2d 01 	lds	r16, 0x012D
    242c:	10 91 2e 01 	lds	r17, 0x012E
    2430:	93 31       	cpi	r25, 0x13	; 19
    2432:	59 f4       	brne	.+22     	; 0x244a <ISPCC_ProgramChip+0x196>
    2434:	00 0f       	add	r16, r16
    2436:	11 1f       	adc	r17, r17
    2438:	c7 01       	movw	r24, r14
    243a:	81 70       	andi	r24, 0x01	; 1
    243c:	90 70       	andi	r25, 0x00	; 0
    243e:	08 0f       	add	r16, r24
    2440:	19 1f       	adc	r17, r25
    2442:	03 c0       	rjmp	.+6      	; 0x244a <ISPCC_ProgramChip+0x196>
    2444:	c8 2d       	mov	r28, r8
    2446:	c1 7f       	andi	r28, 0xF1	; 241
    2448:	c2 60       	ori	r28, 0x02	; 2
    244a:	e0 fc       	sbrc	r14, 0
    244c:	04 c0       	rjmp	.+8      	; 0x2456 <ISPCC_ProgramChip+0x1a2>
    244e:	80 91 36 01 	lds	r24, 0x0136
    2452:	85 31       	cpi	r24, 0x15	; 21
    2454:	11 f4       	brne	.+4      	; 0x245a <ISPCC_ProgramChip+0x1a6>
    2456:	0e 94 15 0f 	call	0x1e2a <V2P_IncrementCurrAddress>
    245a:	b8 01       	movw	r22, r16
    245c:	8c 2f       	mov	r24, r28
    245e:	0e 94 10 11 	call	0x2220 <ISPCC_PollForProgComplete>
    2462:	08 94       	sec
    2464:	e1 1c       	adc	r14, r1
    2466:	f1 1c       	adc	r15, r1
    2468:	08 94       	sec
    246a:	a1 1c       	adc	r10, r1
    246c:	b1 1c       	adc	r11, r1
    246e:	ec 14       	cp	r14, r12
    2470:	fd 04       	cpc	r15, r13
    2472:	08 f4       	brcc	.+2      	; 0x2476 <ISPCC_ProgramChip+0x1c2>
    2474:	b1 cf       	rjmp	.-158    	; 0x23d8 <ISPCC_ProgramChip+0x124>
    2476:	df 91       	pop	r29
    2478:	cf 91       	pop	r28
    247a:	1f 91       	pop	r17
    247c:	0f 91       	pop	r16
    247e:	ff 90       	pop	r15
    2480:	ef 90       	pop	r14
    2482:	df 90       	pop	r13
    2484:	cf 90       	pop	r12
    2486:	bf 90       	pop	r11
    2488:	af 90       	pop	r10
    248a:	9f 90       	pop	r9
    248c:	8f 90       	pop	r8
    248e:	08 95       	ret

00002490 <AICI_InterpretPacket>:

// ======================================================================================

void AICI_InterpretPacket(void)
{
    2490:	df 92       	push	r13
    2492:	ef 92       	push	r14
    2494:	ff 92       	push	r15
    2496:	0f 93       	push	r16
    2498:	1f 93       	push	r17
    249a:	cf 93       	push	r28
    249c:	df 93       	push	r29
	switch (PacketBytes[0])
    249e:	80 91 36 01 	lds	r24, 0x0136
    24a2:	99 27       	eor	r25, r25
    24a4:	86 31       	cpi	r24, 0x16	; 22
    24a6:	91 05       	cpc	r25, r1
    24a8:	09 f4       	brne	.+2      	; 0x24ac <AICI_InterpretPacket+0x1c>
    24aa:	fa c0       	rjmp	.+500    	; 0x26a0 <AICI_InterpretPacket+0x210>
    24ac:	87 31       	cpi	r24, 0x17	; 23
    24ae:	91 05       	cpc	r25, r1
    24b0:	94 f4       	brge	.+36     	; 0x24d6 <AICI_InterpretPacket+0x46>
    24b2:	82 31       	cpi	r24, 0x12	; 18
    24b4:	91 05       	cpc	r25, r1
    24b6:	09 f4       	brne	.+2      	; 0x24ba <AICI_InterpretPacket+0x2a>
    24b8:	5f c0       	rjmp	.+190    	; 0x2578 <AICI_InterpretPacket+0xe8>
    24ba:	83 31       	cpi	r24, 0x13	; 19
    24bc:	91 05       	cpc	r25, r1
    24be:	3c f4       	brge	.+14     	; 0x24ce <AICI_InterpretPacket+0x3e>
    24c0:	80 31       	cpi	r24, 0x10	; 16
    24c2:	91 05       	cpc	r25, r1
    24c4:	f9 f0       	breq	.+62     	; 0x2504 <AICI_InterpretPacket+0x74>
    24c6:	41 97       	sbiw	r24, 0x11	; 17
    24c8:	09 f4       	brne	.+2      	; 0x24cc <AICI_InterpretPacket+0x3c>
    24ca:	3c c0       	rjmp	.+120    	; 0x2544 <AICI_InterpretPacket+0xb4>
    24cc:	3d c1       	rjmp	.+634    	; 0x2748 <AICI_InterpretPacket+0x2b8>
    24ce:	44 97       	sbiw	r24, 0x14	; 20
    24d0:	09 f4       	brne	.+2      	; 0x24d4 <AICI_InterpretPacket+0x44>
    24d2:	e6 c0       	rjmp	.+460    	; 0x26a0 <AICI_InterpretPacket+0x210>
    24d4:	2e c1       	rjmp	.+604    	; 0x2732 <AICI_InterpretPacket+0x2a2>
    24d6:	89 31       	cpi	r24, 0x19	; 25
    24d8:	91 05       	cpc	r25, r1
    24da:	09 f4       	brne	.+2      	; 0x24de <AICI_InterpretPacket+0x4e>
    24dc:	cb c0       	rjmp	.+406    	; 0x2674 <AICI_InterpretPacket+0x1e4>
    24de:	8a 31       	cpi	r24, 0x1A	; 26
    24e0:	91 05       	cpc	r25, r1
    24e2:	44 f4       	brge	.+16     	; 0x24f4 <AICI_InterpretPacket+0x64>
    24e4:	87 31       	cpi	r24, 0x17	; 23
    24e6:	91 05       	cpc	r25, r1
    24e8:	09 f4       	brne	.+2      	; 0x24ec <AICI_InterpretPacket+0x5c>
    24ea:	c4 c0       	rjmp	.+392    	; 0x2674 <AICI_InterpretPacket+0x1e4>
    24ec:	48 97       	sbiw	r24, 0x18	; 24
    24ee:	09 f4       	brne	.+2      	; 0x24f2 <AICI_InterpretPacket+0x62>
    24f0:	a4 c0       	rjmp	.+328    	; 0x263a <AICI_InterpretPacket+0x1aa>
    24f2:	2a c1       	rjmp	.+596    	; 0x2748 <AICI_InterpretPacket+0x2b8>
    24f4:	8d 31       	cpi	r24, 0x1D	; 29
    24f6:	91 05       	cpc	r25, r1
    24f8:	0c f4       	brge	.+2      	; 0x24fc <AICI_InterpretPacket+0x6c>
    24fa:	9f c0       	rjmp	.+318    	; 0x263a <AICI_InterpretPacket+0x1aa>
    24fc:	4d 97       	sbiw	r24, 0x1d	; 29
    24fe:	09 f4       	brne	.+2      	; 0x2502 <AICI_InterpretPacket+0x72>
    2500:	60 c0       	rjmp	.+192    	; 0x25c2 <AICI_InterpretPacket+0x132>
    2502:	22 c1       	rjmp	.+580    	; 0x2748 <AICI_InterpretPacket+0x2b8>
	{
		case CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
    2504:	82 e0       	ldi	r24, 0x02	; 2
    2506:	90 e0       	ldi	r25, 0x00	; 0
    2508:	90 93 33 01 	sts	0x0133, r25
    250c:	80 93 32 01 	sts	0x0132, r24
			
			USI_SPIInitMaster(eeprom_read_byte_169(&Param_SCKDuration));
    2510:	80 e2       	ldi	r24, 0x20	; 32
    2512:	91 e0       	ldi	r25, 0x01	; 1
    2514:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
    2518:	0e 94 a3 09 	call	0x1346 <USI_SPIInitMaster>

			MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);  // Pull the slave AVR's RESET line to active
    251c:	80 e0       	ldi	r24, 0x00	; 0
    251e:	0e 94 15 03 	call	0x62a <MAIN_ResetCSLine>
			MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE); // Orange = Busy
    2522:	81 b3       	in	r24, 0x11	; 17
    2524:	80 63       	ori	r24, 0x30	; 48
    2526:	81 bb       	out	0x11, r24	; 17
			ISPCC_EnterChipProgrammingMode();       // Run the Enter Programming Mode routine
    2528:	0e 94 b2 10 	call	0x2164 <ISPCC_EnterChipProgrammingMode>

			if (InProgrammingMode)
    252c:	80 91 31 01 	lds	r24, 0x0131
    2530:	88 23       	and	r24, r24
    2532:	19 f0       	breq	.+6      	; 0x253a <AICI_InterpretPacket+0xaa>
			   LCD_puts_f(AVRISPModeMessage);
    2534:	84 ee       	ldi	r24, 0xE4	; 228
    2536:	93 e0       	ldi	r25, 0x03	; 3
    2538:	02 c0       	rjmp	.+4      	; 0x253e <AICI_InterpretPacket+0xae>
			else
			   LCD_puts_f(SyncErrorMessage);
    253a:	89 ed       	ldi	r24, 0xD9	; 217
    253c:	93 e0       	ldi	r25, 0x03	; 3
    253e:	0e 94 fc 07 	call	0xff8 <LCD_puts_f>
			
			break;
    2542:	0b c1       	rjmp	.+534    	; 0x275a <AICI_InterpretPacket+0x2ca>
		case CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;
    2544:	82 e0       	ldi	r24, 0x02	; 2
    2546:	90 e0       	ldi	r25, 0x00	; 0
    2548:	90 93 33 01 	sts	0x0133, r25
    254c:	80 93 32 01 	sts	0x0132, r24

			MAIN_Delay1MS(PacketBytes[1]);           // Wait for the "PreDelay" amount specified in the packet
    2550:	80 91 37 01 	lds	r24, 0x0137
    2554:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Non programming mode = green status led
    2558:	81 b3       	in	r24, 0x11	; 17
    255a:	8f 7c       	andi	r24, 0xCF	; 207
    255c:	80 61       	ori	r24, 0x10	; 16
    255e:	81 bb       	out	0x11, r24	; 17
			InProgrammingMode = FALSE;
    2560:	10 92 31 01 	sts	0x0131, r1
			MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run
    2564:	81 e0       	ldi	r24, 0x01	; 1
    2566:	0e 94 15 03 	call	0x62a <MAIN_ResetCSLine>
			MAIN_Delay1MS(PacketBytes[2]);           // Wait for the "PostDelay" amount specified in the packet
    256a:	80 91 38 01 	lds	r24, 0x0138
    256e:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
			
			USI_SPIOff();
    2572:	0e 94 bb 09 	call	0x1376 <USI_SPIOff>
    2576:	e5 c0       	rjmp	.+458    	; 0x2742 <AICI_InterpretPacket+0x2b2>

			PacketBytes[1] = STATUS_CMD_OK;      // Return OK

			break;
		case CMD_CHIP_ERASE_ISP:
			MessageSize = 2;
    2578:	82 e0       	ldi	r24, 0x02	; 2
    257a:	90 e0       	ldi	r25, 0x00	; 0
    257c:	90 93 33 01 	sts	0x0133, r25
    2580:	80 93 32 01 	sts	0x0132, r24
			
			for (uint8_t PacketB = 3; PacketB <= 6; PacketB++) // Send the erase commands to the slave AVR
    2584:	c3 e0       	ldi	r28, 0x03	; 3
    2586:	09 e3       	ldi	r16, 0x39	; 57
    2588:	11 e0       	ldi	r17, 0x01	; 1
				USI_SPITransmit(PacketBytes[PacketB]);
    258a:	f8 01       	movw	r30, r16
    258c:	81 91       	ld	r24, Z+
    258e:	8f 01       	movw	r16, r30
    2590:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    2594:	c1 50       	subi	r28, 0x01	; 1
    2596:	c7 ff       	sbrs	r28, 7
    2598:	f8 cf       	rjmp	.-16     	; 0x258a <AICI_InterpretPacket+0xfa>

			if (PacketBytes[2])                  // Poll mode, value of 1 indicates a busy flag wait
    259a:	80 91 38 01 	lds	r24, 0x0138
    259e:	88 23       	and	r24, r24
    25a0:	59 f0       	breq	.+22     	; 0x25b8 <AICI_InterpretPacket+0x128>
			{
				do
					USI_SPITransmitWord(0xF000);
    25a2:	80 e0       	ldi	r24, 0x00	; 0
    25a4:	90 ef       	ldi	r25, 0xF0	; 240
    25a6:	0e 94 f0 09 	call	0x13e0 <USI_SPITransmitWord>
    25aa:	80 e0       	ldi	r24, 0x00	; 0
    25ac:	90 e0       	ldi	r25, 0x00	; 0
    25ae:	0e 94 f0 09 	call	0x13e0 <USI_SPITransmitWord>
    25b2:	80 fd       	sbrc	r24, 0
    25b4:	f6 cf       	rjmp	.-20     	; 0x25a2 <AICI_InterpretPacket+0x112>
    25b6:	c5 c0       	rjmp	.+394    	; 0x2742 <AICI_InterpretPacket+0x2b2>
				while (USI_SPITransmitWord(0x0000) & 0x01);
			}
			else                                // Poll mode flag of 0 indicates a predefined delay
			{
				MAIN_Delay1MS(PacketBytes[1]);   // Wait the specified interval to ensure erase complete
    25b8:	80 91 37 01 	lds	r24, 0x0137
    25bc:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    25c0:	c0 c0       	rjmp	.+384    	; 0x2742 <AICI_InterpretPacket+0x2b2>
			}
			
			PacketBytes[1] = STATUS_CMD_OK;      // Always return OK
			
			break;
		case CMD_SPI_MULTI:
				MessageSize = (3 + PacketBytes[2]);    // Number of recieved bytes, plus two OKs and the command byte
    25c2:	e0 90 38 01 	lds	r14, 0x0138
    25c6:	8e 2d       	mov	r24, r14
    25c8:	99 27       	eor	r25, r25
    25ca:	03 96       	adiw	r24, 0x03	; 3
    25cc:	90 93 33 01 	sts	0x0133, r25
    25d0:	80 93 32 01 	sts	0x0132, r24
		
				uint8_t TxBytes      = PacketBytes[1]; // \. The packet data is overwritten during the transfer. Because
    25d4:	00 91 37 01 	lds	r16, 0x0137
				uint8_t RxStartByte  = PacketBytes[2]; // |  of this each data byte must be stored into temp variables
				uint8_t RxBytes      = PacketBytes[3]; // /  so that their contents are not lost.
    25d8:	f0 90 39 01 	lds	r15, 0x0139
				uint8_t RxByteNum    = 1;
    25dc:	c1 e0       	ldi	r28, 0x01	; 1
				uint8_t TxByteNum    = 1;
				uint8_t RecievedByte = 0;

				while (TxByteNum++ < TxBytes)          // Still bytes to transfer
				{
					RecievedByte = USI_SPITransmit(PacketBytes[3 + TxByteNum]); // Transmit the byte, store the answer

					if ((TxByteNum >= RxStartByte) && (RxByteNum < RxBytes))
					   PacketBytes[2 + RxByteNum++] = RecievedByte;
    25de:	12 e0       	ldi	r17, 0x02	; 2
    25e0:	c0 17       	cp	r28, r16
    25e2:	a8 f4       	brcc	.+42     	; 0x260e <AICI_InterpretPacket+0x17e>
    25e4:	e1 2f       	mov	r30, r17
    25e6:	ff 27       	eor	r31, r31
    25e8:	ea 5c       	subi	r30, 0xCA	; 202
    25ea:	fe 4f       	sbci	r31, 0xFE	; 254
    25ec:	83 81       	ldd	r24, Z+3	; 0x03
    25ee:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    25f2:	1e 15       	cp	r17, r14
    25f4:	40 f0       	brcs	.+16     	; 0x2606 <AICI_InterpretPacket+0x176>
    25f6:	cf 15       	cp	r28, r15
    25f8:	30 f4       	brcc	.+12     	; 0x2606 <AICI_InterpretPacket+0x176>
    25fa:	ec 2f       	mov	r30, r28
    25fc:	ff 27       	eor	r31, r31
    25fe:	ea 5c       	subi	r30, 0xCA	; 202
    2600:	fe 4f       	sbci	r31, 0xFE	; 254
    2602:	82 83       	std	Z+2, r24	; 0x02
    2604:	cf 5f       	subi	r28, 0xFF	; 255
    2606:	81 2f       	mov	r24, r17
    2608:	1f 5f       	subi	r17, 0xFF	; 255
    260a:	80 17       	cp	r24, r16
    260c:	58 f3       	brcs	.-42     	; 0x25e4 <AICI_InterpretPacket+0x154>
				}

				while (RxByteNum++ < RxBytes)                         // Still more bytes to recieve
				   PacketBytes[2 + RxByteNum] = USI_SPITransmit(0x00); // its answer to be recorded (or more bytes than sent need responses), send dummy bytes to fetch the response(s)
    260e:	8c 2f       	mov	r24, r28
    2610:	cf 5f       	subi	r28, 0xFF	; 255
    2612:	8f 15       	cp	r24, r15
    2614:	50 f4       	brcc	.+20     	; 0x262a <AICI_InterpretPacket+0x19a>
    2616:	0c 2f       	mov	r16, r28
    2618:	11 27       	eor	r17, r17
    261a:	0a 5c       	subi	r16, 0xCA	; 202
    261c:	1e 4f       	sbci	r17, 0xFE	; 254
    261e:	80 e0       	ldi	r24, 0x00	; 0
    2620:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    2624:	f8 01       	movw	r30, r16
    2626:	82 83       	std	Z+2, r24	; 0x02
    2628:	f2 cf       	rjmp	.-28     	; 0x260e <AICI_InterpretPacket+0x17e>

				PacketBytes[1]             = STATUS_CMD_OK; // Data should be encompassed
    262a:	10 92 37 01 	sts	0x0137, r1
				PacketBytes[3 + RxByteNum] = STATUS_CMD_OK; //  by STATS_CMD_OKs
    262e:	ec 2f       	mov	r30, r28
    2630:	ff 27       	eor	r31, r31
    2632:	ea 5c       	subi	r30, 0xCA	; 202
    2634:	fe 4f       	sbci	r31, 0xFE	; 254
    2636:	13 82       	std	Z+3, r1	; 0x03

				break;
    2638:	90 c0       	rjmp	.+288    	; 0x275a <AICI_InterpretPacket+0x2ca>
		case CMD_READ_SIGNATURE_ISP:
		case CMD_READ_FUSE_ISP:
		case CMD_READ_LOCK_ISP:
		case CMD_READ_OSCCAL_ISP:
			MessageSize = 4;
    263a:	84 e0       	ldi	r24, 0x04	; 4
    263c:	90 e0       	ldi	r25, 0x00	; 0
    263e:	90 93 33 01 	sts	0x0133, r25
    2642:	80 93 32 01 	sts	0x0132, r24
	
			for(uint8_t ByteNum = 1; ByteNum <= 4; ByteNum++)
    2646:	c1 e0       	ldi	r28, 0x01	; 1
    2648:	08 e3       	ldi	r16, 0x38	; 56
    264a:	11 e0       	ldi	r17, 0x01	; 1
			{
				uint8_t Response = USI_SPITransmit(PacketBytes[1 + ByteNum]); // Transmit the four signature request bytes
    264c:	f8 01       	movw	r30, r16
    264e:	81 91       	ld	r24, Z+
    2650:	8f 01       	movw	r16, r30
    2652:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    2656:	98 2f       	mov	r25, r24

				if (ByteNum == PacketBytes[1])         // If the current byte is the requested signature byte, save the reponse in the packet
    2658:	80 91 37 01 	lds	r24, 0x0137
    265c:	c8 17       	cp	r28, r24
    265e:	11 f4       	brne	.+4      	; 0x2664 <AICI_InterpretPacket+0x1d4>
					PacketBytes[2] = Response;
    2660:	90 93 38 01 	sts	0x0138, r25
    2664:	cf 5f       	subi	r28, 0xFF	; 255
    2666:	c5 30       	cpi	r28, 0x05	; 5
    2668:	88 f3       	brcs	.-30     	; 0x264c <AICI_InterpretPacket+0x1bc>
			}

			PacketBytes[1] = STATUS_CMD_OK;            // Data byte is encased in CMD_OKs
    266a:	10 92 37 01 	sts	0x0137, r1
			PacketBytes[3] = STATUS_CMD_OK;            // Data byte is encased in CMD_OKs
    266e:	10 92 39 01 	sts	0x0139, r1

			break;
    2672:	73 c0       	rjmp	.+230    	; 0x275a <AICI_InterpretPacket+0x2ca>
		case CMD_PROGRAM_FUSE_ISP:
		case CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;
    2674:	83 e0       	ldi	r24, 0x03	; 3
    2676:	90 e0       	ldi	r25, 0x00	; 0
    2678:	90 93 33 01 	sts	0x0133, r25
    267c:	80 93 32 01 	sts	0x0132, r24
    2680:	07 e3       	ldi	r16, 0x37	; 55
    2682:	11 e0       	ldi	r17, 0x01	; 1
    2684:	c3 e0       	ldi	r28, 0x03	; 3
			
			for (uint8_t PacketB = 1; PacketB <= 4; PacketB++) // Send the lock-byte values to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    2686:	f8 01       	movw	r30, r16
    2688:	81 91       	ld	r24, Z+
    268a:	8f 01       	movw	r16, r30
    268c:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    2690:	c1 50       	subi	r28, 0x01	; 1
    2692:	c7 ff       	sbrs	r28, 7
    2694:	f8 cf       	rjmp	.-16     	; 0x2686 <AICI_InterpretPacket+0x1f6>

			PacketBytes[1] = STATUS_CMD_OK;            // Two CMD_OKs are always returned
    2696:	10 92 37 01 	sts	0x0137, r1
			PacketBytes[2] = STATUS_CMD_OK;            // Two CMD_OKs are always returned
    269a:	10 92 38 01 	sts	0x0138, r1

			break;
    269e:	5d c0       	rjmp	.+186    	; 0x275a <AICI_InterpretPacket+0x2ca>
		case CMD_READ_FLASH_ISP:
		case CMD_READ_EEPROM_ISP:
			MessageSize = 0;                           // Here to prevent compiler from complaining if a var dec appears straight after a case

			uint8_t  ReadCommand = PacketBytes[3];
    26a0:	d0 90 39 01 	lds	r13, 0x0139
			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8) // Load in the number of bytes that is to
    26a4:	80 91 37 01 	lds	r24, 0x0137
    26a8:	99 27       	eor	r25, r25
    26aa:	d8 2f       	mov	r29, r24
    26ac:	cc 27       	eor	r28, r28
    26ae:	80 91 38 01 	lds	r24, 0x0138
    26b2:	99 27       	eor	r25, r25
    26b4:	c8 2b       	or	r28, r24
    26b6:	d9 2b       	or	r29, r25
			                     | PacketBytes[2];                 // be read into a temp variable (MSB first)

			MessageSize = BytesToRead + 3;
    26b8:	23 96       	adiw	r28, 0x03	; 3
    26ba:	d0 93 33 01 	sts	0x0133, r29
    26be:	c0 93 32 01 	sts	0x0132, r28
    26c2:	23 97       	sbiw	r28, 0x03	; 3

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
    26c4:	00 e0       	ldi	r16, 0x00	; 0
    26c6:	10 e0       	ldi	r17, 0x00	; 0
    26c8:	0c 17       	cp	r16, r28
    26ca:	1d 07       	cpc	r17, r29
    26cc:	60 f5       	brcc	.+88     	; 0x2726 <AICI_InterpretPacket+0x296>
    26ce:	88 e3       	ldi	r24, 0x38	; 56
    26d0:	e8 2e       	mov	r14, r24
    26d2:	81 e0       	ldi	r24, 0x01	; 1
    26d4:	f8 2e       	mov	r15, r24
			{
				if (PacketBytes[0] == CMD_READ_FLASH_ISP)  // Flash read mode - word addresses so MSB/LSB masking nessesary
    26d6:	80 91 36 01 	lds	r24, 0x0136
    26da:	84 31       	cpi	r24, 0x14	; 20
    26dc:	31 f4       	brne	.+12     	; 0x26ea <AICI_InterpretPacket+0x25a>
				{
					USI_SPITransmit(ReadCommand | ((ReadByte & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ));
    26de:	8d 2d       	mov	r24, r13
    26e0:	99 27       	eor	r25, r25
    26e2:	00 ff       	sbrs	r16, 0
    26e4:	03 c0       	rjmp	.+6      	; 0x26ec <AICI_InterpretPacket+0x25c>
    26e6:	88 60       	ori	r24, 0x08	; 8
    26e8:	01 c0       	rjmp	.+2      	; 0x26ec <AICI_InterpretPacket+0x25c>
				}
				else                                       // EEPROM read mode, address is in bytes and so no masking nessesary
				{
					USI_SPITransmit(ReadCommand);
    26ea:	8d 2d       	mov	r24, r13
    26ec:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
				}
				
				USI_SPITransmitWord(CurrAddress);          // Transmit the current address to the slave AVR
    26f0:	80 91 2d 01 	lds	r24, 0x012D
    26f4:	90 91 2e 01 	lds	r25, 0x012E
    26f8:	0e 94 f0 09 	call	0x13e0 <USI_SPITransmitWord>

				PacketBytes[2 + ReadByte] = USI_SPITransmit(0x00); // Read in the byte stored at the requested location
    26fc:	80 e0       	ldi	r24, 0x00	; 0
    26fe:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    2702:	f7 01       	movw	r30, r14
    2704:	80 83       	st	Z, r24

				if ((ReadByte & 0x01) || (PacketBytes[0] == CMD_READ_EEPROM_ISP)) // Flash addresses are given in words; only increment on the odd byte if reading the flash.
    2706:	00 fd       	sbrc	r16, 0
    2708:	04 c0       	rjmp	.+8      	; 0x2712 <AICI_InterpretPacket+0x282>
    270a:	80 91 36 01 	lds	r24, 0x0136
    270e:	86 31       	cpi	r24, 0x16	; 22
    2710:	11 f4       	brne	.+4      	; 0x2716 <AICI_InterpretPacket+0x286>
				{
					V2P_IncrementCurrAddress();             // Increment the address counter
    2712:	0e 94 15 0f 	call	0x1e2a <V2P_IncrementCurrAddress>
    2716:	0f 5f       	subi	r16, 0xFF	; 255
    2718:	1f 4f       	sbci	r17, 0xFF	; 255
    271a:	08 94       	sec
    271c:	e1 1c       	adc	r14, r1
    271e:	f1 1c       	adc	r15, r1
    2720:	0c 17       	cp	r16, r28
    2722:	1d 07       	cpc	r17, r29
    2724:	c0 f2       	brcs	.-80     	; 0x26d6 <AICI_InterpretPacket+0x246>
				}
				else
				{
					if ((CurrAddress & 0x00FF0000) & !(CurrAddress & 0x0000FFFF))
					{
						CurrAddress |= (1UL << 31);        // Set MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
						V2P_CheckForExtendedAddress();
					}
				}
			}
			
			PacketBytes[1]               = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    2726:	10 92 37 01 	sts	0x0137, r1
			PacketBytes[2 + BytesToRead] = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    272a:	ca 5c       	subi	r28, 0xCA	; 202
    272c:	de 4f       	sbci	r29, 0xFE	; 254
    272e:	1a 82       	std	Y+2, r1	; 0x02

			break;
    2730:	14 c0       	rjmp	.+40     	; 0x275a <AICI_InterpretPacket+0x2ca>
		case CMD_PROGRAM_FLASH_ISP:
		case CMD_PROGRAM_EEPROM_ISP:
			ISPCC_ProgramChip();                          // Program the bytes into the chip
    2732:	0e 94 5a 11 	call	0x22b4 <ISPCC_ProgramChip>
			
			MessageSize = 2;
    2736:	82 e0       	ldi	r24, 0x02	; 2
    2738:	90 e0       	ldi	r25, 0x00	; 0
    273a:	90 93 33 01 	sts	0x0133, r25
    273e:	80 93 32 01 	sts	0x0132, r24

			PacketBytes[1] = STATUS_CMD_OK;
    2742:	10 92 37 01 	sts	0x0137, r1
			
			break;
    2746:	09 c0       	rjmp	.+18     	; 0x275a <AICI_InterpretPacket+0x2ca>
		default:                                        // Unknown command, return error
			MessageSize = 1;
    2748:	81 e0       	ldi	r24, 0x01	; 1
    274a:	90 e0       	ldi	r25, 0x00	; 0
    274c:	90 93 33 01 	sts	0x0133, r25
    2750:	80 93 32 01 	sts	0x0132, r24
			
			PacketBytes[1] = STATUS_CMD_UNKNOWN;
    2754:	89 ec       	ldi	r24, 0xC9	; 201
    2756:	80 93 37 01 	sts	0x0137, r24
	}

	V2P_SendPacket();                                   // Send the response packet
    275a:	0e 94 3b 0e 	call	0x1c76 <V2P_SendPacket>
    275e:	df 91       	pop	r29
    2760:	cf 91       	pop	r28
    2762:	1f 91       	pop	r17
    2764:	0f 91       	pop	r16
    2766:	ff 90       	pop	r15
    2768:	ef 90       	pop	r14
    276a:	df 90       	pop	r13
    276c:	08 95       	ret

0000276e <PM_GetStoredDataSize>:

// ======================================================================================

uint32_t PM_GetStoredDataSize(uint8_t Type)
{
    276e:	ef 92       	push	r14
    2770:	ff 92       	push	r15
    2772:	0f 93       	push	r16
    2774:	1f 93       	push	r17
    2776:	cf 93       	push	r28
    2778:	df 93       	push	r29
    277a:	cd b7       	in	r28, 0x3d	; 61
    277c:	de b7       	in	r29, 0x3e	; 62
    277e:	22 97       	sbiw	r28, 0x02	; 2
    2780:	0f b6       	in	r0, 0x3f	; 63
    2782:	f8 94       	cli
    2784:	de bf       	out	0x3e, r29	; 62
    2786:	0f be       	out	0x3f, r0	; 63
    2788:	cd bf       	out	0x3d, r28	; 61
	/* This take a **LOT** of code (202 bytes), and is accessed several times throughout
	   the program, so I've put it into a seperate function to save on flash.            */

	uint32_t ProgDataSize  = 0;
	uint16_t EEPROMAddress;

	EEPROMAddress = ((Type == TYPE_FLASH)? Prog_DataSize : Prog_EEPROMSize);
    278a:	81 30       	cpi	r24, 0x01	; 1
    278c:	29 f4       	brne	.+10     	; 0x2798 <PM_GetStoredDataSize+0x2a>
    278e:	80 91 16 01 	lds	r24, 0x0116
    2792:	90 91 17 01 	lds	r25, 0x0117
    2796:	04 c0       	rjmp	.+8      	; 0x27a0 <PM_GetStoredDataSize+0x32>
    2798:	80 91 14 01 	lds	r24, 0x0114
    279c:	90 91 15 01 	lds	r25, 0x0115
    27a0:	9a 83       	std	Y+2, r25	; 0x02
    27a2:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize  = ((uint32_t)eeprom_read_byte_169(&EEPROMAddress) << 24);
    27a4:	ce 01       	movw	r24, r28
    27a6:	01 96       	adiw	r24, 0x01	; 1
    27a8:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
    27ac:	99 27       	eor	r25, r25
    27ae:	aa 27       	eor	r26, r26
    27b0:	bb 27       	eor	r27, r27
    27b2:	18 2f       	mov	r17, r24
    27b4:	00 27       	eor	r16, r16
    27b6:	ff 24       	eor	r15, r15
    27b8:	ee 24       	eor	r14, r14
	EEPROMAddress++;
    27ba:	89 81       	ldd	r24, Y+1	; 0x01
    27bc:	9a 81       	ldd	r25, Y+2	; 0x02
    27be:	01 96       	adiw	r24, 0x01	; 1
    27c0:	9a 83       	std	Y+2, r25	; 0x02
    27c2:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize |= ((uint32_t)eeprom_read_byte_169(&EEPROMAddress) << 16);
    27c4:	ce 01       	movw	r24, r28
    27c6:	01 96       	adiw	r24, 0x01	; 1
    27c8:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
    27cc:	99 27       	eor	r25, r25
    27ce:	aa 27       	eor	r26, r26
    27d0:	bb 27       	eor	r27, r27
    27d2:	dc 01       	movw	r26, r24
    27d4:	99 27       	eor	r25, r25
    27d6:	88 27       	eor	r24, r24
    27d8:	e8 2a       	or	r14, r24
    27da:	f9 2a       	or	r15, r25
    27dc:	0a 2b       	or	r16, r26
    27de:	1b 2b       	or	r17, r27
	EEPROMAddress++;
    27e0:	89 81       	ldd	r24, Y+1	; 0x01
    27e2:	9a 81       	ldd	r25, Y+2	; 0x02
    27e4:	01 96       	adiw	r24, 0x01	; 1
    27e6:	9a 83       	std	Y+2, r25	; 0x02
    27e8:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize |= ((uint32_t)eeprom_read_byte_169(&EEPROMAddress) << 8);
    27ea:	ce 01       	movw	r24, r28
    27ec:	01 96       	adiw	r24, 0x01	; 1
    27ee:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
    27f2:	99 27       	eor	r25, r25
    27f4:	aa 27       	eor	r26, r26
    27f6:	bb 27       	eor	r27, r27
    27f8:	ba 2f       	mov	r27, r26
    27fa:	a9 2f       	mov	r26, r25
    27fc:	98 2f       	mov	r25, r24
    27fe:	88 27       	eor	r24, r24
    2800:	e8 2a       	or	r14, r24
    2802:	f9 2a       	or	r15, r25
    2804:	0a 2b       	or	r16, r26
    2806:	1b 2b       	or	r17, r27
	EEPROMAddress++;
    2808:	89 81       	ldd	r24, Y+1	; 0x01
    280a:	9a 81       	ldd	r25, Y+2	; 0x02
    280c:	01 96       	adiw	r24, 0x01	; 1
    280e:	9a 83       	std	Y+2, r25	; 0x02
    2810:	89 83       	std	Y+1, r24	; 0x01
	ProgDataSize |= eeprom_read_byte_169(&EEPROMAddress);
    2812:	ce 01       	movw	r24, r28
    2814:	01 96       	adiw	r24, 0x01	; 1
    2816:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
    281a:	99 27       	eor	r25, r25
    281c:	aa 27       	eor	r26, r26
    281e:	bb 27       	eor	r27, r27
    2820:	e8 2a       	or	r14, r24
    2822:	f9 2a       	or	r15, r25
    2824:	0a 2b       	or	r16, r26
    2826:	1b 2b       	or	r17, r27

	if (ProgDataSize == 0xFFFFFFFF)                                      // Blank EEPROM, return a size  of 0 bytes
    2828:	8f ef       	ldi	r24, 0xFF	; 255
    282a:	e8 16       	cp	r14, r24
    282c:	8f ef       	ldi	r24, 0xFF	; 255
    282e:	f8 06       	cpc	r15, r24
    2830:	8f ef       	ldi	r24, 0xFF	; 255
    2832:	08 07       	cpc	r16, r24
    2834:	8f ef       	ldi	r24, 0xFF	; 255
    2836:	18 07       	cpc	r17, r24
    2838:	19 f4       	brne	.+6      	; 0x2840 <PM_GetStoredDataSize+0xd2>
	   ProgDataSize = 0x00;
    283a:	ee 24       	eor	r14, r14
    283c:	ff 24       	eor	r15, r15
    283e:	87 01       	movw	r16, r14

	return ProgDataSize;
}
    2840:	c8 01       	movw	r24, r16
    2842:	b7 01       	movw	r22, r14
    2844:	22 96       	adiw	r28, 0x02	; 2
    2846:	0f b6       	in	r0, 0x3f	; 63
    2848:	f8 94       	cli
    284a:	de bf       	out	0x3e, r29	; 62
    284c:	0f be       	out	0x3f, r0	; 63
    284e:	cd bf       	out	0x3d, r28	; 61
    2850:	df 91       	pop	r29
    2852:	cf 91       	pop	r28
    2854:	1f 91       	pop	r17
    2856:	0f 91       	pop	r16
    2858:	ff 90       	pop	r15
    285a:	ef 90       	pop	r14
    285c:	08 95       	ret

0000285e <PM_SetupDFAddressCounters>:

void PM_SetupDFAddressCounters(uint8_t Type)
{
	uint32_t StartAddress;

	MemoryType   = Type;
    285e:	80 93 4c 02 	sts	0x024C, r24
	PageLength   = 0;
    2862:	10 92 4a 02 	sts	0x024A, r1
    2866:	10 92 49 02 	sts	0x0249, r1
    286a:	20 91 2d 01 	lds	r18, 0x012D
    286e:	30 91 2e 01 	lds	r19, 0x012E
    2872:	40 91 2f 01 	lds	r20, 0x012F
    2876:	50 91 30 01 	lds	r21, 0x0130

	if (Type == TYPE_FLASH)                                              // Type 1 = Flash
    287a:	81 30       	cpi	r24, 0x01	; 1
    287c:	39 f4       	brne	.+14     	; 0x288c <PM_SetupDFAddressCounters+0x2e>
		StartAddress = (CurrAddress << 1);                               // Convert flash word address to byte address
    287e:	da 01       	movw	r26, r20
    2880:	c9 01       	movw	r24, r18
    2882:	88 0f       	add	r24, r24
    2884:	99 1f       	adc	r25, r25
    2886:	aa 1f       	adc	r26, r26
    2888:	bb 1f       	adc	r27, r27
    288a:	06 c0       	rjmp	.+12     	; 0x2898 <PM_SetupDFAddressCounters+0x3a>
	else
		StartAddress = CurrAddress + PM_EEPROM_OFFSET;                   // EEPROM uses byte addresses, and starts at the 257th kilobyte in Dataflash
    288c:	da 01       	movw	r26, r20
    288e:	c9 01       	movw	r24, r18
    2890:	80 50       	subi	r24, 0x00	; 0
    2892:	9c 4f       	sbci	r25, 0xFC	; 252
    2894:	ab 4f       	sbci	r26, 0xFB	; 251
    2896:	bf 4f       	sbci	r27, 0xFF	; 255
	
	CurrPageAddress = 0;
    2898:	10 92 8c 02 	sts	0x028C, r1
    289c:	10 92 8b 02 	sts	0x028B, r1

	while (StartAddress > DF_INTERNALDF_BUFFBYTES)                      // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DF_INTERNALDF_BUFFBYTES;                         // Subtract one page's worth of bytes from the desired address
		CurrPageAddress++;
    28a0:	89 30       	cpi	r24, 0x09	; 9
    28a2:	21 e0       	ldi	r18, 0x01	; 1
    28a4:	92 07       	cpc	r25, r18
    28a6:	20 e0       	ldi	r18, 0x00	; 0
    28a8:	a2 07       	cpc	r26, r18
    28aa:	20 e0       	ldi	r18, 0x00	; 0
    28ac:	b2 07       	cpc	r27, r18
    28ae:	a0 f0       	brcs	.+40     	; 0x28d8 <PM_SetupDFAddressCounters+0x7a>
    28b0:	20 e0       	ldi	r18, 0x00	; 0
    28b2:	30 e0       	ldi	r19, 0x00	; 0
    28b4:	88 50       	subi	r24, 0x08	; 8
    28b6:	91 40       	sbci	r25, 0x01	; 1
    28b8:	a0 40       	sbci	r26, 0x00	; 0
    28ba:	b0 40       	sbci	r27, 0x00	; 0
    28bc:	2f 5f       	subi	r18, 0xFF	; 255
    28be:	3f 4f       	sbci	r19, 0xFF	; 255
    28c0:	89 30       	cpi	r24, 0x09	; 9
    28c2:	41 e0       	ldi	r20, 0x01	; 1
    28c4:	94 07       	cpc	r25, r20
    28c6:	40 e0       	ldi	r20, 0x00	; 0
    28c8:	a4 07       	cpc	r26, r20
    28ca:	40 e0       	ldi	r20, 0x00	; 0
    28cc:	b4 07       	cpc	r27, r20
    28ce:	90 f7       	brcc	.-28     	; 0x28b4 <PM_SetupDFAddressCounters+0x56>
    28d0:	30 93 8c 02 	sts	0x028C, r19
    28d4:	20 93 8b 02 	sts	0x028B, r18
	}
	
	CurrBuffByte = (uint16_t)StartAddress;                               // The buffer byte is the remainder
    28d8:	90 93 85 02 	sts	0x0285, r25
    28dc:	80 93 84 02 	sts	0x0284, r24
    28e0:	08 95       	ret

000028e2 <PM_StoreProgramByte>:
}

void PM_StoreProgramByte(uint8_t Data)
{
    28e2:	cf 93       	push	r28
    28e4:	c8 2f       	mov	r28, r24
	if (CurrBuffByte == DF_INTERNALDF_BUFFBYTES)
    28e6:	80 91 84 02 	lds	r24, 0x0284
    28ea:	90 91 85 02 	lds	r25, 0x0285
    28ee:	88 50       	subi	r24, 0x08	; 8
    28f0:	91 40       	sbci	r25, 0x01	; 1
    28f2:	a9 f4       	brne	.+42     	; 0x291e <PM_StoreProgramByte+0x3c>
	{
		DF_CopyBufferToFlashPage(CurrPageAddress++);
    28f4:	80 91 8b 02 	lds	r24, 0x028B
    28f8:	90 91 8c 02 	lds	r25, 0x028C
    28fc:	9c 01       	movw	r18, r24
    28fe:	01 96       	adiw	r24, 0x01	; 1
    2900:	90 93 8c 02 	sts	0x028C, r25
    2904:	80 93 8b 02 	sts	0x028B, r24
    2908:	c9 01       	movw	r24, r18
    290a:	0e 94 74 0b 	call	0x16e8 <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    290e:	80 e0       	ldi	r24, 0x00	; 0
    2910:	90 e0       	ldi	r25, 0x00	; 0
    2912:	0e 94 94 0a 	call	0x1528 <DF_BufferWriteEnable>
		CurrBuffByte = 0;
    2916:	10 92 85 02 	sts	0x0285, r1
    291a:	10 92 84 02 	sts	0x0284, r1
	}
	
	SPI_SPITransmit(Data);                                               // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    291e:	8c 2f       	mov	r24, r28
    2920:	0e 94 3f 09 	call	0x127e <SPI_SPITransmit>
	CurrBuffByte++;
    2924:	80 91 84 02 	lds	r24, 0x0284
    2928:	90 91 85 02 	lds	r25, 0x0285
    292c:	01 96       	adiw	r24, 0x01	; 1
    292e:	90 93 85 02 	sts	0x0285, r25
    2932:	80 93 84 02 	sts	0x0284, r24
	PageLength++;
    2936:	80 91 49 02 	lds	r24, 0x0249
    293a:	90 91 4a 02 	lds	r25, 0x024A
    293e:	01 96       	adiw	r24, 0x01	; 1
    2940:	90 93 4a 02 	sts	0x024A, r25
    2944:	80 93 49 02 	sts	0x0249, r24
    2948:	cf 91       	pop	r28
    294a:	08 95       	ret

0000294c <PM_CheckEndOfProgramming>:
}

void PM_InterpretAVRISPPacket(void)
{
	uint16_t EEPROMAddress;

	switch (PacketBytes[0])
	{
		case CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
			
			EEPROMAddress = Prog_EnterProgMode;
			
			for (uint8_t PacketB = 0; PacketB <= 11; PacketB++)          // Save the enter programming mode command bytes
			{
				eeprom_write_byte_169(&EEPROMAddress, PacketBytes[PacketB]);
				EEPROMAddress++;
			}
			
			InProgrammingMode = TRUE;                                    // Set the flag, prevent the user from exiting the V2P state machine			
			CurrentMode = PM_NO_SETUP;                                   // Clear the current mode variable

			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = STATUS_CMD_OK;

			break;			
		case CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;

			PM_CheckEndOfProgramming();                                  // Check if the last command was a program - if so store the program length
			PM_CheckEndOfFuseLockStore();                                // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
			
			InProgrammingMode = FALSE;                                   // Clear the flag, allow the user to exit the V2P state machine

			DF_EnableDataflash(FALSE);

			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
			PacketBytes[1] = STATUS_CMD_OK;

			break;
		case CMD_READ_SIGNATURE_ISP:
			MessageSize = 4;

			PacketBytes[1] = STATUS_CMD_OK;                              // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x01;                                       // Signature bytes all return "01" in storage mode
			PacketBytes[3] = STATUS_CMD_OK;                              // Data byte is encased in CMD_OKs

			break;
		case CMD_CHIP_ERASE_ISP:
			MessageSize = 2;

			EEPROMAddress = Prog_EraseChip;                              // Program erase chip command start address
			
			for (uint8_t PacketB = 1; PacketB <= 6; PacketB++)          // Save the erase chip command bytes to EEPROM
			{
				eeprom_write_byte_169(&EEPROMAddress, PacketBytes[PacketB]);
				EEPROMAddress++;
			}

			EEPROMAddress = Prog_DataSize;
										
			for (uint8_t Byte = 0; Byte < 8; Byte++)                    // Clear the program and EEPROM size counters
			{
				if (Byte == 4)
				   EEPROMAddress = Prog_EEPROMSize;

				eeprom_write_byte_169(&EEPROMAddress, 0x00);
				EEPROMAddress++;						
			}
			
			eeprom_write_byte_169(&Prog_EraseCmdStored, TRUE);
			
			PacketBytes[1] = STATUS_CMD_OK;
			
			break;
		case CMD_READ_OSCCAL_ISP:
			MessageSize = 4;

			PacketBytes[1] = STATUS_CMD_OK;                             // Data byte is encased in CMD_OKs
			PacketBytes[1] = 0x00;                                      // Return 0x00 for the OSCCAL byte
			PacketBytes[3] = STATUS_CMD_OK;                             // Data byte is encased in CMD_OKs

			break;
		case CMD_READ_FUSE_ISP:
		case CMD_READ_LOCK_ISP:
			MessageSize = 4;
	
			if (CurrentMode != PM_LOCKFUSEBITS_READ)                    // First lock or fuse byte being read, set the EEPROM pointer
			{
				PM_CheckEndOfProgramming();                             // Check if the last command was a program - if so store the program length
				PM_CheckEndOfFuseLockStore();                           // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
				
				CurrBuffByte = 0;
				CurrentMode  = PM_LOCKFUSEBITS_READ;
			}
			
			EEPROMAddress = ((PacketBytes[0] == CMD_READ_FUSE_ISP)? Prog_TotalFuseBytes : Prog_TotalLockBytes);

			if (CurrBuffByte > eeprom_read_byte_169(&EEPROMAddress))    // Trying to read more fuse/lock bytes than are stored in memory
			{
				PacketBytes[2] = 0xFF;                                  // Return 0xFF for the fuse/lock byte
			}
			else
			{
				EEPROMAddress  = ((PacketBytes[0] == CMD_READ_FUSE_ISP)? Prog_FuseBytes : Prog_LockBytes) // Starting location
									+ (CurrBuffByte << 2) + (PacketBytes[1] - 1); // The start position of the actual fuse/lock byte to read (4 bytes each)

				PacketBytes[2] = eeprom_read_byte_169(&EEPROMAddress); // Return the fuse/lock byte
			}

			PacketBytes[1] = STATUS_CMD_OK;                            // Data byte is encased in CMD_OKs
			PacketBytes[3] = STATUS_CMD_OK;                            // Data byte is encased in CMD_OKs

			CurrBuffByte++;

			break;
		case CMD_PROGRAM_FUSE_ISP:
		case CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;

			if (CurrentMode != PM_LOCKFUSEBITS_WRITE)                  // First lock or fuse byte being written, set the EEPROM pointer
			{
				CurrentMode   = PM_LOCKFUSEBITS_WRITE;
				CurrBuffByte  = 0;                                     // CurrBuffByte is used to store the total fuse/lock bytes written
			}

			if (PacketBytes[0] == CMD_PROGRAM_FUSE_ISP)
			{
				EEPROMAddress = Prog_FuseBytes + (CurrBuffByte << 2);
				MemoryType    = TYPE_FUSE;
			}
			else
			{
				EEPROMAddress = Prog_LockBytes + (CurrBuffByte << 2);
				MemoryType    = TYPE_LOCK;
			}				
			
			if (CurrBuffByte < PM_MAX_FUSELOCKBITS)
			{
				for (uint8_t FLByte = 1; FLByte <= 4; FLByte++)
				{
					eeprom_write_byte_169(&EEPROMAddress, PacketBytes[FLByte]);
					EEPROMAddress++;
				}

				CurrBuffByte++;                                        // Increment the total fuse/lock bytes written counter
			}
			
			PacketBytes[1] = STATUS_CMD_OK;                            // Two CMD_OKs are always returned
			PacketBytes[2] = STATUS_CMD_OK;                            // Two CMD_OKs are always returned

			break;
		case CMD_PROGRAM_FLASH_ISP:
		case CMD_PROGRAM_EEPROM_ISP:
			MessageSize = 2;

			if (CurrentMode != PM_DATAFLASH_WRITE)                     // First programming packet
			{
				if (PacketBytes[0] == CMD_PROGRAM_FLASH_ISP)           // Flash programming mode
				{
					EEPROMAddress = Prog_WriteProgram;                 // Set the eeprom address to the Program command bytes location
					PM_SetupDFAddressCounters(TYPE_FLASH);
				}
				else                                                  // EEPROM programming mode
				{
					EEPROMAddress = Prog_WriteEEPROM;                  // Set the eeprom address to the EEPROM command bytes location
					PM_SetupDFAddressCounters(TYPE_EEPROM);
				}
				
				DF_BufferWriteEnable(CurrBuffByte);
				CurrentMode = PM_DATAFLASH_WRITE;
				
				for (uint8_t B = 1; B <= 9; B++)                       // Save the command bytes
				{
					eeprom_write_byte_169(&EEPROMAddress, PacketBytes[B]);
					EEPROMAddress++;				
				}
			}

			uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
			                      | PacketBytes[2];

			for (uint16_t CurrByte = 0; CurrByte < BytesToWrite; CurrByte++)
				PM_StoreProgramByte(PacketBytes[10 + CurrByte]);
						
			if ((PacketBytes[3] & ISPCC_PROG_MODE_PAGEDONE) && !(PageLength & PM_PAGELENGTH_FOUNDBIT) && PageLength)
			{
				EEPROMAddress = ((MemoryType == TYPE_FLASH)? Prog_PageLength : Prog_EPageLength);
	
				eeprom_write_byte_169(&EEPROMAddress, (uint8_t)(PageLength >> 8));
				EEPROMAddress++;
				eeprom_write_byte_169(&EEPROMAddress, (uint8_t)PageLength);		
		
				PageLength |= PM_PAGELENGTH_FOUNDBIT;                 // Bit 15 is used to indicate if the length has been found
			}

			PacketBytes[1] = STATUS_CMD_OK;
		
			break;
		case CMD_READ_FLASH_ISP:
		case CMD_READ_EEPROM_ISP:	
			if (CurrentMode != PM_DATAFLASH_READ)
			{
				PM_CheckEndOfProgramming();                           // Check if the last command was a program - if so store the program length
				PM_CheckEndOfFuseLockStore();                         // Check if the last command was a fuse/lock byte program - if so store the total number of bytes
				
				PM_SetupDFAddressCounters((PacketBytes[0] == CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);
				DF_ContinuousReadEnable(CurrPageAddress, CurrBuffByte);
				
				CurrentMode = PM_DATAFLASH_READ;
				CurrAddress = 0;
			}

			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8)    // \. Load in the number of bytes that is to
			                     | PacketBytes[2];                    // /  be read into a temp variable (MSB first)
						
			uint16_t BytesInMem  = PM_GetStoredDataSize((PacketBytes[0] == CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
			   PacketBytes[2 + ReadByte] = ((CurrAddress < BytesInMem)? SPI_SPITransmit(0x00) : 0xFF); // Read in the next dataflash byte if present
			   V2P_IncrementCurrAddress();
			}
			
			MessageSize = BytesToRead + 3;

			PacketBytes[1]               = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
			PacketBytes[2 + BytesToRead] = STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
		
			break;
		default:
			MessageSize = 1;
			
			PacketBytes[1] = STATUS_CMD_UNKNOWN;
	}

	V2P_SendPacket();                                   // Send the response packet
}

void PM_CheckEndOfProgramming(void)
{
    294c:	ef 92       	push	r14
    294e:	ff 92       	push	r15
    2950:	0f 93       	push	r16
    2952:	1f 93       	push	r17
    2954:	cf 93       	push	r28
    2956:	df 93       	push	r29
    2958:	cd b7       	in	r28, 0x3d	; 61
    295a:	de b7       	in	r29, 0x3e	; 62
    295c:	22 97       	sbiw	r28, 0x02	; 2
    295e:	0f b6       	in	r0, 0x3f	; 63
    2960:	f8 94       	cli
    2962:	de bf       	out	0x3e, r29	; 62
    2964:	0f be       	out	0x3f, r0	; 63
    2966:	cd bf       	out	0x3d, r28	; 61
   uint16_t EEPROMAddress;

   if (CurrentMode == PM_DATAFLASH_WRITE)
    2968:	80 91 4b 02 	lds	r24, 0x024B
    296c:	81 30       	cpi	r24, 0x01	; 1
    296e:	09 f0       	breq	.+2      	; 0x2972 <PM_CheckEndOfProgramming+0x26>
    2970:	6d c0       	rjmp	.+218    	; 0x2a4c <PM_CheckEndOfProgramming+0x100>
   {
      if (CurrBuffByte)                               // Data in the dataflash buffer, pending to be written
    2972:	80 91 84 02 	lds	r24, 0x0284
    2976:	90 91 85 02 	lds	r25, 0x0285
    297a:	89 2b       	or	r24, r25
    297c:	31 f0       	breq	.+12     	; 0x298a <PM_CheckEndOfProgramming+0x3e>
         DF_CopyBufferToFlashPage(CurrPageAddress);   // Save the buffer
    297e:	80 91 8b 02 	lds	r24, 0x028B
    2982:	90 91 8c 02 	lds	r25, 0x028C
    2986:	0e 94 74 0b 	call	0x16e8 <DF_CopyBufferToFlashPage>

      uint32_t DataSize = ((uint32_t)CurrPageAddress * DF_INTERNALDF_BUFFBYTES) + CurrBuffByte;
    298a:	80 91 8b 02 	lds	r24, 0x028B
    298e:	90 91 8c 02 	lds	r25, 0x028C
    2992:	aa 27       	eor	r26, r26
    2994:	bb 27       	eor	r27, r27
    2996:	bc 01       	movw	r22, r24
    2998:	cd 01       	movw	r24, r26
    299a:	28 e0       	ldi	r18, 0x08	; 8
    299c:	31 e0       	ldi	r19, 0x01	; 1
    299e:	40 e0       	ldi	r20, 0x00	; 0
    29a0:	50 e0       	ldi	r21, 0x00	; 0
    29a2:	0e 94 a6 1b 	call	0x374c <__mulsi3>
    29a6:	7b 01       	movw	r14, r22
    29a8:	8c 01       	movw	r16, r24
    29aa:	80 91 84 02 	lds	r24, 0x0284
    29ae:	90 91 85 02 	lds	r25, 0x0285
    29b2:	aa 27       	eor	r26, r26
    29b4:	bb 27       	eor	r27, r27
    29b6:	e8 0e       	add	r14, r24
    29b8:	f9 1e       	adc	r15, r25
    29ba:	0a 1f       	adc	r16, r26
    29bc:	1b 1f       	adc	r17, r27

      if (MemoryType == TYPE_FLASH)
    29be:	80 91 4c 02 	lds	r24, 0x024C
    29c2:	81 30       	cpi	r24, 0x01	; 1
    29c4:	39 f4       	brne	.+14     	; 0x29d4 <PM_CheckEndOfProgramming+0x88>
      {
         EEPROMAddress = Prog_DataSize;       
    29c6:	80 91 16 01 	lds	r24, 0x0116
    29ca:	90 91 17 01 	lds	r25, 0x0117
    29ce:	9a 83       	std	Y+2, r25	; 0x02
    29d0:	89 83       	std	Y+1, r24	; 0x01
    29d2:	0e c0       	rjmp	.+28     	; 0x29f0 <PM_CheckEndOfProgramming+0xa4>
      }
      else
      {
         EEPROMAddress = Prog_EEPROMSize;
    29d4:	80 91 14 01 	lds	r24, 0x0114
    29d8:	90 91 15 01 	lds	r25, 0x0115
    29dc:	9a 83       	std	Y+2, r25	; 0x02
    29de:	89 83       	std	Y+1, r24	; 0x01
         DataSize -= PM_EEPROM_OFFSET;                // Remove DataFlash starting offset
    29e0:	80 e0       	ldi	r24, 0x00	; 0
    29e2:	9c ef       	ldi	r25, 0xFC	; 252
    29e4:	ab ef       	ldi	r26, 0xFB	; 251
    29e6:	bf ef       	ldi	r27, 0xFF	; 255
    29e8:	e8 0e       	add	r14, r24
    29ea:	f9 1e       	adc	r15, r25
    29ec:	0a 1f       	adc	r16, r26
    29ee:	1b 1f       	adc	r17, r27
      }

      eeprom_write_byte_169(&EEPROMAddress, (DataSize >> 24));
    29f0:	81 2f       	mov	r24, r17
    29f2:	99 27       	eor	r25, r25
    29f4:	aa 27       	eor	r26, r26
    29f6:	bb 27       	eor	r27, r27
    29f8:	68 2f       	mov	r22, r24
    29fa:	ce 01       	movw	r24, r28
    29fc:	01 96       	adiw	r24, 0x01	; 1
    29fe:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
      EEPROMAddress++;
    2a02:	89 81       	ldd	r24, Y+1	; 0x01
    2a04:	9a 81       	ldd	r25, Y+2	; 0x02
    2a06:	01 96       	adiw	r24, 0x01	; 1
    2a08:	9a 83       	std	Y+2, r25	; 0x02
    2a0a:	89 83       	std	Y+1, r24	; 0x01
      eeprom_write_byte_169(&EEPROMAddress, (DataSize >> 16));             
    2a0c:	c8 01       	movw	r24, r16
    2a0e:	aa 27       	eor	r26, r26
    2a10:	bb 27       	eor	r27, r27
    2a12:	68 2f       	mov	r22, r24
    2a14:	ce 01       	movw	r24, r28
    2a16:	01 96       	adiw	r24, 0x01	; 1
    2a18:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
      EEPROMAddress++;
    2a1c:	89 81       	ldd	r24, Y+1	; 0x01
    2a1e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a20:	01 96       	adiw	r24, 0x01	; 1
    2a22:	9a 83       	std	Y+2, r25	; 0x02
    2a24:	89 83       	std	Y+1, r24	; 0x01
      eeprom_write_byte_169(&EEPROMAddress, (DataSize >> 8));
    2a26:	bb 27       	eor	r27, r27
    2a28:	a1 2f       	mov	r26, r17
    2a2a:	90 2f       	mov	r25, r16
    2a2c:	8f 2d       	mov	r24, r15
    2a2e:	68 2f       	mov	r22, r24
    2a30:	ce 01       	movw	r24, r28
    2a32:	01 96       	adiw	r24, 0x01	; 1
    2a34:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
      EEPROMAddress++;
    2a38:	89 81       	ldd	r24, Y+1	; 0x01
    2a3a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a3c:	01 96       	adiw	r24, 0x01	; 1
    2a3e:	9a 83       	std	Y+2, r25	; 0x02
    2a40:	89 83       	std	Y+1, r24	; 0x01
      eeprom_write_byte_169(&EEPROMAddress, DataSize);
    2a42:	6e 2d       	mov	r22, r14
    2a44:	ce 01       	movw	r24, r28
    2a46:	01 96       	adiw	r24, 0x01	; 1
    2a48:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
    2a4c:	22 96       	adiw	r28, 0x02	; 2
    2a4e:	0f b6       	in	r0, 0x3f	; 63
    2a50:	f8 94       	cli
    2a52:	de bf       	out	0x3e, r29	; 62
    2a54:	0f be       	out	0x3f, r0	; 63
    2a56:	cd bf       	out	0x3d, r28	; 61
    2a58:	df 91       	pop	r29
    2a5a:	cf 91       	pop	r28
    2a5c:	1f 91       	pop	r17
    2a5e:	0f 91       	pop	r16
    2a60:	ff 90       	pop	r15
    2a62:	ef 90       	pop	r14
    2a64:	08 95       	ret

00002a66 <PM_CheckEndOfFuseLockStore>:
   }
}

void PM_CheckEndOfFuseLockStore(void)
{
    2a66:	cf 93       	push	r28
    2a68:	df 93       	push	r29
    2a6a:	cd b7       	in	r28, 0x3d	; 61
    2a6c:	de b7       	in	r29, 0x3e	; 62
    2a6e:	22 97       	sbiw	r28, 0x02	; 2
    2a70:	0f b6       	in	r0, 0x3f	; 63
    2a72:	f8 94       	cli
    2a74:	de bf       	out	0x3e, r29	; 62
    2a76:	0f be       	out	0x3f, r0	; 63
    2a78:	cd bf       	out	0x3d, r28	; 61
	uint16_t EEPROMAddress;

	if (CurrentMode == PM_LOCKFUSEBITS_WRITE)
    2a7a:	80 91 4b 02 	lds	r24, 0x024B
    2a7e:	83 30       	cpi	r24, 0x03	; 3
    2a80:	a9 f4       	brne	.+42     	; 0x2aac <PM_CheckEndOfFuseLockStore+0x46>
	{
		EEPROMAddress = ((MemoryType == TYPE_FUSE)? Prog_TotalFuseBytes : Prog_TotalLockBytes);
    2a82:	80 91 4c 02 	lds	r24, 0x024C
    2a86:	82 30       	cpi	r24, 0x02	; 2
    2a88:	29 f4       	brne	.+10     	; 0x2a94 <PM_CheckEndOfFuseLockStore+0x2e>
    2a8a:	80 91 10 01 	lds	r24, 0x0110
    2a8e:	90 91 11 01 	lds	r25, 0x0111
    2a92:	04 c0       	rjmp	.+8      	; 0x2a9c <PM_CheckEndOfFuseLockStore+0x36>
    2a94:	80 91 0e 01 	lds	r24, 0x010E
    2a98:	90 91 0f 01 	lds	r25, 0x010F
    2a9c:	9a 83       	std	Y+2, r25	; 0x02
    2a9e:	89 83       	std	Y+1, r24	; 0x01
		
		eeprom_write_byte_169(&EEPROMAddress, CurrBuffByte); // CurrBuffByte stores the total number of fuse/lock bytes written in this case
    2aa0:	60 91 84 02 	lds	r22, 0x0284
    2aa4:	ce 01       	movw	r24, r28
    2aa6:	01 96       	adiw	r24, 0x01	; 1
    2aa8:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
    2aac:	22 96       	adiw	r28, 0x02	; 2
    2aae:	0f b6       	in	r0, 0x3f	; 63
    2ab0:	f8 94       	cli
    2ab2:	de bf       	out	0x3e, r29	; 62
    2ab4:	0f be       	out	0x3f, r0	; 63
    2ab6:	cd bf       	out	0x3d, r28	; 61
    2ab8:	df 91       	pop	r29
    2aba:	cf 91       	pop	r28
    2abc:	08 95       	ret

00002abe <PM_InterpretAVRISPPacket>:
    2abe:	af 92       	push	r10
    2ac0:	bf 92       	push	r11
    2ac2:	cf 92       	push	r12
    2ac4:	df 92       	push	r13
    2ac6:	ef 92       	push	r14
    2ac8:	ff 92       	push	r15
    2aca:	0f 93       	push	r16
    2acc:	1f 93       	push	r17
    2ace:	cf 93       	push	r28
    2ad0:	df 93       	push	r29
    2ad2:	cd b7       	in	r28, 0x3d	; 61
    2ad4:	de b7       	in	r29, 0x3e	; 62
    2ad6:	22 97       	sbiw	r28, 0x02	; 2
    2ad8:	0f b6       	in	r0, 0x3f	; 63
    2ada:	f8 94       	cli
    2adc:	de bf       	out	0x3e, r29	; 62
    2ade:	0f be       	out	0x3f, r0	; 63
    2ae0:	cd bf       	out	0x3d, r28	; 61
    2ae2:	40 91 36 01 	lds	r20, 0x0136
    2ae6:	84 2f       	mov	r24, r20
    2ae8:	99 27       	eor	r25, r25
    2aea:	86 31       	cpi	r24, 0x16	; 22
    2aec:	91 05       	cpc	r25, r1
    2aee:	09 f4       	brne	.+2      	; 0x2af2 <PM_InterpretAVRISPPacket+0x34>
    2af0:	18 c2       	rjmp	.+1072   	; 0x2f22 <PM_InterpretAVRISPPacket+0x464>
    2af2:	87 31       	cpi	r24, 0x17	; 23
    2af4:	91 05       	cpc	r25, r1
    2af6:	94 f4       	brge	.+36     	; 0x2b1c <PM_InterpretAVRISPPacket+0x5e>
    2af8:	82 31       	cpi	r24, 0x12	; 18
    2afa:	91 05       	cpc	r25, r1
    2afc:	09 f4       	brne	.+2      	; 0x2b00 <PM_InterpretAVRISPPacket+0x42>
    2afe:	72 c0       	rjmp	.+228    	; 0x2be4 <PM_InterpretAVRISPPacket+0x126>
    2b00:	83 31       	cpi	r24, 0x13	; 19
    2b02:	91 05       	cpc	r25, r1
    2b04:	3c f4       	brge	.+14     	; 0x2b14 <PM_InterpretAVRISPPacket+0x56>
    2b06:	80 31       	cpi	r24, 0x10	; 16
    2b08:	91 05       	cpc	r25, r1
    2b0a:	19 f1       	breq	.+70     	; 0x2b52 <PM_InterpretAVRISPPacket+0x94>
    2b0c:	41 97       	sbiw	r24, 0x11	; 17
    2b0e:	09 f4       	brne	.+2      	; 0x2b12 <PM_InterpretAVRISPPacket+0x54>
    2b10:	49 c0       	rjmp	.+146    	; 0x2ba4 <PM_InterpretAVRISPPacket+0xe6>
    2b12:	7b c2       	rjmp	.+1270   	; 0x300a <PM_InterpretAVRISPPacket+0x54c>
    2b14:	44 97       	sbiw	r24, 0x14	; 20
    2b16:	09 f4       	brne	.+2      	; 0x2b1a <PM_InterpretAVRISPPacket+0x5c>
    2b18:	04 c2       	rjmp	.+1032   	; 0x2f22 <PM_InterpretAVRISPPacket+0x464>
    2b1a:	71 c1       	rjmp	.+738    	; 0x2dfe <PM_InterpretAVRISPPacket+0x340>
    2b1c:	89 31       	cpi	r24, 0x19	; 25
    2b1e:	91 05       	cpc	r25, r1
    2b20:	09 f4       	brne	.+2      	; 0x2b24 <PM_InterpretAVRISPPacket+0x66>
    2b22:	11 c1       	rjmp	.+546    	; 0x2d46 <PM_InterpretAVRISPPacket+0x288>
    2b24:	8a 31       	cpi	r24, 0x1A	; 26
    2b26:	91 05       	cpc	r25, r1
    2b28:	44 f4       	brge	.+16     	; 0x2b3a <PM_InterpretAVRISPPacket+0x7c>
    2b2a:	87 31       	cpi	r24, 0x17	; 23
    2b2c:	91 05       	cpc	r25, r1
    2b2e:	09 f4       	brne	.+2      	; 0x2b32 <PM_InterpretAVRISPPacket+0x74>
    2b30:	0a c1       	rjmp	.+532    	; 0x2d46 <PM_InterpretAVRISPPacket+0x288>
    2b32:	48 97       	sbiw	r24, 0x18	; 24
    2b34:	09 f4       	brne	.+2      	; 0x2b38 <PM_InterpretAVRISPPacket+0x7a>
    2b36:	a3 c0       	rjmp	.+326    	; 0x2c7e <PM_InterpretAVRISPPacket+0x1c0>
    2b38:	68 c2       	rjmp	.+1232   	; 0x300a <PM_InterpretAVRISPPacket+0x54c>
    2b3a:	8b 31       	cpi	r24, 0x1B	; 27
    2b3c:	91 05       	cpc	r25, r1
    2b3e:	09 f4       	brne	.+2      	; 0x2b42 <PM_InterpretAVRISPPacket+0x84>
    2b40:	45 c0       	rjmp	.+138    	; 0x2bcc <PM_InterpretAVRISPPacket+0x10e>
    2b42:	8b 31       	cpi	r24, 0x1B	; 27
    2b44:	91 05       	cpc	r25, r1
    2b46:	0c f4       	brge	.+2      	; 0x2b4a <PM_InterpretAVRISPPacket+0x8c>
    2b48:	9a c0       	rjmp	.+308    	; 0x2c7e <PM_InterpretAVRISPPacket+0x1c0>
    2b4a:	4c 97       	sbiw	r24, 0x1c	; 28
    2b4c:	09 f4       	brne	.+2      	; 0x2b50 <PM_InterpretAVRISPPacket+0x92>
    2b4e:	8c c0       	rjmp	.+280    	; 0x2c68 <PM_InterpretAVRISPPacket+0x1aa>
    2b50:	5c c2       	rjmp	.+1208   	; 0x300a <PM_InterpretAVRISPPacket+0x54c>
    2b52:	82 e0       	ldi	r24, 0x02	; 2
    2b54:	90 e0       	ldi	r25, 0x00	; 0
    2b56:	90 93 33 01 	sts	0x0133, r25
    2b5a:	80 93 32 01 	sts	0x0132, r24
    2b5e:	80 91 12 01 	lds	r24, 0x0112
    2b62:	90 91 13 01 	lds	r25, 0x0113
    2b66:	9a 83       	std	Y+2, r25	; 0x02
    2b68:	89 83       	std	Y+1, r24	; 0x01
    2b6a:	f6 e3       	ldi	r31, 0x36	; 54
    2b6c:	ef 2e       	mov	r14, r31
    2b6e:	f1 e0       	ldi	r31, 0x01	; 1
    2b70:	ff 2e       	mov	r15, r31
    2b72:	1b e0       	ldi	r17, 0x0B	; 11
    2b74:	f7 01       	movw	r30, r14
    2b76:	61 91       	ld	r22, Z+
    2b78:	7f 01       	movw	r14, r30
    2b7a:	ce 01       	movw	r24, r28
    2b7c:	01 96       	adiw	r24, 0x01	; 1
    2b7e:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
    2b82:	89 81       	ldd	r24, Y+1	; 0x01
    2b84:	9a 81       	ldd	r25, Y+2	; 0x02
    2b86:	01 96       	adiw	r24, 0x01	; 1
    2b88:	9a 83       	std	Y+2, r25	; 0x02
    2b8a:	89 83       	std	Y+1, r24	; 0x01
    2b8c:	11 50       	subi	r17, 0x01	; 1
    2b8e:	17 ff       	sbrs	r17, 7
    2b90:	f1 cf       	rjmp	.-30     	; 0x2b74 <PM_InterpretAVRISPPacket+0xb6>
    2b92:	81 e0       	ldi	r24, 0x01	; 1
    2b94:	80 93 31 01 	sts	0x0131, r24
    2b98:	10 92 4b 02 	sts	0x024B, r1
    2b9c:	81 b3       	in	r24, 0x11	; 17
    2b9e:	8f 7c       	andi	r24, 0xCF	; 207
    2ba0:	80 62       	ori	r24, 0x20	; 32
    2ba2:	12 c0       	rjmp	.+36     	; 0x2bc8 <PM_InterpretAVRISPPacket+0x10a>
    2ba4:	82 e0       	ldi	r24, 0x02	; 2
    2ba6:	90 e0       	ldi	r25, 0x00	; 0
    2ba8:	90 93 33 01 	sts	0x0133, r25
    2bac:	80 93 32 01 	sts	0x0132, r24
    2bb0:	0e 94 a6 14 	call	0x294c <PM_CheckEndOfProgramming>
    2bb4:	0e 94 33 15 	call	0x2a66 <PM_CheckEndOfFuseLockStore>
    2bb8:	10 92 31 01 	sts	0x0131, r1
    2bbc:	80 e0       	ldi	r24, 0x00	; 0
    2bbe:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    2bc2:	81 b3       	in	r24, 0x11	; 17
    2bc4:	8f 7c       	andi	r24, 0xCF	; 207
    2bc6:	80 61       	ori	r24, 0x10	; 16
    2bc8:	81 bb       	out	0x11, r24	; 17
    2bca:	a8 c1       	rjmp	.+848    	; 0x2f1c <PM_InterpretAVRISPPacket+0x45e>
    2bcc:	84 e0       	ldi	r24, 0x04	; 4
    2bce:	90 e0       	ldi	r25, 0x00	; 0
    2bd0:	90 93 33 01 	sts	0x0133, r25
    2bd4:	80 93 32 01 	sts	0x0132, r24
    2bd8:	10 92 37 01 	sts	0x0137, r1
    2bdc:	81 e0       	ldi	r24, 0x01	; 1
    2bde:	80 93 38 01 	sts	0x0138, r24
    2be2:	4a c0       	rjmp	.+148    	; 0x2c78 <PM_InterpretAVRISPPacket+0x1ba>
    2be4:	82 e0       	ldi	r24, 0x02	; 2
    2be6:	90 e0       	ldi	r25, 0x00	; 0
    2be8:	90 93 33 01 	sts	0x0133, r25
    2bec:	80 93 32 01 	sts	0x0132, r24
    2bf0:	80 91 18 01 	lds	r24, 0x0118
    2bf4:	90 91 19 01 	lds	r25, 0x0119
    2bf8:	9a 83       	std	Y+2, r25	; 0x02
    2bfa:	89 83       	std	Y+1, r24	; 0x01
    2bfc:	e7 e3       	ldi	r30, 0x37	; 55
    2bfe:	ee 2e       	mov	r14, r30
    2c00:	e1 e0       	ldi	r30, 0x01	; 1
    2c02:	fe 2e       	mov	r15, r30
    2c04:	15 e0       	ldi	r17, 0x05	; 5
    2c06:	f7 01       	movw	r30, r14
    2c08:	61 91       	ld	r22, Z+
    2c0a:	7f 01       	movw	r14, r30
    2c0c:	ce 01       	movw	r24, r28
    2c0e:	01 96       	adiw	r24, 0x01	; 1
    2c10:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
    2c14:	89 81       	ldd	r24, Y+1	; 0x01
    2c16:	9a 81       	ldd	r25, Y+2	; 0x02
    2c18:	01 96       	adiw	r24, 0x01	; 1
    2c1a:	9a 83       	std	Y+2, r25	; 0x02
    2c1c:	89 83       	std	Y+1, r24	; 0x01
    2c1e:	11 50       	subi	r17, 0x01	; 1
    2c20:	17 ff       	sbrs	r17, 7
    2c22:	f1 cf       	rjmp	.-30     	; 0x2c06 <PM_InterpretAVRISPPacket+0x148>
    2c24:	80 91 16 01 	lds	r24, 0x0116
    2c28:	90 91 17 01 	lds	r25, 0x0117
    2c2c:	9a 83       	std	Y+2, r25	; 0x02
    2c2e:	89 83       	std	Y+1, r24	; 0x01
    2c30:	10 e0       	ldi	r17, 0x00	; 0
    2c32:	14 30       	cpi	r17, 0x04	; 4
    2c34:	31 f4       	brne	.+12     	; 0x2c42 <PM_InterpretAVRISPPacket+0x184>
    2c36:	80 91 14 01 	lds	r24, 0x0114
    2c3a:	90 91 15 01 	lds	r25, 0x0115
    2c3e:	9a 83       	std	Y+2, r25	; 0x02
    2c40:	89 83       	std	Y+1, r24	; 0x01
    2c42:	60 e0       	ldi	r22, 0x00	; 0
    2c44:	ce 01       	movw	r24, r28
    2c46:	01 96       	adiw	r24, 0x01	; 1
    2c48:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
    2c4c:	89 81       	ldd	r24, Y+1	; 0x01
    2c4e:	9a 81       	ldd	r25, Y+2	; 0x02
    2c50:	01 96       	adiw	r24, 0x01	; 1
    2c52:	9a 83       	std	Y+2, r25	; 0x02
    2c54:	89 83       	std	Y+1, r24	; 0x01
    2c56:	1f 5f       	subi	r17, 0xFF	; 255
    2c58:	18 30       	cpi	r17, 0x08	; 8
    2c5a:	58 f3       	brcs	.-42     	; 0x2c32 <PM_InterpretAVRISPPacket+0x174>
    2c5c:	61 e0       	ldi	r22, 0x01	; 1
    2c5e:	8a e1       	ldi	r24, 0x1A	; 26
    2c60:	91 e0       	ldi	r25, 0x01	; 1
    2c62:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
    2c66:	5a c1       	rjmp	.+692    	; 0x2f1c <PM_InterpretAVRISPPacket+0x45e>
    2c68:	84 e0       	ldi	r24, 0x04	; 4
    2c6a:	90 e0       	ldi	r25, 0x00	; 0
    2c6c:	90 93 33 01 	sts	0x0133, r25
    2c70:	80 93 32 01 	sts	0x0132, r24
    2c74:	10 92 37 01 	sts	0x0137, r1
    2c78:	10 92 39 01 	sts	0x0139, r1
    2c7c:	cf c1       	rjmp	.+926    	; 0x301c <PM_InterpretAVRISPPacket+0x55e>
    2c7e:	84 e0       	ldi	r24, 0x04	; 4
    2c80:	90 e0       	ldi	r25, 0x00	; 0
    2c82:	90 93 33 01 	sts	0x0133, r25
    2c86:	80 93 32 01 	sts	0x0132, r24
    2c8a:	80 91 4b 02 	lds	r24, 0x024B
    2c8e:	84 30       	cpi	r24, 0x04	; 4
    2c90:	59 f0       	breq	.+22     	; 0x2ca8 <PM_InterpretAVRISPPacket+0x1ea>
    2c92:	0e 94 a6 14 	call	0x294c <PM_CheckEndOfProgramming>
    2c96:	0e 94 33 15 	call	0x2a66 <PM_CheckEndOfFuseLockStore>
    2c9a:	10 92 85 02 	sts	0x0285, r1
    2c9e:	10 92 84 02 	sts	0x0284, r1
    2ca2:	84 e0       	ldi	r24, 0x04	; 4
    2ca4:	80 93 4b 02 	sts	0x024B, r24
    2ca8:	80 91 36 01 	lds	r24, 0x0136
    2cac:	88 31       	cpi	r24, 0x18	; 24
    2cae:	29 f4       	brne	.+10     	; 0x2cba <PM_InterpretAVRISPPacket+0x1fc>
    2cb0:	80 91 10 01 	lds	r24, 0x0110
    2cb4:	90 91 11 01 	lds	r25, 0x0111
    2cb8:	04 c0       	rjmp	.+8      	; 0x2cc2 <PM_InterpretAVRISPPacket+0x204>
    2cba:	80 91 0e 01 	lds	r24, 0x010E
    2cbe:	90 91 0f 01 	lds	r25, 0x010F
    2cc2:	9a 83       	std	Y+2, r25	; 0x02
    2cc4:	89 83       	std	Y+1, r24	; 0x01
    2cc6:	ce 01       	movw	r24, r28
    2cc8:	01 96       	adiw	r24, 0x01	; 1
    2cca:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
    2cce:	99 27       	eor	r25, r25
    2cd0:	20 91 84 02 	lds	r18, 0x0284
    2cd4:	30 91 85 02 	lds	r19, 0x0285
    2cd8:	82 17       	cp	r24, r18
    2cda:	93 07       	cpc	r25, r19
    2cdc:	10 f4       	brcc	.+4      	; 0x2ce2 <PM_InterpretAVRISPPacket+0x224>
    2cde:	8f ef       	ldi	r24, 0xFF	; 255
    2ce0:	22 c0       	rjmp	.+68     	; 0x2d26 <PM_InterpretAVRISPPacket+0x268>
    2ce2:	a9 01       	movw	r20, r18
    2ce4:	44 0f       	add	r20, r20
    2ce6:	55 1f       	adc	r21, r21
    2ce8:	44 0f       	add	r20, r20
    2cea:	55 1f       	adc	r21, r21
    2cec:	80 91 37 01 	lds	r24, 0x0137
    2cf0:	28 2f       	mov	r18, r24
    2cf2:	33 27       	eor	r19, r19
    2cf4:	21 50       	subi	r18, 0x01	; 1
    2cf6:	30 40       	sbci	r19, 0x00	; 0
    2cf8:	80 91 36 01 	lds	r24, 0x0136
    2cfc:	88 31       	cpi	r24, 0x18	; 24
    2cfe:	29 f4       	brne	.+10     	; 0x2d0a <PM_InterpretAVRISPPacket+0x24c>
    2d00:	80 91 0c 01 	lds	r24, 0x010C
    2d04:	90 91 0d 01 	lds	r25, 0x010D
    2d08:	04 c0       	rjmp	.+8      	; 0x2d12 <PM_InterpretAVRISPPacket+0x254>
    2d0a:	80 91 0a 01 	lds	r24, 0x010A
    2d0e:	90 91 0b 01 	lds	r25, 0x010B
    2d12:	84 0f       	add	r24, r20
    2d14:	95 1f       	adc	r25, r21
    2d16:	82 0f       	add	r24, r18
    2d18:	93 1f       	adc	r25, r19
    2d1a:	9a 83       	std	Y+2, r25	; 0x02
    2d1c:	89 83       	std	Y+1, r24	; 0x01
    2d1e:	ce 01       	movw	r24, r28
    2d20:	01 96       	adiw	r24, 0x01	; 1
    2d22:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
    2d26:	80 93 38 01 	sts	0x0138, r24
    2d2a:	10 92 37 01 	sts	0x0137, r1
    2d2e:	10 92 39 01 	sts	0x0139, r1
    2d32:	80 91 84 02 	lds	r24, 0x0284
    2d36:	90 91 85 02 	lds	r25, 0x0285
    2d3a:	01 96       	adiw	r24, 0x01	; 1
    2d3c:	90 93 85 02 	sts	0x0285, r25
    2d40:	80 93 84 02 	sts	0x0284, r24
    2d44:	6b c1       	rjmp	.+726    	; 0x301c <PM_InterpretAVRISPPacket+0x55e>
    2d46:	83 e0       	ldi	r24, 0x03	; 3
    2d48:	90 e0       	ldi	r25, 0x00	; 0
    2d4a:	90 93 33 01 	sts	0x0133, r25
    2d4e:	80 93 32 01 	sts	0x0132, r24
    2d52:	80 91 4b 02 	lds	r24, 0x024B
    2d56:	83 30       	cpi	r24, 0x03	; 3
    2d58:	39 f0       	breq	.+14     	; 0x2d68 <PM_InterpretAVRISPPacket+0x2aa>
    2d5a:	83 e0       	ldi	r24, 0x03	; 3
    2d5c:	80 93 4b 02 	sts	0x024B, r24
    2d60:	10 92 85 02 	sts	0x0285, r1
    2d64:	10 92 84 02 	sts	0x0284, r1
    2d68:	20 91 84 02 	lds	r18, 0x0284
    2d6c:	30 91 85 02 	lds	r19, 0x0285
    2d70:	47 31       	cpi	r20, 0x17	; 23
    2d72:	71 f4       	brne	.+28     	; 0x2d90 <PM_InterpretAVRISPPacket+0x2d2>
    2d74:	22 0f       	add	r18, r18
    2d76:	33 1f       	adc	r19, r19
    2d78:	22 0f       	add	r18, r18
    2d7a:	33 1f       	adc	r19, r19
    2d7c:	80 91 0c 01 	lds	r24, 0x010C
    2d80:	90 91 0d 01 	lds	r25, 0x010D
    2d84:	82 0f       	add	r24, r18
    2d86:	93 1f       	adc	r25, r19
    2d88:	9a 83       	std	Y+2, r25	; 0x02
    2d8a:	89 83       	std	Y+1, r24	; 0x01
    2d8c:	82 e0       	ldi	r24, 0x02	; 2
    2d8e:	0d c0       	rjmp	.+26     	; 0x2daa <PM_InterpretAVRISPPacket+0x2ec>
    2d90:	22 0f       	add	r18, r18
    2d92:	33 1f       	adc	r19, r19
    2d94:	22 0f       	add	r18, r18
    2d96:	33 1f       	adc	r19, r19
    2d98:	80 91 0a 01 	lds	r24, 0x010A
    2d9c:	90 91 0b 01 	lds	r25, 0x010B
    2da0:	82 0f       	add	r24, r18
    2da2:	93 1f       	adc	r25, r19
    2da4:	9a 83       	std	Y+2, r25	; 0x02
    2da6:	89 83       	std	Y+1, r24	; 0x01
    2da8:	83 e0       	ldi	r24, 0x03	; 3
    2daa:	80 93 4c 02 	sts	0x024C, r24
    2dae:	80 91 84 02 	lds	r24, 0x0284
    2db2:	90 91 85 02 	lds	r25, 0x0285
    2db6:	0a 97       	sbiw	r24, 0x0a	; 10
    2db8:	e8 f4       	brcc	.+58     	; 0x2df4 <PM_InterpretAVRISPPacket+0x336>
    2dba:	47 e3       	ldi	r20, 0x37	; 55
    2dbc:	e4 2e       	mov	r14, r20
    2dbe:	41 e0       	ldi	r20, 0x01	; 1
    2dc0:	f4 2e       	mov	r15, r20
    2dc2:	13 e0       	ldi	r17, 0x03	; 3
    2dc4:	f7 01       	movw	r30, r14
    2dc6:	61 91       	ld	r22, Z+
    2dc8:	7f 01       	movw	r14, r30
    2dca:	ce 01       	movw	r24, r28
    2dcc:	01 96       	adiw	r24, 0x01	; 1
    2dce:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
    2dd2:	89 81       	ldd	r24, Y+1	; 0x01
    2dd4:	9a 81       	ldd	r25, Y+2	; 0x02
    2dd6:	01 96       	adiw	r24, 0x01	; 1
    2dd8:	9a 83       	std	Y+2, r25	; 0x02
    2dda:	89 83       	std	Y+1, r24	; 0x01
    2ddc:	11 50       	subi	r17, 0x01	; 1
    2dde:	17 ff       	sbrs	r17, 7
    2de0:	f1 cf       	rjmp	.-30     	; 0x2dc4 <PM_InterpretAVRISPPacket+0x306>
    2de2:	80 91 84 02 	lds	r24, 0x0284
    2de6:	90 91 85 02 	lds	r25, 0x0285
    2dea:	01 96       	adiw	r24, 0x01	; 1
    2dec:	90 93 85 02 	sts	0x0285, r25
    2df0:	80 93 84 02 	sts	0x0284, r24
    2df4:	10 92 37 01 	sts	0x0137, r1
    2df8:	10 92 38 01 	sts	0x0138, r1
    2dfc:	0f c1       	rjmp	.+542    	; 0x301c <PM_InterpretAVRISPPacket+0x55e>
    2dfe:	82 e0       	ldi	r24, 0x02	; 2
    2e00:	90 e0       	ldi	r25, 0x00	; 0
    2e02:	90 93 33 01 	sts	0x0133, r25
    2e06:	80 93 32 01 	sts	0x0132, r24
    2e0a:	80 91 4b 02 	lds	r24, 0x024B
    2e0e:	81 30       	cpi	r24, 0x01	; 1
    2e10:	81 f1       	breq	.+96     	; 0x2e72 <PM_InterpretAVRISPPacket+0x3b4>
    2e12:	43 31       	cpi	r20, 0x13	; 19
    2e14:	41 f4       	brne	.+16     	; 0x2e26 <PM_InterpretAVRISPPacket+0x368>
    2e16:	80 91 1e 01 	lds	r24, 0x011E
    2e1a:	90 91 1f 01 	lds	r25, 0x011F
    2e1e:	9a 83       	std	Y+2, r25	; 0x02
    2e20:	89 83       	std	Y+1, r24	; 0x01
    2e22:	81 e0       	ldi	r24, 0x01	; 1
    2e24:	07 c0       	rjmp	.+14     	; 0x2e34 <PM_InterpretAVRISPPacket+0x376>
    2e26:	80 91 1c 01 	lds	r24, 0x011C
    2e2a:	90 91 1d 01 	lds	r25, 0x011D
    2e2e:	9a 83       	std	Y+2, r25	; 0x02
    2e30:	89 83       	std	Y+1, r24	; 0x01
    2e32:	80 e0       	ldi	r24, 0x00	; 0
    2e34:	0e 94 2f 14 	call	0x285e <PM_SetupDFAddressCounters>
    2e38:	80 91 84 02 	lds	r24, 0x0284
    2e3c:	90 91 85 02 	lds	r25, 0x0285
    2e40:	0e 94 94 0a 	call	0x1528 <DF_BufferWriteEnable>
    2e44:	81 e0       	ldi	r24, 0x01	; 1
    2e46:	80 93 4b 02 	sts	0x024B, r24
    2e4a:	37 e3       	ldi	r19, 0x37	; 55
    2e4c:	e3 2e       	mov	r14, r19
    2e4e:	31 e0       	ldi	r19, 0x01	; 1
    2e50:	f3 2e       	mov	r15, r19
    2e52:	18 e0       	ldi	r17, 0x08	; 8
    2e54:	f7 01       	movw	r30, r14
    2e56:	61 91       	ld	r22, Z+
    2e58:	7f 01       	movw	r14, r30
    2e5a:	ce 01       	movw	r24, r28
    2e5c:	01 96       	adiw	r24, 0x01	; 1
    2e5e:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
    2e62:	89 81       	ldd	r24, Y+1	; 0x01
    2e64:	9a 81       	ldd	r25, Y+2	; 0x02
    2e66:	01 96       	adiw	r24, 0x01	; 1
    2e68:	9a 83       	std	Y+2, r25	; 0x02
    2e6a:	89 83       	std	Y+1, r24	; 0x01
    2e6c:	11 50       	subi	r17, 0x01	; 1
    2e6e:	17 ff       	sbrs	r17, 7
    2e70:	f1 cf       	rjmp	.-30     	; 0x2e54 <PM_InterpretAVRISPPacket+0x396>
    2e72:	80 91 37 01 	lds	r24, 0x0137
    2e76:	99 27       	eor	r25, r25
    2e78:	18 2f       	mov	r17, r24
    2e7a:	00 27       	eor	r16, r16
    2e7c:	80 91 38 01 	lds	r24, 0x0138
    2e80:	99 27       	eor	r25, r25
    2e82:	08 2b       	or	r16, r24
    2e84:	19 2b       	or	r17, r25
    2e86:	ee 24       	eor	r14, r14
    2e88:	ff 24       	eor	r15, r15
    2e8a:	e0 16       	cp	r14, r16
    2e8c:	f1 06       	cpc	r15, r17
    2e8e:	78 f4       	brcc	.+30     	; 0x2eae <PM_InterpretAVRISPPacket+0x3f0>
    2e90:	80 e4       	ldi	r24, 0x40	; 64
    2e92:	c8 2e       	mov	r12, r24
    2e94:	81 e0       	ldi	r24, 0x01	; 1
    2e96:	d8 2e       	mov	r13, r24
    2e98:	f6 01       	movw	r30, r12
    2e9a:	81 91       	ld	r24, Z+
    2e9c:	6f 01       	movw	r12, r30
    2e9e:	0e 94 71 14 	call	0x28e2 <PM_StoreProgramByte>
    2ea2:	08 94       	sec
    2ea4:	e1 1c       	adc	r14, r1
    2ea6:	f1 1c       	adc	r15, r1
    2ea8:	e0 16       	cp	r14, r16
    2eaa:	f1 06       	cpc	r15, r17
    2eac:	a8 f3       	brcs	.-22     	; 0x2e98 <PM_InterpretAVRISPPacket+0x3da>
    2eae:	80 91 39 01 	lds	r24, 0x0139
    2eb2:	87 ff       	sbrs	r24, 7
    2eb4:	33 c0       	rjmp	.+102    	; 0x2f1c <PM_InterpretAVRISPPacket+0x45e>
    2eb6:	40 91 49 02 	lds	r20, 0x0249
    2eba:	50 91 4a 02 	lds	r21, 0x024A
    2ebe:	57 fd       	sbrc	r21, 7
    2ec0:	2d c0       	rjmp	.+90     	; 0x2f1c <PM_InterpretAVRISPPacket+0x45e>
    2ec2:	41 15       	cp	r20, r1
    2ec4:	51 05       	cpc	r21, r1
    2ec6:	51 f1       	breq	.+84     	; 0x2f1c <PM_InterpretAVRISPPacket+0x45e>
    2ec8:	80 91 4c 02 	lds	r24, 0x024C
    2ecc:	81 30       	cpi	r24, 0x01	; 1
    2ece:	29 f4       	brne	.+10     	; 0x2eda <PM_InterpretAVRISPPacket+0x41c>
    2ed0:	20 91 08 01 	lds	r18, 0x0108
    2ed4:	30 91 09 01 	lds	r19, 0x0109
    2ed8:	04 c0       	rjmp	.+8      	; 0x2ee2 <PM_InterpretAVRISPPacket+0x424>
    2eda:	20 91 06 01 	lds	r18, 0x0106
    2ede:	30 91 07 01 	lds	r19, 0x0107
    2ee2:	3a 83       	std	Y+2, r19	; 0x02
    2ee4:	29 83       	std	Y+1, r18	; 0x01
    2ee6:	85 2f       	mov	r24, r21
    2ee8:	99 27       	eor	r25, r25
    2eea:	68 2f       	mov	r22, r24
    2eec:	ce 01       	movw	r24, r28
    2eee:	01 96       	adiw	r24, 0x01	; 1
    2ef0:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
    2ef4:	89 81       	ldd	r24, Y+1	; 0x01
    2ef6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ef8:	01 96       	adiw	r24, 0x01	; 1
    2efa:	9a 83       	std	Y+2, r25	; 0x02
    2efc:	89 83       	std	Y+1, r24	; 0x01
    2efe:	60 91 49 02 	lds	r22, 0x0249
    2f02:	ce 01       	movw	r24, r28
    2f04:	01 96       	adiw	r24, 0x01	; 1
    2f06:	0e 94 c1 08 	call	0x1182 <eeprom_write_byte_169>
    2f0a:	80 91 49 02 	lds	r24, 0x0249
    2f0e:	90 91 4a 02 	lds	r25, 0x024A
    2f12:	90 68       	ori	r25, 0x80	; 128
    2f14:	90 93 4a 02 	sts	0x024A, r25
    2f18:	80 93 49 02 	sts	0x0249, r24
    2f1c:	10 92 37 01 	sts	0x0137, r1
    2f20:	7d c0       	rjmp	.+250    	; 0x301c <PM_InterpretAVRISPPacket+0x55e>
    2f22:	80 91 4b 02 	lds	r24, 0x024B
    2f26:	82 30       	cpi	r24, 0x02	; 2
    2f28:	11 f1       	breq	.+68     	; 0x2f6e <PM_InterpretAVRISPPacket+0x4b0>
    2f2a:	0e 94 a6 14 	call	0x294c <PM_CheckEndOfProgramming>
    2f2e:	0e 94 33 15 	call	0x2a66 <PM_CheckEndOfFuseLockStore>
    2f32:	90 e0       	ldi	r25, 0x00	; 0
    2f34:	80 91 36 01 	lds	r24, 0x0136
    2f38:	84 31       	cpi	r24, 0x14	; 20
    2f3a:	09 f4       	brne	.+2      	; 0x2f3e <PM_InterpretAVRISPPacket+0x480>
    2f3c:	91 e0       	ldi	r25, 0x01	; 1
    2f3e:	89 2f       	mov	r24, r25
    2f40:	0e 94 2f 14 	call	0x285e <PM_SetupDFAddressCounters>
    2f44:	60 91 84 02 	lds	r22, 0x0284
    2f48:	70 91 85 02 	lds	r23, 0x0285
    2f4c:	80 91 8b 02 	lds	r24, 0x028B
    2f50:	90 91 8c 02 	lds	r25, 0x028C
    2f54:	0e 94 51 0a 	call	0x14a2 <DF_ContinuousReadEnable>
    2f58:	82 e0       	ldi	r24, 0x02	; 2
    2f5a:	80 93 4b 02 	sts	0x024B, r24
    2f5e:	10 92 2d 01 	sts	0x012D, r1
    2f62:	10 92 2e 01 	sts	0x012E, r1
    2f66:	10 92 2f 01 	sts	0x012F, r1
    2f6a:	10 92 30 01 	sts	0x0130, r1
    2f6e:	80 91 37 01 	lds	r24, 0x0137
    2f72:	99 27       	eor	r25, r25
    2f74:	18 2f       	mov	r17, r24
    2f76:	00 27       	eor	r16, r16
    2f78:	80 91 38 01 	lds	r24, 0x0138
    2f7c:	99 27       	eor	r25, r25
    2f7e:	08 2b       	or	r16, r24
    2f80:	19 2b       	or	r17, r25
    2f82:	90 e0       	ldi	r25, 0x00	; 0
    2f84:	80 91 36 01 	lds	r24, 0x0136
    2f88:	84 31       	cpi	r24, 0x14	; 20
    2f8a:	09 f4       	brne	.+2      	; 0x2f8e <PM_InterpretAVRISPPacket+0x4d0>
    2f8c:	91 e0       	ldi	r25, 0x01	; 1
    2f8e:	89 2f       	mov	r24, r25
    2f90:	0e 94 b7 13 	call	0x276e <PM_GetStoredDataSize>
    2f94:	dc 01       	movw	r26, r24
    2f96:	cb 01       	movw	r24, r22
    2f98:	6c 01       	movw	r12, r24
    2f9a:	ee 24       	eor	r14, r14
    2f9c:	ff 24       	eor	r15, r15
    2f9e:	e0 16       	cp	r14, r16
    2fa0:	f1 06       	cpc	r15, r17
    2fa2:	20 f5       	brcc	.+72     	; 0x2fec <PM_InterpretAVRISPPacket+0x52e>
    2fa4:	f8 e3       	ldi	r31, 0x38	; 56
    2fa6:	af 2e       	mov	r10, r31
    2fa8:	f1 e0       	ldi	r31, 0x01	; 1
    2faa:	bf 2e       	mov	r11, r31
    2fac:	96 01       	movw	r18, r12
    2fae:	44 27       	eor	r20, r20
    2fb0:	55 27       	eor	r21, r21
    2fb2:	80 91 2d 01 	lds	r24, 0x012D
    2fb6:	90 91 2e 01 	lds	r25, 0x012E
    2fba:	a0 91 2f 01 	lds	r26, 0x012F
    2fbe:	b0 91 30 01 	lds	r27, 0x0130
    2fc2:	82 17       	cp	r24, r18
    2fc4:	93 07       	cpc	r25, r19
    2fc6:	a4 07       	cpc	r26, r20
    2fc8:	b5 07       	cpc	r27, r21
    2fca:	20 f4       	brcc	.+8      	; 0x2fd4 <PM_InterpretAVRISPPacket+0x516>
    2fcc:	80 e0       	ldi	r24, 0x00	; 0
    2fce:	0e 94 3f 09 	call	0x127e <SPI_SPITransmit>
    2fd2:	01 c0       	rjmp	.+2      	; 0x2fd6 <PM_InterpretAVRISPPacket+0x518>
    2fd4:	8f ef       	ldi	r24, 0xFF	; 255
    2fd6:	f5 01       	movw	r30, r10
    2fd8:	81 93       	st	Z+, r24
    2fda:	5f 01       	movw	r10, r30
    2fdc:	0e 94 15 0f 	call	0x1e2a <V2P_IncrementCurrAddress>
    2fe0:	08 94       	sec
    2fe2:	e1 1c       	adc	r14, r1
    2fe4:	f1 1c       	adc	r15, r1
    2fe6:	e0 16       	cp	r14, r16
    2fe8:	f1 06       	cpc	r15, r17
    2fea:	00 f3       	brcs	.-64     	; 0x2fac <PM_InterpretAVRISPPacket+0x4ee>
    2fec:	0d 5f       	subi	r16, 0xFD	; 253
    2fee:	1f 4f       	sbci	r17, 0xFF	; 255
    2ff0:	10 93 33 01 	sts	0x0133, r17
    2ff4:	00 93 32 01 	sts	0x0132, r16
    2ff8:	03 50       	subi	r16, 0x03	; 3
    2ffa:	10 40       	sbci	r17, 0x00	; 0
    2ffc:	10 92 37 01 	sts	0x0137, r1
    3000:	0a 5c       	subi	r16, 0xCA	; 202
    3002:	1e 4f       	sbci	r17, 0xFE	; 254
    3004:	f8 01       	movw	r30, r16
    3006:	12 82       	std	Z+2, r1	; 0x02
    3008:	09 c0       	rjmp	.+18     	; 0x301c <PM_InterpretAVRISPPacket+0x55e>
    300a:	81 e0       	ldi	r24, 0x01	; 1
    300c:	90 e0       	ldi	r25, 0x00	; 0
    300e:	90 93 33 01 	sts	0x0133, r25
    3012:	80 93 32 01 	sts	0x0132, r24
    3016:	89 ec       	ldi	r24, 0xC9	; 201
    3018:	80 93 37 01 	sts	0x0137, r24
    301c:	0e 94 3b 0e 	call	0x1c76 <V2P_SendPacket>
    3020:	22 96       	adiw	r28, 0x02	; 2
    3022:	0f b6       	in	r0, 0x3f	; 63
    3024:	f8 94       	cli
    3026:	de bf       	out	0x3e, r29	; 62
    3028:	0f be       	out	0x3f, r0	; 63
    302a:	cd bf       	out	0x3d, r28	; 61
    302c:	df 91       	pop	r29
    302e:	cf 91       	pop	r28
    3030:	1f 91       	pop	r17
    3032:	0f 91       	pop	r16
    3034:	ff 90       	pop	r15
    3036:	ef 90       	pop	r14
    3038:	df 90       	pop	r13
    303a:	cf 90       	pop	r12
    303c:	bf 90       	pop	r11
    303e:	af 90       	pop	r10
    3040:	08 95       	ret

00003042 <PM_SendFuseLockBytes>:
	}
}

void PM_SendFuseLockBytes(uint8_t Type)
{
    3042:	0f 93       	push	r16
    3044:	1f 93       	push	r17
    3046:	cf 93       	push	r28
    3048:	df 93       	push	r29
    304a:	cd b7       	in	r28, 0x3d	; 61
    304c:	de b7       	in	r29, 0x3e	; 62
    304e:	22 97       	sbiw	r28, 0x02	; 2
    3050:	0f b6       	in	r0, 0x3f	; 63
    3052:	f8 94       	cli
    3054:	de bf       	out	0x3e, r29	; 62
    3056:	0f be       	out	0x3f, r0	; 63
    3058:	cd bf       	out	0x3d, r28	; 61
    305a:	08 2f       	mov	r16, r24
	uint16_t EEPROMAddress;
	uint8_t  TotalBytes;
	
	EEPROMAddress = ((Type == TYPE_FUSE)? Prog_TotalFuseBytes : Prog_TotalLockBytes);
    305c:	82 30       	cpi	r24, 0x02	; 2
    305e:	29 f4       	brne	.+10     	; 0x306a <PM_SendFuseLockBytes+0x28>
    3060:	80 91 10 01 	lds	r24, 0x0110
    3064:	90 91 11 01 	lds	r25, 0x0111
    3068:	04 c0       	rjmp	.+8      	; 0x3072 <PM_SendFuseLockBytes+0x30>
    306a:	80 91 0e 01 	lds	r24, 0x010E
    306e:	90 91 0f 01 	lds	r25, 0x010F
    3072:	9a 83       	std	Y+2, r25	; 0x02
    3074:	89 83       	std	Y+1, r24	; 0x01

	TotalBytes = eeprom_read_byte_169(&EEPROMAddress); // Get the total number of stored fuse/lock bytes
    3076:	ce 01       	movw	r24, r28
    3078:	01 96       	adiw	r24, 0x01	; 1
    307a:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
    307e:	18 2f       	mov	r17, r24
			
	EEPROMAddress = ((Type == TYPE_FUSE)? Prog_FuseBytes : Prog_LockBytes); // Set the EEPROM pointer to the fuse/lock bytes start (each fuse or lock byte takes four bytes in EEPROM)
    3080:	02 30       	cpi	r16, 0x02	; 2
    3082:	29 f4       	brne	.+10     	; 0x308e <PM_SendFuseLockBytes+0x4c>
    3084:	80 91 0c 01 	lds	r24, 0x010C
    3088:	90 91 0d 01 	lds	r25, 0x010D
    308c:	04 c0       	rjmp	.+8      	; 0x3096 <PM_SendFuseLockBytes+0x54>
    308e:	80 91 0a 01 	lds	r24, 0x010A
    3092:	90 91 0b 01 	lds	r25, 0x010B
    3096:	9a 83       	std	Y+2, r25	; 0x02
    3098:	89 83       	std	Y+1, r24	; 0x01

	while (TotalBytes--)                              // Write each of the fuse/lock bytes stored in memory to the slave AVR
	{
		for (uint8_t CommandByte = 0; CommandByte < 4; CommandByte++)      // Write each individual command byte
		{
			USI_SPITransmit(eeprom_read_byte_169(&EEPROMAddress));
			EEPROMAddress++;
		}
		
		// Add some delay before programming next byte, if there is one:
		if (TotalBytes)
		   MAIN_Delay10MS(5);
    309a:	11 50       	subi	r17, 0x01	; 1
    309c:	1f 3f       	cpi	r17, 0xFF	; 255
    309e:	b1 f0       	breq	.+44     	; 0x30cc <PM_SendFuseLockBytes+0x8a>
    30a0:	03 e0       	ldi	r16, 0x03	; 3
    30a2:	ce 01       	movw	r24, r28
    30a4:	01 96       	adiw	r24, 0x01	; 1
    30a6:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
    30aa:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    30ae:	89 81       	ldd	r24, Y+1	; 0x01
    30b0:	9a 81       	ldd	r25, Y+2	; 0x02
    30b2:	01 96       	adiw	r24, 0x01	; 1
    30b4:	9a 83       	std	Y+2, r25	; 0x02
    30b6:	89 83       	std	Y+1, r24	; 0x01
    30b8:	01 50       	subi	r16, 0x01	; 1
    30ba:	07 ff       	sbrs	r16, 7
    30bc:	f2 cf       	rjmp	.-28     	; 0x30a2 <PM_SendFuseLockBytes+0x60>
    30be:	11 23       	and	r17, r17
    30c0:	19 f0       	breq	.+6      	; 0x30c8 <PM_SendFuseLockBytes+0x86>
    30c2:	85 e0       	ldi	r24, 0x05	; 5
    30c4:	0e 94 27 02 	call	0x44e <MAIN_Delay10MS>
    30c8:	11 50       	subi	r17, 0x01	; 1
    30ca:	50 f7       	brcc	.-44     	; 0x30a0 <PM_SendFuseLockBytes+0x5e>
    30cc:	22 96       	adiw	r28, 0x02	; 2
    30ce:	0f b6       	in	r0, 0x3f	; 63
    30d0:	f8 94       	cli
    30d2:	de bf       	out	0x3e, r29	; 62
    30d4:	0f be       	out	0x3f, r0	; 63
    30d6:	cd bf       	out	0x3d, r28	; 61
    30d8:	df 91       	pop	r29
    30da:	cf 91       	pop	r28
    30dc:	1f 91       	pop	r17
    30de:	0f 91       	pop	r16
    30e0:	08 95       	ret

000030e2 <PM_SendEraseCommand>:
	}
}

void PM_SendEraseCommand(void)
{
    30e2:	0f 93       	push	r16
    30e4:	1f 93       	push	r17
    30e6:	cf 93       	push	r28
    30e8:	df 93       	push	r29
    30ea:	cd b7       	in	r28, 0x3d	; 61
    30ec:	de b7       	in	r29, 0x3e	; 62
    30ee:	22 97       	sbiw	r28, 0x02	; 2
    30f0:	0f b6       	in	r0, 0x3f	; 63
    30f2:	f8 94       	cli
    30f4:	de bf       	out	0x3e, r29	; 62
    30f6:	0f be       	out	0x3f, r0	; 63
    30f8:	cd bf       	out	0x3d, r28	; 61
	uint16_t EEPROMAddress;

	EEPROMAddress = Prog_EraseChip + 2;               // Start of the erase commands
    30fa:	80 91 18 01 	lds	r24, 0x0118
    30fe:	90 91 19 01 	lds	r25, 0x0119
    3102:	02 96       	adiw	r24, 0x02	; 2
    3104:	9a 83       	std	Y+2, r25	; 0x02
    3106:	89 83       	std	Y+1, r24	; 0x01
    3108:	13 e0       	ldi	r17, 0x03	; 3
			
	for (uint8_t B = 0; B < 4 ; B++)                  // Read out the erase chip command bytes
	{
		USI_SPITransmit(eeprom_read_byte_169(&EEPROMAddress)); // Send the erase chip commands
    310a:	ce 01       	movw	r24, r28
    310c:	01 96       	adiw	r24, 0x01	; 1
    310e:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
    3112:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
		EEPROMAddress++;
    3116:	89 81       	ldd	r24, Y+1	; 0x01
    3118:	9a 81       	ldd	r25, Y+2	; 0x02
    311a:	01 96       	adiw	r24, 0x01	; 1
    311c:	9a 83       	std	Y+2, r25	; 0x02
    311e:	89 83       	std	Y+1, r24	; 0x01
    3120:	11 50       	subi	r17, 0x01	; 1
    3122:	17 ff       	sbrs	r17, 7
    3124:	f2 cf       	rjmp	.-28     	; 0x310a <PM_SendEraseCommand+0x28>
	}
			
	EEPROMAddress = Prog_EraseChip + 1;                // Poll mode flag address
    3126:	00 91 18 01 	lds	r16, 0x0118
    312a:	10 91 19 01 	lds	r17, 0x0119
    312e:	0f 5f       	subi	r16, 0xFF	; 255
    3130:	1f 4f       	sbci	r17, 0xFF	; 255
    3132:	1a 83       	std	Y+2, r17	; 0x02
    3134:	09 83       	std	Y+1, r16	; 0x01
    3136:	01 50       	subi	r16, 0x01	; 1
    3138:	10 40       	sbci	r17, 0x00	; 0
	if (eeprom_read_byte_169(&EEPROMAddress))          // Value of 1 indicates a busy flag test
    313a:	ce 01       	movw	r24, r28
    313c:	01 96       	adiw	r24, 0x01	; 1
    313e:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
    3142:	88 23       	and	r24, r24
    3144:	59 f0       	breq	.+22     	; 0x315c <PM_SendEraseCommand+0x7a>
	{
		do
			USI_SPITransmitWord(0xF000);
    3146:	80 e0       	ldi	r24, 0x00	; 0
    3148:	90 ef       	ldi	r25, 0xF0	; 240
    314a:	0e 94 f0 09 	call	0x13e0 <USI_SPITransmitWord>
    314e:	80 e0       	ldi	r24, 0x00	; 0
    3150:	90 e0       	ldi	r25, 0x00	; 0
    3152:	0e 94 f0 09 	call	0x13e0 <USI_SPITransmitWord>
    3156:	80 fd       	sbrc	r24, 0
    3158:	f6 cf       	rjmp	.-20     	; 0x3146 <PM_SendEraseCommand+0x64>
    315a:	08 c0       	rjmp	.+16     	; 0x316c <PM_SendEraseCommand+0x8a>
		while (USI_SPITransmitWord(0x0000) & 0x01);
	}
	else                                               // Cleared flag means use a predefined delay
	{
		EEPROMAddress = Prog_EraseChip;                 // Delay value address			
    315c:	1a 83       	std	Y+2, r17	; 0x02
    315e:	09 83       	std	Y+1, r16	; 0x01
		MAIN_Delay1MS(eeprom_read_byte_169(&EEPROMAddress)); // Wait the erase delay
    3160:	ce 01       	movw	r24, r28
    3162:	01 96       	adiw	r24, 0x01	; 1
    3164:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
    3168:	0e 94 03 03 	call	0x606 <MAIN_Delay1MS>
    316c:	22 96       	adiw	r28, 0x02	; 2
    316e:	0f b6       	in	r0, 0x3f	; 63
    3170:	f8 94       	cli
    3172:	de bf       	out	0x3e, r29	; 62
    3174:	0f be       	out	0x3f, r0	; 63
    3176:	cd bf       	out	0x3d, r28	; 61
    3178:	df 91       	pop	r29
    317a:	cf 91       	pop	r28
    317c:	1f 91       	pop	r17
    317e:	0f 91       	pop	r16
    3180:	08 95       	ret

00003182 <PM_CreateProgrammingPackets>:
	}
}

void PM_CreateProgrammingPackets(uint8_t Type)
{			
    3182:	2f 92       	push	r2
    3184:	3f 92       	push	r3
    3186:	4f 92       	push	r4
    3188:	5f 92       	push	r5
    318a:	6f 92       	push	r6
    318c:	7f 92       	push	r7
    318e:	8f 92       	push	r8
    3190:	9f 92       	push	r9
    3192:	af 92       	push	r10
    3194:	bf 92       	push	r11
    3196:	cf 92       	push	r12
    3198:	df 92       	push	r13
    319a:	ef 92       	push	r14
    319c:	ff 92       	push	r15
    319e:	0f 93       	push	r16
    31a0:	1f 93       	push	r17
    31a2:	cf 93       	push	r28
    31a4:	df 93       	push	r29
    31a6:	cd b7       	in	r28, 0x3d	; 61
    31a8:	de b7       	in	r29, 0x3e	; 62
    31aa:	23 97       	sbiw	r28, 0x03	; 3
    31ac:	0f b6       	in	r0, 0x3f	; 63
    31ae:	f8 94       	cli
    31b0:	de bf       	out	0x3e, r29	; 62
    31b2:	0f be       	out	0x3f, r0	; 63
    31b4:	cd bf       	out	0x3d, r28	; 61
    31b6:	18 2f       	mov	r17, r24
	uint32_t BytesRead       = 0;
    31b8:	88 24       	eor	r8, r8
    31ba:	99 24       	eor	r9, r9
    31bc:	54 01       	movw	r10, r8
	uint32_t BytesToRead     = PM_GetStoredDataSize(Type);      // Get the byte size of the stored program
    31be:	0e 94 b7 13 	call	0x276e <PM_GetStoredDataSize>
    31c2:	1b 01       	movw	r2, r22
    31c4:	2c 01       	movw	r4, r24
	uint16_t BytesPerProgram;
	uint16_t EEPROMAddress;
	uint16_t PageLength;
	uint8_t  ContinuedPage   = FALSE;
    31c6:	1b 82       	std	Y+3, r1	; 0x03

	EEPROMAddress = ((Type == TYPE_FLASH)? Prog_PageLength : Prog_EPageLength);
    31c8:	11 30       	cpi	r17, 0x01	; 1
    31ca:	29 f4       	brne	.+10     	; 0x31d6 <PM_CreateProgrammingPackets+0x54>
    31cc:	80 91 08 01 	lds	r24, 0x0108
    31d0:	90 91 09 01 	lds	r25, 0x0109
    31d4:	04 c0       	rjmp	.+8      	; 0x31de <PM_CreateProgrammingPackets+0x5c>
    31d6:	80 91 06 01 	lds	r24, 0x0106
    31da:	90 91 07 01 	lds	r25, 0x0107
    31de:	9a 83       	std	Y+2, r25	; 0x02
    31e0:	89 83       	std	Y+1, r24	; 0x01
	PageLength    = ((uint16_t)eeprom_read_byte_169(&EEPROMAddress) << 8);
    31e2:	ce 01       	movw	r24, r28
    31e4:	01 96       	adiw	r24, 0x01	; 1
    31e6:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
    31ea:	99 27       	eor	r25, r25
    31ec:	78 2e       	mov	r7, r24
    31ee:	66 24       	eor	r6, r6
	EEPROMAddress++;
    31f0:	89 81       	ldd	r24, Y+1	; 0x01
    31f2:	9a 81       	ldd	r25, Y+2	; 0x02
    31f4:	01 96       	adiw	r24, 0x01	; 1
    31f6:	9a 83       	std	Y+2, r25	; 0x02
    31f8:	89 83       	std	Y+1, r24	; 0x01
	PageLength   |= (eeprom_read_byte_169(&EEPROMAddress));
    31fa:	ce 01       	movw	r24, r28
    31fc:	01 96       	adiw	r24, 0x01	; 1
    31fe:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
    3202:	99 27       	eor	r25, r25
    3204:	68 2a       	or	r6, r24
    3206:	79 2a       	or	r7, r25
	
	CurrAddress = 0;
    3208:	10 92 2d 01 	sts	0x012D, r1
    320c:	10 92 2e 01 	sts	0x012E, r1
    3210:	10 92 2f 01 	sts	0x012F, r1
    3214:	10 92 30 01 	sts	0x0130, r1

	if (Type == TYPE_FLASH)
    3218:	11 30       	cpi	r17, 0x01	; 1
    321a:	69 f4       	brne	.+26     	; 0x3236 <PM_CreateProgrammingPackets+0xb4>
	{
		EEPROMAddress = Prog_WriteProgram;             // Set the EEPROM pointer to the write flash command bytes location
    321c:	80 91 1e 01 	lds	r24, 0x011E
    3220:	90 91 1f 01 	lds	r25, 0x011F
    3224:	9a 83       	std	Y+2, r25	; 0x02
    3226:	89 83       	std	Y+1, r24	; 0x01
		DF_ContinuousReadEnable(0, 0);
    3228:	60 e0       	ldi	r22, 0x00	; 0
    322a:	70 e0       	ldi	r23, 0x00	; 0
    322c:	cb 01       	movw	r24, r22
    322e:	0e 94 51 0a 	call	0x14a2 <DF_ContinuousReadEnable>
		PacketBytes[0] = CMD_PROGRAM_FLASH_ISP;
    3232:	83 e1       	ldi	r24, 0x13	; 19
    3234:	0d c0       	rjmp	.+26     	; 0x3250 <PM_CreateProgrammingPackets+0xce>
	}
	else
	{
		EEPROMAddress = Prog_WriteEEPROM;              // Set the EEPROM pointer to the write EEPROM command bytes location
    3236:	80 91 1c 01 	lds	r24, 0x011C
    323a:	90 91 1d 01 	lds	r25, 0x011D
    323e:	9a 83       	std	Y+2, r25	; 0x02
    3240:	89 83       	std	Y+1, r24	; 0x01
		DF_ContinuousReadEnable(PM_EEPROM_OFFSET / DF_INTERNALDF_BUFFBYTES, PM_EEPROM_OFFSET % DF_INTERNALDF_BUFFBYTES); // Start read from the EEPROM offset location
    3242:	60 ee       	ldi	r22, 0xE0	; 224
    3244:	70 e0       	ldi	r23, 0x00	; 0
    3246:	84 ee       	ldi	r24, 0xE4	; 228
    3248:	93 e0       	ldi	r25, 0x03	; 3
    324a:	0e 94 51 0a 	call	0x14a2 <DF_ContinuousReadEnable>
		PacketBytes[0] = CMD_PROGRAM_EEPROM_ISP;
    324e:	85 e1       	ldi	r24, 0x15	; 21
    3250:	80 93 36 01 	sts	0x0136, r24
    3254:	f7 e3       	ldi	r31, 0x37	; 55
    3256:	ef 2e       	mov	r14, r31
    3258:	f1 e0       	ldi	r31, 0x01	; 1
    325a:	ff 2e       	mov	r15, r31
    325c:	18 e0       	ldi	r17, 0x08	; 8
	}

	for (uint8_t B = 1; B <= 9 ; B++)                 // Load in the write data command bytes
	{
		PacketBytes[B] = eeprom_read_byte_169(&EEPROMAddress); // Synthesise a write packet header
    325e:	ce 01       	movw	r24, r28
    3260:	01 96       	adiw	r24, 0x01	; 1
    3262:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
    3266:	f7 01       	movw	r30, r14
    3268:	81 93       	st	Z+, r24
    326a:	7f 01       	movw	r14, r30
		EEPROMAddress++;                               // Increment the EEPROM location counter
    326c:	89 81       	ldd	r24, Y+1	; 0x01
    326e:	9a 81       	ldd	r25, Y+2	; 0x02
    3270:	01 96       	adiw	r24, 0x01	; 1
    3272:	9a 83       	std	Y+2, r25	; 0x02
    3274:	89 83       	std	Y+1, r24	; 0x01
    3276:	11 50       	subi	r17, 0x01	; 1
    3278:	17 ff       	sbrs	r17, 7
    327a:	f1 cf       	rjmp	.-30     	; 0x325e <PM_CreateProgrammingPackets+0xdc>
	}
	
	BytesPerProgram = ((uint16_t)PacketBytes[1] << 8)
    327c:	80 91 37 01 	lds	r24, 0x0137
    3280:	99 27       	eor	r25, r25
    3282:	d8 2e       	mov	r13, r24
    3284:	cc 24       	eor	r12, r12
    3286:	80 91 38 01 	lds	r24, 0x0138
    328a:	99 27       	eor	r25, r25
    328c:	c8 2a       	or	r12, r24
    328e:	d9 2a       	or	r13, r25
	                | PacketBytes[2];

	while (BytesRead < BytesToRead)
	{
		if (PacketBytes[3] & ISPCC_PROG_MODE_PAGE)
		{
			if (PageLength > 160) // Max 160 bytes at a time
			{
				if (!(ContinuedPage))                      // Start of a new page, program in the first 150 bytes
				{
					BytesPerProgram = 160;
					PacketBytes[3] &= ~ISPCC_PROG_MODE_PAGEDONE;		
					ContinuedPage = TRUE;
				}
				else                                       // Middle of a page, program in the remainder
				{
					BytesPerProgram = PageLength - 160;
					PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
					ContinuedPage = FALSE;
				}
				
				for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page				

				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);
				PacketBytes[2] = (uint8_t)(BytesPerProgram);

				BytesRead += BytesPerProgram;                         // Increment the counter
			}
			else
			{
				for (uint16_t LoadB = 0; LoadB < PageLength; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page
			
				PacketBytes[1]  = (uint8_t)(PageLength >> 8);
				PacketBytes[2]  = (uint8_t)(PageLength);
				PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;

				BytesRead     += PageLength;                          // Increment the counter
			}
		}
		else
		{
			if ((BytesRead + BytesPerProgram) > BytesToRead)        // Less than a whole BytesPerProgram left of data to write
			{
				BytesPerProgram = BytesToRead - BytesRead;          // Next lot of bytes will be the remaining data length
				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);   // \. Save the new length
				PacketBytes[2] = (uint8_t)(BytesPerProgram);        // /  into the data packet
			}

			for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
				PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);    // Load in the page
			
			BytesRead += BytesPerProgram;                           // Increment the counter
		}
	
		if (!(BytesRead & 0xFFFF) && (BytesRead & 0x00FF0000))      // Extended address required
		{
			USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);            // Load extended address command
			USI_SPITransmit(0x00);
			USI_SPITransmit((BytesRead & 0x00FF0000) >> 16);        // The 3rd byte of the long holds the extended address
			USI_SPITransmit(0x00);
		}

		ISPCC_ProgramChip();                                        // Start the program cycle
    3290:	82 14       	cp	r8, r2
    3292:	93 04       	cpc	r9, r3
    3294:	a4 04       	cpc	r10, r4
    3296:	b5 04       	cpc	r11, r5
    3298:	08 f0       	brcs	.+2      	; 0x329c <PM_CreateProgrammingPackets+0x11a>
    329a:	b7 c0       	rjmp	.+366    	; 0x340a <PM_CreateProgrammingPackets+0x288>
    329c:	20 91 39 01 	lds	r18, 0x0139
    32a0:	82 2f       	mov	r24, r18
    32a2:	99 27       	eor	r25, r25
    32a4:	ac 01       	movw	r20, r24
    32a6:	41 70       	andi	r20, 0x01	; 1
    32a8:	50 70       	andi	r21, 0x00	; 0
    32aa:	80 ff       	sbrs	r24, 0
    32ac:	58 c0       	rjmp	.+176    	; 0x335e <PM_CreateProgrammingPackets+0x1dc>
    32ae:	f1 ea       	ldi	r31, 0xA1	; 161
    32b0:	6f 16       	cp	r6, r31
    32b2:	71 04       	cpc	r7, r1
    32b4:	88 f1       	brcs	.+98     	; 0x3318 <PM_CreateProgrammingPackets+0x196>
    32b6:	8b 81       	ldd	r24, Y+3	; 0x03
    32b8:	88 23       	and	r24, r24
    32ba:	49 f4       	brne	.+18     	; 0x32ce <PM_CreateProgrammingPackets+0x14c>
    32bc:	70 ea       	ldi	r23, 0xA0	; 160
    32be:	c7 2e       	mov	r12, r23
    32c0:	d1 2c       	mov	r13, r1
    32c2:	2f 77       	andi	r18, 0x7F	; 127
    32c4:	20 93 39 01 	sts	0x0139, r18
    32c8:	e1 e0       	ldi	r30, 0x01	; 1
    32ca:	eb 83       	std	Y+3, r30	; 0x03
    32cc:	0a c0       	rjmp	.+20     	; 0x32e2 <PM_CreateProgrammingPackets+0x160>
    32ce:	60 e6       	ldi	r22, 0x60	; 96
    32d0:	c6 2e       	mov	r12, r22
    32d2:	6f ef       	ldi	r22, 0xFF	; 255
    32d4:	d6 2e       	mov	r13, r22
    32d6:	c6 0c       	add	r12, r6
    32d8:	d7 1c       	adc	r13, r7
    32da:	20 68       	ori	r18, 0x80	; 128
    32dc:	20 93 39 01 	sts	0x0139, r18
    32e0:	1b 82       	std	Y+3, r1	; 0x03
    32e2:	00 e0       	ldi	r16, 0x00	; 0
    32e4:	10 e0       	ldi	r17, 0x00	; 0
    32e6:	0c 15       	cp	r16, r12
    32e8:	1d 05       	cpc	r17, r13
    32ea:	78 f4       	brcc	.+30     	; 0x330a <PM_CreateProgrammingPackets+0x188>
    32ec:	50 e4       	ldi	r21, 0x40	; 64
    32ee:	e5 2e       	mov	r14, r21
    32f0:	51 e0       	ldi	r21, 0x01	; 1
    32f2:	f5 2e       	mov	r15, r21
    32f4:	80 e0       	ldi	r24, 0x00	; 0
    32f6:	0e 94 3f 09 	call	0x127e <SPI_SPITransmit>
    32fa:	f7 01       	movw	r30, r14
    32fc:	81 93       	st	Z+, r24
    32fe:	7f 01       	movw	r14, r30
    3300:	0f 5f       	subi	r16, 0xFF	; 255
    3302:	1f 4f       	sbci	r17, 0xFF	; 255
    3304:	0c 15       	cp	r16, r12
    3306:	1d 05       	cpc	r17, r13
    3308:	a8 f3       	brcs	.-22     	; 0x32f4 <PM_CreateProgrammingPackets+0x172>
    330a:	8d 2d       	mov	r24, r13
    330c:	99 27       	eor	r25, r25
    330e:	80 93 37 01 	sts	0x0137, r24
    3312:	c0 92 38 01 	sts	0x0138, r12
    3316:	4b c0       	rjmp	.+150    	; 0x33ae <PM_CreateProgrammingPackets+0x22c>
    3318:	00 e0       	ldi	r16, 0x00	; 0
    331a:	10 e0       	ldi	r17, 0x00	; 0
    331c:	06 15       	cp	r16, r6
    331e:	17 05       	cpc	r17, r7
    3320:	78 f4       	brcc	.+30     	; 0x3340 <PM_CreateProgrammingPackets+0x1be>
    3322:	30 e4       	ldi	r19, 0x40	; 64
    3324:	e3 2e       	mov	r14, r19
    3326:	31 e0       	ldi	r19, 0x01	; 1
    3328:	f3 2e       	mov	r15, r19
    332a:	80 e0       	ldi	r24, 0x00	; 0
    332c:	0e 94 3f 09 	call	0x127e <SPI_SPITransmit>
    3330:	f7 01       	movw	r30, r14
    3332:	81 93       	st	Z+, r24
    3334:	7f 01       	movw	r14, r30
    3336:	0f 5f       	subi	r16, 0xFF	; 255
    3338:	1f 4f       	sbci	r17, 0xFF	; 255
    333a:	06 15       	cp	r16, r6
    333c:	17 05       	cpc	r17, r7
    333e:	a8 f3       	brcs	.-22     	; 0x332a <PM_CreateProgrammingPackets+0x1a8>
    3340:	87 2d       	mov	r24, r7
    3342:	99 27       	eor	r25, r25
    3344:	80 93 37 01 	sts	0x0137, r24
    3348:	60 92 38 01 	sts	0x0138, r6
    334c:	80 91 39 01 	lds	r24, 0x0139
    3350:	80 68       	ori	r24, 0x80	; 128
    3352:	80 93 39 01 	sts	0x0139, r24
    3356:	c3 01       	movw	r24, r6
    3358:	aa 27       	eor	r26, r26
    335a:	bb 27       	eor	r27, r27
    335c:	2b c0       	rjmp	.+86     	; 0x33b4 <PM_CreateProgrammingPackets+0x232>
    335e:	c6 01       	movw	r24, r12
    3360:	aa 27       	eor	r26, r26
    3362:	bb 27       	eor	r27, r27
    3364:	88 0d       	add	r24, r8
    3366:	99 1d       	adc	r25, r9
    3368:	aa 1d       	adc	r26, r10
    336a:	bb 1d       	adc	r27, r11
    336c:	28 16       	cp	r2, r24
    336e:	39 06       	cpc	r3, r25
    3370:	4a 06       	cpc	r4, r26
    3372:	5b 06       	cpc	r5, r27
    3374:	48 f4       	brcc	.+18     	; 0x3388 <PM_CreateProgrammingPackets+0x206>
    3376:	61 01       	movw	r12, r2
    3378:	c8 18       	sub	r12, r8
    337a:	d9 08       	sbc	r13, r9
    337c:	8d 2d       	mov	r24, r13
    337e:	99 27       	eor	r25, r25
    3380:	80 93 37 01 	sts	0x0137, r24
    3384:	c0 92 38 01 	sts	0x0138, r12
    3388:	8a 01       	movw	r16, r20
    338a:	4c 15       	cp	r20, r12
    338c:	5d 05       	cpc	r21, r13
    338e:	78 f4       	brcc	.+30     	; 0x33ae <PM_CreateProgrammingPackets+0x22c>
    3390:	80 e4       	ldi	r24, 0x40	; 64
    3392:	e8 2e       	mov	r14, r24
    3394:	81 e0       	ldi	r24, 0x01	; 1
    3396:	f8 2e       	mov	r15, r24
    3398:	80 e0       	ldi	r24, 0x00	; 0
    339a:	0e 94 3f 09 	call	0x127e <SPI_SPITransmit>
    339e:	f7 01       	movw	r30, r14
    33a0:	81 93       	st	Z+, r24
    33a2:	7f 01       	movw	r14, r30
    33a4:	0f 5f       	subi	r16, 0xFF	; 255
    33a6:	1f 4f       	sbci	r17, 0xFF	; 255
    33a8:	0c 15       	cp	r16, r12
    33aa:	1d 05       	cpc	r17, r13
    33ac:	a8 f3       	brcs	.-22     	; 0x3398 <PM_CreateProgrammingPackets+0x216>
    33ae:	c6 01       	movw	r24, r12
    33b0:	aa 27       	eor	r26, r26
    33b2:	bb 27       	eor	r27, r27
    33b4:	88 0e       	add	r8, r24
    33b6:	99 1e       	adc	r9, r25
    33b8:	aa 1e       	adc	r10, r26
    33ba:	bb 1e       	adc	r11, r27
    33bc:	81 14       	cp	r8, r1
    33be:	91 04       	cpc	r9, r1
    33c0:	e1 f4       	brne	.+56     	; 0x33fa <PM_CreateProgrammingPackets+0x278>
    33c2:	e1 2c       	mov	r14, r1
    33c4:	f1 2c       	mov	r15, r1
    33c6:	bf ef       	ldi	r27, 0xFF	; 255
    33c8:	0b 2f       	mov	r16, r27
    33ca:	11 2d       	mov	r17, r1
    33cc:	e8 20       	and	r14, r8
    33ce:	f9 20       	and	r15, r9
    33d0:	0a 21       	and	r16, r10
    33d2:	1b 21       	and	r17, r11
    33d4:	e1 14       	cp	r14, r1
    33d6:	f1 04       	cpc	r15, r1
    33d8:	01 05       	cpc	r16, r1
    33da:	11 05       	cpc	r17, r1
    33dc:	71 f0       	breq	.+28     	; 0x33fa <PM_CreateProgrammingPackets+0x278>
    33de:	8d e4       	ldi	r24, 0x4D	; 77
    33e0:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    33e4:	80 e0       	ldi	r24, 0x00	; 0
    33e6:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    33ea:	c8 01       	movw	r24, r16
    33ec:	aa 27       	eor	r26, r26
    33ee:	bb 27       	eor	r27, r27
    33f0:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    33f4:	80 e0       	ldi	r24, 0x00	; 0
    33f6:	0e 94 c5 09 	call	0x138a <USI_SPITransmit>
    33fa:	0e 94 5a 11 	call	0x22b4 <ISPCC_ProgramChip>
    33fe:	82 14       	cp	r8, r2
    3400:	93 04       	cpc	r9, r3
    3402:	a4 04       	cpc	r10, r4
    3404:	b5 04       	cpc	r11, r5
    3406:	08 f4       	brcc	.+2      	; 0x340a <PM_CreateProgrammingPackets+0x288>
    3408:	49 cf       	rjmp	.-366    	; 0x329c <PM_CreateProgrammingPackets+0x11a>
    340a:	23 96       	adiw	r28, 0x03	; 3
    340c:	0f b6       	in	r0, 0x3f	; 63
    340e:	f8 94       	cli
    3410:	de bf       	out	0x3e, r29	; 62
    3412:	0f be       	out	0x3f, r0	; 63
    3414:	cd bf       	out	0x3d, r28	; 61
    3416:	df 91       	pop	r29
    3418:	cf 91       	pop	r28
    341a:	1f 91       	pop	r17
    341c:	0f 91       	pop	r16
    341e:	ff 90       	pop	r15
    3420:	ef 90       	pop	r14
    3422:	df 90       	pop	r13
    3424:	cf 90       	pop	r12
    3426:	bf 90       	pop	r11
    3428:	af 90       	pop	r10
    342a:	9f 90       	pop	r9
    342c:	8f 90       	pop	r8
    342e:	7f 90       	pop	r7
    3430:	6f 90       	pop	r6
    3432:	5f 90       	pop	r5
    3434:	4f 90       	pop	r4
    3436:	3f 90       	pop	r3
    3438:	2f 90       	pop	r2
    343a:	08 95       	ret

0000343c <PM_ShowStoredItemSizes>:
	}
}

void PM_ShowStoredItemSizes(void)
{
    343c:	1f 93       	push	r17
    343e:	cf 93       	push	r28
    3440:	df 93       	push	r29
    3442:	cd b7       	in	r28, 0x3d	; 61
    3444:	de b7       	in	r29, 0x3e	; 62
    3446:	2e 97       	sbiw	r28, 0x0e	; 14
    3448:	0f b6       	in	r0, 0x3f	; 63
    344a:	f8 94       	cli
    344c:	de bf       	out	0x3e, r29	; 62
    344e:	0f be       	out	0x3f, r0	; 63
    3450:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[14];
	uint8_t ItemInfoIndex = 0;
    3452:	10 e0       	ldi	r17, 0x00	; 0
	uint8_t TempB;
	
	JoyStatus = 1;
    3454:	81 e0       	ldi	r24, 0x01	; 1
    3456:	8e bb       	out	0x1e, r24	; 30
	
	while (1)
	{
		if (JoyStatus)                           // Joystick is in the non-center position
    3458:	8e b3       	in	r24, 0x1e	; 30
    345a:	88 23       	and	r24, r24
    345c:	e9 f3       	breq	.-6      	; 0x3458 <PM_ShowStoredItemSizes+0x1c>
		{
			if (JoyStatus & JOY_UP)              // Previous item
    345e:	f6 9b       	sbis	0x1e, 6	; 30
    3460:	06 c0       	rjmp	.+12     	; 0x346e <PM_ShowStoredItemSizes+0x32>
				(ItemInfoIndex == 0)? ItemInfoIndex = 3 : ItemInfoIndex--;
    3462:	11 23       	and	r17, r17
    3464:	11 f4       	brne	.+4      	; 0x346a <PM_ShowStoredItemSizes+0x2e>
    3466:	13 e0       	ldi	r17, 0x03	; 3
    3468:	0c c0       	rjmp	.+24     	; 0x3482 <PM_ShowStoredItemSizes+0x46>
    346a:	11 50       	subi	r17, 0x01	; 1
    346c:	0a c0       	rjmp	.+20     	; 0x3482 <PM_ShowStoredItemSizes+0x46>
			else if (JoyStatus & JOY_DOWN)      // Next item
    346e:	f7 9b       	sbis	0x1e, 7	; 30
    3470:	06 c0       	rjmp	.+12     	; 0x347e <PM_ShowStoredItemSizes+0x42>
				(ItemInfoIndex == 3)? ItemInfoIndex = 0 : ItemInfoIndex++;
    3472:	13 30       	cpi	r17, 0x03	; 3
    3474:	11 f4       	brne	.+4      	; 0x347a <PM_ShowStoredItemSizes+0x3e>
    3476:	10 e0       	ldi	r17, 0x00	; 0
    3478:	04 c0       	rjmp	.+8      	; 0x3482 <PM_ShowStoredItemSizes+0x46>
    347a:	1f 5f       	subi	r17, 0xFF	; 255
    347c:	02 c0       	rjmp	.+4      	; 0x3482 <PM_ShowStoredItemSizes+0x46>
			else if (JoyStatus & JOY_LEFT)
    347e:	f2 99       	sbic	0x1e, 2	; 30
    3480:	53 c0       	rjmp	.+166    	; 0x3528 <PM_ShowStoredItemSizes+0xec>
				return;
		
			switch (ItemInfoIndex)
    3482:	81 2f       	mov	r24, r17
    3484:	99 27       	eor	r25, r25
    3486:	81 30       	cpi	r24, 0x01	; 1
    3488:	91 05       	cpc	r25, r1
    348a:	a1 f0       	breq	.+40     	; 0x34b4 <PM_ShowStoredItemSizes+0x78>
    348c:	82 30       	cpi	r24, 0x02	; 2
    348e:	91 05       	cpc	r25, r1
    3490:	1c f4       	brge	.+6      	; 0x3498 <PM_ShowStoredItemSizes+0x5c>
    3492:	89 2b       	or	r24, r25
    3494:	39 f0       	breq	.+14     	; 0x34a4 <PM_ShowStoredItemSizes+0x68>
    3496:	41 c0       	rjmp	.+130    	; 0x351a <PM_ShowStoredItemSizes+0xde>
    3498:	82 30       	cpi	r24, 0x02	; 2
    349a:	91 05       	cpc	r25, r1
    349c:	01 f1       	breq	.+64     	; 0x34de <PM_ShowStoredItemSizes+0xa2>
    349e:	03 97       	sbiw	r24, 0x03	; 3
    34a0:	39 f1       	breq	.+78     	; 0x34f0 <PM_ShowStoredItemSizes+0xb4>
    34a2:	3b c0       	rjmp	.+118    	; 0x351a <PM_ShowStoredItemSizes+0xde>
			{
				case 0:
					strcpy_P(Buffer, PSTR("DATA-"));
    34a4:	64 ef       	ldi	r22, 0xF4	; 244
    34a6:	73 e0       	ldi	r23, 0x03	; 3
    34a8:	ce 01       	movw	r24, r28
    34aa:	01 96       	adiw	r24, 0x01	; 1
    34ac:	0e 94 6a 1b 	call	0x36d4 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_FLASH), &Buffer[5], 10);
    34b0:	81 e0       	ldi	r24, 0x01	; 1
    34b2:	07 c0       	rjmp	.+14     	; 0x34c2 <PM_ShowStoredItemSizes+0x86>
					break;
				case 1:
					strcpy_P(Buffer, PSTR("EPRM-"));
    34b4:	6a ef       	ldi	r22, 0xFA	; 250
    34b6:	73 e0       	ldi	r23, 0x03	; 3
    34b8:	ce 01       	movw	r24, r28
    34ba:	01 96       	adiw	r24, 0x01	; 1
    34bc:	0e 94 6a 1b 	call	0x36d4 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_EEPROM), &Buffer[5], 10);
    34c0:	80 e0       	ldi	r24, 0x00	; 0
    34c2:	0e 94 b7 13 	call	0x276e <PM_GetStoredDataSize>
    34c6:	dc 01       	movw	r26, r24
    34c8:	cb 01       	movw	r24, r22
    34ca:	2a e0       	ldi	r18, 0x0A	; 10
    34cc:	30 e0       	ldi	r19, 0x00	; 0
    34ce:	ae 01       	movw	r20, r28
    34d0:	4a 5f       	subi	r20, 0xFA	; 250
    34d2:	5f 4f       	sbci	r21, 0xFF	; 255
    34d4:	bc 01       	movw	r22, r24
    34d6:	cd 01       	movw	r24, r26
    34d8:	0e 94 71 1b 	call	0x36e2 <ultoa>
					break;
    34dc:	1e c0       	rjmp	.+60     	; 0x351a <PM_ShowStoredItemSizes+0xde>
				case 2:
					strcpy_P(Buffer, PSTR("FUSE-"));
    34de:	60 e0       	ldi	r22, 0x00	; 0
    34e0:	74 e0       	ldi	r23, 0x04	; 4
    34e2:	ce 01       	movw	r24, r28
    34e4:	01 96       	adiw	r24, 0x01	; 1
    34e6:	0e 94 6a 1b 	call	0x36d4 <strcpy_P>
					TempB = eeprom_read_byte_169(&Prog_TotalFuseBytes);
    34ea:	80 e1       	ldi	r24, 0x10	; 16
    34ec:	91 e0       	ldi	r25, 0x01	; 1
    34ee:	08 c0       	rjmp	.+16     	; 0x3500 <PM_ShowStoredItemSizes+0xc4>
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);
					break;
				case 3:
					strcpy_P(Buffer, PSTR("LOCK-"));
    34f0:	66 e0       	ldi	r22, 0x06	; 6
    34f2:	74 e0       	ldi	r23, 0x04	; 4
    34f4:	ce 01       	movw	r24, r28
    34f6:	01 96       	adiw	r24, 0x01	; 1
    34f8:	0e 94 6a 1b 	call	0x36d4 <strcpy_P>
					TempB = eeprom_read_byte_169(&Prog_TotalLockBytes);
    34fc:	8e e0       	ldi	r24, 0x0E	; 14
    34fe:	91 e0       	ldi	r25, 0x01	; 1
    3500:	0e 94 b6 08 	call	0x116c <eeprom_read_byte_169>
					MAIN_IntToStr(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5]);		
    3504:	8f 3f       	cpi	r24, 0xFF	; 255
    3506:	11 f0       	breq	.+4      	; 0x350c <PM_ShowStoredItemSizes+0xd0>
    3508:	99 27       	eor	r25, r25
    350a:	02 c0       	rjmp	.+4      	; 0x3510 <PM_ShowStoredItemSizes+0xd4>
    350c:	80 e0       	ldi	r24, 0x00	; 0
    350e:	90 e0       	ldi	r25, 0x00	; 0
    3510:	be 01       	movw	r22, r28
    3512:	6a 5f       	subi	r22, 0xFA	; 250
    3514:	7f 4f       	sbci	r23, 0xFF	; 255
    3516:	0e 94 30 03 	call	0x660 <MAIN_IntToStr>
			}
	
			LCD_puts(Buffer);
    351a:	ce 01       	movw	r24, r28
    351c:	01 96       	adiw	r24, 0x01	; 1
    351e:	0e 94 bb 07 	call	0xf76 <LCD_puts>

			MAIN_WaitForJoyRelease();
    3522:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
    3526:	98 cf       	rjmp	.-208    	; 0x3458 <PM_ShowStoredItemSizes+0x1c>
    3528:	2e 96       	adiw	r28, 0x0e	; 14
    352a:	0f b6       	in	r0, 0x3f	; 63
    352c:	f8 94       	cli
    352e:	de bf       	out	0x3e, r29	; 62
    3530:	0f be       	out	0x3f, r0	; 63
    3532:	cd bf       	out	0x3d, r28	; 61
    3534:	df 91       	pop	r29
    3536:	cf 91       	pop	r28
    3538:	1f 91       	pop	r17
    353a:	08 95       	ret

0000353c <TM_FindNextTag>:
	DF_EnableDataflash(FALSE);
}

void TM_FindNextTag(void)
{
    353c:	af 92       	push	r10
    353e:	bf 92       	push	r11
    3540:	df 92       	push	r13
    3542:	ef 92       	push	r14
    3544:	ff 92       	push	r15
    3546:	0f 93       	push	r16
    3548:	1f 93       	push	r17
    354a:	cf 93       	push	r28
    354c:	df 93       	push	r29
    354e:	cd b7       	in	r28, 0x3d	; 61
    3550:	de b7       	in	r29, 0x3e	; 62
    3552:	69 97       	sbiw	r28, 0x19	; 25
    3554:	0f b6       	in	r0, 0x3f	; 63
    3556:	f8 94       	cli
    3558:	de bf       	out	0x3e, r29	; 62
    355a:	0f be       	out	0x3f, r0	; 63
    355c:	cd bf       	out	0x3d, r28	; 61
	uint8_t  Buffer[21];
	uint8_t  HeadBuff[4]      = BT_TAGHEADER;
    355e:	80 e4       	ldi	r24, 0x40	; 64
    3560:	8e 8b       	std	Y+22, r24	; 0x16
    3562:	86 e1       	ldi	r24, 0x16	; 22
    3564:	a8 2e       	mov	r10, r24
    3566:	b1 2c       	mov	r11, r1
    3568:	ac 0e       	add	r10, r28
    356a:	bd 1e       	adc	r11, r29
    356c:	88 e2       	ldi	r24, 0x28	; 40
    356e:	8f 8b       	std	Y+23, r24	; 0x17
    3570:	83 e2       	ldi	r24, 0x23	; 35
    3572:	88 8f       	std	Y+24, r24	; 0x18
    3574:	89 e2       	ldi	r24, 0x29	; 41
    3576:	89 8f       	std	Y+25, r24	; 0x19
	uint32_t ProgDataSize     = PM_GetStoredDataSize(TYPE_FLASH);
    3578:	81 e0       	ldi	r24, 0x01	; 1
    357a:	0e 94 b7 13 	call	0x276e <PM_GetStoredDataSize>
    357e:	7b 01       	movw	r14, r22
    3580:	8c 01       	movw	r16, r24
	uint8_t  TotalOkHeadBytes = 0;
    3582:	dd 24       	eor	r13, r13
	uint8_t  TagByte;
	uint8_t  BytesRead;
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);    // Orange = busy
    3584:	81 b3       	in	r24, 0x11	; 17
    3586:	80 63       	ori	r24, 0x30	; 48
    3588:	81 bb       	out	0x11, r24	; 17

	while (DFPos < ProgDataSize)
	{
		BytesRead = 1;
		
		if (SPI_SPITransmit(0x00) == HeadBuff[TotalOkHeadBytes++])
		{
			if (TotalOkHeadBytes == 4)
			{
				uint8_t HB;
			
				for (HB = 0; HB < 20; HB++)
				{
					TagByte = SPI_SPITransmit(0x00);
					Buffer[HB] = TagByte;
					
					if (TagByte == 0x00)
					  break;
				}
				
				Buffer[20] = '\0';             // Make sure string is null-terminated

				TagExists = TRUE;
				BytesRead = (HB + 2);

				LCD_puts(Buffer);
				MAIN_SETSTATUSLED(MAIN_STATLED_GREEN); // Green = ready
				return;
			}
		}
		else
		{
			TotalOkHeadBytes = 0;
		}

		DFPos += BytesRead;
    358a:	80 91 d2 02 	lds	r24, 0x02D2
    358e:	90 91 d3 02 	lds	r25, 0x02D3
    3592:	a0 91 d4 02 	lds	r26, 0x02D4
    3596:	b0 91 d5 02 	lds	r27, 0x02D5
    359a:	8e 15       	cp	r24, r14
    359c:	9f 05       	cpc	r25, r15
    359e:	a0 07       	cpc	r26, r16
    35a0:	b1 07       	cpc	r27, r17
    35a2:	08 f0       	brcs	.+2      	; 0x35a6 <TM_FindNextTag+0x6a>
    35a4:	43 c0       	rjmp	.+134    	; 0x362c <TM_FindNextTag+0xf0>
    35a6:	80 e0       	ldi	r24, 0x00	; 0
    35a8:	0e 94 3f 09 	call	0x127e <SPI_SPITransmit>
    35ac:	f5 01       	movw	r30, r10
    35ae:	ed 0d       	add	r30, r13
    35b0:	f1 1d       	adc	r31, r1
    35b2:	d3 94       	inc	r13
    35b4:	90 81       	ld	r25, Z
    35b6:	89 17       	cp	r24, r25
    35b8:	21 f5       	brne	.+72     	; 0x3602 <TM_FindNextTag+0xc6>
    35ba:	84 e0       	ldi	r24, 0x04	; 4
    35bc:	d8 16       	cp	r13, r24
    35be:	11 f5       	brne	.+68     	; 0x3604 <TM_FindNextTag+0xc8>
    35c0:	ff 24       	eor	r15, r15
    35c2:	00 e0       	ldi	r16, 0x00	; 0
    35c4:	10 e0       	ldi	r17, 0x00	; 0
    35c6:	80 e0       	ldi	r24, 0x00	; 0
    35c8:	0e 94 3f 09 	call	0x127e <SPI_SPITransmit>
    35cc:	9e 01       	movw	r18, r28
    35ce:	2f 5f       	subi	r18, 0xFF	; 255
    35d0:	3f 4f       	sbci	r19, 0xFF	; 255
    35d2:	f8 01       	movw	r30, r16
    35d4:	e2 0f       	add	r30, r18
    35d6:	f3 1f       	adc	r31, r19
    35d8:	80 83       	st	Z, r24
    35da:	88 23       	and	r24, r24
    35dc:	31 f0       	breq	.+12     	; 0x35ea <TM_FindNextTag+0xae>
    35de:	f3 94       	inc	r15
    35e0:	0f 5f       	subi	r16, 0xFF	; 255
    35e2:	1f 4f       	sbci	r17, 0xFF	; 255
    35e4:	83 e1       	ldi	r24, 0x13	; 19
    35e6:	8f 15       	cp	r24, r15
    35e8:	70 f7       	brcc	.-36     	; 0x35c6 <TM_FindNextTag+0x8a>
    35ea:	1d 8a       	std	Y+21, r1	; 0x15
    35ec:	81 e0       	ldi	r24, 0x01	; 1
    35ee:	80 93 4d 02 	sts	0x024D, r24
    35f2:	c9 01       	movw	r24, r18
    35f4:	0e 94 bb 07 	call	0xf76 <LCD_puts>
    35f8:	81 b3       	in	r24, 0x11	; 17
    35fa:	8f 7c       	andi	r24, 0xCF	; 207
    35fc:	80 61       	ori	r24, 0x10	; 16
    35fe:	81 bb       	out	0x11, r24	; 17
    3600:	31 c0       	rjmp	.+98     	; 0x3664 <TM_FindNextTag+0x128>
    3602:	dd 24       	eor	r13, r13
    3604:	80 91 d2 02 	lds	r24, 0x02D2
    3608:	90 91 d3 02 	lds	r25, 0x02D3
    360c:	a0 91 d4 02 	lds	r26, 0x02D4
    3610:	b0 91 d5 02 	lds	r27, 0x02D5
    3614:	01 96       	adiw	r24, 0x01	; 1
    3616:	a1 1d       	adc	r26, r1
    3618:	b1 1d       	adc	r27, r1
    361a:	80 93 d2 02 	sts	0x02D2, r24
    361e:	90 93 d3 02 	sts	0x02D3, r25
    3622:	a0 93 d4 02 	sts	0x02D4, r26
    3626:	b0 93 d5 02 	sts	0x02D5, r27
    362a:	b7 cf       	rjmp	.-146    	; 0x359a <TM_FindNextTag+0x5e>
	}
	
	DF_ContinuousReadEnable(0, 0);
    362c:	60 e0       	ldi	r22, 0x00	; 0
    362e:	70 e0       	ldi	r23, 0x00	; 0
    3630:	cb 01       	movw	r24, r22
    3632:	0e 94 51 0a 	call	0x14a2 <DF_ContinuousReadEnable>
	DFPos = 0;
    3636:	10 92 d2 02 	sts	0x02D2, r1
    363a:	10 92 d3 02 	sts	0x02D3, r1
    363e:	10 92 d4 02 	sts	0x02D4, r1
    3642:	10 92 d5 02 	sts	0x02D5, r1
	
	if (TagExists == FALSE)
    3646:	80 91 4d 02 	lds	r24, 0x024D
    364a:	88 23       	and	r24, r24
    364c:	49 f4       	brne	.+18     	; 0x3660 <TM_FindNextTag+0x124>
	{
		MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);  // Green = ready
    364e:	81 b3       	in	r24, 0x11	; 17
    3650:	8f 7c       	andi	r24, 0xCF	; 207
    3652:	80 61       	ori	r24, 0x10	; 16
    3654:	81 bb       	out	0x11, r24	; 17
		MAIN_ShowError(PSTR("NO TAGS"));
    3656:	8c e0       	ldi	r24, 0x0C	; 12
    3658:	94 e0       	ldi	r25, 0x04	; 4
    365a:	0e 94 6a 03 	call	0x6d4 <MAIN_ShowError>
    365e:	02 c0       	rjmp	.+4      	; 0x3664 <TM_FindNextTag+0x128>
	}
	else
	{
		/* The following line _is_ recursion, but the function will only ever call itself
		   a maximum of one time. The function will call itself upon skipping from the last
		   tag stored in the program data to the first; to guard against infinite recursion
		   if no tags are present, the system will error out if the TagExists flag is empty
		   after a full data read. Once a tag has been read and displayed onto the LCD, the
           function returns to the main tag handling routine.                               */
		TM_FindNextTag();
    3660:	0e 94 9e 1a 	call	0x353c <TM_FindNextTag>
    3664:	69 96       	adiw	r28, 0x19	; 25
    3666:	0f b6       	in	r0, 0x3f	; 63
    3668:	f8 94       	cli
    366a:	de bf       	out	0x3e, r29	; 62
    366c:	0f be       	out	0x3f, r0	; 63
    366e:	cd bf       	out	0x3d, r28	; 61
    3670:	df 91       	pop	r29
    3672:	cf 91       	pop	r28
    3674:	1f 91       	pop	r17
    3676:	0f 91       	pop	r16
    3678:	ff 90       	pop	r15
    367a:	ef 90       	pop	r14
    367c:	df 90       	pop	r13
    367e:	bf 90       	pop	r11
    3680:	af 90       	pop	r10
    3682:	08 95       	ret

00003684 <TM_ShowTags>:
    3684:	60 e0       	ldi	r22, 0x00	; 0
    3686:	70 e0       	ldi	r23, 0x00	; 0
    3688:	cb 01       	movw	r24, r22
    368a:	0e 94 51 0a 	call	0x14a2 <DF_ContinuousReadEnable>
    368e:	10 92 4d 02 	sts	0x024D, r1
    3692:	10 92 d2 02 	sts	0x02D2, r1
    3696:	10 92 d3 02 	sts	0x02D3, r1
    369a:	10 92 d4 02 	sts	0x02D4, r1
    369e:	10 92 d5 02 	sts	0x02D5, r1
    36a2:	0e 94 9e 1a 	call	0x353c <TM_FindNextTag>
    36a6:	80 91 4d 02 	lds	r24, 0x024D
    36aa:	88 23       	and	r24, r24
    36ac:	71 f0       	breq	.+28     	; 0x36ca <TM_ShowTags+0x46>
    36ae:	8e b3       	in	r24, 0x1e	; 30
    36b0:	88 23       	and	r24, r24
    36b2:	e9 f3       	breq	.-6      	; 0x36ae <TM_ShowTags+0x2a>
    36b4:	f7 9b       	sbis	0x1e, 7	; 30
    36b6:	03 c0       	rjmp	.+6      	; 0x36be <TM_ShowTags+0x3a>
    36b8:	0e 94 9e 1a 	call	0x353c <TM_FindNextTag>
    36bc:	02 c0       	rjmp	.+4      	; 0x36c2 <TM_ShowTags+0x3e>
    36be:	f2 99       	sbic	0x1e, 2	; 30
    36c0:	03 c0       	rjmp	.+6      	; 0x36c8 <TM_ShowTags+0x44>
    36c2:	0e 94 39 02 	call	0x472 <MAIN_WaitForJoyRelease>
    36c6:	f3 cf       	rjmp	.-26     	; 0x36ae <TM_ShowTags+0x2a>
    36c8:	80 e0       	ldi	r24, 0x00	; 0
    36ca:	0e 94 12 0a 	call	0x1424 <DF_EnableDataflash>
    36ce:	08 95       	ret

000036d0 <__vector_2>:
.global PCINT0_vect             ; Pin change 0 (joystick)
.global PCINT1_vect             ; Pin change 1 (joystick)

PCINT0_vect:
  jmp PCINT1_vect
    36d0:	0c 94 90 03 	jmp	0x720 <__vector_3>

000036d4 <strcpy_P>:
    36d4:	fb 01       	movw	r30, r22
    36d6:	dc 01       	movw	r26, r24
    36d8:	05 90       	lpm	r0, Z+
    36da:	0d 92       	st	X+, r0
    36dc:	00 20       	and	r0, r0
    36de:	e1 f7       	brne	.-8      	; 0x36d8 <strcpy_P+0x4>
    36e0:	08 95       	ret

000036e2 <ultoa>:
    36e2:	fa 01       	movw	r30, r20
    36e4:	cf 93       	push	r28
    36e6:	ff 93       	push	r31
    36e8:	ef 93       	push	r30
    36ea:	22 30       	cpi	r18, 0x02	; 2
    36ec:	cc f0       	brlt	.+50     	; 0x3720 <ultoa+0x3e>
    36ee:	25 32       	cpi	r18, 0x25	; 37
    36f0:	bc f4       	brge	.+46     	; 0x3720 <ultoa+0x3e>
    36f2:	c2 2f       	mov	r28, r18
    36f4:	2c 2f       	mov	r18, r28
    36f6:	33 27       	eor	r19, r19
    36f8:	44 27       	eor	r20, r20
    36fa:	55 27       	eor	r21, r21
    36fc:	ff 93       	push	r31
    36fe:	ef 93       	push	r30
    3700:	0e 94 c5 1b 	call	0x378a <__udivmodsi4>
    3704:	ef 91       	pop	r30
    3706:	ff 91       	pop	r31
    3708:	60 5d       	subi	r22, 0xD0	; 208
    370a:	6a 33       	cpi	r22, 0x3A	; 58
    370c:	0c f0       	brlt	.+2      	; 0x3710 <ultoa+0x2e>
    370e:	69 5d       	subi	r22, 0xD9	; 217
    3710:	61 93       	st	Z+, r22
    3712:	b9 01       	movw	r22, r18
    3714:	ca 01       	movw	r24, r20
    3716:	60 50       	subi	r22, 0x00	; 0
    3718:	70 40       	sbci	r23, 0x00	; 0
    371a:	80 40       	sbci	r24, 0x00	; 0
    371c:	90 40       	sbci	r25, 0x00	; 0
    371e:	51 f7       	brne	.-44     	; 0x36f4 <ultoa+0x12>
    3720:	10 82       	st	Z, r1
    3722:	8f 91       	pop	r24
    3724:	9f 91       	pop	r25
    3726:	cf 91       	pop	r28
    3728:	0c 94 96 1b 	jmp	0x372c <strrev>

0000372c <strrev>:
    372c:	dc 01       	movw	r26, r24
    372e:	fc 01       	movw	r30, r24
    3730:	01 90       	ld	r0, Z+
    3732:	00 20       	and	r0, r0
    3734:	e9 f7       	brne	.-6      	; 0x3730 <strrev+0x4>
    3736:	32 97       	sbiw	r30, 0x02	; 2
    3738:	ae 17       	cp	r26, r30
    373a:	bf 07       	cpc	r27, r31
    373c:	30 f4       	brcc	.+12     	; 0x374a <strrev+0x1e>
    373e:	7c 91       	ld	r23, X
    3740:	60 81       	ld	r22, Z
    3742:	70 83       	st	Z, r23
    3744:	31 97       	sbiw	r30, 0x01	; 1
    3746:	6d 93       	st	X+, r22
    3748:	f7 cf       	rjmp	.-18     	; 0x3738 <strrev+0xc>
    374a:	08 95       	ret

0000374c <__mulsi3>:
    374c:	62 9f       	mul	r22, r18
    374e:	d0 01       	movw	r26, r0
    3750:	73 9f       	mul	r23, r19
    3752:	f0 01       	movw	r30, r0
    3754:	82 9f       	mul	r24, r18
    3756:	e0 0d       	add	r30, r0
    3758:	f1 1d       	adc	r31, r1
    375a:	64 9f       	mul	r22, r20
    375c:	e0 0d       	add	r30, r0
    375e:	f1 1d       	adc	r31, r1
    3760:	92 9f       	mul	r25, r18
    3762:	f0 0d       	add	r31, r0
    3764:	83 9f       	mul	r24, r19
    3766:	f0 0d       	add	r31, r0
    3768:	74 9f       	mul	r23, r20
    376a:	f0 0d       	add	r31, r0
    376c:	65 9f       	mul	r22, r21
    376e:	f0 0d       	add	r31, r0
    3770:	99 27       	eor	r25, r25
    3772:	72 9f       	mul	r23, r18
    3774:	b0 0d       	add	r27, r0
    3776:	e1 1d       	adc	r30, r1
    3778:	f9 1f       	adc	r31, r25
    377a:	63 9f       	mul	r22, r19
    377c:	b0 0d       	add	r27, r0
    377e:	e1 1d       	adc	r30, r1
    3780:	f9 1f       	adc	r31, r25
    3782:	bd 01       	movw	r22, r26
    3784:	cf 01       	movw	r24, r30
    3786:	11 24       	eor	r1, r1
    3788:	08 95       	ret

0000378a <__udivmodsi4>:
    378a:	a1 e2       	ldi	r26, 0x21	; 33
    378c:	1a 2e       	mov	r1, r26
    378e:	aa 1b       	sub	r26, r26
    3790:	bb 1b       	sub	r27, r27
    3792:	fd 01       	movw	r30, r26
    3794:	0d c0       	rjmp	.+26     	; 0x37b0 <__udivmodsi4_ep>

00003796 <__udivmodsi4_loop>:
    3796:	aa 1f       	adc	r26, r26
    3798:	bb 1f       	adc	r27, r27
    379a:	ee 1f       	adc	r30, r30
    379c:	ff 1f       	adc	r31, r31
    379e:	a2 17       	cp	r26, r18
    37a0:	b3 07       	cpc	r27, r19
    37a2:	e4 07       	cpc	r30, r20
    37a4:	f5 07       	cpc	r31, r21
    37a6:	20 f0       	brcs	.+8      	; 0x37b0 <__udivmodsi4_ep>
    37a8:	a2 1b       	sub	r26, r18
    37aa:	b3 0b       	sbc	r27, r19
    37ac:	e4 0b       	sbc	r30, r20
    37ae:	f5 0b       	sbc	r31, r21

000037b0 <__udivmodsi4_ep>:
    37b0:	66 1f       	adc	r22, r22
    37b2:	77 1f       	adc	r23, r23
    37b4:	88 1f       	adc	r24, r24
    37b6:	99 1f       	adc	r25, r25
    37b8:	1a 94       	dec	r1
    37ba:	69 f7       	brne	.-38     	; 0x3796 <__udivmodsi4_loop>
    37bc:	60 95       	com	r22
    37be:	70 95       	com	r23
    37c0:	80 95       	com	r24
    37c2:	90 95       	com	r25
    37c4:	9b 01       	movw	r18, r22
    37c6:	ac 01       	movw	r20, r24
    37c8:	bd 01       	movw	r22, r26
    37ca:	cf 01       	movw	r24, r30
    37cc:	08 95       	ret
