
ButtLoad.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  000035b4  00003668  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000035b4  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b2  00800104  00800104  0000366c  2**0
                  ALLOC
  3 .eeprom       0000008b  00810000  00810000  0000366c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00000084  00000000  00000000  000036f8  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00000078  00000000  00000000  0000377c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 0000012c  00000000  00000000  000037f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 00000d5a  00000000  00000000  00003920  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   000044c4  00000000  00000000  0000467a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00001290  00000000  00000000  00008b3e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00003361  00000000  00000000  00009dce  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000004f8  00000000  00000000  0000d12f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000011a2  00000000  00000000  0000d627  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000116e  00000000  00000000  0000e7c9  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000060  00000000  00000000  0000f937  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 33 02 	jmp	0x466	; 0x466 <__ctors_end>
       4:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
       8:	0c 94 4b 1a 	jmp	0x3496	; 0x3496 <__vector_2>
       c:	0c 94 b6 02 	jmp	0x56c	; 0x56c <__vector_3>
      10:	0c 94 bd 0c 	jmp	0x197a	; 0x197a <__vector_4>
      14:	0c 94 40 08 	jmp	0x1080	; 0x1080 <__vector_5>
      18:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      1c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      20:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      24:	0c 94 83 0c 	jmp	0x1906	; 0x1906 <__vector_9>
      28:	0c 94 4d 1a 	jmp	0x349a	; 0x349a <__vector_10>
      2c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      30:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      34:	0c 94 01 0c 	jmp	0x1802	; 0x1802 <__vector_13>
      38:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      3c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      40:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      44:	0c 94 c7 09 	jmp	0x138e	; 0x138e <__vector_17>
      48:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      4c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      50:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      54:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__bad_interrupt>
      58:	0c 94 e3 08 	jmp	0x11c6	; 0x11c6 <__vector_22>

0000005c <BUTTTAG_Title>:
      5c:	40 28 23 29 42 55 54 54 4c 4f 41 44 20 41 56 52     @(#)BUTTLOAD AVR
      6c:	49 53 50 00                                         ISP.

00000070 <BUTTTAG_Version>:
      70:	40 28 23 29 56 31 2d 34 00                          @(#)V1-4.

00000079 <BUTTTAG_Author>:
      79:	40 28 23 29 42 59 20 44 45 41 4e 20 43 41 4d 45     @(#)BY DEAN CAME
      89:	52 41 00                                            RA.

0000008c <BUTTTAG_Copyright>:
      8c:	40 28 23 29 3c 43 3e 20 32 30 30 36 20 2d 20 47     @(#)<C> 2006 - G
      9c:	50 4c 00                                            PL.

0000009f <AboutTextPtrs>:
      9f:	60 00 74 00 7d 00 90 00                             `.t.}...

000000a7 <WaitText>:
      a7:	2a 57 41 49 54 2a 00                                *WAIT*.

000000ae <Func_ISPPRGM>:
      ae:	41 56 52 49 53 50 20 4d 4f 44 45 00                 AVRISP MODE.

000000ba <Func_STOREPRGM>:
      ba:	53 54 4f 52 45 20 50 52 47 4d 00                    STORE PRGM.

000000c5 <Func_PRGMAVR>:
      c5:	50 52 4f 47 52 41 4d 20 41 56 52 00                 PROGRAM AVR.

000000d1 <Func_PRGMDATAFLASH>:
      d1:	44 41 54 41 46 4c 41 53 48 20 50 52 47 4d 00        DATAFLASH PRGM.

000000e0 <Func_PRGMSTOREINFO>:
      e0:	44 41 54 41 53 54 4f 52 45 20 49 4e 46 4f 00        DATASTORE INFO.

000000ef <Func_SETTINGS>:
      ef:	53 45 54 54 49 4e 47 53 00                          SETTINGS.

000000f8 <Func_SLEEP>:
      f8:	53 4c 45 45 50 20 4d 4f 44 45 00                    SLEEP MODE.

00000103 <MainFunctionNames>:
     103:	ae 00 ba 00 c5 00 d1 00 e0 00 ef 00 f8 00           ..............

00000111 <MainFunctionPtrs>:
     111:	8a 04 5c 04 ef 04 9f 04 e4 03 27 03 d5 02           ..\.......'...

0000011f <SFunc_SETCONTRAST>:
     11f:	53 45 54 20 43 4f 4e 54 52 41 53 54 00              SET CONTRAST.

0000012c <SFunc_SETSPISPEED>:
     12c:	53 45 54 20 53 50 49 20 53 50 45 45 44 00           SET SPI SPEED.

0000013a <SFunc_SETRESETMODE>:
     13a:	53 45 54 20 52 45 53 45 54 20 4d 4f 44 45 00        SET RESET MODE.

00000149 <SFunc_SETFIRMMINOR>:
     149:	53 45 54 20 46 49 52 4d 20 56 45 52 53 49 4f 4e     SET FIRM VERSION
	...

0000015a <SFunc_SETAUTOSLEEPTO>:
     15a:	53 45 54 20 53 4c 45 45 50 20 54 49 4d 45 4f 55     SET SLEEP TIMEOU
     16a:	54 00                                               T.

0000016c <SFunc_CLEARMEM>:
     16c:	43 4c 45 41 52 20 4d 45 4d 4f 52 59 00              CLEAR MEMORY.

00000179 <SFunc_GOBOOTLOADER>:
     179:	4a 55 4d 50 20 54 4f 20 42 4f 4f 54 4c 4f 41 44     JUMP TO BOOTLOAD
     189:	45 52 00                                            ER.

0000018c <SettingFunctionNames>:
     18c:	1f 01 2c 01 3a 01 49 01 5a 01 6c 01 79 01           ..,.:.I.Z.l.y.

0000019a <SettingFunctionPtrs>:
     19a:	f5 06 41 07 74 07 9c 07 5c 03 c2 06 ef 02           ..A.t...\.....

000001a8 <PRG_A>:
     1a8:	50 52 47 4d 20 41 4c 4c 00                          PRGM ALL.

000001b1 <PRG_D>:
     1b1:	44 41 54 41 20 4f 4e 4c 59 00                       DATA ONLY.

000001bb <PRG_E>:
     1bb:	45 45 50 52 4f 4d 20 4f 4e 4c 59 00                 EEPROM ONLY.

000001c7 <PRG_DE>:
     1c7:	44 41 54 41 20 41 4e 44 20 45 45 50 52 4f 4d 00     DATA AND EEPROM.

000001d7 <PRG_F>:
     1d7:	46 55 53 45 20 42 59 54 45 53 20 4f 4e 4c 59 00     FUSE BYTES ONLY.

000001e7 <PRG_L>:
     1e7:	4c 4f 43 4b 20 42 59 54 45 53 20 4f 4e 4c 59 00     LOCK BYTES ONLY.

000001f7 <PRG_FL>:
     1f7:	46 55 53 45 20 41 4e 44 20 4c 4f 43 4b 20 42 59     FUSE AND LOCK BY
     207:	54 45 53 00                                         TES.

0000020b <PRG_C>:
     20b:	45 52 41 53 45 20 4f 4e 4c 59 00                    ERASE ONLY.

00000216 <ProgOptions>:
     216:	a8 01 b1 01 bb 01 c7 01 d7 01 e7 01 f7 01 0b 02     ................

00000226 <USISpeeds>:
     226:	20 35 37 31 35 33 20 48 5a 00 20 38 36 37 33 38      57153 HZ. 86738
     236:	20 48 5a 00 31 31 33 34 32 37 20 48 5a 00 32 31      HZ.113427 HZ.21
     246:	30 36 35 31 20 48 5a 00                             0651 HZ.

0000024e <SPIResetModes>:
     24e:	4c 4f 47 49 43 00 46 4c 4f 41 54 00                 LOGIC.FLOAT.

0000025a <SIFONames>:
     25a:	53 54 4f 52 41 47 45 20 53 49 5a 45 53 00 00 56     STORAGE SIZES..V
     26a:	49 45 57 20 44 41 54 41 20 54 41 47 53 00           IEW DATA TAGS.

00000278 <__c.2512>:
     278:	2a 4a 54 41 47 20 4f 4e 2a 00                       *JTAG ON*.

00000282 <__c.2481>:
     282:	4e 4f 20 53 54 4f 52 45 44 20 50 52 47 4d 00        NO STORED PRGM.

00000291 <__c.2427>:
     291:	4f 46 46 00                                         OFF.

00000295 <__c.2425>:
     295:	20 20 20 20 53 45 43 00                                 SEC.

0000029d <__c.2404>:
     29d:	56 32 2d 20 00                                      V2- .

000002a2 <__c.2306>:
     2a2:	4d 45 4d 20 43 4c 45 41 52 45 44 00                 MEM CLEARED.

000002ae <__c.2298>:
     2ae:	3c 4e 20 59 3e 00                                   <N Y>.

000002b4 <__c.2296>:
     2b4:	43 4f 4e 46 49 52 4d 00                             CONFIRM.

000002bc <__c.2279>:
     2bc:	2a 53 54 4f 52 41 47 45 20 4d 4f 44 45 2a 00        *STORAGE MODE*.

000002cb <__c.2212>:
     2cb:	46 41 49 4c 45 44 00                                FAILED.

000002d2 <__c.2210>:
     2d2:	50 52 4f 47 52 41 4d 4d 49 4e 47 20 44 4f 4e 45     PROGRAMMING DONE
	...

000002e3 <__c.2208>:
     2e3:	4e 4f 20 4c 4f 43 4b 20 42 59 54 45 53 00           NO LOCK BYTES.

000002f1 <__c.2206>:
     2f1:	4e 4f 20 46 55 53 45 20 42 59 54 45 53 00           NO FUSE BYTES.

000002ff <__c.2204>:
     2ff:	4e 4f 20 45 45 50 52 4f 4d 00                       NO EEPROM.

00000309 <__c.2202>:
     309:	4e 4f 20 44 41 54 41 00                             NO DATA.

00000311 <__c.2200>:
     311:	4e 4f 20 45 52 41 53 45 20 43 4d 44 00              NO ERASE CMD.

0000031e <__c.2097>:
     31e:	42 41 44 49 53 52 00                                BADISR.

00000325 <__c.2034>:
     325:	50 52 47 3e 20 20 00                                PRG>  .

0000032c <LCD_SegTable>:
     32c:	a8 ea 80 2a 00 40 00 0a 51 0a 08 40 59 55 18 01     ...*.@..Q..@YU..
     33c:	11 1e 11 1b 50 0b 41 1b 41 1f 11 01 51 1f 51 1b     ....P.A.A...Q.Q.
     34c:	00 00 00 00 08 80 00 1a 20 40 00 00 00 00 51 0f     ........ @....Q.
     35c:	91 39 41 14 91 31 41 1e 41 0e 41 1d 50 0f 80 20     .9A..1A.A.A.P.. 
     36c:	10 15 48 86 40 14 78 05 70 85 51 15 51 0e 51 95     ..H.@.x.p.Q.Q.Q.
     37c:	51 8e 21 90 81 20 50 15 48 44 50 c5 28 c0 28 20     Q.!.. P.HDP.(.( 
     38c:	09 50 41 14 20 80 11 11 00 00 00 10                 .PA. .......

00000398 <USIPSValues>:
     398:	03 80 02 54 01 40 00 22                             ...T.@."

000003a0 <DF_PageBits>:
     3a0:	09 09 09 09 09 0a 0a 0b                             ........

000003a8 <DF_PageSize>:
     3a8:	08 01 08 01 08 01 08 01 08 01 10 02 10 02 20 04     .............. .

000003b8 <DF_Pages>:
     3b8:	00 01 00 02 00 04 00 08 00 10 00 10 00 20 00 20     ............. . 

000003c8 <DataFlashError>:
     3c8:	44 41 54 41 46 4c 41 53 48 20 45 52 52 4f 52 00     DATAFLASH ERROR.

000003d8 <__c.1865>:
     3d8:	42 55 46 46 20 4f 56 46 00                          BUFF OVF.

000003e1 <AutoSleepTOValues>:
     3e1:	00 0f 1e 3c 78                                      ...<x

000003e6 <__c.1868>:
     3e6:	46 52 41 4d 45 20 45 52 52 00                       FRAME ERR.

000003f0 <__c.1866>:
     3f0:	44 41 54 41 20 4f 56 52 00                          DATA OVR.

000003f9 <DataFlashProgMode>:
     3f9:	2a 44 41 54 41 46 4c 41 53 48 20 4d 4f 44 45 2a     *DATAFLASH MODE*
	...

0000040a <SignonResponse>:
     40a:	01 00 08 41 56 52 49 53 50 5f 32 00                 ...AVRISP_2.

00000416 <ButtLoadData>:
     416:	40 28 23 29 2a 53 43 52 45 57 20 52 45 54 52 4f     @(#)*SCREW RETRO
     426:	44 41 4e 00 2a                                      DAN.*

0000042b <SyncErrorMessage>:
     42b:	53 59 4e 43 20 45 52 52 4f 52 00                    SYNC ERROR.

00000436 <AVRISPModeMessage>:
     436:	2a 41 54 41 56 52 49 53 50 20 4d 4f 44 45 2a 00     *ATAVRISP MODE*.

00000446 <__c.2142>:
     446:	4c 4f 43 4b 2d 00                                   LOCK-.

0000044c <__c.2139>:
     44c:	46 55 53 45 2d 00                                   FUSE-.

00000452 <__c.2136>:
     452:	45 50 52 4d 2d 00                                   EPRM-.

00000458 <__c.2132>:
     458:	44 41 54 41 2d 00                                   DATA-.

0000045e <__c.1887>:
     45e:	4e 4f 20 54 41 47 53 00                             NO TAGS.

00000466 <__ctors_end>:
     466:	11 24       	eor	r1, r1
     468:	1f be       	out	0x3f, r1	; 63
     46a:	cf ef       	ldi	r28, 0xFF	; 255
     46c:	d4 e0       	ldi	r29, 0x04	; 4
     46e:	de bf       	out	0x3e, r29	; 62
     470:	cd bf       	out	0x3d, r28	; 61

00000472 <__do_copy_data>:
     472:	11 e0       	ldi	r17, 0x01	; 1
     474:	a0 e0       	ldi	r26, 0x00	; 0
     476:	b1 e0       	ldi	r27, 0x01	; 1
     478:	e4 eb       	ldi	r30, 0xB4	; 180
     47a:	f5 e3       	ldi	r31, 0x35	; 53
     47c:	02 c0       	rjmp	.+4      	; 0x482 <.do_copy_data_start>

0000047e <.do_copy_data_loop>:
     47e:	05 90       	lpm	r0, Z+
     480:	0d 92       	st	X+, r0

00000482 <.do_copy_data_start>:
     482:	a4 30       	cpi	r26, 0x04	; 4
     484:	b1 07       	cpc	r27, r17
     486:	d9 f7       	brne	.-10     	; 0x47e <.do_copy_data_loop>

00000488 <__do_clear_bss>:
     488:	12 e0       	ldi	r17, 0x02	; 2
     48a:	a4 e0       	ldi	r26, 0x04	; 4
     48c:	b1 e0       	ldi	r27, 0x01	; 1
     48e:	01 c0       	rjmp	.+2      	; 0x492 <.do_clear_bss_start>

00000490 <.do_clear_bss_loop>:
     490:	1d 92       	st	X+, r1

00000492 <.do_clear_bss_start>:
     492:	a6 3b       	cpi	r26, 0xB6	; 182
     494:	b1 07       	cpc	r27, r17
     496:	e1 f7       	brne	.-8      	; 0x490 <.do_clear_bss_loop>
     498:	0e 94 32 06 	call	0xc64	; 0xc64 <main>
     49c:	0c 94 d9 1a 	jmp	0x35b2	; 0x35b2 <_exit>

000004a0 <__bad_interrupt>:
     4a0:	0c 94 eb 04 	jmp	0x9d6	; 0x9d6 <__vector_default>

000004a4 <MAIN_Delay10MS>:

// ======================================================================================

void MAIN_Delay10MS(uint8_t loops)
{
     4a4:	28 2f       	mov	r18, r24
     4a6:	e0 e0       	ldi	r30, 0x00	; 0
     4a8:	f8 e4       	ldi	r31, 0x48	; 72
     4aa:	03 c0       	rjmp	.+6      	; 0x4b2 <MAIN_Delay10MS+0xe>
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     4ac:	cf 01       	movw	r24, r30
     4ae:	01 97       	sbiw	r24, 0x01	; 1
     4b0:	f1 f7       	brne	.-4      	; 0x4ae <MAIN_Delay10MS+0xa>
  /* Prevents the use of floating point libraries. Delaying in groups of
     10ms increases accuracy by reducing the time overhead for each loop
     interation of the while.                                            */

	while (loops--)
     4b2:	21 50       	subi	r18, 0x01	; 1
     4b4:	d8 f7       	brcc	.-10     	; 0x4ac <MAIN_Delay10MS+0x8>
     4b6:	08 95       	ret

000004b8 <MAIN_Delay1MS>:
	  _delay_ms(10);
}

void MAIN_Delay1MS(uint8_t loops)
{
     4b8:	28 2f       	mov	r18, r24
     4ba:	e3 e3       	ldi	r30, 0x33	; 51
     4bc:	f7 e0       	ldi	r31, 0x07	; 7
     4be:	03 c0       	rjmp	.+6      	; 0x4c6 <MAIN_Delay1MS+0xe>
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     4c0:	cf 01       	movw	r24, r30
     4c2:	01 97       	sbiw	r24, 0x01	; 1
     4c4:	f1 f7       	brne	.-4      	; 0x4c2 <MAIN_Delay1MS+0xa>
  /* Prevents the use of floating point libraries. Less accurate than the
     Delay10MS routine, but nessesary for many commands. The overhead required
     to call the routine is substantially less than the overhead required to
     calculate the float at compile time, so this actually saves execution time. */

	while (loops--)
     4c6:	21 50       	subi	r18, 0x01	; 1
     4c8:	d8 f7       	brcc	.-10     	; 0x4c0 <MAIN_Delay1MS+0x8>
     4ca:	08 95       	ret

000004cc <MAIN_ResetCSLine>:
	  _delay_ms(1);
}

void MAIN_ResetCSLine(const uint8_t ActiveInactive)
{
     4cc:	81 30       	cpi	r24, 0x01	; 1
     4ce:	81 f0       	breq	.+32     	; 0x4f0 <MAIN_ResetCSLine+0x24>
	/* ActiveInactive controls the /Reset line to an AVR device or external dataflash
	/CS line. If the reset polarity parameter is a 0 then interfacing with AT89
	devices which has an active high reset. Pins are tristated when inactive.         */
	
	switch (ActiveInactive)
     4d0:	81 30       	cpi	r24, 0x01	; 1
     4d2:	18 f0       	brcs	.+6      	; 0x4da <MAIN_ResetCSLine+0xe>
     4d4:	82 30       	cpi	r24, 0x02	; 2
     4d6:	01 f5       	brne	.+64     	; 0x518 <__stack+0x19>
     4d8:	09 c0       	rjmp	.+18     	; 0x4ec <MAIN_ResetCSLine+0x20>
	{
		case MAIN_RESETCS_ACTIVE:                // The target RESET line may be either active high or low.
			DDRF |= (1 << 6);
     4da:	86 9a       	sbi	0x10, 6	; 16
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     4dc:	a1 e0       	ldi	r26, 0x01	; 1
     4de:	b0 e0       	ldi	r27, 0x00	; 0
     4e0:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
     4e4:	80 2d       	mov	r24, r0
		
			if (eeprom_read_byte(&EEPROMVars.ResetPolarity)) // Translate to correct active logic level for target device type
     4e6:	88 23       	and	r24, r24
     4e8:	59 f4       	brne	.+22     	; 0x500 <__stack+0x1>
     4ea:	13 c0       	rjmp	.+38     	; 0x512 <__stack+0x13>
			  PORTF &= ~(1 << 6);
			else
			  PORTF |= (1 << 6);
		
			break;
		case MAIN_RESETCS_EXTDFACTIVE:           // Dataflashes are always active low.
			DDRF  |=  (1 << 6);
     4ec:	86 9a       	sbi	0x10, 6	; 16
     4ee:	08 c0       	rjmp	.+16     	; 0x500 <__stack+0x1>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     4f0:	a9 e8       	ldi	r26, 0x89	; 137
     4f2:	b0 e0       	ldi	r27, 0x00	; 0
     4f4:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
     4f8:	80 2d       	mov	r24, r0
			PORTF &= ~(1 << 6);
			
			break;
		case MAIN_RESETCS_INACTIVE:              // Must determine what to do for inactive RESET.
			if (eeprom_read_byte(&EEPROMVars.SPIResetMode)) // FLOAT mode reset
     4fa:	88 23       	and	r24, r24
     4fc:	19 f0       	breq	.+6      	; 0x504 <__stack+0x5>
			{
				DDRF  &= ~(1 << 6);
     4fe:	86 98       	cbi	0x10, 6	; 16
				PORTF &= ~(1 << 6);
     500:	8e 98       	cbi	0x11, 6	; 17
     502:	08 95       	ret
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     504:	a1 e0       	ldi	r26, 0x01	; 1
     506:	b0 e0       	ldi	r27, 0x00	; 0
     508:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
     50c:	80 2d       	mov	r24, r0
			}
			else                                 // ACTIVE mode reset
			{
				if (eeprom_read_byte(&EEPROMVars.ResetPolarity)) // Translate to correct inactive logic level for target device type
     50e:	88 23       	and	r24, r24
     510:	11 f0       	breq	.+4      	; 0x516 <__stack+0x17>
				  PORTF |= (1 << 6);
     512:	8e 9a       	sbi	0x11, 6	; 17
     514:	08 95       	ret
				else
				  PORTF &= ~(1 << 6);			
     516:	8e 98       	cbi	0x11, 6	; 17
     518:	08 95       	ret

0000051a <MAIN_WaitForJoyRelease>:
			}
	}
}

void MAIN_WaitForJoyRelease(void)
{
     51a:	8e b3       	in	r24, 0x1e	; 30
     51c:	88 23       	and	r24, r24
     51e:	e9 f7       	brne	.-6      	; 0x51a <MAIN_WaitForJoyRelease>
	for (;;)
	{
		while (JoyStatus) {};                    // Wait until joystick released

		MAIN_Delay10MS(2);
     520:	82 e0       	ldi	r24, 0x02	; 2
     522:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>

		if (!(JoyStatus))                        // Joystick still released (not bouncing), return
     526:	8e b3       	in	r24, 0x1e	; 30
     528:	88 23       	and	r24, r24
     52a:	b9 f7       	brne	.-18     	; 0x51a <MAIN_WaitForJoyRelease>
     52c:	08 95       	ret

0000052e <MAIN_IntToStr>:
		  return;
	}
}

void MAIN_IntToStr(uint16_t IntV, uint8_t* Buff)
{
     52e:	cf 93       	push	r28
     530:	df 93       	push	r29
     532:	fb 01       	movw	r30, r22
     534:	20 e0       	ldi	r18, 0x00	; 0
     536:	03 c0       	rjmp	.+6      	; 0x53e <MAIN_IntToStr+0x10>
	// Shows leading zeros, unlike itoa.

	uint8_t Temp = 0;
	
	while (IntV >= 100)
	{
		Temp++;
     538:	2f 5f       	subi	r18, 0xFF	; 255
		IntV -= 100;
     53a:	84 56       	subi	r24, 0x64	; 100
     53c:	90 40       	sbci	r25, 0x00	; 0
     53e:	84 36       	cpi	r24, 0x64	; 100
     540:	91 05       	cpc	r25, r1
     542:	d0 f7       	brcc	.-12     	; 0x538 <MAIN_IntToStr+0xa>
	}

	*(Buff++) = '0' + Temp;
     544:	20 5d       	subi	r18, 0xD0	; 208
     546:	21 93       	st	Z+, r18
     548:	df 01       	movw	r26, r30
     54a:	20 e0       	ldi	r18, 0x00	; 0
     54c:	02 c0       	rjmp	.+4      	; 0x552 <MAIN_IntToStr+0x24>
	
	Temp = 0;
	
	while (IntV >= 10)
	{
		Temp++;
     54e:	2f 5f       	subi	r18, 0xFF	; 255
		IntV -= 10;
     550:	0a 97       	sbiw	r24, 0x0a	; 10
     552:	8a 30       	cpi	r24, 0x0A	; 10
     554:	91 05       	cpc	r25, r1
     556:	d8 f7       	brcc	.-10     	; 0x54e <MAIN_IntToStr+0x20>
	}
		
	*(Buff++) = '0' + Temp;
     558:	20 5d       	subi	r18, 0xD0	; 208
     55a:	fd 01       	movw	r30, r26
     55c:	21 93       	st	Z+, r18
	*(Buff++) = '0' + IntV;
     55e:	80 5d       	subi	r24, 0xD0	; 208
     560:	ed 01       	movw	r28, r26
     562:	89 83       	std	Y+1, r24	; 0x01
	*(Buff)   = '\0';
     564:	11 82       	std	Z+1, r1	; 0x01
     566:	df 91       	pop	r29
     568:	cf 91       	pop	r28
     56a:	08 95       	ret

0000056c <__vector_3>:
}

void MAIN_ShowProgType(const uint8_t Letter)
{
	uint8_t ProgTypeBuffer[7];

	strcpy_P(ProgTypeBuffer, PSTR("PRG>  "));
	ProgTypeBuffer[5] = Letter;
	
	LCD_puts(ProgTypeBuffer);
}

void MAIN_ShowError(const uint8_t *pFlashStr)
{
	uint8_t ErrorBuff[LCD_TEXTBUFFER_SIZE];      // New buffer, LCD text buffer size
	
	ErrorBuff[0] = 'E';
	ErrorBuff[1] = '>';

	strcpy_P(&ErrorBuff[2], pFlashStr);          // WARNING: If flash error text is larger than (TEXTBUFFER_SIZE - 1),
	                                             // this will overflow the buffer and crash the program!
	LCD_puts(ErrorBuff);
	
	MAIN_WaitForJoyRelease();
	while (!(JoyStatus & JOY_PRESS)) {};
	MAIN_WaitForJoyRelease();
}

void MAIN_CrashProgram(uint8_t *ErrTxtPtr)
{
	SPI_SPIOFF();
	USI_SPIOff();
	TIMEOUT_PACKET_TIMER_OFF();
	TIMEOUT_SLEEP_TIMER_OFF();
	USART_ENABLE(USART_TX_OFF, USART_RX_OFF);

	LCD_puts(ErrTxtPtr);	
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);	

	for (;;)
	{
		MAIN_Delay10MS(50);
		PORTF ^= MAIN_STATLED_RED;               // Loop forever, blinking the status LED from orange to red and back
	}
}

// ======================================================================================

ISR(PCINT1_vect, ISR_NOBLOCK)                    // Joystick routine; PCINT0_vect is bound to this also via JoystickInterrupt.S
{
     56c:	78 94       	sei
     56e:	1f 92       	push	r1
     570:	0f 92       	push	r0
     572:	0f b6       	in	r0, 0x3f	; 63
     574:	0f 92       	push	r0
     576:	11 24       	eor	r1, r1
     578:	8f 93       	push	r24
     57a:	9f 93       	push	r25
	JoyStatus = (~PINB & JOY_BMASK)
     57c:	83 b1       	in	r24, 0x03	; 3
     57e:	9c b1       	in	r25, 0x0c	; 12
     580:	80 95       	com	r24
     582:	80 7d       	andi	r24, 0xD0	; 208
     584:	90 95       	com	r25
     586:	9c 70       	andi	r25, 0x0C	; 12
     588:	89 2b       	or	r24, r25
     58a:	8e bb       	out	0x1e, r24	; 30
	          | (~PINE & JOY_EMASK);
			  
	TIMEOUT_SLEEP_TIMEOUT_RESET();
     58c:	10 92 8e 01 	sts	0x018E, r1
     590:	10 92 8d 01 	sts	0x018D, r1
     594:	10 92 85 00 	sts	0x0085, r1
     598:	10 92 84 00 	sts	0x0084, r1
     59c:	9f 91       	pop	r25
     59e:	8f 91       	pop	r24
     5a0:	0f 90       	pop	r0
     5a2:	0f be       	out	0x3f, r0	; 63
     5a4:	0f 90       	pop	r0
     5a6:	1f 90       	pop	r1
     5a8:	18 95       	reti

000005aa <FUNCSleepMode>:
}

ISR(BADISR_vect, ISR_NAKED)                      // Bad ISR routine; should never be called, here for safety
{
	MAIN_CrashProgram(PSTR("BADISR"));
}

// ======================================================================================

void FUNCChangeSettings(void)
{
	uint8_t CurrSFunc = 0;
	
	JoyStatus = 1;

	for (;;)
	{
		if (JoyStatus)                           // Joystick is in the non-center position
		{
			if (JoyStatus & JOY_UP)              // Previous function
			  (CurrSFunc == 0)? CurrSFunc = ARRAY_UPPERBOUND(SettingFunctionPtrs) : CurrSFunc--;
			else if (JoyStatus & JOY_DOWN)       // Next function
			  (CurrSFunc == ARRAY_UPPERBOUND(SettingFunctionPtrs))? CurrSFunc = 0 : CurrSFunc++;
			else if (JoyStatus & JOY_PRESS)      // Select current function
			  ((FuncPtr)pgm_read_word(&SettingFunctionPtrs[CurrSFunc]))(); // Run associated function
			else if (JoyStatus & JOY_LEFT)
			  return;
		
			// Show current function onto the LCD:
			LCD_puts_f((uint8_t*)pgm_read_word(&SettingFunctionNames[CurrSFunc]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCShowAbout(void)
{
	uint8_t InfoNum = 0;
	
	JoyStatus = 1;
			
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			  (InfoNum == 0)? InfoNum = ARRAY_UPPERBOUND(AboutTextPtrs) : InfoNum--;
			else if (JoyStatus & JOY_DOWN)
			  (InfoNum == ARRAY_UPPERBOUND(AboutTextPtrs))? InfoNum = 0 : InfoNum++;
			else if (JoyStatus & JOY_LEFT)
			  return;

			LCD_puts_f((uint8_t*)pgm_read_word(&AboutTextPtrs[InfoNum]));

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCAVRISPMode(void)
{
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(AVRISPModeMessage);
	
	V2P_RunStateMachine(AICI_InterpretPacket);
}

void FUNCProgramDataflash(void)
{
	USI_SPIInitMaster();
	DataflashInfo.UseExernalDF = TRUE;
	DFSPIRoutinePointer = USI_SPITransmit;
	
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(DataFlashProgMode);

	V2P_RunStateMachine(PD_InterpretAVRISPPacket);
	   
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
}

void FUNCProgramAVR(void)
{
	uint8_t  DoneFailMessageBuff[19];
	uint8_t  Fault    = ISPCC_NO_FAULT;
	uint8_t  ProgMode = 0;

	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
	SPI_SPIInit();
	DataflashInfo.UseExernalDF = FALSE;
	
	if (!(DF_CheckCorrectOnboardChip()))
	  return;

	MAIN_WaitForJoyRelease();
	
	JoyStatus = 1;                               // Use an invalid joystick value to force the program to write the
	                                             // name of the default command onto the LCD
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_LEFT)
			  return;
			else if (JoyStatus & JOY_PRESS)
			  break;
			else if (JoyStatus & JOY_UP)
			  (ProgMode == 0)? ProgMode = ARRAY_UPPERBOUND(ProgOptions) : ProgMode--;
			else if (JoyStatus & JOY_DOWN)
			  (ProgMode == ARRAY_UPPERBOUND(ProgOptions))? ProgMode = 0 : ProgMode++;

			LCD_puts_f((uint8_t*)pgm_read_word(&ProgOptions[ProgMode])); // Show current function onto the LCD

			MAIN_WaitForJoyRelease();
		}
	}

	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_BASECLOCKSPEED_8MHZ);
	LCD_puts_f(WaitText);

	TIMEOUT_SLEEP_TIMER_OFF();

	USI_SPIInitMaster();
	MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);       // Capture the RESET line of the slave AVR
			
	for (uint8_t PacketB = 0; PacketB < 12; PacketB++) // Read the enter programming mode command bytes
	  PacketBytes[PacketB] = eeprom_read_byte(&EEPROMVars.EnterProgMode[PacketB]);
	
	ISPCC_EnterChipProgrammingMode();            // Try to sync with the slave AVR

	CurrAddress = 0;

	if (PacketBytes[1] == AICB_STATUS_CMD_OK)    // ISPCC_EnterChipProgrammingMode alters the PacketBytes buffer rather than returning a value
	{						
		if (!(ProgMode) || (ProgMode == 7) || (ProgMode == 1) || (ProgMode == 3)) // All, erase chip, flash and eeprom, or program flash mode
		{
			MAIN_ShowProgType('C');
			
			if (!(eeprom_read_byte(&EEPROMVars.EraseCmdStored) == TRUE))
			{
				Fault = ISPCC_FAULT_NOERASE;
				MAIN_ShowError(PSTR("NO ERASE CMD"));
			}
			else
			{
				PM_SendEraseCommand();
			}
		}

		if ((!(ProgMode) || (ProgMode == 1) || (ProgMode == 3)) && (Fault == ISPCC_NO_FAULT)) // All, flash and EEPROM, or program flash mode
		{
			MAIN_ShowProgType('D');

			if (!(PM_GetStoredDataSize(TYPE_FLASH))) // Check to make sure a program is present in memory
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
				MAIN_ShowError(PSTR("NO DATA"));
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_FLASH);
			}
		}
	
		if (!(ProgMode) || (ProgMode == 2) || (ProgMode == 3)) // All, flash and EEPROM, or program EEPROM mode
		{
			MAIN_ShowProgType('E');
				
			if (!(PM_GetStoredDataSize(TYPE_EEPROM))) // Check to make sure EEPROM data is present in memory
			{
				Fault = ISPCC_FAULT_NODATATYPE;
				MAIN_ShowError(PSTR("NO EEPROM"));
			}
			else
			{
				PM_CreateProgrammingPackets(TYPE_EEPROM);
			}
		}

		if (!(ProgMode) || (ProgMode == 4) || (ProgMode == 6)) // All, fuse and lock bytes, or program fuse bytes mode
		{
			MAIN_ShowProgType('F');
			
			if (!(eeprom_read_byte(&EEPROMVars.TotalFuseBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;					
				MAIN_ShowError(PSTR("NO FUSE BYTES"));
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_FUSE);
			}
		}

		if (!(ProgMode) || (ProgMode == 5) || (ProgMode == 6)) // All, fuse and lock bytes, or program lock bytes mode
		{
			if (ProgMode == 6)                           // If fusebytes have already been written, we need to reenter programming mode to latch them
			{
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line of the slave AVR
				MAIN_Delay10MS(1);
				MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);   // Capture the RESET line of the slave AVR
				ISPCC_EnterChipProgrammingMode();        // Try to sync with the slave AVR
			}

			MAIN_ShowProgType('L');
		
			if (!(eeprom_read_byte(&EEPROMVars.TotalLockBytes)))
			{
				Fault = ISPCC_FAULT_NODATATYPE;
				MAIN_ShowError(PSTR("NO LOCK BYTES"));
			}
			else
			{
				PM_SendFuseLockBytes(TYPE_LOCK);
			}
		}

		strcpy_P(DoneFailMessageBuff, PSTR("PROGRAMMING DONE"));

		if (Fault != ISPCC_NO_FAULT)             // Takes less code to just overwrite part of the string on fail
		  strcpy_P(&DoneFailMessageBuff[12], PSTR("FAILED"));

		LCD_puts(DoneFailMessageBuff);

		MAIN_Delay10MS(250);
		MAIN_Delay10MS(200);
	}
	else
	{
		MAIN_ShowError(SyncErrorMessage);
	}
	
	TOUT_SetupSleepTimer();
	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_BASECLOCKSPEED_1MHZ);
	MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);     // Release the RESET line and allow the slave AVR to run	
	USI_SPIOff();
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);       // Set status LEDs to green (ready)
}

void FUNCStoreProgram(void)
{
	DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
	SPI_SPIInit();
	DataflashInfo.UseExernalDF = FALSE;
	DF_EnableDataflash(TRUE);

	if (!(DF_CheckCorrectOnboardChip()))
	  return;
			
	USART_ENABLE(USART_TX_ON, USART_RX_ON);
	LCD_puts_f(PSTR("*STORAGE MODE*"));

	V2P_RunStateMachine(PM_InterpretAVRISPPacket);
	
	DF_EnableDataflash(FALSE);
	SPI_SPIOFF();
}

void FUNCClearMem(void)
{
	LCD_puts_f(PSTR("CONFIRM"));
	MAIN_Delay10MS(180);

	LCD_puts_f(PSTR("<N Y>"));

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_LEFT)
			  return;
			else if (JoyStatus & JOY_RIGHT)
			  break;
		}
	}

	MAIN_WaitForJoyRelease();

	LCD_puts_f(WaitText);
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);      // Set status LEDs to orange (busy)

	for (uint16_t EAddr = 0; EAddr < sizeof(EEPROMVars); EAddr++)
	  eeprom_write_byte((uint8_t*)EAddr, 0xFF);

	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);       // Set status LEDs to green (ready)
	LCD_puts_f(PSTR("MEM CLEARED"));
	MAIN_Delay10MS(250);
}

void FUNCSetContrast(void)
{
	uint8_t Buffer[6];
	uint8_t Contrast = (eeprom_read_byte(&EEPROMVars.LCDContrast) & 0x0F); // Ranges from 0-15 so mask retuns 15 on blank EEPROM (0xFF)
	
	JoyStatus = 1;                               // Invalid value to force the LCD to update
	
	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				if (Contrast < 15)
				  Contrast++;
			}
			else if (JoyStatus & JOY_DOWN)
			{
				if (Contrast > 1)                // Zero is non-visible, so 1 is the minimum
				  Contrast--;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.LCDContrast, Contrast);
				return;
			}
					
			Buffer[0] = 'C';
			Buffer[1] = 'T';
			Buffer[2] = ' ';

			MAIN_IntToStr((uint16_t)Contrast, &Buffer[3]);
			LCD_puts(Buffer);

			LCD_CONTRAST_LEVEL(Contrast);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCSetISPSpeed(void)
{
	uint8_t CurrSpeed = eeprom_read_byte(&EEPROMVars.SCKDuration);

	if (CurrSpeed > ARRAY_UPPERBOUND(USISpeeds))
	  CurrSpeed = ARRAY_UPPERBOUND(USISpeeds);   // Protection against blank EEPROM

	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				(CurrSpeed == 0)? CurrSpeed = ARRAY_UPPERBOUND(USISpeeds) : CurrSpeed--;
			}
			else if (JoyStatus & JOY_DOWN)
			{
				(CurrSpeed == ARRAY_UPPERBOUND(USISpeeds))? CurrSpeed = 0 : CurrSpeed++;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.SCKDuration, CurrSpeed);
				return;
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f(USISpeeds[CurrSpeed]);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCSetResetMode(void)
{
	uint8_t CurrMode = (eeprom_read_byte(&EEPROMVars.SPIResetMode) & 0x01);

	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if ((JoyStatus & JOY_UP) || (JoyStatus & JOY_DOWN))
			{
				CurrMode ^= 1;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.SPIResetMode, CurrMode);
				return;
			}
			
			// Show selected USI speed value onto the LCD:
			LCD_puts_f(SPIResetModes[CurrMode]);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCSetFirmMinorVer(void)
{
	uint8_t VerBuffer[5];
	uint8_t VerMinor = eeprom_read_byte(&EEPROMVars.FirmVerMinor);

	if (VerMinor > 9)
	  VerMinor = V2P_SW_VERSION_MINOR_DEFAULT;
	
	strcpy_P(VerBuffer, PSTR("V2- "));

	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				if (VerMinor < 9)
				  VerMinor++;
			}
			if (JoyStatus & JOY_DOWN)
			{
				if (VerMinor)
				  VerMinor--;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.FirmVerMinor, VerMinor);
				return;
			}
			
			VerBuffer[3] = ('0' + VerMinor);
			LCD_puts(VerBuffer);

			MAIN_WaitForJoyRelease();
		}
	}	
}

void FUNCSetAutoSleepTimeOut(void)
{
	uint8_t SleepTxtBuffer[8];
	uint8_t SleepVal = eeprom_read_byte(&EEPROMVars.AutoSleepValIndex);

	if (SleepVal > ARRAY_UPPERBOUND(AutoSleepTOValues))
	  SleepVal = ARRAY_UPPERBOUND(AutoSleepTOValues);

	strcpy_P(SleepTxtBuffer, PSTR("    SEC"));
	
	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & JOY_UP)
			{
				(SleepVal == 0)? SleepVal = ARRAY_UPPERBOUND(AutoSleepTOValues) : SleepVal--;
			}
			if (JoyStatus & JOY_DOWN)
			{
				(SleepVal == ARRAY_UPPERBOUND(AutoSleepTOValues))? SleepVal = 0 : SleepVal++;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				eeprom_write_byte(&EEPROMVars.AutoSleepValIndex, SleepVal);
				TOUT_SetupSleepTimer();
				return;
			}

			if (!(SleepVal))
			{
				LCD_puts_f(PSTR("OFF"));
			}
			else
			{
				MAIN_IntToStr(pgm_read_byte(&AutoSleepTOValues[SleepVal]), &SleepTxtBuffer[0]);
				SleepTxtBuffer[3] = ' ';         // Remove the auto-string termination from the buffer
				LCD_puts(SleepTxtBuffer);
			}

			MAIN_WaitForJoyRelease();
		}
	}	
}

void FUNCSleepMode(void)
{
     5aa:	85 e0       	ldi	r24, 0x05	; 5
     5ac:	83 bf       	out	0x33, r24	; 51
	SMCR    = ((1 << SM1) | (1 << SE));          // Power down sleep mode
	LCDCRA &= ~(1 << LCDEN); 
     5ae:	80 91 e4 00 	lds	r24, 0x00E4
     5b2:	8f 77       	andi	r24, 0x7F	; 127
     5b4:	80 93 e4 00 	sts	0x00E4, r24
	
	MAIN_SETSTATUSLED(MAIN_STATLED_OFF);         // Save battery power - turn off status LED
     5b8:	81 b3       	in	r24, 0x11	; 17
     5ba:	8f 7c       	andi	r24, 0xCF	; 207
     5bc:	81 bb       	out	0x11, r24	; 17
     5be:	01 c0       	rjmp	.+2      	; 0x5c2 <FUNCSleepMode+0x18>

	while (!(JoyStatus & JOY_UP))                // Joystick interrupt wakes the micro
	  SLEEP();
     5c0:	88 95       	sleep
     5c2:	f6 9b       	sbis	0x1e, 6	; 30
     5c4:	fd cf       	rjmp	.-6      	; 0x5c0 <FUNCSleepMode+0x16>
	   
	MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);       // Turn status LED back on
     5c6:	81 b3       	in	r24, 0x11	; 17
     5c8:	8f 7c       	andi	r24, 0xCF	; 207
     5ca:	80 61       	ori	r24, 0x10	; 16
     5cc:	81 bb       	out	0x11, r24	; 17

	LCDCRA |= (1 << LCDEN);
     5ce:	80 91 e4 00 	lds	r24, 0x00E4
     5d2:	80 68       	ori	r24, 0x80	; 128
     5d4:	80 93 e4 00 	sts	0x00E4, r24
	
	MAIN_WaitForJoyRelease();
     5d8:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     5dc:	08 95       	ret

000005de <FUNCGoBootloader>:
}

void FUNCStorageInfo(void)
{
	uint8_t SelectedItem = 0;

	MAIN_WaitForJoyRelease();

	JoyStatus = 1;                               // Invalid value to force the LCD to update

	for (;;)
	{
		if (JoyStatus)
		{
			if (JoyStatus & (JOY_UP | JOY_DOWN))
			{
				SelectedItem ^= 1;
			}
			else if (JoyStatus & JOY_LEFT)
			{
				return;
			}
			else if (JoyStatus & JOY_PRESS)
			{
				if (SelectedItem == 1)           // View storage tags
				{
					DFSPIRoutinePointer = (SPIFuncPtr)SPI_SPITransmit;
					SPI_SPIInit();
					DataflashInfo.UseExernalDF = FALSE;
					DF_EnableDataflash(TRUE);

					if (DF_CheckCorrectOnboardChip())
					{
						TM_ShowTags();
						SPI_SPIOFF();
					}
					else if (!(PM_GetStoredDataSize(TYPE_FLASH)))
					{
						DF_EnableDataflash(FALSE);
						SPI_SPIOFF();

						MAIN_ShowError(PSTR("NO STORED PRGM"));
					}	
				}
				else                             // View stored data sizes
				{
					PM_ShowStoredItemSizes();
				}
			}
			
			LCD_puts_f(SIFONames[SelectedItem]);

			MAIN_WaitForJoyRelease();
		}
	}
}

void FUNCGoBootloader(void)
{
     5de:	85 b7       	in	r24, 0x35	; 53
     5e0:	8f 77       	andi	r24, 0x7F	; 127
	uint8_t MD = (MCUCR & ~(1 << JTD));         // Forces compiler to use IN, AND plus two OUTs rather than two lots of IN/AND/OUTs
	MCUCR = MD;                                 // Turn on JTAG via code
     5e2:	85 bf       	out	0x35, r24	; 53
	MCUCR = MD;                                 // Set bit twice as specified in datasheet        
     5e4:	85 bf       	out	0x35, r24	; 53

	TIMEOUT_SLEEP_TIMER_OFF();
     5e6:	10 92 81 00 	sts	0x0081, r1
	
	LCD_puts_f(PSTR("*JTAG ON*"));
     5ea:	88 e7       	ldi	r24, 0x78	; 120
     5ec:	92 e0       	ldi	r25, 0x02	; 2
     5ee:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
	
	MAIN_WaitForJoyRelease();
     5f2:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
	
	WDTCR = ((1<<WDCE) | (1<<WDE));             // Enable Watchdog Timer to give reset after minimum timeout
     5f6:	88 e1       	ldi	r24, 0x18	; 24
     5f8:	80 93 60 00 	sts	0x0060, r24
     5fc:	ff cf       	rjmp	.-2      	; 0x5fc <FUNCGoBootloader+0x1e>

000005fe <FUNCShowAbout>:
     5fe:	1f 93       	push	r17
     600:	81 e0       	ldi	r24, 0x01	; 1
     602:	8e bb       	out	0x1e, r24	; 30
     604:	10 e0       	ldi	r17, 0x00	; 0
     606:	8e b3       	in	r24, 0x1e	; 30
     608:	88 23       	and	r24, r24
     60a:	e9 f3       	breq	.-6      	; 0x606 <FUNCShowAbout+0x8>
     60c:	f6 9b       	sbis	0x1e, 6	; 30
     60e:	06 c0       	rjmp	.+12     	; 0x61c <FUNCShowAbout+0x1e>
     610:	11 23       	and	r17, r17
     612:	11 f4       	brne	.+4      	; 0x618 <FUNCShowAbout+0x1a>
     614:	13 e0       	ldi	r17, 0x03	; 3
     616:	0c c0       	rjmp	.+24     	; 0x630 <FUNCShowAbout+0x32>
     618:	11 50       	subi	r17, 0x01	; 1
     61a:	0a c0       	rjmp	.+20     	; 0x630 <FUNCShowAbout+0x32>
     61c:	f7 9b       	sbis	0x1e, 7	; 30
     61e:	06 c0       	rjmp	.+12     	; 0x62c <FUNCShowAbout+0x2e>
     620:	13 30       	cpi	r17, 0x03	; 3
     622:	11 f4       	brne	.+4      	; 0x628 <FUNCShowAbout+0x2a>
     624:	10 e0       	ldi	r17, 0x00	; 0
     626:	04 c0       	rjmp	.+8      	; 0x630 <FUNCShowAbout+0x32>
     628:	1f 5f       	subi	r17, 0xFF	; 255
     62a:	02 c0       	rjmp	.+4      	; 0x630 <FUNCShowAbout+0x32>
     62c:	f2 99       	sbic	0x1e, 2	; 30
     62e:	0d c0       	rjmp	.+26     	; 0x64a <FUNCShowAbout+0x4c>
     630:	e1 2f       	mov	r30, r17
     632:	ff 27       	eor	r31, r31
     634:	ee 0f       	add	r30, r30
     636:	ff 1f       	adc	r31, r31
     638:	e1 56       	subi	r30, 0x61	; 97
     63a:	ff 4f       	sbci	r31, 0xFF	; 255
     63c:	85 91       	lpm	r24, Z+
     63e:	94 91       	lpm	r25, Z
     640:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     644:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     648:	de cf       	rjmp	.-68     	; 0x606 <FUNCShowAbout+0x8>
     64a:	1f 91       	pop	r17
     64c:	08 95       	ret

0000064e <FUNCChangeSettings>:
     64e:	1f 93       	push	r17
     650:	81 e0       	ldi	r24, 0x01	; 1
     652:	8e bb       	out	0x1e, r24	; 30
     654:	10 e0       	ldi	r17, 0x00	; 0
     656:	8e b3       	in	r24, 0x1e	; 30
     658:	88 23       	and	r24, r24
     65a:	e9 f3       	breq	.-6      	; 0x656 <FUNCChangeSettings+0x8>
     65c:	f6 9b       	sbis	0x1e, 6	; 30
     65e:	06 c0       	rjmp	.+12     	; 0x66c <FUNCChangeSettings+0x1e>
     660:	11 23       	and	r17, r17
     662:	11 f4       	brne	.+4      	; 0x668 <FUNCChangeSettings+0x1a>
     664:	16 e0       	ldi	r17, 0x06	; 6
     666:	19 c0       	rjmp	.+50     	; 0x69a <FUNCChangeSettings+0x4c>
     668:	11 50       	subi	r17, 0x01	; 1
     66a:	17 c0       	rjmp	.+46     	; 0x69a <FUNCChangeSettings+0x4c>
     66c:	f7 9b       	sbis	0x1e, 7	; 30
     66e:	06 c0       	rjmp	.+12     	; 0x67c <FUNCChangeSettings+0x2e>
     670:	16 30       	cpi	r17, 0x06	; 6
     672:	11 f4       	brne	.+4      	; 0x678 <FUNCChangeSettings+0x2a>
     674:	10 e0       	ldi	r17, 0x00	; 0
     676:	11 c0       	rjmp	.+34     	; 0x69a <FUNCChangeSettings+0x4c>
     678:	1f 5f       	subi	r17, 0xFF	; 255
     67a:	0f c0       	rjmp	.+30     	; 0x69a <FUNCChangeSettings+0x4c>
     67c:	f4 9b       	sbis	0x1e, 4	; 30
     67e:	0b c0       	rjmp	.+22     	; 0x696 <FUNCChangeSettings+0x48>
     680:	e1 2f       	mov	r30, r17
     682:	ff 27       	eor	r31, r31
     684:	ee 0f       	add	r30, r30
     686:	ff 1f       	adc	r31, r31
     688:	e6 56       	subi	r30, 0x66	; 102
     68a:	fe 4f       	sbci	r31, 0xFE	; 254
     68c:	85 91       	lpm	r24, Z+
     68e:	94 91       	lpm	r25, Z
     690:	fc 01       	movw	r30, r24
     692:	09 95       	icall
     694:	02 c0       	rjmp	.+4      	; 0x69a <FUNCChangeSettings+0x4c>
     696:	f2 99       	sbic	0x1e, 2	; 30
     698:	0d c0       	rjmp	.+26     	; 0x6b4 <FUNCChangeSettings+0x66>
     69a:	e1 2f       	mov	r30, r17
     69c:	ff 27       	eor	r31, r31
     69e:	ee 0f       	add	r30, r30
     6a0:	ff 1f       	adc	r31, r31
     6a2:	e4 57       	subi	r30, 0x74	; 116
     6a4:	fe 4f       	sbci	r31, 0xFE	; 254
     6a6:	85 91       	lpm	r24, Z+
     6a8:	94 91       	lpm	r25, Z
     6aa:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     6ae:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     6b2:	d1 cf       	rjmp	.-94     	; 0x656 <FUNCChangeSettings+0x8>
     6b4:	1f 91       	pop	r17
     6b6:	08 95       	ret

000006b8 <FUNCSetAutoSleepTimeOut>:
     6b8:	ef 92       	push	r14
     6ba:	ff 92       	push	r15
     6bc:	0f 93       	push	r16
     6be:	cf 93       	push	r28
     6c0:	df 93       	push	r29
     6c2:	cd b7       	in	r28, 0x3d	; 61
     6c4:	de b7       	in	r29, 0x3e	; 62
     6c6:	28 97       	sbiw	r28, 0x08	; 8
     6c8:	0f b6       	in	r0, 0x3f	; 63
     6ca:	f8 94       	cli
     6cc:	de bf       	out	0x3e, r29	; 62
     6ce:	0f be       	out	0x3f, r0	; 63
     6d0:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     6d2:	a8 e8       	ldi	r26, 0x88	; 136
     6d4:	b0 e0       	ldi	r27, 0x00	; 0
     6d6:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
     6da:	80 2d       	mov	r24, r0
     6dc:	08 2f       	mov	r16, r24
     6de:	85 30       	cpi	r24, 0x05	; 5
     6e0:	08 f0       	brcs	.+2      	; 0x6e4 <FUNCSetAutoSleepTimeOut+0x2c>
     6e2:	04 e0       	ldi	r16, 0x04	; 4
     6e4:	65 e9       	ldi	r22, 0x95	; 149
     6e6:	72 e0       	ldi	r23, 0x02	; 2
     6e8:	ce 01       	movw	r24, r28
     6ea:	01 96       	adiw	r24, 0x01	; 1
     6ec:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <strcpy_P>
     6f0:	81 e0       	ldi	r24, 0x01	; 1
     6f2:	8e bb       	out	0x1e, r24	; 30
     6f4:	8e b3       	in	r24, 0x1e	; 30
     6f6:	88 23       	and	r24, r24
     6f8:	e9 f3       	breq	.-6      	; 0x6f4 <FUNCSetAutoSleepTimeOut+0x3c>
     6fa:	f6 9b       	sbis	0x1e, 6	; 30
     6fc:	05 c0       	rjmp	.+10     	; 0x708 <FUNCSetAutoSleepTimeOut+0x50>
     6fe:	00 23       	and	r16, r16
     700:	11 f4       	brne	.+4      	; 0x706 <FUNCSetAutoSleepTimeOut+0x4e>
     702:	04 e0       	ldi	r16, 0x04	; 4
     704:	01 c0       	rjmp	.+2      	; 0x708 <FUNCSetAutoSleepTimeOut+0x50>
     706:	01 50       	subi	r16, 0x01	; 1
     708:	f7 9b       	sbis	0x1e, 7	; 30
     70a:	06 c0       	rjmp	.+12     	; 0x718 <FUNCSetAutoSleepTimeOut+0x60>
     70c:	04 30       	cpi	r16, 0x04	; 4
     70e:	11 f4       	brne	.+4      	; 0x714 <FUNCSetAutoSleepTimeOut+0x5c>
     710:	00 e0       	ldi	r16, 0x00	; 0
     712:	06 c0       	rjmp	.+12     	; 0x720 <FUNCSetAutoSleepTimeOut+0x68>
     714:	0f 5f       	subi	r16, 0xFF	; 255
     716:	02 c0       	rjmp	.+4      	; 0x71c <FUNCSetAutoSleepTimeOut+0x64>
     718:	f2 99       	sbic	0x1e, 2	; 30
     71a:	1d c0       	rjmp	.+58     	; 0x756 <FUNCSetAutoSleepTimeOut+0x9e>
     71c:	00 23       	and	r16, r16
     71e:	29 f4       	brne	.+10     	; 0x72a <FUNCSetAutoSleepTimeOut+0x72>
     720:	81 e9       	ldi	r24, 0x91	; 145
     722:	92 e0       	ldi	r25, 0x02	; 2
     724:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     728:	13 c0       	rjmp	.+38     	; 0x750 <FUNCSetAutoSleepTimeOut+0x98>
     72a:	e0 2f       	mov	r30, r16
     72c:	ff 27       	eor	r31, r31
     72e:	ef 51       	subi	r30, 0x1F	; 31
     730:	fc 4f       	sbci	r31, 0xFC	; 252
     732:	e4 91       	lpm	r30, Z
     734:	7e 01       	movw	r14, r28
     736:	08 94       	sec
     738:	e1 1c       	adc	r14, r1
     73a:	f1 1c       	adc	r15, r1
     73c:	b7 01       	movw	r22, r14
     73e:	8e 2f       	mov	r24, r30
     740:	99 27       	eor	r25, r25
     742:	0e 94 97 02 	call	0x52e	; 0x52e <MAIN_IntToStr>
     746:	80 e2       	ldi	r24, 0x20	; 32
     748:	8c 83       	std	Y+4, r24	; 0x04
     74a:	c7 01       	movw	r24, r14
     74c:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
     750:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     754:	cf cf       	rjmp	.-98     	; 0x6f4 <FUNCSetAutoSleepTimeOut+0x3c>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     756:	a8 e8       	ldi	r26, 0x88	; 136
     758:	b0 e0       	ldi	r27, 0x00	; 0
     75a:	00 2e       	mov	r0, r16
     75c:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
     760:	0e 94 42 0c 	call	0x1884	; 0x1884 <TOUT_SetupSleepTimer>
     764:	28 96       	adiw	r28, 0x08	; 8
     766:	0f b6       	in	r0, 0x3f	; 63
     768:	f8 94       	cli
     76a:	de bf       	out	0x3e, r29	; 62
     76c:	0f be       	out	0x3f, r0	; 63
     76e:	cd bf       	out	0x3d, r28	; 61
     770:	df 91       	pop	r29
     772:	cf 91       	pop	r28
     774:	0f 91       	pop	r16
     776:	ff 90       	pop	r15
     778:	ef 90       	pop	r14
     77a:	08 95       	ret

0000077c <MAIN_ShowError>:
     77c:	cf 93       	push	r28
     77e:	df 93       	push	r29
     780:	cd b7       	in	r28, 0x3d	; 61
     782:	de b7       	in	r29, 0x3e	; 62
     784:	64 97       	sbiw	r28, 0x14	; 20
     786:	0f b6       	in	r0, 0x3f	; 63
     788:	f8 94       	cli
     78a:	de bf       	out	0x3e, r29	; 62
     78c:	0f be       	out	0x3f, r0	; 63
     78e:	cd bf       	out	0x3d, r28	; 61
     790:	25 e4       	ldi	r18, 0x45	; 69
     792:	29 83       	std	Y+1, r18	; 0x01
     794:	2e e3       	ldi	r18, 0x3E	; 62
     796:	2a 83       	std	Y+2, r18	; 0x02
     798:	bc 01       	movw	r22, r24
     79a:	ce 01       	movw	r24, r28
     79c:	03 96       	adiw	r24, 0x03	; 3
     79e:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <strcpy_P>
     7a2:	ce 01       	movw	r24, r28
     7a4:	01 96       	adiw	r24, 0x01	; 1
     7a6:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
     7aa:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     7ae:	f4 9b       	sbis	0x1e, 4	; 30
     7b0:	fe cf       	rjmp	.-4      	; 0x7ae <MAIN_ShowError+0x32>
     7b2:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     7b6:	64 96       	adiw	r28, 0x14	; 20
     7b8:	0f b6       	in	r0, 0x3f	; 63
     7ba:	f8 94       	cli
     7bc:	de bf       	out	0x3e, r29	; 62
     7be:	0f be       	out	0x3f, r0	; 63
     7c0:	cd bf       	out	0x3d, r28	; 61
     7c2:	df 91       	pop	r29
     7c4:	cf 91       	pop	r28
     7c6:	08 95       	ret

000007c8 <FUNCStorageInfo>:
     7c8:	1f 93       	push	r17
     7ca:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     7ce:	81 e0       	ldi	r24, 0x01	; 1
     7d0:	8e bb       	out	0x1e, r24	; 30
     7d2:	10 e0       	ldi	r17, 0x00	; 0
     7d4:	8e b3       	in	r24, 0x1e	; 30
     7d6:	88 23       	and	r24, r24
     7d8:	e9 f3       	breq	.-6      	; 0x7d4 <FUNCStorageInfo+0xc>
     7da:	8e b3       	in	r24, 0x1e	; 30
     7dc:	80 7c       	andi	r24, 0xC0	; 192
     7de:	19 f0       	breq	.+6      	; 0x7e6 <FUNCStorageInfo+0x1e>
     7e0:	81 e0       	ldi	r24, 0x01	; 1
     7e2:	18 27       	eor	r17, r24
     7e4:	36 c0       	rjmp	.+108    	; 0x852 <FUNCStorageInfo+0x8a>
     7e6:	f2 99       	sbic	0x1e, 2	; 30
     7e8:	3f c0       	rjmp	.+126    	; 0x868 <FUNCStorageInfo+0xa0>
     7ea:	f4 9b       	sbis	0x1e, 4	; 30
     7ec:	32 c0       	rjmp	.+100    	; 0x852 <FUNCStorageInfo+0x8a>
     7ee:	11 30       	cpi	r17, 0x01	; 1
     7f0:	71 f5       	brne	.+92     	; 0x84e <FUNCStorageInfo+0x86>
     7f2:	81 eb       	ldi	r24, 0xB1	; 177
     7f4:	99 e0       	ldi	r25, 0x09	; 9
     7f6:	90 93 01 01 	sts	0x0101, r25
     7fa:	80 93 00 01 	sts	0x0100, r24
     7fe:	0e 94 a7 09 	call	0x134e	; 0x134e <SPI_SPIInit>
     802:	10 92 47 01 	sts	0x0147, r1
     806:	81 e0       	ldi	r24, 0x01	; 1
     808:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
     80c:	0e 94 c3 0b 	call	0x1786	; 0x1786 <DF_CheckCorrectOnboardChip>
     810:	88 23       	and	r24, r24
     812:	41 f0       	breq	.+16     	; 0x824 <FUNCStorageInfo+0x5c>
     814:	0e 94 24 1a 	call	0x3448	; 0x3448 <TM_ShowTags>
     818:	80 91 64 00 	lds	r24, 0x0064
     81c:	84 60       	ori	r24, 0x04	; 4
     81e:	80 93 64 00 	sts	0x0064, r24
     822:	17 c0       	rjmp	.+46     	; 0x852 <FUNCStorageInfo+0x8a>
     824:	81 e0       	ldi	r24, 0x01	; 1
     826:	0e 94 f7 14 	call	0x29ee	; 0x29ee <PM_GetStoredDataSize>
     82a:	61 15       	cp	r22, r1
     82c:	71 05       	cpc	r23, r1
     82e:	81 05       	cpc	r24, r1
     830:	91 05       	cpc	r25, r1
     832:	79 f4       	brne	.+30     	; 0x852 <FUNCStorageInfo+0x8a>
     834:	80 e0       	ldi	r24, 0x00	; 0
     836:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
     83a:	80 91 64 00 	lds	r24, 0x0064
     83e:	84 60       	ori	r24, 0x04	; 4
     840:	80 93 64 00 	sts	0x0064, r24
     844:	82 e8       	ldi	r24, 0x82	; 130
     846:	92 e0       	ldi	r25, 0x02	; 2
     848:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
     84c:	02 c0       	rjmp	.+4      	; 0x852 <FUNCStorageInfo+0x8a>
     84e:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <PM_ShowStoredItemSizes>
     852:	8f e0       	ldi	r24, 0x0F	; 15
     854:	18 9f       	mul	r17, r24
     856:	c0 01       	movw	r24, r0
     858:	11 24       	eor	r1, r1
     85a:	86 5a       	subi	r24, 0xA6	; 166
     85c:	9d 4f       	sbci	r25, 0xFD	; 253
     85e:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     862:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     866:	b6 cf       	rjmp	.-148    	; 0x7d4 <FUNCStorageInfo+0xc>
     868:	1f 91       	pop	r17
     86a:	08 95       	ret

0000086c <MAIN_ShowProgType>:
     86c:	ff 92       	push	r15
     86e:	0f 93       	push	r16
     870:	1f 93       	push	r17
     872:	cf 93       	push	r28
     874:	df 93       	push	r29
     876:	cd b7       	in	r28, 0x3d	; 61
     878:	de b7       	in	r29, 0x3e	; 62
     87a:	27 97       	sbiw	r28, 0x07	; 7
     87c:	0f b6       	in	r0, 0x3f	; 63
     87e:	f8 94       	cli
     880:	de bf       	out	0x3e, r29	; 62
     882:	0f be       	out	0x3f, r0	; 63
     884:	cd bf       	out	0x3d, r28	; 61
     886:	f8 2e       	mov	r15, r24
     888:	8e 01       	movw	r16, r28
     88a:	0f 5f       	subi	r16, 0xFF	; 255
     88c:	1f 4f       	sbci	r17, 0xFF	; 255
     88e:	65 e2       	ldi	r22, 0x25	; 37
     890:	73 e0       	ldi	r23, 0x03	; 3
     892:	c8 01       	movw	r24, r16
     894:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <strcpy_P>
     898:	fe 82       	std	Y+6, r15	; 0x06
     89a:	c8 01       	movw	r24, r16
     89c:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
     8a0:	27 96       	adiw	r28, 0x07	; 7
     8a2:	0f b6       	in	r0, 0x3f	; 63
     8a4:	f8 94       	cli
     8a6:	de bf       	out	0x3e, r29	; 62
     8a8:	0f be       	out	0x3f, r0	; 63
     8aa:	cd bf       	out	0x3d, r28	; 61
     8ac:	df 91       	pop	r29
     8ae:	cf 91       	pop	r28
     8b0:	1f 91       	pop	r17
     8b2:	0f 91       	pop	r16
     8b4:	ff 90       	pop	r15
     8b6:	08 95       	ret

000008b8 <FUNCStoreProgram>:
     8b8:	81 eb       	ldi	r24, 0xB1	; 177
     8ba:	99 e0       	ldi	r25, 0x09	; 9
     8bc:	90 93 01 01 	sts	0x0101, r25
     8c0:	80 93 00 01 	sts	0x0100, r24
     8c4:	0e 94 a7 09 	call	0x134e	; 0x134e <SPI_SPIInit>
     8c8:	10 92 47 01 	sts	0x0147, r1
     8cc:	81 e0       	ldi	r24, 0x01	; 1
     8ce:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
     8d2:	0e 94 c3 0b 	call	0x1786	; 0x1786 <DF_CheckCorrectOnboardChip>
     8d6:	88 23       	and	r24, r24
     8d8:	e1 f0       	breq	.+56     	; 0x912 <FUNCStoreProgram+0x5a>
     8da:	87 ea       	ldi	r24, 0xA7	; 167
     8dc:	90 e0       	ldi	r25, 0x00	; 0
     8de:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     8e2:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <OSCCAL_Calibrate>
     8e6:	80 91 c1 00 	lds	r24, 0x00C1
     8ea:	80 78       	andi	r24, 0x80	; 128
     8ec:	88 61       	ori	r24, 0x18	; 24
     8ee:	80 93 c1 00 	sts	0x00C1, r24
     8f2:	8c eb       	ldi	r24, 0xBC	; 188
     8f4:	92 e0       	ldi	r25, 0x02	; 2
     8f6:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     8fa:	84 e5       	ldi	r24, 0x54	; 84
     8fc:	97 e1       	ldi	r25, 0x17	; 23
     8fe:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <V2P_RunStateMachine>
     902:	80 e0       	ldi	r24, 0x00	; 0
     904:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
     908:	80 91 64 00 	lds	r24, 0x0064
     90c:	84 60       	ori	r24, 0x04	; 4
     90e:	80 93 64 00 	sts	0x0064, r24
     912:	08 95       	ret

00000914 <FUNCAVRISPMode>:
     914:	87 ea       	ldi	r24, 0xA7	; 167
     916:	90 e0       	ldi	r25, 0x00	; 0
     918:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     91c:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <OSCCAL_Calibrate>
     920:	e1 ec       	ldi	r30, 0xC1	; 193
     922:	f0 e0       	ldi	r31, 0x00	; 0
     924:	80 81       	ld	r24, Z
     926:	80 78       	andi	r24, 0x80	; 128
     928:	88 61       	ori	r24, 0x18	; 24
     92a:	80 83       	st	Z, r24
     92c:	86 e3       	ldi	r24, 0x36	; 54
     92e:	94 e0       	ldi	r25, 0x04	; 4
     930:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     934:	8b ef       	ldi	r24, 0xFB	; 251
     936:	92 e1       	ldi	r25, 0x12	; 18
     938:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <V2P_RunStateMachine>
     93c:	08 95       	ret

0000093e <FUNCProgramDataflash>:
     93e:	0e 94 30 0a 	call	0x1460	; 0x1460 <USI_SPIInitMaster>
     942:	81 e0       	ldi	r24, 0x01	; 1
     944:	80 93 47 01 	sts	0x0147, r24
     948:	80 ef       	ldi	r24, 0xF0	; 240
     94a:	99 e0       	ldi	r25, 0x09	; 9
     94c:	90 93 01 01 	sts	0x0101, r25
     950:	80 93 00 01 	sts	0x0100, r24
     954:	87 ea       	ldi	r24, 0xA7	; 167
     956:	90 e0       	ldi	r25, 0x00	; 0
     958:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     95c:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <OSCCAL_Calibrate>
     960:	e1 ec       	ldi	r30, 0xC1	; 193
     962:	f0 e0       	ldi	r31, 0x00	; 0
     964:	80 81       	ld	r24, Z
     966:	80 78       	andi	r24, 0x80	; 128
     968:	88 61       	ori	r24, 0x18	; 24
     96a:	80 83       	st	Z, r24
     96c:	89 ef       	ldi	r24, 0xF9	; 249
     96e:	93 e0       	ldi	r25, 0x03	; 3
     970:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     974:	84 e6       	ldi	r24, 0x64	; 100
     976:	9d e0       	ldi	r25, 0x0D	; 13
     978:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <V2P_RunStateMachine>
     97c:	80 e0       	ldi	r24, 0x00	; 0
     97e:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
     982:	e4 e6       	ldi	r30, 0x64	; 100
     984:	f0 e0       	ldi	r31, 0x00	; 0
     986:	80 81       	ld	r24, Z
     988:	84 60       	ori	r24, 0x04	; 4
     98a:	80 83       	st	Z, r24
     98c:	08 95       	ret

0000098e <MAIN_CrashProgram>:
     98e:	8c 01       	movw	r16, r24
     990:	80 91 64 00 	lds	r24, 0x0064
     994:	84 60       	ori	r24, 0x04	; 4
     996:	80 93 64 00 	sts	0x0064, r24
     99a:	0e 94 e6 09 	call	0x13cc	; 0x13cc <USI_SPIOff>
     99e:	10 92 b0 00 	sts	0x00B0, r1
     9a2:	10 92 70 00 	sts	0x0070, r1
     9a6:	10 92 81 00 	sts	0x0081, r1
     9aa:	80 e8       	ldi	r24, 0x80	; 128
     9ac:	80 93 61 00 	sts	0x0061, r24
     9b0:	83 e0       	ldi	r24, 0x03	; 3
     9b2:	80 93 61 00 	sts	0x0061, r24
     9b6:	10 92 c1 00 	sts	0x00C1, r1
     9ba:	c8 01       	movw	r24, r16
     9bc:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
     9c0:	81 b3       	in	r24, 0x11	; 17
     9c2:	8f 7c       	andi	r24, 0xCF	; 207
     9c4:	80 63       	ori	r24, 0x30	; 48
     9c6:	81 bb       	out	0x11, r24	; 17
     9c8:	82 e3       	ldi	r24, 0x32	; 50
     9ca:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     9ce:	81 b3       	in	r24, 0x11	; 17
     9d0:	90 e2       	ldi	r25, 0x20	; 32
     9d2:	89 27       	eor	r24, r25
     9d4:	f8 cf       	rjmp	.-16     	; 0x9c6 <MAIN_CrashProgram+0x38>

000009d6 <__vector_default>:
     9d6:	8e e1       	ldi	r24, 0x1E	; 30
     9d8:	93 e0       	ldi	r25, 0x03	; 3
     9da:	0e 94 c7 04 	call	0x98e	; 0x98e <MAIN_CrashProgram>

000009de <FUNCProgramAVR>:
     9de:	0f 93       	push	r16
     9e0:	1f 93       	push	r17
     9e2:	cf 93       	push	r28
     9e4:	df 93       	push	r29
     9e6:	cd b7       	in	r28, 0x3d	; 61
     9e8:	de b7       	in	r29, 0x3e	; 62
     9ea:	63 97       	sbiw	r28, 0x13	; 19
     9ec:	0f b6       	in	r0, 0x3f	; 63
     9ee:	f8 94       	cli
     9f0:	de bf       	out	0x3e, r29	; 62
     9f2:	0f be       	out	0x3f, r0	; 63
     9f4:	cd bf       	out	0x3d, r28	; 61
     9f6:	81 eb       	ldi	r24, 0xB1	; 177
     9f8:	99 e0       	ldi	r25, 0x09	; 9
     9fa:	90 93 01 01 	sts	0x0101, r25
     9fe:	80 93 00 01 	sts	0x0100, r24
     a02:	0e 94 a7 09 	call	0x134e	; 0x134e <SPI_SPIInit>
     a06:	10 92 47 01 	sts	0x0147, r1
     a0a:	0e 94 c3 0b 	call	0x1786	; 0x1786 <DF_CheckCorrectOnboardChip>
     a0e:	88 23       	and	r24, r24
     a10:	09 f4       	brne	.+2      	; 0xa14 <FUNCProgramAVR+0x36>
     a12:	1d c1       	rjmp	.+570    	; 0xc4e <FUNCProgramAVR+0x270>
     a14:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     a18:	81 e0       	ldi	r24, 0x01	; 1
     a1a:	8e bb       	out	0x1e, r24	; 30
     a1c:	10 e0       	ldi	r17, 0x00	; 0
     a1e:	8e b3       	in	r24, 0x1e	; 30
     a20:	88 23       	and	r24, r24
     a22:	e9 f3       	breq	.-6      	; 0xa1e <FUNCProgramAVR+0x40>
     a24:	f2 99       	sbic	0x1e, 2	; 30
     a26:	13 c1       	rjmp	.+550    	; 0xc4e <FUNCProgramAVR+0x270>
     a28:	f4 99       	sbic	0x1e, 4	; 30
     a2a:	1c c0       	rjmp	.+56     	; 0xa64 <FUNCProgramAVR+0x86>
     a2c:	f6 9b       	sbis	0x1e, 6	; 30
     a2e:	06 c0       	rjmp	.+12     	; 0xa3c <FUNCProgramAVR+0x5e>
     a30:	11 23       	and	r17, r17
     a32:	11 f4       	brne	.+4      	; 0xa38 <FUNCProgramAVR+0x5a>
     a34:	17 e0       	ldi	r17, 0x07	; 7
     a36:	09 c0       	rjmp	.+18     	; 0xa4a <FUNCProgramAVR+0x6c>
     a38:	11 50       	subi	r17, 0x01	; 1
     a3a:	07 c0       	rjmp	.+14     	; 0xa4a <FUNCProgramAVR+0x6c>
     a3c:	f7 9b       	sbis	0x1e, 7	; 30
     a3e:	05 c0       	rjmp	.+10     	; 0xa4a <FUNCProgramAVR+0x6c>
     a40:	17 30       	cpi	r17, 0x07	; 7
     a42:	11 f4       	brne	.+4      	; 0xa48 <FUNCProgramAVR+0x6a>
     a44:	10 e0       	ldi	r17, 0x00	; 0
     a46:	01 c0       	rjmp	.+2      	; 0xa4a <FUNCProgramAVR+0x6c>
     a48:	1f 5f       	subi	r17, 0xFF	; 255
     a4a:	e1 2f       	mov	r30, r17
     a4c:	ff 27       	eor	r31, r31
     a4e:	ee 0f       	add	r30, r30
     a50:	ff 1f       	adc	r31, r31
     a52:	ea 5e       	subi	r30, 0xEA	; 234
     a54:	fd 4f       	sbci	r31, 0xFD	; 253
     a56:	85 91       	lpm	r24, Z+
     a58:	94 91       	lpm	r25, Z
     a5a:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     a5e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     a62:	dd cf       	rjmp	.-70     	; 0xa1e <FUNCProgramAVR+0x40>
     a64:	80 e8       	ldi	r24, 0x80	; 128
     a66:	80 93 61 00 	sts	0x0061, r24
     a6a:	10 92 61 00 	sts	0x0061, r1
     a6e:	87 ea       	ldi	r24, 0xA7	; 167
     a70:	90 e0       	ldi	r25, 0x00	; 0
     a72:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     a76:	10 92 81 00 	sts	0x0081, r1
     a7a:	0e 94 30 0a 	call	0x1460	; 0x1460 <USI_SPIInitMaster>
     a7e:	80 e0       	ldi	r24, 0x00	; 0
     a80:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     a84:	24 e2       	ldi	r18, 0x24	; 36
     a86:	30 e0       	ldi	r19, 0x00	; 0
     a88:	e1 e9       	ldi	r30, 0x91	; 145
     a8a:	f1 e0       	ldi	r31, 0x01	; 1
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     a8c:	d9 01       	movw	r26, r18
     a8e:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
     a92:	80 2d       	mov	r24, r0
     a94:	81 93       	st	Z+, r24
     a96:	2f 5f       	subi	r18, 0xFF	; 255
     a98:	3f 4f       	sbci	r19, 0xFF	; 255
     a9a:	80 e0       	ldi	r24, 0x00	; 0
     a9c:	20 33       	cpi	r18, 0x30	; 48
     a9e:	38 07       	cpc	r19, r24
     aa0:	a9 f7       	brne	.-22     	; 0xa8c <FUNCProgramAVR+0xae>
     aa2:	0e 94 9a 12 	call	0x2534	; 0x2534 <ISPCC_EnterChipProgrammingMode>
     aa6:	10 92 a9 02 	sts	0x02A9, r1
     aaa:	10 92 aa 02 	sts	0x02AA, r1
     aae:	10 92 ab 02 	sts	0x02AB, r1
     ab2:	10 92 ac 02 	sts	0x02AC, r1
     ab6:	80 91 92 01 	lds	r24, 0x0192
     aba:	88 23       	and	r24, r24
     abc:	09 f0       	breq	.+2      	; 0xac0 <FUNCProgramAVR+0xe2>
     abe:	aa c0       	rjmp	.+340    	; 0xc14 <FUNCProgramAVR+0x236>
     ac0:	11 23       	and	r17, r17
     ac2:	31 f0       	breq	.+12     	; 0xad0 <FUNCProgramAVR+0xf2>
     ac4:	17 30       	cpi	r17, 0x07	; 7
     ac6:	21 f0       	breq	.+8      	; 0xad0 <FUNCProgramAVR+0xf2>
     ac8:	11 30       	cpi	r17, 0x01	; 1
     aca:	11 f0       	breq	.+4      	; 0xad0 <FUNCProgramAVR+0xf2>
     acc:	13 30       	cpi	r17, 0x03	; 3
     ace:	91 f4       	brne	.+36     	; 0xaf4 <FUNCProgramAVR+0x116>
     ad0:	83 e4       	ldi	r24, 0x43	; 67
     ad2:	0e 94 36 04 	call	0x86c	; 0x86c <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     ad6:	a5 e1       	ldi	r26, 0x15	; 21
     ad8:	b0 e0       	ldi	r27, 0x00	; 0
     ada:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
     ade:	80 2d       	mov	r24, r0
     ae0:	81 30       	cpi	r24, 0x01	; 1
     ae2:	31 f0       	breq	.+12     	; 0xaf0 <FUNCProgramAVR+0x112>
     ae4:	81 e1       	ldi	r24, 0x11	; 17
     ae6:	93 e0       	ldi	r25, 0x03	; 3
     ae8:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
     aec:	02 e0       	ldi	r16, 0x02	; 2
     aee:	03 c0       	rjmp	.+6      	; 0xaf6 <FUNCProgramAVR+0x118>
     af0:	0e 94 99 15 	call	0x2b32	; 0x2b32 <PM_SendEraseCommand>
     af4:	00 e0       	ldi	r16, 0x00	; 0
     af6:	12 30       	cpi	r17, 0x02	; 2
     af8:	10 f0       	brcs	.+4      	; 0xafe <FUNCProgramAVR+0x120>
     afa:	13 30       	cpi	r17, 0x03	; 3
     afc:	c1 f4       	brne	.+48     	; 0xb2e <FUNCProgramAVR+0x150>
     afe:	00 23       	and	r16, r16
     b00:	a1 f4       	brne	.+40     	; 0xb2a <FUNCProgramAVR+0x14c>
     b02:	84 e4       	ldi	r24, 0x44	; 68
     b04:	0e 94 36 04 	call	0x86c	; 0x86c <MAIN_ShowProgType>
     b08:	81 e0       	ldi	r24, 0x01	; 1
     b0a:	0e 94 f7 14 	call	0x29ee	; 0x29ee <PM_GetStoredDataSize>
     b0e:	61 15       	cp	r22, r1
     b10:	71 05       	cpc	r23, r1
     b12:	81 05       	cpc	r24, r1
     b14:	91 05       	cpc	r25, r1
     b16:	31 f4       	brne	.+12     	; 0xb24 <FUNCProgramAVR+0x146>
     b18:	89 e0       	ldi	r24, 0x09	; 9
     b1a:	93 e0       	ldi	r25, 0x03	; 3
     b1c:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
     b20:	03 e0       	ldi	r16, 0x03	; 3
     b22:	03 c0       	rjmp	.+6      	; 0xb2a <FUNCProgramAVR+0x14c>
     b24:	81 e0       	ldi	r24, 0x01	; 1
     b26:	0e 94 c5 15 	call	0x2b8a	; 0x2b8a <PM_CreateProgrammingPackets>
     b2a:	11 23       	and	r17, r17
     b2c:	21 f0       	breq	.+8      	; 0xb36 <FUNCProgramAVR+0x158>
     b2e:	12 30       	cpi	r17, 0x02	; 2
     b30:	11 f0       	breq	.+4      	; 0xb36 <FUNCProgramAVR+0x158>
     b32:	13 30       	cpi	r17, 0x03	; 3
     b34:	b1 f4       	brne	.+44     	; 0xb62 <FUNCProgramAVR+0x184>
     b36:	85 e4       	ldi	r24, 0x45	; 69
     b38:	0e 94 36 04 	call	0x86c	; 0x86c <MAIN_ShowProgType>
     b3c:	80 e0       	ldi	r24, 0x00	; 0
     b3e:	0e 94 f7 14 	call	0x29ee	; 0x29ee <PM_GetStoredDataSize>
     b42:	61 15       	cp	r22, r1
     b44:	71 05       	cpc	r23, r1
     b46:	81 05       	cpc	r24, r1
     b48:	91 05       	cpc	r25, r1
     b4a:	31 f4       	brne	.+12     	; 0xb58 <FUNCProgramAVR+0x17a>
     b4c:	8f ef       	ldi	r24, 0xFF	; 255
     b4e:	92 e0       	ldi	r25, 0x02	; 2
     b50:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
     b54:	03 e0       	ldi	r16, 0x03	; 3
     b56:	03 c0       	rjmp	.+6      	; 0xb5e <FUNCProgramAVR+0x180>
     b58:	80 e0       	ldi	r24, 0x00	; 0
     b5a:	0e 94 c5 15 	call	0x2b8a	; 0x2b8a <PM_CreateProgrammingPackets>
     b5e:	11 23       	and	r17, r17
     b60:	21 f0       	breq	.+8      	; 0xb6a <FUNCProgramAVR+0x18c>
     b62:	14 30       	cpi	r17, 0x04	; 4
     b64:	11 f0       	breq	.+4      	; 0xb6a <FUNCProgramAVR+0x18c>
     b66:	16 30       	cpi	r17, 0x06	; 6
     b68:	a9 f4       	brne	.+42     	; 0xb94 <FUNCProgramAVR+0x1b6>
     b6a:	86 e4       	ldi	r24, 0x46	; 70
     b6c:	0e 94 36 04 	call	0x86c	; 0x86c <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     b70:	a0 e3       	ldi	r26, 0x30	; 48
     b72:	b0 e0       	ldi	r27, 0x00	; 0
     b74:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
     b78:	80 2d       	mov	r24, r0
     b7a:	88 23       	and	r24, r24
     b7c:	31 f4       	brne	.+12     	; 0xb8a <FUNCProgramAVR+0x1ac>
     b7e:	81 ef       	ldi	r24, 0xF1	; 241
     b80:	92 e0       	ldi	r25, 0x02	; 2
     b82:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
     b86:	03 e0       	ldi	r16, 0x03	; 3
     b88:	03 c0       	rjmp	.+6      	; 0xb90 <FUNCProgramAVR+0x1b2>
     b8a:	82 e0       	ldi	r24, 0x02	; 2
     b8c:	0e 94 5b 15 	call	0x2ab6	; 0x2ab6 <PM_SendFuseLockBytes>
     b90:	11 23       	and	r17, r17
     b92:	79 f0       	breq	.+30     	; 0xbb2 <FUNCProgramAVR+0x1d4>
     b94:	15 30       	cpi	r17, 0x05	; 5
     b96:	69 f0       	breq	.+26     	; 0xbb2 <FUNCProgramAVR+0x1d4>
     b98:	16 30       	cpi	r17, 0x06	; 6
     b9a:	19 f5       	brne	.+70     	; 0xbe2 <FUNCProgramAVR+0x204>
     b9c:	81 e0       	ldi	r24, 0x01	; 1
     b9e:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     ba2:	81 e0       	ldi	r24, 0x01	; 1
     ba4:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     ba8:	80 e0       	ldi	r24, 0x00	; 0
     baa:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     bae:	0e 94 9a 12 	call	0x2534	; 0x2534 <ISPCC_EnterChipProgrammingMode>
     bb2:	8c e4       	ldi	r24, 0x4C	; 76
     bb4:	0e 94 36 04 	call	0x86c	; 0x86c <MAIN_ShowProgType>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     bb8:	a1 e3       	ldi	r26, 0x31	; 49
     bba:	b0 e0       	ldi	r27, 0x00	; 0
     bbc:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
     bc0:	80 2d       	mov	r24, r0
     bc2:	88 23       	and	r24, r24
     bc4:	59 f4       	brne	.+22     	; 0xbdc <FUNCProgramAVR+0x1fe>
     bc6:	83 ee       	ldi	r24, 0xE3	; 227
     bc8:	92 e0       	ldi	r25, 0x02	; 2
     bca:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
     bce:	62 ed       	ldi	r22, 0xD2	; 210
     bd0:	72 e0       	ldi	r23, 0x02	; 2
     bd2:	ce 01       	movw	r24, r28
     bd4:	01 96       	adiw	r24, 0x01	; 1
     bd6:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <strcpy_P>
     bda:	0b c0       	rjmp	.+22     	; 0xbf2 <FUNCProgramAVR+0x214>
     bdc:	83 e0       	ldi	r24, 0x03	; 3
     bde:	0e 94 5b 15 	call	0x2ab6	; 0x2ab6 <PM_SendFuseLockBytes>
     be2:	62 ed       	ldi	r22, 0xD2	; 210
     be4:	72 e0       	ldi	r23, 0x02	; 2
     be6:	ce 01       	movw	r24, r28
     be8:	01 96       	adiw	r24, 0x01	; 1
     bea:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <strcpy_P>
     bee:	00 23       	and	r16, r16
     bf0:	31 f0       	breq	.+12     	; 0xbfe <FUNCProgramAVR+0x220>
     bf2:	6b ec       	ldi	r22, 0xCB	; 203
     bf4:	72 e0       	ldi	r23, 0x02	; 2
     bf6:	ce 01       	movw	r24, r28
     bf8:	0d 96       	adiw	r24, 0x0d	; 13
     bfa:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <strcpy_P>
     bfe:	ce 01       	movw	r24, r28
     c00:	01 96       	adiw	r24, 0x01	; 1
     c02:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
     c06:	8a ef       	ldi	r24, 0xFA	; 250
     c08:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     c0c:	88 ec       	ldi	r24, 0xC8	; 200
     c0e:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     c12:	04 c0       	rjmp	.+8      	; 0xc1c <FUNCProgramAVR+0x23e>
     c14:	8b e2       	ldi	r24, 0x2B	; 43
     c16:	94 e0       	ldi	r25, 0x04	; 4
     c18:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
     c1c:	0e 94 42 0c 	call	0x1884	; 0x1884 <TOUT_SetupSleepTimer>
     c20:	80 e8       	ldi	r24, 0x80	; 128
     c22:	80 93 61 00 	sts	0x0061, r24
     c26:	83 e0       	ldi	r24, 0x03	; 3
     c28:	80 93 61 00 	sts	0x0061, r24
     c2c:	81 e0       	ldi	r24, 0x01	; 1
     c2e:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     c32:	0e 94 e6 09 	call	0x13cc	; 0x13cc <USI_SPIOff>
     c36:	80 e0       	ldi	r24, 0x00	; 0
     c38:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
     c3c:	80 91 64 00 	lds	r24, 0x0064
     c40:	84 60       	ori	r24, 0x04	; 4
     c42:	80 93 64 00 	sts	0x0064, r24
     c46:	81 b3       	in	r24, 0x11	; 17
     c48:	8f 7c       	andi	r24, 0xCF	; 207
     c4a:	80 61       	ori	r24, 0x10	; 16
     c4c:	81 bb       	out	0x11, r24	; 17
     c4e:	63 96       	adiw	r28, 0x13	; 19
     c50:	0f b6       	in	r0, 0x3f	; 63
     c52:	f8 94       	cli
     c54:	de bf       	out	0x3e, r29	; 62
     c56:	0f be       	out	0x3f, r0	; 63
     c58:	cd bf       	out	0x3d, r28	; 61
     c5a:	df 91       	pop	r29
     c5c:	cf 91       	pop	r28
     c5e:	1f 91       	pop	r17
     c60:	0f 91       	pop	r16
     c62:	08 95       	ret

00000c64 <main>:
     c64:	1f 93       	push	r17
     c66:	80 e8       	ldi	r24, 0x80	; 128
     c68:	85 bf       	out	0x35, r24	; 53
     c6a:	85 bf       	out	0x35, r24	; 53
     c6c:	80 bf       	out	0x30, r24	; 48
     c6e:	85 e0       	ldi	r24, 0x05	; 5
     c70:	80 93 64 00 	sts	0x0064, r24
     c74:	80 e3       	ldi	r24, 0x30	; 48
     c76:	80 bb       	out	0x10, r24	; 16
     c78:	87 e2       	ldi	r24, 0x27	; 39
     c7a:	84 b9       	out	0x04, r24	; 4
     c7c:	8f ed       	ldi	r24, 0xDF	; 223
     c7e:	85 b9       	out	0x05, r24	; 5
     c80:	8c e0       	ldi	r24, 0x0C	; 12
     c82:	8e b9       	out	0x0e, r24	; 14
     c84:	80 93 6b 00 	sts	0x006B, r24
     c88:	80 ed       	ldi	r24, 0xD0	; 208
     c8a:	80 93 6c 00 	sts	0x006C, r24
     c8e:	80 ec       	ldi	r24, 0xC0	; 192
     c90:	8d bb       	out	0x1d, r24	; 29
     c92:	8c bb       	out	0x1c, r24	; 28
     c94:	81 b3       	in	r24, 0x11	; 17
     c96:	8f 7c       	andi	r24, 0xCF	; 207
     c98:	80 63       	ori	r24, 0x30	; 48
     c9a:	81 bb       	out	0x11, r24	; 17
     c9c:	81 e0       	ldi	r24, 0x01	; 1
     c9e:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
     ca2:	0e 94 67 08 	call	0x10ce	; 0x10ce <LCD_Init>
     ca6:	8f e0       	ldi	r24, 0x0F	; 15
     ca8:	80 93 e7 00 	sts	0x00E7, r24
     cac:	87 ea       	ldi	r24, 0xA7	; 167
     cae:	90 e0       	ldi	r25, 0x00	; 0
     cb0:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     cb4:	78 94       	sei
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     cb6:	aa e8       	ldi	r26, 0x8A	; 138
     cb8:	b0 e0       	ldi	r27, 0x00	; 0
     cba:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
     cbe:	80 2d       	mov	r24, r0
     cc0:	8a 37       	cpi	r24, 0x7A	; 122
     cc2:	89 f0       	breq	.+34     	; 0xce6 <main+0x82>
     cc4:	80 e0       	ldi	r24, 0x00	; 0
     cc6:	90 e0       	ldi	r25, 0x00	; 0
     cc8:	2f ef       	ldi	r18, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     cca:	dc 01       	movw	r26, r24
     ccc:	02 2e       	mov	r0, r18
     cce:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
     cd2:	01 96       	adiw	r24, 0x01	; 1
     cd4:	8b 38       	cpi	r24, 0x8B	; 139
     cd6:	91 05       	cpc	r25, r1
     cd8:	c1 f7       	brne	.-16     	; 0xcca <main+0x66>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     cda:	8a e7       	ldi	r24, 0x7A	; 122
     cdc:	aa e8       	ldi	r26, 0x8A	; 138
     cde:	b0 e0       	ldi	r27, 0x00	; 0
     ce0:	08 2e       	mov	r0, r24
     ce2:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
     ce6:	a6 e8       	ldi	r26, 0x86	; 134
     ce8:	b0 e0       	ldi	r27, 0x00	; 0
     cea:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
     cee:	80 2d       	mov	r24, r0
     cf0:	8f 70       	andi	r24, 0x0F	; 15
     cf2:	80 93 e7 00 	sts	0x00E7, r24
     cf6:	80 e0       	ldi	r24, 0x00	; 0
     cf8:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
     cfc:	0e 94 96 09 	call	0x132c	; 0x132c <USART_Init>
     d00:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <OSCCAL_Calibrate>
     d04:	0e 94 42 0c 	call	0x1884	; 0x1884 <TOUT_SetupSleepTimer>
     d08:	81 b3       	in	r24, 0x11	; 17
     d0a:	8f 7c       	andi	r24, 0xCF	; 207
     d0c:	80 61       	ori	r24, 0x10	; 16
     d0e:	81 bb       	out	0x11, r24	; 17
     d10:	81 e0       	ldi	r24, 0x01	; 1
     d12:	8e bb       	out	0x1e, r24	; 30
     d14:	80 e8       	ldi	r24, 0x80	; 128
     d16:	80 93 61 00 	sts	0x0061, r24
     d1a:	83 e0       	ldi	r24, 0x03	; 3
     d1c:	80 93 61 00 	sts	0x0061, r24
     d20:	10 e0       	ldi	r17, 0x00	; 0
     d22:	8e b3       	in	r24, 0x1e	; 30
     d24:	88 23       	and	r24, r24
     d26:	e9 f3       	breq	.-6      	; 0xd22 <main+0xbe>
     d28:	f6 9b       	sbis	0x1e, 6	; 30
     d2a:	06 c0       	rjmp	.+12     	; 0xd38 <main+0xd4>
     d2c:	11 23       	and	r17, r17
     d2e:	11 f4       	brne	.+4      	; 0xd34 <main+0xd0>
     d30:	16 e0       	ldi	r17, 0x06	; 6
     d32:	1b c0       	rjmp	.+54     	; 0xd6a <main+0x106>
     d34:	11 50       	subi	r17, 0x01	; 1
     d36:	19 c0       	rjmp	.+50     	; 0xd6a <main+0x106>
     d38:	f7 9b       	sbis	0x1e, 7	; 30
     d3a:	06 c0       	rjmp	.+12     	; 0xd48 <main+0xe4>
     d3c:	16 30       	cpi	r17, 0x06	; 6
     d3e:	11 f4       	brne	.+4      	; 0xd44 <main+0xe0>
     d40:	10 e0       	ldi	r17, 0x00	; 0
     d42:	13 c0       	rjmp	.+38     	; 0xd6a <main+0x106>
     d44:	1f 5f       	subi	r17, 0xFF	; 255
     d46:	11 c0       	rjmp	.+34     	; 0xd6a <main+0x106>
     d48:	f4 9b       	sbis	0x1e, 4	; 30
     d4a:	0b c0       	rjmp	.+22     	; 0xd62 <main+0xfe>
     d4c:	e1 2f       	mov	r30, r17
     d4e:	ff 27       	eor	r31, r31
     d50:	ee 0f       	add	r30, r30
     d52:	ff 1f       	adc	r31, r31
     d54:	ef 5e       	subi	r30, 0xEF	; 239
     d56:	fe 4f       	sbci	r31, 0xFE	; 254
     d58:	85 91       	lpm	r24, Z+
     d5a:	94 91       	lpm	r25, Z
     d5c:	fc 01       	movw	r30, r24
     d5e:	09 95       	icall
     d60:	04 c0       	rjmp	.+8      	; 0xd6a <main+0x106>
     d62:	f3 9b       	sbis	0x1e, 3	; 30
     d64:	02 c0       	rjmp	.+4      	; 0xd6a <main+0x106>
     d66:	0e 94 ff 02 	call	0x5fe	; 0x5fe <FUNCShowAbout>
     d6a:	e1 2f       	mov	r30, r17
     d6c:	ff 27       	eor	r31, r31
     d6e:	ee 0f       	add	r30, r30
     d70:	ff 1f       	adc	r31, r31
     d72:	ed 5f       	subi	r30, 0xFD	; 253
     d74:	fe 4f       	sbci	r31, 0xFE	; 254
     d76:	85 91       	lpm	r24, Z+
     d78:	94 91       	lpm	r25, Z
     d7a:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     d7e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     d82:	cf cf       	rjmp	.-98     	; 0xd22 <main+0xbe>

00000d84 <FUNCClearMem>:
     d84:	84 eb       	ldi	r24, 0xB4	; 180
     d86:	92 e0       	ldi	r25, 0x02	; 2
     d88:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     d8c:	84 eb       	ldi	r24, 0xB4	; 180
     d8e:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     d92:	8e ea       	ldi	r24, 0xAE	; 174
     d94:	92 e0       	ldi	r25, 0x02	; 2
     d96:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     d9a:	8e b3       	in	r24, 0x1e	; 30
     d9c:	88 23       	and	r24, r24
     d9e:	e9 f3       	breq	.-6      	; 0xd9a <FUNCClearMem+0x16>
     da0:	f2 99       	sbic	0x1e, 2	; 30
     da2:	22 c0       	rjmp	.+68     	; 0xde8 <FUNCClearMem+0x64>
     da4:	f3 9b       	sbis	0x1e, 3	; 30
     da6:	f9 cf       	rjmp	.-14     	; 0xd9a <FUNCClearMem+0x16>
     da8:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     dac:	87 ea       	ldi	r24, 0xA7	; 167
     dae:	90 e0       	ldi	r25, 0x00	; 0
     db0:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     db4:	81 b3       	in	r24, 0x11	; 17
     db6:	8f 7c       	andi	r24, 0xCF	; 207
     db8:	80 63       	ori	r24, 0x30	; 48
     dba:	81 bb       	out	0x11, r24	; 17
     dbc:	80 e0       	ldi	r24, 0x00	; 0
     dbe:	90 e0       	ldi	r25, 0x00	; 0
     dc0:	2f ef       	ldi	r18, 0xFF	; 255

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     dc2:	dc 01       	movw	r26, r24
     dc4:	02 2e       	mov	r0, r18
     dc6:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
     dca:	01 96       	adiw	r24, 0x01	; 1
     dcc:	8b 38       	cpi	r24, 0x8B	; 139
     dce:	91 05       	cpc	r25, r1
     dd0:	c1 f7       	brne	.-16     	; 0xdc2 <FUNCClearMem+0x3e>
     dd2:	81 b3       	in	r24, 0x11	; 17
     dd4:	8f 7c       	andi	r24, 0xCF	; 207
     dd6:	80 61       	ori	r24, 0x10	; 16
     dd8:	81 bb       	out	0x11, r24	; 17
     dda:	82 ea       	ldi	r24, 0xA2	; 162
     ddc:	92 e0       	ldi	r25, 0x02	; 2
     dde:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     de2:	8a ef       	ldi	r24, 0xFA	; 250
     de4:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
     de8:	08 95       	ret

00000dea <FUNCSetContrast>:
     dea:	1f 93       	push	r17
     dec:	cf 93       	push	r28
     dee:	df 93       	push	r29
     df0:	cd b7       	in	r28, 0x3d	; 61
     df2:	de b7       	in	r29, 0x3e	; 62
     df4:	26 97       	sbiw	r28, 0x06	; 6
     df6:	0f b6       	in	r0, 0x3f	; 63
     df8:	f8 94       	cli
     dfa:	de bf       	out	0x3e, r29	; 62
     dfc:	0f be       	out	0x3f, r0	; 63
     dfe:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     e00:	a6 e8       	ldi	r26, 0x86	; 134
     e02:	b0 e0       	ldi	r27, 0x00	; 0
     e04:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
     e08:	80 2d       	mov	r24, r0
     e0a:	18 2f       	mov	r17, r24
     e0c:	1f 70       	andi	r17, 0x0F	; 15
     e0e:	81 e0       	ldi	r24, 0x01	; 1
     e10:	8e bb       	out	0x1e, r24	; 30
     e12:	8e b3       	in	r24, 0x1e	; 30
     e14:	88 23       	and	r24, r24
     e16:	e9 f3       	breq	.-6      	; 0xe12 <FUNCSetContrast+0x28>
     e18:	f6 9b       	sbis	0x1e, 6	; 30
     e1a:	04 c0       	rjmp	.+8      	; 0xe24 <FUNCSetContrast+0x3a>
     e1c:	1f 30       	cpi	r17, 0x0F	; 15
     e1e:	50 f4       	brcc	.+20     	; 0xe34 <FUNCSetContrast+0x4a>
     e20:	1f 5f       	subi	r17, 0xFF	; 255
     e22:	08 c0       	rjmp	.+16     	; 0xe34 <FUNCSetContrast+0x4a>
     e24:	f7 9b       	sbis	0x1e, 7	; 30
     e26:	04 c0       	rjmp	.+8      	; 0xe30 <FUNCSetContrast+0x46>
     e28:	12 30       	cpi	r17, 0x02	; 2
     e2a:	20 f0       	brcs	.+8      	; 0xe34 <FUNCSetContrast+0x4a>
     e2c:	11 50       	subi	r17, 0x01	; 1
     e2e:	02 c0       	rjmp	.+4      	; 0xe34 <FUNCSetContrast+0x4a>
     e30:	f2 99       	sbic	0x1e, 2	; 30
     e32:	18 c0       	rjmp	.+48     	; 0xe64 <FUNCSetContrast+0x7a>
     e34:	83 e4       	ldi	r24, 0x43	; 67
     e36:	89 83       	std	Y+1, r24	; 0x01
     e38:	84 e5       	ldi	r24, 0x54	; 84
     e3a:	8a 83       	std	Y+2, r24	; 0x02
     e3c:	80 e2       	ldi	r24, 0x20	; 32
     e3e:	8b 83       	std	Y+3, r24	; 0x03
     e40:	be 01       	movw	r22, r28
     e42:	6c 5f       	subi	r22, 0xFC	; 252
     e44:	7f 4f       	sbci	r23, 0xFF	; 255
     e46:	81 2f       	mov	r24, r17
     e48:	99 27       	eor	r25, r25
     e4a:	0e 94 97 02 	call	0x52e	; 0x52e <MAIN_IntToStr>
     e4e:	ce 01       	movw	r24, r28
     e50:	01 96       	adiw	r24, 0x01	; 1
     e52:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
     e56:	81 2f       	mov	r24, r17
     e58:	8f 70       	andi	r24, 0x0F	; 15
     e5a:	80 93 e7 00 	sts	0x00E7, r24
     e5e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     e62:	d7 cf       	rjmp	.-82     	; 0xe12 <FUNCSetContrast+0x28>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     e64:	a6 e8       	ldi	r26, 0x86	; 134
     e66:	b0 e0       	ldi	r27, 0x00	; 0
     e68:	01 2e       	mov	r0, r17
     e6a:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
     e6e:	26 96       	adiw	r28, 0x06	; 6
     e70:	0f b6       	in	r0, 0x3f	; 63
     e72:	f8 94       	cli
     e74:	de bf       	out	0x3e, r29	; 62
     e76:	0f be       	out	0x3f, r0	; 63
     e78:	cd bf       	out	0x3d, r28	; 61
     e7a:	df 91       	pop	r29
     e7c:	cf 91       	pop	r28
     e7e:	1f 91       	pop	r17
     e80:	08 95       	ret

00000e82 <FUNCSetISPSpeed>:
     e82:	1f 93       	push	r17
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     e84:	a2 e0       	ldi	r26, 0x02	; 2
     e86:	b0 e0       	ldi	r27, 0x00	; 0
     e88:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
     e8c:	80 2d       	mov	r24, r0
     e8e:	18 2f       	mov	r17, r24
     e90:	84 30       	cpi	r24, 0x04	; 4
     e92:	08 f0       	brcs	.+2      	; 0xe96 <FUNCSetISPSpeed+0x14>
     e94:	13 e0       	ldi	r17, 0x03	; 3
     e96:	81 e0       	ldi	r24, 0x01	; 1
     e98:	8e bb       	out	0x1e, r24	; 30
     e9a:	8e b3       	in	r24, 0x1e	; 30
     e9c:	88 23       	and	r24, r24
     e9e:	e9 f3       	breq	.-6      	; 0xe9a <FUNCSetISPSpeed+0x18>
     ea0:	f6 9b       	sbis	0x1e, 6	; 30
     ea2:	06 c0       	rjmp	.+12     	; 0xeb0 <FUNCSetISPSpeed+0x2e>
     ea4:	11 23       	and	r17, r17
     ea6:	11 f4       	brne	.+4      	; 0xeac <FUNCSetISPSpeed+0x2a>
     ea8:	13 e0       	ldi	r17, 0x03	; 3
     eaa:	0c c0       	rjmp	.+24     	; 0xec4 <FUNCSetISPSpeed+0x42>
     eac:	11 50       	subi	r17, 0x01	; 1
     eae:	0a c0       	rjmp	.+20     	; 0xec4 <FUNCSetISPSpeed+0x42>
     eb0:	f7 9b       	sbis	0x1e, 7	; 30
     eb2:	04 c0       	rjmp	.+8      	; 0xebc <FUNCSetISPSpeed+0x3a>
     eb4:	13 30       	cpi	r17, 0x03	; 3
     eb6:	29 f0       	breq	.+10     	; 0xec2 <FUNCSetISPSpeed+0x40>
     eb8:	1f 5f       	subi	r17, 0xFF	; 255
     eba:	04 c0       	rjmp	.+8      	; 0xec4 <FUNCSetISPSpeed+0x42>
     ebc:	f2 9b       	sbis	0x1e, 2	; 30
     ebe:	02 c0       	rjmp	.+4      	; 0xec4 <FUNCSetISPSpeed+0x42>
     ec0:	0c c0       	rjmp	.+24     	; 0xeda <FUNCSetISPSpeed+0x58>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     ec2:	10 e0       	ldi	r17, 0x00	; 0
     ec4:	8a e0       	ldi	r24, 0x0A	; 10
     ec6:	18 9f       	mul	r17, r24
     ec8:	c0 01       	movw	r24, r0
     eca:	11 24       	eor	r1, r1
     ecc:	8a 5d       	subi	r24, 0xDA	; 218
     ece:	9d 4f       	sbci	r25, 0xFD	; 253
     ed0:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     ed4:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     ed8:	e0 cf       	rjmp	.-64     	; 0xe9a <FUNCSetISPSpeed+0x18>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     eda:	a2 e0       	ldi	r26, 0x02	; 2
     edc:	b0 e0       	ldi	r27, 0x00	; 0
     ede:	01 2e       	mov	r0, r17
     ee0:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
     ee4:	1f 91       	pop	r17
     ee6:	08 95       	ret

00000ee8 <FUNCSetResetMode>:
     ee8:	1f 93       	push	r17
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     eea:	a9 e8       	ldi	r26, 0x89	; 137
     eec:	b0 e0       	ldi	r27, 0x00	; 0
     eee:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
     ef2:	80 2d       	mov	r24, r0
     ef4:	18 2f       	mov	r17, r24
     ef6:	11 70       	andi	r17, 0x01	; 1
     ef8:	81 e0       	ldi	r24, 0x01	; 1
     efa:	8e bb       	out	0x1e, r24	; 30
     efc:	8e b3       	in	r24, 0x1e	; 30
     efe:	88 23       	and	r24, r24
     f00:	e9 f3       	breq	.-6      	; 0xefc <FUNCSetResetMode+0x14>
     f02:	f6 99       	sbic	0x1e, 6	; 30
     f04:	02 c0       	rjmp	.+4      	; 0xf0a <FUNCSetResetMode+0x22>
     f06:	f7 9b       	sbis	0x1e, 7	; 30
     f08:	03 c0       	rjmp	.+6      	; 0xf10 <FUNCSetResetMode+0x28>
     f0a:	81 e0       	ldi	r24, 0x01	; 1
     f0c:	18 27       	eor	r17, r24
     f0e:	02 c0       	rjmp	.+4      	; 0xf14 <FUNCSetResetMode+0x2c>
     f10:	f2 99       	sbic	0x1e, 2	; 30
     f12:	0b c0       	rjmp	.+22     	; 0xf2a <FUNCSetResetMode+0x42>
     f14:	86 e0       	ldi	r24, 0x06	; 6
     f16:	18 9f       	mul	r17, r24
     f18:	c0 01       	movw	r24, r0
     f1a:	11 24       	eor	r1, r1
     f1c:	82 5b       	subi	r24, 0xB2	; 178
     f1e:	9d 4f       	sbci	r25, 0xFD	; 253
     f20:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
     f24:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     f28:	e9 cf       	rjmp	.-46     	; 0xefc <FUNCSetResetMode+0x14>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     f2a:	a9 e8       	ldi	r26, 0x89	; 137
     f2c:	b0 e0       	ldi	r27, 0x00	; 0
     f2e:	01 2e       	mov	r0, r17
     f30:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
     f34:	1f 91       	pop	r17
     f36:	08 95       	ret

00000f38 <FUNCSetFirmMinorVer>:
     f38:	1f 93       	push	r17
     f3a:	cf 93       	push	r28
     f3c:	df 93       	push	r29
     f3e:	cd b7       	in	r28, 0x3d	; 61
     f40:	de b7       	in	r29, 0x3e	; 62
     f42:	25 97       	sbiw	r28, 0x05	; 5
     f44:	0f b6       	in	r0, 0x3f	; 63
     f46:	f8 94       	cli
     f48:	de bf       	out	0x3e, r29	; 62
     f4a:	0f be       	out	0x3f, r0	; 63
     f4c:	cd bf       	out	0x3d, r28	; 61
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
     f4e:	a7 e8       	ldi	r26, 0x87	; 135
     f50:	b0 e0       	ldi	r27, 0x00	; 0
     f52:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
     f56:	80 2d       	mov	r24, r0
     f58:	18 2f       	mov	r17, r24
     f5a:	8a 30       	cpi	r24, 0x0A	; 10
     f5c:	08 f0       	brcs	.+2      	; 0xf60 <FUNCSetFirmMinorVer+0x28>
     f5e:	14 e0       	ldi	r17, 0x04	; 4
     f60:	6d e9       	ldi	r22, 0x9D	; 157
     f62:	72 e0       	ldi	r23, 0x02	; 2
     f64:	ce 01       	movw	r24, r28
     f66:	01 96       	adiw	r24, 0x01	; 1
     f68:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <strcpy_P>
     f6c:	81 e0       	ldi	r24, 0x01	; 1
     f6e:	8e bb       	out	0x1e, r24	; 30
     f70:	8e b3       	in	r24, 0x1e	; 30
     f72:	88 23       	and	r24, r24
     f74:	e9 f3       	breq	.-6      	; 0xf70 <FUNCSetFirmMinorVer+0x38>
     f76:	f6 9b       	sbis	0x1e, 6	; 30
     f78:	03 c0       	rjmp	.+6      	; 0xf80 <FUNCSetFirmMinorVer+0x48>
     f7a:	19 30       	cpi	r17, 0x09	; 9
     f7c:	08 f4       	brcc	.+2      	; 0xf80 <FUNCSetFirmMinorVer+0x48>
     f7e:	1f 5f       	subi	r17, 0xFF	; 255
     f80:	f7 9b       	sbis	0x1e, 7	; 30
     f82:	04 c0       	rjmp	.+8      	; 0xf8c <FUNCSetFirmMinorVer+0x54>
     f84:	11 23       	and	r17, r17
     f86:	21 f0       	breq	.+8      	; 0xf90 <FUNCSetFirmMinorVer+0x58>
     f88:	11 50       	subi	r17, 0x01	; 1
     f8a:	02 c0       	rjmp	.+4      	; 0xf90 <FUNCSetFirmMinorVer+0x58>
     f8c:	f2 99       	sbic	0x1e, 2	; 30
     f8e:	0a c0       	rjmp	.+20     	; 0xfa4 <FUNCSetFirmMinorVer+0x6c>
     f90:	10 5d       	subi	r17, 0xD0	; 208
     f92:	1c 83       	std	Y+4, r17	; 0x04
     f94:	10 53       	subi	r17, 0x30	; 48
     f96:	ce 01       	movw	r24, r28
     f98:	01 96       	adiw	r24, 0x01	; 1
     f9a:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
     f9e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
     fa2:	e6 cf       	rjmp	.-52     	; 0xf70 <FUNCSetFirmMinorVer+0x38>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
     fa4:	a7 e8       	ldi	r26, 0x87	; 135
     fa6:	b0 e0       	ldi	r27, 0x00	; 0
     fa8:	01 2e       	mov	r0, r17
     faa:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
     fae:	25 96       	adiw	r28, 0x05	; 5
     fb0:	0f b6       	in	r0, 0x3f	; 63
     fb2:	f8 94       	cli
     fb4:	de bf       	out	0x3e, r29	; 62
     fb6:	0f be       	out	0x3f, r0	; 63
     fb8:	cd bf       	out	0x3d, r28	; 61
     fba:	df 91       	pop	r29
     fbc:	cf 91       	pop	r28
     fbe:	1f 91       	pop	r17
     fc0:	08 95       	ret

00000fc2 <OSCCAL_Calibrate>:

volatile uint16_t ActualCount = 0;

void OSCCAL_Calibrate(void)
{
     fc2:	10 92 05 01 	sts	0x0105, r1
     fc6:	10 92 04 01 	sts	0x0104, r1
	uint8_t SREG_Backup;
	uint8_t LoopCount = (0x7F / 2); // Maximum range is 128, and starts from the middle, so 64 is the max number of iterations required
	uint8_t PrevOSCALValues[2];
   
	// Reset ActualCount
	ActualCount = 0;
   
	// Make sure all clock division is turned off (8Mhz RC clock)
	OSCCAL_SETSYSCLOCKSPEED(OSCCAL_BASECLOCKSPEED_8MHZ);
     fca:	80 e8       	ldi	r24, 0x80	; 128
     fcc:	80 93 61 00 	sts	0x0061, r24
     fd0:	10 92 61 00 	sts	0x0061, r1

	// Inital OSCCAL of half its maximum
	OSCCAL = (0x7F / 2);
     fd4:	8f e3       	ldi	r24, 0x3F	; 63
     fd6:	80 93 66 00 	sts	0x0066, r24

	// Save the SREG
	SREG_Backup = SREG;
     fda:	5f b7       	in	r21, 0x3f	; 63
    
	// Disable all timer 1 interrupts
	TIMSK1 = 0;
     fdc:	10 92 6f 00 	sts	0x006F, r1
        
	// Set timer 2 to asyncronous mode (32.768KHz crystal)
	ASSR   = (1 << AS2);
     fe0:	88 e0       	ldi	r24, 0x08	; 8
     fe2:	80 93 b6 00 	sts	0x00B6, r24
        
	// Timer 2 overflow interrupt enable
	TIMSK2 = (1 << TOIE2);
     fe6:	81 e0       	ldi	r24, 0x01	; 1
     fe8:	80 93 70 00 	sts	0x0070, r24

	// Enable interrupts
	sei();
     fec:	78 94       	sei

	// Start both counters with no prescaling
	TCCR1B = (1 << CS10);
     fee:	80 93 81 00 	sts	0x0081, r24
	TCCR2A = (1 << CS20);
     ff2:	80 93 b0 00 	sts	0x00B0, r24
	 	 
	// Previous OSCCAL value of 0
	PrevOSCALValues[0] = 0;

	// Wait until timer 2's external 32.768KHz crystal is stable
	while (ASSR & ((1 << TCN2UB) | (1 << TCR2UB) | (1 << OCR2UB)));
     ff6:	80 91 b6 00 	lds	r24, 0x00B6
     ffa:	99 27       	eor	r25, r25
     ffc:	87 70       	andi	r24, 0x07	; 7
     ffe:	90 70       	andi	r25, 0x00	; 0
    1000:	89 2b       	or	r24, r25
    1002:	c9 f7       	brne	.-14     	; 0xff6 <OSCCAL_Calibrate+0x34>
    
	// Clear the timer values
	TCNT1  = 0;
    1004:	10 92 85 00 	sts	0x0085, r1
    1008:	10 92 84 00 	sts	0x0084, r1
	TCNT2  = 0;
    100c:	10 92 b2 00 	sts	0x00B2, r1
    1010:	2e e3       	ldi	r18, 0x3E	; 62
    1012:	40 e0       	ldi	r20, 0x00	; 0
    1014:	ec ec       	ldi	r30, 0xCC	; 204
    1016:	f4 e6       	ldi	r31, 0x64	; 100
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1018:	cf 01       	movw	r24, r30
    101a:	01 97       	sbiw	r24, 0x01	; 1
    101c:	f1 f7       	brne	.-4      	; 0x101a <OSCCAL_Calibrate+0x58>
    
	while (LoopCount--)
	{
		// Let it take a few readings (14ms, approx 2 readings)
		_delay_ms(14);

		PrevOSCALValues[1] = PrevOSCALValues[0];
		PrevOSCALValues[0] = OSCCAL;
    101e:	30 91 66 00 	lds	r19, 0x0066
        
		if (ActualCount > OSCCAL_TARGETCOUNT)       // Clock is running too fast
    1022:	80 91 04 01 	lds	r24, 0x0104
    1026:	90 91 05 01 	lds	r25, 0x0105
    102a:	81 50       	subi	r24, 0x01	; 1
    102c:	91 4e       	sbci	r25, 0xE1	; 225
    102e:	20 f0       	brcs	.+8      	; 0x1038 <OSCCAL_Calibrate+0x76>
			OSCCAL--;
    1030:	80 91 66 00 	lds	r24, 0x0066
    1034:	81 50       	subi	r24, 0x01	; 1
    1036:	0a c0       	rjmp	.+20     	; 0x104c <OSCCAL_Calibrate+0x8a>
		else if (ActualCount < OSCCAL_TARGETCOUNT) // Clock is running too slow
    1038:	80 91 04 01 	lds	r24, 0x0104
    103c:	90 91 05 01 	lds	r25, 0x0105
    1040:	80 50       	subi	r24, 0x00	; 0
    1042:	91 4e       	sbci	r25, 0xE1	; 225
    1044:	28 f4       	brcc	.+10     	; 0x1050 <OSCCAL_Calibrate+0x8e>
			OSCCAL++;
    1046:	80 91 66 00 	lds	r24, 0x0066
    104a:	8f 5f       	subi	r24, 0xFF	; 255
    104c:	80 93 66 00 	sts	0x0066, r24
		
		// When the routine finds the closest value for the given target count,
		// it will cause the OSCCAL to hover around the closest two values.
		// If the current value is the same as two loops previous, exit the
		// routine as the best value has been found.
		if (OSCCAL == PrevOSCALValues[1])
    1050:	80 91 66 00 	lds	r24, 0x0066
    1054:	84 17       	cp	r24, r20
    1056:	29 f0       	breq	.+10     	; 0x1062 <OSCCAL_Calibrate+0xa0>
    1058:	21 50       	subi	r18, 0x01	; 1
    105a:	2f 3f       	cpi	r18, 0xFF	; 255
    105c:	11 f0       	breq	.+4      	; 0x1062 <OSCCAL_Calibrate+0xa0>
    105e:	43 2f       	mov	r20, r19
    1060:	db cf       	rjmp	.-74     	; 0x1018 <OSCCAL_Calibrate+0x56>
		  break;
	}

	// Disable all timer interrupts
	TIMSK1 = 0;
    1062:	10 92 6f 00 	sts	0x006F, r1
	TIMSK2 = 0;
    1066:	10 92 70 00 	sts	0x0070, r1
    
	// Stop the timers
	TCCR1B = 0x00;
    106a:	10 92 81 00 	sts	0x0081, r1
	TCCR2A = 0x00;
    106e:	10 92 b0 00 	sts	0x00B0, r1

	// Turn off timer 2 asynchronous mode
	ASSR  &= ~(1 << AS2);
    1072:	80 91 b6 00 	lds	r24, 0x00B6
    1076:	87 7f       	andi	r24, 0xF7	; 247
    1078:	80 93 b6 00 	sts	0x00B6, r24

	// Restore SREG
	SREG = SREG_Backup;
    107c:	5f bf       	out	0x3f, r21	; 63
    107e:	08 95       	ret

00001080 <__vector_5>:
        
	return;
}

ISR(TIMER2_OVF_vect, ISR_BLOCK) // Occurs 32768/256 timers per second, or 128Hz
{
    1080:	1f 92       	push	r1
    1082:	0f 92       	push	r0
    1084:	0f b6       	in	r0, 0x3f	; 63
    1086:	0f 92       	push	r0
    1088:	11 24       	eor	r1, r1
    108a:	8f 93       	push	r24
    108c:	9f 93       	push	r25
    108e:	af 93       	push	r26
    1090:	bf 93       	push	r27
    1092:	ef 93       	push	r30
    1094:	ff 93       	push	r31
	// Stop timer 1 so it can be read
	TCCR1B = 0x00;
    1096:	a1 e8       	ldi	r26, 0x81	; 129
    1098:	b0 e0       	ldi	r27, 0x00	; 0
    109a:	1c 92       	st	X, r1
    
	// Record timer 1's value
	ActualCount = TCNT1;
    109c:	e4 e8       	ldi	r30, 0x84	; 132
    109e:	f0 e0       	ldi	r31, 0x00	; 0
    10a0:	80 81       	ld	r24, Z
    10a2:	91 81       	ldd	r25, Z+1	; 0x01
    10a4:	90 93 05 01 	sts	0x0105, r25
    10a8:	80 93 04 01 	sts	0x0104, r24
	     
	// Reset counters and restart timer 1
	TCNT1  = 0;
    10ac:	11 82       	std	Z+1, r1	; 0x01
    10ae:	10 82       	st	Z, r1
	TCNT2  = 0;
    10b0:	10 92 b2 00 	sts	0x00B2, r1
	TCCR1B = (1 << CS10);
    10b4:	81 e0       	ldi	r24, 0x01	; 1
    10b6:	8c 93       	st	X, r24
    10b8:	ff 91       	pop	r31
    10ba:	ef 91       	pop	r30
    10bc:	bf 91       	pop	r27
    10be:	af 91       	pop	r26
    10c0:	9f 91       	pop	r25
    10c2:	8f 91       	pop	r24
    10c4:	0f 90       	pop	r0
    10c6:	0f be       	out	0x3f, r0	; 63
    10c8:	0f 90       	pop	r0
    10ca:	1f 90       	pop	r1
    10cc:	18 95       	reti

000010ce <LCD_Init>:

// ======================================================================================

void LCD_Init(void)
{
    10ce:	8f e0       	ldi	r24, 0x0F	; 15
    10d0:	80 93 e7 00 	sts	0x00E7, r24
	// Set the initial contrast level to maximum:
	LCDCCR = 0x0F;

    // Select asynchronous clock source, enable all COM pins and enable all segment pins:
    LCDCRB  = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
    10d4:	87 eb       	ldi	r24, 0xB7	; 183
    10d6:	80 93 e5 00 	sts	0x00E5, r24

    // Set LCD prescaler to give a framerate of 32Hz:
    LCDFRR  = (7<<LCDCD0);    
    10da:	87 e0       	ldi	r24, 0x07	; 7
    10dc:	80 93 e6 00 	sts	0x00E6, r24

	// Enable LCD and set low power waveform, enable start of frame interrupt:
    LCDCRA  = (1<<LCDEN) | (1<<LCDAB) | (1<<LCDIE);
    10e0:	88 ec       	ldi	r24, 0xC8	; 200
    10e2:	80 93 e4 00 	sts	0x00E4, r24
    10e6:	08 95       	ret

000010e8 <LCD_puts>:
}

void LCD_puts_f(const uint8_t *FlashData)
{
	uint8_t StrBuff[LCD_TEXTBUFFER_SIZE];

	strcpy_P(StrBuff, FlashData);
	LCD_puts(StrBuff);
}

void LCD_puts(const uint8_t *Data)
{
    10e8:	fc 01       	movw	r30, r24
    10ea:	ac e0       	ldi	r26, 0x0C	; 12
    10ec:	b1 e0       	ldi	r27, 0x01	; 1
    10ee:	38 2f       	mov	r19, r24
    10f0:	4f ef       	ldi	r20, 0xFF	; 255
    10f2:	2e 2f       	mov	r18, r30
    10f4:	23 1b       	sub	r18, r19
	uint8_t LoadB;
	
	for (LoadB = 0; LoadB < 20; LoadB++)
	{
		uint8_t CByte = *(Data++);
    10f6:	91 91       	ld	r25, Z+
	
		if ((CByte >= '*') && (CByte <= 'z') && (CByte != ' '))
    10f8:	89 2f       	mov	r24, r25
    10fa:	8a 52       	subi	r24, 0x2A	; 42
    10fc:	81 35       	cpi	r24, 0x51	; 81
    10fe:	10 f4       	brcc	.+4      	; 0x1104 <LCD_puts+0x1c>
		  TextBuffer[LoadB] = (CByte - '*');
    1100:	8c 93       	st	X, r24
    1102:	03 c0       	rjmp	.+6      	; 0x110a <LCD_puts+0x22>
		else if (CByte == 0x00)
    1104:	99 23       	and	r25, r25
    1106:	41 f0       	breq	.+16     	; 0x1118 <LCD_puts+0x30>
		  break;
		else
		  TextBuffer[LoadB] = 0xFF;		
    1108:	4c 93       	st	X, r20
    110a:	2e 2f       	mov	r18, r30
    110c:	23 1b       	sub	r18, r19
    110e:	11 96       	adiw	r26, 0x01	; 1
    1110:	81 e0       	ldi	r24, 0x01	; 1
    1112:	a0 32       	cpi	r26, 0x20	; 32
    1114:	b8 07       	cpc	r27, r24
    1116:	69 f7       	brne	.-38     	; 0x10f2 <LCD_puts+0xa>
	}

	ScrollMode  = ((LoadB > 6)? TRUE : FALSE);
    1118:	10 92 06 01 	sts	0x0106, r1
    111c:	27 30       	cpi	r18, 0x07	; 7
    111e:	18 f0       	brcs	.+6      	; 0x1126 <LCD_puts+0x3e>
    1120:	81 e0       	ldi	r24, 0x01	; 1
    1122:	80 93 06 01 	sts	0x0106, r24
	ScrollCount = 0;
    1126:	10 92 08 01 	sts	0x0108, r1
    112a:	82 2f       	mov	r24, r18
    112c:	90 e0       	ldi	r25, 0x00	; 0
    112e:	3f ef       	ldi	r19, 0xFF	; 255

	for (uint8_t Nulls = 0; Nulls < 7; Nulls++)
		TextBuffer[LoadB++] = 0xFF;
    1130:	e8 2f       	mov	r30, r24
    1132:	ff 27       	eor	r31, r31
    1134:	e4 5f       	subi	r30, 0xF4	; 244
    1136:	fe 4f       	sbci	r31, 0xFE	; 254
    1138:	30 83       	st	Z, r19
    113a:	8f 5f       	subi	r24, 0xFF	; 255
    113c:	9f 5f       	subi	r25, 0xFF	; 255
    113e:	97 30       	cpi	r25, 0x07	; 7
    1140:	b9 f7       	brne	.-18     	; 0x1130 <LCD_puts+0x48>
    1142:	82 2f       	mov	r24, r18
    1144:	89 5f       	subi	r24, 0xF9	; 249
	
	TextBuffer[LoadB] = 0x00;
    1146:	e8 2f       	mov	r30, r24
    1148:	ff 27       	eor	r31, r31
    114a:	e4 5f       	subi	r30, 0xF4	; 244
    114c:	fe 4f       	sbci	r31, 0xFE	; 254
    114e:	10 82       	st	Z, r1
	StrStart   = 0;
    1150:	10 92 0a 01 	sts	0x010A, r1
	StrEnd     = LoadB;	
    1154:	80 93 0b 01 	sts	0x010B, r24
	DelayCount = LCD_DELAYCOUNT_DEFAULT;
    1158:	8a e0       	ldi	r24, 0x0A	; 10
    115a:	80 93 07 01 	sts	0x0107, r24

	UpdateLCD  = TRUE;
    115e:	81 e0       	ldi	r24, 0x01	; 1
    1160:	80 93 09 01 	sts	0x0109, r24
    1164:	08 95       	ret

00001166 <LCD_WriteChar>:
}

void LCD_WriteChar(const uint8_t Byte, const uint8_t Digit)
{
    1166:	8f 3f       	cpi	r24, 0xFF	; 255
    1168:	19 f4       	brne	.+6      	; 0x1170 <LCD_WriteChar+0xa>
	uint16_t SegData  = 0x00;
	uint8_t  *BuffPtr = (&SegBuffer[0] + (Digit >> 1));

	if (Byte != 0xFF)
    116a:	40 e0       	ldi	r20, 0x00	; 0
    116c:	50 e0       	ldi	r21, 0x00	; 0
    116e:	08 c0       	rjmp	.+16     	; 0x1180 <LCD_WriteChar+0x1a>
	  SegData = pgm_read_word(&LCD_SegTable[Byte]);	
    1170:	e8 2f       	mov	r30, r24
    1172:	ff 27       	eor	r31, r31
    1174:	ee 0f       	add	r30, r30
    1176:	ff 1f       	adc	r31, r31
    1178:	e4 5d       	subi	r30, 0xD4	; 212
    117a:	fc 4f       	sbci	r31, 0xFC	; 252
    117c:	45 91       	lpm	r20, Z+
    117e:	54 91       	lpm	r21, Z
    1180:	86 2f       	mov	r24, r22
    1182:	86 95       	lsr	r24
    1184:	e8 2f       	mov	r30, r24
    1186:	ff 27       	eor	r31, r31
    1188:	e9 5d       	subi	r30, 0xD9	; 217
    118a:	fe 4f       	sbci	r31, 0xFE	; 254
    118c:	30 e0       	ldi	r19, 0x00	; 0
    118e:	77 27       	eor	r23, r23
    1190:	61 70       	andi	r22, 0x01	; 1
    1192:	70 70       	andi	r23, 0x00	; 0

	for (uint8_t BNib = 0; BNib < 4; BNib++)
	{
		uint8_t Mask          = 0xF0;
		uint8_t MaskedSegData = (SegData & 0x0000F);
    1194:	24 2f       	mov	r18, r20
    1196:	2f 70       	andi	r18, 0x0F	; 15
	
		if (Digit & 0x01)
    1198:	61 15       	cp	r22, r1
    119a:	71 05       	cpc	r23, r1
    119c:	11 f4       	brne	.+4      	; 0x11a2 <LCD_WriteChar+0x3c>
    119e:	90 ef       	ldi	r25, 0xF0	; 240
    11a0:	03 c0       	rjmp	.+6      	; 0x11a8 <LCD_WriteChar+0x42>
		{
			Mask = 0x0F;
			MaskedSegData <<= 4;
    11a2:	22 95       	swap	r18
    11a4:	20 7f       	andi	r18, 0xF0	; 240
    11a6:	9f e0       	ldi	r25, 0x0F	; 15
		}
		
		*BuffPtr = ((*BuffPtr & Mask) | MaskedSegData);
    11a8:	80 81       	ld	r24, Z
    11aa:	98 23       	and	r25, r24
    11ac:	92 2b       	or	r25, r18
    11ae:	90 83       	st	Z, r25
    11b0:	3f 5f       	subi	r19, 0xFF	; 255
    11b2:	34 30       	cpi	r19, 0x04	; 4
    11b4:	39 f0       	breq	.+14     	; 0x11c4 <LCD_WriteChar+0x5e>

		SegData >>= 4;
    11b6:	84 e0       	ldi	r24, 0x04	; 4
    11b8:	56 95       	lsr	r21
    11ba:	47 95       	ror	r20
    11bc:	8a 95       	dec	r24
    11be:	e1 f7       	brne	.-8      	; 0x11b8 <LCD_WriteChar+0x52>
		BuffPtr  += 5;
    11c0:	35 96       	adiw	r30, 0x05	; 5
    11c2:	e8 cf       	rjmp	.-48     	; 0x1194 <LCD_WriteChar+0x2e>
    11c4:	08 95       	ret

000011c6 <__vector_22>:
	}
}

ISR(LCD_vect, ISR_NOBLOCK)
{
    11c6:	78 94       	sei
    11c8:	1f 92       	push	r1
    11ca:	0f 92       	push	r0
    11cc:	0f b6       	in	r0, 0x3f	; 63
    11ce:	0f 92       	push	r0
    11d0:	11 24       	eor	r1, r1
    11d2:	cf 92       	push	r12
    11d4:	df 92       	push	r13
    11d6:	ff 92       	push	r15
    11d8:	0f 93       	push	r16
    11da:	1f 93       	push	r17
    11dc:	2f 93       	push	r18
    11de:	3f 93       	push	r19
    11e0:	4f 93       	push	r20
    11e2:	5f 93       	push	r21
    11e4:	6f 93       	push	r22
    11e6:	7f 93       	push	r23
    11e8:	8f 93       	push	r24
    11ea:	9f 93       	push	r25
    11ec:	af 93       	push	r26
    11ee:	bf 93       	push	r27
    11f0:	cf 93       	push	r28
    11f2:	df 93       	push	r29
    11f4:	ef 93       	push	r30
    11f6:	ff 93       	push	r31
	if (ScrollMode)
    11f8:	80 91 06 01 	lds	r24, 0x0106
    11fc:	88 23       	and	r24, r24
    11fe:	99 f0       	breq	.+38     	; 0x1226 <__vector_22+0x60>
	{
		if (DelayCount)
    1200:	80 91 07 01 	lds	r24, 0x0107
    1204:	88 23       	and	r24, r24
    1206:	21 f0       	breq	.+8      	; 0x1210 <__vector_22+0x4a>
		{
			DelayCount--;
    1208:	81 50       	subi	r24, 0x01	; 1
    120a:	80 93 07 01 	sts	0x0107, r24
    120e:	0b c0       	rjmp	.+22     	; 0x1226 <__vector_22+0x60>
		}
		else
		{
			if (!(ScrollCount--))
    1210:	80 91 08 01 	lds	r24, 0x0108
    1214:	81 50       	subi	r24, 0x01	; 1
    1216:	80 93 08 01 	sts	0x0108, r24
    121a:	8f 3f       	cpi	r24, 0xFF	; 255
    121c:	21 f4       	brne	.+8      	; 0x1226 <__vector_22+0x60>
			  UpdateLCD = TRUE;
    121e:	81 e0       	ldi	r24, 0x01	; 1
    1220:	80 93 09 01 	sts	0x0109, r24
    1224:	04 c0       	rjmp	.+8      	; 0x122e <__vector_22+0x68>
		}
	}

	if (UpdateLCD)
    1226:	80 91 09 01 	lds	r24, 0x0109
    122a:	88 23       	and	r24, r24
    122c:	41 f1       	breq	.+80     	; 0x127e <__vector_22+0xb8>
	{
		for (uint8_t Character = 0; Character < 6; Character++)
		{
			uint8_t Byte = (StrStart + Character);
    122e:	10 91 0a 01 	lds	r17, 0x010A

			if (Byte >= StrEnd)
    1232:	f0 90 0b 01 	lds	r15, 0x010B
			  Byte = TextBuffer[Byte - StrEnd];
    1236:	cf 2c       	mov	r12, r15
    1238:	dd 24       	eor	r13, r13
    123a:	01 2f       	mov	r16, r17
    123c:	c0 e0       	ldi	r28, 0x00	; 0
    123e:	d0 e0       	ldi	r29, 0x00	; 0
    1240:	6c 2f       	mov	r22, r28
    1242:	e0 2f       	mov	r30, r16
    1244:	ff 27       	eor	r31, r31
    1246:	0f 15       	cp	r16, r15
    1248:	10 f0       	brcs	.+4      	; 0x124e <__vector_22+0x88>
    124a:	ec 19       	sub	r30, r12
    124c:	fd 09       	sbc	r31, r13
			else
			  Byte = TextBuffer[Byte];
    124e:	e4 5f       	subi	r30, 0xF4	; 244
    1250:	fe 4f       	sbci	r31, 0xFE	; 254
    1252:	80 81       	ld	r24, Z
			
			LCD_WriteChar(Byte, Character);
    1254:	0e 94 b3 08 	call	0x1166	; 0x1166 <LCD_WriteChar>
    1258:	21 96       	adiw	r28, 0x01	; 1
    125a:	0f 5f       	subi	r16, 0xFF	; 255
    125c:	c6 30       	cpi	r28, 0x06	; 6
    125e:	d1 05       	cpc	r29, r1
    1260:	79 f7       	brne	.-34     	; 0x1240 <__vector_22+0x7a>
		}
		
		if (StrStart++ == StrEnd)
    1262:	1f 5f       	subi	r17, 0xFF	; 255
    1264:	10 93 0a 01 	sts	0x010A, r17
    1268:	11 50       	subi	r17, 0x01	; 1
    126a:	1f 15       	cp	r17, r15
    126c:	19 f4       	brne	.+6      	; 0x1274 <__vector_22+0xae>
		  StrStart = 1;
    126e:	81 e0       	ldi	r24, 0x01	; 1
    1270:	80 93 0a 01 	sts	0x010A, r24
		
		ScrollCount = LCD_SCROLLCOUNT_DEFAULT;
    1274:	83 e0       	ldi	r24, 0x03	; 3
    1276:	80 93 08 01 	sts	0x0108, r24
		UpdateLCD = FALSE;
    127a:	10 92 09 01 	sts	0x0109, r1
    127e:	a7 e2       	ldi	r26, 0x27	; 39
    1280:	b1 e0       	ldi	r27, 0x01	; 1
    1282:	ec ee       	ldi	r30, 0xEC	; 236
    1284:	f0 e0       	ldi	r31, 0x00	; 0
	}

	for (uint8_t LCDChar = 0; LCDChar < LCD_SEGBUFFER_SIZE; LCDChar++)
	  *(pLCDREG + LCDChar) = SegBuffer[LCDChar];
    1286:	8d 91       	ld	r24, X+
    1288:	81 93       	st	Z+, r24
    128a:	81 e0       	ldi	r24, 0x01	; 1
    128c:	e0 30       	cpi	r30, 0x00	; 0
    128e:	f8 07       	cpc	r31, r24
    1290:	d1 f7       	brne	.-12     	; 0x1286 <__vector_22+0xc0>
    1292:	ff 91       	pop	r31
    1294:	ef 91       	pop	r30
    1296:	df 91       	pop	r29
    1298:	cf 91       	pop	r28
    129a:	bf 91       	pop	r27
    129c:	af 91       	pop	r26
    129e:	9f 91       	pop	r25
    12a0:	8f 91       	pop	r24
    12a2:	7f 91       	pop	r23
    12a4:	6f 91       	pop	r22
    12a6:	5f 91       	pop	r21
    12a8:	4f 91       	pop	r20
    12aa:	3f 91       	pop	r19
    12ac:	2f 91       	pop	r18
    12ae:	1f 91       	pop	r17
    12b0:	0f 91       	pop	r16
    12b2:	ff 90       	pop	r15
    12b4:	df 90       	pop	r13
    12b6:	cf 90       	pop	r12
    12b8:	0f 90       	pop	r0
    12ba:	0f be       	out	0x3f, r0	; 63
    12bc:	0f 90       	pop	r0
    12be:	1f 90       	pop	r1
    12c0:	18 95       	reti

000012c2 <LCD_puts_f>:
    12c2:	0f 93       	push	r16
    12c4:	1f 93       	push	r17
    12c6:	cf 93       	push	r28
    12c8:	df 93       	push	r29
    12ca:	cd b7       	in	r28, 0x3d	; 61
    12cc:	de b7       	in	r29, 0x3e	; 62
    12ce:	64 97       	sbiw	r28, 0x14	; 20
    12d0:	0f b6       	in	r0, 0x3f	; 63
    12d2:	f8 94       	cli
    12d4:	de bf       	out	0x3e, r29	; 62
    12d6:	0f be       	out	0x3f, r0	; 63
    12d8:	cd bf       	out	0x3d, r28	; 61
    12da:	8e 01       	movw	r16, r28
    12dc:	0f 5f       	subi	r16, 0xFF	; 255
    12de:	1f 4f       	sbci	r17, 0xFF	; 255
    12e0:	bc 01       	movw	r22, r24
    12e2:	c8 01       	movw	r24, r16
    12e4:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <strcpy_P>
    12e8:	c8 01       	movw	r24, r16
    12ea:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
    12ee:	64 96       	adiw	r28, 0x14	; 20
    12f0:	0f b6       	in	r0, 0x3f	; 63
    12f2:	f8 94       	cli
    12f4:	de bf       	out	0x3e, r29	; 62
    12f6:	0f be       	out	0x3f, r0	; 63
    12f8:	cd bf       	out	0x3d, r28	; 61
    12fa:	df 91       	pop	r29
    12fc:	cf 91       	pop	r28
    12fe:	1f 91       	pop	r17
    1300:	0f 91       	pop	r16
    1302:	08 95       	ret

00001304 <USART_Tx>:
*   Purpose :       Send one byte through the USART
*
*****************************************************************************/
void USART_Tx(const char data)
{
    1304:	98 2f       	mov	r25, r24
    while (!(UCSRA & (1 << UDRE)));
    1306:	80 91 c0 00 	lds	r24, 0x00C0
    130a:	85 ff       	sbrs	r24, 5
    130c:	fc cf       	rjmp	.-8      	; 0x1306 <USART_Tx+0x2>
    UDR = data;
    130e:	90 93 c6 00 	sts	0x00C6, r25
    1312:	08 95       	ret

00001314 <USART_Rx>:
}

/*****************************************************************************
*
*   Function name : Usart_Rx
*
*   Returns :       char: byte received
*
*   Parameters :    None
*
*   Purpose :       Receives one byte from the USART
*
*****************************************************************************/
char USART_Rx(void)
{
    1314:	80 91 88 01 	lds	r24, 0x0188
    1318:	88 23       	and	r24, r24
    131a:	21 f4       	brne	.+8      	; 0x1324 <USART_Rx+0x10>
    while (!(BuffElements) && !(PacketTimeOut)) {};
    131c:	80 91 8c 01 	lds	r24, 0x018C
    1320:	88 23       	and	r24, r24
    1322:	c1 f3       	breq	.-16     	; 0x1314 <USART_Rx>
    return BUFF_GetBuffByte();
    1324:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <BUFF_GetBuffByte>
}
    1328:	99 27       	eor	r25, r25
    132a:	08 95       	ret

0000132c <USART_Init>:
    132c:	10 92 c5 00 	sts	0x00C5, r1
    1330:	87 e0       	ldi	r24, 0x07	; 7
    1332:	80 93 c4 00 	sts	0x00C4, r24
    1336:	82 e0       	ldi	r24, 0x02	; 2
    1338:	80 93 c0 00 	sts	0x00C0, r24
    133c:	80 e8       	ldi	r24, 0x80	; 128
    133e:	80 93 c1 00 	sts	0x00C1, r24
    1342:	86 e0       	ldi	r24, 0x06	; 6
    1344:	80 93 c2 00 	sts	0x00C2, r24
    1348:	0e 94 db 0b 	call	0x17b6	; 0x17b6 <BUFF_InitialiseBuffer>
    134c:	08 95       	ret

0000134e <SPI_SPIInit>:

// ======================================================================================

void SPI_SPIInit(void)
{
    134e:	e4 e6       	ldi	r30, 0x64	; 100
    1350:	f0 e0       	ldi	r31, 0x00	; 0
    1352:	80 81       	ld	r24, Z
    1354:	8b 7f       	andi	r24, 0xFB	; 251
    1356:	80 83       	st	Z, r24
	PRR &= ~(1 << PRSPI);              // Enable the SPI system by clearing the power save register SPI disable bit

	// Master, Sample falling edge (setup rising), Fosc/2 speed (7.3MHz/2 = 3.6MHz)
	SPSR = (1 << SPI2X);
    1358:	81 e0       	ldi	r24, 0x01	; 1
    135a:	8d bd       	out	0x2d, r24	; 45
	SPCR = ((1 << SPE) | (1 << MSTR) | (1 << CPHA) | (1 << CPOL));
    135c:	8c e5       	ldi	r24, 0x5C	; 92
    135e:	8c bd       	out	0x2c, r24	; 44
    1360:	08 95       	ret

00001362 <SPI_SPITransmit>:
}

uint8_t SPI_SPITransmit(const uint8_t Data)
{
    1362:	8e bd       	out	0x2e, r24	; 46
	SPDR = Data;                       // Loading a byte into the register starts the transmission
	while (!(SPSR & (1 << SPIF)));    // Wait until transmission completed
    1364:	0d b4       	in	r0, 0x2d	; 45
    1366:	07 fe       	sbrs	r0, 7
    1368:	fd cf       	rjmp	.-6      	; 0x1364 <SPI_SPITransmit+0x2>
	return SPDR;
    136a:	8e b5       	in	r24, 0x2e	; 46
}
    136c:	99 27       	eor	r25, r25
    136e:	08 95       	ret

00001370 <SPI_SPITransmitWord>:

uint8_t SPI_SPITransmitWord(const uint16_t Data)
{
    1370:	9c 01       	movw	r18, r24
	SPI_SPITransmit((uint8_t)(Data >> 8));
    1372:	83 2f       	mov	r24, r19
    1374:	99 27       	eor	r25, r25
    1376:	8e bd       	out	0x2e, r24	; 46
    1378:	0d b4       	in	r0, 0x2d	; 45
    137a:	07 fe       	sbrs	r0, 7
    137c:	fd cf       	rjmp	.-6      	; 0x1378 <SPI_SPITransmitWord+0x8>
    137e:	8e b5       	in	r24, 0x2e	; 46
    1380:	2e bd       	out	0x2e, r18	; 46
    1382:	0d b4       	in	r0, 0x2d	; 45
    1384:	07 fe       	sbrs	r0, 7
    1386:	fd cf       	rjmp	.-6      	; 0x1382 <SPI_SPITransmitWord+0x12>
    1388:	8e b5       	in	r24, 0x2e	; 46
	return SPI_SPITransmit((uint8_t)Data);
}
    138a:	99 27       	eor	r25, r25
    138c:	08 95       	ret

0000138e <__vector_17>:
 *  have to stop the timer tick.
 *  For all modes the USIDR contents are stored and flags are updated.
 */
ISR(USI_OVERFLOW_vect, ISR_BLOCK)
{
    138e:	1f 92       	push	r1
    1390:	0f 92       	push	r0
    1392:	0f b6       	in	r0, 0x3f	; 63
    1394:	0f 92       	push	r0
    1396:	11 24       	eor	r1, r1
    1398:	8f 93       	push	r24
    139a:	ef 93       	push	r30
    139c:	ff 93       	push	r31
	// Master must now disable the compare match interrupt
	// to prevent more USI counter clocks.
	TIMSK0 &= ~(1<<OCIE0A);
    139e:	ee e6       	ldi	r30, 0x6E	; 110
    13a0:	f0 e0       	ldi	r31, 0x00	; 0
    13a2:	80 81       	ld	r24, Z
    13a4:	8d 7f       	andi	r24, 0xFD	; 253
    13a6:	80 83       	st	Z, r24
	
	// Update flags and clear USI counter
	USISR = (1<<USIOIF);
    13a8:	80 e4       	ldi	r24, 0x40	; 64
    13aa:	80 93 b9 00 	sts	0x00B9, r24
	TransferComplete = 1;
    13ae:	81 e0       	ldi	r24, 0x01	; 1
    13b0:	80 93 3c 01 	sts	0x013C, r24

	// Copy USIDR to buffer to prevent overwrite on next transfer.
	StoredUSIDR = USIDR;
    13b4:	80 91 ba 00 	lds	r24, 0x00BA
    13b8:	80 93 3b 01 	sts	0x013B, r24
    13bc:	ff 91       	pop	r31
    13be:	ef 91       	pop	r30
    13c0:	8f 91       	pop	r24
    13c2:	0f 90       	pop	r0
    13c4:	0f be       	out	0x3f, r0	; 63
    13c6:	0f 90       	pop	r0
    13c8:	1f 90       	pop	r1
    13ca:	18 95       	reti

000013cc <USI_SPIOff>:
}

/*! \brief  Initialize USI as SPI master.
 *
 *  This function sets up all pin directions and module configurations.
 *  Use this function initially or when changing from slave to master mode.
 *  Note that the stored USIDR value is cleared.
 *
 */
void USI_SPIInitMaster()
{
	// Configure port directions.
 	USI_DIR_REG |= (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN);  // Outputs.
	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN);                       // Inputs.
	USI_OUT_REG |= (1<<USI_DATAIN_PIN);                        // Pull-ups.
	USI_OUT_REG &= ~(1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN); // Pull-ups.
	
	// Configure USI to 3-wire master mode with overflow interrupt.
	USICR = USI_CONTROL_REG_FLAGS;

	// Set the compare and prescaler for the requested frequency:
	USI_SPISetSpeed();
	
	// Init driver status register.
	TransferComplete = 0;
	
	StoredUSIDR = 0;
}

void USI_SPIOff(void)
{
    13cc:	8d b1       	in	r24, 0x0d	; 13
    13ce:	8f 7a       	andi	r24, 0xAF	; 175
    13d0:	8d b9       	out	0x0d, r24	; 13
	USI_DIR_REG &= ~((1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN));                        // Inputs.
	USI_OUT_REG &= ~((1<<USI_DATAIN_PIN)  | (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN)); // Pull-ups.
    13d2:	8e b1       	in	r24, 0x0e	; 14
    13d4:	8f 78       	andi	r24, 0x8F	; 143
    13d6:	8e b9       	out	0x0e, r24	; 14
	DDRF  &= ~(1 << 6);
    13d8:	86 98       	cbi	0x10, 6	; 16
	PORTF &= ~(1 << 6);
    13da:	8e 98       	cbi	0x11, 6	; 17
	
	USI_STOPUSITIMER();
    13dc:	14 bc       	out	0x24, r1	; 36
    13de:	08 95       	ret

000013e0 <USI_SPITransmit>:
}

/*! \brief  Put one byte on bus.
 *
 *  Use this function like you would write to the SPDR register in the native SPI module.
 *  Calling this function in master mode starts a transfer, while in slave mode, a
 *  byte will be prepared for the next transfer initiated by the master device.
 *  If a transfer is in progress, this function will set the write collision flag
 *  and return without altering the data registers.
 *
 *  \returns  Value returned by slave.
 */
uint8_t USI_SPITransmit(uint8_t val)
{
    13e0:	10 92 3c 01 	sts	0x013C, r1
	// Reinit flags.
	TransferComplete = 0;

	// Put data in USI data register.
	USIDR = val;
    13e4:	80 93 ba 00 	sts	0x00BA, r24
	
	TIFR0  |= (1<<OCF0A);  // Clear compare match flag.
    13e8:	a9 9a       	sbi	0x15, 1	; 21
	TIMSK0 |= (1<<OCIE0A); // Enable compare match interrupt.
    13ea:	80 91 6e 00 	lds	r24, 0x006E
    13ee:	82 60       	ori	r24, 0x02	; 2
    13f0:	80 93 6e 00 	sts	0x006E, r24

	// Clear the timer 0 value
	TCNT0 = 0;
    13f4:	16 bc       	out	0x26, r1	; 38

	while (!(TransferComplete));
    13f6:	80 91 3c 01 	lds	r24, 0x013C
    13fa:	88 23       	and	r24, r24
    13fc:	e1 f3       	breq	.-8      	; 0x13f6 <USI_SPITransmit+0x16>

	return StoredUSIDR;
    13fe:	80 91 3b 01 	lds	r24, 0x013B
}
    1402:	99 27       	eor	r25, r25
    1404:	08 95       	ret

00001406 <USI_SPITransmitWord>:

uint8_t USI_SPITransmitWord(const uint16_t val )
{
    1406:	0f 93       	push	r16
    1408:	1f 93       	push	r17
    140a:	8c 01       	movw	r16, r24
	USI_SPITransmit((uint8_t)(val >> 8));
    140c:	81 2f       	mov	r24, r17
    140e:	99 27       	eor	r25, r25
    1410:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
	return USI_SPITransmit((uint8_t)val);
    1414:	80 2f       	mov	r24, r16
    1416:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
}
    141a:	99 27       	eor	r25, r25
    141c:	1f 91       	pop	r17
    141e:	0f 91       	pop	r16
    1420:	08 95       	ret

00001422 <USI_SPISetSpeed>:

void USI_SPIToggleClock(void)
{
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);
	USICR |= (1 << USITC); // Toggle the clock pin
	MAIN_Delay1MS(1);	
}

void USI_SPISetSpeed()
{
    1422:	42 e0       	ldi	r20, 0x02	; 2
    1424:	50 e0       	ldi	r21, 0x00	; 0
    1426:	29 e9       	ldi	r18, 0x99	; 153
    1428:	33 e0       	ldi	r19, 0x03	; 3
    142a:	f9 01       	movw	r30, r18
    142c:	31 97       	sbiw	r30, 0x01	; 1
	for (uint8_t MatchIndex = 0; MatchIndex < USI_PRESET_SPEEDS; MatchIndex++)
	{
		if ((pgm_read_byte(&USIPSValues[MatchIndex][0]) == eeprom_read_byte(&EEPROMVars.SCKDuration)) || (MatchIndex == (USI_PRESET_SPEEDS - 1)))
    142e:	84 91       	lpm	r24, Z
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1430:	da 01       	movw	r26, r20
    1432:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
    1436:	90 2d       	mov	r25, r0
    1438:	89 17       	cp	r24, r25
    143a:	21 f0       	breq	.+8      	; 0x1444 <USI_SPISetSpeed+0x22>
    143c:	83 e0       	ldi	r24, 0x03	; 3
    143e:	ee 39       	cpi	r30, 0x9E	; 158
    1440:	f8 07       	cpc	r31, r24
    1442:	31 f4       	brne	.+12     	; 0x1450 <USI_SPISetSpeed+0x2e>
		{
			// Init Output Compare Register.
			OCR0A = pgm_read_byte(&USIPSValues[MatchIndex][1]);
    1444:	f9 01       	movw	r30, r18
    1446:	84 91       	lpm	r24, Z
    1448:	87 bd       	out	0x27, r24	; 39

			// Enable 'Clear Timer on Compare match' and set prescaler, which starts the timer
			TCCR0A = ((1<<WGM01) | TC0_PS_1);
    144a:	89 e0       	ldi	r24, 0x09	; 9
    144c:	84 bd       	out	0x24, r24	; 36
    144e:	08 95       	ret
    1450:	32 96       	adiw	r30, 0x02	; 2
    1452:	2e 5f       	subi	r18, 0xFE	; 254
    1454:	3f 4f       	sbci	r19, 0xFF	; 255
    1456:	83 e0       	ldi	r24, 0x03	; 3
    1458:	e0 3a       	cpi	r30, 0xA0	; 160
    145a:	f8 07       	cpc	r31, r24
    145c:	41 f7       	brne	.-48     	; 0x142e <USI_SPISetSpeed+0xc>
    145e:	08 95       	ret

00001460 <USI_SPIInitMaster>:
    1460:	8d b1       	in	r24, 0x0d	; 13
    1462:	80 65       	ori	r24, 0x50	; 80
    1464:	8d b9       	out	0x0d, r24	; 13
    1466:	6d 98       	cbi	0x0d, 5	; 13
    1468:	75 9a       	sbi	0x0e, 5	; 14
    146a:	76 98       	cbi	0x0e, 6	; 14
    146c:	8a e5       	ldi	r24, 0x5A	; 90
    146e:	80 93 b8 00 	sts	0x00B8, r24
    1472:	0e 94 11 0a 	call	0x1422	; 0x1422 <USI_SPISetSpeed>
    1476:	10 92 3c 01 	sts	0x013C, r1
    147a:	10 92 3b 01 	sts	0x013B, r1
    147e:	08 95       	ret

00001480 <USI_SPIToggleClock>:
    1480:	0f 93       	push	r16
    1482:	1f 93       	push	r17
    1484:	81 e0       	ldi	r24, 0x01	; 1
    1486:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    148a:	08 eb       	ldi	r16, 0xB8	; 184
    148c:	10 e0       	ldi	r17, 0x00	; 0
    148e:	f8 01       	movw	r30, r16
    1490:	80 81       	ld	r24, Z
    1492:	81 60       	ori	r24, 0x01	; 1
    1494:	80 83       	st	Z, r24
    1496:	81 e0       	ldi	r24, 0x01	; 1
    1498:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    149c:	f8 01       	movw	r30, r16
    149e:	80 81       	ld	r24, Z
    14a0:	81 60       	ori	r24, 0x01	; 1
    14a2:	80 83       	st	Z, r24
    14a4:	81 e0       	ldi	r24, 0x01	; 1
    14a6:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    14aa:	1f 91       	pop	r17
    14ac:	0f 91       	pop	r16
    14ae:	08 95       	ret

000014b0 <DF_EnableDataflash>:
	DF_WaitWhileBusy();
}

void DF_EnableDataflash(const uint8_t Enabled)
{
    14b0:	90 91 47 01 	lds	r25, 0x0147
	if (Enabled == TRUE)
    14b4:	81 30       	cpi	r24, 0x01	; 1
    14b6:	31 f4       	brne	.+12     	; 0x14c4 <DF_EnableDataflash+0x14>
	{
		if (DataflashInfo.UseExernalDF == TRUE)
    14b8:	91 30       	cpi	r25, 0x01	; 1
    14ba:	11 f4       	brne	.+4      	; 0x14c0 <DF_EnableDataflash+0x10>
		  MAIN_ResetCSLine(MAIN_RESETCS_EXTDFACTIVE);
    14bc:	82 e0       	ldi	r24, 0x02	; 2
    14be:	05 c0       	rjmp	.+10     	; 0x14ca <DF_EnableDataflash+0x1a>
		else
		  PORTB &= ~(1 << 0);
    14c0:	28 98       	cbi	0x05, 0	; 5
    14c2:	08 95       	ret
	}
	else
	{
		if (DataflashInfo.UseExernalDF == TRUE)
    14c4:	91 30       	cpi	r25, 0x01	; 1
    14c6:	21 f4       	brne	.+8      	; 0x14d0 <DF_EnableDataflash+0x20>
		  MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE);
    14c8:	81 e0       	ldi	r24, 0x01	; 1
    14ca:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
    14ce:	08 95       	ret
		else
		  PORTB |= (1 << 0);
    14d0:	28 9a       	sbi	0x05, 0	; 5
    14d2:	08 95       	ret

000014d4 <DF_ReadBufferByte>:
    14d4:	ef 92       	push	r14
    14d6:	ff 92       	push	r15
    14d8:	0f 93       	push	r16
    14da:	1f 93       	push	r17
    14dc:	7c 01       	movw	r14, r24
    14de:	00 91 00 01 	lds	r16, 0x0100
    14e2:	10 91 01 01 	lds	r17, 0x0101
    14e6:	80 e0       	ldi	r24, 0x00	; 0
    14e8:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    14ec:	81 e0       	ldi	r24, 0x01	; 1
    14ee:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    14f2:	84 e5       	ldi	r24, 0x54	; 84
    14f4:	f8 01       	movw	r30, r16
    14f6:	09 95       	icall
    14f8:	8f 2d       	mov	r24, r15
    14fa:	99 27       	eor	r25, r25
    14fc:	f8 01       	movw	r30, r16
    14fe:	09 95       	icall
    1500:	8e 2d       	mov	r24, r14
    1502:	f8 01       	movw	r30, r16
    1504:	09 95       	icall
    1506:	80 e0       	ldi	r24, 0x00	; 0
    1508:	f8 01       	movw	r30, r16
    150a:	09 95       	icall
    150c:	80 e0       	ldi	r24, 0x00	; 0
    150e:	f8 01       	movw	r30, r16
    1510:	09 95       	icall
    1512:	99 27       	eor	r25, r25
    1514:	1f 91       	pop	r17
    1516:	0f 91       	pop	r16
    1518:	ff 90       	pop	r15
    151a:	ef 90       	pop	r14
    151c:	08 95       	ret

0000151e <DF_ContinuousReadEnable>:
    151e:	ef 92       	push	r14
    1520:	ff 92       	push	r15
    1522:	0f 93       	push	r16
    1524:	1f 93       	push	r17
    1526:	cf 93       	push	r28
    1528:	df 93       	push	r29
    152a:	8c 01       	movw	r16, r24
    152c:	7b 01       	movw	r14, r22
    152e:	c0 91 00 01 	lds	r28, 0x0100
    1532:	d0 91 01 01 	lds	r29, 0x0101
    1536:	80 e0       	ldi	r24, 0x00	; 0
    1538:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    153c:	81 e0       	ldi	r24, 0x01	; 1
    153e:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    1542:	88 e6       	ldi	r24, 0x68	; 104
    1544:	fe 01       	movw	r30, r28
    1546:	09 95       	icall
    1548:	8a b5       	in	r24, 0x2a	; 42
    154a:	98 01       	movw	r18, r16
    154c:	02 c0       	rjmp	.+4      	; 0x1552 <DF_ContinuousReadEnable+0x34>
    154e:	36 95       	lsr	r19
    1550:	27 95       	ror	r18
    1552:	8a 95       	dec	r24
    1554:	e2 f7       	brpl	.-8      	; 0x154e <DF_ContinuousReadEnable+0x30>
    1556:	c9 01       	movw	r24, r18
    1558:	fe 01       	movw	r30, r28
    155a:	09 95       	icall
    155c:	8b b5       	in	r24, 0x2b	; 43
    155e:	02 c0       	rjmp	.+4      	; 0x1564 <DF_ContinuousReadEnable+0x46>
    1560:	00 0f       	add	r16, r16
    1562:	11 1f       	adc	r17, r17
    1564:	8a 95       	dec	r24
    1566:	e2 f7       	brpl	.-8      	; 0x1560 <DF_ContinuousReadEnable+0x42>
    1568:	8f 2d       	mov	r24, r15
    156a:	99 27       	eor	r25, r25
    156c:	80 0f       	add	r24, r16
    156e:	fe 01       	movw	r30, r28
    1570:	09 95       	icall
    1572:	8e 2d       	mov	r24, r14
    1574:	fe 01       	movw	r30, r28
    1576:	09 95       	icall
    1578:	00 e0       	ldi	r16, 0x00	; 0
    157a:	80 e0       	ldi	r24, 0x00	; 0
    157c:	fe 01       	movw	r30, r28
    157e:	09 95       	icall
    1580:	0f 5f       	subi	r16, 0xFF	; 255
    1582:	04 30       	cpi	r16, 0x04	; 4
    1584:	d1 f7       	brne	.-12     	; 0x157a <DF_ContinuousReadEnable+0x5c>
    1586:	df 91       	pop	r29
    1588:	cf 91       	pop	r28
    158a:	1f 91       	pop	r17
    158c:	0f 91       	pop	r16
    158e:	ff 90       	pop	r15
    1590:	ef 90       	pop	r14
    1592:	08 95       	ret

00001594 <DF_BufferWriteEnable>:
    1594:	ef 92       	push	r14
    1596:	ff 92       	push	r15
    1598:	0f 93       	push	r16
    159a:	1f 93       	push	r17
    159c:	7c 01       	movw	r14, r24
    159e:	00 91 00 01 	lds	r16, 0x0100
    15a2:	10 91 01 01 	lds	r17, 0x0101
    15a6:	80 e0       	ldi	r24, 0x00	; 0
    15a8:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    15ac:	81 e0       	ldi	r24, 0x01	; 1
    15ae:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    15b2:	84 e8       	ldi	r24, 0x84	; 132
    15b4:	f8 01       	movw	r30, r16
    15b6:	09 95       	icall
    15b8:	80 e0       	ldi	r24, 0x00	; 0
    15ba:	f8 01       	movw	r30, r16
    15bc:	09 95       	icall
    15be:	8f 2d       	mov	r24, r15
    15c0:	99 27       	eor	r25, r25
    15c2:	f8 01       	movw	r30, r16
    15c4:	09 95       	icall
    15c6:	8e 2d       	mov	r24, r14
    15c8:	f8 01       	movw	r30, r16
    15ca:	09 95       	icall
    15cc:	1f 91       	pop	r17
    15ce:	0f 91       	pop	r16
    15d0:	ff 90       	pop	r15
    15d2:	ef 90       	pop	r14
    15d4:	08 95       	ret

000015d6 <DF_WaitWhileBusy>:
    15d6:	cf 93       	push	r28
    15d8:	df 93       	push	r29
    15da:	c0 91 00 01 	lds	r28, 0x0100
    15de:	d0 91 01 01 	lds	r29, 0x0101
    15e2:	80 e0       	ldi	r24, 0x00	; 0
    15e4:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    15e8:	81 e0       	ldi	r24, 0x01	; 1
    15ea:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    15ee:	87 e5       	ldi	r24, 0x57	; 87
    15f0:	fe 01       	movw	r30, r28
    15f2:	09 95       	icall
    15f4:	80 e0       	ldi	r24, 0x00	; 0
    15f6:	fe 01       	movw	r30, r28
    15f8:	09 95       	icall
    15fa:	87 ff       	sbrs	r24, 7
    15fc:	fb cf       	rjmp	.-10     	; 0x15f4 <DF_WaitWhileBusy+0x1e>
    15fe:	df 91       	pop	r29
    1600:	cf 91       	pop	r28
    1602:	08 95       	ret

00001604 <DF_EraseBlock>:
    1604:	ef 92       	push	r14
    1606:	ff 92       	push	r15
    1608:	0f 93       	push	r16
    160a:	1f 93       	push	r17
    160c:	7c 01       	movw	r14, r24
    160e:	00 91 00 01 	lds	r16, 0x0100
    1612:	10 91 01 01 	lds	r17, 0x0101
    1616:	80 e0       	ldi	r24, 0x00	; 0
    1618:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    161c:	81 e0       	ldi	r24, 0x01	; 1
    161e:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    1622:	80 e5       	ldi	r24, 0x50	; 80
    1624:	f8 01       	movw	r30, r16
    1626:	09 95       	icall
    1628:	8f 2d       	mov	r24, r15
    162a:	99 27       	eor	r25, r25
    162c:	f8 01       	movw	r30, r16
    162e:	09 95       	icall
    1630:	8e 2d       	mov	r24, r14
    1632:	f8 01       	movw	r30, r16
    1634:	09 95       	icall
    1636:	80 e0       	ldi	r24, 0x00	; 0
    1638:	f8 01       	movw	r30, r16
    163a:	09 95       	icall
    163c:	0e 94 eb 0a 	call	0x15d6	; 0x15d6 <DF_WaitWhileBusy>
    1640:	1f 91       	pop	r17
    1642:	0f 91       	pop	r16
    1644:	ff 90       	pop	r15
    1646:	ef 90       	pop	r14
    1648:	08 95       	ret

0000164a <DF_CopyFlashPageToBuffer>:
    164a:	ef 92       	push	r14
    164c:	ff 92       	push	r15
    164e:	0f 93       	push	r16
    1650:	1f 93       	push	r17
    1652:	8c 01       	movw	r16, r24
    1654:	e0 90 00 01 	lds	r14, 0x0100
    1658:	f0 90 01 01 	lds	r15, 0x0101
    165c:	80 e0       	ldi	r24, 0x00	; 0
    165e:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    1662:	81 e0       	ldi	r24, 0x01	; 1
    1664:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    1668:	83 e5       	ldi	r24, 0x53	; 83
    166a:	f7 01       	movw	r30, r14
    166c:	09 95       	icall
    166e:	8a b5       	in	r24, 0x2a	; 42
    1670:	98 01       	movw	r18, r16
    1672:	02 c0       	rjmp	.+4      	; 0x1678 <DF_CopyFlashPageToBuffer+0x2e>
    1674:	36 95       	lsr	r19
    1676:	27 95       	ror	r18
    1678:	8a 95       	dec	r24
    167a:	e2 f7       	brpl	.-8      	; 0x1674 <DF_CopyFlashPageToBuffer+0x2a>
    167c:	c9 01       	movw	r24, r18
    167e:	f7 01       	movw	r30, r14
    1680:	09 95       	icall
    1682:	8b b5       	in	r24, 0x2b	; 43
    1684:	02 c0       	rjmp	.+4      	; 0x168a <DF_CopyFlashPageToBuffer+0x40>
    1686:	00 0f       	add	r16, r16
    1688:	11 1f       	adc	r17, r17
    168a:	8a 95       	dec	r24
    168c:	e2 f7       	brpl	.-8      	; 0x1686 <DF_CopyFlashPageToBuffer+0x3c>
    168e:	80 2f       	mov	r24, r16
    1690:	f7 01       	movw	r30, r14
    1692:	09 95       	icall
    1694:	80 e0       	ldi	r24, 0x00	; 0
    1696:	f7 01       	movw	r30, r14
    1698:	09 95       	icall
    169a:	0e 94 eb 0a 	call	0x15d6	; 0x15d6 <DF_WaitWhileBusy>
    169e:	1f 91       	pop	r17
    16a0:	0f 91       	pop	r16
    16a2:	ff 90       	pop	r15
    16a4:	ef 90       	pop	r14
    16a6:	08 95       	ret

000016a8 <DF_CopyBufferToFlashPage>:
    16a8:	ef 92       	push	r14
    16aa:	ff 92       	push	r15
    16ac:	0f 93       	push	r16
    16ae:	1f 93       	push	r17
    16b0:	8c 01       	movw	r16, r24
    16b2:	e0 90 00 01 	lds	r14, 0x0100
    16b6:	f0 90 01 01 	lds	r15, 0x0101
    16ba:	80 e0       	ldi	r24, 0x00	; 0
    16bc:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    16c0:	81 e0       	ldi	r24, 0x01	; 1
    16c2:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    16c6:	83 e8       	ldi	r24, 0x83	; 131
    16c8:	f7 01       	movw	r30, r14
    16ca:	09 95       	icall
    16cc:	8a b5       	in	r24, 0x2a	; 42
    16ce:	98 01       	movw	r18, r16
    16d0:	02 c0       	rjmp	.+4      	; 0x16d6 <DF_CopyBufferToFlashPage+0x2e>
    16d2:	36 95       	lsr	r19
    16d4:	27 95       	ror	r18
    16d6:	8a 95       	dec	r24
    16d8:	e2 f7       	brpl	.-8      	; 0x16d2 <DF_CopyBufferToFlashPage+0x2a>
    16da:	c9 01       	movw	r24, r18
    16dc:	f7 01       	movw	r30, r14
    16de:	09 95       	icall
    16e0:	8b b5       	in	r24, 0x2b	; 43
    16e2:	02 c0       	rjmp	.+4      	; 0x16e8 <DF_CopyBufferToFlashPage+0x40>
    16e4:	00 0f       	add	r16, r16
    16e6:	11 1f       	adc	r17, r17
    16e8:	8a 95       	dec	r24
    16ea:	e2 f7       	brpl	.-8      	; 0x16e4 <DF_CopyBufferToFlashPage+0x3c>
    16ec:	80 2f       	mov	r24, r16
    16ee:	f7 01       	movw	r30, r14
    16f0:	09 95       	icall
    16f2:	80 e0       	ldi	r24, 0x00	; 0
    16f4:	f7 01       	movw	r30, r14
    16f6:	09 95       	icall
    16f8:	0e 94 eb 0a 	call	0x15d6	; 0x15d6 <DF_WaitWhileBusy>
    16fc:	1f 91       	pop	r17
    16fe:	0f 91       	pop	r16
    1700:	ff 90       	pop	r15
    1702:	ef 90       	pop	r14
    1704:	08 95       	ret

00001706 <DF_GetChipCharacteristics>:
    1706:	0f 93       	push	r16
    1708:	1f 93       	push	r17
    170a:	00 91 00 01 	lds	r16, 0x0100
    170e:	10 91 01 01 	lds	r17, 0x0101
    1712:	80 e0       	ldi	r24, 0x00	; 0
    1714:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    1718:	81 e0       	ldi	r24, 0x01	; 1
    171a:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    171e:	87 e5       	ldi	r24, 0x57	; 87
    1720:	f8 01       	movw	r30, r16
    1722:	09 95       	icall
    1724:	80 e0       	ldi	r24, 0x00	; 0
    1726:	f8 01       	movw	r30, r16
    1728:	09 95       	icall
    172a:	99 27       	eor	r25, r25
    172c:	88 73       	andi	r24, 0x38	; 56
    172e:	90 70       	andi	r25, 0x00	; 0
    1730:	63 e0       	ldi	r22, 0x03	; 3
    1732:	96 95       	lsr	r25
    1734:	87 95       	ror	r24
    1736:	6a 95       	dec	r22
    1738:	e1 f7       	brne	.-8      	; 0x1732 <DF_GetChipCharacteristics+0x2c>
    173a:	fc 01       	movw	r30, r24
    173c:	e0 56       	subi	r30, 0x60	; 96
    173e:	fc 4f       	sbci	r31, 0xFC	; 252
    1740:	e4 91       	lpm	r30, Z
    1742:	4e 2f       	mov	r20, r30
    1744:	55 27       	eor	r21, r21
    1746:	50 93 3e 01 	sts	0x013E, r21
    174a:	40 93 3d 01 	sts	0x013D, r20
    174e:	88 0f       	add	r24, r24
    1750:	99 1f       	adc	r25, r25
    1752:	fc 01       	movw	r30, r24
    1754:	e8 55       	subi	r30, 0x58	; 88
    1756:	fc 4f       	sbci	r31, 0xFC	; 252
    1758:	25 91       	lpm	r18, Z+
    175a:	34 91       	lpm	r19, Z
    175c:	30 93 40 01 	sts	0x0140, r19
    1760:	20 93 3f 01 	sts	0x013F, r18
    1764:	88 54       	subi	r24, 0x48	; 72
    1766:	9c 4f       	sbci	r25, 0xFC	; 252
    1768:	fc 01       	movw	r30, r24
    176a:	25 91       	lpm	r18, Z+
    176c:	34 91       	lpm	r19, Z
    176e:	30 93 42 01 	sts	0x0142, r19
    1772:	20 93 41 01 	sts	0x0141, r18
    1776:	80 e1       	ldi	r24, 0x10	; 16
    1778:	84 1b       	sub	r24, r20
    177a:	8a bd       	out	0x2a, r24	; 42
    177c:	48 50       	subi	r20, 0x08	; 8
    177e:	4b bd       	out	0x2b, r20	; 43
    1780:	1f 91       	pop	r17
    1782:	0f 91       	pop	r16
    1784:	08 95       	ret

00001786 <DF_CheckCorrectOnboardChip>:
    1786:	0e 94 83 0b 	call	0x1706	; 0x1706 <DF_GetChipCharacteristics>
    178a:	80 91 41 01 	lds	r24, 0x0141
    178e:	90 91 42 01 	lds	r25, 0x0142
    1792:	80 50       	subi	r24, 0x00	; 0
    1794:	98 40       	sbci	r25, 0x08	; 8
    1796:	19 f4       	brne	.+6      	; 0x179e <DF_CheckCorrectOnboardChip+0x18>
    1798:	81 e0       	ldi	r24, 0x01	; 1
    179a:	90 e0       	ldi	r25, 0x00	; 0
    179c:	08 95       	ret
    179e:	80 91 64 00 	lds	r24, 0x0064
    17a2:	84 60       	ori	r24, 0x04	; 4
    17a4:	80 93 64 00 	sts	0x0064, r24
    17a8:	88 ec       	ldi	r24, 0xC8	; 200
    17aa:	93 e0       	ldi	r25, 0x03	; 3
    17ac:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
    17b0:	80 e0       	ldi	r24, 0x00	; 0
    17b2:	90 e0       	ldi	r25, 0x00	; 0
    17b4:	08 95       	ret

000017b6 <BUFF_InitialiseBuffer>:

// ======================================================================================

void BUFF_InitialiseBuffer(void)
{
    17b6:	10 92 89 01 	sts	0x0189, r1
	InPos  = 0;                            // Set up the IN counter to the start of the buffer
	OutPos = 0;                            // Set up the OUT counter to the start of the buffer
    17ba:	10 92 8a 01 	sts	0x018A, r1

	BuffElements = 0;                      // Reset the buffer elements counter
    17be:	10 92 88 01 	sts	0x0188, r1
    17c2:	08 95       	ret

000017c4 <BUFF_GetBuffByte>:
}

uint8_t BUFF_GetBuffByte(void)
{
    17c4:	80 91 88 01 	lds	r24, 0x0188
    17c8:	88 23       	and	r24, r24
    17ca:	19 f4       	brne	.+6      	; 0x17d2 <BUFF_GetBuffByte+0xe>
	if (!(BuffElements))                   // No elements in the buffer
    17cc:	80 e0       	ldi	r24, 0x00	; 0
    17ce:	90 e0       	ldi	r25, 0x00	; 0
    17d0:	08 95       	ret
	  return 0;

	uint8_t RetrievedData = RingBuffer[OutPos++]; // Grab the stored byte into a temp variable
    17d2:	80 91 8a 01 	lds	r24, 0x018A
    17d6:	e8 2f       	mov	r30, r24
    17d8:	ff 27       	eor	r31, r31
    17da:	e8 5b       	subi	r30, 0xB8	; 184
    17dc:	fe 4f       	sbci	r31, 0xFE	; 254
    17de:	e0 81       	ld	r30, Z
    17e0:	8f 5f       	subi	r24, 0xFF	; 255
    17e2:	80 93 8a 01 	sts	0x018A, r24
	BuffElements--;                        // Decrement the total elements variable
    17e6:	80 91 88 01 	lds	r24, 0x0188
    17ea:	81 50       	subi	r24, 0x01	; 1
    17ec:	80 93 88 01 	sts	0x0188, r24
	
	if (OutPos == BUFF_BUFFLEN)
    17f0:	80 91 8a 01 	lds	r24, 0x018A
    17f4:	80 34       	cpi	r24, 0x40	; 64
    17f6:	11 f4       	brne	.+4      	; 0x17fc <BUFF_GetBuffByte+0x38>
	  OutPos = 0;                        // Wrap pointer if end of array reached
    17f8:	10 92 8a 01 	sts	0x018A, r1
		
	return RetrievedData;                 // Return the retrieved data
    17fc:	8e 2f       	mov	r24, r30
    17fe:	99 27       	eor	r25, r25
}
    1800:	08 95       	ret

00001802 <__vector_13>:
    1802:	1f 92       	push	r1
    1804:	0f 92       	push	r0
    1806:	0f b6       	in	r0, 0x3f	; 63
    1808:	0f 92       	push	r0
    180a:	11 24       	eor	r1, r1
    180c:	2f 93       	push	r18
    180e:	3f 93       	push	r19
    1810:	4f 93       	push	r20
    1812:	5f 93       	push	r21
    1814:	6f 93       	push	r22
    1816:	7f 93       	push	r23
    1818:	8f 93       	push	r24
    181a:	9f 93       	push	r25
    181c:	af 93       	push	r26
    181e:	bf 93       	push	r27
    1820:	ef 93       	push	r30
    1822:	ff 93       	push	r31
    1824:	80 91 88 01 	lds	r24, 0x0188
    1828:	80 34       	cpi	r24, 0x40	; 64
    182a:	21 f4       	brne	.+8      	; 0x1834 <__vector_13+0x32>
    182c:	88 ed       	ldi	r24, 0xD8	; 216
    182e:	93 e0       	ldi	r25, 0x03	; 3
    1830:	0e 94 c7 04 	call	0x98e	; 0x98e <MAIN_CrashProgram>
    1834:	80 91 89 01 	lds	r24, 0x0189
    1838:	e8 2f       	mov	r30, r24
    183a:	ff 27       	eor	r31, r31
    183c:	90 91 c6 00 	lds	r25, 0x00C6
    1840:	e8 5b       	subi	r30, 0xB8	; 184
    1842:	fe 4f       	sbci	r31, 0xFE	; 254
    1844:	90 83       	st	Z, r25
    1846:	8f 5f       	subi	r24, 0xFF	; 255
    1848:	80 93 89 01 	sts	0x0189, r24
    184c:	80 91 88 01 	lds	r24, 0x0188
    1850:	8f 5f       	subi	r24, 0xFF	; 255
    1852:	80 93 88 01 	sts	0x0188, r24
    1856:	80 91 89 01 	lds	r24, 0x0189
    185a:	80 34       	cpi	r24, 0x40	; 64
    185c:	11 f4       	brne	.+4      	; 0x1862 <__vector_13+0x60>
    185e:	10 92 89 01 	sts	0x0189, r1
    1862:	ff 91       	pop	r31
    1864:	ef 91       	pop	r30
    1866:	bf 91       	pop	r27
    1868:	af 91       	pop	r26
    186a:	9f 91       	pop	r25
    186c:	8f 91       	pop	r24
    186e:	7f 91       	pop	r23
    1870:	6f 91       	pop	r22
    1872:	5f 91       	pop	r21
    1874:	4f 91       	pop	r20
    1876:	3f 91       	pop	r19
    1878:	2f 91       	pop	r18
    187a:	0f 90       	pop	r0
    187c:	0f be       	out	0x3f, r0	; 63
    187e:	0f 90       	pop	r0
    1880:	1f 90       	pop	r1
    1882:	18 95       	reti

00001884 <TOUT_SetupSleepTimer>:

// ======================================================================================

void TOUT_SetupSleepTimer(void)
{
    1884:	a8 e8       	ldi	r26, 0x88	; 136
    1886:	b0 e0       	ldi	r27, 0x00	; 0
    1888:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
    188c:	80 2d       	mov	r24, r0
	uint8_t NewTicksIndex = eeprom_read_byte(&EEPROMVars.AutoSleepValIndex);
    188e:	28 2f       	mov	r18, r24
    1890:	33 27       	eor	r19, r19
    1892:	e2 2f       	mov	r30, r18

	if (NewTicksIndex == 0xFF) // Blank EEPROM protection
    1894:	2f 3f       	cpi	r18, 0xFF	; 255
    1896:	01 f1       	breq	.+64     	; 0x18d8 <TOUT_SetupSleepTimer+0x54>
	  NewTicksIndex = 4;

	TIMSK1 = (1 << TOIE1);
    1898:	81 e0       	ldi	r24, 0x01	; 1
    189a:	80 93 6f 00 	sts	0x006F, r24
	TicksBeforeAutoSleep = (pgm_read_byte(&AutoSleepTOValues[NewTicksIndex]) * 10);
    189e:	ff 27       	eor	r31, r31
    18a0:	ef 51       	subi	r30, 0x1F	; 31
    18a2:	fc 4f       	sbci	r31, 0xFC	; 252
    18a4:	e4 91       	lpm	r30, Z
    18a6:	8a e0       	ldi	r24, 0x0A	; 10
    18a8:	e8 9f       	mul	r30, r24
    18aa:	c0 01       	movw	r24, r0
    18ac:	11 24       	eor	r1, r1
    18ae:	90 93 90 01 	sts	0x0190, r25
    18b2:	80 93 8f 01 	sts	0x018F, r24

	TIMEOUT_SLEEP_TIMEOUT_RESET();
    18b6:	10 92 8e 01 	sts	0x018E, r1
    18ba:	10 92 8d 01 	sts	0x018D, r1
    18be:	10 92 85 00 	sts	0x0085, r1
    18c2:	10 92 84 00 	sts	0x0084, r1
	
	if (NewTicksIndex)
    18c6:	22 23       	and	r18, r18
    18c8:	21 f0       	breq	.+8      	; 0x18d2 <TOUT_SetupSleepTimer+0x4e>
	  TIMEOUT_SLEEP_TIMER_ON();
    18ca:	81 e0       	ldi	r24, 0x01	; 1
    18cc:	80 93 81 00 	sts	0x0081, r24
    18d0:	08 95       	ret
	else
	  TIMEOUT_SLEEP_TIMER_OFF();
    18d2:	10 92 81 00 	sts	0x0081, r1
    18d6:	08 95       	ret
    18d8:	81 e0       	ldi	r24, 0x01	; 1
    18da:	80 93 6f 00 	sts	0x006F, r24
    18de:	e5 ee       	ldi	r30, 0xE5	; 229
    18e0:	f3 e0       	ldi	r31, 0x03	; 3
    18e2:	e4 91       	lpm	r30, Z
    18e4:	8a e0       	ldi	r24, 0x0A	; 10
    18e6:	e8 9f       	mul	r30, r24
    18e8:	c0 01       	movw	r24, r0
    18ea:	11 24       	eor	r1, r1
    18ec:	90 93 90 01 	sts	0x0190, r25
    18f0:	80 93 8f 01 	sts	0x018F, r24
    18f4:	10 92 8e 01 	sts	0x018E, r1
    18f8:	10 92 8d 01 	sts	0x018D, r1
    18fc:	10 92 85 00 	sts	0x0085, r1
    1900:	10 92 84 00 	sts	0x0084, r1
    1904:	e2 cf       	rjmp	.-60     	; 0x18ca <TOUT_SetupSleepTimer+0x46>

00001906 <__vector_9>:
    1906:	78 94       	sei
    1908:	1f 92       	push	r1
    190a:	0f 92       	push	r0
    190c:	0f b6       	in	r0, 0x3f	; 63
    190e:	0f 92       	push	r0
    1910:	11 24       	eor	r1, r1
    1912:	2f 93       	push	r18
    1914:	3f 93       	push	r19
    1916:	4f 93       	push	r20
    1918:	5f 93       	push	r21
    191a:	6f 93       	push	r22
    191c:	7f 93       	push	r23
    191e:	8f 93       	push	r24
    1920:	9f 93       	push	r25
    1922:	af 93       	push	r26
    1924:	bf 93       	push	r27
    1926:	ef 93       	push	r30
    1928:	ff 93       	push	r31
    192a:	80 91 8d 01 	lds	r24, 0x018D
    192e:	90 91 8e 01 	lds	r25, 0x018E
    1932:	20 91 8f 01 	lds	r18, 0x018F
    1936:	30 91 90 01 	lds	r19, 0x0190
    193a:	01 96       	adiw	r24, 0x01	; 1
    193c:	90 93 8e 01 	sts	0x018E, r25
    1940:	80 93 8d 01 	sts	0x018D, r24
    1944:	01 97       	sbiw	r24, 0x01	; 1
    1946:	82 17       	cp	r24, r18
    1948:	93 07       	cpc	r25, r19
    194a:	31 f4       	brne	.+12     	; 0x1958 <__vector_9+0x52>
    194c:	10 92 81 00 	sts	0x0081, r1
    1950:	0e 94 d5 02 	call	0x5aa	; 0x5aa <FUNCSleepMode>
    1954:	0e 94 42 0c 	call	0x1884	; 0x1884 <TOUT_SetupSleepTimer>
    1958:	ff 91       	pop	r31
    195a:	ef 91       	pop	r30
    195c:	bf 91       	pop	r27
    195e:	af 91       	pop	r26
    1960:	9f 91       	pop	r25
    1962:	8f 91       	pop	r24
    1964:	7f 91       	pop	r23
    1966:	6f 91       	pop	r22
    1968:	5f 91       	pop	r21
    196a:	4f 91       	pop	r20
    196c:	3f 91       	pop	r19
    196e:	2f 91       	pop	r18
    1970:	0f 90       	pop	r0
    1972:	0f be       	out	0x3f, r0	; 63
    1974:	0f 90       	pop	r0
    1976:	1f 90       	pop	r1
    1978:	18 95       	reti

0000197a <__vector_4>:
    197a:	78 94       	sei
    197c:	1f 92       	push	r1
    197e:	0f 92       	push	r0
    1980:	0f b6       	in	r0, 0x3f	; 63
    1982:	0f 92       	push	r0
    1984:	11 24       	eor	r1, r1
    1986:	2f 93       	push	r18
    1988:	3f 93       	push	r19
    198a:	4f 93       	push	r20
    198c:	5f 93       	push	r21
    198e:	6f 93       	push	r22
    1990:	7f 93       	push	r23
    1992:	8f 93       	push	r24
    1994:	9f 93       	push	r25
    1996:	af 93       	push	r26
    1998:	bf 93       	push	r27
    199a:	ef 93       	push	r30
    199c:	ff 93       	push	r31
    199e:	80 91 8b 01 	lds	r24, 0x018B
    19a2:	8f 5f       	subi	r24, 0xFF	; 255
    19a4:	80 93 8b 01 	sts	0x018B, r24
    19a8:	80 91 8b 01 	lds	r24, 0x018B
    19ac:	87 39       	cpi	r24, 0x97	; 151
    19ae:	29 f4       	brne	.+10     	; 0x19ba <__vector_4+0x40>
    19b0:	10 92 8b 01 	sts	0x018B, r1
    19b4:	81 e0       	ldi	r24, 0x01	; 1
    19b6:	80 93 8c 01 	sts	0x018C, r24
    19ba:	80 91 c0 00 	lds	r24, 0x00C0
    19be:	83 ff       	sbrs	r24, 3
    19c0:	03 c0       	rjmp	.+6      	; 0x19c8 <__vector_4+0x4e>
    19c2:	80 ef       	ldi	r24, 0xF0	; 240
    19c4:	93 e0       	ldi	r25, 0x03	; 3
    19c6:	06 c0       	rjmp	.+12     	; 0x19d4 <__vector_4+0x5a>
    19c8:	80 91 c0 00 	lds	r24, 0x00C0
    19cc:	84 ff       	sbrs	r24, 4
    19ce:	04 c0       	rjmp	.+8      	; 0x19d8 <__vector_4+0x5e>
    19d0:	86 ee       	ldi	r24, 0xE6	; 230
    19d2:	93 e0       	ldi	r25, 0x03	; 3
    19d4:	0e 94 c7 04 	call	0x98e	; 0x98e <MAIN_CrashProgram>
    19d8:	ff 91       	pop	r31
    19da:	ef 91       	pop	r30
    19dc:	bf 91       	pop	r27
    19de:	af 91       	pop	r26
    19e0:	9f 91       	pop	r25
    19e2:	8f 91       	pop	r24
    19e4:	7f 91       	pop	r23
    19e6:	6f 91       	pop	r22
    19e8:	5f 91       	pop	r21
    19ea:	4f 91       	pop	r20
    19ec:	3f 91       	pop	r19
    19ee:	2f 91       	pop	r18
    19f0:	0f 90       	pop	r0
    19f2:	0f be       	out	0x3f, r0	; 63
    19f4:	0f 90       	pop	r0
    19f6:	1f 90       	pop	r1
    19f8:	18 95       	reti

000019fa <PD_SetupDFAddressCounters>:
	}
}

void PD_SetupDFAddressCounters(void)
{
    19fa:	ef 92       	push	r14
    19fc:	ff 92       	push	r15
    19fe:	0f 93       	push	r16
    1a00:	1f 93       	push	r17
	uint32_t StartAddress = CurrAddress;
    1a02:	20 91 a9 02 	lds	r18, 0x02A9
    1a06:	30 91 aa 02 	lds	r19, 0x02AA
    1a0a:	40 91 ab 02 	lds	r20, 0x02AB
    1a0e:	50 91 ac 02 	lds	r21, 0x02AC

	DataflashInfo.CurrPageAddress = 0;
    1a12:	10 92 44 01 	sts	0x0144, r1
    1a16:	10 92 43 01 	sts	0x0143, r1

	while (StartAddress > DataflashInfo.PageSize)      // This loop is the equivalent of a DIV and a MOD
    1a1a:	80 91 3f 01 	lds	r24, 0x013F
    1a1e:	90 91 40 01 	lds	r25, 0x0140
    1a22:	aa 27       	eor	r26, r26
    1a24:	bb 27       	eor	r27, r27
    1a26:	60 e0       	ldi	r22, 0x00	; 0
    1a28:	70 e0       	ldi	r23, 0x00	; 0
    1a2a:	ee 24       	eor	r14, r14
    1a2c:	ff 24       	eor	r15, r15
    1a2e:	87 01       	movw	r16, r14
    1a30:	e8 1a       	sub	r14, r24
    1a32:	f9 0a       	sbc	r15, r25
    1a34:	0a 0b       	sbc	r16, r26
    1a36:	1b 0b       	sbc	r17, r27
    1a38:	06 c0       	rjmp	.+12     	; 0x1a46 <PD_SetupDFAddressCounters+0x4c>
    1a3a:	2e 0d       	add	r18, r14
    1a3c:	3f 1d       	adc	r19, r15
    1a3e:	40 1f       	adc	r20, r16
    1a40:	51 1f       	adc	r21, r17
    1a42:	6f 5f       	subi	r22, 0xFF	; 255
    1a44:	7f 4f       	sbci	r23, 0xFF	; 255
    1a46:	82 17       	cp	r24, r18
    1a48:	93 07       	cpc	r25, r19
    1a4a:	a4 07       	cpc	r26, r20
    1a4c:	b5 07       	cpc	r27, r21
    1a4e:	a8 f3       	brcs	.-22     	; 0x1a3a <PD_SetupDFAddressCounters+0x40>
    1a50:	70 93 44 01 	sts	0x0144, r23
    1a54:	60 93 43 01 	sts	0x0143, r22
	{
		StartAddress -= DataflashInfo.PageSize;         // Subtract one page's worth of bytes from the desired address
		DataflashInfo.CurrPageAddress++;
	}
	
	DataflashInfo.CurrBuffByte = (uint16_t)StartAddress; // The buffer byte is the remainder
    1a58:	30 93 46 01 	sts	0x0146, r19
    1a5c:	20 93 45 01 	sts	0x0145, r18
    1a60:	1f 91       	pop	r17
    1a62:	0f 91       	pop	r16
    1a64:	ff 90       	pop	r15
    1a66:	ef 90       	pop	r14
    1a68:	08 95       	ret

00001a6a <PD_StoreDataflashByte>:
}

void PD_StoreDataflashByte(const uint8_t Data)
{
    1a6a:	1f 93       	push	r17
    1a6c:	18 2f       	mov	r17, r24
	if (DataflashInfo.CurrBuffByte == DataflashInfo.PageSize)
    1a6e:	20 91 45 01 	lds	r18, 0x0145
    1a72:	30 91 46 01 	lds	r19, 0x0146
    1a76:	80 91 3f 01 	lds	r24, 0x013F
    1a7a:	90 91 40 01 	lds	r25, 0x0140
    1a7e:	28 17       	cp	r18, r24
    1a80:	39 07       	cpc	r19, r25
    1a82:	a1 f4       	brne	.+40     	; 0x1aac <PD_StoreDataflashByte+0x42>
	{
		DF_CopyBufferToFlashPage(DataflashInfo.CurrPageAddress++);
    1a84:	80 91 43 01 	lds	r24, 0x0143
    1a88:	90 91 44 01 	lds	r25, 0x0144
    1a8c:	01 96       	adiw	r24, 0x01	; 1
    1a8e:	90 93 44 01 	sts	0x0144, r25
    1a92:	80 93 43 01 	sts	0x0143, r24
    1a96:	01 97       	sbiw	r24, 0x01	; 1
    1a98:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <DF_CopyBufferToFlashPage>
		DF_BufferWriteEnable(0);
    1a9c:	80 e0       	ldi	r24, 0x00	; 0
    1a9e:	90 e0       	ldi	r25, 0x00	; 0
    1aa0:	0e 94 ca 0a 	call	0x1594	; 0x1594 <DF_BufferWriteEnable>
		DataflashInfo.CurrBuffByte = 0;
    1aa4:	10 92 46 01 	sts	0x0146, r1
    1aa8:	10 92 45 01 	sts	0x0145, r1
	}
	
	USI_SPITransmit(Data);                                 // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
    1aac:	81 2f       	mov	r24, r17
    1aae:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
	DataflashInfo.CurrBuffByte++;
    1ab2:	80 91 45 01 	lds	r24, 0x0145
    1ab6:	90 91 46 01 	lds	r25, 0x0146
    1aba:	01 96       	adiw	r24, 0x01	; 1
    1abc:	90 93 46 01 	sts	0x0146, r25
    1ac0:	80 93 45 01 	sts	0x0145, r24
    1ac4:	1f 91       	pop	r17
    1ac6:	08 95       	ret

00001ac8 <PD_InterpretAVRISPPacket>:
    1ac8:	0f 93       	push	r16
    1aca:	1f 93       	push	r17
    1acc:	cf 93       	push	r28
    1ace:	df 93       	push	r29
    1ad0:	80 91 91 01 	lds	r24, 0x0191
    1ad4:	86 31       	cpi	r24, 0x16	; 22
    1ad6:	09 f4       	brne	.+2      	; 0x1ada <PD_InterpretAVRISPPacket+0x12>
    1ad8:	f1 c0       	rjmp	.+482    	; 0x1cbc <PD_InterpretAVRISPPacket+0x1f4>
    1ada:	87 31       	cpi	r24, 0x17	; 23
    1adc:	90 f4       	brcc	.+36     	; 0x1b02 <PD_InterpretAVRISPPacket+0x3a>
    1ade:	82 31       	cpi	r24, 0x12	; 18
    1ae0:	09 f4       	brne	.+2      	; 0x1ae4 <PD_InterpretAVRISPPacket+0x1c>
    1ae2:	65 c0       	rjmp	.+202    	; 0x1bae <PD_InterpretAVRISPPacket+0xe6>
    1ae4:	83 31       	cpi	r24, 0x13	; 19
    1ae6:	30 f4       	brcc	.+12     	; 0x1af4 <PD_InterpretAVRISPPacket+0x2c>
    1ae8:	80 31       	cpi	r24, 0x10	; 16
    1aea:	01 f1       	breq	.+64     	; 0x1b2c <PD_InterpretAVRISPPacket+0x64>
    1aec:	81 31       	cpi	r24, 0x11	; 17
    1aee:	09 f0       	breq	.+2      	; 0x1af2 <PD_InterpretAVRISPPacket+0x2a>
    1af0:	2f c1       	rjmp	.+606    	; 0x1d50 <PD_InterpretAVRISPPacket+0x288>
    1af2:	41 c0       	rjmp	.+130    	; 0x1b76 <PD_InterpretAVRISPPacket+0xae>
    1af4:	84 31       	cpi	r24, 0x14	; 20
    1af6:	09 f4       	brne	.+2      	; 0x1afa <PD_InterpretAVRISPPacket+0x32>
    1af8:	8b c0       	rjmp	.+278    	; 0x1c10 <PD_InterpretAVRISPPacket+0x148>
    1afa:	85 31       	cpi	r24, 0x15	; 21
    1afc:	08 f0       	brcs	.+2      	; 0x1b00 <PD_InterpretAVRISPPacket+0x38>
    1afe:	ab c0       	rjmp	.+342    	; 0x1c56 <PD_InterpretAVRISPPacket+0x18e>
    1b00:	80 c0       	rjmp	.+256    	; 0x1c02 <PD_InterpretAVRISPPacket+0x13a>
    1b02:	89 31       	cpi	r24, 0x19	; 25
    1b04:	09 f4       	brne	.+2      	; 0x1b08 <PD_InterpretAVRISPPacket+0x40>
    1b06:	72 c0       	rjmp	.+228    	; 0x1bec <PD_InterpretAVRISPPacket+0x124>
    1b08:	8a 31       	cpi	r24, 0x1A	; 26
    1b0a:	38 f4       	brcc	.+14     	; 0x1b1a <PD_InterpretAVRISPPacket+0x52>
    1b0c:	87 31       	cpi	r24, 0x17	; 23
    1b0e:	09 f4       	brne	.+2      	; 0x1b12 <PD_InterpretAVRISPPacket+0x4a>
    1b10:	6d c0       	rjmp	.+218    	; 0x1bec <PD_InterpretAVRISPPacket+0x124>
    1b12:	88 31       	cpi	r24, 0x18	; 24
    1b14:	09 f0       	breq	.+2      	; 0x1b18 <PD_InterpretAVRISPPacket+0x50>
    1b16:	1c c1       	rjmp	.+568    	; 0x1d50 <PD_InterpretAVRISPPacket+0x288>
    1b18:	5b c0       	rjmp	.+182    	; 0x1bd0 <PD_InterpretAVRISPPacket+0x108>
    1b1a:	8b 31       	cpi	r24, 0x1B	; 27
    1b1c:	f1 f1       	breq	.+124    	; 0x1b9a <PD_InterpretAVRISPPacket+0xd2>
    1b1e:	8b 31       	cpi	r24, 0x1B	; 27
    1b20:	08 f4       	brcc	.+2      	; 0x1b24 <PD_InterpretAVRISPPacket+0x5c>
    1b22:	56 c0       	rjmp	.+172    	; 0x1bd0 <PD_InterpretAVRISPPacket+0x108>
    1b24:	8c 31       	cpi	r24, 0x1C	; 28
    1b26:	09 f0       	breq	.+2      	; 0x1b2a <PD_InterpretAVRISPPacket+0x62>
    1b28:	13 c1       	rjmp	.+550    	; 0x1d50 <PD_InterpretAVRISPPacket+0x288>
    1b2a:	52 c0       	rjmp	.+164    	; 0x1bd0 <PD_InterpretAVRISPPacket+0x108>
    1b2c:	82 e0       	ldi	r24, 0x02	; 2
    1b2e:	90 e0       	ldi	r25, 0x00	; 0
    1b30:	90 93 a7 02 	sts	0x02A7, r25
    1b34:	80 93 a6 02 	sts	0x02A6, r24
    1b38:	81 e0       	ldi	r24, 0x01	; 1
    1b3a:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    1b3e:	0e 94 83 0b 	call	0x1706	; 0x1706 <DF_GetChipCharacteristics>
    1b42:	80 91 3d 01 	lds	r24, 0x013D
    1b46:	90 91 3e 01 	lds	r25, 0x013E
    1b4a:	89 2b       	or	r24, r25
    1b4c:	59 f0       	breq	.+22     	; 0x1b64 <PD_InterpretAVRISPPacket+0x9c>
    1b4e:	89 ef       	ldi	r24, 0xF9	; 249
    1b50:	93 e0       	ldi	r25, 0x03	; 3
    1b52:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
    1b56:	81 e0       	ldi	r24, 0x01	; 1
    1b58:	80 93 a8 02 	sts	0x02A8, r24
    1b5c:	81 b3       	in	r24, 0x11	; 17
    1b5e:	8f 7c       	andi	r24, 0xCF	; 207
    1b60:	80 62       	ori	r24, 0x20	; 32
    1b62:	17 c0       	rjmp	.+46     	; 0x1b92 <PD_InterpretAVRISPPacket+0xca>
    1b64:	88 ec       	ldi	r24, 0xC8	; 200
    1b66:	93 e0       	ldi	r25, 0x03	; 3
    1b68:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
    1b6c:	80 e0       	ldi	r24, 0x00	; 0
    1b6e:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    1b72:	80 ec       	ldi	r24, 0xC0	; 192
    1b74:	f4 c0       	rjmp	.+488    	; 0x1d5e <PD_InterpretAVRISPPacket+0x296>
    1b76:	82 e0       	ldi	r24, 0x02	; 2
    1b78:	90 e0       	ldi	r25, 0x00	; 0
    1b7a:	90 93 a7 02 	sts	0x02A7, r25
    1b7e:	80 93 a6 02 	sts	0x02A6, r24
    1b82:	10 92 a8 02 	sts	0x02A8, r1
    1b86:	80 e0       	ldi	r24, 0x00	; 0
    1b88:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    1b8c:	81 b3       	in	r24, 0x11	; 17
    1b8e:	8f 7c       	andi	r24, 0xCF	; 207
    1b90:	80 61       	ori	r24, 0x10	; 16
    1b92:	81 bb       	out	0x11, r24	; 17
    1b94:	10 92 92 01 	sts	0x0192, r1
    1b98:	e4 c0       	rjmp	.+456    	; 0x1d62 <PD_InterpretAVRISPPacket+0x29a>
    1b9a:	84 e0       	ldi	r24, 0x04	; 4
    1b9c:	90 e0       	ldi	r25, 0x00	; 0
    1b9e:	90 93 a7 02 	sts	0x02A7, r25
    1ba2:	80 93 a6 02 	sts	0x02A6, r24
    1ba6:	10 92 92 01 	sts	0x0192, r1
    1baa:	82 e0       	ldi	r24, 0x02	; 2
    1bac:	1a c0       	rjmp	.+52     	; 0x1be2 <PD_InterpretAVRISPPacket+0x11a>
    1bae:	82 e0       	ldi	r24, 0x02	; 2
    1bb0:	90 e0       	ldi	r25, 0x00	; 0
    1bb2:	90 93 a7 02 	sts	0x02A7, r25
    1bb6:	80 93 a6 02 	sts	0x02A6, r24
    1bba:	10 92 92 01 	sts	0x0192, r1
    1bbe:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <V2P_SendPacket>
    1bc2:	87 ea       	ldi	r24, 0xA7	; 167
    1bc4:	90 e0       	ldi	r25, 0x00	; 0
    1bc6:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
    1bca:	c0 e0       	ldi	r28, 0x00	; 0
    1bcc:	d0 e0       	ldi	r29, 0x00	; 0
    1bce:	d0 c0       	rjmp	.+416    	; 0x1d70 <PD_InterpretAVRISPPacket+0x2a8>
    1bd0:	84 e0       	ldi	r24, 0x04	; 4
    1bd2:	90 e0       	ldi	r25, 0x00	; 0
    1bd4:	90 93 a7 02 	sts	0x02A7, r25
    1bd8:	80 93 a6 02 	sts	0x02A6, r24
    1bdc:	10 92 92 01 	sts	0x0192, r1
    1be0:	8f ef       	ldi	r24, 0xFF	; 255
    1be2:	80 93 93 01 	sts	0x0193, r24
    1be6:	10 92 94 01 	sts	0x0194, r1
    1bea:	bb c0       	rjmp	.+374    	; 0x1d62 <PD_InterpretAVRISPPacket+0x29a>
    1bec:	83 e0       	ldi	r24, 0x03	; 3
    1bee:	90 e0       	ldi	r25, 0x00	; 0
    1bf0:	90 93 a7 02 	sts	0x02A7, r25
    1bf4:	80 93 a6 02 	sts	0x02A6, r24
    1bf8:	10 92 92 01 	sts	0x0192, r1
    1bfc:	10 92 93 01 	sts	0x0193, r1
    1c00:	b0 c0       	rjmp	.+352    	; 0x1d62 <PD_InterpretAVRISPPacket+0x29a>
    1c02:	82 e0       	ldi	r24, 0x02	; 2
    1c04:	90 e0       	ldi	r25, 0x00	; 0
    1c06:	90 93 a7 02 	sts	0x02A7, r25
    1c0a:	80 93 a6 02 	sts	0x02A6, r24
    1c0e:	c2 cf       	rjmp	.-124    	; 0x1b94 <PD_InterpretAVRISPPacket+0xcc>
    1c10:	20 91 92 01 	lds	r18, 0x0192
    1c14:	33 27       	eor	r19, r19
    1c16:	32 2f       	mov	r19, r18
    1c18:	22 27       	eor	r18, r18
    1c1a:	80 91 93 01 	lds	r24, 0x0193
    1c1e:	99 27       	eor	r25, r25
    1c20:	28 2b       	or	r18, r24
    1c22:	39 2b       	or	r19, r25
    1c24:	f9 01       	movw	r30, r18
    1c26:	33 96       	adiw	r30, 0x03	; 3
    1c28:	f0 93 a7 02 	sts	0x02A7, r31
    1c2c:	e0 93 a6 02 	sts	0x02A6, r30
    1c30:	81 e0       	ldi	r24, 0x01	; 1
    1c32:	90 e0       	ldi	r25, 0x00	; 0
    1c34:	a2 e9       	ldi	r26, 0x92	; 146
    1c36:	b1 e0       	ldi	r27, 0x01	; 1
    1c38:	2f 5f       	subi	r18, 0xFF	; 255
    1c3a:	3f 4f       	sbci	r19, 0xFF	; 255
    1c3c:	4f ef       	ldi	r20, 0xFF	; 255
    1c3e:	02 c0       	rjmp	.+4      	; 0x1c44 <PD_InterpretAVRISPPacket+0x17c>
    1c40:	4d 93       	st	X+, r20
    1c42:	01 96       	adiw	r24, 0x01	; 1
    1c44:	82 17       	cp	r24, r18
    1c46:	93 07       	cpc	r25, r19
    1c48:	d8 f3       	brcs	.-10     	; 0x1c40 <PD_InterpretAVRISPPacket+0x178>
    1c4a:	10 92 92 01 	sts	0x0192, r1
    1c4e:	e0 57       	subi	r30, 0x70	; 112
    1c50:	fe 4f       	sbci	r31, 0xFE	; 254
    1c52:	10 82       	st	Z, r1
    1c54:	86 c0       	rjmp	.+268    	; 0x1d62 <PD_InterpretAVRISPPacket+0x29a>
    1c56:	0e 94 fd 0c 	call	0x19fa	; 0x19fa <PD_SetupDFAddressCounters>
    1c5a:	80 91 43 01 	lds	r24, 0x0143
    1c5e:	90 91 44 01 	lds	r25, 0x0144
    1c62:	0e 94 25 0b 	call	0x164a	; 0x164a <DF_CopyFlashPageToBuffer>
    1c66:	80 91 45 01 	lds	r24, 0x0145
    1c6a:	90 91 46 01 	lds	r25, 0x0146
    1c6e:	0e 94 ca 0a 	call	0x1594	; 0x1594 <DF_BufferWriteEnable>
    1c72:	80 91 92 01 	lds	r24, 0x0192
    1c76:	99 27       	eor	r25, r25
    1c78:	d8 2f       	mov	r29, r24
    1c7a:	cc 27       	eor	r28, r28
    1c7c:	80 91 93 01 	lds	r24, 0x0193
    1c80:	99 27       	eor	r25, r25
    1c82:	c8 2b       	or	r28, r24
    1c84:	d9 2b       	or	r29, r25
    1c86:	01 e9       	ldi	r16, 0x91	; 145
    1c88:	11 e0       	ldi	r17, 0x01	; 1
    1c8a:	11 c0       	rjmp	.+34     	; 0x1cae <PD_InterpretAVRISPPacket+0x1e6>
    1c8c:	f8 01       	movw	r30, r16
    1c8e:	82 85       	ldd	r24, Z+10	; 0x0a
    1c90:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <PD_StoreDataflashByte>
    1c94:	80 91 45 01 	lds	r24, 0x0145
    1c98:	90 91 46 01 	lds	r25, 0x0146
    1c9c:	01 96       	adiw	r24, 0x01	; 1
    1c9e:	90 93 46 01 	sts	0x0146, r25
    1ca2:	80 93 45 01 	sts	0x0145, r24
    1ca6:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <V2P_IncrementCurrAddress>
    1caa:	0f 5f       	subi	r16, 0xFF	; 255
    1cac:	1f 4f       	sbci	r17, 0xFF	; 255
    1cae:	ce 01       	movw	r24, r28
    1cb0:	8f 56       	subi	r24, 0x6F	; 111
    1cb2:	9e 4f       	sbci	r25, 0xFE	; 254
    1cb4:	08 17       	cp	r16, r24
    1cb6:	19 07       	cpc	r17, r25
    1cb8:	49 f7       	brne	.-46     	; 0x1c8c <PD_InterpretAVRISPPacket+0x1c4>
    1cba:	6c cf       	rjmp	.-296    	; 0x1b94 <PD_InterpretAVRISPPacket+0xcc>
    1cbc:	0e 94 fd 0c 	call	0x19fa	; 0x19fa <PD_SetupDFAddressCounters>
    1cc0:	80 91 43 01 	lds	r24, 0x0143
    1cc4:	90 91 44 01 	lds	r25, 0x0144
    1cc8:	0e 94 25 0b 	call	0x164a	; 0x164a <DF_CopyFlashPageToBuffer>
    1ccc:	80 91 92 01 	lds	r24, 0x0192
    1cd0:	99 27       	eor	r25, r25
    1cd2:	d8 2f       	mov	r29, r24
    1cd4:	cc 27       	eor	r28, r28
    1cd6:	80 91 93 01 	lds	r24, 0x0193
    1cda:	99 27       	eor	r25, r25
    1cdc:	c8 2b       	or	r28, r24
    1cde:	d9 2b       	or	r29, r25
    1ce0:	01 e9       	ldi	r16, 0x91	; 145
    1ce2:	11 e0       	ldi	r17, 0x01	; 1
    1ce4:	25 c0       	rjmp	.+74     	; 0x1d30 <PD_InterpretAVRISPPacket+0x268>
    1ce6:	20 91 45 01 	lds	r18, 0x0145
    1cea:	30 91 46 01 	lds	r19, 0x0146
    1cee:	80 91 3f 01 	lds	r24, 0x013F
    1cf2:	90 91 40 01 	lds	r25, 0x0140
    1cf6:	28 17       	cp	r18, r24
    1cf8:	39 07       	cpc	r19, r25
    1cfa:	41 f4       	brne	.+16     	; 0x1d0c <PD_InterpretAVRISPPacket+0x244>
    1cfc:	0e 94 fd 0c 	call	0x19fa	; 0x19fa <PD_SetupDFAddressCounters>
    1d00:	80 91 43 01 	lds	r24, 0x0143
    1d04:	90 91 44 01 	lds	r25, 0x0144
    1d08:	0e 94 25 0b 	call	0x164a	; 0x164a <DF_CopyFlashPageToBuffer>
    1d0c:	80 91 45 01 	lds	r24, 0x0145
    1d10:	90 91 46 01 	lds	r25, 0x0146
    1d14:	01 96       	adiw	r24, 0x01	; 1
    1d16:	90 93 46 01 	sts	0x0146, r25
    1d1a:	80 93 45 01 	sts	0x0145, r24
    1d1e:	01 97       	sbiw	r24, 0x01	; 1
    1d20:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <DF_ReadBufferByte>
    1d24:	f8 01       	movw	r30, r16
    1d26:	82 83       	std	Z+2, r24	; 0x02
    1d28:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <V2P_IncrementCurrAddress>
    1d2c:	0f 5f       	subi	r16, 0xFF	; 255
    1d2e:	1f 4f       	sbci	r17, 0xFF	; 255
    1d30:	ce 01       	movw	r24, r28
    1d32:	8f 56       	subi	r24, 0x6F	; 111
    1d34:	9e 4f       	sbci	r25, 0xFE	; 254
    1d36:	08 17       	cp	r16, r24
    1d38:	19 07       	cpc	r17, r25
    1d3a:	a9 f6       	brne	.-86     	; 0x1ce6 <PD_InterpretAVRISPPacket+0x21e>
    1d3c:	23 96       	adiw	r28, 0x03	; 3
    1d3e:	d0 93 a7 02 	sts	0x02A7, r29
    1d42:	c0 93 a6 02 	sts	0x02A6, r28
    1d46:	10 92 92 01 	sts	0x0192, r1
    1d4a:	f8 01       	movw	r30, r16
    1d4c:	12 82       	std	Z+2, r1	; 0x02
    1d4e:	09 c0       	rjmp	.+18     	; 0x1d62 <PD_InterpretAVRISPPacket+0x29a>
    1d50:	81 e0       	ldi	r24, 0x01	; 1
    1d52:	90 e0       	ldi	r25, 0x00	; 0
    1d54:	90 93 a7 02 	sts	0x02A7, r25
    1d58:	80 93 a6 02 	sts	0x02A6, r24
    1d5c:	89 ec       	ldi	r24, 0xC9	; 201
    1d5e:	80 93 92 01 	sts	0x0192, r24
    1d62:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <V2P_SendPacket>
    1d66:	14 c0       	rjmp	.+40     	; 0x1d90 <PD_InterpretAVRISPPacket+0x2c8>
    1d68:	ce 01       	movw	r24, r28
    1d6a:	0e 94 02 0b 	call	0x1604	; 0x1604 <DF_EraseBlock>
    1d6e:	21 96       	adiw	r28, 0x01	; 1
    1d70:	80 91 41 01 	lds	r24, 0x0141
    1d74:	90 91 42 01 	lds	r25, 0x0142
    1d78:	23 e0       	ldi	r18, 0x03	; 3
    1d7a:	96 95       	lsr	r25
    1d7c:	87 95       	ror	r24
    1d7e:	2a 95       	dec	r18
    1d80:	e1 f7       	brne	.-8      	; 0x1d7a <PD_InterpretAVRISPPacket+0x2b2>
    1d82:	c8 17       	cp	r28, r24
    1d84:	d9 07       	cpc	r29, r25
    1d86:	80 f3       	brcs	.-32     	; 0x1d68 <PD_InterpretAVRISPPacket+0x2a0>
    1d88:	89 ef       	ldi	r24, 0xF9	; 249
    1d8a:	93 e0       	ldi	r25, 0x03	; 3
    1d8c:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
    1d90:	df 91       	pop	r29
    1d92:	cf 91       	pop	r28
    1d94:	1f 91       	pop	r17
    1d96:	0f 91       	pop	r16
    1d98:	08 95       	ret

00001d9a <V2P_GetChecksum>:
	SequenceNum++;
}

uint8_t V2P_GetChecksum()
{
    1d9a:	90 91 a4 02 	lds	r25, 0x02A4
    1d9e:	8b e1       	ldi	r24, 0x1B	; 27
    1da0:	98 27       	eor	r25, r24
	uint8_t CheckSumByte;
	
	/* Checksum for the V2 protocol is comprised of an XOR of all the packet 
      bytes, including the start, sequence number, size and token bytes.    */
	
	CheckSumByte  = AICB_MESSAGE_START;
	CheckSumByte ^= SequenceNum;
	CheckSumByte ^= (uint8_t)(MessageSize >> 8);
    1da2:	40 91 a6 02 	lds	r20, 0x02A6
    1da6:	50 91 a7 02 	lds	r21, 0x02A7
    1daa:	94 27       	eor	r25, r20
	CheckSumByte ^= (uint8_t)(MessageSize & 0xFF);
    1dac:	25 2f       	mov	r18, r21
    1dae:	33 27       	eor	r19, r19
    1db0:	8e e0       	ldi	r24, 0x0E	; 14
    1db2:	82 27       	eor	r24, r18
	CheckSumByte ^= AICB_TOKEN;
    1db4:	98 27       	eor	r25, r24
    1db6:	20 e0       	ldi	r18, 0x00	; 0
    1db8:	30 e0       	ldi	r19, 0x00	; 0
    1dba:	e1 e9       	ldi	r30, 0x91	; 145
    1dbc:	f1 e0       	ldi	r31, 0x01	; 1
    1dbe:	04 c0       	rjmp	.+8      	; 0x1dc8 <V2P_GetChecksum+0x2e>
	
	for (uint16_t CByteIndex = 0; CByteIndex < MessageSize; CByteIndex++)
	   CheckSumByte ^= PacketBytes[CByteIndex];
    1dc0:	81 91       	ld	r24, Z+
    1dc2:	98 27       	eor	r25, r24
    1dc4:	2f 5f       	subi	r18, 0xFF	; 255
    1dc6:	3f 4f       	sbci	r19, 0xFF	; 255
    1dc8:	24 17       	cp	r18, r20
    1dca:	35 07       	cpc	r19, r21
    1dcc:	c9 f7       	brne	.-14     	; 0x1dc0 <V2P_GetChecksum+0x26>

	return CheckSumByte;
}
    1dce:	89 2f       	mov	r24, r25
    1dd0:	99 27       	eor	r25, r25
    1dd2:	08 95       	ret

00001dd4 <V2P_IncrementCurrAddress>:

void V2P_GetSetParamater(void)
{
	uint8_t Param_Name = PacketBytes[1];    // Save the parameter number

	MessageSize = 3;                        // Set the default response message size to 3 bytes     
	PacketBytes[1] = AICB_STATUS_CMD_OK;    // Set the default response to OK

	switch (Param_Name)                     // Switch based on the recieved parameter byte
	{
		case AICB_PARAM_BUILD_NUMBER_LOW:
			PacketBytes[2] = VERSION_MINOR;

			break;
		case AICB_PARAM_BUILD_NUMBER_HIGH:
			PacketBytes[2] = VERSION_MAJOR;

			break;
		case AICB_PARAM_HARDWARE_VERSION:
			PacketBytes[2] = V2P_HW_VERSION;

			break;
		case AICB_PARAM_SW_MAJOR:
			PacketBytes[2] = V2P_SW_VERSION_MAJOR;

			break;
		case AICB_PARAM_SW_MINOR:
			PacketBytes[2] = ((eeprom_read_byte(&EEPROMVars.FirmVerMinor) == 0xFF)? V2P_SW_VERSION_MINOR_DEFAULT : eeprom_read_byte(&EEPROMVars.FirmVerMinor));

			break;
		case AICB_PARAM_CONTROLLER_INIT:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = Param_ControllerInit;
			}
			else
			{
				MessageSize = 2;
				Param_ControllerInit = PacketBytes[2];
			}
			
			break;
		case AICB_PARAM_SCK_DURATION:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.SCKDuration);
			}
			else
			{
				MessageSize = 2;
				eeprom_write_byte(&EEPROMVars.SCKDuration, PacketBytes[2]);
				USI_SPISetSpeed();          // Re-Initialise the USI system with the new frequency
			}
					
			break;
		case AICB_PARAM_RESET_POLARITY:
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			{
				PacketBytes[2] = eeprom_read_byte(&EEPROMVars.ResetPolarity);		
			}
			else
			{
				MessageSize = 2;
				eeprom_write_byte(&EEPROMVars.ResetPolarity, PacketBytes[2]);
				MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Change takes effect immediatly
			}
			
			break;
		case AICB_PARAM_OSC_PSCALE:
		case AICB_PARAM_OSC_CMATCH:
			/* Despite not supporting these parameters (STK500 only), the AVR Studio programmer
			   sends them along with the SCK duration. A OK must be returned or the sequence will fail
			   and the SCK duration byte will not be sent.                                             */
		
			if (PacketBytes[0] == AICB_CMD_GET_PARAMETER)
			  PacketBytes[2] = 0;             // If the command is a read, return a 0 for both parameters
			else
			  MessageSize = 2;                // Otherwise just send back an OK if the command is a set		
			
			break;
		default:                             // Unrecognised parameter
			MessageSize = 2;
			PacketBytes[1] = AICB_STATUS_CMD_FAILED;			
	}
	
	V2P_SendPacket();
}

void V2P_IncrementCurrAddress(void)
{
    1dd4:	80 91 a9 02 	lds	r24, 0x02A9
    1dd8:	90 91 aa 02 	lds	r25, 0x02AA
    1ddc:	a0 91 ab 02 	lds	r26, 0x02AB
    1de0:	b0 91 ac 02 	lds	r27, 0x02AC
    1de4:	01 96       	adiw	r24, 0x01	; 1
    1de6:	a1 1d       	adc	r26, r1
    1de8:	b1 1d       	adc	r27, r1
    1dea:	80 93 a9 02 	sts	0x02A9, r24
    1dee:	90 93 aa 02 	sts	0x02AA, r25
    1df2:	a0 93 ab 02 	sts	0x02AB, r26
    1df6:	b0 93 ac 02 	sts	0x02AC, r27
    1dfa:	08 95       	ret

00001dfc <V2P_CheckForExtendedAddress>:
	// Incrementing a 32-bit unsigned variable takes a lot of code. Because much of the code is
	// not very time critical (much of it is waiting for the hardware), i've chosen to waste
	// a few extra cycles per increment and save a good 60 bytes or so of code space by putting
	// the incrmement inside a function.

	CurrAddress++;
}

void V2P_CheckForExtendedAddress(void)
{
    1dfc:	80 91 a9 02 	lds	r24, 0x02A9
    1e00:	90 91 aa 02 	lds	r25, 0x02AA
    1e04:	a0 91 ab 02 	lds	r26, 0x02AB
    1e08:	b0 91 ac 02 	lds	r27, 0x02AC
    1e0c:	b7 ff       	sbrs	r27, 7
    1e0e:	1e c0       	rjmp	.+60     	; 0x1e4c <V2P_CheckForExtendedAddress+0x50>
	if (CurrAddress & V2P_LOAD_EXTENDED_ADDR_FLAG)     // MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
	{
		USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);   // Load extended address command
    1e10:	8d e4       	ldi	r24, 0x4D	; 77
    1e12:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1e16:	80 e0       	ldi	r24, 0x00	; 0
    1e18:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
		USI_SPITransmit((CurrAddress & V2P_LOAD_EXTENDED_ADDR_MASK) >> V2P_LOAD_EXTENDED_ADDR_SHIFT);
    1e1c:	80 91 ab 02 	lds	r24, 0x02AB
    1e20:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
		USI_SPITransmit(0x00);
    1e24:	80 e0       	ldi	r24, 0x00	; 0
    1e26:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
		
		CurrAddress &= ~(V2P_LOAD_EXTENDED_ADDR_FLAG); // Clear the flag
    1e2a:	80 91 a9 02 	lds	r24, 0x02A9
    1e2e:	90 91 aa 02 	lds	r25, 0x02AA
    1e32:	a0 91 ab 02 	lds	r26, 0x02AB
    1e36:	b0 91 ac 02 	lds	r27, 0x02AC
    1e3a:	bf 77       	andi	r27, 0x7F	; 127
    1e3c:	80 93 a9 02 	sts	0x02A9, r24
    1e40:	90 93 aa 02 	sts	0x02AA, r25
    1e44:	a0 93 ab 02 	sts	0x02AB, r26
    1e48:	b0 93 ac 02 	sts	0x02AC, r27
    1e4c:	08 95       	ret

00001e4e <V2P_SendPacket>:
    1e4e:	0f 93       	push	r16
    1e50:	1f 93       	push	r17
    1e52:	cf 93       	push	r28
    1e54:	df 93       	push	r29
    1e56:	8b e1       	ldi	r24, 0x1B	; 27
    1e58:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e5c:	80 91 a4 02 	lds	r24, 0x02A4
    1e60:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e64:	80 91 a7 02 	lds	r24, 0x02A7
    1e68:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e6c:	80 91 a6 02 	lds	r24, 0x02A6
    1e70:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e74:	8e e0       	ldi	r24, 0x0E	; 14
    1e76:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e7a:	c0 e0       	ldi	r28, 0x00	; 0
    1e7c:	d0 e0       	ldi	r29, 0x00	; 0
    1e7e:	01 e9       	ldi	r16, 0x91	; 145
    1e80:	11 e0       	ldi	r17, 0x01	; 1
    1e82:	06 c0       	rjmp	.+12     	; 0x1e90 <V2P_SendPacket+0x42>
    1e84:	f8 01       	movw	r30, r16
    1e86:	81 91       	ld	r24, Z+
    1e88:	8f 01       	movw	r16, r30
    1e8a:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1e8e:	21 96       	adiw	r28, 0x01	; 1
    1e90:	80 91 a6 02 	lds	r24, 0x02A6
    1e94:	90 91 a7 02 	lds	r25, 0x02A7
    1e98:	c8 17       	cp	r28, r24
    1e9a:	d9 07       	cpc	r29, r25
    1e9c:	98 f3       	brcs	.-26     	; 0x1e84 <V2P_SendPacket+0x36>
    1e9e:	0e 94 cd 0e 	call	0x1d9a	; 0x1d9a <V2P_GetChecksum>
    1ea2:	0e 94 82 09 	call	0x1304	; 0x1304 <USART_Tx>
    1ea6:	80 91 a4 02 	lds	r24, 0x02A4
    1eaa:	90 91 a5 02 	lds	r25, 0x02A5
    1eae:	01 96       	adiw	r24, 0x01	; 1
    1eb0:	90 93 a5 02 	sts	0x02A5, r25
    1eb4:	80 93 a4 02 	sts	0x02A4, r24
    1eb8:	df 91       	pop	r29
    1eba:	cf 91       	pop	r28
    1ebc:	1f 91       	pop	r17
    1ebe:	0f 91       	pop	r16
    1ec0:	08 95       	ret

00001ec2 <V2P_GetSetParamater>:
    1ec2:	20 91 92 01 	lds	r18, 0x0192
    1ec6:	83 e0       	ldi	r24, 0x03	; 3
    1ec8:	90 e0       	ldi	r25, 0x00	; 0
    1eca:	90 93 a7 02 	sts	0x02A7, r25
    1ece:	80 93 a6 02 	sts	0x02A6, r24
    1ed2:	10 92 92 01 	sts	0x0192, r1
    1ed6:	22 39       	cpi	r18, 0x92	; 146
    1ed8:	21 f1       	breq	.+72     	; 0x1f22 <V2P_GetSetParamater+0x60>
    1eda:	23 39       	cpi	r18, 0x93	; 147
    1edc:	70 f4       	brcc	.+28     	; 0x1efa <V2P_GetSetParamater+0x38>
    1ede:	21 38       	cpi	r18, 0x81	; 129
    1ee0:	d1 f0       	breq	.+52     	; 0x1f16 <V2P_GetSetParamater+0x54>
    1ee2:	22 38       	cpi	r18, 0x82	; 130
    1ee4:	20 f4       	brcc	.+8      	; 0x1eee <V2P_GetSetParamater+0x2c>
    1ee6:	20 38       	cpi	r18, 0x80	; 128
    1ee8:	09 f0       	breq	.+2      	; 0x1eec <V2P_GetSetParamater+0x2a>
    1eea:	74 c0       	rjmp	.+232    	; 0x1fd4 <V2P_GetSetParamater+0x112>
    1eec:	22 c0       	rjmp	.+68     	; 0x1f32 <V2P_GetSetParamater+0x70>
    1eee:	20 39       	cpi	r18, 0x90	; 144
    1ef0:	b1 f0       	breq	.+44     	; 0x1f1e <V2P_GetSetParamater+0x5c>
    1ef2:	21 39       	cpi	r18, 0x91	; 145
    1ef4:	09 f0       	breq	.+2      	; 0x1ef8 <V2P_GetSetParamater+0x36>
    1ef6:	6e c0       	rjmp	.+220    	; 0x1fd4 <V2P_GetSetParamater+0x112>
    1ef8:	12 c0       	rjmp	.+36     	; 0x1f1e <V2P_GetSetParamater+0x5c>
    1efa:	28 39       	cpi	r18, 0x98	; 152
    1efc:	81 f1       	breq	.+96     	; 0x1f5e <V2P_GetSetParamater+0x9c>
    1efe:	29 39       	cpi	r18, 0x99	; 153
    1f00:	20 f4       	brcc	.+8      	; 0x1f0a <V2P_GetSetParamater+0x48>
    1f02:	26 39       	cpi	r18, 0x96	; 150
    1f04:	08 f4       	brcc	.+2      	; 0x1f08 <V2P_GetSetParamater+0x46>
    1f06:	66 c0       	rjmp	.+204    	; 0x1fd4 <V2P_GetSetParamater+0x112>
    1f08:	57 c0       	rjmp	.+174    	; 0x1fb8 <V2P_GetSetParamater+0xf6>
    1f0a:	2e 39       	cpi	r18, 0x9E	; 158
    1f0c:	e1 f1       	breq	.+120    	; 0x1f86 <V2P_GetSetParamater+0xc4>
    1f0e:	2f 39       	cpi	r18, 0x9F	; 159
    1f10:	09 f0       	breq	.+2      	; 0x1f14 <V2P_GetSetParamater+0x52>
    1f12:	60 c0       	rjmp	.+192    	; 0x1fd4 <V2P_GetSetParamater+0x112>
    1f14:	12 c0       	rjmp	.+36     	; 0x1f3a <V2P_GetSetParamater+0x78>
    1f16:	81 e0       	ldi	r24, 0x01	; 1
    1f18:	80 93 93 01 	sts	0x0193, r24
    1f1c:	64 c0       	rjmp	.+200    	; 0x1fe6 <V2P_GetSetParamater+0x124>
    1f1e:	82 e0       	ldi	r24, 0x02	; 2
    1f20:	fb cf       	rjmp	.-10     	; 0x1f18 <V2P_GetSetParamater+0x56>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1f22:	27 e8       	ldi	r18, 0x87	; 135
    1f24:	30 e0       	ldi	r19, 0x00	; 0
    1f26:	d9 01       	movw	r26, r18
    1f28:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
    1f2c:	80 2d       	mov	r24, r0
    1f2e:	8f 3f       	cpi	r24, 0xFF	; 255
    1f30:	11 f4       	brne	.+4      	; 0x1f36 <V2P_GetSetParamater+0x74>
    1f32:	84 e0       	ldi	r24, 0x04	; 4
    1f34:	f1 cf       	rjmp	.-30     	; 0x1f18 <V2P_GetSetParamater+0x56>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1f36:	d9 01       	movw	r26, r18
    1f38:	2c c0       	rjmp	.+88     	; 0x1f92 <V2P_GetSetParamater+0xd0>
    1f3a:	80 91 91 01 	lds	r24, 0x0191
    1f3e:	83 30       	cpi	r24, 0x03	; 3
    1f40:	19 f4       	brne	.+6      	; 0x1f48 <V2P_GetSetParamater+0x86>
    1f42:	80 91 ad 02 	lds	r24, 0x02AD
    1f46:	e8 cf       	rjmp	.-48     	; 0x1f18 <V2P_GetSetParamater+0x56>
    1f48:	82 e0       	ldi	r24, 0x02	; 2
    1f4a:	90 e0       	ldi	r25, 0x00	; 0
    1f4c:	90 93 a7 02 	sts	0x02A7, r25
    1f50:	80 93 a6 02 	sts	0x02A6, r24
    1f54:	80 91 93 01 	lds	r24, 0x0193
    1f58:	80 93 ad 02 	sts	0x02AD, r24
    1f5c:	44 c0       	rjmp	.+136    	; 0x1fe6 <V2P_GetSetParamater+0x124>
    1f5e:	80 91 91 01 	lds	r24, 0x0191
    1f62:	a2 e0       	ldi	r26, 0x02	; 2
    1f64:	b0 e0       	ldi	r27, 0x00	; 0
    1f66:	83 30       	cpi	r24, 0x03	; 3
    1f68:	a1 f0       	breq	.+40     	; 0x1f92 <V2P_GetSetParamater+0xd0>
    1f6a:	82 e0       	ldi	r24, 0x02	; 2
    1f6c:	90 e0       	ldi	r25, 0x00	; 0
    1f6e:	90 93 a7 02 	sts	0x02A7, r25
    1f72:	80 93 a6 02 	sts	0x02A6, r24

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    1f76:	80 91 93 01 	lds	r24, 0x0193
    1f7a:	08 2e       	mov	r0, r24
    1f7c:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
    1f80:	0e 94 11 0a 	call	0x1422	; 0x1422 <USI_SPISetSpeed>
    1f84:	30 c0       	rjmp	.+96     	; 0x1fe6 <V2P_GetSetParamater+0x124>
    1f86:	80 91 91 01 	lds	r24, 0x0191
    1f8a:	a1 e0       	ldi	r26, 0x01	; 1
    1f8c:	b0 e0       	ldi	r27, 0x00	; 0
    1f8e:	83 30       	cpi	r24, 0x03	; 3
    1f90:	21 f4       	brne	.+8      	; 0x1f9a <V2P_GetSetParamater+0xd8>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    1f92:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
    1f96:	80 2d       	mov	r24, r0
    1f98:	bf cf       	rjmp	.-130    	; 0x1f18 <V2P_GetSetParamater+0x56>
    1f9a:	82 e0       	ldi	r24, 0x02	; 2
    1f9c:	90 e0       	ldi	r25, 0x00	; 0
    1f9e:	90 93 a7 02 	sts	0x02A7, r25
    1fa2:	80 93 a6 02 	sts	0x02A6, r24

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    1fa6:	80 91 93 01 	lds	r24, 0x0193
    1faa:	08 2e       	mov	r0, r24
    1fac:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
    1fb0:	81 e0       	ldi	r24, 0x01	; 1
    1fb2:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
    1fb6:	17 c0       	rjmp	.+46     	; 0x1fe6 <V2P_GetSetParamater+0x124>
    1fb8:	80 91 91 01 	lds	r24, 0x0191
    1fbc:	83 30       	cpi	r24, 0x03	; 3
    1fbe:	19 f4       	brne	.+6      	; 0x1fc6 <V2P_GetSetParamater+0x104>
    1fc0:	10 92 93 01 	sts	0x0193, r1
    1fc4:	10 c0       	rjmp	.+32     	; 0x1fe6 <V2P_GetSetParamater+0x124>
    1fc6:	82 e0       	ldi	r24, 0x02	; 2
    1fc8:	90 e0       	ldi	r25, 0x00	; 0
    1fca:	90 93 a7 02 	sts	0x02A7, r25
    1fce:	80 93 a6 02 	sts	0x02A6, r24
    1fd2:	09 c0       	rjmp	.+18     	; 0x1fe6 <V2P_GetSetParamater+0x124>
    1fd4:	82 e0       	ldi	r24, 0x02	; 2
    1fd6:	90 e0       	ldi	r25, 0x00	; 0
    1fd8:	90 93 a7 02 	sts	0x02A7, r25
    1fdc:	80 93 a6 02 	sts	0x02A6, r24
    1fe0:	80 ec       	ldi	r24, 0xC0	; 192
    1fe2:	80 93 92 01 	sts	0x0192, r24
    1fe6:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <V2P_SendPacket>
    1fea:	08 95       	ret

00001fec <V2P_RunStateMachine>:
    1fec:	cf 92       	push	r12
    1fee:	df 92       	push	r13
    1ff0:	ef 92       	push	r14
    1ff2:	ff 92       	push	r15
    1ff4:	0f 93       	push	r16
    1ff6:	1f 93       	push	r17
    1ff8:	cf 93       	push	r28
    1ffa:	df 93       	push	r29
    1ffc:	6c 01       	movw	r12, r24
    1ffe:	0e 94 db 0b 	call	0x17b6	; 0x17b6 <BUFF_InitialiseBuffer>
    2002:	10 92 81 00 	sts	0x0081, r1
    2006:	10 92 a8 02 	sts	0x02A8, r1
    200a:	10 92 a9 02 	sts	0x02A9, r1
    200e:	10 92 aa 02 	sts	0x02AA, r1
    2012:	10 92 ab 02 	sts	0x02AB, r1
    2016:	10 92 ac 02 	sts	0x02AC, r1
    201a:	10 e0       	ldi	r17, 0x00	; 0
    201c:	73 c0       	rjmp	.+230    	; 0x2104 <V2P_RunStateMachine+0x118>
    201e:	12 e0       	ldi	r17, 0x02	; 2
    2020:	01 c0       	rjmp	.+2      	; 0x2024 <V2P_RunStateMachine+0x38>
    2022:	19 e0       	ldi	r17, 0x09	; 9
    2024:	80 91 8c 01 	lds	r24, 0x018C
    2028:	81 30       	cpi	r24, 0x01	; 1
    202a:	09 f4       	brne	.+2      	; 0x202e <V2P_RunStateMachine+0x42>
    202c:	0e c1       	rjmp	.+540    	; 0x224a <V2P_RunStateMachine+0x25e>
    202e:	11 23       	and	r17, r17
    2030:	81 f1       	breq	.+96     	; 0x2092 <V2P_RunStateMachine+0xa6>
    2032:	10 92 8c 01 	sts	0x018C, r1
    2036:	10 92 8b 01 	sts	0x018B, r1
    203a:	10 92 b2 00 	sts	0x00B2, r1
    203e:	80 ef       	ldi	r24, 0xF0	; 240
    2040:	80 93 b3 00 	sts	0x00B3, r24
    2044:	82 e0       	ldi	r24, 0x02	; 2
    2046:	80 93 70 00 	sts	0x0070, r24
    204a:	8f e0       	ldi	r24, 0x0F	; 15
    204c:	80 93 b0 00 	sts	0x00B0, r24
    2050:	15 30       	cpi	r17, 0x05	; 5
    2052:	09 f4       	brne	.+2      	; 0x2056 <V2P_RunStateMachine+0x6a>
    2054:	5a c0       	rjmp	.+180    	; 0x210a <V2P_RunStateMachine+0x11e>
    2056:	16 30       	cpi	r17, 0x06	; 6
    2058:	70 f4       	brcc	.+28     	; 0x2076 <V2P_RunStateMachine+0x8a>
    205a:	12 30       	cpi	r17, 0x02	; 2
    205c:	69 f1       	breq	.+90     	; 0x20b8 <V2P_RunStateMachine+0xcc>
    205e:	13 30       	cpi	r17, 0x03	; 3
    2060:	28 f4       	brcc	.+10     	; 0x206c <V2P_RunStateMachine+0x80>
    2062:	11 23       	and	r17, r17
    2064:	b1 f0       	breq	.+44     	; 0x2092 <V2P_RunStateMachine+0xa6>
    2066:	11 30       	cpi	r17, 0x01	; 1
    2068:	e9 f6       	brne	.-70     	; 0x2024 <V2P_RunStateMachine+0x38>
    206a:	20 c0       	rjmp	.+64     	; 0x20ac <V2P_RunStateMachine+0xc0>
    206c:	13 30       	cpi	r17, 0x03	; 3
    206e:	69 f1       	breq	.+90     	; 0x20ca <V2P_RunStateMachine+0xde>
    2070:	14 30       	cpi	r17, 0x04	; 4
    2072:	c1 f6       	brne	.-80     	; 0x2024 <V2P_RunStateMachine+0x38>
    2074:	35 c0       	rjmp	.+106    	; 0x20e0 <V2P_RunStateMachine+0xf4>
    2076:	18 30       	cpi	r17, 0x08	; 8
    2078:	09 f4       	brne	.+2      	; 0x207c <V2P_RunStateMachine+0x90>
    207a:	f4 c0       	rjmp	.+488    	; 0x2264 <V2P_RunStateMachine+0x278>
    207c:	19 30       	cpi	r17, 0x09	; 9
    207e:	30 f4       	brcc	.+12     	; 0x208c <V2P_RunStateMachine+0xa0>
    2080:	16 30       	cpi	r17, 0x06	; 6
    2082:	09 f4       	brne	.+2      	; 0x2086 <V2P_RunStateMachine+0x9a>
    2084:	49 c0       	rjmp	.+146    	; 0x2118 <V2P_RunStateMachine+0x12c>
    2086:	17 30       	cpi	r17, 0x07	; 7
    2088:	69 f6       	brne	.-102    	; 0x2024 <V2P_RunStateMachine+0x38>
    208a:	57 c0       	rjmp	.+174    	; 0x213a <V2P_RunStateMachine+0x14e>
    208c:	1c 30       	cpi	r17, 0x0C	; 12
    208e:	50 f6       	brcc	.-108    	; 0x2024 <V2P_RunStateMachine+0x38>
    2090:	d6 c0       	rjmp	.+428    	; 0x223e <V2P_RunStateMachine+0x252>
    2092:	80 91 88 01 	lds	r24, 0x0188
    2096:	81 11       	cpse	r24, r1
    2098:	81 e0       	ldi	r24, 0x01	; 1
    209a:	18 2f       	mov	r17, r24
    209c:	f2 9b       	sbis	0x1e, 2	; 30
    209e:	c2 cf       	rjmp	.-124    	; 0x2024 <V2P_RunStateMachine+0x38>
    20a0:	80 91 a8 02 	lds	r24, 0x02A8
    20a4:	88 23       	and	r24, r24
    20a6:	09 f0       	breq	.+2      	; 0x20aa <V2P_RunStateMachine+0xbe>
    20a8:	bd cf       	rjmp	.-134    	; 0x2024 <V2P_RunStateMachine+0x38>
    20aa:	e6 c0       	rjmp	.+460    	; 0x2278 <V2P_RunStateMachine+0x28c>
    20ac:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    20b0:	8b 31       	cpi	r24, 0x1B	; 27
    20b2:	09 f0       	breq	.+2      	; 0x20b6 <V2P_RunStateMachine+0xca>
    20b4:	b6 cf       	rjmp	.-148    	; 0x2022 <V2P_RunStateMachine+0x36>
    20b6:	b3 cf       	rjmp	.-154    	; 0x201e <V2P_RunStateMachine+0x32>
    20b8:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    20bc:	99 27       	eor	r25, r25
    20be:	90 93 a5 02 	sts	0x02A5, r25
    20c2:	80 93 a4 02 	sts	0x02A4, r24
    20c6:	13 e0       	ldi	r17, 0x03	; 3
    20c8:	ad cf       	rjmp	.-166    	; 0x2024 <V2P_RunStateMachine+0x38>
    20ca:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    20ce:	99 27       	eor	r25, r25
    20d0:	98 2f       	mov	r25, r24
    20d2:	88 27       	eor	r24, r24
    20d4:	90 93 a7 02 	sts	0x02A7, r25
    20d8:	80 93 a6 02 	sts	0x02A6, r24
    20dc:	14 e0       	ldi	r17, 0x04	; 4
    20de:	a2 cf       	rjmp	.-188    	; 0x2024 <V2P_RunStateMachine+0x38>
    20e0:	00 91 a6 02 	lds	r16, 0x02A6
    20e4:	10 91 a7 02 	lds	r17, 0x02A7
    20e8:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    20ec:	99 27       	eor	r25, r25
    20ee:	80 2b       	or	r24, r16
    20f0:	91 2b       	or	r25, r17
    20f2:	90 93 a7 02 	sts	0x02A7, r25
    20f6:	80 93 a6 02 	sts	0x02A6, r24
    20fa:	83 51       	subi	r24, 0x13	; 19
    20fc:	91 40       	sbci	r25, 0x01	; 1
    20fe:	08 f0       	brcs	.+2      	; 0x2102 <V2P_RunStateMachine+0x116>
    2100:	90 cf       	rjmp	.-224    	; 0x2022 <V2P_RunStateMachine+0x36>
    2102:	15 e0       	ldi	r17, 0x05	; 5
    2104:	c0 e0       	ldi	r28, 0x00	; 0
    2106:	d0 e0       	ldi	r29, 0x00	; 0
    2108:	8d cf       	rjmp	.-230    	; 0x2024 <V2P_RunStateMachine+0x38>
    210a:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    210e:	8e 30       	cpi	r24, 0x0E	; 14
    2110:	09 f0       	breq	.+2      	; 0x2114 <V2P_RunStateMachine+0x128>
    2112:	87 cf       	rjmp	.-242    	; 0x2022 <V2P_RunStateMachine+0x36>
    2114:	16 e0       	ldi	r17, 0x06	; 6
    2116:	86 cf       	rjmp	.-244    	; 0x2024 <V2P_RunStateMachine+0x38>
    2118:	80 91 a6 02 	lds	r24, 0x02A6
    211c:	90 91 a7 02 	lds	r25, 0x02A7
    2120:	c8 17       	cp	r28, r24
    2122:	d9 07       	cpc	r29, r25
    2124:	11 f4       	brne	.+4      	; 0x212a <V2P_RunStateMachine+0x13e>
    2126:	17 e0       	ldi	r17, 0x07	; 7
    2128:	7d cf       	rjmp	.-262    	; 0x2024 <V2P_RunStateMachine+0x38>
    212a:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    212e:	fe 01       	movw	r30, r28
    2130:	ef 56       	subi	r30, 0x6F	; 111
    2132:	fe 4f       	sbci	r31, 0xFE	; 254
    2134:	80 83       	st	Z, r24
    2136:	21 96       	adiw	r28, 0x01	; 1
    2138:	75 cf       	rjmp	.-278    	; 0x2024 <V2P_RunStateMachine+0x38>
    213a:	80 91 8c 01 	lds	r24, 0x018C
    213e:	88 23       	and	r24, r24
    2140:	09 f0       	breq	.+2      	; 0x2144 <V2P_RunStateMachine+0x158>
    2142:	70 cf       	rjmp	.-288    	; 0x2024 <V2P_RunStateMachine+0x38>
    2144:	0e 94 cd 0e 	call	0x1d9a	; 0x1d9a <V2P_GetChecksum>
    2148:	18 2f       	mov	r17, r24
    214a:	0e 94 8a 09 	call	0x1314	; 0x1314 <USART_Rx>
    214e:	18 17       	cp	r17, r24
    2150:	11 f0       	breq	.+4      	; 0x2156 <V2P_RunStateMachine+0x16a>
    2152:	1b e0       	ldi	r17, 0x0B	; 11
    2154:	67 cf       	rjmp	.-306    	; 0x2024 <V2P_RunStateMachine+0x38>
    2156:	80 91 91 01 	lds	r24, 0x0191
    215a:	84 30       	cpi	r24, 0x04	; 4
    215c:	38 f4       	brcc	.+14     	; 0x216c <V2P_RunStateMachine+0x180>
    215e:	82 30       	cpi	r24, 0x02	; 2
    2160:	08 f0       	brcs	.+2      	; 0x2164 <V2P_RunStateMachine+0x178>
    2162:	66 c0       	rjmp	.+204    	; 0x2230 <V2P_RunStateMachine+0x244>
    2164:	81 30       	cpi	r24, 0x01	; 1
    2166:	09 f0       	breq	.+2      	; 0x216a <V2P_RunStateMachine+0x17e>
    2168:	66 c0       	rjmp	.+204    	; 0x2236 <V2P_RunStateMachine+0x24a>
    216a:	06 c0       	rjmp	.+12     	; 0x2178 <V2P_RunStateMachine+0x18c>
    216c:	86 30       	cpi	r24, 0x06	; 6
    216e:	01 f1       	breq	.+64     	; 0x21b0 <V2P_RunStateMachine+0x1c4>
    2170:	87 30       	cpi	r24, 0x07	; 7
    2172:	09 f0       	breq	.+2      	; 0x2176 <V2P_RunStateMachine+0x18a>
    2174:	60 c0       	rjmp	.+192    	; 0x2236 <V2P_RunStateMachine+0x24a>
    2176:	12 c0       	rjmp	.+36     	; 0x219c <V2P_RunStateMachine+0x1b0>
    2178:	8b e0       	ldi	r24, 0x0B	; 11
    217a:	90 e0       	ldi	r25, 0x00	; 0
    217c:	90 93 a7 02 	sts	0x02A7, r25
    2180:	80 93 a6 02 	sts	0x02A6, r24
    2184:	ea e0       	ldi	r30, 0x0A	; 10
    2186:	f4 e0       	ldi	r31, 0x04	; 4
    2188:	a1 e9       	ldi	r26, 0x91	; 145
    218a:	b1 e0       	ldi	r27, 0x01	; 1
    218c:	84 91       	lpm	r24, Z
    218e:	8d 93       	st	X+, r24
    2190:	31 96       	adiw	r30, 0x01	; 1
    2192:	81 e0       	ldi	r24, 0x01	; 1
    2194:	ac 39       	cpi	r26, 0x9C	; 156
    2196:	b8 07       	cpc	r27, r24
    2198:	c9 f7       	brne	.-14     	; 0x218c <V2P_RunStateMachine+0x1a0>
    219a:	47 c0       	rjmp	.+142    	; 0x222a <V2P_RunStateMachine+0x23e>
    219c:	82 e0       	ldi	r24, 0x02	; 2
    219e:	90 e0       	ldi	r25, 0x00	; 0
    21a0:	90 93 a7 02 	sts	0x02A7, r25
    21a4:	80 93 a6 02 	sts	0x02A6, r24
    21a8:	80 ec       	ldi	r24, 0xC0	; 192
    21aa:	80 93 92 01 	sts	0x0192, r24
    21ae:	3d c0       	rjmp	.+122    	; 0x222a <V2P_RunStateMachine+0x23e>
    21b0:	82 e0       	ldi	r24, 0x02	; 2
    21b2:	90 e0       	ldi	r25, 0x00	; 0
    21b4:	90 93 a7 02 	sts	0x02A7, r25
    21b8:	80 93 a6 02 	sts	0x02A6, r24
    21bc:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <V2P_CheckForExtendedAddress>
    21c0:	e0 90 94 01 	lds	r14, 0x0194
    21c4:	ff 24       	eor	r15, r15
    21c6:	00 27       	eor	r16, r16
    21c8:	11 27       	eor	r17, r17
    21ca:	10 2f       	mov	r17, r16
    21cc:	0f 2d       	mov	r16, r15
    21ce:	fe 2c       	mov	r15, r14
    21d0:	ee 24       	eor	r14, r14
    21d2:	20 91 92 01 	lds	r18, 0x0192
    21d6:	33 27       	eor	r19, r19
    21d8:	44 27       	eor	r20, r20
    21da:	55 27       	eor	r21, r21
    21dc:	52 2f       	mov	r21, r18
    21de:	44 27       	eor	r20, r20
    21e0:	33 27       	eor	r19, r19
    21e2:	22 27       	eor	r18, r18
    21e4:	80 91 93 01 	lds	r24, 0x0193
    21e8:	99 27       	eor	r25, r25
    21ea:	aa 27       	eor	r26, r26
    21ec:	bb 27       	eor	r27, r27
    21ee:	dc 01       	movw	r26, r24
    21f0:	99 27       	eor	r25, r25
    21f2:	88 27       	eor	r24, r24
    21f4:	28 2b       	or	r18, r24
    21f6:	39 2b       	or	r19, r25
    21f8:	4a 2b       	or	r20, r26
    21fa:	5b 2b       	or	r21, r27
    21fc:	80 91 95 01 	lds	r24, 0x0195
    2200:	99 27       	eor	r25, r25
    2202:	aa 27       	eor	r26, r26
    2204:	bb 27       	eor	r27, r27
    2206:	28 2b       	or	r18, r24
    2208:	39 2b       	or	r19, r25
    220a:	4a 2b       	or	r20, r26
    220c:	5b 2b       	or	r21, r27
    220e:	e2 2a       	or	r14, r18
    2210:	f3 2a       	or	r15, r19
    2212:	04 2b       	or	r16, r20
    2214:	15 2b       	or	r17, r21
    2216:	e0 92 a9 02 	sts	0x02A9, r14
    221a:	f0 92 aa 02 	sts	0x02AA, r15
    221e:	00 93 ab 02 	sts	0x02AB, r16
    2222:	10 93 ac 02 	sts	0x02AC, r17
    2226:	10 92 92 01 	sts	0x0192, r1
    222a:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <V2P_SendPacket>
    222e:	05 c0       	rjmp	.+10     	; 0x223a <V2P_RunStateMachine+0x24e>
    2230:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <V2P_GetSetParamater>
    2234:	02 c0       	rjmp	.+4      	; 0x223a <V2P_RunStateMachine+0x24e>
    2236:	f6 01       	movw	r30, r12
    2238:	09 95       	icall
    223a:	18 e0       	ldi	r17, 0x08	; 8
    223c:	f3 ce       	rjmp	.-538    	; 0x2024 <V2P_RunStateMachine+0x38>
    223e:	1b 30       	cpi	r17, 0x0B	; 11
    2240:	11 f4       	brne	.+4      	; 0x2246 <V2P_RunStateMachine+0x25a>
    2242:	81 ec       	ldi	r24, 0xC1	; 193
    2244:	05 c0       	rjmp	.+10     	; 0x2250 <V2P_RunStateMachine+0x264>
    2246:	1a 30       	cpi	r17, 0x0A	; 10
    2248:	11 f4       	brne	.+4      	; 0x224e <V2P_RunStateMachine+0x262>
    224a:	80 e8       	ldi	r24, 0x80	; 128
    224c:	01 c0       	rjmp	.+2      	; 0x2250 <V2P_RunStateMachine+0x264>
    224e:	80 ec       	ldi	r24, 0xC0	; 192
    2250:	80 93 92 01 	sts	0x0192, r24
    2254:	82 e0       	ldi	r24, 0x02	; 2
    2256:	90 e0       	ldi	r25, 0x00	; 0
    2258:	90 93 a7 02 	sts	0x02A7, r25
    225c:	80 93 a6 02 	sts	0x02A6, r24
    2260:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <V2P_SendPacket>
    2264:	10 92 8c 01 	sts	0x018C, r1
    2268:	0e 94 db 0b 	call	0x17b6	; 0x17b6 <BUFF_InitialiseBuffer>
    226c:	10 92 b0 00 	sts	0x00B0, r1
    2270:	10 92 70 00 	sts	0x0070, r1
    2274:	10 e0       	ldi	r17, 0x00	; 0
    2276:	d6 ce       	rjmp	.-596    	; 0x2024 <V2P_RunStateMachine+0x38>
    2278:	80 e8       	ldi	r24, 0x80	; 128
    227a:	80 93 61 00 	sts	0x0061, r24
    227e:	83 e0       	ldi	r24, 0x03	; 3
    2280:	80 93 61 00 	sts	0x0061, r24
    2284:	10 92 c1 00 	sts	0x00C1, r1
    2288:	0e 94 42 0c 	call	0x1884	; 0x1884 <TOUT_SetupSleepTimer>
    228c:	df 91       	pop	r29
    228e:	cf 91       	pop	r28
    2290:	1f 91       	pop	r17
    2292:	0f 91       	pop	r16
    2294:	ff 90       	pop	r15
    2296:	ef 90       	pop	r14
    2298:	df 90       	pop	r13
    229a:	cf 90       	pop	r12
    229c:	08 95       	ret

0000229e <ISPCC_PollForProgComplete>:
	}
}

void ISPCC_PollForProgComplete(const uint8_t PollData, uint16_t PollAddr)
{
    229e:	1f 93       	push	r17
    22a0:	cf 93       	push	r28
    22a2:	df 93       	push	r29
    22a4:	eb 01       	movw	r28, r22
	uint8_t PollType;
	uint8_t ProgCommand;

	if (PollData & ISPCC_PROG_MODE_PAGE)
    22a6:	99 27       	eor	r25, r25
    22a8:	80 ff       	sbrs	r24, 0
    22aa:	08 c0       	rjmp	.+16     	; 0x22bc <ISPCC_PollForProgComplete+0x1e>
	   PollType = ((PollData & ISPCC_PAGE_POLLTYPE_MASK) >> ISPCC_PAGE_POLLTYPE_MASKSHIFT);
    22ac:	80 77       	andi	r24, 0x70	; 112
    22ae:	90 70       	andi	r25, 0x00	; 0
    22b0:	34 e0       	ldi	r19, 0x04	; 4
    22b2:	95 95       	asr	r25
    22b4:	87 95       	ror	r24
    22b6:	3a 95       	dec	r19
    22b8:	e1 f7       	brne	.-8      	; 0x22b2 <ISPCC_PollForProgComplete+0x14>
    22ba:	04 c0       	rjmp	.+8      	; 0x22c4 <ISPCC_PollForProgComplete+0x26>
	else
	   PollType = ((PollData & ISPCC_WORD_POLLTYPE_MASK) >> ISPCC_WORD_POLLTYPE_MASKSHIFT);	
    22bc:	8e 70       	andi	r24, 0x0E	; 14
    22be:	90 70       	andi	r25, 0x00	; 0
    22c0:	95 95       	asr	r25
    22c2:	87 95       	ror	r24

	switch (PollType & ISPCC_POLLTYPE_MASK)
    22c4:	99 27       	eor	r25, r25
    22c6:	87 70       	andi	r24, 0x07	; 7
    22c8:	90 70       	andi	r25, 0x00	; 0
    22ca:	82 30       	cpi	r24, 0x02	; 2
    22cc:	91 05       	cpc	r25, r1
    22ce:	19 f0       	breq	.+6      	; 0x22d6 <ISPCC_PollForProgComplete+0x38>
    22d0:	04 97       	sbiw	r24, 0x04	; 4
    22d2:	41 f5       	brne	.+80     	; 0x2324 <ISPCC_PollForProgComplete+0x86>
    22d4:	1c c0       	rjmp	.+56     	; 0x230e <ISPCC_PollForProgComplete+0x70>
	{
		case ISPCC_POLLTYPE_DATA:
			ProgCommand = PacketBytes[7];
    22d6:	10 91 98 01 	lds	r17, 0x0198
			
			if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP) // Flash uses word addresses
    22da:	80 91 91 01 	lds	r24, 0x0191
    22de:	83 31       	cpi	r24, 0x13	; 19
    22e0:	41 f4       	brne	.+16     	; 0x22f2 <ISPCC_PollForProgComplete+0x54>
			{
				ProgCommand  |= ((PollAddr & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ);
    22e2:	c0 ff       	sbrs	r28, 0
    22e4:	02 c0       	rjmp	.+4      	; 0x22ea <ISPCC_PollForProgComplete+0x4c>
    22e6:	88 e0       	ldi	r24, 0x08	; 8
    22e8:	01 c0       	rjmp	.+2      	; 0x22ec <ISPCC_PollForProgComplete+0x4e>
    22ea:	80 e0       	ldi	r24, 0x00	; 0
    22ec:	18 2b       	or	r17, r24
				PollAddr    >>= 1;
    22ee:	d6 95       	lsr	r29
    22f0:	c7 95       	ror	r28
			}

			do
			{
				USI_SPITransmit(ProgCommand);
    22f2:	81 2f       	mov	r24, r17
    22f4:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
				USI_SPITransmitWord(PollAddr);
    22f8:	ce 01       	movw	r24, r28
    22fa:	0e 94 03 0a 	call	0x1406	; 0x1406 <USI_SPITransmitWord>
			}
			while (USI_SPITransmit(0x00) == PacketBytes[8]);
    22fe:	80 e0       	ldi	r24, 0x00	; 0
    2300:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    2304:	90 91 99 01 	lds	r25, 0x0199
    2308:	89 17       	cp	r24, r25
    230a:	81 f4       	brne	.+32     	; 0x232c <ISPCC_PollForProgComplete+0x8e>
    230c:	f2 cf       	rjmp	.-28     	; 0x22f2 <ISPCC_PollForProgComplete+0x54>
						
			break;
		case ISPCC_POLLTYPE_READY:
			do
			   USI_SPITransmitWord(0xF000);
    230e:	80 e0       	ldi	r24, 0x00	; 0
    2310:	90 ef       	ldi	r25, 0xF0	; 240
    2312:	0e 94 03 0a 	call	0x1406	; 0x1406 <USI_SPITransmitWord>
			while (USI_SPITransmitWord(0x0000) & ISPCC_POLL_BUSYFLAG);
    2316:	80 e0       	ldi	r24, 0x00	; 0
    2318:	90 e0       	ldi	r25, 0x00	; 0
    231a:	0e 94 03 0a 	call	0x1406	; 0x1406 <USI_SPITransmitWord>
    231e:	80 ff       	sbrs	r24, 0
    2320:	05 c0       	rjmp	.+10     	; 0x232c <ISPCC_PollForProgComplete+0x8e>
    2322:	f5 cf       	rjmp	.-22     	; 0x230e <ISPCC_PollForProgComplete+0x70>

			break;
		default:                                      // Default is Wait polling
			MAIN_Delay1MS(PacketBytes[4]);	
    2324:	80 91 95 01 	lds	r24, 0x0195
    2328:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    232c:	df 91       	pop	r29
    232e:	cf 91       	pop	r28
    2330:	1f 91       	pop	r17
    2332:	08 95       	ret

00002334 <ISPCC_ProgramChip>:
    2334:	4f 92       	push	r4
    2336:	5f 92       	push	r5
    2338:	6f 92       	push	r6
    233a:	7f 92       	push	r7
    233c:	8f 92       	push	r8
    233e:	9f 92       	push	r9
    2340:	af 92       	push	r10
    2342:	bf 92       	push	r11
    2344:	cf 92       	push	r12
    2346:	df 92       	push	r13
    2348:	ef 92       	push	r14
    234a:	ff 92       	push	r15
    234c:	0f 93       	push	r16
    234e:	1f 93       	push	r17
    2350:	cf 93       	push	r28
    2352:	df 93       	push	r29
    2354:	b0 90 94 01 	lds	r11, 0x0194
    2358:	a0 90 96 01 	lds	r10, 0x0196
    235c:	40 90 a9 02 	lds	r4, 0x02A9
    2360:	50 90 aa 02 	lds	r5, 0x02AA
    2364:	60 90 ab 02 	lds	r6, 0x02AB
    2368:	70 90 ac 02 	lds	r7, 0x02AC
    236c:	80 91 92 01 	lds	r24, 0x0192
    2370:	99 27       	eor	r25, r25
    2372:	98 2e       	mov	r9, r24
    2374:	88 24       	eor	r8, r8
    2376:	80 91 93 01 	lds	r24, 0x0193
    237a:	99 27       	eor	r25, r25
    237c:	88 2a       	or	r8, r24
    237e:	99 2a       	or	r9, r25
    2380:	e0 90 91 01 	lds	r14, 0x0191
    2384:	b0 fc       	sbrc	r11, 0
    2386:	09 c0       	rjmp	.+18     	; 0x239a <ISPCC_ProgramChip+0x66>
    2388:	c0 e0       	ldi	r28, 0x00	; 0
    238a:	d0 e0       	ldi	r29, 0x00	; 0
    238c:	cc 24       	eor	r12, r12
    238e:	dd 24       	eor	r13, r13
    2390:	7b e9       	ldi	r23, 0x9B	; 155
    2392:	67 2e       	mov	r6, r23
    2394:	71 e0       	ldi	r23, 0x01	; 1
    2396:	77 2e       	mov	r7, r23
    2398:	ac c0       	rjmp	.+344    	; 0x24f2 <ISPCC_ProgramChip+0x1be>
    239a:	c0 e0       	ldi	r28, 0x00	; 0
    239c:	d0 e0       	ldi	r29, 0x00	; 0
    239e:	00 e0       	ldi	r16, 0x00	; 0
    23a0:	10 e0       	ldi	r17, 0x00	; 0
    23a2:	6b e9       	ldi	r22, 0x9B	; 155
    23a4:	c6 2e       	mov	r12, r22
    23a6:	61 e0       	ldi	r22, 0x01	; 1
    23a8:	d6 2e       	mov	r13, r22
    23aa:	41 c0       	rjmp	.+130    	; 0x242e <ISPCC_ProgramChip+0xfa>
    23ac:	f6 01       	movw	r30, r12
    23ae:	f0 80       	ld	r15, Z
    23b0:	f3 e1       	ldi	r31, 0x13	; 19
    23b2:	ef 16       	cp	r14, r31
    23b4:	39 f4       	brne	.+14     	; 0x23c4 <ISPCC_ProgramChip+0x90>
    23b6:	00 ff       	sbrs	r16, 0
    23b8:	02 c0       	rjmp	.+4      	; 0x23be <ISPCC_ProgramChip+0x8a>
    23ba:	88 e0       	ldi	r24, 0x08	; 8
    23bc:	01 c0       	rjmp	.+2      	; 0x23c0 <ISPCC_ProgramChip+0x8c>
    23be:	80 e0       	ldi	r24, 0x00	; 0
    23c0:	8a 29       	or	r24, r10
    23c2:	01 c0       	rjmp	.+2      	; 0x23c6 <ISPCC_ProgramChip+0x92>
    23c4:	8a 2d       	mov	r24, r10
    23c6:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    23ca:	80 91 a9 02 	lds	r24, 0x02A9
    23ce:	90 91 aa 02 	lds	r25, 0x02AA
    23d2:	0e 94 03 0a 	call	0x1406	; 0x1406 <USI_SPITransmitWord>
    23d6:	8f 2d       	mov	r24, r15
    23d8:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    23dc:	20 97       	sbiw	r28, 0x00	; 0
    23de:	d9 f4       	brne	.+54     	; 0x2416 <ISPCC_ProgramChip+0xe2>
    23e0:	80 91 99 01 	lds	r24, 0x0199
    23e4:	8f 15       	cp	r24, r15
    23e6:	b9 f0       	breq	.+46     	; 0x2416 <ISPCC_ProgramChip+0xe2>
    23e8:	83 e1       	ldi	r24, 0x13	; 19
    23ea:	e8 16       	cp	r14, r24
    23ec:	49 f0       	breq	.+18     	; 0x2400 <ISPCC_ProgramChip+0xcc>
    23ee:	e5 e1       	ldi	r30, 0x15	; 21
    23f0:	ee 16       	cp	r14, r30
    23f2:	89 f4       	brne	.+34     	; 0x2416 <ISPCC_ProgramChip+0xe2>
    23f4:	80 91 9a 01 	lds	r24, 0x019A
    23f8:	8f 15       	cp	r24, r15
    23fa:	09 f0       	breq	.+2      	; 0x23fe <ISPCC_ProgramChip+0xca>
    23fc:	7f c0       	rjmp	.+254    	; 0x24fc <ISPCC_ProgramChip+0x1c8>
    23fe:	0b c0       	rjmp	.+22     	; 0x2416 <ISPCC_ProgramChip+0xe2>
    2400:	c0 91 a9 02 	lds	r28, 0x02A9
    2404:	d0 91 aa 02 	lds	r29, 0x02AA
    2408:	cc 0f       	add	r28, r28
    240a:	dd 1f       	adc	r29, r29
    240c:	c8 01       	movw	r24, r16
    240e:	81 70       	andi	r24, 0x01	; 1
    2410:	90 70       	andi	r25, 0x00	; 0
    2412:	c8 0f       	add	r28, r24
    2414:	d9 1f       	adc	r29, r25
    2416:	00 fd       	sbrc	r16, 0
    2418:	03 c0       	rjmp	.+6      	; 0x2420 <ISPCC_ProgramChip+0xec>
    241a:	f5 e1       	ldi	r31, 0x15	; 21
    241c:	ef 16       	cp	r14, r31
    241e:	11 f4       	brne	.+4      	; 0x2424 <ISPCC_ProgramChip+0xf0>
    2420:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <V2P_IncrementCurrAddress>
    2424:	0f 5f       	subi	r16, 0xFF	; 255
    2426:	1f 4f       	sbci	r17, 0xFF	; 255
    2428:	08 94       	sec
    242a:	c1 1c       	adc	r12, r1
    242c:	d1 1c       	adc	r13, r1
    242e:	08 15       	cp	r16, r8
    2430:	19 05       	cpc	r17, r9
    2432:	09 f0       	breq	.+2      	; 0x2436 <ISPCC_ProgramChip+0x102>
    2434:	bb cf       	rjmp	.-138    	; 0x23ac <ISPCC_ProgramChip+0x78>
    2436:	b7 fe       	sbrs	r11, 7
    2438:	6c c0       	rjmp	.+216    	; 0x2512 <ISPCC_ProgramChip+0x1de>
    243a:	80 91 97 01 	lds	r24, 0x0197
    243e:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    2442:	c2 01       	movw	r24, r4
    2444:	0e 94 03 0a 	call	0x1406	; 0x1406 <USI_SPITransmitWord>
    2448:	80 e0       	ldi	r24, 0x00	; 0
    244a:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    244e:	20 97       	sbiw	r28, 0x00	; 0
    2450:	11 f0       	breq	.+4      	; 0x2456 <ISPCC_ProgramChip+0x122>
    2452:	8b 2d       	mov	r24, r11
    2454:	03 c0       	rjmp	.+6      	; 0x245c <ISPCC_ProgramChip+0x128>
    2456:	8b 2d       	mov	r24, r11
    2458:	8f 78       	andi	r24, 0x8F	; 143
    245a:	80 61       	ori	r24, 0x10	; 16
    245c:	be 01       	movw	r22, r28
    245e:	0e 94 4f 11 	call	0x229e	; 0x229e <ISPCC_PollForProgComplete>
    2462:	57 c0       	rjmp	.+174    	; 0x2512 <ISPCC_ProgramChip+0x1de>
    2464:	f3 01       	movw	r30, r6
    2466:	10 81       	ld	r17, Z
    2468:	f3 e1       	ldi	r31, 0x13	; 19
    246a:	ef 16       	cp	r14, r31
    246c:	39 f4       	brne	.+14     	; 0x247c <ISPCC_ProgramChip+0x148>
    246e:	c0 fe       	sbrs	r12, 0
    2470:	02 c0       	rjmp	.+4      	; 0x2476 <ISPCC_ProgramChip+0x142>
    2472:	88 e0       	ldi	r24, 0x08	; 8
    2474:	01 c0       	rjmp	.+2      	; 0x2478 <ISPCC_ProgramChip+0x144>
    2476:	80 e0       	ldi	r24, 0x00	; 0
    2478:	8a 29       	or	r24, r10
    247a:	01 c0       	rjmp	.+2      	; 0x247e <ISPCC_ProgramChip+0x14a>
    247c:	8a 2d       	mov	r24, r10
    247e:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    2482:	80 91 a9 02 	lds	r24, 0x02A9
    2486:	90 91 aa 02 	lds	r25, 0x02AA
    248a:	0e 94 03 0a 	call	0x1406	; 0x1406 <USI_SPITransmitWord>
    248e:	81 2f       	mov	r24, r17
    2490:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    2494:	80 91 99 01 	lds	r24, 0x0199
    2498:	81 17       	cp	r24, r17
    249a:	b9 f0       	breq	.+46     	; 0x24ca <ISPCC_ProgramChip+0x196>
    249c:	83 e1       	ldi	r24, 0x13	; 19
    249e:	e8 16       	cp	r14, r24
    24a0:	41 f0       	breq	.+16     	; 0x24b2 <ISPCC_ProgramChip+0x17e>
    24a2:	e5 e1       	ldi	r30, 0x15	; 21
    24a4:	ee 16       	cp	r14, r30
    24a6:	89 f4       	brne	.+34     	; 0x24ca <ISPCC_ProgramChip+0x196>
    24a8:	80 91 9a 01 	lds	r24, 0x019A
    24ac:	81 17       	cp	r24, r17
    24ae:	59 f5       	brne	.+86     	; 0x2506 <ISPCC_ProgramChip+0x1d2>
    24b0:	0c c0       	rjmp	.+24     	; 0x24ca <ISPCC_ProgramChip+0x196>
    24b2:	c0 91 a9 02 	lds	r28, 0x02A9
    24b6:	d0 91 aa 02 	lds	r29, 0x02AA
    24ba:	cc 0f       	add	r28, r28
    24bc:	dd 1f       	adc	r29, r29
    24be:	c6 01       	movw	r24, r12
    24c0:	81 70       	andi	r24, 0x01	; 1
    24c2:	90 70       	andi	r25, 0x00	; 0
    24c4:	c8 0f       	add	r28, r24
    24c6:	d9 1f       	adc	r29, r25
    24c8:	22 c0       	rjmp	.+68     	; 0x250e <ISPCC_ProgramChip+0x1da>
    24ca:	1b 2d       	mov	r17, r11
    24cc:	11 7f       	andi	r17, 0xF1	; 241
    24ce:	12 60       	ori	r17, 0x02	; 2
    24d0:	c0 fc       	sbrc	r12, 0
    24d2:	03 c0       	rjmp	.+6      	; 0x24da <ISPCC_ProgramChip+0x1a6>
    24d4:	f5 e1       	ldi	r31, 0x15	; 21
    24d6:	ef 16       	cp	r14, r31
    24d8:	11 f4       	brne	.+4      	; 0x24de <ISPCC_ProgramChip+0x1aa>
    24da:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <V2P_IncrementCurrAddress>
    24de:	be 01       	movw	r22, r28
    24e0:	81 2f       	mov	r24, r17
    24e2:	0e 94 4f 11 	call	0x229e	; 0x229e <ISPCC_PollForProgComplete>
    24e6:	08 94       	sec
    24e8:	c1 1c       	adc	r12, r1
    24ea:	d1 1c       	adc	r13, r1
    24ec:	08 94       	sec
    24ee:	61 1c       	adc	r6, r1
    24f0:	71 1c       	adc	r7, r1
    24f2:	c8 14       	cp	r12, r8
    24f4:	d9 04       	cpc	r13, r9
    24f6:	09 f0       	breq	.+2      	; 0x24fa <ISPCC_ProgramChip+0x1c6>
    24f8:	b5 cf       	rjmp	.-150    	; 0x2464 <ISPCC_ProgramChip+0x130>
    24fa:	0b c0       	rjmp	.+22     	; 0x2512 <ISPCC_ProgramChip+0x1de>
    24fc:	c0 91 a9 02 	lds	r28, 0x02A9
    2500:	d0 91 aa 02 	lds	r29, 0x02AA
    2504:	88 cf       	rjmp	.-240    	; 0x2416 <ISPCC_ProgramChip+0xe2>
    2506:	c0 91 a9 02 	lds	r28, 0x02A9
    250a:	d0 91 aa 02 	lds	r29, 0x02AA
    250e:	1b 2d       	mov	r17, r11
    2510:	df cf       	rjmp	.-66     	; 0x24d0 <ISPCC_ProgramChip+0x19c>
    2512:	df 91       	pop	r29
    2514:	cf 91       	pop	r28
    2516:	1f 91       	pop	r17
    2518:	0f 91       	pop	r16
    251a:	ff 90       	pop	r15
    251c:	ef 90       	pop	r14
    251e:	df 90       	pop	r13
    2520:	cf 90       	pop	r12
    2522:	bf 90       	pop	r11
    2524:	af 90       	pop	r10
    2526:	9f 90       	pop	r9
    2528:	8f 90       	pop	r8
    252a:	7f 90       	pop	r7
    252c:	6f 90       	pop	r6
    252e:	5f 90       	pop	r5
    2530:	4f 90       	pop	r4
    2532:	08 95       	ret

00002534 <ISPCC_EnterChipProgrammingMode>:
    2534:	ff 92       	push	r15
    2536:	0f 93       	push	r16
    2538:	1f 93       	push	r17
    253a:	00 91 96 01 	lds	r16, 0x0196
    253e:	10 91 95 01 	lds	r17, 0x0195
    2542:	81 b3       	in	r24, 0x11	; 17
    2544:	8f 7c       	andi	r24, 0xCF	; 207
    2546:	80 63       	ori	r24, 0x30	; 48
    2548:	81 bb       	out	0x11, r24	; 17
    254a:	80 91 93 01 	lds	r24, 0x0193
    254e:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2552:	81 2f       	mov	r24, r17
    2554:	81 50       	subi	r24, 0x01	; 1
    2556:	84 36       	cpi	r24, 0x64	; 100
    2558:	08 f4       	brcc	.+2      	; 0x255c <ISPCC_EnterChipProgrammingMode+0x28>
    255a:	40 c0       	rjmp	.+128    	; 0x25dc <ISPCC_EnterChipProgrammingMode+0xa8>
    255c:	18 e1       	ldi	r17, 0x18	; 24
    255e:	3e c0       	rjmp	.+124    	; 0x25dc <ISPCC_EnterChipProgrammingMode+0xa8>
    2560:	80 91 99 01 	lds	r24, 0x0199
    2564:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    2568:	80 2f       	mov	r24, r16
    256a:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    256e:	80 91 9a 01 	lds	r24, 0x019A
    2572:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    2576:	80 2f       	mov	r24, r16
    2578:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    257c:	80 91 9b 01 	lds	r24, 0x019B
    2580:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    2584:	f8 2e       	mov	r15, r24
    2586:	80 2f       	mov	r24, r16
    2588:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    258c:	80 91 98 01 	lds	r24, 0x0198
    2590:	83 30       	cpi	r24, 0x03	; 3
    2592:	29 f4       	brne	.+10     	; 0x259e <ISPCC_EnterChipProgrammingMode+0x6a>
    2594:	80 91 9c 01 	lds	r24, 0x019C
    2598:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    259c:	05 c0       	rjmp	.+10     	; 0x25a8 <ISPCC_EnterChipProgrammingMode+0x74>
    259e:	80 91 9c 01 	lds	r24, 0x019C
    25a2:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    25a6:	f8 2e       	mov	r15, r24
    25a8:	80 91 98 01 	lds	r24, 0x0198
    25ac:	88 23       	and	r24, r24
    25ae:	21 f0       	breq	.+8      	; 0x25b8 <ISPCC_EnterChipProgrammingMode+0x84>
    25b0:	80 91 97 01 	lds	r24, 0x0197
    25b4:	f8 16       	cp	r15, r24
    25b6:	69 f4       	brne	.+26     	; 0x25d2 <ISPCC_EnterChipProgrammingMode+0x9e>
    25b8:	80 2f       	mov	r24, r16
    25ba:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    25be:	81 e0       	ldi	r24, 0x01	; 1
    25c0:	80 93 a8 02 	sts	0x02A8, r24
    25c4:	81 b3       	in	r24, 0x11	; 17
    25c6:	8f 7c       	andi	r24, 0xCF	; 207
    25c8:	80 62       	ori	r24, 0x20	; 32
    25ca:	81 bb       	out	0x11, r24	; 17
    25cc:	10 92 92 01 	sts	0x0192, r1
    25d0:	0e c0       	rjmp	.+28     	; 0x25ee <ISPCC_EnterChipProgrammingMode+0xba>
    25d2:	80 2f       	mov	r24, r16
    25d4:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    25d8:	0e 94 40 0a 	call	0x1480	; 0x1480 <USI_SPIToggleClock>
    25dc:	11 50       	subi	r17, 0x01	; 1
    25de:	00 f6       	brcc	.-128    	; 0x2560 <ISPCC_EnterChipProgrammingMode+0x2c>
    25e0:	81 b3       	in	r24, 0x11	; 17
    25e2:	8f 7c       	andi	r24, 0xCF	; 207
    25e4:	80 61       	ori	r24, 0x10	; 16
    25e6:	81 bb       	out	0x11, r24	; 17
    25e8:	80 ec       	ldi	r24, 0xC0	; 192
    25ea:	80 93 92 01 	sts	0x0192, r24
    25ee:	1f 91       	pop	r17
    25f0:	0f 91       	pop	r16
    25f2:	ff 90       	pop	r15
    25f4:	08 95       	ret

000025f6 <AICI_InterpretPacket>:

// ======================================================================================

void AICI_InterpretPacket(void)
{
    25f6:	df 92       	push	r13
    25f8:	ef 92       	push	r14
    25fa:	ff 92       	push	r15
    25fc:	0f 93       	push	r16
    25fe:	1f 93       	push	r17
    2600:	cf 93       	push	r28
    2602:	df 93       	push	r29
	switch (PacketBytes[0])
    2604:	80 91 91 01 	lds	r24, 0x0191
    2608:	86 31       	cpi	r24, 0x16	; 22
    260a:	09 f4       	brne	.+2      	; 0x260e <AICI_InterpretPacket+0x18>
    260c:	e5 c0       	rjmp	.+458    	; 0x27d8 <AICI_InterpretPacket+0x1e2>
    260e:	87 31       	cpi	r24, 0x17	; 23
    2610:	78 f4       	brcc	.+30     	; 0x2630 <AICI_InterpretPacket+0x3a>
    2612:	82 31       	cpi	r24, 0x12	; 18
    2614:	09 f4       	brne	.+2      	; 0x2618 <AICI_InterpretPacket+0x22>
    2616:	52 c0       	rjmp	.+164    	; 0x26bc <AICI_InterpretPacket+0xc6>
    2618:	83 31       	cpi	r24, 0x13	; 19
    261a:	30 f4       	brcc	.+12     	; 0x2628 <AICI_InterpretPacket+0x32>
    261c:	80 31       	cpi	r24, 0x10	; 16
    261e:	d9 f0       	breq	.+54     	; 0x2656 <AICI_InterpretPacket+0x60>
    2620:	81 31       	cpi	r24, 0x11	; 17
    2622:	09 f0       	breq	.+2      	; 0x2626 <AICI_InterpretPacket+0x30>
    2624:	2c c1       	rjmp	.+600    	; 0x287e <AICI_InterpretPacket+0x288>
    2626:	30 c0       	rjmp	.+96     	; 0x2688 <AICI_InterpretPacket+0x92>
    2628:	84 31       	cpi	r24, 0x14	; 20
    262a:	09 f0       	breq	.+2      	; 0x262e <AICI_InterpretPacket+0x38>
    262c:	1d c1       	rjmp	.+570    	; 0x2868 <AICI_InterpretPacket+0x272>
    262e:	d4 c0       	rjmp	.+424    	; 0x27d8 <AICI_InterpretPacket+0x1e2>
    2630:	89 31       	cpi	r24, 0x19	; 25
    2632:	09 f4       	brne	.+2      	; 0x2636 <AICI_InterpretPacket+0x40>
    2634:	bd c0       	rjmp	.+378    	; 0x27b0 <AICI_InterpretPacket+0x1ba>
    2636:	8a 31       	cpi	r24, 0x1A	; 26
    2638:	38 f4       	brcc	.+14     	; 0x2648 <AICI_InterpretPacket+0x52>
    263a:	87 31       	cpi	r24, 0x17	; 23
    263c:	09 f4       	brne	.+2      	; 0x2640 <AICI_InterpretPacket+0x4a>
    263e:	b8 c0       	rjmp	.+368    	; 0x27b0 <AICI_InterpretPacket+0x1ba>
    2640:	88 31       	cpi	r24, 0x18	; 24
    2642:	09 f0       	breq	.+2      	; 0x2646 <AICI_InterpretPacket+0x50>
    2644:	1c c1       	rjmp	.+568    	; 0x287e <AICI_InterpretPacket+0x288>
    2646:	95 c0       	rjmp	.+298    	; 0x2772 <AICI_InterpretPacket+0x17c>
    2648:	8d 31       	cpi	r24, 0x1D	; 29
    264a:	08 f4       	brcc	.+2      	; 0x264e <AICI_InterpretPacket+0x58>
    264c:	92 c0       	rjmp	.+292    	; 0x2772 <AICI_InterpretPacket+0x17c>
    264e:	8d 31       	cpi	r24, 0x1D	; 29
    2650:	09 f0       	breq	.+2      	; 0x2654 <AICI_InterpretPacket+0x5e>
    2652:	15 c1       	rjmp	.+554    	; 0x287e <AICI_InterpretPacket+0x288>
    2654:	56 c0       	rjmp	.+172    	; 0x2702 <AICI_InterpretPacket+0x10c>
	{
		case AICB_CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
    2656:	82 e0       	ldi	r24, 0x02	; 2
    2658:	90 e0       	ldi	r25, 0x00	; 0
    265a:	90 93 a7 02 	sts	0x02A7, r25
    265e:	80 93 a6 02 	sts	0x02A6, r24
			
			USI_SPIInitMaster();
    2662:	0e 94 30 0a 	call	0x1460	; 0x1460 <USI_SPIInitMaster>

			MAIN_ResetCSLine(MAIN_RESETCS_ACTIVE);  // Pull the slave AVR's RESET line to active
    2666:	80 e0       	ldi	r24, 0x00	; 0
    2668:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
			ISPCC_EnterChipProgrammingMode();       // Run the Enter Programming Mode routine
    266c:	0e 94 9a 12 	call	0x2534	; 0x2534 <ISPCC_EnterChipProgrammingMode>

			if (InProgrammingMode)
    2670:	80 91 a8 02 	lds	r24, 0x02A8
    2674:	88 23       	and	r24, r24
    2676:	19 f0       	breq	.+6      	; 0x267e <AICI_InterpretPacket+0x88>
			   LCD_puts_f(AVRISPModeMessage);
    2678:	86 e3       	ldi	r24, 0x36	; 54
    267a:	94 e0       	ldi	r25, 0x04	; 4
    267c:	02 c0       	rjmp	.+4      	; 0x2682 <AICI_InterpretPacket+0x8c>
			else
			   LCD_puts_f(SyncErrorMessage);
    267e:	8b e2       	ldi	r24, 0x2B	; 43
    2680:	94 e0       	ldi	r25, 0x04	; 4
    2682:	0e 94 61 09 	call	0x12c2	; 0x12c2 <LCD_puts_f>
    2686:	04 c1       	rjmp	.+520    	; 0x2890 <AICI_InterpretPacket+0x29a>
			
			break;
		case AICB_CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;
    2688:	82 e0       	ldi	r24, 0x02	; 2
    268a:	90 e0       	ldi	r25, 0x00	; 0
    268c:	90 93 a7 02 	sts	0x02A7, r25
    2690:	80 93 a6 02 	sts	0x02A6, r24

			MAIN_Delay1MS(PacketBytes[1]);           // Wait for the "PreDelay" amount specified in the packet
    2694:	80 91 92 01 	lds	r24, 0x0192
    2698:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);   // Non programming mode = green status led
    269c:	81 b3       	in	r24, 0x11	; 17
    269e:	8f 7c       	andi	r24, 0xCF	; 207
    26a0:	80 61       	ori	r24, 0x10	; 16
    26a2:	81 bb       	out	0x11, r24	; 17
			InProgrammingMode = FALSE;
    26a4:	10 92 a8 02 	sts	0x02A8, r1
			MAIN_ResetCSLine(MAIN_RESETCS_INACTIVE); // Release the RESET line and allow the slave AVR to run
    26a8:	81 e0       	ldi	r24, 0x01	; 1
    26aa:	0e 94 66 02 	call	0x4cc	; 0x4cc <MAIN_ResetCSLine>
			MAIN_Delay1MS(PacketBytes[2]);           // Wait for the "PostDelay" amount specified in the packet
    26ae:	80 91 93 01 	lds	r24, 0x0193
    26b2:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
			
			USI_SPIOff();
    26b6:	0e 94 e6 09 	call	0x13cc	; 0x13cc <USI_SPIOff>
    26ba:	de c0       	rjmp	.+444    	; 0x2878 <AICI_InterpretPacket+0x282>

			PacketBytes[1] = AICB_STATUS_CMD_OK;     // Return OK

			break;
		case AICB_CMD_CHIP_ERASE_ISP:
			MessageSize = 2;
    26bc:	82 e0       	ldi	r24, 0x02	; 2
    26be:	90 e0       	ldi	r25, 0x00	; 0
    26c0:	90 93 a7 02 	sts	0x02A7, r25
    26c4:	80 93 a6 02 	sts	0x02A6, r24
    26c8:	c4 e9       	ldi	r28, 0x94	; 148
    26ca:	d1 e0       	ldi	r29, 0x01	; 1
			
			for (uint8_t PacketB = 3; PacketB <= 6; PacketB++) // Send the erase commands to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    26cc:	89 91       	ld	r24, Y+
    26ce:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    26d2:	81 e0       	ldi	r24, 0x01	; 1
    26d4:	c8 39       	cpi	r28, 0x98	; 152
    26d6:	d8 07       	cpc	r29, r24
    26d8:	c9 f7       	brne	.-14     	; 0x26cc <AICI_InterpretPacket+0xd6>

			if (PacketBytes[2])                       // Poll mode, value of 1 indicates a busy flag wait
    26da:	80 91 93 01 	lds	r24, 0x0193
    26de:	88 23       	and	r24, r24
    26e0:	59 f0       	breq	.+22     	; 0x26f8 <AICI_InterpretPacket+0x102>
			{
				do
					USI_SPITransmitWord(0xF000);
    26e2:	80 e0       	ldi	r24, 0x00	; 0
    26e4:	90 ef       	ldi	r25, 0xF0	; 240
    26e6:	0e 94 03 0a 	call	0x1406	; 0x1406 <USI_SPITransmitWord>
				while (USI_SPITransmitWord(0x0000) & 0x01);
    26ea:	80 e0       	ldi	r24, 0x00	; 0
    26ec:	90 e0       	ldi	r25, 0x00	; 0
    26ee:	0e 94 03 0a 	call	0x1406	; 0x1406 <USI_SPITransmitWord>
    26f2:	80 ff       	sbrs	r24, 0
    26f4:	c1 c0       	rjmp	.+386    	; 0x2878 <AICI_InterpretPacket+0x282>
    26f6:	f5 cf       	rjmp	.-22     	; 0x26e2 <AICI_InterpretPacket+0xec>
			}
			else                                      // Poll mode flag of 0 indicates a predefined delay
			{
				MAIN_Delay1MS(PacketBytes[1]);         // Wait the specified interval to ensure erase complete
    26f8:	80 91 92 01 	lds	r24, 0x0192
    26fc:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2700:	bb c0       	rjmp	.+374    	; 0x2878 <AICI_InterpretPacket+0x282>
			}
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Always return OK
			
			break;
		case AICB_CMD_SPI_MULTI:
				MessageSize = (3 + PacketBytes[2]);    // Number of recieved bytes, plus two OKs and the command byte
    2702:	f0 90 93 01 	lds	r15, 0x0193
    2706:	8f 2d       	mov	r24, r15
    2708:	99 27       	eor	r25, r25
    270a:	03 96       	adiw	r24, 0x03	; 3
    270c:	90 93 a7 02 	sts	0x02A7, r25
    2710:	80 93 a6 02 	sts	0x02A6, r24
		
				uint8_t TxBytes      = PacketBytes[1]; // \. The packet data is overwritten during the transfer. Because
    2714:	d0 90 92 01 	lds	r13, 0x0192
				uint8_t RxStartByte  = PacketBytes[2]; // |  of this each data byte must be stored into temp variables
				uint8_t RxBytes      = PacketBytes[3]; // /  so that their contents are not lost.
    2718:	e0 90 94 01 	lds	r14, 0x0194
    271c:	11 e0       	ldi	r17, 0x01	; 1
    271e:	01 e0       	ldi	r16, 0x01	; 1
    2720:	12 c0       	rjmp	.+36     	; 0x2746 <AICI_InterpretPacket+0x150>
				uint8_t RxByteNum    = 1;
				uint8_t TxByteNum    = 1;
				uint8_t RecievedByte = 0;

				while (TxByteNum++ < TxBytes)          // Still bytes to transfer
    2722:	0f 5f       	subi	r16, 0xFF	; 255
				{
					RecievedByte = USI_SPITransmit(PacketBytes[3 + TxByteNum]); // Transmit the byte, store the answer
    2724:	e0 2f       	mov	r30, r16
    2726:	ff 27       	eor	r31, r31
    2728:	ef 56       	subi	r30, 0x6F	; 111
    272a:	fe 4f       	sbci	r31, 0xFE	; 254
    272c:	83 81       	ldd	r24, Z+3	; 0x03
    272e:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>

					if ((TxByteNum >= RxStartByte) && (RxByteNum < RxBytes))
    2732:	0f 15       	cp	r16, r15
    2734:	40 f0       	brcs	.+16     	; 0x2746 <AICI_InterpretPacket+0x150>
    2736:	1e 15       	cp	r17, r14
    2738:	30 f4       	brcc	.+12     	; 0x2746 <AICI_InterpretPacket+0x150>
					   PacketBytes[2 + RxByteNum++] = RecievedByte;
    273a:	e1 2f       	mov	r30, r17
    273c:	ff 27       	eor	r31, r31
    273e:	ef 56       	subi	r30, 0x6F	; 111
    2740:	fe 4f       	sbci	r31, 0xFE	; 254
    2742:	82 83       	std	Z+2, r24	; 0x02
    2744:	1f 5f       	subi	r17, 0xFF	; 255
    2746:	0d 15       	cp	r16, r13
    2748:	60 f3       	brcs	.-40     	; 0x2722 <AICI_InterpretPacket+0x12c>
    274a:	06 c0       	rjmp	.+12     	; 0x2758 <AICI_InterpretPacket+0x162>
				}

				while (RxByteNum++ < RxBytes)                         // Still more bytes to recieve
				   PacketBytes[2 + RxByteNum] = USI_SPITransmit(0x00); // its answer to be recorded (or more bytes than sent need responses), send dummy bytes to fetch the response(s)
    274c:	80 e0       	ldi	r24, 0x00	; 0
    274e:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    2752:	cf 56       	subi	r28, 0x6F	; 111
    2754:	de 4f       	sbci	r29, 0xFE	; 254
    2756:	8a 83       	std	Y+2, r24	; 0x02
    2758:	1f 5f       	subi	r17, 0xFF	; 255
    275a:	81 2f       	mov	r24, r17
    275c:	81 50       	subi	r24, 0x01	; 1
    275e:	c1 2f       	mov	r28, r17
    2760:	dd 27       	eor	r29, r29
    2762:	8e 15       	cp	r24, r14
    2764:	98 f3       	brcs	.-26     	; 0x274c <AICI_InterpretPacket+0x156>

				PacketBytes[1]             = AICB_STATUS_CMD_OK; // Data should be encompassed
    2766:	10 92 92 01 	sts	0x0192, r1
				PacketBytes[3 + RxByteNum] = AICB_STATUS_CMD_OK; //  by STATS_CMD_OKs
    276a:	cf 56       	subi	r28, 0x6F	; 111
    276c:	de 4f       	sbci	r29, 0xFE	; 254
    276e:	1b 82       	std	Y+3, r1	; 0x03
    2770:	8f c0       	rjmp	.+286    	; 0x2890 <AICI_InterpretPacket+0x29a>

				break;
		case AICB_CMD_READ_SIGNATURE_ISP:
		case AICB_CMD_READ_FUSE_ISP:
		case AICB_CMD_READ_LOCK_ISP:
		case AICB_CMD_READ_OSCCAL_ISP:
			MessageSize = 4;
    2772:	84 e0       	ldi	r24, 0x04	; 4
    2774:	90 e0       	ldi	r25, 0x00	; 0
    2776:	90 93 a7 02 	sts	0x02A7, r25
    277a:	80 93 a6 02 	sts	0x02A6, r24
    277e:	c1 e0       	ldi	r28, 0x01	; 1
    2780:	d0 e0       	ldi	r29, 0x00	; 0
    2782:	03 e9       	ldi	r16, 0x93	; 147
    2784:	11 e0       	ldi	r17, 0x01	; 1
	
			for (uint8_t ByteNum = 1; ByteNum <= 4; ByteNum++)
			{
				uint8_t Response = USI_SPITransmit(PacketBytes[1 + ByteNum]); // Transmit the four signature request bytes
    2786:	f8 01       	movw	r30, r16
    2788:	81 91       	ld	r24, Z+
    278a:	8f 01       	movw	r16, r30
    278c:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    2790:	98 2f       	mov	r25, r24

				if (ByteNum == PacketBytes[1])         // If the current byte is the requested signature byte, save the reponse in the packet
    2792:	80 91 92 01 	lds	r24, 0x0192
    2796:	8c 17       	cp	r24, r28
    2798:	11 f4       	brne	.+4      	; 0x279e <AICI_InterpretPacket+0x1a8>
					PacketBytes[2] = Response;
    279a:	90 93 93 01 	sts	0x0193, r25
    279e:	21 96       	adiw	r28, 0x01	; 1
    27a0:	c5 30       	cpi	r28, 0x05	; 5
    27a2:	d1 05       	cpc	r29, r1
    27a4:	81 f7       	brne	.-32     	; 0x2786 <AICI_InterpretPacket+0x190>
			}

			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Data byte is encased in CMD_OKs
    27a6:	10 92 92 01 	sts	0x0192, r1
			PacketBytes[3] = AICB_STATUS_CMD_OK;       // Data byte is encased in CMD_OKs
    27aa:	10 92 94 01 	sts	0x0194, r1
    27ae:	70 c0       	rjmp	.+224    	; 0x2890 <AICI_InterpretPacket+0x29a>

			break;
		case AICB_CMD_PROGRAM_FUSE_ISP:
		case AICB_CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;
    27b0:	83 e0       	ldi	r24, 0x03	; 3
    27b2:	90 e0       	ldi	r25, 0x00	; 0
    27b4:	90 93 a7 02 	sts	0x02A7, r25
    27b8:	80 93 a6 02 	sts	0x02A6, r24
    27bc:	c2 e9       	ldi	r28, 0x92	; 146
    27be:	d1 e0       	ldi	r29, 0x01	; 1
			
			for (uint8_t PacketB = 1; PacketB <= 4; PacketB++) // Send the lock-byte values to the slave AVR
				USI_SPITransmit(PacketBytes[PacketB]);
    27c0:	89 91       	ld	r24, Y+
    27c2:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    27c6:	f1 e0       	ldi	r31, 0x01	; 1
    27c8:	c6 39       	cpi	r28, 0x96	; 150
    27ca:	df 07       	cpc	r29, r31
    27cc:	c9 f7       	brne	.-14     	; 0x27c0 <AICI_InterpretPacket+0x1ca>

			PacketBytes[1] = AICB_STATUS_CMD_OK;       // Two CMD_OKs are always returned
    27ce:	10 92 92 01 	sts	0x0192, r1
			PacketBytes[2] = AICB_STATUS_CMD_OK;       // Two CMD_OKs are always returned
    27d2:	10 92 93 01 	sts	0x0193, r1
    27d6:	5c c0       	rjmp	.+184    	; 0x2890 <AICI_InterpretPacket+0x29a>

			break;
		case AICB_CMD_READ_FLASH_ISP:
		case AICB_CMD_READ_EEPROM_ISP:
			MessageSize = 0;                           // Here to prevent compiler from complaining if a var dec appears straight after a case

			uint8_t  ReadCommand = PacketBytes[3];
    27d8:	d0 90 94 01 	lds	r13, 0x0194
			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8) // Load in the number of bytes that is to
			                     | PacketBytes[2];                 // be read into a temp variable (MSB first)
    27dc:	80 91 92 01 	lds	r24, 0x0192
    27e0:	99 27       	eor	r25, r25
    27e2:	d8 2f       	mov	r29, r24
    27e4:	cc 27       	eor	r28, r28
    27e6:	80 91 93 01 	lds	r24, 0x0193
    27ea:	99 27       	eor	r25, r25
    27ec:	c8 2b       	or	r28, r24
    27ee:	d9 2b       	or	r29, r25

			MessageSize = BytesToRead + 3;
    27f0:	23 96       	adiw	r28, 0x03	; 3
    27f2:	d0 93 a7 02 	sts	0x02A7, r29
    27f6:	c0 93 a6 02 	sts	0x02A6, r28
    27fa:	23 97       	sbiw	r28, 0x03	; 3
    27fc:	00 e0       	ldi	r16, 0x00	; 0
    27fe:	10 e0       	ldi	r17, 0x00	; 0
    2800:	83 e9       	ldi	r24, 0x93	; 147
    2802:	e8 2e       	mov	r14, r24
    2804:	81 e0       	ldi	r24, 0x01	; 1
    2806:	f8 2e       	mov	r15, r24
    2808:	26 c0       	rjmp	.+76     	; 0x2856 <AICI_InterpretPacket+0x260>

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
				if (PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)  // Flash read mode - word addresses so MSB/LSB masking nessesary
    280a:	80 91 91 01 	lds	r24, 0x0191
    280e:	84 31       	cpi	r24, 0x14	; 20
    2810:	39 f4       	brne	.+14     	; 0x2820 <AICI_InterpretPacket+0x22a>
				{
					USI_SPITransmit(ReadCommand | ((ReadByte & 0x01)? ISPCC_HIGH_BYTE_READ : ISPCC_LOW_BYTE_READ));
    2812:	00 ff       	sbrs	r16, 0
    2814:	02 c0       	rjmp	.+4      	; 0x281a <AICI_InterpretPacket+0x224>
    2816:	88 e0       	ldi	r24, 0x08	; 8
    2818:	01 c0       	rjmp	.+2      	; 0x281c <AICI_InterpretPacket+0x226>
    281a:	80 e0       	ldi	r24, 0x00	; 0
    281c:	8d 29       	or	r24, r13
    281e:	01 c0       	rjmp	.+2      	; 0x2822 <AICI_InterpretPacket+0x22c>
				}
				else                                       // EEPROM read mode, address is in bytes and so no masking nessesary
				{
					USI_SPITransmit(ReadCommand);
    2820:	8d 2d       	mov	r24, r13
    2822:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
				}
				
				USI_SPITransmitWord(CurrAddress);          // Transmit the current address to the slave AVR
    2826:	80 91 a9 02 	lds	r24, 0x02A9
    282a:	90 91 aa 02 	lds	r25, 0x02AA
    282e:	0e 94 03 0a 	call	0x1406	; 0x1406 <USI_SPITransmitWord>

				PacketBytes[2 + ReadByte] = USI_SPITransmit(0x00); // Read in the byte stored at the requested location
    2832:	80 e0       	ldi	r24, 0x00	; 0
    2834:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    2838:	f7 01       	movw	r30, r14
    283a:	80 83       	st	Z, r24

				if ((ReadByte & 0x01) || (PacketBytes[0] == AICB_CMD_READ_EEPROM_ISP)) // Flash addresses are given in words; only increment on the odd byte if reading the flash.
    283c:	00 fd       	sbrc	r16, 0
    283e:	04 c0       	rjmp	.+8      	; 0x2848 <AICI_InterpretPacket+0x252>
    2840:	80 91 91 01 	lds	r24, 0x0191
    2844:	86 31       	cpi	r24, 0x16	; 22
    2846:	11 f4       	brne	.+4      	; 0x284c <AICI_InterpretPacket+0x256>
				{
					V2P_IncrementCurrAddress();             // Increment the address counter
    2848:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <V2P_IncrementCurrAddress>
    284c:	0f 5f       	subi	r16, 0xFF	; 255
    284e:	1f 4f       	sbci	r17, 0xFF	; 255
    2850:	08 94       	sec
    2852:	e1 1c       	adc	r14, r1
    2854:	f1 1c       	adc	r15, r1
    2856:	0c 17       	cp	r16, r28
    2858:	1d 07       	cpc	r17, r29
    285a:	b9 f6       	brne	.-82     	; 0x280a <AICI_InterpretPacket+0x214>
				}
				else
				{
					if ((CurrAddress & 0x00FF0000) & !(CurrAddress & 0x0000FFFF))
					{
						CurrAddress |= (1UL << 31);        // Set MSB set of the address, indicates a LOAD_EXTENDED_ADDRESS must be executed
						V2P_CheckForExtendedAddress();
					}
				}
			}
			
			PacketBytes[1]               = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    285c:	10 92 92 01 	sts	0x0192, r1
			PacketBytes[2 + BytesToRead] = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
    2860:	cf 56       	subi	r28, 0x6F	; 111
    2862:	de 4f       	sbci	r29, 0xFE	; 254
    2864:	1a 82       	std	Y+2, r1	; 0x02
    2866:	14 c0       	rjmp	.+40     	; 0x2890 <AICI_InterpretPacket+0x29a>

			break;
		case AICB_CMD_PROGRAM_FLASH_ISP:
		case AICB_CMD_PROGRAM_EEPROM_ISP:
			ISPCC_ProgramChip();                         // Program the bytes into the chip
    2868:	0e 94 9a 11 	call	0x2334	; 0x2334 <ISPCC_ProgramChip>
			
			MessageSize = 2;
    286c:	82 e0       	ldi	r24, 0x02	; 2
    286e:	90 e0       	ldi	r25, 0x00	; 0
    2870:	90 93 a7 02 	sts	0x02A7, r25
    2874:	80 93 a6 02 	sts	0x02A6, r24

			PacketBytes[1] = AICB_STATUS_CMD_OK;
    2878:	10 92 92 01 	sts	0x0192, r1
    287c:	09 c0       	rjmp	.+18     	; 0x2890 <AICI_InterpretPacket+0x29a>
			
			break;
		default:                                        // Unknown command, return error
			MessageSize = 1;
    287e:	81 e0       	ldi	r24, 0x01	; 1
    2880:	90 e0       	ldi	r25, 0x00	; 0
    2882:	90 93 a7 02 	sts	0x02A7, r25
    2886:	80 93 a6 02 	sts	0x02A6, r24
			
			PacketBytes[1] = AICB_STATUS_CMD_UNKNOWN;
    288a:	89 ec       	ldi	r24, 0xC9	; 201
    288c:	80 93 92 01 	sts	0x0192, r24
	}

	V2P_SendPacket();                                    // Send the response packet
    2890:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <V2P_SendPacket>
    2894:	df 91       	pop	r29
    2896:	cf 91       	pop	r28
    2898:	1f 91       	pop	r17
    289a:	0f 91       	pop	r16
    289c:	ff 90       	pop	r15
    289e:	ef 90       	pop	r14
    28a0:	df 90       	pop	r13
    28a2:	08 95       	ret

000028a4 <PM_SetupDFAddressCounters>:
	  return ProgDataSize;
}

void PM_SetupDFAddressCounters(const uint8_t Type)
{
    28a4:	80 93 02 01 	sts	0x0102, r24
	uint32_t StartAddress;
	
	MemoryType  = Type;
	GPageLength = 0;
    28a8:	10 92 b0 02 	sts	0x02B0, r1
    28ac:	10 92 af 02 	sts	0x02AF, r1
    28b0:	20 91 a9 02 	lds	r18, 0x02A9
    28b4:	30 91 aa 02 	lds	r19, 0x02AA
    28b8:	40 91 ab 02 	lds	r20, 0x02AB
    28bc:	50 91 ac 02 	lds	r21, 0x02AC

	if (Type == TYPE_FLASH)                                              // Type 1 = Flash
    28c0:	81 30       	cpi	r24, 0x01	; 1
    28c2:	39 f4       	brne	.+14     	; 0x28d2 <PM_SetupDFAddressCounters+0x2e>
	  StartAddress = (CurrAddress << 1);                                 // Convert flash word address to byte address
    28c4:	da 01       	movw	r26, r20
    28c6:	c9 01       	movw	r24, r18
    28c8:	88 0f       	add	r24, r24
    28ca:	99 1f       	adc	r25, r25
    28cc:	aa 1f       	adc	r26, r26
    28ce:	bb 1f       	adc	r27, r27
    28d0:	06 c0       	rjmp	.+12     	; 0x28de <PM_SetupDFAddressCounters+0x3a>
	else
	  StartAddress = CurrAddress + PM_EEPROM_OFFSET;                     // EEPROM uses byte addresses, and starts at the 257th kilobyte in Dataflash
    28d2:	da 01       	movw	r26, r20
    28d4:	c9 01       	movw	r24, r18
    28d6:	80 50       	subi	r24, 0x00	; 0
    28d8:	9c 4f       	sbci	r25, 0xFC	; 252
    28da:	ab 4f       	sbci	r26, 0xFB	; 251
    28dc:	bf 4f       	sbci	r27, 0xFF	; 255
	
	DataflashInfo.CurrPageAddress = 0;
    28de:	10 92 44 01 	sts	0x0144, r1
    28e2:	10 92 43 01 	sts	0x0143, r1
    28e6:	20 e0       	ldi	r18, 0x00	; 0
    28e8:	30 e0       	ldi	r19, 0x00	; 0
    28ea:	06 c0       	rjmp	.+12     	; 0x28f8 <PM_SetupDFAddressCounters+0x54>

	while (StartAddress >= DF_INTERNALDF_BUFFBYTES)                     // This loop is the equivalent of a DIV and a MOD
	{
		StartAddress -= DF_INTERNALDF_BUFFBYTES;                         // Subtract one page's worth of bytes from the desired address
    28ec:	88 50       	subi	r24, 0x08	; 8
    28ee:	91 40       	sbci	r25, 0x01	; 1
    28f0:	a0 40       	sbci	r26, 0x00	; 0
    28f2:	b0 40       	sbci	r27, 0x00	; 0
    28f4:	2f 5f       	subi	r18, 0xFF	; 255
    28f6:	3f 4f       	sbci	r19, 0xFF	; 255
    28f8:	88 30       	cpi	r24, 0x08	; 8
    28fa:	41 e0       	ldi	r20, 0x01	; 1
    28fc:	94 07       	cpc	r25, r20
    28fe:	40 e0       	ldi	r20, 0x00	; 0
    2900:	a4 07       	cpc	r26, r20
    2902:	40 e0       	ldi	r20, 0x00	; 0
    2904:	b4 07       	cpc	r27, r20
    2906:	90 f7       	brcc	.-28     	; 0x28ec <PM_SetupDFAddressCounters+0x48>
    2908:	30 93 44 01 	sts	0x0144, r19
    290c:	20 93 43 01 	sts	0x0143, r18
		DataflashInfo.CurrPageAddress++;
	}
	
	DataflashInfo.CurrBuffByte = (uint16_t)StartAddress;                 // The buffer byte is the remainder
    2910:	90 93 46 01 	sts	0x0146, r25
    2914:	80 93 45 01 	sts	0x0145, r24
    2918:	08 95       	ret

0000291a <PM_CheckEndOfFuseLockData>:
}

void PM_StoreProgramByte(const uint8_t Data)
{
	if (DataflashInfo.CurrBuffByte == DF_INTERNALDF_BUFFBYTES)
	{
		DF_CopyBufferToFlashPage(DataflashInfo.CurrPageAddress++);
		DF_BufferWriteEnable(0);
		DataflashInfo.CurrBuffByte = 0;
	}
	
	SPI_SPITransmit(Data);                                               // Store the byte, dataflash is in write mode due to DF_BufferWriteEnable
	DataflashInfo.CurrBuffByte++;
	GPageLength++;
}

void PM_InterpretAVRISPPacket(void)
{
	uint8_t* EEPROMAddress;

	switch (PacketBytes[0])
	{
		case AICB_CMD_ENTER_PROGMODE_ISP:
			MessageSize = 2;
						
			for (uint8_t PacketB = 0; PacketB <= 11; PacketB++)          // Save the enter programming mode command bytes
			  eeprom_write_byte(&EEPROMVars.EnterProgMode[PacketB], PacketBytes[PacketB]);
			
			InProgrammingMode = TRUE;                                    // Set the flag, prevent the user from exiting the V2P state machine			
			CurrentMode = PM_NO_SETUP;                                   // Clear the current mode variable

			MAIN_SETSTATUSLED(MAIN_STATLED_RED);
			PacketBytes[1] = AICB_STATUS_CMD_OK;

			break;			
		case AICB_CMD_LEAVE_PROGMODE_ISP:
			MessageSize = 2;

			PM_CheckEndOfFuseLockData();                                 // Check for remaining bytes to be stored and general cleanup
			
			InProgrammingMode = FALSE;                                   // Clear the flag, allow the user to exit the V2P state machine

			DF_EnableDataflash(FALSE);

			MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);
			PacketBytes[1] = AICB_STATUS_CMD_OK;

			break;
		case AICB_CMD_READ_SIGNATURE_ISP:
			MessageSize = 4;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                          // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x01;                                        // Signature bytes all return "01" in storage mode
			PacketBytes[3] = AICB_STATUS_CMD_OK;                          // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_CHIP_ERASE_ISP:
			MessageSize = 2;

			for (uint8_t PacketB = 1; PacketB <= 6; PacketB++)          // Save the erase chip command bytes to EEPROM
			  eeprom_write_byte(&EEPROMVars.EraseChip[PacketB], PacketBytes[PacketB]);

			for (uint8_t Byte = 0; Byte < 8; Byte++)                    // Clear the program and EEPROM size counters
			{
				eeprom_write_byte(&EEPROMVars.DataSize[Byte], 0x00);
				eeprom_write_byte(&EEPROMVars.EEPROMSize[Byte], 0x00);
			}
						
			eeprom_write_byte(&EEPROMVars.EraseCmdStored, TRUE);
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;
			
			break;
		case AICB_CMD_READ_OSCCAL_ISP:
			MessageSize = 4;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs
			PacketBytes[2] = 0x00;                                      // Return 0x00 for the OSCCAL byte
			PacketBytes[3] = AICB_STATUS_CMD_OK;                        // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_READ_FUSE_ISP:
		case AICB_CMD_READ_LOCK_ISP:
			MessageSize = 4;
	
			if (CurrentMode != PM_LOCKFUSEBITS_READ)                    // First lock or fuse byte being read, set the EEPROM pointer
			{
				PM_CheckEndOfFuseLockData();                            // Check for remaining bytes to be stored and general cleanup
				
				DataflashInfo.CurrBuffByte = 0;
				CurrentMode  = PM_LOCKFUSEBITS_READ;
			}
			
			if (DataflashInfo.CurrBuffByte > eeprom_read_byte((PacketBytes[0] == AICB_CMD_READ_FUSE_ISP)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes))  // Trying to read more fuse/lock bytes than are stored in memory
			{
				PacketBytes[2] = 0xFF;                                 // Return 0xFF for the fuse/lock byte
			}
			else
			{
				PacketBytes[2] = eeprom_read_byte((uint8_t*)(((PacketBytes[0] == AICB_CMD_READ_FUSE_ISP)? &EEPROMVars.FuseBytes : &EEPROMVars.LockBytes) // Starting location
									                         + (DataflashInfo.CurrBuffByte << 2) + (PacketBytes[1] - 1)));                               // The start position of the actual fuse/lock byte to read (4 bytes each));
			}

			DataflashInfo.CurrBuffByte++;

			PacketBytes[1] = AICB_STATUS_CMD_OK;                       // Data byte is encased in CMD_OKs
			PacketBytes[3] = AICB_STATUS_CMD_OK;                       // Data byte is encased in CMD_OKs

			break;
		case AICB_CMD_PROGRAM_FUSE_ISP:
		case AICB_CMD_PROGRAM_LOCK_ISP:
			MessageSize = 3;

			if (CurrentMode != PM_LOCKFUSEBITS_WRITE)                  // First lock or fuse byte being written, set the EEPROM pointer
			{
				CurrentMode   = PM_LOCKFUSEBITS_WRITE;
				DataflashInfo.CurrBuffByte  = 0;                       // CurrBuffByte is used to store the total fuse/lock bytes written
			}

			if (PacketBytes[0] == AICB_CMD_PROGRAM_FUSE_ISP)
			{
				EEPROMAddress = (uint8_t*)(&EEPROMVars.FuseBytes + (DataflashInfo.CurrBuffByte << 2));
				MemoryType    = TYPE_FUSE;
			}
			else
			{
				EEPROMAddress = (uint8_t*)(&EEPROMVars.LockBytes + (DataflashInfo.CurrBuffByte << 2));
				MemoryType    = TYPE_LOCK;
			}				
			
			if (DataflashInfo.CurrBuffByte < PM_MAX_FUSELOCKBITS)
			{
				for (uint8_t FLByte = 1; FLByte <= 4; FLByte++)
				{
					eeprom_write_byte(EEPROMAddress, PacketBytes[FLByte]);
					EEPROMAddress++;
				}

				DataflashInfo.CurrBuffByte++;                          // Increment the total fuse/lock bytes written counter
			}
			
			PacketBytes[1] = AICB_STATUS_CMD_OK;                       // Two CMD_OKs are always returned
			PacketBytes[2] = AICB_STATUS_CMD_OK;                       // Two CMD_OKs are always returned

			break;
		case AICB_CMD_PROGRAM_FLASH_ISP:
		case AICB_CMD_PROGRAM_EEPROM_ISP:
			MessageSize = 2;

			if (CurrentMode != PM_DATAFLASH_WRITE)                      // First programming packet
			{
				if (PacketBytes[0] == AICB_CMD_PROGRAM_FLASH_ISP)       // Flash programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram; // Set the eeprom address to the Program command bytes location
					PM_SetupDFAddressCounters(TYPE_FLASH);
				}
				else                                                   // EEPROM programming mode
				{
					EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;  // Set the eeprom address to the EEPROM command bytes location
					PM_SetupDFAddressCounters(TYPE_EEPROM);
				}
				
				DF_BufferWriteEnable(DataflashInfo.CurrBuffByte);
				CurrentMode = PM_DATAFLASH_WRITE;
				
				for (uint8_t B = 1; B <= 9; B++)                       // Save the command bytes
				  eeprom_write_byte(EEPROMAddress, PacketBytes[B]);
			}

			uint16_t BytesToWrite = ((uint16_t)PacketBytes[1] << 8)
			                      | PacketBytes[2];

			for (uint16_t CurrByte = 0; CurrByte < BytesToWrite; CurrByte++)
				PM_StoreProgramByte(PacketBytes[10 + CurrByte]);

			if (!(GPageLength & PM_PAGELENGTH_FOUNDBIT) && (PacketBytes[3] & ISPCC_PROG_MODE_PAGEDONE) && GPageLength)
			{
				eeprom_write_word(((MemoryType == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength), GPageLength);
		
				GPageLength |= PM_PAGELENGTH_FOUNDBIT;                 // Bit 15 is used to indicate if the length has been found
			}

			PacketBytes[1] = AICB_STATUS_CMD_OK;
		
			break;
		case AICB_CMD_READ_FLASH_ISP:
		case AICB_CMD_READ_EEPROM_ISP:	
			if (CurrentMode != PM_DATAFLASH_READ)
			{
				PM_CheckEndOfFuseLockData();                           // Check for remaining bytes to be stored and general cleanup
				
				PM_SetupDFAddressCounters((PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);
				DF_ContinuousReadEnable(DataflashInfo.CurrPageAddress, DataflashInfo.CurrBuffByte);
				
				CurrentMode = PM_DATAFLASH_READ;
				CurrAddress = 0;
			}

			uint16_t BytesToRead = ((uint16_t)PacketBytes[1] << 8)    // \. Load in the number of bytes that is to
			                     | PacketBytes[2];                    // /  be read into a temp variable (MSB first)
						
			uint16_t BytesInMem  = PM_GetStoredDataSize((PacketBytes[0] == AICB_CMD_READ_FLASH_ISP)? TYPE_FLASH : TYPE_EEPROM);

			for (uint16_t ReadByte = 0; ReadByte < BytesToRead; ReadByte++)
			{
			   PacketBytes[2 + ReadByte] = ((CurrAddress < BytesInMem)? SPI_SPITransmit(0x00) : 0xFF); // Read in the next dataflash byte if present
			   V2P_IncrementCurrAddress();
			}
			
			MessageSize = BytesToRead + 3;

			PacketBytes[1]               = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
			PacketBytes[2 + BytesToRead] = AICB_STATUS_CMD_OK; // Return data should be encompassed in STATUS_CMD_OKs
		
			break;
		default:
			MessageSize = 1;
			
			PacketBytes[1] = AICB_STATUS_CMD_UNKNOWN;
	}

	V2P_SendPacket();                                   // Send the response packet
}

void PM_CheckEndOfFuseLockData(void)
{
    291a:	cf 93       	push	r28
    291c:	df 93       	push	r29
    291e:	cd b7       	in	r28, 0x3d	; 61
    2920:	de b7       	in	r29, 0x3e	; 62
    2922:	24 97       	sbiw	r28, 0x04	; 4
    2924:	0f b6       	in	r0, 0x3f	; 63
    2926:	f8 94       	cli
    2928:	de bf       	out	0x3e, r29	; 62
    292a:	0f be       	out	0x3f, r0	; 63
    292c:	cd bf       	out	0x3d, r28	; 61
	if (CurrentMode == PM_DATAFLASH_WRITE)
    292e:	80 91 ae 02 	lds	r24, 0x02AE
    2932:	81 30       	cpi	r24, 0x01	; 1
    2934:	09 f0       	breq	.+2      	; 0x2938 <PM_CheckEndOfFuseLockData+0x1e>
    2936:	40 c0       	rjmp	.+128    	; 0x29b8 <PM_CheckEndOfFuseLockData+0x9e>
	{
		if (DataflashInfo.CurrBuffByte)                               // Data in the dataflash buffer, pending to be written
    2938:	80 91 45 01 	lds	r24, 0x0145
    293c:	90 91 46 01 	lds	r25, 0x0146
    2940:	89 2b       	or	r24, r25
    2942:	31 f0       	breq	.+12     	; 0x2950 <PM_CheckEndOfFuseLockData+0x36>
		  DF_CopyBufferToFlashPage(DataflashInfo.CurrPageAddress);    // Save the remaining buffer bytes
    2944:	80 91 43 01 	lds	r24, 0x0143
    2948:	90 91 44 01 	lds	r25, 0x0144
    294c:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <DF_CopyBufferToFlashPage>

		uint32_t DataSize = ((DataflashInfo.CurrPageAddress * DF_INTERNALDF_BUFFBYTES) + DataflashInfo.CurrBuffByte);
    2950:	20 91 43 01 	lds	r18, 0x0143
    2954:	30 91 44 01 	lds	r19, 0x0144
    2958:	88 e0       	ldi	r24, 0x08	; 8
    295a:	91 e0       	ldi	r25, 0x01	; 1
    295c:	ac 01       	movw	r20, r24
    295e:	24 9f       	mul	r18, r20
    2960:	c0 01       	movw	r24, r0
    2962:	25 9f       	mul	r18, r21
    2964:	90 0d       	add	r25, r0
    2966:	34 9f       	mul	r19, r20
    2968:	90 0d       	add	r25, r0
    296a:	11 24       	eor	r1, r1
    296c:	20 91 45 01 	lds	r18, 0x0145
    2970:	30 91 46 01 	lds	r19, 0x0146
    2974:	82 0f       	add	r24, r18
    2976:	93 1f       	adc	r25, r19
    2978:	9c 01       	movw	r18, r24
    297a:	44 27       	eor	r20, r20
    297c:	55 27       	eor	r21, r21
    297e:	29 83       	std	Y+1, r18	; 0x01
    2980:	3a 83       	std	Y+2, r19	; 0x02
    2982:	4b 83       	std	Y+3, r20	; 0x03
    2984:	5c 83       	std	Y+4, r21	; 0x04

		if (MemoryType == TYPE_FLASH)
    2986:	80 91 02 01 	lds	r24, 0x0102
    298a:	fe 01       	movw	r30, r28
    298c:	31 96       	adiw	r30, 0x01	; 1
    298e:	81 30       	cpi	r24, 0x01	; 1
    2990:	21 f4       	brne	.+8      	; 0x299a <PM_CheckEndOfFuseLockData+0x80>
            {
              uint8_t len;
              len = (uint8_t) n;

              asm volatile (
    2992:	84 e0       	ldi	r24, 0x04	; 4
    2994:	ac e1       	ldi	r26, 0x1C	; 28
    2996:	b0 e0       	ldi	r27, 0x00	; 0
    2998:	0b c0       	rjmp	.+22     	; 0x29b0 <PM_CheckEndOfFuseLockData+0x96>
		{
			eeprom_write_block((const void*)&DataSize, (void*)&EEPROMVars.DataSize, sizeof(uint32_t));
		}
		else
		{
			DataSize -= PM_EEPROM_OFFSET;                // Remove DataFlash EEPROM start offset
    299a:	20 50       	subi	r18, 0x00	; 0
    299c:	34 40       	sbci	r19, 0x04	; 4
    299e:	44 40       	sbci	r20, 0x04	; 4
    29a0:	50 40       	sbci	r21, 0x00	; 0
    29a2:	29 83       	std	Y+1, r18	; 0x01
    29a4:	3a 83       	std	Y+2, r19	; 0x02
    29a6:	4b 83       	std	Y+3, r20	; 0x03
    29a8:	5c 83       	std	Y+4, r21	; 0x04
            {
              uint8_t len;
              len = (uint8_t) n;

              asm volatile (
    29aa:	84 e0       	ldi	r24, 0x04	; 4
    29ac:	a0 e2       	ldi	r26, 0x20	; 32
    29ae:	b0 e0       	ldi	r27, 0x00	; 0
    29b0:	18 2e       	mov	r1, r24
    29b2:	0e 94 b2 1a 	call	0x3564	; 0x3564 <__eeprom_write_block_1F2021>
    29b6:	12 c0       	rjmp	.+36     	; 0x29dc <PM_CheckEndOfFuseLockData+0xc2>
			eeprom_write_block((const void*)&DataSize, (void*)&EEPROMVars.EEPROMSize, sizeof(uint32_t));
		}
	}
	else if (CurrentMode == PM_LOCKFUSEBITS_WRITE)
    29b8:	83 30       	cpi	r24, 0x03	; 3
    29ba:	81 f4       	brne	.+32     	; 0x29dc <PM_CheckEndOfFuseLockData+0xc2>
	{
		// CurrBuffByte stores the total number of fuse/lock bytes written in this case:
		eeprom_write_byte(((MemoryType == TYPE_FUSE)? &EEPROMVars.TotalFuseBytes : &EEPROMVars.TotalLockBytes), DataflashInfo.CurrBuffByte);
    29bc:	20 91 45 01 	lds	r18, 0x0145
    29c0:	30 91 46 01 	lds	r19, 0x0146
    29c4:	80 91 02 01 	lds	r24, 0x0102
    29c8:	82 30       	cpi	r24, 0x02	; 2
    29ca:	19 f4       	brne	.+6      	; 0x29d2 <PM_CheckEndOfFuseLockData+0xb8>
    29cc:	a0 e3       	ldi	r26, 0x30	; 48
    29ce:	b0 e0       	ldi	r27, 0x00	; 0
    29d0:	02 c0       	rjmp	.+4      	; 0x29d6 <PM_CheckEndOfFuseLockData+0xbc>
    29d2:	a1 e3       	ldi	r26, 0x31	; 49
    29d4:	b0 e0       	ldi	r27, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    29d6:	02 2e       	mov	r0, r18
    29d8:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
    29dc:	24 96       	adiw	r28, 0x04	; 4
    29de:	0f b6       	in	r0, 0x3f	; 63
    29e0:	f8 94       	cli
    29e2:	de bf       	out	0x3e, r29	; 62
    29e4:	0f be       	out	0x3f, r0	; 63
    29e6:	cd bf       	out	0x3d, r28	; 61
    29e8:	df 91       	pop	r29
    29ea:	cf 91       	pop	r28
    29ec:	08 95       	ret

000029ee <PM_GetStoredDataSize>:
    29ee:	cf 93       	push	r28
    29f0:	df 93       	push	r29
    29f2:	cd b7       	in	r28, 0x3d	; 61
    29f4:	de b7       	in	r29, 0x3e	; 62
    29f6:	24 97       	sbiw	r28, 0x04	; 4
    29f8:	0f b6       	in	r0, 0x3f	; 63
    29fa:	f8 94       	cli
    29fc:	de bf       	out	0x3e, r29	; 62
    29fe:	0f be       	out	0x3f, r0	; 63
    2a00:	cd bf       	out	0x3d, r28	; 61
    2a02:	81 30       	cpi	r24, 0x01	; 1
    2a04:	19 f4       	brne	.+6      	; 0x2a0c <PM_GetStoredDataSize+0x1e>
    2a06:	ac e1       	ldi	r26, 0x1C	; 28
    2a08:	b0 e0       	ldi	r27, 0x00	; 0
    2a0a:	02 c0       	rjmp	.+4      	; 0x2a10 <PM_GetStoredDataSize+0x22>
    2a0c:	a0 e2       	ldi	r26, 0x20	; 32
    2a0e:	b0 e0       	ldi	r27, 0x00	; 0
              /* Needed in order to truncate to 8 bit.  */
              uint8_t len;
              len = (uint8_t) n; 

              asm volatile (
    2a10:	84 e0       	ldi	r24, 0x04	; 4
    2a12:	fe 01       	movw	r30, r28
    2a14:	31 96       	adiw	r30, 0x01	; 1
    2a16:	18 2e       	mov	r1, r24
    2a18:	0e 94 97 1a 	call	0x352e	; 0x352e <__eeprom_read_block_1F2021>
    2a1c:	69 81       	ldd	r22, Y+1	; 0x01
    2a1e:	7a 81       	ldd	r23, Y+2	; 0x02
    2a20:	8b 81       	ldd	r24, Y+3	; 0x03
    2a22:	9c 81       	ldd	r25, Y+4	; 0x04
    2a24:	6f 3f       	cpi	r22, 0xFF	; 255
    2a26:	2f ef       	ldi	r18, 0xFF	; 255
    2a28:	72 07       	cpc	r23, r18
    2a2a:	2f ef       	ldi	r18, 0xFF	; 255
    2a2c:	82 07       	cpc	r24, r18
    2a2e:	2f ef       	ldi	r18, 0xFF	; 255
    2a30:	92 07       	cpc	r25, r18
    2a32:	21 f4       	brne	.+8      	; 0x2a3c <PM_GetStoredDataSize+0x4e>
    2a34:	60 e0       	ldi	r22, 0x00	; 0
    2a36:	70 e0       	ldi	r23, 0x00	; 0
    2a38:	80 e0       	ldi	r24, 0x00	; 0
    2a3a:	90 e0       	ldi	r25, 0x00	; 0
    2a3c:	24 96       	adiw	r28, 0x04	; 4
    2a3e:	0f b6       	in	r0, 0x3f	; 63
    2a40:	f8 94       	cli
    2a42:	de bf       	out	0x3e, r29	; 62
    2a44:	0f be       	out	0x3f, r0	; 63
    2a46:	cd bf       	out	0x3d, r28	; 61
    2a48:	df 91       	pop	r29
    2a4a:	cf 91       	pop	r28
    2a4c:	08 95       	ret

00002a4e <PM_StoreProgramByte>:
    2a4e:	1f 93       	push	r17
    2a50:	18 2f       	mov	r17, r24
    2a52:	80 91 45 01 	lds	r24, 0x0145
    2a56:	90 91 46 01 	lds	r25, 0x0146
    2a5a:	88 50       	subi	r24, 0x08	; 8
    2a5c:	91 40       	sbci	r25, 0x01	; 1
    2a5e:	a1 f4       	brne	.+40     	; 0x2a88 <PM_StoreProgramByte+0x3a>
    2a60:	80 91 43 01 	lds	r24, 0x0143
    2a64:	90 91 44 01 	lds	r25, 0x0144
    2a68:	01 96       	adiw	r24, 0x01	; 1
    2a6a:	90 93 44 01 	sts	0x0144, r25
    2a6e:	80 93 43 01 	sts	0x0143, r24
    2a72:	01 97       	sbiw	r24, 0x01	; 1
    2a74:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <DF_CopyBufferToFlashPage>
    2a78:	80 e0       	ldi	r24, 0x00	; 0
    2a7a:	90 e0       	ldi	r25, 0x00	; 0
    2a7c:	0e 94 ca 0a 	call	0x1594	; 0x1594 <DF_BufferWriteEnable>
    2a80:	10 92 46 01 	sts	0x0146, r1
    2a84:	10 92 45 01 	sts	0x0145, r1
    2a88:	81 2f       	mov	r24, r17
    2a8a:	0e 94 b1 09 	call	0x1362	; 0x1362 <SPI_SPITransmit>
    2a8e:	80 91 45 01 	lds	r24, 0x0145
    2a92:	90 91 46 01 	lds	r25, 0x0146
    2a96:	01 96       	adiw	r24, 0x01	; 1
    2a98:	90 93 46 01 	sts	0x0146, r25
    2a9c:	80 93 45 01 	sts	0x0145, r24
    2aa0:	80 91 af 02 	lds	r24, 0x02AF
    2aa4:	90 91 b0 02 	lds	r25, 0x02B0
    2aa8:	01 96       	adiw	r24, 0x01	; 1
    2aaa:	90 93 b0 02 	sts	0x02B0, r25
    2aae:	80 93 af 02 	sts	0x02AF, r24
    2ab2:	1f 91       	pop	r17
    2ab4:	08 95       	ret

00002ab6 <PM_SendFuseLockBytes>:
	}
}

void PM_SendFuseLockBytes(const uint8_t Type)
{
    2ab6:	ef 92       	push	r14
    2ab8:	ff 92       	push	r15
    2aba:	0f 93       	push	r16
    2abc:	1f 93       	push	r17
    2abe:	cf 93       	push	r28
    2ac0:	df 93       	push	r29
	uint8_t  TotalBytes;
	uint8_t* EEPROMAddress;

	if (Type == TYPE_FUSE)
    2ac2:	82 30       	cpi	r24, 0x02	; 2
    2ac4:	59 f4       	brne	.+22     	; 0x2adc <PM_SendFuseLockBytes+0x26>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2ac6:	40 e3       	ldi	r20, 0x30	; 48
    2ac8:	50 e0       	ldi	r21, 0x00	; 0
    2aca:	da 01       	movw	r26, r20
    2acc:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
    2ad0:	80 2d       	mov	r24, r0
	{
		TotalBytes    = eeprom_read_byte(&EEPROMVars.TotalFuseBytes);
    2ad2:	18 2f       	mov	r17, r24
    2ad4:	62 e0       	ldi	r22, 0x02	; 2
    2ad6:	e6 2e       	mov	r14, r22
    2ad8:	f1 2c       	mov	r15, r1
    2ada:	0a c0       	rjmp	.+20     	; 0x2af0 <PM_SendFuseLockBytes+0x3a>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2adc:	41 e3       	ldi	r20, 0x31	; 49
    2ade:	50 e0       	ldi	r21, 0x00	; 0
    2ae0:	da 01       	movw	r26, r20
    2ae2:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
    2ae6:	80 2d       	mov	r24, r0
		EEPROMAddress = EEPROMVars.FuseBytes;
	}
	else
	{
		TotalBytes    = eeprom_read_byte(&EEPROMVars.TotalLockBytes);
    2ae8:	18 2f       	mov	r17, r24
    2aea:	39 e2       	ldi	r19, 0x29	; 41
    2aec:	e3 2e       	mov	r14, r19
    2aee:	f1 2c       	mov	r15, r1
    2af0:	e4 0e       	add	r14, r20
    2af2:	f5 1e       	adc	r15, r21
    2af4:	15 c0       	rjmp	.+42     	; 0x2b20 <PM_SendFuseLockBytes+0x6a>
    2af6:	e7 01       	movw	r28, r14
    2af8:	00 e0       	ldi	r16, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2afa:	de 01       	movw	r26, r28
    2afc:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
    2b00:	80 2d       	mov	r24, r0
		EEPROMAddress = EEPROMVars.LockBytes;	
	}

	while (TotalBytes--)                              // Write each of the fuse/lock bytes stored in memory to the slave AVR
	{
		for (uint8_t CommandByte = 0; CommandByte < 4; CommandByte++)      // Write each individual command byte
		{
			USI_SPITransmit(eeprom_read_byte(EEPROMAddress));
    2b02:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
			EEPROMAddress++;
    2b06:	21 96       	adiw	r28, 0x01	; 1
    2b08:	0f 5f       	subi	r16, 0xFF	; 255
    2b0a:	04 30       	cpi	r16, 0x04	; 4
    2b0c:	b1 f7       	brne	.-20     	; 0x2afa <PM_SendFuseLockBytes+0x44>
    2b0e:	84 e0       	ldi	r24, 0x04	; 4
    2b10:	90 e0       	ldi	r25, 0x00	; 0
    2b12:	e8 0e       	add	r14, r24
    2b14:	f9 1e       	adc	r15, r25
		}
		
		// Add some delay before programming next byte, if there is one:
		if (TotalBytes)
    2b16:	11 23       	and	r17, r17
    2b18:	19 f0       	breq	.+6      	; 0x2b20 <PM_SendFuseLockBytes+0x6a>
		  MAIN_Delay10MS(5);
    2b1a:	85 e0       	ldi	r24, 0x05	; 5
    2b1c:	0e 94 52 02 	call	0x4a4	; 0x4a4 <MAIN_Delay10MS>
    2b20:	11 50       	subi	r17, 0x01	; 1
    2b22:	48 f7       	brcc	.-46     	; 0x2af6 <PM_SendFuseLockBytes+0x40>
    2b24:	df 91       	pop	r29
    2b26:	cf 91       	pop	r28
    2b28:	1f 91       	pop	r17
    2b2a:	0f 91       	pop	r16
    2b2c:	ff 90       	pop	r15
    2b2e:	ef 90       	pop	r14
    2b30:	08 95       	ret

00002b32 <PM_SendEraseCommand>:
	}
}

void PM_SendEraseCommand(void)
{			
    2b32:	cf 93       	push	r28
    2b34:	df 93       	push	r29
    2b36:	c8 e1       	ldi	r28, 0x18	; 24
    2b38:	d0 e0       	ldi	r29, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2b3a:	de 01       	movw	r26, r28
    2b3c:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
    2b40:	80 2d       	mov	r24, r0
	for (uint8_t B = 2; B < 6 ; B++)                  // Read out the erase chip command bytes
	  USI_SPITransmit(eeprom_read_byte(&EEPROMVars.EraseChip[B])); // Send the erase chip commands
    2b42:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
    2b46:	21 96       	adiw	r28, 0x01	; 1
    2b48:	80 e0       	ldi	r24, 0x00	; 0
    2b4a:	cc 31       	cpi	r28, 0x1C	; 28
    2b4c:	d8 07       	cpc	r29, r24
    2b4e:	a9 f7       	brne	.-22     	; 0x2b3a <PM_SendEraseCommand+0x8>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2b50:	25 97       	sbiw	r28, 0x05	; 5
    2b52:	de 01       	movw	r26, r28
    2b54:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
    2b58:	80 2d       	mov	r24, r0
    2b5a:	25 96       	adiw	r28, 0x05	; 5
			
	if (eeprom_read_byte(&EEPROMVars.EraseChip[1]))   // Value of 1 indicates a busy flag test
    2b5c:	88 23       	and	r24, r24
    2b5e:	59 f0       	breq	.+22     	; 0x2b76 <PM_SendEraseCommand+0x44>
	{
		do
			USI_SPITransmitWord(0xF000);
    2b60:	80 e0       	ldi	r24, 0x00	; 0
    2b62:	90 ef       	ldi	r25, 0xF0	; 240
    2b64:	0e 94 03 0a 	call	0x1406	; 0x1406 <USI_SPITransmitWord>
		while (USI_SPITransmitWord(0x0000) & 0x01);
    2b68:	80 e0       	ldi	r24, 0x00	; 0
    2b6a:	90 e0       	ldi	r25, 0x00	; 0
    2b6c:	0e 94 03 0a 	call	0x1406	; 0x1406 <USI_SPITransmitWord>
    2b70:	80 ff       	sbrs	r24, 0
    2b72:	08 c0       	rjmp	.+16     	; 0x2b84 <PM_SendEraseCommand+0x52>
    2b74:	f5 cf       	rjmp	.-22     	; 0x2b60 <PM_SendEraseCommand+0x2e>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2b76:	26 97       	sbiw	r28, 0x06	; 6
    2b78:	de 01       	movw	r26, r28
    2b7a:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
    2b7e:	80 2d       	mov	r24, r0
	}
	else                                              // Cleared flag means use a predefined delay
	{		
		MAIN_Delay1MS(eeprom_read_byte(&EEPROMVars.EraseChip[0])); // Wait the erase delay
    2b80:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <MAIN_Delay1MS>
    2b84:	df 91       	pop	r29
    2b86:	cf 91       	pop	r28
    2b88:	08 95       	ret

00002b8a <PM_CreateProgrammingPackets>:
	}
}

void PM_CreateProgrammingPackets(const uint8_t Type)
{			
    2b8a:	3f 92       	push	r3
    2b8c:	4f 92       	push	r4
    2b8e:	5f 92       	push	r5
    2b90:	6f 92       	push	r6
    2b92:	7f 92       	push	r7
    2b94:	8f 92       	push	r8
    2b96:	9f 92       	push	r9
    2b98:	af 92       	push	r10
    2b9a:	bf 92       	push	r11
    2b9c:	cf 92       	push	r12
    2b9e:	df 92       	push	r13
    2ba0:	ef 92       	push	r14
    2ba2:	ff 92       	push	r15
    2ba4:	0f 93       	push	r16
    2ba6:	1f 93       	push	r17
    2ba8:	cf 93       	push	r28
    2baa:	df 93       	push	r29
    2bac:	18 2f       	mov	r17, r24
	uint32_t BytesRead       = 0;
	uint32_t BytesToRead     = PM_GetStoredDataSize(Type);      // Get the byte size of the stored program
    2bae:	0e 94 f7 14 	call	0x29ee	; 0x29ee <PM_GetStoredDataSize>
    2bb2:	2b 01       	movw	r4, r22
    2bb4:	3c 01       	movw	r6, r24
	uint16_t BytesPerProgram;
	uint16_t PageLength;
	uint8_t* EEPROMAddress;
	uint8_t  ContinuedPage   = FALSE;

	PageLength  = eeprom_read_word((Type == TYPE_FLASH)? &EEPROMVars.PageLength : &EEPROMVars.EPageLength);
    2bb6:	11 30       	cpi	r17, 0x01	; 1
    2bb8:	09 f0       	breq	.+2      	; 0x2bbc <PM_CreateProgrammingPackets+0x32>
    2bba:	d7 c0       	rjmp	.+430    	; 0x2d6a <PM_CreateProgrammingPackets+0x1e0>
eeprom_read_word (const uint16_t *addr)
{
  uint16_t result;

  asm ( 
    2bbc:	a2 e8       	ldi	r26, 0x82	; 130
    2bbe:	b0 e0       	ldi	r27, 0x00	; 0
    2bc0:	0e 94 9c 1a 	call	0x3538	; 0x3538 <__eeprom_read_word_1F2021>
    2bc4:	4f 01       	movw	r8, r30
	CurrAddress = 0;
    2bc6:	10 92 a9 02 	sts	0x02A9, r1
    2bca:	10 92 aa 02 	sts	0x02AA, r1
    2bce:	10 92 ab 02 	sts	0x02AB, r1
    2bd2:	10 92 ac 02 	sts	0x02AC, r1

	if (Type == TYPE_FLASH)
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteProgram;       // Set the EEPROM pointer to the write flash command bytes location
		DF_ContinuousReadEnable(0, 0);
    2bd6:	60 e0       	ldi	r22, 0x00	; 0
    2bd8:	70 e0       	ldi	r23, 0x00	; 0
    2bda:	80 e0       	ldi	r24, 0x00	; 0
    2bdc:	90 e0       	ldi	r25, 0x00	; 0
    2bde:	0e 94 8f 0a 	call	0x151e	; 0x151e <DF_ContinuousReadEnable>
		PacketBytes[0] = AICB_CMD_PROGRAM_FLASH_ISP;
    2be2:	83 e1       	ldi	r24, 0x13	; 19
    2be4:	80 93 91 01 	sts	0x0191, r24
    2be8:	23 e0       	ldi	r18, 0x03	; 3
    2bea:	30 e0       	ldi	r19, 0x00	; 0
    2bec:	e2 e9       	ldi	r30, 0x92	; 146
    2bee:	f1 e0       	ldi	r31, 0x01	; 1
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2bf0:	d9 01       	movw	r26, r18
    2bf2:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
    2bf6:	80 2d       	mov	r24, r0
	}
	else
	{
		EEPROMAddress = (uint8_t*)&EEPROMVars.WriteEEPROM;        // Set the EEPROM pointer to the write EEPROM command bytes location
		DF_ContinuousReadEnable(PM_EEPROM_OFFSET / DF_INTERNALDF_BUFFBYTES, PM_EEPROM_OFFSET % DF_INTERNALDF_BUFFBYTES); // Start read from the EEPROM offset location
		PacketBytes[0] = AICB_CMD_PROGRAM_EEPROM_ISP;
	}

	for (uint8_t B = 1; B <= 9 ; B++)                 // Load in the write data command bytes
	{
		PacketBytes[B] = eeprom_read_byte(EEPROMAddress); // Synthesise a write packet header
    2bf8:	81 93       	st	Z+, r24
		EEPROMAddress++;                               // Increment the EEPROM location counter
    2bfa:	2f 5f       	subi	r18, 0xFF	; 255
    2bfc:	3f 4f       	sbci	r19, 0xFF	; 255
    2bfe:	81 e0       	ldi	r24, 0x01	; 1
    2c00:	eb 39       	cpi	r30, 0x9B	; 155
    2c02:	f8 07       	cpc	r31, r24
    2c04:	a9 f7       	brne	.-22     	; 0x2bf0 <PM_CreateProgrammingPackets+0x66>
	}
	
	BytesPerProgram = ((uint16_t)PacketBytes[1] << 8)
    2c06:	80 91 92 01 	lds	r24, 0x0192
    2c0a:	99 27       	eor	r25, r25
    2c0c:	d8 2f       	mov	r29, r24
    2c0e:	cc 27       	eor	r28, r28
    2c10:	80 91 93 01 	lds	r24, 0x0193
    2c14:	99 27       	eor	r25, r25
    2c16:	c8 2b       	or	r28, r24
    2c18:	d9 2b       	or	r29, r25
    2c1a:	aa 24       	eor	r10, r10
    2c1c:	bb 24       	eor	r11, r11
    2c1e:	65 01       	movw	r12, r10
    2c20:	33 24       	eor	r3, r3
    2c22:	9c c0       	rjmp	.+312    	; 0x2d5c <PM_CreateProgrammingPackets+0x1d2>
	                | PacketBytes[2];

	while (BytesRead < BytesToRead)
	{
		if (PacketBytes[3] & ISPCC_PROG_MODE_PAGE)
    2c24:	80 91 94 01 	lds	r24, 0x0194
    2c28:	80 ff       	sbrs	r24, 0
    2c2a:	4b c0       	rjmp	.+150    	; 0x2cc2 <PM_CreateProgrammingPackets+0x138>
		{
			if (PageLength > 160) // Max 160 bytes at a time
    2c2c:	91 ea       	ldi	r25, 0xA1	; 161
    2c2e:	89 16       	cp	r8, r25
    2c30:	91 04       	cpc	r9, r1
    2c32:	18 f4       	brcc	.+6      	; 0x2c3a <PM_CreateProgrammingPackets+0xb0>
    2c34:	01 e9       	ldi	r16, 0x91	; 145
    2c36:	11 e0       	ldi	r17, 0x01	; 1
    2c38:	2f c0       	rjmp	.+94     	; 0x2c98 <PM_CreateProgrammingPackets+0x10e>
			{
				if (!(ContinuedPage))                      // Start of a new page, program in the first 150 bytes
    2c3a:	33 20       	and	r3, r3
    2c3c:	41 f4       	brne	.+16     	; 0x2c4e <PM_CreateProgrammingPackets+0xc4>
				{
					BytesPerProgram = 160;
					PacketBytes[3] &= ~ISPCC_PROG_MODE_PAGEDONE;		
    2c3e:	8f 77       	andi	r24, 0x7F	; 127
    2c40:	80 93 94 01 	sts	0x0194, r24
    2c44:	c0 ea       	ldi	r28, 0xA0	; 160
    2c46:	d0 e0       	ldi	r29, 0x00	; 0
    2c48:	11 e0       	ldi	r17, 0x01	; 1
    2c4a:	31 2e       	mov	r3, r17
    2c4c:	07 c0       	rjmp	.+14     	; 0x2c5c <PM_CreateProgrammingPackets+0xd2>
					ContinuedPage = TRUE;
				}
				else                                       // Middle of a page, program in the remainder
				{
					BytesPerProgram = PageLength - 160;
    2c4e:	e4 01       	movw	r28, r8
    2c50:	c0 5a       	subi	r28, 0xA0	; 160
    2c52:	d0 40       	sbci	r29, 0x00	; 0
					PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
    2c54:	80 68       	ori	r24, 0x80	; 128
    2c56:	80 93 94 01 	sts	0x0194, r24
    2c5a:	33 24       	eor	r3, r3
    2c5c:	01 e9       	ldi	r16, 0x91	; 145
    2c5e:	11 e0       	ldi	r17, 0x01	; 1
    2c60:	07 c0       	rjmp	.+14     	; 0x2c70 <PM_CreateProgrammingPackets+0xe6>
					ContinuedPage = FALSE;
				}
				
				for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page				
    2c62:	80 e0       	ldi	r24, 0x00	; 0
    2c64:	0e 94 b1 09 	call	0x1362	; 0x1362 <SPI_SPITransmit>
    2c68:	f8 01       	movw	r30, r16
    2c6a:	82 87       	std	Z+10, r24	; 0x0a
    2c6c:	0f 5f       	subi	r16, 0xFF	; 255
    2c6e:	1f 4f       	sbci	r17, 0xFF	; 255
    2c70:	ce 01       	movw	r24, r28
    2c72:	8f 56       	subi	r24, 0x6F	; 111
    2c74:	9e 4f       	sbci	r25, 0xFE	; 254
    2c76:	08 17       	cp	r16, r24
    2c78:	19 07       	cpc	r17, r25
    2c7a:	99 f7       	brne	.-26     	; 0x2c62 <PM_CreateProgrammingPackets+0xd8>

				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);
    2c7c:	8d 2f       	mov	r24, r29
    2c7e:	99 27       	eor	r25, r25
    2c80:	80 93 92 01 	sts	0x0192, r24
				PacketBytes[2] = (uint8_t)(BytesPerProgram);
    2c84:	c0 93 93 01 	sts	0x0193, r28
    2c88:	41 c0       	rjmp	.+130    	; 0x2d0c <PM_CreateProgrammingPackets+0x182>

				BytesRead += BytesPerProgram;                         // Increment the counter
			}
			else
			{
				for (uint16_t LoadB = 0; LoadB < PageLength; LoadB++)
					PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);  // Load in the page
    2c8a:	80 e0       	ldi	r24, 0x00	; 0
    2c8c:	0e 94 b1 09 	call	0x1362	; 0x1362 <SPI_SPITransmit>
    2c90:	f8 01       	movw	r30, r16
    2c92:	82 87       	std	Z+10, r24	; 0x0a
    2c94:	0f 5f       	subi	r16, 0xFF	; 255
    2c96:	1f 4f       	sbci	r17, 0xFF	; 255
    2c98:	c4 01       	movw	r24, r8
    2c9a:	8f 56       	subi	r24, 0x6F	; 111
    2c9c:	9e 4f       	sbci	r25, 0xFE	; 254
    2c9e:	08 17       	cp	r16, r24
    2ca0:	19 07       	cpc	r17, r25
    2ca2:	99 f7       	brne	.-26     	; 0x2c8a <PM_CreateProgrammingPackets+0x100>
			
				PacketBytes[1]  = (uint8_t)(PageLength >> 8);
    2ca4:	89 2d       	mov	r24, r9
    2ca6:	99 27       	eor	r25, r25
    2ca8:	80 93 92 01 	sts	0x0192, r24
				PacketBytes[2]  = (uint8_t)(PageLength);
    2cac:	80 92 93 01 	sts	0x0193, r8
				PacketBytes[3] |= ISPCC_PROG_MODE_PAGEDONE;
    2cb0:	80 91 94 01 	lds	r24, 0x0194
    2cb4:	80 68       	ori	r24, 0x80	; 128
    2cb6:	80 93 94 01 	sts	0x0194, r24

				BytesRead += PageLength;                            // Increment the counter
    2cba:	c4 01       	movw	r24, r8
    2cbc:	aa 27       	eor	r26, r26
    2cbe:	bb 27       	eor	r27, r27
    2cc0:	28 c0       	rjmp	.+80     	; 0x2d12 <PM_CreateProgrammingPackets+0x188>
			}
		}
		else
		{
			if ((BytesRead + BytesPerProgram) > BytesToRead)        // Less than a whole BytesPerProgram left of data to write
    2cc2:	ce 01       	movw	r24, r28
    2cc4:	aa 27       	eor	r26, r26
    2cc6:	bb 27       	eor	r27, r27
    2cc8:	8a 0d       	add	r24, r10
    2cca:	9b 1d       	adc	r25, r11
    2ccc:	ac 1d       	adc	r26, r12
    2cce:	bd 1d       	adc	r27, r13
    2cd0:	48 16       	cp	r4, r24
    2cd2:	59 06       	cpc	r5, r25
    2cd4:	6a 06       	cpc	r6, r26
    2cd6:	7b 06       	cpc	r7, r27
    2cd8:	48 f4       	brcc	.+18     	; 0x2cec <PM_CreateProgrammingPackets+0x162>
			{
				BytesPerProgram = BytesToRead - BytesRead;          // Next lot of bytes will be the remaining data length
    2cda:	e2 01       	movw	r28, r4
    2cdc:	ca 19       	sub	r28, r10
    2cde:	db 09       	sbc	r29, r11
				PacketBytes[1] = (uint8_t)(BytesPerProgram >> 8);   // \. Save the new length
    2ce0:	8d 2f       	mov	r24, r29
    2ce2:	99 27       	eor	r25, r25
    2ce4:	80 93 92 01 	sts	0x0192, r24
				PacketBytes[2] = (uint8_t)(BytesPerProgram);        // /  into the data packet
    2ce8:	c0 93 93 01 	sts	0x0193, r28
    2cec:	01 e9       	ldi	r16, 0x91	; 145
    2cee:	11 e0       	ldi	r17, 0x01	; 1
    2cf0:	07 c0       	rjmp	.+14     	; 0x2d00 <PM_CreateProgrammingPackets+0x176>
			}

			for (uint16_t LoadB = 0; LoadB < BytesPerProgram; LoadB++)
				PacketBytes[10 + LoadB] = SPI_SPITransmit(0x00);    // Load in the page
    2cf2:	80 e0       	ldi	r24, 0x00	; 0
    2cf4:	0e 94 b1 09 	call	0x1362	; 0x1362 <SPI_SPITransmit>
    2cf8:	f8 01       	movw	r30, r16
    2cfa:	82 87       	std	Z+10, r24	; 0x0a
    2cfc:	0f 5f       	subi	r16, 0xFF	; 255
    2cfe:	1f 4f       	sbci	r17, 0xFF	; 255
    2d00:	ce 01       	movw	r24, r28
    2d02:	8f 56       	subi	r24, 0x6F	; 111
    2d04:	9e 4f       	sbci	r25, 0xFE	; 254
    2d06:	08 17       	cp	r16, r24
    2d08:	19 07       	cpc	r17, r25
    2d0a:	99 f7       	brne	.-26     	; 0x2cf2 <PM_CreateProgrammingPackets+0x168>
			
			BytesRead += BytesPerProgram;                           // Increment the counter
    2d0c:	ce 01       	movw	r24, r28
    2d0e:	aa 27       	eor	r26, r26
    2d10:	bb 27       	eor	r27, r27
    2d12:	a8 0e       	add	r10, r24
    2d14:	b9 1e       	adc	r11, r25
    2d16:	ca 1e       	adc	r12, r26
    2d18:	db 1e       	adc	r13, r27
		}
	
		if (!(BytesRead & 0xFFFF) && (BytesRead & 0x00FF0000))      // Extended address required
    2d1a:	a1 14       	cp	r10, r1
    2d1c:	b1 04       	cpc	r11, r1
    2d1e:	e1 f4       	brne	.+56     	; 0x2d58 <PM_CreateProgrammingPackets+0x1ce>
    2d20:	e1 2c       	mov	r14, r1
    2d22:	f1 2c       	mov	r15, r1
    2d24:	ef ef       	ldi	r30, 0xFF	; 255
    2d26:	0e 2f       	mov	r16, r30
    2d28:	11 2d       	mov	r17, r1
    2d2a:	ea 20       	and	r14, r10
    2d2c:	fb 20       	and	r15, r11
    2d2e:	0c 21       	and	r16, r12
    2d30:	1d 21       	and	r17, r13
    2d32:	e1 14       	cp	r14, r1
    2d34:	f1 04       	cpc	r15, r1
    2d36:	01 05       	cpc	r16, r1
    2d38:	11 05       	cpc	r17, r1
    2d3a:	71 f0       	breq	.+28     	; 0x2d58 <PM_CreateProgrammingPackets+0x1ce>
		{
			USI_SPITransmit(V2P_LOAD_EXTENDED_ADDR_CMD);            // Load extended address command
    2d3c:	8d e4       	ldi	r24, 0x4D	; 77
    2d3e:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
			USI_SPITransmit(0x00);
    2d42:	80 e0       	ldi	r24, 0x00	; 0
    2d44:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
			USI_SPITransmit((BytesRead & 0x00FF0000) >> 16);        // The 3rd byte of the long holds the extended address
    2d48:	c8 01       	movw	r24, r16
    2d4a:	aa 27       	eor	r26, r26
    2d4c:	bb 27       	eor	r27, r27
    2d4e:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
			USI_SPITransmit(0x00);
    2d52:	80 e0       	ldi	r24, 0x00	; 0
    2d54:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <USI_SPITransmit>
		}

		ISPCC_ProgramChip();                                        // Start the program cycle
    2d58:	0e 94 9a 11 	call	0x2334	; 0x2334 <ISPCC_ProgramChip>
    2d5c:	a4 14       	cp	r10, r4
    2d5e:	b5 04       	cpc	r11, r5
    2d60:	c6 04       	cpc	r12, r6
    2d62:	d7 04       	cpc	r13, r7
    2d64:	08 f4       	brcc	.+2      	; 0x2d68 <PM_CreateProgrammingPackets+0x1de>
    2d66:	5e cf       	rjmp	.-324    	; 0x2c24 <PM_CreateProgrammingPackets+0x9a>
    2d68:	19 c0       	rjmp	.+50     	; 0x2d9c <PM_CreateProgrammingPackets+0x212>
eeprom_read_word (const uint16_t *addr)
{
  uint16_t result;

  asm ( 
    2d6a:	a4 e8       	ldi	r26, 0x84	; 132
    2d6c:	b0 e0       	ldi	r27, 0x00	; 0
    2d6e:	0e 94 9c 1a 	call	0x3538	; 0x3538 <__eeprom_read_word_1F2021>
    2d72:	4f 01       	movw	r8, r30
    2d74:	10 92 a9 02 	sts	0x02A9, r1
    2d78:	10 92 aa 02 	sts	0x02AA, r1
    2d7c:	10 92 ab 02 	sts	0x02AB, r1
    2d80:	10 92 ac 02 	sts	0x02AC, r1
    2d84:	60 ee       	ldi	r22, 0xE0	; 224
    2d86:	70 e0       	ldi	r23, 0x00	; 0
    2d88:	84 ee       	ldi	r24, 0xE4	; 228
    2d8a:	93 e0       	ldi	r25, 0x03	; 3
    2d8c:	0e 94 8f 0a 	call	0x151e	; 0x151e <DF_ContinuousReadEnable>
    2d90:	85 e1       	ldi	r24, 0x15	; 21
    2d92:	80 93 91 01 	sts	0x0191, r24
    2d96:	2c e0       	ldi	r18, 0x0C	; 12
    2d98:	30 e0       	ldi	r19, 0x00	; 0
    2d9a:	28 cf       	rjmp	.-432    	; 0x2bec <PM_CreateProgrammingPackets+0x62>
    2d9c:	df 91       	pop	r29
    2d9e:	cf 91       	pop	r28
    2da0:	1f 91       	pop	r17
    2da2:	0f 91       	pop	r16
    2da4:	ff 90       	pop	r15
    2da6:	ef 90       	pop	r14
    2da8:	df 90       	pop	r13
    2daa:	cf 90       	pop	r12
    2dac:	bf 90       	pop	r11
    2dae:	af 90       	pop	r10
    2db0:	9f 90       	pop	r9
    2db2:	8f 90       	pop	r8
    2db4:	7f 90       	pop	r7
    2db6:	6f 90       	pop	r6
    2db8:	5f 90       	pop	r5
    2dba:	4f 90       	pop	r4
    2dbc:	3f 90       	pop	r3
    2dbe:	08 95       	ret

00002dc0 <PM_ShowStoredItemSizes>:
	}
}

void PM_ShowStoredItemSizes(void)
{
    2dc0:	1f 93       	push	r17
    2dc2:	cf 93       	push	r28
    2dc4:	df 93       	push	r29
    2dc6:	cd b7       	in	r28, 0x3d	; 61
    2dc8:	de b7       	in	r29, 0x3e	; 62
    2dca:	2e 97       	sbiw	r28, 0x0e	; 14
    2dcc:	0f b6       	in	r0, 0x3f	; 63
    2dce:	f8 94       	cli
    2dd0:	de bf       	out	0x3e, r29	; 62
    2dd2:	0f be       	out	0x3f, r0	; 63
    2dd4:	cd bf       	out	0x3d, r28	; 61
	uint8_t Buffer[14];
	uint8_t ItemInfoIndex = 0;
	uint8_t TempB;
	
	JoyStatus = 1;
    2dd6:	81 e0       	ldi	r24, 0x01	; 1
    2dd8:	8e bb       	out	0x1e, r24	; 30
    2dda:	10 e0       	ldi	r17, 0x00	; 0
	
	for (;;)
	{
		if (JoyStatus)                           // Joystick is in the non-center position
    2ddc:	8e b3       	in	r24, 0x1e	; 30
    2dde:	88 23       	and	r24, r24
    2de0:	e9 f3       	breq	.-6      	; 0x2ddc <PM_ShowStoredItemSizes+0x1c>
		{
			if (JoyStatus & JOY_UP)              // Previous item
    2de2:	f6 9b       	sbis	0x1e, 6	; 30
    2de4:	04 c0       	rjmp	.+8      	; 0x2dee <PM_ShowStoredItemSizes+0x2e>
				(ItemInfoIndex == 0)? ItemInfoIndex = 3 : ItemInfoIndex--;
    2de6:	11 23       	and	r17, r17
    2de8:	81 f1       	breq	.+96     	; 0x2e4a <PM_ShowStoredItemSizes+0x8a>
    2dea:	11 50       	subi	r17, 0x01	; 1
    2dec:	0a c0       	rjmp	.+20     	; 0x2e02 <PM_ShowStoredItemSizes+0x42>
			else if (JoyStatus & JOY_DOWN)      // Next item
    2dee:	f7 9b       	sbis	0x1e, 7	; 30
    2df0:	06 c0       	rjmp	.+12     	; 0x2dfe <PM_ShowStoredItemSizes+0x3e>
				(ItemInfoIndex == 3)? ItemInfoIndex = 0 : ItemInfoIndex++;
    2df2:	13 30       	cpi	r17, 0x03	; 3
    2df4:	11 f4       	brne	.+4      	; 0x2dfa <PM_ShowStoredItemSizes+0x3a>
    2df6:	10 e0       	ldi	r17, 0x00	; 0
    2df8:	0d c0       	rjmp	.+26     	; 0x2e14 <PM_ShowStoredItemSizes+0x54>
    2dfa:	1f 5f       	subi	r17, 0xFF	; 255
    2dfc:	02 c0       	rjmp	.+4      	; 0x2e02 <PM_ShowStoredItemSizes+0x42>
			else if (JoyStatus & JOY_LEFT)
    2dfe:	f2 99       	sbic	0x1e, 2	; 30
    2e00:	49 c0       	rjmp	.+146    	; 0x2e94 <PM_ShowStoredItemSizes+0xd4>
				return;
		
			switch (ItemInfoIndex)
    2e02:	11 30       	cpi	r17, 0x01	; 1
    2e04:	79 f0       	breq	.+30     	; 0x2e24 <PM_ShowStoredItemSizes+0x64>
    2e06:	11 30       	cpi	r17, 0x01	; 1
    2e08:	28 f0       	brcs	.+10     	; 0x2e14 <PM_ShowStoredItemSizes+0x54>
    2e0a:	12 30       	cpi	r17, 0x02	; 2
    2e0c:	a9 f0       	breq	.+42     	; 0x2e38 <PM_ShowStoredItemSizes+0x78>
    2e0e:	13 30       	cpi	r17, 0x03	; 3
    2e10:	d1 f5       	brne	.+116    	; 0x2e86 <PM_ShowStoredItemSizes+0xc6>
    2e12:	1c c0       	rjmp	.+56     	; 0x2e4c <PM_ShowStoredItemSizes+0x8c>
			{
				case 0:
					strcpy_P(Buffer, PSTR("DATA-"));
    2e14:	68 e5       	ldi	r22, 0x58	; 88
    2e16:	74 e0       	ldi	r23, 0x04	; 4
    2e18:	ce 01       	movw	r24, r28
    2e1a:	01 96       	adiw	r24, 0x01	; 1
    2e1c:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_FLASH), &Buffer[5], 10);
    2e20:	81 e0       	ldi	r24, 0x01	; 1
    2e22:	07 c0       	rjmp	.+14     	; 0x2e32 <PM_ShowStoredItemSizes+0x72>
					break;
				case 1:
					strcpy_P(Buffer, PSTR("EPRM-"));
    2e24:	62 e5       	ldi	r22, 0x52	; 82
    2e26:	74 e0       	ldi	r23, 0x04	; 4
    2e28:	ce 01       	movw	r24, r28
    2e2a:	01 96       	adiw	r24, 0x01	; 1
    2e2c:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <strcpy_P>
					ultoa(PM_GetStoredDataSize(TYPE_EEPROM), &Buffer[5], 10);
    2e30:	80 e0       	ldi	r24, 0x00	; 0
    2e32:	0e 94 f7 14 	call	0x29ee	; 0x29ee <PM_GetStoredDataSize>
    2e36:	20 c0       	rjmp	.+64     	; 0x2e78 <PM_ShowStoredItemSizes+0xb8>
					break;
				case 2:
					strcpy_P(Buffer, PSTR("FUSE-"));
    2e38:	6c e4       	ldi	r22, 0x4C	; 76
    2e3a:	74 e0       	ldi	r23, 0x04	; 4
    2e3c:	ce 01       	movw	r24, r28
    2e3e:	01 96       	adiw	r24, 0x01	; 1
    2e40:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <strcpy_P>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2e44:	a0 e3       	ldi	r26, 0x30	; 48
    2e46:	b0 e0       	ldi	r27, 0x00	; 0
    2e48:	09 c0       	rjmp	.+18     	; 0x2e5c <PM_ShowStoredItemSizes+0x9c>
					TempB = eeprom_read_byte(&EEPROMVars.TotalFuseBytes);
					ultoa(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5], 10);
					break;
    2e4a:	13 e0       	ldi	r17, 0x03	; 3
				case 3:
					strcpy_P(Buffer, PSTR("LOCK-"));
    2e4c:	66 e4       	ldi	r22, 0x46	; 70
    2e4e:	74 e0       	ldi	r23, 0x04	; 4
    2e50:	ce 01       	movw	r24, r28
    2e52:	01 96       	adiw	r24, 0x01	; 1
    2e54:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <strcpy_P>
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    2e58:	a1 e3       	ldi	r26, 0x31	; 49
    2e5a:	b0 e0       	ldi	r27, 0x00	; 0
    2e5c:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
    2e60:	80 2d       	mov	r24, r0
					TempB = eeprom_read_byte(&EEPROMVars.TotalLockBytes);
					ultoa(((TempB == 0xFF)? 0x00 : TempB), &Buffer[5], 10);
    2e62:	8f 3f       	cpi	r24, 0xFF	; 255
    2e64:	29 f4       	brne	.+10     	; 0x2e70 <PM_ShowStoredItemSizes+0xb0>
    2e66:	60 e0       	ldi	r22, 0x00	; 0
    2e68:	70 e0       	ldi	r23, 0x00	; 0
    2e6a:	80 e0       	ldi	r24, 0x00	; 0
    2e6c:	90 e0       	ldi	r25, 0x00	; 0
    2e6e:	04 c0       	rjmp	.+8      	; 0x2e78 <PM_ShowStoredItemSizes+0xb8>
    2e70:	68 2f       	mov	r22, r24
    2e72:	77 27       	eor	r23, r23
    2e74:	88 27       	eor	r24, r24
    2e76:	99 27       	eor	r25, r25
    2e78:	2a e0       	ldi	r18, 0x0A	; 10
    2e7a:	30 e0       	ldi	r19, 0x00	; 0
    2e7c:	ae 01       	movw	r20, r28
    2e7e:	4a 5f       	subi	r20, 0xFA	; 250
    2e80:	5f 4f       	sbci	r21, 0xFF	; 255
    2e82:	0e 94 5a 1a 	call	0x34b4	; 0x34b4 <ultoa>
			}
	
			LCD_puts(Buffer);
    2e86:	ce 01       	movw	r24, r28
    2e88:	01 96       	adiw	r24, 0x01	; 1
    2e8a:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>

			MAIN_WaitForJoyRelease();
    2e8e:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
    2e92:	a4 cf       	rjmp	.-184    	; 0x2ddc <PM_ShowStoredItemSizes+0x1c>
    2e94:	2e 96       	adiw	r28, 0x0e	; 14
    2e96:	0f b6       	in	r0, 0x3f	; 63
    2e98:	f8 94       	cli
    2e9a:	de bf       	out	0x3e, r29	; 62
    2e9c:	0f be       	out	0x3f, r0	; 63
    2e9e:	cd bf       	out	0x3d, r28	; 61
    2ea0:	df 91       	pop	r29
    2ea2:	cf 91       	pop	r28
    2ea4:	1f 91       	pop	r17
    2ea6:	08 95       	ret

00002ea8 <PM_InterpretAVRISPPacket>:
    2ea8:	ef 92       	push	r14
    2eaa:	ff 92       	push	r15
    2eac:	0f 93       	push	r16
    2eae:	1f 93       	push	r17
    2eb0:	cf 93       	push	r28
    2eb2:	df 93       	push	r29
    2eb4:	20 91 91 01 	lds	r18, 0x0191
    2eb8:	26 31       	cpi	r18, 0x16	; 22
    2eba:	09 f4       	brne	.+2      	; 0x2ebe <PM_InterpretAVRISPPacket+0x16>
    2ebc:	ad c1       	rjmp	.+858    	; 0x3218 <PM_InterpretAVRISPPacket+0x370>
    2ebe:	27 31       	cpi	r18, 0x17	; 23
    2ec0:	78 f4       	brcc	.+30     	; 0x2ee0 <PM_InterpretAVRISPPacket+0x38>
    2ec2:	22 31       	cpi	r18, 0x12	; 18
    2ec4:	09 f4       	brne	.+2      	; 0x2ec8 <PM_InterpretAVRISPPacket+0x20>
    2ec6:	5f c0       	rjmp	.+190    	; 0x2f86 <PM_InterpretAVRISPPacket+0xde>
    2ec8:	23 31       	cpi	r18, 0x13	; 19
    2eca:	30 f4       	brcc	.+12     	; 0x2ed8 <PM_InterpretAVRISPPacket+0x30>
    2ecc:	20 31       	cpi	r18, 0x10	; 16
    2ece:	e9 f0       	breq	.+58     	; 0x2f0a <PM_InterpretAVRISPPacket+0x62>
    2ed0:	21 31       	cpi	r18, 0x11	; 17
    2ed2:	09 f0       	breq	.+2      	; 0x2ed6 <PM_InterpretAVRISPPacket+0x2e>
    2ed4:	07 c2       	rjmp	.+1038   	; 0x32e4 <PM_InterpretAVRISPPacket+0x43c>
    2ed6:	37 c0       	rjmp	.+110    	; 0x2f46 <PM_InterpretAVRISPPacket+0x9e>
    2ed8:	24 31       	cpi	r18, 0x14	; 20
    2eda:	09 f0       	breq	.+2      	; 0x2ede <PM_InterpretAVRISPPacket+0x36>
    2edc:	35 c1       	rjmp	.+618    	; 0x3148 <PM_InterpretAVRISPPacket+0x2a0>
    2ede:	9c c1       	rjmp	.+824    	; 0x3218 <PM_InterpretAVRISPPacket+0x370>
    2ee0:	29 31       	cpi	r18, 0x19	; 25
    2ee2:	09 f4       	brne	.+2      	; 0x2ee6 <PM_InterpretAVRISPPacket+0x3e>
    2ee4:	de c0       	rjmp	.+444    	; 0x30a2 <PM_InterpretAVRISPPacket+0x1fa>
    2ee6:	2a 31       	cpi	r18, 0x1A	; 26
    2ee8:	38 f4       	brcc	.+14     	; 0x2ef8 <PM_InterpretAVRISPPacket+0x50>
    2eea:	27 31       	cpi	r18, 0x17	; 23
    2eec:	09 f4       	brne	.+2      	; 0x2ef0 <PM_InterpretAVRISPPacket+0x48>
    2eee:	d9 c0       	rjmp	.+434    	; 0x30a2 <PM_InterpretAVRISPPacket+0x1fa>
    2ef0:	28 31       	cpi	r18, 0x18	; 24
    2ef2:	09 f0       	breq	.+2      	; 0x2ef6 <PM_InterpretAVRISPPacket+0x4e>
    2ef4:	f7 c1       	rjmp	.+1006   	; 0x32e4 <PM_InterpretAVRISPPacket+0x43c>
    2ef6:	83 c0       	rjmp	.+262    	; 0x2ffe <PM_InterpretAVRISPPacket+0x156>
    2ef8:	2b 31       	cpi	r18, 0x1B	; 27
    2efa:	c9 f1       	breq	.+114    	; 0x2f6e <PM_InterpretAVRISPPacket+0xc6>
    2efc:	2b 31       	cpi	r18, 0x1B	; 27
    2efe:	08 f4       	brcc	.+2      	; 0x2f02 <PM_InterpretAVRISPPacket+0x5a>
    2f00:	7e c0       	rjmp	.+252    	; 0x2ffe <PM_InterpretAVRISPPacket+0x156>
    2f02:	2c 31       	cpi	r18, 0x1C	; 28
    2f04:	09 f0       	breq	.+2      	; 0x2f08 <PM_InterpretAVRISPPacket+0x60>
    2f06:	ee c1       	rjmp	.+988    	; 0x32e4 <PM_InterpretAVRISPPacket+0x43c>
    2f08:	6d c0       	rjmp	.+218    	; 0x2fe4 <PM_InterpretAVRISPPacket+0x13c>
    2f0a:	82 e0       	ldi	r24, 0x02	; 2
    2f0c:	90 e0       	ldi	r25, 0x00	; 0
    2f0e:	90 93 a7 02 	sts	0x02A7, r25
    2f12:	80 93 a6 02 	sts	0x02A6, r24
    2f16:	e1 e9       	ldi	r30, 0x91	; 145
    2f18:	f1 e0       	ldi	r31, 0x01	; 1
    2f1a:	24 e2       	ldi	r18, 0x24	; 36
    2f1c:	30 e0       	ldi	r19, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2f1e:	81 91       	ld	r24, Z+
    2f20:	d9 01       	movw	r26, r18
    2f22:	08 2e       	mov	r0, r24
    2f24:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
    2f28:	2f 5f       	subi	r18, 0xFF	; 255
    2f2a:	3f 4f       	sbci	r19, 0xFF	; 255
    2f2c:	81 e0       	ldi	r24, 0x01	; 1
    2f2e:	ed 39       	cpi	r30, 0x9D	; 157
    2f30:	f8 07       	cpc	r31, r24
    2f32:	a9 f7       	brne	.-22     	; 0x2f1e <PM_InterpretAVRISPPacket+0x76>
    2f34:	81 e0       	ldi	r24, 0x01	; 1
    2f36:	80 93 a8 02 	sts	0x02A8, r24
    2f3a:	10 92 ae 02 	sts	0x02AE, r1
    2f3e:	81 b3       	in	r24, 0x11	; 17
    2f40:	8f 7c       	andi	r24, 0xCF	; 207
    2f42:	80 62       	ori	r24, 0x20	; 32
    2f44:	10 c0       	rjmp	.+32     	; 0x2f66 <PM_InterpretAVRISPPacket+0xbe>
    2f46:	82 e0       	ldi	r24, 0x02	; 2
    2f48:	90 e0       	ldi	r25, 0x00	; 0
    2f4a:	90 93 a7 02 	sts	0x02A7, r25
    2f4e:	80 93 a6 02 	sts	0x02A6, r24
    2f52:	0e 94 8d 14 	call	0x291a	; 0x291a <PM_CheckEndOfFuseLockData>
    2f56:	10 92 a8 02 	sts	0x02A8, r1
    2f5a:	80 e0       	ldi	r24, 0x00	; 0
    2f5c:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    2f60:	81 b3       	in	r24, 0x11	; 17
    2f62:	8f 7c       	andi	r24, 0xCF	; 207
    2f64:	80 61       	ori	r24, 0x10	; 16
    2f66:	81 bb       	out	0x11, r24	; 17
    2f68:	10 92 92 01 	sts	0x0192, r1
    2f6c:	c4 c1       	rjmp	.+904    	; 0x32f6 <PM_InterpretAVRISPPacket+0x44e>
    2f6e:	84 e0       	ldi	r24, 0x04	; 4
    2f70:	90 e0       	ldi	r25, 0x00	; 0
    2f72:	90 93 a7 02 	sts	0x02A7, r25
    2f76:	80 93 a6 02 	sts	0x02A6, r24
    2f7a:	10 92 92 01 	sts	0x0192, r1
    2f7e:	81 e0       	ldi	r24, 0x01	; 1
    2f80:	80 93 93 01 	sts	0x0193, r24
    2f84:	39 c0       	rjmp	.+114    	; 0x2ff8 <PM_InterpretAVRISPPacket+0x150>
    2f86:	82 e0       	ldi	r24, 0x02	; 2
    2f88:	90 e0       	ldi	r25, 0x00	; 0
    2f8a:	90 93 a7 02 	sts	0x02A7, r25
    2f8e:	80 93 a6 02 	sts	0x02A6, r24
    2f92:	e2 e9       	ldi	r30, 0x92	; 146
    2f94:	f1 e0       	ldi	r31, 0x01	; 1
    2f96:	27 e1       	ldi	r18, 0x17	; 23
    2f98:	30 e0       	ldi	r19, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2f9a:	81 91       	ld	r24, Z+
    2f9c:	d9 01       	movw	r26, r18
    2f9e:	08 2e       	mov	r0, r24
    2fa0:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
    2fa4:	2f 5f       	subi	r18, 0xFF	; 255
    2fa6:	3f 4f       	sbci	r19, 0xFF	; 255
    2fa8:	91 e0       	ldi	r25, 0x01	; 1
    2faa:	e8 39       	cpi	r30, 0x98	; 152
    2fac:	f9 07       	cpc	r31, r25
    2fae:	a9 f7       	brne	.-22     	; 0x2f9a <PM_InterpretAVRISPPacket+0xf2>
    2fb0:	2c e1       	ldi	r18, 0x1C	; 28
    2fb2:	30 e0       	ldi	r19, 0x00	; 0
    2fb4:	80 e0       	ldi	r24, 0x00	; 0

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2fb6:	d9 01       	movw	r26, r18
    2fb8:	08 2e       	mov	r0, r24
    2fba:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
    2fbe:	d9 01       	movw	r26, r18
    2fc0:	14 96       	adiw	r26, 0x04	; 4
    2fc2:	08 2e       	mov	r0, r24
    2fc4:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
    2fc8:	2f 5f       	subi	r18, 0xFF	; 255
    2fca:	3f 4f       	sbci	r19, 0xFF	; 255
    2fcc:	e0 e0       	ldi	r30, 0x00	; 0
    2fce:	24 32       	cpi	r18, 0x24	; 36
    2fd0:	3e 07       	cpc	r19, r30
    2fd2:	89 f7       	brne	.-30     	; 0x2fb6 <PM_InterpretAVRISPPacket+0x10e>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    2fd4:	81 e0       	ldi	r24, 0x01	; 1
    2fd6:	2f 50       	subi	r18, 0x0F	; 15
    2fd8:	30 40       	sbci	r19, 0x00	; 0
    2fda:	d9 01       	movw	r26, r18
    2fdc:	08 2e       	mov	r0, r24
    2fde:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
    2fe2:	c2 cf       	rjmp	.-124    	; 0x2f68 <PM_InterpretAVRISPPacket+0xc0>
    2fe4:	84 e0       	ldi	r24, 0x04	; 4
    2fe6:	90 e0       	ldi	r25, 0x00	; 0
    2fe8:	90 93 a7 02 	sts	0x02A7, r25
    2fec:	80 93 a6 02 	sts	0x02A6, r24
    2ff0:	10 92 92 01 	sts	0x0192, r1
    2ff4:	10 92 93 01 	sts	0x0193, r1
    2ff8:	10 92 94 01 	sts	0x0194, r1
    2ffc:	7c c1       	rjmp	.+760    	; 0x32f6 <PM_InterpretAVRISPPacket+0x44e>
    2ffe:	84 e0       	ldi	r24, 0x04	; 4
    3000:	90 e0       	ldi	r25, 0x00	; 0
    3002:	90 93 a7 02 	sts	0x02A7, r25
    3006:	80 93 a6 02 	sts	0x02A6, r24
    300a:	80 91 ae 02 	lds	r24, 0x02AE
    300e:	84 30       	cpi	r24, 0x04	; 4
    3010:	49 f0       	breq	.+18     	; 0x3024 <PM_InterpretAVRISPPacket+0x17c>
    3012:	0e 94 8d 14 	call	0x291a	; 0x291a <PM_CheckEndOfFuseLockData>
    3016:	10 92 46 01 	sts	0x0146, r1
    301a:	10 92 45 01 	sts	0x0145, r1
    301e:	84 e0       	ldi	r24, 0x04	; 4
    3020:	80 93 ae 02 	sts	0x02AE, r24
    3024:	40 91 45 01 	lds	r20, 0x0145
    3028:	50 91 46 01 	lds	r21, 0x0146
    302c:	20 91 91 01 	lds	r18, 0x0191
    3030:	28 31       	cpi	r18, 0x18	; 24
    3032:	19 f0       	breq	.+6      	; 0x303a <PM_InterpretAVRISPPacket+0x192>
    3034:	a1 e3       	ldi	r26, 0x31	; 49
    3036:	b0 e0       	ldi	r27, 0x00	; 0
    3038:	02 c0       	rjmp	.+4      	; 0x303e <PM_InterpretAVRISPPacket+0x196>
    303a:	a0 e3       	ldi	r26, 0x30	; 48
    303c:	b0 e0       	ldi	r27, 0x00	; 0
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    303e:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
    3042:	80 2d       	mov	r24, r0
    3044:	99 27       	eor	r25, r25
    3046:	84 17       	cp	r24, r20
    3048:	95 07       	cpc	r25, r21
    304a:	10 f4       	brcc	.+4      	; 0x3050 <PM_InterpretAVRISPPacket+0x1a8>
    304c:	8f ef       	ldi	r24, 0xFF	; 255
    304e:	1e c0       	rjmp	.+60     	; 0x308c <PM_InterpretAVRISPPacket+0x1e4>
    3050:	28 31       	cpi	r18, 0x18	; 24
    3052:	19 f4       	brne	.+6      	; 0x305a <PM_InterpretAVRISPPacket+0x1b2>
    3054:	22 e3       	ldi	r18, 0x32	; 50
    3056:	30 e0       	ldi	r19, 0x00	; 0
    3058:	02 c0       	rjmp	.+4      	; 0x305e <PM_InterpretAVRISPPacket+0x1b6>
    305a:	2a e5       	ldi	r18, 0x5A	; 90
    305c:	30 e0       	ldi	r19, 0x00	; 0
    305e:	80 ea       	ldi	r24, 0xA0	; 160
    3060:	90 e0       	ldi	r25, 0x00	; 0
    3062:	48 9f       	mul	r20, r24
    3064:	d0 01       	movw	r26, r0
    3066:	49 9f       	mul	r20, r25
    3068:	b0 0d       	add	r27, r0
    306a:	58 9f       	mul	r21, r24
    306c:	b0 0d       	add	r27, r0
    306e:	11 24       	eor	r1, r1
    3070:	a2 0f       	add	r26, r18
    3072:	b3 1f       	adc	r27, r19
    3074:	80 91 92 01 	lds	r24, 0x0192
    3078:	28 e2       	ldi	r18, 0x28	; 40
    307a:	82 9f       	mul	r24, r18
    307c:	c0 01       	movw	r24, r0
    307e:	11 24       	eor	r1, r1
    3080:	a8 0f       	add	r26, r24
    3082:	b9 1f       	adc	r27, r25
    3084:	98 97       	sbiw	r26, 0x28	; 40
uint8_t 
eeprom_read_byte (const uint8_t *addr) 
{
  uint8_t result;
  asm volatile
    3086:	0e 94 8f 1a 	call	0x351e	; 0x351e <__eeprom_read_byte_1F2021>
    308a:	80 2d       	mov	r24, r0
    308c:	80 93 93 01 	sts	0x0193, r24
    3090:	4f 5f       	subi	r20, 0xFF	; 255
    3092:	5f 4f       	sbci	r21, 0xFF	; 255
    3094:	50 93 46 01 	sts	0x0146, r21
    3098:	40 93 45 01 	sts	0x0145, r20
    309c:	10 92 92 01 	sts	0x0192, r1
    30a0:	ab cf       	rjmp	.-170    	; 0x2ff8 <PM_InterpretAVRISPPacket+0x150>
    30a2:	83 e0       	ldi	r24, 0x03	; 3
    30a4:	90 e0       	ldi	r25, 0x00	; 0
    30a6:	90 93 a7 02 	sts	0x02A7, r25
    30aa:	80 93 a6 02 	sts	0x02A6, r24
    30ae:	80 91 ae 02 	lds	r24, 0x02AE
    30b2:	83 30       	cpi	r24, 0x03	; 3
    30b4:	39 f0       	breq	.+14     	; 0x30c4 <PM_InterpretAVRISPPacket+0x21c>
    30b6:	83 e0       	ldi	r24, 0x03	; 3
    30b8:	80 93 ae 02 	sts	0x02AE, r24
    30bc:	10 92 46 01 	sts	0x0146, r1
    30c0:	10 92 45 01 	sts	0x0145, r1
    30c4:	40 91 45 01 	lds	r20, 0x0145
    30c8:	50 91 46 01 	lds	r21, 0x0146
    30cc:	27 31       	cpi	r18, 0x17	; 23
    30ce:	69 f4       	brne	.+26     	; 0x30ea <PM_InterpretAVRISPPacket+0x242>
    30d0:	80 ea       	ldi	r24, 0xA0	; 160
    30d2:	90 e0       	ldi	r25, 0x00	; 0
    30d4:	48 9f       	mul	r20, r24
    30d6:	90 01       	movw	r18, r0
    30d8:	49 9f       	mul	r20, r25
    30da:	30 0d       	add	r19, r0
    30dc:	58 9f       	mul	r21, r24
    30de:	30 0d       	add	r19, r0
    30e0:	11 24       	eor	r1, r1
    30e2:	2e 5c       	subi	r18, 0xCE	; 206
    30e4:	3f 4f       	sbci	r19, 0xFF	; 255
    30e6:	82 e0       	ldi	r24, 0x02	; 2
    30e8:	0c c0       	rjmp	.+24     	; 0x3102 <PM_InterpretAVRISPPacket+0x25a>
    30ea:	80 ea       	ldi	r24, 0xA0	; 160
    30ec:	90 e0       	ldi	r25, 0x00	; 0
    30ee:	48 9f       	mul	r20, r24
    30f0:	90 01       	movw	r18, r0
    30f2:	49 9f       	mul	r20, r25
    30f4:	30 0d       	add	r19, r0
    30f6:	58 9f       	mul	r21, r24
    30f8:	30 0d       	add	r19, r0
    30fa:	11 24       	eor	r1, r1
    30fc:	26 5a       	subi	r18, 0xA6	; 166
    30fe:	3f 4f       	sbci	r19, 0xFF	; 255
    3100:	83 e0       	ldi	r24, 0x03	; 3
    3102:	80 93 02 01 	sts	0x0102, r24
    3106:	80 91 45 01 	lds	r24, 0x0145
    310a:	90 91 46 01 	lds	r25, 0x0146
    310e:	0a 97       	sbiw	r24, 0x0a	; 10
    3110:	b0 f4       	brcc	.+44     	; 0x313e <PM_InterpretAVRISPPacket+0x296>
    3112:	e2 e9       	ldi	r30, 0x92	; 146
    3114:	f1 e0       	ldi	r31, 0x01	; 1

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    3116:	81 91       	ld	r24, Z+
    3118:	d9 01       	movw	r26, r18
    311a:	08 2e       	mov	r0, r24
    311c:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
    3120:	2f 5f       	subi	r18, 0xFF	; 255
    3122:	3f 4f       	sbci	r19, 0xFF	; 255
    3124:	81 e0       	ldi	r24, 0x01	; 1
    3126:	e6 39       	cpi	r30, 0x96	; 150
    3128:	f8 07       	cpc	r31, r24
    312a:	a9 f7       	brne	.-22     	; 0x3116 <PM_InterpretAVRISPPacket+0x26e>
    312c:	80 91 45 01 	lds	r24, 0x0145
    3130:	90 91 46 01 	lds	r25, 0x0146
    3134:	01 96       	adiw	r24, 0x01	; 1
    3136:	90 93 46 01 	sts	0x0146, r25
    313a:	80 93 45 01 	sts	0x0145, r24
    313e:	10 92 92 01 	sts	0x0192, r1
    3142:	10 92 93 01 	sts	0x0193, r1
    3146:	d7 c0       	rjmp	.+430    	; 0x32f6 <PM_InterpretAVRISPPacket+0x44e>
    3148:	82 e0       	ldi	r24, 0x02	; 2
    314a:	90 e0       	ldi	r25, 0x00	; 0
    314c:	90 93 a7 02 	sts	0x02A7, r25
    3150:	80 93 a6 02 	sts	0x02A6, r24
    3154:	80 91 ae 02 	lds	r24, 0x02AE
    3158:	81 30       	cpi	r24, 0x01	; 1
    315a:	09 f1       	breq	.+66     	; 0x319e <PM_InterpretAVRISPPacket+0x2f6>
    315c:	23 31       	cpi	r18, 0x13	; 19
    315e:	31 f4       	brne	.+12     	; 0x316c <PM_InterpretAVRISPPacket+0x2c4>
    3160:	81 e0       	ldi	r24, 0x01	; 1
    3162:	0e 94 52 14 	call	0x28a4	; 0x28a4 <PM_SetupDFAddressCounters>
    3166:	c3 e0       	ldi	r28, 0x03	; 3
    3168:	d0 e0       	ldi	r29, 0x00	; 0
    316a:	05 c0       	rjmp	.+10     	; 0x3176 <PM_InterpretAVRISPPacket+0x2ce>
    316c:	80 e0       	ldi	r24, 0x00	; 0
    316e:	0e 94 52 14 	call	0x28a4	; 0x28a4 <PM_SetupDFAddressCounters>
    3172:	cc e0       	ldi	r28, 0x0C	; 12
    3174:	d0 e0       	ldi	r29, 0x00	; 0
    3176:	80 91 45 01 	lds	r24, 0x0145
    317a:	90 91 46 01 	lds	r25, 0x0146
    317e:	0e 94 ca 0a 	call	0x1594	; 0x1594 <DF_BufferWriteEnable>
    3182:	81 e0       	ldi	r24, 0x01	; 1
    3184:	80 93 ae 02 	sts	0x02AE, r24
    3188:	e2 e9       	ldi	r30, 0x92	; 146
    318a:	f1 e0       	ldi	r31, 0x01	; 1

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  asm volatile (
    318c:	81 91       	ld	r24, Z+
    318e:	de 01       	movw	r26, r28
    3190:	08 2e       	mov	r0, r24
    3192:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__eeprom_write_byte_1F2021>
    3196:	91 e0       	ldi	r25, 0x01	; 1
    3198:	eb 39       	cpi	r30, 0x9B	; 155
    319a:	f9 07       	cpc	r31, r25
    319c:	b9 f7       	brne	.-18     	; 0x318c <PM_InterpretAVRISPPacket+0x2e4>
    319e:	80 91 92 01 	lds	r24, 0x0192
    31a2:	99 27       	eor	r25, r25
    31a4:	d8 2f       	mov	r29, r24
    31a6:	cc 27       	eor	r28, r28
    31a8:	80 91 93 01 	lds	r24, 0x0193
    31ac:	99 27       	eor	r25, r25
    31ae:	c8 2b       	or	r28, r24
    31b0:	d9 2b       	or	r29, r25
    31b2:	01 e9       	ldi	r16, 0x91	; 145
    31b4:	11 e0       	ldi	r17, 0x01	; 1
    31b6:	06 c0       	rjmp	.+12     	; 0x31c4 <PM_InterpretAVRISPPacket+0x31c>
    31b8:	f8 01       	movw	r30, r16
    31ba:	82 85       	ldd	r24, Z+10	; 0x0a
    31bc:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <PM_StoreProgramByte>
    31c0:	0f 5f       	subi	r16, 0xFF	; 255
    31c2:	1f 4f       	sbci	r17, 0xFF	; 255
    31c4:	ce 01       	movw	r24, r28
    31c6:	8f 56       	subi	r24, 0x6F	; 111
    31c8:	9e 4f       	sbci	r25, 0xFE	; 254
    31ca:	08 17       	cp	r16, r24
    31cc:	19 07       	cpc	r17, r25
    31ce:	a1 f7       	brne	.-24     	; 0x31b8 <PM_InterpretAVRISPPacket+0x310>
    31d0:	20 91 af 02 	lds	r18, 0x02AF
    31d4:	30 91 b0 02 	lds	r19, 0x02B0
    31d8:	37 fd       	sbrc	r19, 7
    31da:	c6 ce       	rjmp	.-628    	; 0x2f68 <PM_InterpretAVRISPPacket+0xc0>
    31dc:	80 91 94 01 	lds	r24, 0x0194
    31e0:	87 ff       	sbrs	r24, 7
    31e2:	c2 ce       	rjmp	.-636    	; 0x2f68 <PM_InterpretAVRISPPacket+0xc0>
    31e4:	21 15       	cp	r18, r1
    31e6:	31 05       	cpc	r19, r1
    31e8:	09 f4       	brne	.+2      	; 0x31ec <PM_InterpretAVRISPPacket+0x344>
    31ea:	be ce       	rjmp	.-644    	; 0x2f68 <PM_InterpretAVRISPPacket+0xc0>
    31ec:	80 91 02 01 	lds	r24, 0x0102
    31f0:	81 30       	cpi	r24, 0x01	; 1
    31f2:	19 f4       	brne	.+6      	; 0x31fa <PM_InterpretAVRISPPacket+0x352>
    31f4:	a2 e8       	ldi	r26, 0x82	; 130
    31f6:	b0 e0       	ldi	r27, 0x00	; 0
    31f8:	02 c0       	rjmp	.+4      	; 0x31fe <PM_InterpretAVRISPPacket+0x356>
    31fa:	a4 e8       	ldi	r26, 0x84	; 132
    31fc:	b0 e0       	ldi	r27, 0x00	; 0

void 
eeprom_write_word (uint16_t *addr,uint16_t value)
{
  asm volatile (
    31fe:	09 01       	movw	r0, r18
    3200:	0e 94 ad 1a 	call	0x355a	; 0x355a <__eeprom_write_word_1F2021>
    3204:	80 91 af 02 	lds	r24, 0x02AF
    3208:	90 91 b0 02 	lds	r25, 0x02B0
    320c:	90 68       	ori	r25, 0x80	; 128
    320e:	90 93 b0 02 	sts	0x02B0, r25
    3212:	80 93 af 02 	sts	0x02AF, r24
    3216:	a8 ce       	rjmp	.-688    	; 0x2f68 <PM_InterpretAVRISPPacket+0xc0>
    3218:	80 91 ae 02 	lds	r24, 0x02AE
    321c:	82 30       	cpi	r24, 0x02	; 2
    321e:	01 f1       	breq	.+64     	; 0x3260 <PM_InterpretAVRISPPacket+0x3b8>
    3220:	0e 94 8d 14 	call	0x291a	; 0x291a <PM_CheckEndOfFuseLockData>
    3224:	90 e0       	ldi	r25, 0x00	; 0
    3226:	80 91 91 01 	lds	r24, 0x0191
    322a:	84 31       	cpi	r24, 0x14	; 20
    322c:	09 f4       	brne	.+2      	; 0x3230 <PM_InterpretAVRISPPacket+0x388>
    322e:	91 e0       	ldi	r25, 0x01	; 1
    3230:	89 2f       	mov	r24, r25
    3232:	0e 94 52 14 	call	0x28a4	; 0x28a4 <PM_SetupDFAddressCounters>
    3236:	60 91 45 01 	lds	r22, 0x0145
    323a:	70 91 46 01 	lds	r23, 0x0146
    323e:	80 91 43 01 	lds	r24, 0x0143
    3242:	90 91 44 01 	lds	r25, 0x0144
    3246:	0e 94 8f 0a 	call	0x151e	; 0x151e <DF_ContinuousReadEnable>
    324a:	82 e0       	ldi	r24, 0x02	; 2
    324c:	80 93 ae 02 	sts	0x02AE, r24
    3250:	10 92 a9 02 	sts	0x02A9, r1
    3254:	10 92 aa 02 	sts	0x02AA, r1
    3258:	10 92 ab 02 	sts	0x02AB, r1
    325c:	10 92 ac 02 	sts	0x02AC, r1
    3260:	80 91 92 01 	lds	r24, 0x0192
    3264:	99 27       	eor	r25, r25
    3266:	d8 2f       	mov	r29, r24
    3268:	cc 27       	eor	r28, r28
    326a:	80 91 93 01 	lds	r24, 0x0193
    326e:	99 27       	eor	r25, r25
    3270:	c8 2b       	or	r28, r24
    3272:	d9 2b       	or	r29, r25
    3274:	90 e0       	ldi	r25, 0x00	; 0
    3276:	80 91 91 01 	lds	r24, 0x0191
    327a:	84 31       	cpi	r24, 0x14	; 20
    327c:	09 f4       	brne	.+2      	; 0x3280 <PM_InterpretAVRISPPacket+0x3d8>
    327e:	91 e0       	ldi	r25, 0x01	; 1
    3280:	89 2f       	mov	r24, r25
    3282:	0e 94 f7 14 	call	0x29ee	; 0x29ee <PM_GetStoredDataSize>
    3286:	7b 01       	movw	r14, r22
    3288:	01 e9       	ldi	r16, 0x91	; 145
    328a:	11 e0       	ldi	r17, 0x01	; 1
    328c:	1b c0       	rjmp	.+54     	; 0x32c4 <PM_InterpretAVRISPPacket+0x41c>
    328e:	97 01       	movw	r18, r14
    3290:	44 27       	eor	r20, r20
    3292:	55 27       	eor	r21, r21
    3294:	80 91 a9 02 	lds	r24, 0x02A9
    3298:	90 91 aa 02 	lds	r25, 0x02AA
    329c:	a0 91 ab 02 	lds	r26, 0x02AB
    32a0:	b0 91 ac 02 	lds	r27, 0x02AC
    32a4:	82 17       	cp	r24, r18
    32a6:	93 07       	cpc	r25, r19
    32a8:	a4 07       	cpc	r26, r20
    32aa:	b5 07       	cpc	r27, r21
    32ac:	10 f0       	brcs	.+4      	; 0x32b2 <PM_InterpretAVRISPPacket+0x40a>
    32ae:	8f ef       	ldi	r24, 0xFF	; 255
    32b0:	03 c0       	rjmp	.+6      	; 0x32b8 <PM_InterpretAVRISPPacket+0x410>
    32b2:	80 e0       	ldi	r24, 0x00	; 0
    32b4:	0e 94 b1 09 	call	0x1362	; 0x1362 <SPI_SPITransmit>
    32b8:	f8 01       	movw	r30, r16
    32ba:	82 83       	std	Z+2, r24	; 0x02
    32bc:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <V2P_IncrementCurrAddress>
    32c0:	0f 5f       	subi	r16, 0xFF	; 255
    32c2:	1f 4f       	sbci	r17, 0xFF	; 255
    32c4:	ce 01       	movw	r24, r28
    32c6:	8f 56       	subi	r24, 0x6F	; 111
    32c8:	9e 4f       	sbci	r25, 0xFE	; 254
    32ca:	08 17       	cp	r16, r24
    32cc:	19 07       	cpc	r17, r25
    32ce:	f9 f6       	brne	.-66     	; 0x328e <PM_InterpretAVRISPPacket+0x3e6>
    32d0:	23 96       	adiw	r28, 0x03	; 3
    32d2:	d0 93 a7 02 	sts	0x02A7, r29
    32d6:	c0 93 a6 02 	sts	0x02A6, r28
    32da:	10 92 92 01 	sts	0x0192, r1
    32de:	f8 01       	movw	r30, r16
    32e0:	12 82       	std	Z+2, r1	; 0x02
    32e2:	09 c0       	rjmp	.+18     	; 0x32f6 <PM_InterpretAVRISPPacket+0x44e>
    32e4:	81 e0       	ldi	r24, 0x01	; 1
    32e6:	90 e0       	ldi	r25, 0x00	; 0
    32e8:	90 93 a7 02 	sts	0x02A7, r25
    32ec:	80 93 a6 02 	sts	0x02A6, r24
    32f0:	89 ec       	ldi	r24, 0xC9	; 201
    32f2:	80 93 92 01 	sts	0x0192, r24
    32f6:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <V2P_SendPacket>
    32fa:	df 91       	pop	r29
    32fc:	cf 91       	pop	r28
    32fe:	1f 91       	pop	r17
    3300:	0f 91       	pop	r16
    3302:	ff 90       	pop	r15
    3304:	ef 90       	pop	r14
    3306:	08 95       	ret

00003308 <TM_FindNextTag>:
	DF_EnableDataflash(FALSE);
}

void TM_FindNextTag(void)
{
    3308:	cf 92       	push	r12
    330a:	df 92       	push	r13
    330c:	ef 92       	push	r14
    330e:	ff 92       	push	r15
    3310:	0f 93       	push	r16
    3312:	1f 93       	push	r17
    3314:	cf 93       	push	r28
    3316:	df 93       	push	r29
    3318:	cd b7       	in	r28, 0x3d	; 61
    331a:	de b7       	in	r29, 0x3e	; 62
    331c:	69 97       	sbiw	r28, 0x19	; 25
    331e:	0f b6       	in	r0, 0x3f	; 63
    3320:	f8 94       	cli
    3322:	de bf       	out	0x3e, r29	; 62
    3324:	0f be       	out	0x3f, r0	; 63
    3326:	cd bf       	out	0x3d, r28	; 61
	uint8_t  Buffer[21];
	uint8_t  HeadBuff[4]      = BT_TAGHEADER;
    3328:	80 e4       	ldi	r24, 0x40	; 64
    332a:	89 83       	std	Y+1, r24	; 0x01
    332c:	88 e2       	ldi	r24, 0x28	; 40
    332e:	8a 83       	std	Y+2, r24	; 0x02
    3330:	83 e2       	ldi	r24, 0x23	; 35
    3332:	8b 83       	std	Y+3, r24	; 0x03
    3334:	89 e2       	ldi	r24, 0x29	; 41
    3336:	8c 83       	std	Y+4, r24	; 0x04
	uint32_t ProgDataSize     = PM_GetStoredDataSize(TYPE_FLASH);
    3338:	81 e0       	ldi	r24, 0x01	; 1
    333a:	0e 94 f7 14 	call	0x29ee	; 0x29ee <PM_GetStoredDataSize>
    333e:	6b 01       	movw	r12, r22
    3340:	7c 01       	movw	r14, r24
	uint8_t  TotalOkHeadBytes = 0;
	uint8_t  TagByte;
	uint8_t  BytesRead;
	
	MAIN_SETSTATUSLED(MAIN_STATLED_ORANGE);    // Orange = busy
    3342:	81 b3       	in	r24, 0x11	; 17
    3344:	8f 7c       	andi	r24, 0xCF	; 207
    3346:	80 63       	ori	r24, 0x30	; 48
    3348:	81 bb       	out	0x11, r24	; 17

	while (DFPos < ProgDataSize)
	{
		BytesRead = 1;
		
		TagByte = SPI_SPITransmit(0x00);       // Get next byte from dataflash
		if (TagByte == HeadBuff[TotalOkHeadBytes++])
		{
			if (TotalOkHeadBytes == 4)
			{
				uint8_t HB;
			
				for (HB = 0; HB < 20; HB++)
				{
					TagByte = SPI_SPITransmit(0x00);
					Buffer[HB] = TagByte;
					
					if (TagByte == 0x00)
					  break;
				}
				
				Buffer[20] = '\0';             // Make sure string is null-terminated

				TagExists = TRUE;
				BytesRead = (HB + 2);

				LCD_puts(Buffer);
				MAIN_SETSTATUSLED(MAIN_STATLED_GREEN); // Green = ready
				return;
			}
		}
		else
		{
			TotalOkHeadBytes = ((TagByte == HeadBuff[0])? 1 : 0);
    334a:	09 81       	ldd	r16, Y+1	; 0x01
    334c:	10 e0       	ldi	r17, 0x00	; 0
    334e:	42 c0       	rjmp	.+132    	; 0x33d4 <TM_FindNextTag+0xcc>
    3350:	80 e0       	ldi	r24, 0x00	; 0
    3352:	0e 94 b1 09 	call	0x1362	; 0x1362 <SPI_SPITransmit>
    3356:	98 2f       	mov	r25, r24
    3358:	fe 01       	movw	r30, r28
    335a:	e1 0f       	add	r30, r17
    335c:	f1 1d       	adc	r31, r1
    335e:	81 81       	ldd	r24, Z+1	; 0x01
    3360:	98 17       	cp	r25, r24
    3362:	09 f5       	brne	.+66     	; 0x33a6 <TM_FindNextTag+0x9e>
    3364:	1f 5f       	subi	r17, 0xFF	; 255
    3366:	14 30       	cpi	r17, 0x04	; 4
    3368:	11 f5       	brne	.+68     	; 0x33ae <TM_FindNextTag+0xa6>
    336a:	8e 01       	movw	r16, r28
    336c:	0b 5f       	subi	r16, 0xFB	; 251
    336e:	1f 4f       	sbci	r17, 0xFF	; 255
    3370:	80 e0       	ldi	r24, 0x00	; 0
    3372:	0e 94 b1 09 	call	0x1362	; 0x1362 <SPI_SPITransmit>
    3376:	f8 01       	movw	r30, r16
    3378:	80 83       	st	Z, r24
    337a:	88 23       	and	r24, r24
    337c:	39 f0       	breq	.+14     	; 0x338c <TM_FindNextTag+0x84>
    337e:	0f 5f       	subi	r16, 0xFF	; 255
    3380:	1f 4f       	sbci	r17, 0xFF	; 255
    3382:	ce 01       	movw	r24, r28
    3384:	49 96       	adiw	r24, 0x19	; 25
    3386:	08 17       	cp	r16, r24
    3388:	19 07       	cpc	r17, r25
    338a:	91 f7       	brne	.-28     	; 0x3370 <TM_FindNextTag+0x68>
    338c:	19 8e       	std	Y+25, r1	; 0x19
    338e:	81 e0       	ldi	r24, 0x01	; 1
    3390:	80 93 b1 02 	sts	0x02B1, r24
    3394:	ce 01       	movw	r24, r28
    3396:	05 96       	adiw	r24, 0x05	; 5
    3398:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_puts>
    339c:	81 b3       	in	r24, 0x11	; 17
    339e:	8f 7c       	andi	r24, 0xCF	; 207
    33a0:	80 61       	ori	r24, 0x10	; 16
    33a2:	81 bb       	out	0x11, r24	; 17
    33a4:	42 c0       	rjmp	.+132    	; 0x342a <TM_FindNextTag+0x122>
    33a6:	10 e0       	ldi	r17, 0x00	; 0
    33a8:	90 17       	cp	r25, r16
    33aa:	09 f4       	brne	.+2      	; 0x33ae <TM_FindNextTag+0xa6>
    33ac:	11 e0       	ldi	r17, 0x01	; 1
		}

		DFPos += BytesRead;
    33ae:	80 91 b2 02 	lds	r24, 0x02B2
    33b2:	90 91 b3 02 	lds	r25, 0x02B3
    33b6:	a0 91 b4 02 	lds	r26, 0x02B4
    33ba:	b0 91 b5 02 	lds	r27, 0x02B5
    33be:	01 96       	adiw	r24, 0x01	; 1
    33c0:	a1 1d       	adc	r26, r1
    33c2:	b1 1d       	adc	r27, r1
    33c4:	80 93 b2 02 	sts	0x02B2, r24
    33c8:	90 93 b3 02 	sts	0x02B3, r25
    33cc:	a0 93 b4 02 	sts	0x02B4, r26
    33d0:	b0 93 b5 02 	sts	0x02B5, r27
    33d4:	80 91 b2 02 	lds	r24, 0x02B2
    33d8:	90 91 b3 02 	lds	r25, 0x02B3
    33dc:	a0 91 b4 02 	lds	r26, 0x02B4
    33e0:	b0 91 b5 02 	lds	r27, 0x02B5
    33e4:	8c 15       	cp	r24, r12
    33e6:	9d 05       	cpc	r25, r13
    33e8:	ae 05       	cpc	r26, r14
    33ea:	bf 05       	cpc	r27, r15
    33ec:	08 f4       	brcc	.+2      	; 0x33f0 <TM_FindNextTag+0xe8>
    33ee:	b0 cf       	rjmp	.-160    	; 0x3350 <TM_FindNextTag+0x48>
	}
	
	DF_ContinuousReadEnable(0, 0);
    33f0:	60 e0       	ldi	r22, 0x00	; 0
    33f2:	70 e0       	ldi	r23, 0x00	; 0
    33f4:	80 e0       	ldi	r24, 0x00	; 0
    33f6:	90 e0       	ldi	r25, 0x00	; 0
    33f8:	0e 94 8f 0a 	call	0x151e	; 0x151e <DF_ContinuousReadEnable>
	DFPos = 0;
    33fc:	10 92 b2 02 	sts	0x02B2, r1
    3400:	10 92 b3 02 	sts	0x02B3, r1
    3404:	10 92 b4 02 	sts	0x02B4, r1
    3408:	10 92 b5 02 	sts	0x02B5, r1
	
	if (TagExists == FALSE)
    340c:	80 91 b1 02 	lds	r24, 0x02B1
    3410:	88 23       	and	r24, r24
    3412:	49 f4       	brne	.+18     	; 0x3426 <TM_FindNextTag+0x11e>
	{
		MAIN_SETSTATUSLED(MAIN_STATLED_GREEN);  // Green = ready
    3414:	81 b3       	in	r24, 0x11	; 17
    3416:	8f 7c       	andi	r24, 0xCF	; 207
    3418:	80 61       	ori	r24, 0x10	; 16
    341a:	81 bb       	out	0x11, r24	; 17
		MAIN_ShowError(PSTR("NO TAGS"));
    341c:	8e e5       	ldi	r24, 0x5E	; 94
    341e:	94 e0       	ldi	r25, 0x04	; 4
    3420:	0e 94 be 03 	call	0x77c	; 0x77c <MAIN_ShowError>
    3424:	02 c0       	rjmp	.+4      	; 0x342a <TM_FindNextTag+0x122>
	}
	else
	{
		/* The following line _is_ recursion, but the function will only ever call itself
		   a maximum of one time. The function will call itself upon skipping from the last
		   tag stored in the program data to the first; to guard against infinite recursion
		   if no tags are present, the system will error out if the TagExists flag is empty
		   after a full data read. Once a tag has been read and displayed onto the LCD, the
           function returns to the main tag handling routine.                               */
		TM_FindNextTag();
    3426:	0e 94 84 19 	call	0x3308	; 0x3308 <TM_FindNextTag>
    342a:	69 96       	adiw	r28, 0x19	; 25
    342c:	0f b6       	in	r0, 0x3f	; 63
    342e:	f8 94       	cli
    3430:	de bf       	out	0x3e, r29	; 62
    3432:	0f be       	out	0x3f, r0	; 63
    3434:	cd bf       	out	0x3d, r28	; 61
    3436:	df 91       	pop	r29
    3438:	cf 91       	pop	r28
    343a:	1f 91       	pop	r17
    343c:	0f 91       	pop	r16
    343e:	ff 90       	pop	r15
    3440:	ef 90       	pop	r14
    3442:	df 90       	pop	r13
    3444:	cf 90       	pop	r12
    3446:	08 95       	ret

00003448 <TM_ShowTags>:
    3448:	60 e0       	ldi	r22, 0x00	; 0
    344a:	70 e0       	ldi	r23, 0x00	; 0
    344c:	80 e0       	ldi	r24, 0x00	; 0
    344e:	90 e0       	ldi	r25, 0x00	; 0
    3450:	0e 94 8f 0a 	call	0x151e	; 0x151e <DF_ContinuousReadEnable>
    3454:	10 92 b1 02 	sts	0x02B1, r1
    3458:	10 92 b2 02 	sts	0x02B2, r1
    345c:	10 92 b3 02 	sts	0x02B3, r1
    3460:	10 92 b4 02 	sts	0x02B4, r1
    3464:	10 92 b5 02 	sts	0x02B5, r1
    3468:	0e 94 84 19 	call	0x3308	; 0x3308 <TM_FindNextTag>
    346c:	80 91 b1 02 	lds	r24, 0x02B1
    3470:	88 23       	and	r24, r24
    3472:	71 f0       	breq	.+28     	; 0x3490 <TM_ShowTags+0x48>
    3474:	8e b3       	in	r24, 0x1e	; 30
    3476:	88 23       	and	r24, r24
    3478:	e9 f3       	breq	.-6      	; 0x3474 <TM_ShowTags+0x2c>
    347a:	f7 9b       	sbis	0x1e, 7	; 30
    347c:	03 c0       	rjmp	.+6      	; 0x3484 <TM_ShowTags+0x3c>
    347e:	0e 94 84 19 	call	0x3308	; 0x3308 <TM_FindNextTag>
    3482:	02 c0       	rjmp	.+4      	; 0x3488 <TM_ShowTags+0x40>
    3484:	f2 99       	sbic	0x1e, 2	; 30
    3486:	03 c0       	rjmp	.+6      	; 0x348e <TM_ShowTags+0x46>
    3488:	0e 94 8d 02 	call	0x51a	; 0x51a <MAIN_WaitForJoyRelease>
    348c:	f3 cf       	rjmp	.-26     	; 0x3474 <TM_ShowTags+0x2c>
    348e:	80 e0       	ldi	r24, 0x00	; 0
    3490:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <DF_EnableDataflash>
    3494:	08 95       	ret

00003496 <__vector_2>:
.global PCINT0_vect             ; Pin change 0 (joystick)
.global PCINT1_vect             ; Pin change 1 (joystick)

PCINT0_vect:
  jmp PCINT1_vect
    3496:	0c 94 b6 02 	jmp	0x56c	; 0x56c <__vector_3>

0000349a <__vector_10>:

.global TIMER0_COMP_vect             ; Timer 0 compare

TIMER0_COMP_vect:
  push r24
    349a:	8f 93       	push	r24
  ldi r24, (USI_CONTROL_REG_FLAGS | (1<<USITC))
    349c:	8b e5       	ldi	r24, 0x5B	; 91
  sts _SFR_MEM_ADDR(USICR), r24
    349e:	80 93 b8 00 	sts	0x00B8, r24
  pop r24
    34a2:	8f 91       	pop	r24
  reti
    34a4:	18 95       	reti

000034a6 <strcpy_P>:
    34a6:	fb 01       	movw	r30, r22
    34a8:	dc 01       	movw	r26, r24
    34aa:	05 90       	lpm	r0, Z+
    34ac:	0d 92       	st	X+, r0
    34ae:	00 20       	and	r0, r0
    34b0:	e1 f7       	brne	.-8      	; 0x34aa <strcpy_P+0x4>
    34b2:	08 95       	ret

000034b4 <ultoa>:
    34b4:	fa 01       	movw	r30, r20
    34b6:	cf 93       	push	r28
    34b8:	ff 93       	push	r31
    34ba:	ef 93       	push	r30
    34bc:	22 30       	cpi	r18, 0x02	; 2
    34be:	cc f0       	brlt	.+50     	; 0x34f2 <ultoa+0x3e>
    34c0:	25 32       	cpi	r18, 0x25	; 37
    34c2:	bc f4       	brge	.+46     	; 0x34f2 <ultoa+0x3e>
    34c4:	c2 2f       	mov	r28, r18
    34c6:	2c 2f       	mov	r18, r28
    34c8:	33 27       	eor	r19, r19
    34ca:	44 27       	eor	r20, r20
    34cc:	55 27       	eor	r21, r21
    34ce:	ff 93       	push	r31
    34d0:	ef 93       	push	r30
    34d2:	0e 94 b7 1a 	call	0x356e	; 0x356e <__udivmodsi4>
    34d6:	ef 91       	pop	r30
    34d8:	ff 91       	pop	r31
    34da:	60 5d       	subi	r22, 0xD0	; 208
    34dc:	6a 33       	cpi	r22, 0x3A	; 58
    34de:	0c f0       	brlt	.+2      	; 0x34e2 <ultoa+0x2e>
    34e0:	69 5d       	subi	r22, 0xD9	; 217
    34e2:	61 93       	st	Z+, r22
    34e4:	b9 01       	movw	r22, r18
    34e6:	ca 01       	movw	r24, r20
    34e8:	60 50       	subi	r22, 0x00	; 0
    34ea:	70 40       	sbci	r23, 0x00	; 0
    34ec:	80 40       	sbci	r24, 0x00	; 0
    34ee:	90 40       	sbci	r25, 0x00	; 0
    34f0:	51 f7       	brne	.-44     	; 0x34c6 <ultoa+0x12>
    34f2:	10 82       	st	Z, r1
    34f4:	8f 91       	pop	r24
    34f6:	9f 91       	pop	r25
    34f8:	cf 91       	pop	r28
    34fa:	0c 94 7f 1a 	jmp	0x34fe	; 0x34fe <strrev>

000034fe <strrev>:
    34fe:	dc 01       	movw	r26, r24
    3500:	fc 01       	movw	r30, r24
    3502:	01 90       	ld	r0, Z+
    3504:	00 20       	and	r0, r0
    3506:	e9 f7       	brne	.-6      	; 0x3502 <strrev+0x4>
    3508:	32 97       	sbiw	r30, 0x02	; 2
    350a:	ae 17       	cp	r26, r30
    350c:	bf 07       	cpc	r27, r31
    350e:	30 f4       	brcc	.+12     	; 0x351c <strrev+0x1e>
    3510:	7c 91       	ld	r23, X
    3512:	60 81       	ld	r22, Z
    3514:	70 83       	st	Z, r23
    3516:	31 97       	sbiw	r30, 0x01	; 1
    3518:	6d 93       	st	X+, r22
    351a:	f7 cf       	rjmp	.-18     	; 0x350a <strrev+0xc>
    351c:	08 95       	ret

0000351e <__eeprom_read_byte_1F2021>:
    351e:	f9 99       	sbic	0x1f, 1	; 31
    3520:	fe cf       	rjmp	.-4      	; 0x351e <__eeprom_read_byte_1F2021>
    3522:	b2 bd       	out	0x22, r27	; 34
    3524:	a1 bd       	out	0x21, r26	; 33
    3526:	f8 9a       	sbi	0x1f, 0	; 31
    3528:	11 96       	adiw	r26, 0x01	; 1
    352a:	00 b4       	in	r0, 0x20	; 32
    352c:	08 95       	ret

0000352e <__eeprom_read_block_1F2021>:
    352e:	f7 df       	rcall	.-18     	; 0x351e <__eeprom_read_byte_1F2021>
    3530:	01 92       	st	Z+, r0
    3532:	1a 94       	dec	r1
    3534:	e1 f7       	brne	.-8      	; 0x352e <__eeprom_read_block_1F2021>
    3536:	08 95       	ret

00003538 <__eeprom_read_word_1F2021>:
    3538:	f2 df       	rcall	.-28     	; 0x351e <__eeprom_read_byte_1F2021>
    353a:	e0 2d       	mov	r30, r0
    353c:	f0 df       	rcall	.-32     	; 0x351e <__eeprom_read_byte_1F2021>
    353e:	f0 2d       	mov	r31, r0
    3540:	08 95       	ret

00003542 <__eeprom_write_byte_1F2021>:
    3542:	f9 99       	sbic	0x1f, 1	; 31
    3544:	fe cf       	rjmp	.-4      	; 0x3542 <__eeprom_write_byte_1F2021>
    3546:	b2 bd       	out	0x22, r27	; 34
    3548:	a1 bd       	out	0x21, r26	; 33
    354a:	00 bc       	out	0x20, r0	; 32
    354c:	11 96       	adiw	r26, 0x01	; 1
    354e:	0f b6       	in	r0, 0x3f	; 63
    3550:	f8 94       	cli
    3552:	fa 9a       	sbi	0x1f, 2	; 31
    3554:	f9 9a       	sbi	0x1f, 1	; 31
    3556:	0f be       	out	0x3f, r0	; 63
    3558:	08 95       	ret

0000355a <__eeprom_write_word_1F2021>:
    355a:	f3 df       	rcall	.-26     	; 0x3542 <__eeprom_write_byte_1F2021>
    355c:	01 2c       	mov	r0, r1
    355e:	f1 df       	rcall	.-30     	; 0x3542 <__eeprom_write_byte_1F2021>
    3560:	11 24       	eor	r1, r1
    3562:	08 95       	ret

00003564 <__eeprom_write_block_1F2021>:
    3564:	01 90       	ld	r0, Z+
    3566:	ed df       	rcall	.-38     	; 0x3542 <__eeprom_write_byte_1F2021>
    3568:	1a 94       	dec	r1
    356a:	e1 f7       	brne	.-8      	; 0x3564 <__eeprom_write_block_1F2021>
    356c:	08 95       	ret

0000356e <__udivmodsi4>:
    356e:	a1 e2       	ldi	r26, 0x21	; 33
    3570:	1a 2e       	mov	r1, r26
    3572:	aa 1b       	sub	r26, r26
    3574:	bb 1b       	sub	r27, r27
    3576:	fd 01       	movw	r30, r26
    3578:	0d c0       	rjmp	.+26     	; 0x3594 <__udivmodsi4_ep>

0000357a <__udivmodsi4_loop>:
    357a:	aa 1f       	adc	r26, r26
    357c:	bb 1f       	adc	r27, r27
    357e:	ee 1f       	adc	r30, r30
    3580:	ff 1f       	adc	r31, r31
    3582:	a2 17       	cp	r26, r18
    3584:	b3 07       	cpc	r27, r19
    3586:	e4 07       	cpc	r30, r20
    3588:	f5 07       	cpc	r31, r21
    358a:	20 f0       	brcs	.+8      	; 0x3594 <__udivmodsi4_ep>
    358c:	a2 1b       	sub	r26, r18
    358e:	b3 0b       	sbc	r27, r19
    3590:	e4 0b       	sbc	r30, r20
    3592:	f5 0b       	sbc	r31, r21

00003594 <__udivmodsi4_ep>:
    3594:	66 1f       	adc	r22, r22
    3596:	77 1f       	adc	r23, r23
    3598:	88 1f       	adc	r24, r24
    359a:	99 1f       	adc	r25, r25
    359c:	1a 94       	dec	r1
    359e:	69 f7       	brne	.-38     	; 0x357a <__udivmodsi4_loop>
    35a0:	60 95       	com	r22
    35a2:	70 95       	com	r23
    35a4:	80 95       	com	r24
    35a6:	90 95       	com	r25
    35a8:	9b 01       	movw	r18, r22
    35aa:	ac 01       	movw	r20, r24
    35ac:	bd 01       	movw	r22, r26
    35ae:	cf 01       	movw	r24, r30
    35b0:	08 95       	ret

000035b2 <_exit>:
    35b2:	ff cf       	rjmp	.-2      	; 0x35b2 <_exit>
